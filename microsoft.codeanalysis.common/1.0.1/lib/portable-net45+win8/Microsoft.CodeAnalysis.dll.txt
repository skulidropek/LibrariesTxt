internal class Microsoft.Cci.AssemblyReferenceAlias : ValueType {
    public string Name;
    public IAssemblyReference Assembly;
    internal AssemblyReferenceAlias(string name, IAssemblyReference assembly);
}
internal class Microsoft.Cci.AsyncMethodBodyDebugInfo : object {
    public IMethodDefinition KickoffMethod;
    public int CatchHandlerOffset;
    public ImmutableArray`1<int> YieldOffsets;
    public ImmutableArray`1<int> ResumeOffsets;
    public AsyncMethodBodyDebugInfo(IMethodDefinition kickoffMethod, int catchHandlerOffset, ImmutableArray`1<int> yieldOffsets, ImmutableArray`1<int> resumeOffsets);
}
internal class Microsoft.Cci.BinaryWriter : ValueType {
    internal MemoryStream BaseStream;
    private bool _utf8;
    public bool IsDefault { get; }
    internal BinaryWriter(MemoryStream output);
    internal BinaryWriter(MemoryStream output, bool unicode);
    public bool get_IsDefault();
    internal void Align(UInt32 alignment);
    internal void WriteBool(bool value);
    internal void WriteByte(byte value);
    internal void Pad(int byteCount);
    internal void WriteSbyte(sbyte value);
    internal void WriteBytes(Byte[] buffer);
    internal void WriteBytes(Byte[] buffer, int offset, int count);
    internal void WriteBytes(ImmutableArray`1<byte> buffer);
    internal void WriteBytes(byte value, int count);
    internal void WriteChars(Char[] chars);
    internal void WriteStringUtf16LE(string str);
    internal void WriteDouble(double value);
    internal void WriteShort(short value);
    internal void WriteUshort(ushort value);
    internal void WriteInt(int value);
    internal void WriteUint(UInt32 value);
    internal void WriteLong(long value);
    internal void WriteUlong(ulong value);
    internal void WriteReference(UInt32 reference, int size);
    internal void WriteFloat(float value);
    internal void WriteString(string str);
    internal void WriteString(string str, bool emitNullTerminator);
    internal void WriteString(string str, Encoding encoding);
    internal void WriteCompressedSignedInteger(int value);
    internal void WriteCompressedUInt(UInt32 val);
    internal static UInt32 GetUTF8ByteCount(string str);
    private static bool IsHighSurrogateCharFollowedByLowSurrogateChar(string str, int index);
    private static bool IsHighSurrogateChar(char ch);
    private static bool IsLowSurrogateChar(char ch);
    public void WriteConstantValueBlob(object value);
}
[FlagsAttribute]
internal enum Microsoft.Cci.CallingConvention : Enum {
    public int value__;
    public static CallingConvention C;
    public static CallingConvention Default;
    public static CallingConvention ExtraArguments;
    public static CallingConvention FastCall;
    public static CallingConvention Standard;
    public static CallingConvention ThisCall;
    public static CallingConvention Generic;
    public static CallingConvention HasThis;
    public static CallingConvention ExplicitThis;
}
internal static class Microsoft.Cci.Constants : object {
    public static CharSet CharSet_None;
    public static CharSet CharSet_Auto;
    public static CallingConvention CallingConvention_FastCall;
    public static UnmanagedType UnmanagedType_CustomMarshaler;
    public static int CompilationRelaxations_NoStringInterning;
    public static SignatureTypeCode SignatureTypeCode_Class;
    public static SignatureTypeCode SignatureTypeCode_ValueType;
}
internal class Microsoft.Cci.ContentId : ValueType {
    public Byte[] Guid;
    public Byte[] Stamp;
    public ContentId(Byte[] guid, Byte[] stamp);
    internal static ContentId FromHash(ImmutableArray`1<byte> hashCode);
}
internal class Microsoft.Cci.COR_FIELD_OFFSET : ValueType {
    public UInt32 RidOfField;
    public UInt32 UlOffset;
    internal COR_FIELD_OFFSET(object dummy);
}
internal class Microsoft.Cci.CorHeader : object {
    internal ushort MajorRuntimeVersion;
    internal ushort MinorRuntimeVersion;
    internal DirectoryEntry MetadataDirectory;
    internal CorFlags Flags;
    internal UInt32 EntryPointToken;
    internal DirectoryEntry Resources;
    internal DirectoryEntry StrongNameSignature;
    internal DirectoryEntry CodeManagerTable;
    internal DirectoryEntry VTableFixups;
    internal DirectoryEntry ExportAddressTableJumps;
}
internal static class Microsoft.Cci.CustomDebugInfoConstants : object {
    internal static int CdiVersion;
    internal static int CdiGlobalHeaderSize;
    internal static int CdiRecordHeaderSize;
    internal static byte CdiKindUsingInfo;
    internal static byte CdiKindForwardInfo;
    internal static byte CdiKindForwardToModuleInfo;
    internal static byte CdiKindStateMachineHoistedLocalScopes;
    internal static byte CdiKindForwardIterator;
    internal static byte CdiKindDynamicLocals;
    internal static byte CdiKindEditAndContinueLocalSlotMap;
    internal static byte CdiKindEditAndContinueLambdaMap;
}
internal class Microsoft.Cci.CustomDebugInfoWriter : object {
    private UInt32 _methodTokenWithModuleInfo;
    private IMethodBody _methodBodyWithModuleInfo;
    private UInt32 _previousMethodTokenWithUsingInfo;
    private IMethodBody _previousMethodBodyWithUsingInfo;
    private PdbWriter _pdbWriter;
    public CustomDebugInfoWriter(PdbWriter pdbWriter);
    public bool ShouldForwardNamespaceScopes(EmitContext context, IMethodBody methodBody, UInt32 methodToken, IMethodDefinition& forwardToMethod);
    public Byte[] SerializeMethodDebugInfo(EmitContext context, IMethodBody methodBody, UInt32 methodToken, bool isEncDelta, bool suppressNewCustomDebugInfo, Boolean& emitExternNamespaces);
    internal static void SerializeCustomDebugInformation(EditAndContinueMethodDebugInformation debugInfo, ArrayBuilder`1<MemoryStream> customDebugInfo);
    private static MemoryStream SerializeRecord(byte kind, Action`1<BinaryWriter> data);
    private static void SerializeIteratorClassMetadata(IMethodBody methodBody, ArrayBuilder`1<MemoryStream> customDebugInfo);
    private static void SerializeReferenceToIteratorClass(string iteratorClassName, ArrayBuilder`1<MemoryStream> customDebugInfo);
    private static void SerializeStateMachineLocalScopes(IMethodBody methodBody, ArrayBuilder`1<MemoryStream> customDebugInfo);
    private static void SerializeDynamicLocalInfo(IMethodBody methodBody, ArrayBuilder`1<MemoryStream> customDebugInfo);
    internal static Byte[] SerializeCustomDebugMetadata(ArrayBuilder`1<MemoryStream> customDebugInfo);
    private void SerializeNamespaceScopeMetadata(EmitContext context, IMethodBody methodBody, ArrayBuilder`1<MemoryStream> customDebugInfo);
    private bool ShouldForwardToPreviousMethodWithUsingInfo(EmitContext context, IMethodBody methodBody);
    private void SerializeReferenceToMethodWithModuleInfo(ArrayBuilder`1<MemoryStream> customDebugInfo);
    private void SerializeReferenceToPreviousMethodWithUsingInfo(ArrayBuilder`1<MemoryStream> customDebugInfo);
}
internal class Microsoft.Cci.DebugSourceDocument : object {
    internal static Guid CorSymLanguageTypeCSharp;
    internal static Guid CorSymLanguageTypeBasic;
    private static Guid s_corSymLanguageVendorMicrosoft;
    private static Guid s_corSymDocumentTypeText;
    private string _location;
    private Guid _language;
    private bool _isComputedChecksum;
    private Task`1<ValueTuple`2<ImmutableArray`1<byte>, Guid>> _checksumAndAlgorithm;
    public Guid DocumentType { get; }
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public string Location { get; }
    public ValueTuple`2<ImmutableArray`1<byte>, Guid> ChecksumAndAlgorithm { get; }
    internal bool IsComputedChecksum { get; }
    public DebugSourceDocument(string location, Guid language);
    public DebugSourceDocument(string location, Guid language, Func`1<ValueTuple`2<ImmutableArray`1<byte>, Guid>> checksumAndAlgorithm);
    public DebugSourceDocument(string location, Guid language, ImmutableArray`1<byte> checksum, Guid algorithm);
    private static DebugSourceDocument();
    internal static bool IsSupportedAlgorithm(SourceHashAlgorithm algorithm);
    internal static bool TryGetAlgorithmGuid(SourceHashAlgorithm algorithm, Guid& guid);
    public Guid get_DocumentType();
    public Guid get_Language();
    public Guid get_LanguageVendor();
    public string get_Location();
    public ValueTuple`2<ImmutableArray`1<byte>, Guid> get_ChecksumAndAlgorithm();
    internal bool get_IsComputedChecksum();
}
internal class Microsoft.Cci.DefinitionWithLocation : ValueType {
    public IDefinition Definition;
    public UInt32 StartLine;
    public UInt32 StartColumn;
    public UInt32 EndLine;
    public UInt32 EndColumn;
    public DefinitionWithLocation(IDefinition definition, int startLine, int startColumn, int endLine, int endColumn);
    public virtual string ToString();
}
internal class Microsoft.Cci.DirectoryEntry : ValueType {
    internal UInt32 RelativeVirtualAddress;
    internal UInt32 Size;
}
internal enum Microsoft.Cci.EncFuncCode : Enum {
    public int value__;
    public static EncFuncCode Default;
    public static EncFuncCode AddMethod;
    public static EncFuncCode AddField;
    public static EncFuncCode AddParameter;
    public static EncFuncCode AddProperty;
    public static EncFuncCode AddEvent;
}
internal abstract class Microsoft.Cci.ExceptionHandlerRegion : object {
    private int _tryStartOffset;
    private int _tryEndOffset;
    private int _handlerStartOffset;
    private int _handlerEndOffset;
    public ExceptionRegionKind HandlerKind { get; }
    public ITypeReference ExceptionType { get; }
    public int FilterDecisionStartOffset { get; }
    public int TryStartOffset { get; }
    public int TryEndOffset { get; }
    public int HandlerStartOffset { get; }
    public int HandlerEndOffset { get; }
    public ExceptionHandlerRegion(int tryStartOffset, int tryEndOffset, int handlerStartOffset, int handlerEndOffset);
    public abstract virtual ExceptionRegionKind get_HandlerKind();
    public virtual ITypeReference get_ExceptionType();
    public virtual int get_FilterDecisionStartOffset();
    public int get_TryStartOffset();
    public int get_TryEndOffset();
    public int get_HandlerStartOffset();
    public int get_HandlerEndOffset();
}
internal class Microsoft.Cci.ExceptionHandlerRegionCatch : ExceptionHandlerRegion {
    private ITypeReference _exceptionType;
    public ExceptionRegionKind HandlerKind { get; }
    public ITypeReference ExceptionType { get; }
    public ExceptionHandlerRegionCatch(int tryStartOffset, int tryEndOffset, int handlerStartOffset, int handlerEndOffset, ITypeReference exceptionType);
    public virtual ExceptionRegionKind get_HandlerKind();
    public virtual ITypeReference get_ExceptionType();
}
internal class Microsoft.Cci.ExceptionHandlerRegionFault : ExceptionHandlerRegion {
    public ExceptionRegionKind HandlerKind { get; }
    public ExceptionHandlerRegionFault(int tryStartOffset, int tryEndOffset, int handlerStartOffset, int handlerEndOffset);
    public virtual ExceptionRegionKind get_HandlerKind();
}
internal class Microsoft.Cci.ExceptionHandlerRegionFilter : ExceptionHandlerRegion {
    private int _filterDecisionStartOffset;
    public ExceptionRegionKind HandlerKind { get; }
    public int FilterDecisionStartOffset { get; }
    public ExceptionHandlerRegionFilter(int tryStartOffset, int tryEndOffset, int handlerStartOffset, int handlerEndOffset, int filterDecisionStartOffset);
    public virtual ExceptionRegionKind get_HandlerKind();
    public virtual int get_FilterDecisionStartOffset();
}
internal class Microsoft.Cci.ExceptionHandlerRegionFinally : ExceptionHandlerRegion {
    public ExceptionRegionKind HandlerKind { get; }
    public ExceptionHandlerRegionFinally(int tryStartOffset, int tryEndOffset, int handlerStartOffset, int handlerEndOffset);
    public virtual ExceptionRegionKind get_HandlerKind();
}
[ExtensionAttribute]
internal static class Microsoft.Cci.Extensions : object {
    [ExtensionAttribute]
internal static bool HasBody(IMethodDefinition methodDef);
}
internal class Microsoft.Cci.FullMetadataWriter : MetadataWriter {
    private DefinitionIndex`1<ITypeDefinition> _typeDefs;
    private DefinitionIndex`1<IEventDefinition> _eventDefs;
    private DefinitionIndex`1<IFieldDefinition> _fieldDefs;
    private DefinitionIndex`1<IMethodDefinition> _methodDefs;
    private DefinitionIndex`1<IPropertyDefinition> _propertyDefs;
    private DefinitionIndex`1<IParameterDefinition> _parameterDefs;
    private DefinitionIndex`1<IGenericParameter> _genericParameters;
    private Dictionary`2<ITypeDefinition, UInt32> _fieldDefIndex;
    private Dictionary`2<ITypeDefinition, UInt32> _methodDefIndex;
    private Dictionary`2<IMethodDefinition, UInt32> _parameterListIndex;
    private HeapOrReferenceIndex`1<IAssemblyReference> _assemblyRefIndex;
    private HeapOrReferenceIndex`1<string> _moduleRefIndex;
    private InstanceAndStructuralReferenceIndex`1<ITypeMemberReference> _memberRefIndex;
    private InstanceAndStructuralReferenceIndex`1<IGenericMethodInstanceReference> _methodSpecIndex;
    private HeapOrReferenceIndex`1<ITypeReference> _typeRefIndex;
    private InstanceAndStructuralReferenceIndex`1<ITypeReference> _typeSpecIndex;
    private HeapOrReferenceIndex`1<UInt32> _standAloneSignatureIndex;
    protected ushort Generation { get; }
    protected Guid EncId { get; }
    protected Guid EncBaseId { get; }
    protected bool CompressMetadataStream { get; }
    private FullMetadataWriter(EmitContext context, MetadataHeapsBuilder heaps, CommonMessageProvider messageProvider, bool allowMissingMethodBodies, bool deterministic, CancellationToken cancellationToken);
    public static MetadataWriter Create(EmitContext context, CommonMessageProvider messageProvider, bool allowMissingMethodBodies, bool deterministic, CancellationToken cancellationToken);
    protected virtual ushort get_Generation();
    protected virtual Guid get_EncId();
    protected virtual Guid get_EncBaseId();
    protected virtual bool get_CompressMetadataStream();
    protected virtual bool TryGetTypeDefIndex(ITypeDefinition def, UInt32& index);
    protected virtual UInt32 GetTypeDefIndex(ITypeDefinition def);
    protected virtual ITypeDefinition GetTypeDef(int index);
    protected virtual IReadOnlyList`1<ITypeDefinition> GetTypeDefs();
    protected virtual UInt32 GetEventDefIndex(IEventDefinition def);
    protected virtual IReadOnlyList`1<IEventDefinition> GetEventDefs();
    protected virtual UInt32 GetFieldDefIndex(IFieldDefinition def);
    protected virtual IReadOnlyList`1<IFieldDefinition> GetFieldDefs();
    protected virtual bool TryGetMethodDefIndex(IMethodDefinition def, UInt32& index);
    protected virtual UInt32 GetMethodDefIndex(IMethodDefinition def);
    protected virtual IMethodDefinition GetMethodDef(int index);
    protected virtual IReadOnlyList`1<IMethodDefinition> GetMethodDefs();
    protected virtual UInt32 GetPropertyDefIndex(IPropertyDefinition def);
    protected virtual IReadOnlyList`1<IPropertyDefinition> GetPropertyDefs();
    protected virtual UInt32 GetParameterDefIndex(IParameterDefinition def);
    protected virtual IReadOnlyList`1<IParameterDefinition> GetParameterDefs();
    protected virtual IReadOnlyList`1<IGenericParameter> GetGenericParameters();
    protected virtual UInt32 GetFieldDefIndex(INamedTypeDefinition typeDef);
    protected virtual UInt32 GetMethodDefIndex(INamedTypeDefinition typeDef);
    protected virtual UInt32 GetParameterDefIndex(IMethodDefinition methodDef);
    protected virtual UInt32 GetOrAddAssemblyRefIndex(IAssemblyReference reference);
    protected virtual IReadOnlyList`1<IAssemblyReference> GetAssemblyRefs();
    protected virtual UInt32 GetOrAddModuleRefIndex(string reference);
    protected virtual IReadOnlyList`1<string> GetModuleRefs();
    protected virtual UInt32 GetOrAddMemberRefIndex(ITypeMemberReference reference);
    protected virtual IReadOnlyList`1<ITypeMemberReference> GetMemberRefs();
    protected virtual UInt32 GetOrAddMethodSpecIndex(IGenericMethodInstanceReference reference);
    protected virtual IReadOnlyList`1<IGenericMethodInstanceReference> GetMethodSpecs();
    protected virtual bool TryGetTypeRefIndex(ITypeReference reference, UInt32& index);
    protected virtual UInt32 GetOrAddTypeRefIndex(ITypeReference reference);
    protected virtual IReadOnlyList`1<ITypeReference> GetTypeRefs();
    protected virtual UInt32 GetOrAddTypeSpecIndex(ITypeReference reference);
    protected virtual IReadOnlyList`1<ITypeReference> GetTypeSpecs();
    protected virtual UInt32 GetOrAddStandAloneSignatureIndex(UInt32 blobIndex);
    protected virtual IReadOnlyList`1<UInt32> GetStandAloneSignatures();
    protected virtual ReferenceIndexer CreateReferenceVisitor();
    protected virtual void ReportReferencesToAddedSymbols();
    protected virtual void PopulateEncLogTableRows(List`1<EncLogRow> table, ImmutableArray`1<int> rowCounts);
    protected virtual void PopulateEncMapTableRows(List`1<EncMapRow> table, ImmutableArray`1<int> rowCounts);
    protected virtual void PopulateEventMapTableRows(List`1<EventMapRow> table);
    protected virtual void PopulatePropertyMapTableRows(List`1<PropertyMapRow> table);
    protected virtual IEnumerable`1<INamespaceTypeDefinition> GetTopLevelTypes(IModule module);
    protected virtual void CreateIndicesForNonTypeMembers(ITypeDefinition typeDef);
    private void CreateIndicesFor(IMethodDefinition methodDef);
}
internal enum Microsoft.Cci.HeapSizeFlag : Enum {
    public byte value__;
    public static HeapSizeFlag StringHeapLarge;
    public static HeapSizeFlag GuidHeapLarge;
    public static HeapSizeFlag BlobHeapLarge;
    public static HeapSizeFlag EnCDeltas;
    public static HeapSizeFlag DeletedMarks;
}
internal interface Microsoft.Cci.IArrayTypeReference {
    public bool IsVector { get; }
    public IEnumerable`1<int> LowerBounds { get; }
    public UInt32 Rank { get; }
    public IEnumerable`1<ulong> Sizes { get; }
    public abstract virtual ITypeReference GetElementType(EmitContext context);
    public abstract virtual bool get_IsVector();
    public abstract virtual IEnumerable`1<int> get_LowerBounds();
    public abstract virtual UInt32 get_Rank();
    public abstract virtual IEnumerable`1<ulong> get_Sizes();
}
internal interface Microsoft.Cci.IAssembly {
    public UInt32 Flags { get; }
    public ImmutableArray`1<byte> PublicKey { get; }
    public string SignatureKey { get; }
    public AssemblyHashAlgorithm HashAlgorithm { get; }
    public abstract virtual IEnumerable`1<IFileReference> GetFiles(EmitContext context);
    public abstract virtual UInt32 get_Flags();
    public abstract virtual ImmutableArray`1<byte> get_PublicKey();
    public abstract virtual string get_SignatureKey();
    public abstract virtual AssemblyHashAlgorithm get_HashAlgorithm();
}
internal interface Microsoft.Cci.IAssemblyReference {
    public string Culture { get; }
    public bool IsRetargetable { get; }
    public AssemblyContentType ContentType { get; }
    public ImmutableArray`1<byte> PublicKeyToken { get; }
    public Version Version { get; }
    public abstract virtual string get_Culture();
    public abstract virtual bool get_IsRetargetable();
    public abstract virtual AssemblyContentType get_ContentType();
    public abstract virtual ImmutableArray`1<byte> get_PublicKeyToken();
    public abstract virtual Version get_Version();
    public abstract virtual string GetDisplayName();
}
internal interface Microsoft.Cci.IContextualNamedEntity {
    public abstract virtual void AssociateWithMetadataWriter(MetadataWriter metadataWriter);
}
internal interface Microsoft.Cci.ICustomAttribute {
    public int ArgumentCount { get; }
    public ushort NamedArgumentCount { get; }
    public bool AllowMultiple { get; }
    public abstract virtual ImmutableArray`1<IMetadataExpression> GetArguments(EmitContext context);
    public abstract virtual IMethodReference Constructor(EmitContext context);
    public abstract virtual ImmutableArray`1<IMetadataNamedArgument> GetNamedArguments(EmitContext context);
    public abstract virtual int get_ArgumentCount();
    public abstract virtual ushort get_NamedArgumentCount();
    public abstract virtual ITypeReference GetType(EmitContext context);
    public abstract virtual bool get_AllowMultiple();
}
internal interface Microsoft.Cci.ICustomModifier {
    public bool IsOptional { get; }
    public abstract virtual bool get_IsOptional();
    public abstract virtual ITypeReference GetModifier(EmitContext context);
}
internal interface Microsoft.Cci.IDefinition {
}
internal interface Microsoft.Cci.IEventDefinition {
    public IEnumerable`1<IMethodReference> Accessors { get; }
    public IMethodReference Adder { get; }
    public IMethodReference Caller { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public IMethodReference Remover { get; }
    public abstract virtual IEnumerable`1<IMethodReference> get_Accessors();
    public abstract virtual IMethodReference get_Adder();
    public abstract virtual IMethodReference get_Caller();
    public abstract virtual bool get_IsRuntimeSpecial();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual IMethodReference get_Remover();
    public abstract virtual ITypeReference GetType(EmitContext context);
}
internal interface Microsoft.Cci.IFieldDefinition {
    public ImmutableArray`1<byte> MappedData { get; }
    public bool IsCompileTimeConstant { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsNotSerialized { get; }
    public bool IsReadOnly { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public ImmutableArray`1<byte> MarshallingDescriptor { get; }
    public UInt32 Offset { get; }
    public abstract virtual IMetadataConstant GetCompileTimeValue(EmitContext context);
    public abstract virtual ImmutableArray`1<byte> get_MappedData();
    public abstract virtual bool get_IsCompileTimeConstant();
    public abstract virtual bool get_IsMarshalledExplicitly();
    public abstract virtual bool get_IsNotSerialized();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsRuntimeSpecial();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsStatic();
    public abstract virtual IMarshallingInformation get_MarshallingInformation();
    public abstract virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    public abstract virtual UInt32 get_Offset();
}
internal interface Microsoft.Cci.IFieldReference {
    public ISpecializedFieldReference AsSpecializedFieldReference { get; }
    public bool IsContextualNamedEntity { get; }
    public abstract virtual ITypeReference GetType(EmitContext context);
    public abstract virtual IFieldDefinition GetResolvedField(EmitContext context);
    public abstract virtual ISpecializedFieldReference get_AsSpecializedFieldReference();
    public abstract virtual bool get_IsContextualNamedEntity();
}
internal interface Microsoft.Cci.IFileReference {
    public bool HasMetadata { get; }
    public string FileName { get; }
    public abstract virtual bool get_HasMetadata();
    public abstract virtual string get_FileName();
    public abstract virtual ImmutableArray`1<byte> GetHashValue(AssemblyHashAlgorithm algorithmId);
}
internal interface Microsoft.Cci.IGenericMethodInstanceReference {
    public abstract virtual IEnumerable`1<ITypeReference> GetGenericArguments(EmitContext context);
    public abstract virtual IMethodReference GetGenericMethod(EmitContext context);
}
internal interface Microsoft.Cci.IGenericMethodParameter {
    public IMethodDefinition DefiningMethod { get; }
    public abstract virtual IMethodDefinition get_DefiningMethod();
}
internal interface Microsoft.Cci.IGenericMethodParameterReference {
    public IMethodReference DefiningMethod { get; }
    public abstract virtual IMethodReference get_DefiningMethod();
}
internal interface Microsoft.Cci.IGenericParameter {
    public bool MustBeReferenceType { get; }
    public bool MustBeValueType { get; }
    public bool MustHaveDefaultConstructor { get; }
    public TypeParameterVariance Variance { get; }
    public IGenericMethodParameter AsGenericMethodParameter { get; }
    public IGenericTypeParameter AsGenericTypeParameter { get; }
    public abstract virtual IEnumerable`1<ITypeReference> GetConstraints(EmitContext context);
    public abstract virtual bool get_MustBeReferenceType();
    public abstract virtual bool get_MustBeValueType();
    public abstract virtual bool get_MustHaveDefaultConstructor();
    public abstract virtual TypeParameterVariance get_Variance();
    public abstract virtual IGenericMethodParameter get_AsGenericMethodParameter();
    public abstract virtual IGenericTypeParameter get_AsGenericTypeParameter();
}
internal interface Microsoft.Cci.IGenericParameterReference {
}
internal interface Microsoft.Cci.IGenericTypeInstanceReference {
    public INamedTypeReference GenericType { get; }
    public abstract virtual ImmutableArray`1<ITypeReference> GetGenericArguments(EmitContext context);
    public abstract virtual INamedTypeReference get_GenericType();
}
internal interface Microsoft.Cci.IGenericTypeParameter {
    public ITypeDefinition DefiningType { get; }
    public abstract virtual ITypeDefinition get_DefiningType();
}
internal interface Microsoft.Cci.IGenericTypeParameterReference {
    public ITypeReference DefiningType { get; }
    public abstract virtual ITypeReference get_DefiningType();
}
internal interface Microsoft.Cci.IGlobalFieldDefinition {
}
internal interface Microsoft.Cci.IGlobalMethodDefinition {
    public string Name { get; }
    public abstract virtual string get_Name();
}
internal interface Microsoft.Cci.IImportScope {
    public IImportScope Parent { get; }
    public abstract virtual ImmutableArray`1<UsedNamespaceOrType> GetUsedNamespaces();
    public abstract virtual IImportScope get_Parent();
}
internal interface Microsoft.Cci.ILocalDefinition {
    public IMetadataConstant CompileTimeValue { get; }
    public ImmutableArray`1<ICustomModifier> CustomModifiers { get; }
    public bool IsPinned { get; }
    public bool IsReference { get; }
    public LocalSlotConstraints Constraints { get; }
    public bool IsDynamic { get; }
    public UInt32 PdbAttributes { get; }
    public ImmutableArray`1<TypedConstant> DynamicTransformFlags { get; }
    public ITypeReference Type { get; }
    public Location Location { get; }
    public int SlotIndex { get; }
    public Byte[] Signature { get; }
    public LocalSlotDebugInfo SlotInfo { get; }
    public abstract virtual IMetadataConstant get_CompileTimeValue();
    public abstract virtual ImmutableArray`1<ICustomModifier> get_CustomModifiers();
    public abstract virtual bool get_IsPinned();
    public abstract virtual bool get_IsReference();
    public abstract virtual LocalSlotConstraints get_Constraints();
    public abstract virtual bool get_IsDynamic();
    public abstract virtual UInt32 get_PdbAttributes();
    public abstract virtual ImmutableArray`1<TypedConstant> get_DynamicTransformFlags();
    public abstract virtual ITypeReference get_Type();
    public abstract virtual Location get_Location();
    public abstract virtual int get_SlotIndex();
    public abstract virtual Byte[] get_Signature();
    public abstract virtual LocalSlotDebugInfo get_SlotInfo();
}
internal class Microsoft.Cci.ImageDebugDirectory : ValueType {
    internal int Characteristics;
    internal int TimeDateStamp;
    internal short MajorVersion;
    internal short MinorVersion;
    internal int Type;
    internal int SizeOfData;
    internal int AddressOfRawData;
    internal int PointerToRawData;
}
internal interface Microsoft.Cci.IManagedPointerTypeReference {
    public abstract virtual ITypeReference GetTargetType(EmitContext context);
}
internal interface Microsoft.Cci.IMarshallingInformation {
    public string CustomMarshallerRuntimeArgument { get; }
    public UnmanagedType ElementType { get; }
    public int IidParameterIndex { get; }
    public UnmanagedType UnmanagedType { get; }
    public int NumberOfElements { get; }
    public short ParamIndex { get; }
    public VarEnum SafeArrayElementSubtype { get; }
    public abstract virtual object GetCustomMarshaller(EmitContext context);
    public abstract virtual string get_CustomMarshallerRuntimeArgument();
    public abstract virtual UnmanagedType get_ElementType();
    public abstract virtual int get_IidParameterIndex();
    public abstract virtual UnmanagedType get_UnmanagedType();
    public abstract virtual int get_NumberOfElements();
    public abstract virtual short get_ParamIndex();
    public abstract virtual VarEnum get_SafeArrayElementSubtype();
    public abstract virtual ITypeReference GetSafeArrayElementUserDefinedSubtype(EmitContext context);
}
internal interface Microsoft.Cci.IMetadataConstant {
    public object Value { get; }
    public abstract virtual object get_Value();
}
internal interface Microsoft.Cci.IMetadataCreateArray {
    public ITypeReference ElementType { get; }
    public IEnumerable`1<IMetadataExpression> Elements { get; }
    public UInt32 ElementCount { get; }
    public abstract virtual ITypeReference get_ElementType();
    public abstract virtual IEnumerable`1<IMetadataExpression> get_Elements();
    public abstract virtual UInt32 get_ElementCount();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("BA3FEE4C-ECB9-4e41-83B7-183FA41CD859")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Cci.IMetaDataEmit {
    public abstract virtual void SetModuleProps(string stringName);
    public abstract virtual void Save(string stringFile, UInt32 dwordSaveFlags);
    public abstract virtual void SaveToStream(Void* pointerIStream, UInt32 dwordSaveFlags);
    public abstract virtual UInt32 GetSaveSize(UInt32 save);
    public abstract virtual UInt32 DefineTypeDef(Char* stringTypeDef, UInt32 dwordTypeDefFlags, UInt32 tokenExtends, UInt32* rtkImplements);
    public abstract virtual UInt32 DefineNestedType(Char* stringTypeDef, UInt32 dwordTypeDefFlags, UInt32 tokenExtends, UInt32* rtkImplements, UInt32 typeDefEncloser);
    public abstract virtual void SetHandler(object pointerUnk);
    public abstract virtual UInt32 DefineMethod(UInt32 td, Char* name, UInt32 dwordMethodFlags, Byte* voidPointerSigBlob, UInt32 byteCountSigBlob, UInt32 ulongCodeRVA, UInt32 dwordImplFlags);
    public abstract virtual void DefineMethodImpl(UInt32 td, UInt32 tokenBody, UInt32 tokenDecl);
    public abstract virtual UInt32 DefineTypeRefByName(UInt32 tokenResolutionScope, Char* stringName);
    public abstract virtual UInt32 DefineImportType(IntPtr pointerAssemImport, Void* bytePointerHashValue, UInt32 byteCountHashValue, IMetaDataImport pointerImport, UInt32 typeDefImport, IntPtr pointerAssemEmit);
    public abstract virtual UInt32 DefineMemberRef(UInt32 tokenImport, string stringName, Byte* voidPointerSigBlob, UInt32 byteCountSigBlob);
    public abstract virtual UInt32 DefineImportMember(IntPtr pointerAssemImport, Void* bytePointerHashValue, UInt32 byteCountHashValue, IMetaDataImport pointerImport, UInt32 member, IntPtr pointerAssemEmit, UInt32 tokenParent);
    public abstract virtual UInt32 DefineEvent(UInt32 td, string stringEvent, UInt32 dwordEventFlags, UInt32 tokenEventType, UInt32 memberDefAddOn, UInt32 memberDefRemoveOn, UInt32 memberDefFire, UInt32* rmdOtherMethods);
    public abstract virtual void SetClassLayout(UInt32 td, UInt32 dwordPackSize, COR_FIELD_OFFSET* arrayFieldOffsets, UInt32 ulongClassSize);
    public abstract virtual void DeleteClassLayout(UInt32 td);
    public abstract virtual void SetFieldMarshal(UInt32 tk, Byte* voidPointerNativeType, UInt32 byteCountNativeType);
    public abstract virtual void DeleteFieldMarshal(UInt32 tk);
    public abstract virtual UInt32 DefinePermissionSet(UInt32 tk, UInt32 dwordAction, Void* voidPointerPermission, UInt32 byteCountPermission);
    public abstract virtual void SetRVA(UInt32 md, UInt32 ulongRVA);
    public abstract virtual UInt32 GetTokenFromSig(Byte* voidPointerSig, UInt32 byteCountSig);
    public abstract virtual UInt32 DefineModuleRef(string stringName);
    public abstract virtual void SetParent(UInt32 mr, UInt32 tk);
    public abstract virtual UInt32 GetTokenFromTypeSpec(Byte* voidPointerSig, UInt32 byteCountSig);
    public abstract virtual void SaveToMemory(Void* bytePointerData, UInt32 byteCountData);
    public abstract virtual UInt32 DefineUserString(string stringString, UInt32 cchString);
    public abstract virtual void DeleteToken(UInt32 tokenObj);
    public abstract virtual void SetMethodProps(UInt32 md, UInt32 dwordMethodFlags, UInt32 ulongCodeRVA, UInt32 dwordImplFlags);
    public abstract virtual void SetTypeDefProps(UInt32 td, UInt32 dwordTypeDefFlags, UInt32 tokenExtends, UInt32* rtkImplements);
    public abstract virtual void SetEventProps(UInt32 ev, UInt32 dwordEventFlags, UInt32 tokenEventType, UInt32 memberDefAddOn, UInt32 memberDefRemoveOn, UInt32 memberDefFire, UInt32* rmdOtherMethods);
    public abstract virtual UInt32 SetPermissionSetProps(UInt32 tk, UInt32 dwordAction, Void* voidPointerPermission, UInt32 byteCountPermission);
    public abstract virtual void DefinePinvokeMap(UInt32 tk, UInt32 dwordMappingFlags, string stringImportName, UInt32 importDLL);
    public abstract virtual void SetPinvokeMap(UInt32 tk, UInt32 dwordMappingFlags, string stringImportName, UInt32 importDLL);
    public abstract virtual void DeletePinvokeMap(UInt32 tk);
    public abstract virtual UInt32 DefineCustomAttribute(UInt32 tokenObj, UInt32 tokenType, Void* pointerCustomAttribute, UInt32 byteCountCustomAttribute);
    public abstract virtual void SetCustomAttributeValue(UInt32 pcv, Void* pointerCustomAttribute, UInt32 byteCountCustomAttribute);
    public abstract virtual UInt32 DefineField(UInt32 td, string stringName, UInt32 dwordFieldFlags, Byte* voidPointerSigBlob, UInt32 byteCountSigBlob, UInt32 dwordCPlusTypeFlag, Void* pointerValue, UInt32 cchValue);
    public abstract virtual UInt32 DefineProperty(UInt32 td, string stringProperty, UInt32 dwordPropFlags, Byte* voidPointerSig, UInt32 byteCountSig, UInt32 dwordCPlusTypeFlag, Void* pointerValue, UInt32 cchValue, UInt32 memberDefSetter, UInt32 memberDefGetter, UInt32* rmdOtherMethods);
    public abstract virtual UInt32 DefineParam(UInt32 md, UInt32 ulongParamSeq, string stringName, UInt32 dwordParamFlags, UInt32 dwordCPlusTypeFlag, Void* pointerValue, UInt32 cchValue);
    public abstract virtual void SetFieldProps(UInt32 fd, UInt32 dwordFieldFlags, UInt32 dwordCPlusTypeFlag, Void* pointerValue, UInt32 cchValue);
    public abstract virtual void SetPropertyProps(UInt32 pr, UInt32 dwordPropFlags, UInt32 dwordCPlusTypeFlag, Void* pointerValue, UInt32 cchValue, UInt32 memberDefSetter, UInt32 memberDefGetter, UInt32* rmdOtherMethods);
    public abstract virtual void SetParamProps(UInt32 pd, string stringName, UInt32 dwordParamFlags, UInt32 dwordCPlusTypeFlag, Void* pointerValue, UInt32 cchValue);
    public abstract virtual UInt32 DefineSecurityAttributeSet(UInt32 tokenObj, IntPtr arraySecAttrs, UInt32 countSecAttrs);
    public abstract virtual void ApplyEditAndContinue(object pointerImport);
    public abstract virtual UInt32 TranslateSigWithScope(IntPtr pointerAssemImport, Void* bytePointerHashValue, UInt32 byteCountHashValue, IMetaDataImport import, Byte* bytePointerSigBlob, UInt32 byteCountSigBlob, IntPtr pointerAssemEmit, IMetaDataEmit emit, Byte* voidPointerTranslatedSig, UInt32 byteCountTranslatedSigMax);
    public abstract virtual void SetMethodImplFlags(UInt32 md, UInt32 dwordImplFlags);
    public abstract virtual void SetFieldRVA(UInt32 fd, UInt32 ulongRVA);
    public abstract virtual void Merge(IMetaDataImport pointerImport, IntPtr pointerHostMapToken, object pointerHandler);
    public abstract virtual void MergeEnd();
}
internal interface Microsoft.Cci.IMetadataExpression {
    public ITypeReference Type { get; }
    public abstract virtual void Dispatch(MetadataVisitor visitor);
    public abstract virtual ITypeReference get_Type();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("7DAC8207-D3AE-4c75-9B67-92801A497D44")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Cci.IMetaDataImport {
    public abstract virtual void CloseEnum(UInt32 handleEnum);
    public abstract virtual UInt32 CountEnum(UInt32 handleEnum);
    public abstract virtual void ResetEnum(UInt32 handleEnum, UInt32 ulongPos);
    public abstract virtual UInt32 EnumTypeDefs(UInt32& handlePointerEnum, UInt32[] arrayTypeDefs, UInt32 countMax);
    public abstract virtual UInt32 EnumInterfaceImpls(UInt32& handlePointerEnum, UInt32 td, UInt32[] arrayImpls, UInt32 countMax);
    public abstract virtual UInt32 EnumTypeRefs(UInt32& handlePointerEnum, UInt32[] arrayTypeRefs, UInt32 countMax);
    public abstract virtual UInt32 FindTypeDefByName(string stringTypeDef, UInt32 tokenEnclosingClass);
    public abstract virtual Guid GetScopeProps(StringBuilder stringName, UInt32 cchName, UInt32& pchName);
    public abstract virtual UInt32 GetModuleFromScope();
    public abstract virtual UInt32 GetTypeDefProps(UInt32 td, IntPtr stringTypeDef, UInt32 cchTypeDef, UInt32& pchTypeDef, IntPtr pdwTypeDefFlags);
    public abstract virtual UInt32 GetInterfaceImplProps(UInt32 impl, UInt32& pointerClass);
    public abstract virtual UInt32 GetTypeRefProps(UInt32 tr, UInt32& ptkResolutionScope, StringBuilder stringName, UInt32 cchName);
    public abstract virtual UInt32 ResolveTypeRef(UInt32 tr, Guid& riid, Object& ppIScope);
    public abstract virtual UInt32 EnumMembers(UInt32& handlePointerEnum, UInt32 cl, UInt32[] arrayMembers, UInt32 countMax);
    public abstract virtual UInt32 EnumMembersWithName(UInt32& handlePointerEnum, UInt32 cl, string stringName, UInt32[] arrayMembers, UInt32 countMax);
    public abstract virtual UInt32 EnumMethods(UInt32& handlePointerEnum, UInt32 cl, UInt32* arrayMethods, UInt32 countMax);
    public abstract virtual UInt32 EnumMethodsWithName(UInt32& handlePointerEnum, UInt32 cl, string stringName, UInt32[] arrayMethods, UInt32 countMax);
    public abstract virtual UInt32 EnumFields(UInt32& handlePointerEnum, UInt32 cl, UInt32* arrayFields, UInt32 countMax);
    public abstract virtual UInt32 EnumFieldsWithName(UInt32& handlePointerEnum, UInt32 cl, string stringName, UInt32[] arrayFields, UInt32 countMax);
    public abstract virtual UInt32 EnumParams(UInt32& handlePointerEnum, UInt32 mb, UInt32[] arrayParams, UInt32 countMax);
    public abstract virtual UInt32 EnumMemberRefs(UInt32& handlePointerEnum, UInt32 tokenParent, UInt32[] arrayMemberRefs, UInt32 countMax);
    public abstract virtual UInt32 EnumMethodImpls(UInt32& handlePointerEnum, UInt32 td, UInt32[] arrayMethodBody, UInt32[] arrayMethodDecl, UInt32 countMax);
    public abstract virtual UInt32 EnumPermissionSets(UInt32& handlePointerEnum, UInt32 tk, UInt32 dwordActions, UInt32[] arrayPermission, UInt32 countMax);
    public abstract virtual UInt32 FindMember(UInt32 td, string stringName, Byte[] voidPointerSigBlob, UInt32 byteCountSigBlob);
    public abstract virtual UInt32 FindMethod(UInt32 td, string stringName, Byte[] voidPointerSigBlob, UInt32 byteCountSigBlob);
    public abstract virtual UInt32 FindField(UInt32 td, string stringName, Byte[] voidPointerSigBlob, UInt32 byteCountSigBlob);
    public abstract virtual UInt32 FindMemberRef(UInt32 td, string stringName, Byte[] voidPointerSigBlob, UInt32 byteCountSigBlob);
    public abstract virtual UInt32 GetMethodProps(UInt32 mb, UInt32& pointerClass, IntPtr stringMethod, UInt32 cchMethod, UInt32& pchMethod, IntPtr pdwAttr, IntPtr ppvSigBlob, IntPtr pcbSigBlob, IntPtr pulCodeRVA);
    public abstract virtual UInt32 GetMemberRefProps(UInt32 mr, UInt32& ptk, StringBuilder stringMember, UInt32 cchMember, UInt32& pchMember, Byte*& ppvSigBlob);
    public abstract virtual UInt32 EnumProperties(UInt32& handlePointerEnum, UInt32 td, UInt32* arrayProperties, UInt32 countMax);
    public abstract virtual UInt32 EnumEvents(UInt32& handlePointerEnum, UInt32 td, UInt32* arrayEvents, UInt32 countMax);
    public abstract virtual UInt32 GetEventProps(UInt32 ev, UInt32& pointerClass, StringBuilder stringEvent, UInt32 cchEvent, UInt32& pchEvent, UInt32& pdwEventFlags, UInt32& ptkEventType, UInt32& pmdAddOn, UInt32& pmdRemoveOn, UInt32& pmdFire, UInt32[] rmdOtherMethod, UInt32 countMax);
    public abstract virtual UInt32 EnumMethodSemantics(UInt32& handlePointerEnum, UInt32 mb, UInt32[] arrayEventProp, UInt32 countMax);
    public abstract virtual UInt32 GetMethodSemantics(UInt32 mb, UInt32 tokenEventProp);
    public abstract virtual UInt32 GetClassLayout(UInt32 td, UInt32& pdwPackSize, COR_FIELD_OFFSET[] arrayFieldOffset, UInt32 countMax, UInt32& countPointerFieldOffset);
    public abstract virtual UInt32 GetFieldMarshal(UInt32 tk, Byte*& ppvNativeType);
    public abstract virtual UInt32 GetRVA(UInt32 tk, UInt32& pulCodeRVA);
    public abstract virtual UInt32 GetPermissionSetProps(UInt32 pm, UInt32& pdwAction, Void*& ppvPermission);
    public abstract virtual UInt32 GetSigFromToken(UInt32 memberDefSig, IntPtr& ppvSig, UInt32& pcbSig);
    public abstract virtual UInt32 GetModuleRefProps(UInt32 mur, StringBuilder stringName, UInt32 cchName);
    public abstract virtual UInt32 EnumModuleRefs(UInt32& handlePointerEnum, UInt32[] arrayModuleRefs, UInt32 cmax);
    public abstract virtual UInt32 GetTypeSpecFromToken(UInt32 typespec, Byte*& ppvSig);
    public abstract virtual UInt32 GetNameFromToken(UInt32 tk);
    public abstract virtual UInt32 EnumUnresolvedMethods(UInt32& handlePointerEnum, UInt32[] arrayMethods, UInt32 countMax);
    public abstract virtual UInt32 GetUserString(UInt32 stk, StringBuilder stringString, UInt32 cchString);
    public abstract virtual UInt32 GetPinvokeMap(UInt32 tk, UInt32& pdwMappingFlags, StringBuilder stringImportName, UInt32 cchImportName, UInt32& pchImportName);
    public abstract virtual UInt32 EnumSignatures(UInt32& handlePointerEnum, UInt32[] arraySignatures, UInt32 cmax);
    public abstract virtual UInt32 EnumTypeSpecs(UInt32& handlePointerEnum, UInt32[] arrayTypeSpecs, UInt32 cmax);
    public abstract virtual UInt32 EnumUserStrings(UInt32& handlePointerEnum, UInt32[] arrayStrings, UInt32 cmax);
    public abstract virtual int GetParamForMethodIndex(UInt32 md, UInt32 ulongParamSeq, UInt32& pointerParam);
    public abstract virtual UInt32 EnumCustomAttributes(UInt32& handlePointerEnum, UInt32 tk, UInt32 tokenType, UInt32[] arrayCustomAttributes, UInt32 countMax);
    public abstract virtual UInt32 GetCustomAttributeProps(UInt32 cv, UInt32& ptkObj, UInt32& ptkType, Void*& ppBlob);
    public abstract virtual UInt32 FindTypeRef(UInt32 tokenResolutionScope, string stringName);
    public abstract virtual UInt32 GetMemberProps(UInt32 mb, UInt32& pointerClass, StringBuilder stringMember, UInt32 cchMember, UInt32& pchMember, UInt32& pdwAttr, Byte*& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pulCodeRVA, UInt32& pdwImplFlags, UInt32& pdwCPlusTypeFlag, Void*& ppValue);
    public abstract virtual UInt32 GetFieldProps(UInt32 mb, UInt32& pointerClass, StringBuilder stringField, UInt32 cchField, UInt32& pchField, UInt32& pdwAttr, Byte*& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pdwCPlusTypeFlag, Void*& ppValue);
    public abstract virtual UInt32 GetPropertyProps(UInt32 prop, UInt32& pointerClass, StringBuilder stringProperty, UInt32 cchProperty, UInt32& pchProperty, UInt32& pdwPropFlags, Byte*& ppvSig, UInt32& bytePointerSig, UInt32& pdwCPlusTypeFlag, Void*& ppDefaultValue, UInt32& pcchDefaultValue, UInt32& pmdSetter, UInt32& pmdGetter, UInt32[] rmdOtherMethod, UInt32 countMax);
    public abstract virtual UInt32 GetParamProps(UInt32 tk, UInt32& pmd, UInt32& pulSequence, StringBuilder stringName, UInt32 cchName, UInt32& pchName, UInt32& pdwAttr, UInt32& pdwCPlusTypeFlag, Void*& ppValue);
    public abstract virtual UInt32 GetCustomAttributeByName(UInt32 tokenObj, string stringName, Void*& ppData);
    public abstract virtual bool IsValidToken(UInt32 tk);
    public abstract virtual UInt32 GetNestedClassProps(UInt32 typeDefNestedClass);
    public abstract virtual UInt32 GetNativeCallConvFromSig(Void* voidPointerSig, UInt32 byteCountSig);
    public abstract virtual int IsGlobal(UInt32 pd);
}
internal interface Microsoft.Cci.IMetadataNamedArgument {
    public string ArgumentName { get; }
    public IMetadataExpression ArgumentValue { get; }
    public bool IsField { get; }
    public abstract virtual string get_ArgumentName();
    public abstract virtual IMetadataExpression get_ArgumentValue();
    public abstract virtual bool get_IsField();
}
internal interface Microsoft.Cci.IMetadataTypeOf {
    public ITypeReference TypeToGet { get; }
    public abstract virtual ITypeReference get_TypeToGet();
}
internal interface Microsoft.Cci.IMethodBody {
    public ImmutableArray`1<ExceptionHandlerRegion> ExceptionRegions { get; }
    public bool LocalsAreZeroed { get; }
    public ImmutableArray`1<ILocalDefinition> LocalVariables { get; }
    public IMethodDefinition MethodDefinition { get; }
    public AsyncMethodBodyDebugInfo AsyncDebugInfo { get; }
    public ushort MaxStack { get; }
    public Byte[] IL { get; }
    public bool HasAnySequencePoints { get; }
    public bool HasDynamicLocalVariables { get; }
    public ImmutableArray`1<LocalScope> LocalScopes { get; }
    public IImportScope ImportScope { get; }
    public DebugId MethodId { get; }
    public ImmutableArray`1<StateMachineHoistedLocalScope> StateMachineHoistedLocalScopes { get; }
    public string StateMachineTypeName { get; }
    public ImmutableArray`1<EncHoistedLocalInfo> StateMachineHoistedLocalSlots { get; }
    public ImmutableArray`1<ITypeReference> StateMachineAwaiterSlots { get; }
    public ImmutableArray`1<ClosureDebugInfo> ClosureDebugInfo { get; }
    public ImmutableArray`1<LambdaDebugInfo> LambdaDebugInfo { get; }
    public abstract virtual void Dispatch(MetadataVisitor visitor);
    public abstract virtual ImmutableArray`1<ExceptionHandlerRegion> get_ExceptionRegions();
    public abstract virtual bool get_LocalsAreZeroed();
    public abstract virtual ImmutableArray`1<ILocalDefinition> get_LocalVariables();
    public abstract virtual IMethodDefinition get_MethodDefinition();
    public abstract virtual AsyncMethodBodyDebugInfo get_AsyncDebugInfo();
    public abstract virtual ushort get_MaxStack();
    public abstract virtual Byte[] get_IL();
    public abstract virtual bool get_HasAnySequencePoints();
    public abstract virtual ImmutableArray`1<SequencePoint> GetSequencePoints();
    public abstract virtual ImmutableArray`1<SequencePoint> GetLocations();
    public abstract virtual bool get_HasDynamicLocalVariables();
    public abstract virtual ImmutableArray`1<LocalScope> get_LocalScopes();
    public abstract virtual IImportScope get_ImportScope();
    public abstract virtual DebugId get_MethodId();
    public abstract virtual ImmutableArray`1<StateMachineHoistedLocalScope> get_StateMachineHoistedLocalScopes();
    public abstract virtual string get_StateMachineTypeName();
    public abstract virtual ImmutableArray`1<EncHoistedLocalInfo> get_StateMachineHoistedLocalSlots();
    public abstract virtual ImmutableArray`1<ITypeReference> get_StateMachineAwaiterSlots();
    public abstract virtual ImmutableArray`1<ClosureDebugInfo> get_ClosureDebugInfo();
    public abstract virtual ImmutableArray`1<LambdaDebugInfo> get_LambdaDebugInfo();
}
internal interface Microsoft.Cci.IMethodDefinition {
    public IEnumerable`1<IGenericMethodParameter> GenericParameters { get; }
    public bool IsImplicitlyDeclared { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool IsAbstract { get; }
    public bool IsAccessCheckedOnOverride { get; }
    public bool IsConstructor { get; }
    public bool IsExternal { get; }
    public bool IsHiddenBySignature { get; }
    public bool IsNewSlot { get; }
    public bool IsPlatformInvoke { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSealed { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public ImmutableArray`1<IParameterDefinition> Parameters { get; }
    public IPlatformInvokeInformation PlatformInvokeData { get; }
    public bool RequiresSecurityObject { get; }
    public IEnumerable`1<ICustomAttribute> ReturnValueAttributes { get; }
    public bool ReturnValueIsMarshalledExplicitly { get; }
    public IMarshallingInformation ReturnValueMarshallingInformation { get; }
    public ImmutableArray`1<byte> ReturnValueMarshallingDescriptor { get; }
    public IEnumerable`1<SecurityAttribute> SecurityAttributes { get; }
    public INamespace ContainingNamespace { get; }
    public abstract virtual IMethodBody GetBody(EmitContext context);
    public abstract virtual IEnumerable`1<IGenericMethodParameter> get_GenericParameters();
    public abstract virtual bool get_IsImplicitlyDeclared();
    public abstract virtual bool get_HasDeclarativeSecurity();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsAccessCheckedOnOverride();
    public abstract virtual bool get_IsConstructor();
    public abstract virtual bool get_IsExternal();
    public abstract virtual bool get_IsHiddenBySignature();
    public abstract virtual bool get_IsNewSlot();
    public abstract virtual bool get_IsPlatformInvoke();
    public abstract virtual bool get_IsRuntimeSpecial();
    public abstract virtual bool get_IsSealed();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsVirtual();
    public abstract virtual MethodImplAttributes GetImplementationAttributes(EmitContext context);
    public abstract virtual ImmutableArray`1<IParameterDefinition> get_Parameters();
    public abstract virtual IPlatformInvokeInformation get_PlatformInvokeData();
    public abstract virtual bool get_RequiresSecurityObject();
    public abstract virtual IEnumerable`1<ICustomAttribute> get_ReturnValueAttributes();
    public abstract virtual bool get_ReturnValueIsMarshalledExplicitly();
    public abstract virtual IMarshallingInformation get_ReturnValueMarshallingInformation();
    public abstract virtual ImmutableArray`1<byte> get_ReturnValueMarshallingDescriptor();
    public abstract virtual IEnumerable`1<SecurityAttribute> get_SecurityAttributes();
    public abstract virtual INamespace get_ContainingNamespace();
}
internal interface Microsoft.Cci.IMethodReference {
    public bool AcceptsExtraArguments { get; }
    public ushort GenericParameterCount { get; }
    public bool IsGeneric { get; }
    public ImmutableArray`1<IParameterTypeInformation> ExtraParameters { get; }
    public IGenericMethodInstanceReference AsGenericMethodInstanceReference { get; }
    public ISpecializedMethodReference AsSpecializedMethodReference { get; }
    public abstract virtual bool get_AcceptsExtraArguments();
    public abstract virtual ushort get_GenericParameterCount();
    public abstract virtual bool get_IsGeneric();
    public abstract virtual IMethodDefinition GetResolvedMethod(EmitContext context);
    public abstract virtual ImmutableArray`1<IParameterTypeInformation> get_ExtraParameters();
    public abstract virtual IGenericMethodInstanceReference get_AsGenericMethodInstanceReference();
    public abstract virtual ISpecializedMethodReference get_AsSpecializedMethodReference();
}
internal interface Microsoft.Cci.IModifiedTypeReference {
    public ImmutableArray`1<ICustomModifier> CustomModifiers { get; }
    public ITypeReference UnmodifiedType { get; }
    public abstract virtual ImmutableArray`1<ICustomModifier> get_CustomModifiers();
    public abstract virtual ITypeReference get_UnmodifiedType();
}
internal interface Microsoft.Cci.IModule {
    public bool GenerateVisualBasicStylePdb { get; }
    public IEnumerable`1<ICustomAttribute> AssemblyAttributes { get; }
    public IEnumerable`1<SecurityAttribute> AssemblySecurityAttributes { get; }
    public ulong BaseAddress { get; }
    public ushort DllCharacteristics { get; }
    public IMethodReference EntryPoint { get; }
    public UInt32 FileAlignment { get; }
    public bool ILOnly { get; }
    public ModuleKind Kind { get; }
    public byte LinkerMajorVersion { get; }
    public byte LinkerMinorVersion { get; }
    public Machine Machine { get; }
    public byte MetadataFormatMajorVersion { get; }
    public byte MetadataFormatMinorVersion { get; }
    public IEnumerable`1<ICustomAttribute> ModuleAttributes { get; }
    public string ModuleName { get; }
    public IEnumerable`1<IModuleReference> ModuleReferences { get; }
    public Guid PersistentIdentifier { get; }
    public bool StrongNameSigned { get; }
    public bool RequiresAmdInstructionSet { get; }
    public bool RequiresStartupStub { get; }
    public bool Requires32bits { get; }
    public bool Prefers32bits { get; }
    public bool Requires64bits { get; }
    public ulong SizeOfHeapCommit { get; }
    public ulong SizeOfHeapReserve { get; }
    public ulong SizeOfStackCommit { get; }
    public ulong SizeOfStackReserve { get; }
    public string TargetRuntimeVersion { get; }
    public bool TrackDebugData { get; }
    public IEnumerable`1<IWin32Resource> Win32Resources { get; }
    public ResourceSection Win32ResourceSection { get; }
    public IAssembly AsAssembly { get; }
    public IEnumerable`1<string> LinkedAssembliesDebugInfo { get; }
    public string DefaultNamespace { get; }
    public ushort MajorSubsystemVersion { get; }
    public ushort MinorSubsystemVersion { get; }
    public int HintNumberOfMethodDefinitions { get; }
    public abstract virtual bool get_GenerateVisualBasicStylePdb();
    public abstract virtual IEnumerable`1<ITypeExport> GetExportedTypes(EmitContext context);
    public abstract virtual IEnumerable`1<ICustomAttribute> get_AssemblyAttributes();
    public abstract virtual IEnumerable`1<SecurityAttribute> get_AssemblySecurityAttributes();
    public abstract virtual IEnumerable`1<IAssemblyReference> GetAssemblyReferences(EmitContext context);
    public abstract virtual IEnumerable`1<ManagedResource> GetResources(EmitContext context);
    public abstract virtual IAssemblyReference GetCorLibrary(EmitContext context);
    public abstract virtual ulong get_BaseAddress();
    public abstract virtual IAssembly GetContainingAssembly(EmitContext context);
    public abstract virtual ushort get_DllCharacteristics();
    public abstract virtual IMethodReference get_EntryPoint();
    public abstract virtual UInt32 get_FileAlignment();
    public abstract virtual IEnumerable`1<string> GetStrings();
    public abstract virtual IEnumerable`1<INamespaceTypeDefinition> GetTopLevelTypes(EmitContext context);
    public abstract virtual bool get_ILOnly();
    public abstract virtual ModuleKind get_Kind();
    public abstract virtual byte get_LinkerMajorVersion();
    public abstract virtual byte get_LinkerMinorVersion();
    public abstract virtual Machine get_Machine();
    public abstract virtual byte get_MetadataFormatMajorVersion();
    public abstract virtual byte get_MetadataFormatMinorVersion();
    public abstract virtual IEnumerable`1<ICustomAttribute> get_ModuleAttributes();
    public abstract virtual string get_ModuleName();
    public abstract virtual IEnumerable`1<IModuleReference> get_ModuleReferences();
    public abstract virtual Guid get_PersistentIdentifier();
    public abstract virtual bool get_StrongNameSigned();
    public abstract virtual bool get_RequiresAmdInstructionSet();
    public abstract virtual bool get_RequiresStartupStub();
    public abstract virtual bool get_Requires32bits();
    public abstract virtual bool get_Prefers32bits();
    public abstract virtual bool get_Requires64bits();
    public abstract virtual ulong get_SizeOfHeapCommit();
    public abstract virtual ulong get_SizeOfHeapReserve();
    public abstract virtual ulong get_SizeOfStackCommit();
    public abstract virtual ulong get_SizeOfStackReserve();
    public abstract virtual string get_TargetRuntimeVersion();
    public abstract virtual bool get_TrackDebugData();
    public abstract virtual IEnumerable`1<IWin32Resource> get_Win32Resources();
    public abstract virtual ResourceSection get_Win32ResourceSection();
    public abstract virtual IAssembly get_AsAssembly();
    public abstract virtual ITypeReference GetPlatformType(PlatformType t, EmitContext context);
    public abstract virtual bool IsPlatformType(ITypeReference typeRef, PlatformType t);
    public abstract virtual IEnumerable`1<IReference> ReferencesInIL(Int32& count);
    public abstract virtual MultiDictionary`2<DebugSourceDocument, DefinitionWithLocation> GetSymbolToLocationMap();
    public abstract virtual ImmutableArray`1<AssemblyReferenceAlias> GetAssemblyReferenceAliases(EmitContext context);
    public abstract virtual IEnumerable`1<string> get_LinkedAssembliesDebugInfo();
    public abstract virtual ImmutableArray`1<UsedNamespaceOrType> GetImports();
    public abstract virtual string get_DefaultNamespace();
    public abstract virtual ushort get_MajorSubsystemVersion();
    public abstract virtual ushort get_MinorSubsystemVersion();
    public abstract virtual int get_HintNumberOfMethodDefinitions();
}
internal interface Microsoft.Cci.IModuleReference {
    public abstract virtual IAssemblyReference GetContainingAssembly(EmitContext context);
}
internal interface Microsoft.Cci.INamedEntity {
    public string Name { get; }
    public abstract virtual string get_Name();
}
internal interface Microsoft.Cci.INamedTypeDefinition {
}
internal interface Microsoft.Cci.INamedTypeReference {
    public ushort GenericParameterCount { get; }
    public bool MangleName { get; }
    public abstract virtual ushort get_GenericParameterCount();
    public abstract virtual bool get_MangleName();
}
internal interface Microsoft.Cci.INamespace {
    public INamespace ContainingNamespace { get; }
    public abstract virtual INamespace get_ContainingNamespace();
}
internal interface Microsoft.Cci.INamespaceTypeDefinition {
    public bool IsPublic { get; }
    public abstract virtual bool get_IsPublic();
}
internal interface Microsoft.Cci.INamespaceTypeReference {
    public string NamespaceName { get; }
    public abstract virtual IUnitReference GetUnit(EmitContext context);
    public abstract virtual string get_NamespaceName();
}
internal interface Microsoft.Cci.INestedTypeDefinition {
}
internal interface Microsoft.Cci.INestedTypeReference {
}
internal class Microsoft.Cci.InheritedTypeParameter : object {
    private ushort _index;
    private ITypeDefinition _inheritingType;
    private IGenericTypeParameter _parentParameter;
    public ITypeDefinition DefiningType { get; }
    public bool MustBeReferenceType { get; }
    public bool MustBeValueType { get; }
    public bool MustHaveDefaultConstructor { get; }
    public TypeParameterVariance Variance { get; }
    public ushort Alignment { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool IsEnum { get; }
    public IArrayTypeReference AsArrayTypeReference { get; }
    public IGenericMethodParameter AsGenericMethodParameter { get; }
    public IGenericMethodParameterReference AsGenericMethodParameterReference { get; }
    public IGenericTypeInstanceReference AsGenericTypeInstanceReference { get; }
    public IGenericTypeParameter AsGenericTypeParameter { get; }
    public IGenericTypeParameterReference AsGenericTypeParameterReference { get; }
    public INamespaceTypeReference AsNamespaceTypeReference { get; }
    public INestedTypeReference AsNestedTypeReference { get; }
    public ISpecializedNestedTypeReference AsSpecializedNestedTypeReference { get; }
    public IModifiedTypeReference AsModifiedTypeReference { get; }
    public IPointerTypeReference AsPointerTypeReference { get; }
    public IManagedPointerTypeReference AsManagedPointerTypeReference { get; }
    public TypeDefinitionHandle TypeDef { get; }
    public bool IsAlias { get; }
    public bool IsValueType { get; }
    public ushort Index { get; }
    public string Name { get; }
    private ITypeReference Microsoft.Cci.IGenericTypeParameterReference.DefiningType { get; }
    public bool MangleName { get; }
    public bool IsNested { get; }
    public bool IsSpecializedNested { get; }
    public ITypeReference UnspecializedVersion { get; }
    public bool IsNamespaceTypeReference { get; }
    public bool IsGenericTypeInstance { get; }
    internal InheritedTypeParameter(ushort index, ITypeDefinition inheritingType, IGenericTypeParameter parentParameter);
    public sealed virtual ITypeDefinition get_DefiningType();
    public sealed virtual IEnumerable`1<ITypeReference> GetConstraints(EmitContext context);
    public sealed virtual bool get_MustBeReferenceType();
    public sealed virtual bool get_MustBeValueType();
    public sealed virtual bool get_MustHaveDefaultConstructor();
    public sealed virtual TypeParameterVariance get_Variance();
    public ushort get_Alignment();
    public bool get_HasDeclarativeSecurity();
    public sealed virtual bool get_IsEnum();
    public IArrayTypeReference get_AsArrayTypeReference();
    public sealed virtual IGenericMethodParameter get_AsGenericMethodParameter();
    public sealed virtual IGenericMethodParameterReference get_AsGenericMethodParameterReference();
    public sealed virtual IGenericTypeInstanceReference get_AsGenericTypeInstanceReference();
    public sealed virtual IGenericTypeParameter get_AsGenericTypeParameter();
    public sealed virtual IGenericTypeParameterReference get_AsGenericTypeParameterReference();
    public sealed virtual INamespaceTypeDefinition AsNamespaceTypeDefinition(EmitContext context);
    public sealed virtual INamespaceTypeReference get_AsNamespaceTypeReference();
    public sealed virtual INestedTypeDefinition AsNestedTypeDefinition(EmitContext context);
    public sealed virtual INestedTypeReference get_AsNestedTypeReference();
    public sealed virtual ISpecializedNestedTypeReference get_AsSpecializedNestedTypeReference();
    public IModifiedTypeReference get_AsModifiedTypeReference();
    public IPointerTypeReference get_AsPointerTypeReference();
    public IManagedPointerTypeReference get_AsManagedPointerTypeReference();
    public sealed virtual ITypeDefinition AsTypeDefinition(EmitContext context);
    public sealed virtual IDefinition AsDefinition(EmitContext context);
    public sealed virtual IEnumerable`1<ICustomAttribute> GetAttributes(EmitContext context);
    public sealed virtual void Dispatch(MetadataVisitor visitor);
    public sealed virtual TypeDefinitionHandle get_TypeDef();
    public bool get_IsAlias();
    public sealed virtual bool get_IsValueType();
    public sealed virtual ITypeDefinition GetResolvedType(EmitContext context);
    public sealed virtual PrimitiveTypeCode TypeCode(EmitContext context);
    public sealed virtual ushort get_Index();
    public sealed virtual string get_Name();
    private sealed virtual override ITypeReference Microsoft.Cci.IGenericTypeParameterReference.get_DefiningType();
    public bool get_MangleName();
    public bool get_IsNested();
    public bool get_IsSpecializedNested();
    public ITypeReference get_UnspecializedVersion();
    public bool get_IsNamespaceTypeReference();
    public bool get_IsGenericTypeInstance();
}
internal static class Microsoft.Cci.InstructionOperandTypes : object {
    internal static Byte[] OneByte;
    internal static Byte[] TwoByte;
    private static InstructionOperandTypes();
    internal static OperandType ReadOperandType(Byte[] il, Int32& position);
}
internal interface Microsoft.Cci.IParameterDefinition {
    public bool HasDefaultValue { get; }
    public bool IsIn { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public ImmutableArray`1<byte> MarshallingDescriptor { get; }
    public abstract virtual IMetadataConstant GetDefaultValue(EmitContext context);
    public abstract virtual bool get_HasDefaultValue();
    public abstract virtual bool get_IsIn();
    public abstract virtual bool get_IsMarshalledExplicitly();
    public abstract virtual bool get_IsOptional();
    public abstract virtual bool get_IsOut();
    public abstract virtual IMarshallingInformation get_MarshallingInformation();
    public abstract virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
}
internal interface Microsoft.Cci.IParameterListEntry {
    public ushort Index { get; }
    public abstract virtual ushort get_Index();
}
internal interface Microsoft.Cci.IParameterTypeInformation {
    public ImmutableArray`1<ICustomModifier> CustomModifiers { get; }
    public bool IsByReference { get; }
    public bool HasByRefBeforeCustomModifiers { get; }
    public abstract virtual ImmutableArray`1<ICustomModifier> get_CustomModifiers();
    public abstract virtual bool get_IsByReference();
    public abstract virtual bool get_HasByRefBeforeCustomModifiers();
    public abstract virtual ITypeReference GetType(EmitContext context);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("98ECEE1E-752D-11d3-8D56-00C04F680B2B")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Cci.IPdbWriter {
    public abstract virtual int __SetPath();
    public abstract virtual int __OpenMod();
    public abstract virtual int __CloseMod();
    public abstract virtual int __GetPath();
    public abstract virtual void GetSignatureAge(UInt32& sig, UInt32& age);
}
internal interface Microsoft.Cci.IPlatformInvokeInformation {
    public string ModuleName { get; }
    public string EntryPointName { get; }
    public PInvokeAttributes Flags { get; }
    public abstract virtual string get_ModuleName();
    public abstract virtual string get_EntryPointName();
    public abstract virtual PInvokeAttributes get_Flags();
}
internal interface Microsoft.Cci.IPointerTypeReference {
    public abstract virtual ITypeReference GetTargetType(EmitContext context);
}
internal interface Microsoft.Cci.IPropertyDefinition {
    public IEnumerable`1<IMethodReference> Accessors { get; }
    public IMetadataConstant DefaultValue { get; }
    public IMethodReference Getter { get; }
    public bool HasDefaultValue { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public ImmutableArray`1<IParameterDefinition> Parameters { get; }
    public IMethodReference Setter { get; }
    public abstract virtual IEnumerable`1<IMethodReference> get_Accessors();
    public abstract virtual IMetadataConstant get_DefaultValue();
    public abstract virtual IMethodReference get_Getter();
    public abstract virtual bool get_HasDefaultValue();
    public abstract virtual bool get_IsRuntimeSpecial();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual ImmutableArray`1<IParameterDefinition> get_Parameters();
    public abstract virtual IMethodReference get_Setter();
}
internal interface Microsoft.Cci.IReference {
    public abstract virtual IEnumerable`1<ICustomAttribute> GetAttributes(EmitContext context);
    public abstract virtual void Dispatch(MetadataVisitor visitor);
    public abstract virtual IDefinition AsDefinition(EmitContext context);
}
internal interface Microsoft.Cci.ISignature {
    public CallingConvention CallingConvention { get; }
    public ushort ParameterCount { get; }
    public ImmutableArray`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public abstract virtual CallingConvention get_CallingConvention();
    public abstract virtual ushort get_ParameterCount();
    public abstract virtual ImmutableArray`1<IParameterTypeInformation> GetParameters(EmitContext context);
    public abstract virtual ImmutableArray`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public abstract virtual bool get_ReturnValueIsByRef();
    public abstract virtual ITypeReference GetType(EmitContext context);
}
internal interface Microsoft.Cci.ISpecializedEventDefinition {
    public IEventDefinition UnspecializedVersion { get; }
    public abstract virtual IEventDefinition get_UnspecializedVersion();
}
internal interface Microsoft.Cci.ISpecializedFieldReference {
    public IFieldReference UnspecializedVersion { get; }
    public abstract virtual IFieldReference get_UnspecializedVersion();
}
internal interface Microsoft.Cci.ISpecializedMethodReference {
    public IMethodReference UnspecializedVersion { get; }
    public abstract virtual IMethodReference get_UnspecializedVersion();
}
internal interface Microsoft.Cci.ISpecializedNestedTypeReference {
    public INestedTypeReference UnspecializedVersion { get; }
    public abstract virtual INestedTypeReference get_UnspecializedVersion();
}
internal interface Microsoft.Cci.ISpecializedPropertyDefinition {
    public IPropertyDefinition UnspecializedVersion { get; }
    public abstract virtual IPropertyDefinition get_UnspecializedVersion();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("FC073774-1739-4232-BD56-A027294BEC15")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Cci.ISymUnmanagedAsyncMethodPropertiesWriter {
    public abstract virtual void DefineKickoffMethod(UInt32 kickoffMethod);
    public abstract virtual void DefineCatchHandlerILOffset(UInt32 catchHandlerOffset);
    public abstract virtual void DefineAsyncStepInfo(UInt32 count, UInt32[] yieldOffsets, UInt32[] breakpointOffset, UInt32[] breakpointMethod);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B01FAFEB-C450-3A4D-BEEC-B4CEEC01E006")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Cci.ISymUnmanagedDocumentWriter {
    public abstract virtual void SetSource(UInt32 sourceSize, Byte[] source);
    public abstract virtual void SetCheckSum(Guid algorithmId, UInt32 checkSumSize, Byte[] checkSum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("0B97726E-9E6D-4f05-9A26-424022093CAA")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Cci.ISymUnmanagedWriter2 {
    public abstract virtual ISymUnmanagedDocumentWriter DefineDocument(string url, Guid& language, Guid& languageVendor, Guid& documentType);
    public abstract virtual void SetUserEntryPoint(UInt32 entryMethod);
    public abstract virtual void OpenMethod(UInt32 method);
    public abstract virtual void CloseMethod();
    public abstract virtual UInt32 OpenScope(UInt32 startOffset);
    public abstract virtual void CloseScope(UInt32 endOffset);
    public abstract virtual void SetScopeRange(UInt32 scopeID, UInt32 startOffset, UInt32 endOffset);
    public abstract virtual void DefineLocalVariable(string name, UInt32 attributes, UInt32 sig, IntPtr signature, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 startOffset, UInt32 endOffset);
    public abstract virtual void DefineParameter(string name, UInt32 attributes, UInt32 sequence, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3);
    public abstract virtual void DefineField(UInt32 parent, string name, UInt32 attributes, UInt32 sig, IntPtr signature, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3);
    public abstract virtual void DefineGlobalVariable(string name, UInt32 attributes, UInt32 sig, IntPtr signature, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3);
    public abstract virtual void Close();
    public abstract virtual void SetSymAttribute(UInt32 parent, string name, UInt32 data, IntPtr signature);
    public abstract virtual void OpenNamespace(string name);
    public abstract virtual void CloseNamespace();
    public abstract virtual void UsingNamespace(string fullName);
    public abstract virtual void SetMethodSourceRange(ISymUnmanagedDocumentWriter startDoc, UInt32 startLine, UInt32 startColumn, object endDoc, UInt32 endLine, UInt32 endColumn);
    public abstract virtual void Initialize(object emitter, string filename, object ptrIStream, bool fullBuild);
    public abstract virtual void GetDebugInfo(ImageDebugDirectory& ptrIDD, UInt32 dataCount, UInt32& dataCountPtr, IntPtr data);
    public abstract virtual void DefineSequencePoints(ISymUnmanagedDocumentWriter document, UInt32 count, UInt32[] offsets, UInt32[] lines, UInt32[] columns, UInt32[] endLines, UInt32[] endColumns);
    public abstract virtual void RemapToken(UInt32 oldToken, UInt32 newToken);
    public abstract virtual void Initialize2(object emitter, string tempfilename, object ptrIStream, bool fullBuild, string finalfilename);
    public abstract virtual void DefineConstant(string name, object value, UInt32 sig, IntPtr signature);
    public abstract virtual void Abort();
    public abstract virtual void DefineLocalVariable2(string name, UInt32 attributes, UInt32 sigToken, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3, UInt32 startOffset, UInt32 endOffset);
    public abstract virtual void DefineGlobalVariable2(string name, UInt32 attributes, UInt32 sigToken, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3);
    public abstract virtual void DefineConstant2(string name, VariantStructure value, UInt32 sigToken);
}
[ExtensionAttribute]
internal static class Microsoft.Cci.ISymUnmanagedWriter2Helper : object {
    [ExtensionAttribute]
public static void DefineConstant2(ISymUnmanagedWriter2 writer, string name, object value, UInt32 sigToken);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("DCF7780D-BDE9-45DF-ACFE-21731A32000C")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.Cci.ISymUnmanagedWriter5 {
    public abstract virtual void _VtblGap1_30();
    public abstract virtual void OpenMapTokensToSourceSpans();
    public abstract virtual void CloseMapTokensToSourceSpans();
    public abstract virtual void MapTokenToSourceSpan(UInt32 token, ISymUnmanagedDocumentWriter document, UInt32 startLine, UInt32 startColumn, UInt32 endLine, UInt32 endColumn);
}
internal static class Microsoft.Cci.IteratorHelper : object {
    public static bool EnumerableIsNotEmpty(IEnumerable`1<T> enumerable);
    public static bool EnumerableIsEmpty(IEnumerable`1<T> enumerable);
    public static UInt32 EnumerableCount(IEnumerable`1<T> enumerable);
}
internal interface Microsoft.Cci.ITypeDefinition {
    public ushort Alignment { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsComObject { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSerializable { get; }
    public bool IsSpecialName { get; }
    public bool IsWindowsRuntimeImport { get; }
    public bool IsSealed { get; }
    public LayoutKind Layout { get; }
    public IEnumerable`1<SecurityAttribute> SecurityAttributes { get; }
    public UInt32 SizeOf { get; }
    public CharSet StringFormat { get; }
    public abstract virtual ushort get_Alignment();
    public abstract virtual ITypeReference GetBaseClass(EmitContext context);
    public abstract virtual IEnumerable`1<IEventDefinition> get_Events();
    public abstract virtual IEnumerable`1<MethodImplementation> GetExplicitImplementationOverrides(EmitContext context);
    public abstract virtual IEnumerable`1<IFieldDefinition> GetFields(EmitContext context);
    public abstract virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public abstract virtual ushort get_GenericParameterCount();
    public abstract virtual bool get_HasDeclarativeSecurity();
    public abstract virtual IEnumerable`1<ITypeReference> Interfaces(EmitContext context);
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsBeforeFieldInit();
    public abstract virtual bool get_IsComObject();
    public abstract virtual bool get_IsGeneric();
    public abstract virtual bool get_IsInterface();
    public abstract virtual bool get_IsRuntimeSpecial();
    public abstract virtual bool get_IsSerializable();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsWindowsRuntimeImport();
    public abstract virtual bool get_IsSealed();
    public abstract virtual LayoutKind get_Layout();
    public abstract virtual IEnumerable`1<IMethodDefinition> GetMethods(EmitContext context);
    public abstract virtual IEnumerable`1<INestedTypeDefinition> GetNestedTypes(EmitContext context);
    public abstract virtual IEnumerable`1<IPropertyDefinition> GetProperties(EmitContext context);
    public abstract virtual IEnumerable`1<SecurityAttribute> get_SecurityAttributes();
    public abstract virtual UInt32 get_SizeOf();
    public abstract virtual CharSet get_StringFormat();
}
internal interface Microsoft.Cci.ITypeDefinitionMember {
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public abstract virtual ITypeDefinition get_ContainingTypeDefinition();
    public abstract virtual TypeMemberVisibility get_Visibility();
}
internal interface Microsoft.Cci.ITypeExport {
    public ITypeReference ExportedType { get; }
    public abstract virtual ITypeReference get_ExportedType();
}
internal interface Microsoft.Cci.ITypeMemberReference {
    public abstract virtual ITypeReference GetContainingType(EmitContext context);
}
internal interface Microsoft.Cci.ITypeReference {
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public TypeDefinitionHandle TypeDef { get; }
    public IGenericMethodParameterReference AsGenericMethodParameterReference { get; }
    public IGenericTypeInstanceReference AsGenericTypeInstanceReference { get; }
    public IGenericTypeParameterReference AsGenericTypeParameterReference { get; }
    public INamespaceTypeReference AsNamespaceTypeReference { get; }
    public INestedTypeReference AsNestedTypeReference { get; }
    public ISpecializedNestedTypeReference AsSpecializedNestedTypeReference { get; }
    public abstract virtual bool get_IsEnum();
    public abstract virtual bool get_IsValueType();
    public abstract virtual ITypeDefinition GetResolvedType(EmitContext context);
    public abstract virtual PrimitiveTypeCode TypeCode(EmitContext context);
    public abstract virtual TypeDefinitionHandle get_TypeDef();
    public abstract virtual IGenericMethodParameterReference get_AsGenericMethodParameterReference();
    public abstract virtual IGenericTypeInstanceReference get_AsGenericTypeInstanceReference();
    public abstract virtual IGenericTypeParameterReference get_AsGenericTypeParameterReference();
    public abstract virtual INamespaceTypeDefinition AsNamespaceTypeDefinition(EmitContext context);
    public abstract virtual INamespaceTypeReference get_AsNamespaceTypeReference();
    public abstract virtual INestedTypeDefinition AsNestedTypeDefinition(EmitContext context);
    public abstract virtual INestedTypeReference get_AsNestedTypeReference();
    public abstract virtual ISpecializedNestedTypeReference get_AsSpecializedNestedTypeReference();
    public abstract virtual ITypeDefinition AsTypeDefinition(EmitContext context);
}
[ExtensionAttribute]
internal static class Microsoft.Cci.ITypeReferenceExtensions : object {
    [ExtensionAttribute]
internal static void GetConsolidatedTypeArguments(ITypeReference typeReference, ArrayBuilder`1<ITypeReference> consolidatedTypeArguments, EmitContext context);
    [ExtensionAttribute]
internal static ITypeReference GetUninstantiatedGenericType(ITypeReference typeReference);
    [ExtensionAttribute]
internal static bool IsTypeSpecification(ITypeReference typeReference);
}
internal interface Microsoft.Cci.IUnit {
}
internal interface Microsoft.Cci.IUnitReference {
}
internal interface Microsoft.Cci.IWin32Resource {
    public string TypeName { get; }
    public int TypeId { get; }
    public string Name { get; }
    public int Id { get; }
    public UInt32 LanguageId { get; }
    public UInt32 CodePage { get; }
    public IEnumerable`1<byte> Data { get; }
    public abstract virtual string get_TypeName();
    public abstract virtual int get_TypeId();
    public abstract virtual string get_Name();
    public abstract virtual int get_Id();
    public abstract virtual UInt32 get_LanguageId();
    public abstract virtual UInt32 get_CodePage();
    public abstract virtual IEnumerable`1<byte> get_Data();
}
internal class Microsoft.Cci.LocalScope : ValueType {
    public int StartOffset;
    public int EndOffset;
    private ImmutableArray`1<ILocalDefinition> _constants;
    private ImmutableArray`1<ILocalDefinition> _locals;
    public int Length { get; }
    public ImmutableArray`1<ILocalDefinition> Constants { get; }
    public ImmutableArray`1<ILocalDefinition> Variables { get; }
    internal LocalScope(int offset, int endOffset, ImmutableArray`1<ILocalDefinition> constants, ImmutableArray`1<ILocalDefinition> locals);
    public int get_Length();
    public ImmutableArray`1<ILocalDefinition> get_Constants();
    public ImmutableArray`1<ILocalDefinition> get_Variables();
}
internal enum Microsoft.Cci.Machine : Enum {
    public ushort value__;
    public static Machine Unknown;
    public static Machine I386;
    public static Machine ARMThumb2;
    public static Machine IA64;
    public static Machine AMD64;
}
internal class Microsoft.Cci.ManagedResource : object {
    private Func`1<Stream> _streamProvider;
    private IFileReference _fileReference;
    private UInt32 _offset;
    private string _name;
    private bool _isPublic;
    public IFileReference ExternalFile { get; }
    public UInt32 Offset { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public bool IsPublic { get; }
    public string Name { get; }
    internal ManagedResource(string name, bool isPublic, Func`1<Stream> streamProvider, IFileReference fileReference, UInt32 offset);
    public void WriteData(BinaryWriter resourceWriter);
    public IFileReference get_ExternalFile();
    public UInt32 get_Offset();
    public IEnumerable`1<ICustomAttribute> get_Attributes();
    public bool get_IsPublic();
    public string get_Name();
}
internal class Microsoft.Cci.MemberRefComparer : object {
    private MetadataWriter _metadataWriter;
    internal MemberRefComparer(MetadataWriter metadataWriter);
    public sealed virtual bool Equals(ITypeMemberReference x, ITypeMemberReference y);
    public sealed virtual int GetHashCode(ITypeMemberReference memberRef);
}
internal class Microsoft.Cci.MemoryStream : object {
    internal Byte[] Buffer;
    internal UInt32 Length;
    private UInt32 _position;
    private ObjectPool`1<MemoryStream> _pool;
    private static ObjectPool`1<MemoryStream> s_poolInstance;
    private UInt32 Capacity { get; }
    internal UInt32 Position { get; internal set; }
    internal MemoryStream(UInt32 initialSize);
    internal MemoryStream(ObjectPool`1<MemoryStream> pool);
    private static MemoryStream();
    private void Grow(UInt32 m);
    private UInt32 get_Capacity();
    internal UInt32 get_Position();
    internal void set_Position(UInt32 value);
    internal Byte[] ToArray();
    internal ImmutableArray`1<byte> ToImmutableArray();
    internal void Write(byte value, int count);
    internal void Write(Byte[] buffer, int index, int length);
    internal void Write(ImmutableArray`1<byte> buffer, int index, int length);
    internal void WriteTo(MemoryStream stream);
    internal void WriteTo(Stream stream);
    internal void Clear();
    public void Free();
    public static MemoryStream GetInstance();
    public static ObjectPool`1<MemoryStream> CreatePool();
    public static ObjectPool`1<MemoryStream> CreatePool(int size);
}
internal class Microsoft.Cci.MetadataHeapsBuilder : object {
    private static Encoding s_utf8Encoding;
    private Dictionary`2<string, UInt32> _userStringIndex;
    private BinaryWriter _userStringWriter;
    private int _userStringIndexStartOffset;
    private Dictionary`2<string, StringIdx> _stringIndex;
    private UInt32[] _stringIndexMap;
    private BinaryWriter _stringWriter;
    private int _stringIndexStartOffset;
    private Dictionary`2<ImmutableArray`1<byte>, UInt32> _blobIndex;
    private BinaryWriter _blobWriter;
    private int _blobIndexStartOffset;
    private Dictionary`2<Guid, UInt32> _guidIndex;
    private BinaryWriter _guidWriter;
    private bool _streamsAreComplete;
    public MetadataHeapsBuilder(int userStringIndexStartOffset, int stringIndexStartOffset, int blobIndexStartOffset, int guidIndexStartOffset);
    private static MetadataHeapsBuilder();
    internal UInt32 GetBlobIndex(MemoryStream stream);
    internal UInt32 GetBlobIndex(ImmutableArray`1<byte> blob);
    public UInt32 GetConstantBlobIndex(object value);
    public UInt32 GetBlobIndex(string str);
    public UInt32 GetGuidIndex(Guid guid);
    public UInt32 AllocateGuid(Guid guid);
    public Byte[] GetExistingBlob(int signatureOffset);
    public StringIdx GetStringIndex(string str);
    public UInt32 ResolveStringIndex(StringIdx index);
    public UInt32 GetUserStringToken(string str);
    public void Complete();
    public ImmutableArray`1<int> GetHeapSizes();
    private void SerializeStringHeap();
    public void WriteTo(MemoryStream stream, UInt32& guidHeapStartOffset);
    private static void WriteAligned(MemoryStream source, MemoryStream target);
}
internal class Microsoft.Cci.MetadataSizes : object {
    private static int StreamAlignment;
    private bool _isMinimalDelta;
    public byte BlobIndexSize;
    public byte StringIndexSize;
    public byte GuidIndexSize;
    public byte CustomAttributeTypeCodedIndexSize;
    public byte DeclSecurityCodedIndexSize;
    public byte EventDefIndexSize;
    public byte FieldDefIndexSize;
    public byte GenericParamIndexSize;
    public byte HasConstantCodedIndexSize;
    public byte HasCustomAttributeCodedIndexSize;
    public byte HasFieldMarshalCodedIndexSize;
    public byte HasSemanticsCodedIndexSize;
    public byte ImplementationCodedIndexSize;
    public byte MemberForwardedCodedIndexSize;
    public byte MemberRefParentCodedIndexSize;
    public byte MethodDefIndexSize;
    public byte MethodDefOrRefCodedIndexSize;
    public byte ModuleRefIndexSize;
    public byte ParameterIndexSize;
    public byte PropertyDefIndexSize;
    public byte ResolutionScopeCodedIndexSize;
    public byte TypeDefIndexSize;
    public byte TypeDefOrRefCodedIndexSize;
    public byte TypeOrMethodDefCodedIndexSize;
    public ImmutableArray`1<int> RowCounts;
    public ImmutableArray`1<int> HeapSizes;
    public int MetadataStreamStorageSize;
    public int MetadataTableStreamSize;
    public int ILStreamSize;
    public int MappedFieldDataSize;
    public int ResourceDataSize;
    public int MetadataHeaderSize { get; }
    public int MetadataSize { get; }
    public MetadataSizes(ImmutableArray`1<int> rowCounts, ImmutableArray`1<int> heapSizes, int ilStreamSize, int mappedFieldDataSize, int resourceDataSize, bool isMinimalDelta);
    public bool IsEmpty(TableIndex table);
    public int get_MetadataHeaderSize();
    public int get_MetadataSize();
    public int GetAlignedHeapSize(HeapIndex index);
    private int GetTableSize(TableIndex index, int rowSize);
    internal int CalculateTableStreamHeaderSize();
    private byte GetIndexByteSize(int discriminatingBits, TableIndex[] tables);
    private bool IndexDoesNotFit(int numberOfBits, TableIndex[] tables);
}
internal abstract class Microsoft.Cci.MetadataVisitor : object {
    public EmitContext Context;
    public MetadataVisitor(EmitContext context);
    public void Visit(IEnumerable`1<ITypeExport> typeExports);
    public virtual void Visit(ITypeExport typeExport);
    public virtual void Visit(IArrayTypeReference arrayTypeReference);
    public abstract virtual void Visit(IAssembly assembly);
    public void Visit(IEnumerable`1<IAssemblyReference> assemblyReferences);
    public virtual void Visit(IAssemblyReference assemblyReference);
    public void Visit(IEnumerable`1<ICustomAttribute> customAttributes);
    public virtual void Visit(ICustomAttribute customAttribute);
    public void Visit(ImmutableArray`1<ICustomModifier> customModifiers);
    public virtual void Visit(ICustomModifier customModifier);
    public void Visit(IEnumerable`1<IEventDefinition> events);
    public virtual void Visit(IEventDefinition eventDefinition);
    public void Visit(IEnumerable`1<IFieldDefinition> fields);
    public virtual void Visit(IFieldDefinition fieldDefinition);
    public virtual void Visit(IFieldReference fieldReference);
    public void Visit(IEnumerable`1<IFileReference> fileReferences);
    public virtual void Visit(IFileReference fileReference);
    public virtual void Visit(IGenericMethodInstanceReference genericMethodInstanceReference);
    public void Visit(IEnumerable`1<IGenericMethodParameter> genericParameters);
    public virtual void Visit(IGenericMethodParameter genericMethodParameter);
    public virtual void Visit(IGenericMethodParameterReference genericMethodParameterReference);
    public virtual void Visit(IGenericParameter genericParameter);
    public abstract virtual void Visit(IGenericTypeInstanceReference genericTypeInstanceReference);
    public void Visit(IEnumerable`1<IGenericParameter> genericParameters);
    public virtual void Visit(IGenericTypeParameter genericTypeParameter);
    public virtual void Visit(IGenericTypeParameterReference genericTypeParameterReference);
    public virtual void Visit(IGlobalFieldDefinition globalFieldDefinition);
    public virtual void Visit(IGlobalMethodDefinition globalMethodDefinition);
    public void Visit(ImmutableArray`1<ILocalDefinition> localDefinitions);
    public virtual void Visit(ILocalDefinition localDefinition);
    public virtual void Visit(IManagedPointerTypeReference managedPointerTypeReference);
    public virtual void Visit(IMarshallingInformation marshallingInformation);
    public virtual void Visit(IMetadataConstant constant);
    public virtual void Visit(IMetadataCreateArray createArray);
    public void Visit(IEnumerable`1<IMetadataExpression> expressions);
    public virtual void Visit(IMetadataExpression expression);
    public void Visit(IEnumerable`1<IMetadataNamedArgument> namedArguments);
    public virtual void Visit(IMetadataNamedArgument namedArgument);
    public virtual void Visit(IMetadataTypeOf typeOf);
    public virtual void Visit(IMethodBody methodBody);
    public void Visit(IEnumerable`1<IMethodDefinition> methods);
    public virtual void Visit(IMethodDefinition method);
    public void Visit(IEnumerable`1<MethodImplementation> methodImplementations);
    public virtual void Visit(MethodImplementation methodImplementation);
    public void Visit(IEnumerable`1<IMethodReference> methodReferences);
    public virtual void Visit(IMethodReference methodReference);
    public virtual void Visit(IModifiedTypeReference modifiedTypeReference);
    public abstract virtual void Visit(IModule module);
    public void Visit(IEnumerable`1<IModuleReference> moduleReferences);
    public virtual void Visit(IModuleReference moduleReference);
    public void Visit(IEnumerable`1<INamedTypeDefinition> types);
    public virtual void Visit(INamespaceTypeDefinition namespaceTypeDefinition);
    public virtual void Visit(INamespaceTypeReference namespaceTypeReference);
    public void VisitNestedTypes(IEnumerable`1<INamedTypeDefinition> nestedTypes);
    public virtual void Visit(INestedTypeDefinition nestedTypeDefinition);
    public virtual void Visit(INestedTypeReference nestedTypeReference);
    public void Visit(ImmutableArray`1<ExceptionHandlerRegion> exceptionRegions);
    public virtual void Visit(ExceptionHandlerRegion exceptionRegion);
    public void Visit(ImmutableArray`1<IParameterDefinition> parameters);
    public virtual void Visit(IParameterDefinition parameterDefinition);
    public void Visit(ImmutableArray`1<IParameterTypeInformation> parameterTypeInformations);
    public virtual void Visit(IParameterTypeInformation parameterTypeInformation);
    public virtual void Visit(IPlatformInvokeInformation platformInvokeInformation);
    public virtual void Visit(IPointerTypeReference pointerTypeReference);
    public void Visit(IEnumerable`1<IPropertyDefinition> properties);
    public virtual void Visit(IPropertyDefinition propertyDefinition);
    public void Visit(IEnumerable`1<ManagedResource> resources);
    public virtual void Visit(ManagedResource resource);
    public virtual void Visit(SecurityAttribute securityAttribute);
    public void Visit(IEnumerable`1<SecurityAttribute> securityAttributes);
    public void Visit(IEnumerable`1<ITypeDefinitionMember> typeMembers);
    public void Visit(IEnumerable`1<ITypeDefinition> types);
    public abstract virtual void Visit(ITypeDefinition typeDefinition);
    public virtual void Visit(ITypeDefinitionMember typeMember);
    public virtual void Visit(ITypeMemberReference typeMemberReference);
    public void Visit(IEnumerable`1<ITypeReference> typeReferences);
    public virtual void Visit(ITypeReference typeReference);
    protected void DispatchAsReference(ITypeReference typeReference);
    public void Visit(IEnumerable`1<IUnitReference> unitReferences);
    public virtual void Visit(IUnitReference unitReference);
    private void DispatchAsReference(IUnitReference unitReference);
    public virtual void Visit(IWin32Resource win32Resource);
}
internal abstract class Microsoft.Cci.MetadataWriter : object {
    private static Encoding s_utf8Encoding;
    internal static int NameLengthLimit;
    internal static int PathLengthLimit;
    internal static int PdbLengthLimit;
    private int _numTypeDefsEstimate;
    private bool _deterministic;
    internal bool allowMissingMethodBodies;
    private Dictionary`2<Byte[], UInt32> _smallMethodBodies;
    private CancellationToken _cancellationToken;
    protected IModule module;
    public EmitContext Context;
    protected CommonMessageProvider messageProvider;
    private bool _tableIndicesAreComplete;
    private UInt32[] _pseudoSymbolTokenToTokenMap;
    private IReference[] _pseudoSymbolTokenToReferenceMap;
    private UInt32[] _pseudoStringTokenToTokenMap;
    private List`1<string> _pseudoStringTokenToStringMap;
    private ReferenceIndexer _referenceVisitor;
    protected MetadataHeapsBuilder heaps;
    private Dictionary`2<ICustomAttribute, UInt32> _customAttributeSignatureIndex;
    private Dictionary`2<ITypeReference, UInt32> _typeSpecSignatureIndex;
    private Dictionary`2<ITypeReference, UInt32> _exportedTypeIndex;
    private List`1<ITypeReference> _exportedTypeList;
    private Dictionary`2<string, UInt32> _fileRefIndex;
    private List`1<IFileReference> _fileRefList;
    private Dictionary`2<IFieldReference, UInt32> _fieldSignatureIndex;
    private Dictionary`2<ISignature, UInt32> _signatureIndex;
    private Dictionary`2<IMarshallingInformation, UInt32> _marshallingDescriptorIndex;
    protected List`1<MethodImplementation> methodImplList;
    private Dictionary`2<IGenericMethodInstanceReference, UInt32> _methodInstanceSignatureIndex;
    internal static string dummyAssemblyAttributeParentNamespace;
    internal static string dummyAssemblyAttributeParentName;
    internal static String[0...,0...] dummyAssemblyAttributeParentQualifier;
    private UInt32[0...,0...] _dummyAssemblyAttributeParent;
    internal static int MappedFieldDataAlignment;
    private List`1<AssemblyRefTableRow> _assemblyRefTable;
    private UInt32 _assemblyKey;
    private StringIdx _assemblyName;
    private StringIdx _assemblyCulture;
    private List`1<ClassLayoutRow> _classLayoutTable;
    private List`1<ConstantRow> _constantTable;
    private List`1<CustomAttributeRow> _customAttributeTable;
    private List`1<DeclSecurityRow> _declSecurityTable;
    private List`1<EncLogRow> _encLogTable;
    private List`1<EncMapRow> _encMapTable;
    private List`1<EventMapRow> _eventMapTable;
    private List`1<EventRow> _eventTable;
    private List`1<ExportedTypeRow> _exportedTypeTable;
    private List`1<FieldLayoutRow> _fieldLayoutTable;
    private List`1<FieldMarshalRow> _fieldMarshalTable;
    private List`1<FieldRvaRow> _fieldRvaTable;
    private List`1<FieldDefRow> _fieldDefTable;
    private List`1<FileTableRow> _fileTable;
    private List`1<GenericParamConstraintRow> _genericParamConstraintTable;
    private List`1<GenericParamRow> _genericParamTable;
    private List`1<ImplMapRow> _implMapTable;
    private List`1<InterfaceImplRow> _interfaceImplTable;
    private List`1<ManifestResourceRow> _manifestResourceTable;
    private List`1<MemberRefRow> _memberRefTable;
    private List`1<MethodImplRow> _methodImplTable;
    private List`1<MethodSemanticsRow> _methodSemanticsTable;
    private List`1<MethodSpecRow> _methodSpecTable;
    private MethodRow[] _methodTable;
    private List`1<ModuleRefRow> _moduleRefTable;
    private ModuleRow _moduleRow;
    private List`1<NestedClassRow> _nestedClassTable;
    private List`1<ParamRow> _paramTable;
    private List`1<PropertyMapRow> _propertyMapTable;
    private List`1<PropertyRow> _propertyTable;
    private List`1<TypeDefRow> _typeDefTable;
    private List`1<TypeRefRow> _typeRefTable;
    private List`1<TypeSpecRow> _typeSpecTable;
    private int NumberOfTypeDefsEstimate { get; }
    internal bool IsFullMetadata { get; }
    private bool IsMinimalDelta { get; }
    protected ushort Generation { get; }
    protected Guid EncId { get; }
    protected Guid EncBaseId { get; }
    protected bool CompressMetadataStream { get; }
    protected MetadataWriter(MetadataHeapsBuilder heaps, EmitContext context, CommonMessageProvider messageProvider, bool allowMissingMethodBodies, bool deterministic, CancellationToken cancellationToken);
    private static MetadataWriter();
    private int get_NumberOfTypeDefsEstimate();
    internal bool get_IsFullMetadata();
    private bool get_IsMinimalDelta();
    protected abstract virtual ushort get_Generation();
    protected abstract virtual Guid get_EncId();
    protected abstract virtual Guid get_EncBaseId();
    protected abstract virtual bool get_CompressMetadataStream();
    protected abstract virtual bool TryGetTypeDefIndex(ITypeDefinition def, UInt32& index);
    protected abstract virtual UInt32 GetTypeDefIndex(ITypeDefinition def);
    protected abstract virtual ITypeDefinition GetTypeDef(int index);
    protected abstract virtual IReadOnlyList`1<ITypeDefinition> GetTypeDefs();
    protected abstract virtual UInt32 GetEventDefIndex(IEventDefinition def);
    protected abstract virtual IReadOnlyList`1<IEventDefinition> GetEventDefs();
    protected abstract virtual UInt32 GetFieldDefIndex(IFieldDefinition def);
    protected abstract virtual IReadOnlyList`1<IFieldDefinition> GetFieldDefs();
    protected abstract virtual bool TryGetMethodDefIndex(IMethodDefinition def, UInt32& index);
    protected abstract virtual UInt32 GetMethodDefIndex(IMethodDefinition def);
    protected abstract virtual IMethodDefinition GetMethodDef(int index);
    protected abstract virtual IReadOnlyList`1<IMethodDefinition> GetMethodDefs();
    protected abstract virtual UInt32 GetPropertyDefIndex(IPropertyDefinition def);
    protected abstract virtual IReadOnlyList`1<IPropertyDefinition> GetPropertyDefs();
    protected abstract virtual UInt32 GetParameterDefIndex(IParameterDefinition def);
    protected abstract virtual IReadOnlyList`1<IParameterDefinition> GetParameterDefs();
    protected abstract virtual IReadOnlyList`1<IGenericParameter> GetGenericParameters();
    protected abstract virtual UInt32 GetFieldDefIndex(INamedTypeDefinition typeDef);
    protected abstract virtual UInt32 GetMethodDefIndex(INamedTypeDefinition typeDef);
    protected abstract virtual UInt32 GetParameterDefIndex(IMethodDefinition methodDef);
    protected abstract virtual UInt32 GetOrAddAssemblyRefIndex(IAssemblyReference reference);
    protected abstract virtual IReadOnlyList`1<IAssemblyReference> GetAssemblyRefs();
    protected abstract virtual UInt32 GetOrAddModuleRefIndex(string reference);
    protected abstract virtual IReadOnlyList`1<string> GetModuleRefs();
    protected abstract virtual UInt32 GetOrAddMemberRefIndex(ITypeMemberReference reference);
    protected abstract virtual IReadOnlyList`1<ITypeMemberReference> GetMemberRefs();
    protected abstract virtual UInt32 GetOrAddMethodSpecIndex(IGenericMethodInstanceReference reference);
    protected abstract virtual IReadOnlyList`1<IGenericMethodInstanceReference> GetMethodSpecs();
    protected abstract virtual bool TryGetTypeRefIndex(ITypeReference reference, UInt32& index);
    protected abstract virtual UInt32 GetOrAddTypeRefIndex(ITypeReference reference);
    protected abstract virtual IReadOnlyList`1<ITypeReference> GetTypeRefs();
    protected abstract virtual UInt32 GetOrAddTypeSpecIndex(ITypeReference reference);
    protected abstract virtual IReadOnlyList`1<ITypeReference> GetTypeSpecs();
    protected abstract virtual UInt32 GetOrAddStandAloneSignatureIndex(UInt32 blobIndex);
    protected abstract virtual IReadOnlyList`1<UInt32> GetStandAloneSignatures();
    protected abstract virtual IEnumerable`1<INamespaceTypeDefinition> GetTopLevelTypes(IModule module);
    protected abstract virtual void CreateIndicesForNonTypeMembers(ITypeDefinition typeDef);
    protected abstract virtual ReferenceIndexer CreateReferenceVisitor();
    protected abstract virtual void PopulateEventMapTableRows(List`1<EventMapRow> table);
    protected abstract virtual void PopulatePropertyMapTableRows(List`1<PropertyMapRow> table);
    protected abstract virtual void PopulateEncLogTableRows(List`1<EncLogRow> table, ImmutableArray`1<int> rowCounts);
    protected abstract virtual void PopulateEncMapTableRows(List`1<EncMapRow> table, ImmutableArray`1<int> rowCounts);
    protected abstract virtual void ReportReferencesToAddedSymbols();
    private ImmutableArray`1<int> GetRowCounts();
    private void CreateMethodBodyReferenceIndex();
    private void CreateIndices();
    private void CreateUserStringIndices();
    protected virtual void CreateIndicesForModule();
    private void CreateIndicesFor(ITypeDefinition typeDef, Queue`1<ITypeDefinition> nestedTypes);
    protected IEnumerable`1<IGenericTypeParameter> GetConsolidatedTypeParameters(ITypeDefinition typeDef);
    private List`1<IGenericTypeParameter> GetConsolidatedTypeParameters(ITypeDefinition typeDef, ITypeDefinition owner);
    protected ImmutableArray`1<IParameterDefinition> GetParametersToEmit(IMethodDefinition methodDef);
    private ImmutableArray`1<IParameterDefinition> GetParametersToEmitCore(IMethodDefinition methodDef);
    public static IUnitReference GetDefiningUnitReference(ITypeReference typeReference, EmitContext context);
    private void CreateInitialAssemblyRefIndex();
    private void CreateInitialExportedTypeIndex();
    private void CreateInitialFileRefIndex();
    internal UInt32 GetAssemblyRefIndex(IAssemblyReference assemblyReference);
    internal UInt32 GetModuleRefIndex(string moduleName);
    private UInt32 GetCustomAttributeSignatureIndex(ICustomAttribute customAttribute);
    private UInt32 GetCustomAttributeTypeCodedIndex(IMethodReference methodReference);
    public static ushort GetEventFlags(IEventDefinition eventDef);
    private UInt32 GetExportedTypeIndex(ITypeReference typeReference);
    public static ushort GetFieldFlags(IFieldDefinition fieldDef);
    internal UInt32 GetFieldSignatureIndex(IFieldReference fieldReference);
    internal virtual UInt32 GetFieldToken(IFieldReference fieldReference);
    internal UInt32 GetFileRefIndex(IFileReference fileReference);
    private UInt32 GetFileRefIndex(IModuleReference mref);
    private static ushort GetGenericParamFlags(IGenericParameter genPar);
    private UInt32 GetImplementationCodedIndex(INamespaceTypeReference namespaceRef);
    private static UInt32 GetManagedResourceOffset(ManagedResource resource, BinaryWriter resourceWriter);
    public static string GetMangledName(INamedTypeReference namedType);
    internal UInt32 GetMemberRefIndex(ITypeMemberReference memberRef);
    internal UInt32 GetMemberRefParentCodedIndex(ITypeMemberReference memberRef);
    internal UInt32 GetMethodDefOrRefCodedIndex(IMethodReference methodReference);
    public static ushort GetMethodFlags(IMethodDefinition methodDef);
    internal UInt32 GetMethodInstanceSignatureIndex(IGenericMethodInstanceReference methodInstanceReference);
    private UInt32 GetMarshallingDescriptorIndex(IMarshallingInformation marshallingInformation);
    private UInt32 GetMarshallingDescriptorIndex(ImmutableArray`1<byte> descriptor);
    private UInt32 GetMemberRefSignatureIndex(ITypeMemberReference memberRef);
    internal UInt32 GetMethodSignatureIndex(IMethodReference methodReference);
    internal Byte[] GetMethodSignature(IMethodReference methodReference);
    private UInt32 GetGenericMethodInstanceIndex(IGenericMethodInstanceReference genericMethodInstanceReference);
    private UInt32 GetMethodSpecIndex(IGenericMethodInstanceReference methodSpec);
    internal virtual UInt32 GetMethodToken(IMethodReference methodReference);
    public static ushort GetParameterFlags(IParameterDefinition parDef);
    internal PrimitiveTypeCode GetConstantTypeCode(ILocalDefinition constant);
    private UInt32 GetPermissionSetIndex(ImmutableArray`1<ICustomAttribute> permissionSet);
    public static ushort GetPropertyFlags(IPropertyDefinition propertyDef);
    private UInt32 GetPropertySignatureIndex(IPropertyDefinition propertyDef);
    private UInt32 GetResolutionScopeCodedIndex(ITypeReference typeReference);
    private UInt32 GetResolutionScopeCodedIndex(IUnitReference unitReference);
    private StringIdx GetStringIndexForPathAndCheckLength(string path, INamedEntity errorEntity);
    private StringIdx GetStringIndexForNameAndCheckLength(string name, INamedEntity errorEntity);
    private StringIdx GetStringIndexForNamespaceAndCheckLength(INamespaceTypeReference namespaceType, string mangledTypeName);
    private void CheckNameLength(string name, INamedEntity errorEntity);
    private void CheckPathLength(string path, INamedEntity errorEntity);
    private void CheckNamespaceLength(string namespaceName, string mangledTypeName, INamespaceTypeReference errorEntity);
    internal bool IsUsingStringTooLong(string usingString, INamedEntity errorEntity);
    internal bool IsLocalNameTooLong(ILocalDefinition localDefinition);
    internal static bool IsTooLongInternal(string str, int maxLength);
    private static Location GetNamedEntityLocation(INamedEntity errorEntity);
    protected static Location GetSymbolLocation(ISymbol symbolOpt);
    private static SignatureTypeCode GetConstantTypeCode(object val);
    internal UInt32 GetTypeDefFlags(ITypeDefinition typeDef);
    public static UInt32 GetTypeDefFlags(ITypeDefinition typeDef, EmitContext context);
    private UInt32 GetTypeDefOrRefCodedIndex(ITypeReference typeReference, bool treatRefAsPotentialTypeSpec);
    private static ushort GetTypeMemberVisibilityFlags(ITypeDefinitionMember member);
    private UInt32 GetTypeOrMethodDefCodedIndex(IGenericParameter genPar);
    private UInt32 GetTypeRefIndex(ITypeReference typeReference);
    private UInt32 GetTypeSpecIndex(ITypeReference typeReference);
    internal ITypeDefinition GetTypeDefinition(UInt32 token);
    internal IMethodDefinition GetMethodDefinition(UInt32 token);
    internal INestedTypeReference GetNestedTypeReference(UInt32 token);
    internal UInt32 GetTypeSpecSignatureIndex(ITypeReference typeReference);
    internal void RecordTypeReference(ITypeReference typeReference);
    internal virtual UInt32 GetTypeToken(ITypeReference typeReference);
    internal UInt32 GetTokenForDefinition(IDefinition definition);
    private void SerializeCustomModifier(ICustomModifier customModifier, BinaryWriter writer);
    private void SerializeMetadataHeader(BinaryWriter writer, MetadataSizes metadataSizes);
    private static void SerializeStreamHeader(Int32& offsetFromStartOfMetadata, int alignedStreamSize, string streamName, BinaryWriter writer);
    public void WriteMetadataAndIL(PdbWriter pdbWriterOpt, Stream metadataStream, Stream ilStream, MetadataSizes& metadataSizes);
    public void SerializeMetadataAndIL(PdbWriter pdbWriterOpt, BinaryWriter metadataWriter, BinaryWriter ilWriter, BinaryWriter mappedFieldDataWriter, BinaryWriter managedResourceDataWriter, Func`2<MetadataSizes, int> calculateMethodBodyStreamRva, Func`2<MetadataSizes, int> calculateMappedFieldDataStreamRva, UInt32& moduleVersionIdOffsetInMetadataStream, UInt32& entryPointToken, MetadataSizes& metadataSizes);
    private void SerializeMetadata(BinaryWriter metadataWriter, MetadataSizes metadataSizes, int methodBodyStreamRva, int mappedFieldDataStreamRva, UInt32& guidHeapStartOffset);
    private UInt32 GetModuleVersionGuidOffsetInMetadataStream(UInt32 guidHeapOffsetInMetadataStream);
    private void SerializeMetadataTables(BinaryWriter writer, MetadataSizes metadataSizes, int methodBodyStreamRva, int mappedFieldDataStreamRva);
    private void PopulateTables(UInt32[] methodBodyRvas, BinaryWriter mappedFieldDataWriter, BinaryWriter resourceWriter);
    private void PopulateAssemblyRefTableRows();
    private void PopulateAssemblyTableRows();
    private void PopulateClassLayoutTableRows();
    private void PopulateConstantTableRows();
    private ConstantRow CreateConstantRow(object value, UInt32 parent);
    private void PopulateCustomAttributeTableRows();
    private void AddAssemblyAttributesToTable();
    private void AddAssemblyAttributesToTable(IEnumerable`1<ICustomAttribute> assemblyAttributes, bool needsDummyParent, bool isSecurity);
    private UInt32 GetDummyAssemblyAttributeParent(bool isSecurity, bool allowMultiple);
    private void AddModuleAttributesToTable(IModule module, UInt32 tag);
    private void AddCustomAttributesToTable(IEnumerable`1<T> parentList, UInt32 tag);
    private void AddCustomAttributesToTable(IEnumerable`1<T> parentList, UInt32 tag, Func`2<T, UInt32> getDefIndex);
    private void AddCustomAttributeToTable(UInt32 parentToken, ICustomAttribute customAttribute);
    private void PopulateDeclSecurityTableRows();
    private void PopulateDeclSecurityTableRowsFor(UInt32 parent, IEnumerable`1<SecurityAttribute> attributes);
    private void PopulateEventMapTableRows();
    private void PopulateEventTableRows();
    private void PopulateExportedTypeTableRows();
    private void PopulateFieldLayoutTableRows();
    private void PopulateFieldMarshalTableRows();
    private void PopulateFieldRvaTableRows(BinaryWriter mappedFieldDataWriter);
    private void PopulateFieldTableRows();
    private void PopulateFileTableRows();
    private void PopulateGenericParamConstraintTableRows();
    private void PopulateGenericParamTableRows();
    private void PopulateImplMapTableRows();
    private void PopulateInterfaceImplTableRows();
    private void PopulateManifestResourceTableRows(BinaryWriter resourceDataWriter);
    private void PopulateMemberRefTableRows();
    private void PopulateMethodImplTableRows();
    private void PopulateMethodSemanticsTableRows();
    private void PopulateMethodSpecTableRows();
    private void PopulateMethodTableRows(UInt32[] methodBodyRvas);
    private void PopulateModuleRefTableRows();
    private void PopulateModuleTableRow();
    private ModuleRow MakeModuleRow(MetadataHeapsBuilder heaps, Guid mvid);
    private void PopulateNestedClassTableRows();
    private void PopulateParamTableRows();
    private void PopulatePropertyMapTableRows();
    private void PopulatePropertyTableRows();
    private void PopulateTypeDefTableRows();
    private void PopulateTypeRefTableRows();
    private void PopulateTypeSpecTableRows();
    private void SerializeTablesHeader(BinaryWriter writer, MetadataSizes metadataSizes);
    private static void ComputeValidAndSortedMasks(MetadataSizes metadataSizes, UInt64& validTables, UInt64& sortedTables);
    private static void SerializeRowCounts(BinaryWriter writer, MetadataSizes tableSizes);
    private static void SerializeModuleTable(BinaryWriter writer, MetadataSizes metadataSizes, MetadataHeapsBuilder heaps, ModuleRow& moduleRow);
    private void SerializeEncLogTable(BinaryWriter writer);
    private void SerializeEncMapTable(BinaryWriter writer);
    private void SerializeTypeRefTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeTypeDefTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeFieldTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeMethodDefTable(BinaryWriter writer, MetadataSizes metadataSizes, int methodBodyStreamRva);
    private void SerializeParamTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeInterfaceImplTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeMemberRefTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeConstantTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeCustomAttributeTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeFieldMarshalTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeDeclSecurityTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeClassLayoutTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeFieldLayoutTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeStandAloneSigTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeEventMapTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeEventTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializePropertyMapTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializePropertyTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeMethodSemanticsTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeMethodImplTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeModuleRefTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeTypeSpecTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeImplMapTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeFieldRvaTable(BinaryWriter writer, MetadataSizes metadataSizes, int mappedFieldDataStreamRva);
    private void SerializeAssemblyTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeAssemblyRefTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeFileTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeExportedTypeTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeManifestResourceTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeNestedClassTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeGenericParamTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeMethodSpecTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private void SerializeGenericParamConstraintTable(BinaryWriter writer, MetadataSizes metadataSizes);
    private UInt32[] SerializeMethodBodies(BinaryWriter writer, PdbWriter pdbWriterOpt);
    private UInt32 SerializeMethodBody(IMethodBody methodBody, BinaryWriter writer, UInt32 localSignatureToken);
    protected virtual UInt32 SerializeLocalVariablesSignature(IMethodBody body);
    protected void SerializeLocalVariableSignature(BinaryWriter writer, ILocalDefinition local);
    internal UInt32 SerializeLocalConstantSignature(ILocalDefinition localConstant);
    private static UInt32 ReadUint(Byte[] buffer, int pos);
    private static void WriteUint(Byte[] buffer, UInt32 value, int pos);
    private UInt32 ResolveTokenFromReference(IReference reference);
    private UInt32 ResolveSymbolTokenFromPseudoSymbolToken(UInt32 pseudoSymbolToken);
    private UInt32 ResolveStringTokenFromPseudoStringToken(UInt32 pseudoStringToken);
    private Byte[] SerializeMethodBodyIL(IMethodBody methodBody);
    private void SerializeMethodBodyExceptionHandlerTable(IMethodBody methodBody, UInt32 numberOfExceptionHandlers, BinaryWriter writer);
    private void SerializeExceptionRegion(ExceptionHandlerRegion region, bool useSmallExceptionHeaders, BinaryWriter writer);
    private static bool MayUseSmallExceptionHeaders(UInt32 numberOfExceptionHandlers, ImmutableArray`1<ExceptionHandlerRegion> exceptionRegions);
    private void SerializeParameterInformation(IParameterTypeInformation parameterTypeInformation, BinaryWriter writer);
    private void SerializeFieldSignature(IFieldReference fieldReference, BinaryWriter writer);
    private void SerializeGenericMethodInstanceSignature(BinaryWriter writer, IGenericMethodInstanceReference genericMethodInstanceReference);
    private void SerializeCustomAttributeSignature(ICustomAttribute customAttribute, bool writeOnlyNamedArguments, BinaryWriter writer);
    private void SerializeMetadataExpression(BinaryWriter writer, IMetadataExpression expression, ITypeReference targetType);
    private void SerializeMarshallingDescriptor(IMarshallingInformation marshallingInformation, BinaryWriter writer);
    private void SerializeTypeName(ITypeReference typeReference, BinaryWriter writer);
    internal static string StrongName(IAssemblyReference assemblyReference);
    private void SerializePermissionSet(IEnumerable`1<ICustomAttribute> permissionSet, BinaryWriter writer);
    private void SerializeSignature(ISignature signature, ushort genericParameterCount, ImmutableArray`1<IParameterTypeInformation> extraArgumentTypes, BinaryWriter writer);
    private void SerializeTypeReference(ITypeReference typeReference, BinaryWriter writer, bool noTokens, bool treatRefAsPotentialTypeSpec);
    private UInt32 GetNumberOfInheritedTypeParameters(ITypeReference type);
    internal static EditAndContinueMethodDebugInformation GetEncMethodDebugInfo(IMethodBody methodBody);
    internal static ImmutableArray`1<LocalSlotDebugInfo> GetLocalSlotDebugInfos(ImmutableArray`1<ILocalDefinition> locals);
    internal static ImmutableArray`1<LocalSlotDebugInfo> GetLocalSlotDebugInfos(ImmutableArray`1<EncHoistedLocalInfo> locals);
    protected static UInt32 RowOnly(UInt32 token);
    protected static UInt32 TypeOnly(UInt32 token);
}
internal class Microsoft.Cci.MethodImplementation : ValueType {
    public IMethodDefinition ImplementingMethod;
    public IMethodReference ImplementedMethod;
    public ITypeDefinition ContainingType { get; }
    public MethodImplementation(IMethodDefinition ImplementingMethod, IMethodReference ImplementedMethod);
    public ITypeDefinition get_ContainingType();
}
internal class Microsoft.Cci.MethodSpecComparer : object {
    private MetadataWriter _metadataWriter;
    internal MethodSpecComparer(MetadataWriter metadataWriter);
    public sealed virtual bool Equals(IGenericMethodInstanceReference x, IGenericMethodInstanceReference y);
    public sealed virtual int GetHashCode(IGenericMethodInstanceReference methodInstanceReference);
}
internal class Microsoft.Cci.ModifiedTypeReference : object {
    private ITypeReference _modifiedType;
    private ImmutableArray`1<ICustomModifier> _customModifiers;
    private ImmutableArray`1<ICustomModifier> Microsoft.Cci.IModifiedTypeReference.CustomModifiers { get; }
    private ITypeReference Microsoft.Cci.IModifiedTypeReference.UnmodifiedType { get; }
    private bool Microsoft.Cci.ITypeReference.IsEnum { get; }
    private bool Microsoft.Cci.ITypeReference.IsValueType { get; }
    private TypeDefinitionHandle Microsoft.Cci.ITypeReference.TypeDef { get; }
    private IGenericMethodParameterReference Microsoft.Cci.ITypeReference.AsGenericMethodParameterReference { get; }
    private IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.AsGenericTypeInstanceReference { get; }
    private IGenericTypeParameterReference Microsoft.Cci.ITypeReference.AsGenericTypeParameterReference { get; }
    private INamespaceTypeReference Microsoft.Cci.ITypeReference.AsNamespaceTypeReference { get; }
    private INestedTypeReference Microsoft.Cci.ITypeReference.AsNestedTypeReference { get; }
    private ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.AsSpecializedNestedTypeReference { get; }
    public ModifiedTypeReference(ITypeReference modifiedType, ImmutableArray`1<ICustomModifier> customModifiers);
    private sealed virtual override ImmutableArray`1<ICustomModifier> Microsoft.Cci.IModifiedTypeReference.get_CustomModifiers();
    private sealed virtual override ITypeReference Microsoft.Cci.IModifiedTypeReference.get_UnmodifiedType();
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsEnum();
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsValueType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.GetResolvedType(EmitContext context);
    private sealed virtual override PrimitiveTypeCode Microsoft.Cci.ITypeReference.TypeCode(EmitContext context);
    private sealed virtual override TypeDefinitionHandle Microsoft.Cci.ITypeReference.get_TypeDef();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.GetAttributes(EmitContext context);
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override IGenericMethodParameterReference Microsoft.Cci.ITypeReference.get_AsGenericMethodParameterReference();
    private sealed virtual override IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.get_AsGenericTypeInstanceReference();
    private sealed virtual override IGenericTypeParameterReference Microsoft.Cci.ITypeReference.get_AsGenericTypeParameterReference();
    private sealed virtual override INamespaceTypeDefinition Microsoft.Cci.ITypeReference.AsNamespaceTypeDefinition(EmitContext context);
    private sealed virtual override INamespaceTypeReference Microsoft.Cci.ITypeReference.get_AsNamespaceTypeReference();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.ITypeReference.AsNestedTypeDefinition(EmitContext context);
    private sealed virtual override INestedTypeReference Microsoft.Cci.ITypeReference.get_AsNestedTypeReference();
    private sealed virtual override ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.get_AsSpecializedNestedTypeReference();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.AsTypeDefinition(EmitContext context);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
}
internal enum Microsoft.Cci.ModuleKind : Enum {
    public int value__;
    public static ModuleKind ConsoleApplication;
    public static ModuleKind WindowsApplication;
    public static ModuleKind DynamicallyLinkedLibrary;
    public static ModuleKind WindowsRuntimeMetadata;
    public static ModuleKind ManifestResourceFile;
    public static ModuleKind UnmanagedDynamicallyLinkedLibrary;
}
internal class Microsoft.Cci.NoPiaReferenceIndexer : ReferenceIndexerBase {
    internal NoPiaReferenceIndexer(EmitContext context);
    public virtual void Visit(IAssembly assembly);
    public virtual void Visit(IModule module);
    protected virtual void RecordAssemblyReference(IAssemblyReference assemblyReference);
    protected virtual void RecordFileReference(IFileReference fileReference);
    protected virtual void RecordModuleReference(IModuleReference moduleReference);
    public virtual void Visit(IPlatformInvokeInformation platformInvokeInformation);
    protected virtual void ProcessMethodBody(IMethodDefinition method);
    protected virtual void RecordTypeReference(ITypeReference typeReference);
    protected virtual void ReserveFieldToken(IFieldReference fieldReference);
    protected virtual void ReserveMethodToken(IMethodReference methodReference);
    protected virtual void RecordTypeMemberReference(ITypeMemberReference typeMemberReference);
}
internal class Microsoft.Cci.NtHeader : object {
    internal ushort NumberOfSections;
    internal UInt32 TimeDateStamp;
    internal UInt32 PointerToSymbolTable;
    internal UInt32 SizeOfCode;
    internal UInt32 SizeOfInitializedData;
    internal UInt32 SizeOfUninitializedData;
    internal UInt32 AddressOfEntryPoint;
    internal UInt32 BaseOfCode;
    internal UInt32 BaseOfData;
    internal UInt32 SizeOfImage;
    internal UInt32 SizeOfHeaders;
    internal DirectoryEntry ExportTable;
    internal DirectoryEntry ImportTable;
    internal DirectoryEntry ResourceTable;
    internal DirectoryEntry ExceptionTable;
    internal DirectoryEntry CertificateTable;
    internal DirectoryEntry BaseRelocationTable;
    internal DirectoryEntry DebugTable;
    internal DirectoryEntry CopyrightTable;
    internal DirectoryEntry GlobalPointerTable;
    internal DirectoryEntry ThreadLocalStorageTable;
    internal DirectoryEntry LoadConfigTable;
    internal DirectoryEntry BoundImportTable;
    internal DirectoryEntry ImportAddressTable;
    internal DirectoryEntry DelayImportTable;
    internal DirectoryEntry CliHeaderTable;
    internal DirectoryEntry Reserved;
}
internal class Microsoft.Cci.PdbLogger : object {
    private bool _logging;
    private BinaryWriter _logData;
    private static int bufferFlushLimit;
    private HashAlgorithm _hashAlgorithm;
    internal PdbLogger(bool logging);
    private void MaybeFlush();
    internal ContentId ContentIdFromLog();
    internal void Close();
    public bool LogOperation(PdbWriterOperation op);
    public void LogArgument(UInt32[] data);
    public void LogArgument(string data);
    public void LogArgument(UInt32 data);
    public void LogArgument(byte data);
    public void LogArgument(Byte[] data);
    public void LogArgument(Int32[] data);
    public void LogArgument(long data);
    public void LogArgument(int data);
    public void LogArgument(object data);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class Microsoft.Cci.PdbMetadataWrapper : object {
    private MetadataWriter _writer;
    private UInt32 _lastTypeDef;
    private string _lastTypeDefName;
    internal PdbMetadataWrapper(MetadataWriter writer);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetTypeDefProps(UInt32 td, IntPtr stringTypeDef, UInt32 cchTypeDef, UInt32& pchTypeDef, IntPtr pdwTypeDefFlags);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetMethodProps(UInt32 mb, UInt32& pointerClass, IntPtr stringMethod, UInt32 cchMethod, UInt32& pchMethod, IntPtr pdwAttr, IntPtr ppvSigBlob, IntPtr pcbSigBlob, IntPtr pulCodeRVA);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetNestedClassProps(UInt32 typeDefNestedClass);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.SetModuleProps(string stringName);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.Save(string stringFile, UInt32 dwordSaveFlags);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.SaveToStream(Void* pointerIStream, UInt32 dwordSaveFlags);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.GetSaveSize(UInt32 save);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.DefineTypeDef(Char* stringTypeDef, UInt32 dwordTypeDefFlags, UInt32 tokenExtends, UInt32* rtkImplements);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.DefineNestedType(Char* stringTypeDef, UInt32 dwordTypeDefFlags, UInt32 tokenExtends, UInt32* rtkImplements, UInt32 typeDefEncloser);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.SetHandler(object pointerUnk);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.DefineMethod(UInt32 td, Char* name, UInt32 dwordMethodFlags, Byte* voidPointerSigBlob, UInt32 byteCountSigBlob, UInt32 ulongCodeRVA, UInt32 dwordImplFlags);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.DefineMethodImpl(UInt32 td, UInt32 tokenBody, UInt32 tokenDecl);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.DefineTypeRefByName(UInt32 tokenResolutionScope, Char* stringName);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.DefineImportType(IntPtr pointerAssemImport, Void* bytePointerHashValue, UInt32 byteCountHashValue, IMetaDataImport pointerImport, UInt32 typeDefImport, IntPtr pointerAssemEmit);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.DefineMemberRef(UInt32 tokenImport, string stringName, Byte* voidPointerSigBlob, UInt32 byteCountSigBlob);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.DefineImportMember(IntPtr pointerAssemImport, Void* bytePointerHashValue, UInt32 byteCountHashValue, IMetaDataImport pointerImport, UInt32 member, IntPtr pointerAssemEmit, UInt32 tokenParent);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.DefineEvent(UInt32 td, string stringEvent, UInt32 dwordEventFlags, UInt32 tokenEventType, UInt32 memberDefAddOn, UInt32 memberDefRemoveOn, UInt32 memberDefFire, UInt32* rmdOtherMethods);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.SetClassLayout(UInt32 td, UInt32 dwordPackSize, COR_FIELD_OFFSET* arrayFieldOffsets, UInt32 ulongClassSize);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.DeleteClassLayout(UInt32 td);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.SetFieldMarshal(UInt32 tk, Byte* voidPointerNativeType, UInt32 byteCountNativeType);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.DeleteFieldMarshal(UInt32 tk);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.DefinePermissionSet(UInt32 tk, UInt32 dwordAction, Void* voidPointerPermission, UInt32 byteCountPermission);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.SetRVA(UInt32 md, UInt32 ulongRVA);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.GetTokenFromSig(Byte* voidPointerSig, UInt32 byteCountSig);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.DefineModuleRef(string stringName);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.SetParent(UInt32 mr, UInt32 tk);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.GetTokenFromTypeSpec(Byte* voidPointerSig, UInt32 byteCountSig);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.SaveToMemory(Void* bytePointerData, UInt32 byteCountData);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.DefineUserString(string stringString, UInt32 cchString);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.DeleteToken(UInt32 tokenObj);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.SetMethodProps(UInt32 md, UInt32 dwordMethodFlags, UInt32 ulongCodeRVA, UInt32 dwordImplFlags);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.SetTypeDefProps(UInt32 td, UInt32 dwordTypeDefFlags, UInt32 tokenExtends, UInt32* rtkImplements);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.SetEventProps(UInt32 ev, UInt32 dwordEventFlags, UInt32 tokenEventType, UInt32 memberDefAddOn, UInt32 memberDefRemoveOn, UInt32 memberDefFire, UInt32* rmdOtherMethods);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.SetPermissionSetProps(UInt32 tk, UInt32 dwordAction, Void* voidPointerPermission, UInt32 byteCountPermission);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.DefinePinvokeMap(UInt32 tk, UInt32 dwordMappingFlags, string stringImportName, UInt32 importDLL);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.SetPinvokeMap(UInt32 tk, UInt32 dwordMappingFlags, string stringImportName, UInt32 importDLL);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.DeletePinvokeMap(UInt32 tk);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.DefineCustomAttribute(UInt32 tokenObj, UInt32 tokenType, Void* pointerCustomAttribute, UInt32 byteCountCustomAttribute);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.SetCustomAttributeValue(UInt32 pcv, Void* pointerCustomAttribute, UInt32 byteCountCustomAttribute);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.DefineField(UInt32 td, string stringName, UInt32 dwordFieldFlags, Byte* voidPointerSigBlob, UInt32 byteCountSigBlob, UInt32 dwordCPlusTypeFlag, Void* pointerValue, UInt32 cchValue);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.DefineProperty(UInt32 td, string stringProperty, UInt32 dwordPropFlags, Byte* voidPointerSig, UInt32 byteCountSig, UInt32 dwordCPlusTypeFlag, Void* pointerValue, UInt32 cchValue, UInt32 memberDefSetter, UInt32 memberDefGetter, UInt32* rmdOtherMethods);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.DefineParam(UInt32 md, UInt32 ulongParamSeq, string stringName, UInt32 dwordParamFlags, UInt32 dwordCPlusTypeFlag, Void* pointerValue, UInt32 cchValue);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.SetFieldProps(UInt32 fd, UInt32 dwordFieldFlags, UInt32 dwordCPlusTypeFlag, Void* pointerValue, UInt32 cchValue);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.SetPropertyProps(UInt32 pr, UInt32 dwordPropFlags, UInt32 dwordCPlusTypeFlag, Void* pointerValue, UInt32 cchValue, UInt32 memberDefSetter, UInt32 memberDefGetter, UInt32* rmdOtherMethods);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.SetParamProps(UInt32 pd, string stringName, UInt32 dwordParamFlags, UInt32 dwordCPlusTypeFlag, Void* pointerValue, UInt32 cchValue);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.DefineSecurityAttributeSet(UInt32 tokenObj, IntPtr arraySecAttrs, UInt32 countSecAttrs);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.ApplyEditAndContinue(object pointerImport);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataEmit.TranslateSigWithScope(IntPtr pointerAssemImport, Void* bytePointerHashValue, UInt32 byteCountHashValue, IMetaDataImport import, Byte* bytePointerSigBlob, UInt32 byteCountSigBlob, IntPtr pointerAssemEmit, IMetaDataEmit emit, Byte* voidPointerTranslatedSig, UInt32 byteCountTranslatedSigMax);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.SetMethodImplFlags(UInt32 md, UInt32 dwordImplFlags);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.SetFieldRVA(UInt32 fd, UInt32 ulongRVA);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.Merge(IMetaDataImport pointerImport, IntPtr pointerHostMapToken, object pointerHandler);
    private sealed virtual override void Microsoft.Cci.IMetaDataEmit.MergeEnd();
    private sealed virtual override void Microsoft.Cci.IMetaDataImport.CloseEnum(UInt32 handleEnum);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.CountEnum(UInt32 handleEnum);
    private sealed virtual override void Microsoft.Cci.IMetaDataImport.ResetEnum(UInt32 handleEnum, UInt32 ulongPos);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumTypeDefs(UInt32& handlePointerEnum, UInt32[] arrayTypeDefs, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumInterfaceImpls(UInt32& handlePointerEnum, UInt32 td, UInt32[] arrayImpls, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumTypeRefs(UInt32& handlePointerEnum, UInt32[] arrayTypeRefs, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.FindTypeDefByName(string stringTypeDef, UInt32 tokenEnclosingClass);
    private sealed virtual override Guid Microsoft.Cci.IMetaDataImport.GetScopeProps(StringBuilder stringName, UInt32 cchName, UInt32& pchName);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetModuleFromScope();
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetInterfaceImplProps(UInt32 impl, UInt32& pointerClass);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetTypeRefProps(UInt32 tr, UInt32& ptkResolutionScope, StringBuilder stringName, UInt32 cchName);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.ResolveTypeRef(UInt32 tr, Guid& riid, Object& ppIScope);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumMembers(UInt32& handlePointerEnum, UInt32 cl, UInt32[] arrayMembers, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumMembersWithName(UInt32& handlePointerEnum, UInt32 cl, string stringName, UInt32[] arrayMembers, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumMethods(UInt32& handlePointerEnum, UInt32 cl, UInt32* arrayMethods, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumMethodsWithName(UInt32& handlePointerEnum, UInt32 cl, string stringName, UInt32[] arrayMethods, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumFields(UInt32& handlePointerEnum, UInt32 cl, UInt32* arrayFields, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumFieldsWithName(UInt32& handlePointerEnum, UInt32 cl, string stringName, UInt32[] arrayFields, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumParams(UInt32& handlePointerEnum, UInt32 mb, UInt32[] arrayParams, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumMemberRefs(UInt32& handlePointerEnum, UInt32 tokenParent, UInt32[] arrayMemberRefs, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumMethodImpls(UInt32& handlePointerEnum, UInt32 td, UInt32[] arrayMethodBody, UInt32[] arrayMethodDecl, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumPermissionSets(UInt32& handlePointerEnum, UInt32 tk, UInt32 dwordActions, UInt32[] arrayPermission, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.FindMember(UInt32 td, string stringName, Byte[] voidPointerSigBlob, UInt32 byteCountSigBlob);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.FindMethod(UInt32 td, string stringName, Byte[] voidPointerSigBlob, UInt32 byteCountSigBlob);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.FindField(UInt32 td, string stringName, Byte[] voidPointerSigBlob, UInt32 byteCountSigBlob);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.FindMemberRef(UInt32 td, string stringName, Byte[] voidPointerSigBlob, UInt32 byteCountSigBlob);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetMemberRefProps(UInt32 mr, UInt32& ptk, StringBuilder stringMember, UInt32 cchMember, UInt32& pchMember, Byte*& ppvSigBlob);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumProperties(UInt32& handlePointerEnum, UInt32 td, UInt32* arrayProperties, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumEvents(UInt32& handlePointerEnum, UInt32 td, UInt32* arrayEvents, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetEventProps(UInt32 ev, UInt32& pointerClass, StringBuilder stringEvent, UInt32 cchEvent, UInt32& pchEvent, UInt32& pdwEventFlags, UInt32& ptkEventType, UInt32& pmdAddOn, UInt32& pmdRemoveOn, UInt32& pmdFire, UInt32[] rmdOtherMethod, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumMethodSemantics(UInt32& handlePointerEnum, UInt32 mb, UInt32[] arrayEventProp, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetMethodSemantics(UInt32 mb, UInt32 tokenEventProp);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetClassLayout(UInt32 td, UInt32& pdwPackSize, COR_FIELD_OFFSET[] arrayFieldOffset, UInt32 countMax, UInt32& countPointerFieldOffset);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetFieldMarshal(UInt32 tk, Byte*& ppvNativeType);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetRVA(UInt32 tk, UInt32& pulCodeRVA);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetPermissionSetProps(UInt32 pm, UInt32& pdwAction, Void*& ppvPermission);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetSigFromToken(UInt32 memberDefSig, IntPtr& ppvSig, UInt32& pcbSig);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetModuleRefProps(UInt32 mur, StringBuilder stringName, UInt32 cchName);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumModuleRefs(UInt32& handlePointerEnum, UInt32[] arrayModuleRefs, UInt32 cmax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetTypeSpecFromToken(UInt32 typespec, Byte*& ppvSig);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetNameFromToken(UInt32 tk);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumUnresolvedMethods(UInt32& handlePointerEnum, UInt32[] arrayMethods, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetUserString(UInt32 stk, StringBuilder stringString, UInt32 cchString);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetPinvokeMap(UInt32 tk, UInt32& pdwMappingFlags, StringBuilder stringImportName, UInt32 cchImportName, UInt32& pchImportName);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumSignatures(UInt32& handlePointerEnum, UInt32[] arraySignatures, UInt32 cmax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumTypeSpecs(UInt32& handlePointerEnum, UInt32[] arrayTypeSpecs, UInt32 cmax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumUserStrings(UInt32& handlePointerEnum, UInt32[] arrayStrings, UInt32 cmax);
    private sealed virtual override int Microsoft.Cci.IMetaDataImport.GetParamForMethodIndex(UInt32 md, UInt32 ulongParamSeq, UInt32& pointerParam);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.EnumCustomAttributes(UInt32& handlePointerEnum, UInt32 tk, UInt32 tokenType, UInt32[] arrayCustomAttributes, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetCustomAttributeProps(UInt32 cv, UInt32& ptkObj, UInt32& ptkType, Void*& ppBlob);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.FindTypeRef(UInt32 tokenResolutionScope, string stringName);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetMemberProps(UInt32 mb, UInt32& pointerClass, StringBuilder stringMember, UInt32 cchMember, UInt32& pchMember, UInt32& pdwAttr, Byte*& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pulCodeRVA, UInt32& pdwImplFlags, UInt32& pdwCPlusTypeFlag, Void*& ppValue);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetFieldProps(UInt32 mb, UInt32& pointerClass, StringBuilder stringField, UInt32 cchField, UInt32& pchField, UInt32& pdwAttr, Byte*& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pdwCPlusTypeFlag, Void*& ppValue);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetPropertyProps(UInt32 prop, UInt32& pointerClass, StringBuilder stringProperty, UInt32 cchProperty, UInt32& pchProperty, UInt32& pdwPropFlags, Byte*& ppvSig, UInt32& bytePointerSig, UInt32& pdwCPlusTypeFlag, Void*& ppDefaultValue, UInt32& pcchDefaultValue, UInt32& pmdSetter, UInt32& pmdGetter, UInt32[] rmdOtherMethod, UInt32 countMax);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetParamProps(UInt32 tk, UInt32& pmd, UInt32& pulSequence, StringBuilder stringName, UInt32 cchName, UInt32& pchName, UInt32& pdwAttr, UInt32& pdwCPlusTypeFlag, Void*& ppValue);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetCustomAttributeByName(UInt32 tokenObj, string stringName, Void*& ppData);
    private sealed virtual override bool Microsoft.Cci.IMetaDataImport.IsValidToken(UInt32 tk);
    private sealed virtual override UInt32 Microsoft.Cci.IMetaDataImport.GetNativeCallConvFromSig(Void* voidPointerSig, UInt32 byteCountSig);
    private sealed virtual override int Microsoft.Cci.IMetaDataImport.IsGlobal(UInt32 pd);
}
internal class Microsoft.Cci.PdbWriter : object {
    internal static UInt32 HiddenLocalAttributesValue;
    internal static UInt32 DefaultLocalAttributesValue;
    internal static UInt32 Age;
    private static Type s_lazyCorSymWriterSxSType;
    private string _fileName;
    private Func`1<object> _symWriterFactory;
    private ComMemoryStream _pdbStream;
    private MetadataWriter _metadataWriter;
    private ISymUnmanagedWriter2 _symWriter;
    private Dictionary`2<DebugSourceDocument, ISymUnmanagedDocumentWriter> _documentMap;
    private Dictionary`2<object, string> _qualifiedNameCache;
    private UInt32[] _sequencePointOffsets;
    private UInt32[] _sequencePointStartLines;
    private UInt32[] _sequencePointStartColumns;
    private UInt32[] _sequencePointEndLines;
    private UInt32[] _sequencePointEndColumns;
    private bool _deterministic;
    private PdbLogger _callLogger;
    private static string SymWriterClsid;
    private IModule Module { get; }
    private EmitContext Context { get; }
    public PdbWriter(string fileName, Func`1<object> symWriterFactory, bool deterministic);
    public void WriteTo(Stream stream);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void Close();
    private IModule get_Module();
    private EmitContext get_Context();
    public void SerializeDebugInfo(IMethodBody methodBody, UInt32 localSignatureToken, CustomDebugInfoWriter customDebugInfoWriter);
    private void DefineNamespaceScopes(IMethodBody methodBody);
    private void DefineAssemblyReferenceAliases();
    private string TryEncodeImport(UsedNamespaceOrType import, HashSet`1<string> declaredExternAliasesOpt, bool isProjectLevel);
    internal string GetOrCreateSerializedNamespaceName(INamespace namespace);
    internal string GetOrCreateSerializedTypeName(ITypeReference typeReference);
    private string SerializeVisualBasicImportTypeReference(ITypeReference typeReference);
    private string GetAssemblyReferenceAlias(IAssemblyReference assembly, HashSet`1<string> declaredExternAliases);
    private void DefineLocalScopes(ImmutableArray`1<LocalScope> scopes, UInt32 localSignatureToken);
    private void DefineScopeLocals(LocalScope currentScope, UInt32 localSignatureToken);
    private static Type GetCorSymWriterSxSType();
    private static object CreateSymWriterWorker();
    public void SetMetadataEmitter(MetadataWriter metadataWriter);
    public ContentId GetContentId();
    public void SetEntryPoint(UInt32 entryMethodToken);
    private ISymUnmanagedDocumentWriter GetDocumentWriter(DebugSourceDocument document);
    private void OpenMethod(UInt32 methodToken, IMethodDefinition method);
    private void CloseMethod(int ilLength);
    private void OpenScope(int offset);
    private void CloseScope(int endOffset);
    private void UsingNamespace(string fullName, INamedEntity errorEntity);
    private void CreateSequencePointBuffers(int capacity);
    private void ResizeSequencePointBuffers();
    private void EmitSequencePoints(ImmutableArray`1<SequencePoint> sequencePoints);
    private void WriteSequencePoints(ISymUnmanagedDocumentWriter symDocument, int count);
    private void DefineCustomMetadata(string name, Byte[] metadata);
    private void DefineLocalConstant(string name, object value, PrimitiveTypeCode typeCode, UInt32 constantSignatureToken);
    private void DefineLocalStringConstant(string name, string value, UInt32 constantSignatureToken);
    private void DefineLocalVariable(UInt32 index, string name, UInt32 attributes, UInt32 localVariablesSignatureToken);
    private void SetAsyncInfo(UInt32 thisMethodToken, UInt32 kickoffMethodToken, int catchHandlerOffset, ImmutableArray`1<int> yieldOffsets, ImmutableArray`1<int> resumeOffsets);
    [ConditionalAttribute("DEBUG")]
public void AssertAllDefinitionsHaveTokens(MultiDictionary`2<DebugSourceDocument, DefinitionWithLocation> file2definitions);
    public void WriteDefinitionLocations(MultiDictionary`2<DebugSourceDocument, DefinitionWithLocation> file2definitions);
}
internal class Microsoft.Cci.PdbWritingException : Exception {
    internal PdbWritingException(Exception inner);
}
internal class Microsoft.Cci.PeWriter : object {
    private bool _deterministic;
    private IModule _module;
    private string _pdbPathOpt;
    private bool _emitRuntimeStartupStub;
    private int _sizeOfImportAddressTable;
    private MemoryStream _headerStream;
    private MemoryStream _emptyStream;
    private NtHeader _ntHeader;
    private BinaryWriter _rdataWriter;
    private BinaryWriter _sdataWriter;
    private BinaryWriter _tlsDataWriter;
    private BinaryWriter _win32ResourceWriter;
    private BinaryWriter _coverageDataWriter;
    private SectionHeader _coverSection;
    private SectionHeader _relocSection;
    private SectionHeader _resourceSection;
    private SectionHeader _rdataSection;
    private SectionHeader _sdataSection;
    private SectionHeader _textSection;
    private SectionHeader _tlsSection;
    private static int ImageDebugDirectoryBaseSize;
    private static Byte[] s_dosHeader;
    private bool EmitPdb { get; }
    private PeWriter(IModule module, string pdbPathOpt, bool deterministic);
    private static PeWriter();
    private bool get_EmitPdb();
    public static bool WritePeToStream(EmitContext context, CommonMessageProvider messageProvider, Func`1<Stream> getPeStream, PdbWriter nativePdbWriterOpt, string pdbPathOpt, bool allowMissingMethodBodies, bool deterministic, CancellationToken cancellationToken);
    private bool WritePeToStream(MetadataWriter mdWriter, Func`1<Stream> getPeStream, PdbWriter nativePdbWriterOpt);
    private int CalculateMappedFieldDataStreamRva(MetadataSizes metadataSizes);
    private static void WriteDeterministicGuidAndTimestamps(Stream peStream, long mvidPosition, long ntHeaderTimestampPosition);
    [ConditionalAttribute("DEBUG")]
private static void CheckZeroDataInStream(Stream stream, long position, int bytes);
    private int ComputeStrongNameSignatureSize();
    private int ComputeOffsetToDebugTable(MetadataSizes metadataSizes);
    private int ComputeOffsetToImportTable(MetadataSizes metadataSizes);
    private int ComputeOffsetToMetadata(int ilStreamLength);
    private int ComputeSizeOfDebugDirectoryData();
    private int ComputeSizeOfDebugDirectory();
    private UInt32 ComputeSizeOfPeHeaders();
    private int ComputeSizeOfTextSection(MetadataSizes metadataSizes);
    private UInt32 ComputeSizeOfWin32Resources(UInt32 resourcesRva);
    private CorHeader CreateCorHeader(MetadataSizes metadataSizes, UInt32 entryPointToken);
    private void FillInNtHeader(MetadataSizes metadataSizes, int mappedFieldDataStreamRva);
    private void FillInTextSectionHeader(MetadataSizes metadataSizes);
    private void FillInSectionHeaders();
    private CorFlags GetCorHeaderFlags();
    private static int CompareResources(IWin32Resource left, IWin32Resource right);
    private static int CompareResourceIdentifiers(int xOrdinal, string xString, int yOrdinal, string yString);
    internal static IEnumerable`1<IWin32Resource> SortResources(IEnumerable`1<IWin32Resource> resources);
    private void SerializeWin32Resources(UInt32 resourcesRva);
    private void SerializeWin32Resources(IEnumerable`1<IWin32Resource> theResources, UInt32 resourcesRva);
    private void WriteDirectory(Directory directory, BinaryWriter writer, UInt32 offset, UInt32 level, UInt32 sizeOfDirectoryTree, UInt32 virtualAddressBase, BinaryWriter dataWriter);
    private static UInt32 SizeOfDirectory(Directory directory);
    private void SerializeWin32Resources(ResourceSection resourceSections, UInt32 resourcesRva);
    private void WriteHeaders(Stream peStream, Int64& ntHeaderTimestampPosition);
    private static void WriteSectionHeader(SectionHeader sectionHeader, BinaryWriter writer);
    private void WriteTextSection(Stream peStream, CorHeader corHeader, MemoryStream metadataStream, MemoryStream ilStream, MemoryStream mappedFieldDataStream, MemoryStream managedResourceStream, MetadataSizes metadataSizes, ContentId pdbContentId, Int64& metadataPosition);
    private void WriteImportAddressTable(Stream peStream);
    private void WriteImportTable(Stream peStream);
    private static void WriteNameTable(Stream peStream);
    private static void WriteCorHeader(Stream peStream, CorHeader corHeader);
    private static void WriteIL(Stream peStream, MemoryStream ilStream);
    private static void WriteMappedFieldData(Stream peStream, MemoryStream dataStream);
    private static void WriteSpaceForHash(Stream peStream, int strongNameSignatureSize);
    private static void WriteMetadata(Stream peStream, MemoryStream metadataStream);
    private static void WriteManagedResources(Stream peStream, MemoryStream managedResourceStream);
    private void WriteDebugTable(Stream peStream, ContentId pdbContentId, MetadataSizes metadataSizes);
    private void WriteRuntimeStartupStub(Stream peStream);
    private void WriteCoverSection(Stream peStream);
    private void WriteRdataSection(Stream peStream);
    private void WriteSdataSection(Stream peStream);
    private void WriteRelocSection(Stream peStream);
    private void WriteResourceSection(Stream peStream);
    private void WriteTlsSection(Stream peStream);
    [CompilerGeneratedAttribute]
private int <WritePeToStream>b__24_0(MetadataSizes mdSizes);
}
internal class Microsoft.Cci.PeWritingException : Exception {
    public PeWritingException(Exception inner);
}
[FlagsAttribute]
internal enum Microsoft.Cci.PInvokeAttributes : Enum {
    public ushort value__;
    public static PInvokeAttributes NoMangle;
    public static PInvokeAttributes CharSetMask;
    public static PInvokeAttributes CharSetNotSpec;
    public static PInvokeAttributes CharSetAnsi;
    public static PInvokeAttributes CharSetUnicode;
    public static PInvokeAttributes CharSetAuto;
    public static PInvokeAttributes BestFitUseAssem;
    public static PInvokeAttributes BestFitEnabled;
    public static PInvokeAttributes BestFitDisabled;
    public static PInvokeAttributes BestFitMask;
    public static PInvokeAttributes ThrowOnUnmappableCharUseAssem;
    public static PInvokeAttributes ThrowOnUnmappableCharEnabled;
    public static PInvokeAttributes ThrowOnUnmappableCharDisabled;
    public static PInvokeAttributes ThrowOnUnmappableCharMask;
    public static PInvokeAttributes SupportsLastError;
    public static PInvokeAttributes CallConvMask;
    public static PInvokeAttributes CallConvWinapi;
    public static PInvokeAttributes CallConvCdecl;
    public static PInvokeAttributes CallConvStdcall;
    public static PInvokeAttributes CallConvThiscall;
    public static PInvokeAttributes CallConvFastcall;
    public static PInvokeAttributes MaxValue;
}
internal enum Microsoft.Cci.PlatformType : Enum {
    public int value__;
    public static PlatformType SystemObject;
    public static PlatformType SystemDecimal;
    public static PlatformType SystemTypedReference;
    public static PlatformType SystemType;
    public static PlatformType SystemInt32;
    public static PlatformType SystemVoid;
    public static PlatformType SystemString;
}
internal enum Microsoft.Cci.PrimitiveTypeCode : Enum {
    public int value__;
    public static PrimitiveTypeCode Boolean;
    public static PrimitiveTypeCode Char;
    public static PrimitiveTypeCode Int8;
    public static PrimitiveTypeCode Float32;
    public static PrimitiveTypeCode Float64;
    public static PrimitiveTypeCode Int16;
    public static PrimitiveTypeCode Int32;
    public static PrimitiveTypeCode Int64;
    public static PrimitiveTypeCode IntPtr;
    public static PrimitiveTypeCode Pointer;
    public static PrimitiveTypeCode Reference;
    public static PrimitiveTypeCode String;
    public static PrimitiveTypeCode UInt8;
    public static PrimitiveTypeCode UInt16;
    public static PrimitiveTypeCode UInt32;
    public static PrimitiveTypeCode UInt64;
    public static PrimitiveTypeCode UIntPtr;
    public static PrimitiveTypeCode Void;
    public static PrimitiveTypeCode NotPrimitive;
    public static PrimitiveTypeCode Invalid;
}
internal abstract class Microsoft.Cci.ReferenceIndexer : ReferenceIndexerBase {
    protected MetadataWriter metadataWriter;
    private HashSet`1<IImportScope> _alreadySeenScopes;
    internal ReferenceIndexer(MetadataWriter metadataWriter);
    public virtual void Visit(IAssembly assembly);
    public virtual void Visit(IModule module);
    public void VisitMethodBodyReference(IReference reference);
    protected virtual void RecordAssemblyReference(IAssemblyReference assemblyReference);
    protected virtual void ProcessMethodBody(IMethodDefinition method);
    private void VisitImports(ImmutableArray`1<UsedNamespaceOrType> imports);
    protected virtual void RecordTypeReference(ITypeReference typeReference);
    protected virtual void RecordTypeMemberReference(ITypeMemberReference typeMemberReference);
    protected virtual void RecordFileReference(IFileReference fileReference);
    protected virtual void ReserveMethodToken(IMethodReference methodReference);
    protected virtual void ReserveFieldToken(IFieldReference fieldReference);
    protected virtual void RecordModuleReference(IModuleReference moduleReference);
    public virtual void Visit(IPlatformInvokeInformation platformInvokeInformation);
}
internal abstract class Microsoft.Cci.ReferenceIndexerBase : MetadataVisitor {
    private HashSet`1<IReference> _alreadySeen;
    private HashSet`1<IReference> _alreadyHasToken;
    protected bool typeReferenceNeedsToken;
    protected IModule module;
    internal ReferenceIndexerBase(EmitContext context);
    public abstract virtual void Visit(IAssembly assembly);
    public virtual void Visit(IAssemblyReference assemblyReference);
    protected abstract virtual void RecordAssemblyReference(IAssemblyReference assemblyReference);
    public virtual void Visit(ITypeExport aliasForType);
    public virtual void Visit(ICustomModifier customModifier);
    public virtual void Visit(IEventDefinition eventDefinition);
    public virtual void Visit(IFieldReference fieldReference);
    protected abstract virtual void ReserveFieldToken(IFieldReference fieldReference);
    public virtual void Visit(IFileReference fileReference);
    protected abstract virtual void RecordFileReference(IFileReference fileReference);
    public virtual void Visit(IGenericMethodInstanceReference genericMethodInstanceReference);
    public virtual void Visit(IGenericParameter genericParameter);
    public virtual void Visit(IGenericTypeInstanceReference genericTypeInstanceReference);
    public virtual void Visit(IMarshallingInformation marshallingInformation);
    public virtual void Visit(IMethodDefinition method);
    protected abstract virtual void ProcessMethodBody(IMethodDefinition method);
    public virtual void Visit(IMethodReference methodReference);
    protected abstract virtual void ReserveMethodToken(IMethodReference methodReference);
    public abstract virtual void Visit(IModule module);
    public virtual void Visit(IModuleReference moduleReference);
    protected abstract virtual void RecordModuleReference(IModuleReference moduleReference);
    public abstract virtual void Visit(IPlatformInvokeInformation platformInvokeInformation);
    public virtual void Visit(INamespaceTypeReference namespaceTypeReference);
    protected abstract virtual void RecordTypeReference(ITypeReference typeReference);
    public virtual void Visit(INestedTypeReference nestedTypeReference);
    public virtual void Visit(IPropertyDefinition propertyDefinition);
    public virtual void Visit(ManagedResource resourceReference);
    public virtual void Visit(SecurityAttribute securityAttribute);
    public void VisitTypeDefinitionNoMembers(ITypeDefinition typeDefinition);
    public virtual void Visit(ITypeDefinition typeDefinition);
    public void VisitTypeReferencesThatNeedTokens(IEnumerable`1<ITypeReference> typeReferences);
    private void VisitTypeReferencesThatNeedTokens(ITypeReference typeReference);
    public virtual void Visit(ITypeMemberReference typeMemberReference);
    protected abstract virtual void RecordTypeMemberReference(ITypeMemberReference typeMemberReference);
    public virtual void Visit(IArrayTypeReference arrayTypeReference);
    public virtual void Visit(IPointerTypeReference pointerTypeReference);
    public virtual void Visit(ITypeReference typeReference);
    private bool VisitTypeReference(ITypeReference typeReference);
    public virtual void Visit(IManagedPointerTypeReference managedPointerTypeReference);
}
internal class Microsoft.Cci.ResourceSection : object {
    internal Byte[] SectionBytes;
    internal UInt32[] Relocations;
    internal ResourceSection(Byte[] sectionBytes, UInt32[] relocations);
}
internal class Microsoft.Cci.ReturnValueParameter : object {
    private IMethodDefinition _containingMethod;
    public ISignature ContainingSignature { get; }
    public IMetadataConstant Constant { get; }
    public ImmutableArray`1<ICustomModifier> CustomModifiers { get; }
    public bool HasDefaultValue { get; }
    public ushort Index { get; }
    public bool IsIn { get; }
    public bool IsByReference { get; }
    public bool HasByRefBeforeCustomModifiers { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public ImmutableArray`1<byte> MarshallingDescriptor { get; }
    public string Name { get; }
    internal ReturnValueParameter(IMethodDefinition containingMethod);
    public sealed virtual IEnumerable`1<ICustomAttribute> GetAttributes(EmitContext context);
    public ISignature get_ContainingSignature();
    public IMetadataConstant get_Constant();
    public sealed virtual ImmutableArray`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual IMetadataConstant GetDefaultValue(EmitContext context);
    public sealed virtual void Dispatch(MetadataVisitor visitor);
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual ushort get_Index();
    public sealed virtual bool get_IsIn();
    public sealed virtual bool get_IsByReference();
    public sealed virtual bool get_HasByRefBeforeCustomModifiers();
    public sealed virtual bool get_IsMarshalledExplicitly();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_IsOut();
    public sealed virtual IMarshallingInformation get_MarshallingInformation();
    public sealed virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    public sealed virtual string get_Name();
    public sealed virtual ITypeReference GetType(EmitContext context);
    public sealed virtual IDefinition AsDefinition(EmitContext context);
}
internal class Microsoft.Cci.RootModuleType : object {
    public TypeDefinitionHandle TypeDef { get; }
    public ITypeDefinition ResolvedType { get; }
    public bool MangleName { get; }
    public string Name { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsComObject { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSerializable { get; }
    public bool IsSpecialName { get; }
    public bool IsWindowsRuntimeImport { get; }
    public bool IsSealed { get; }
    public LayoutKind Layout { get; }
    public UInt32 SizeOf { get; }
    public CharSet StringFormat { get; }
    public bool IsPublic { get; }
    public bool IsNested { get; }
    private IEnumerable`1<IGenericTypeParameter> Microsoft.Cci.ITypeDefinition.GenericParameters { get; }
    private ushort Microsoft.Cci.ITypeDefinition.GenericParameterCount { get; }
    private IEnumerable`1<SecurityAttribute> Microsoft.Cci.ITypeDefinition.SecurityAttributes { get; }
    private bool Microsoft.Cci.ITypeReference.IsEnum { get; }
    private bool Microsoft.Cci.ITypeReference.IsValueType { get; }
    private ushort Microsoft.Cci.INamedTypeReference.GenericParameterCount { get; }
    private string Microsoft.Cci.INamespaceTypeReference.NamespaceName { get; }
    private IGenericMethodParameterReference Microsoft.Cci.ITypeReference.AsGenericMethodParameterReference { get; }
    private IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.AsGenericTypeInstanceReference { get; }
    private IGenericTypeParameterReference Microsoft.Cci.ITypeReference.AsGenericTypeParameterReference { get; }
    private INamespaceTypeReference Microsoft.Cci.ITypeReference.AsNamespaceTypeReference { get; }
    private INestedTypeReference Microsoft.Cci.ITypeReference.AsNestedTypeReference { get; }
    private ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.AsSpecializedNestedTypeReference { get; }
    public sealed virtual TypeDefinitionHandle get_TypeDef();
    public ITypeDefinition get_ResolvedType();
    public sealed virtual IEnumerable`1<ICustomAttribute> GetAttributes(EmitContext context);
    public sealed virtual bool get_MangleName();
    public sealed virtual string get_Name();
    public sealed virtual ushort get_Alignment();
    public sealed virtual ITypeReference GetBaseClass(EmitContext context);
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<MethodImplementation> GetExplicitImplementationOverrides(EmitContext context);
    public sealed virtual IEnumerable`1<IFieldDefinition> GetFields(EmitContext context);
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<ITypeReference> Interfaces(EmitContext context);
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsWindowsRuntimeImport();
    public sealed virtual bool get_IsSealed();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual IEnumerable`1<IMethodDefinition> GetMethods(EmitContext context);
    public sealed virtual IEnumerable`1<INestedTypeDefinition> GetNestedTypes(EmitContext context);
    public sealed virtual IEnumerable`1<IPropertyDefinition> GetProperties(EmitContext context);
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual CharSet get_StringFormat();
    public sealed virtual bool get_IsPublic();
    public bool get_IsNested();
    private sealed virtual override IEnumerable`1<IGenericTypeParameter> Microsoft.Cci.ITypeDefinition.get_GenericParameters();
    private sealed virtual override ushort Microsoft.Cci.ITypeDefinition.get_GenericParameterCount();
    private sealed virtual override IEnumerable`1<SecurityAttribute> Microsoft.Cci.ITypeDefinition.get_SecurityAttributes();
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsEnum();
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsValueType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.GetResolvedType(EmitContext context);
    private sealed virtual override PrimitiveTypeCode Microsoft.Cci.ITypeReference.TypeCode(EmitContext context);
    private sealed virtual override ushort Microsoft.Cci.INamedTypeReference.get_GenericParameterCount();
    private sealed virtual override IUnitReference Microsoft.Cci.INamespaceTypeReference.GetUnit(EmitContext context);
    private sealed virtual override string Microsoft.Cci.INamespaceTypeReference.get_NamespaceName();
    private sealed virtual override IGenericMethodParameterReference Microsoft.Cci.ITypeReference.get_AsGenericMethodParameterReference();
    private sealed virtual override IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.get_AsGenericTypeInstanceReference();
    private sealed virtual override IGenericTypeParameterReference Microsoft.Cci.ITypeReference.get_AsGenericTypeParameterReference();
    private sealed virtual override INamespaceTypeDefinition Microsoft.Cci.ITypeReference.AsNamespaceTypeDefinition(EmitContext context);
    private sealed virtual override INamespaceTypeReference Microsoft.Cci.ITypeReference.get_AsNamespaceTypeReference();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.ITypeReference.AsNestedTypeDefinition(EmitContext context);
    private sealed virtual override INestedTypeReference Microsoft.Cci.ITypeReference.get_AsNestedTypeReference();
    private sealed virtual override ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.get_AsSpecializedNestedTypeReference();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.AsTypeDefinition(EmitContext context);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
}
internal class Microsoft.Cci.SectionHeader : object {
    internal string Name;
    internal UInt32 VirtualSize;
    internal UInt32 RelativeVirtualAddress;
    internal UInt32 SizeOfRawData;
    internal UInt32 PointerToRawData;
    internal UInt32 PointerToRelocations;
    internal UInt32 PointerToLinenumbers;
    internal ushort NumberOfRelocations;
    internal ushort NumberOfLinenumbers;
    internal UInt32 Characteristics;
}
internal enum Microsoft.Cci.SecurityAction : Enum {
    public int value__;
    public static SecurityAction Undocumented;
    public static SecurityAction Demand;
    public static SecurityAction Assert;
    public static SecurityAction Deny;
    public static SecurityAction PermitOnly;
    public static SecurityAction LinkDemand;
    public static SecurityAction InheritanceDemand;
    public static SecurityAction RequestMinimum;
    public static SecurityAction RequestOptional;
    public static SecurityAction RequestRefuse;
}
internal class Microsoft.Cci.SecurityAttribute : ValueType {
    private SecurityAction _action;
    private ICustomAttribute _attribute;
    public SecurityAction Action { get; }
    public ICustomAttribute Attribute { get; }
    public SecurityAttribute(SecurityAction action, ICustomAttribute attribute);
    public SecurityAction get_Action();
    public ICustomAttribute get_Attribute();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.Cci.SequencePoint : ValueType {
    public int Offset;
    public int StartLine;
    public int StartColumn;
    public int EndLine;
    public int EndColumn;
    public DebugSourceDocument Document;
    public bool IsHidden { get; }
    public SequencePoint(DebugSourceDocument document, int offset, int startLine, int startColumn, int endLine, int endColumn);
    public bool get_IsHidden();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private string GetDebuggerDisplay();
}
internal class Microsoft.Cci.StateMachineHoistedLocalScope : ValueType {
    public int StartOffset;
    public int EndOffset;
    public int Length { get; }
    public bool IsDefault { get; }
    public StateMachineHoistedLocalScope(int startOffset, int endOffset);
    public int get_Length();
    public bool get_IsDefault();
}
internal class Microsoft.Cci.StringIdx : ValueType {
    public UInt32 VirtIdx;
    internal StringIdx(UInt32 virtIdx);
}
internal static class Microsoft.Cci.TokenTypeIds : object {
    internal static UInt32 Module;
    internal static UInt32 TypeRef;
    internal static UInt32 TypeDef;
    internal static UInt32 FieldDef;
    internal static UInt32 MethodDef;
    internal static UInt32 ParamDef;
    internal static UInt32 InterfaceImpl;
    internal static UInt32 MemberRef;
    internal static UInt32 Constant;
    internal static UInt32 CustomAttribute;
    internal static UInt32 Permission;
    internal static UInt32 Signature;
    internal static UInt32 EventMap;
    internal static UInt32 Event;
    internal static UInt32 PropertyMap;
    internal static UInt32 Property;
    internal static UInt32 MethodSemantics;
    internal static UInt32 MethodImpl;
    internal static UInt32 ModuleRef;
    internal static UInt32 TypeSpec;
    internal static UInt32 Assembly;
    internal static UInt32 AssemblyRef;
    internal static UInt32 File;
    internal static UInt32 ExportedType;
    internal static UInt32 ManifestResource;
    internal static UInt32 NestedClass;
    internal static UInt32 GenericParam;
    internal static UInt32 MethodSpec;
    internal static UInt32 GenericParamConstraint;
    internal static UInt32 UserString;
    internal static UInt32 String;
}
internal enum Microsoft.Cci.TypeFlags : Enum {
    public UInt32 value__;
    public static TypeFlags PrivateAccess;
    public static TypeFlags PublicAccess;
    public static TypeFlags NestedPublicAccess;
    public static TypeFlags NestedPrivateAccess;
    public static TypeFlags NestedFamilyAccess;
    public static TypeFlags NestedAssemblyAccess;
    public static TypeFlags NestedFamilyAndAssemblyAccess;
    public static TypeFlags NestedFamilyOrAssemblyAccess;
    public static TypeFlags AccessMask;
    public static TypeFlags NestedMask;
    public static TypeFlags AutoLayout;
    public static TypeFlags SequentialLayout;
    public static TypeFlags ExplicitLayout;
    public static TypeFlags LayoutMask;
    public static TypeFlags ClassSemantics;
    public static TypeFlags InterfaceSemantics;
    public static TypeFlags AbstractSemantics;
    public static TypeFlags SealedSemantics;
    public static TypeFlags SpecialNameSemantics;
    public static TypeFlags ImportImplementation;
    public static TypeFlags SerializableImplementation;
    public static TypeFlags WindowsRuntimeImplementation;
    public static TypeFlags BeforeFieldInitImplementation;
    public static TypeFlags ForwarderImplementation;
    public static TypeFlags AnsiString;
    public static TypeFlags UnicodeString;
    public static TypeFlags AutoCharString;
    public static TypeFlags StringMask;
    public static TypeFlags RTSpecialNameReserved;
    public static TypeFlags HasSecurityReserved;
}
[FlagsAttribute]
internal enum Microsoft.Cci.TypeLibTypeFlags : Enum {
    public int value__;
    public static TypeLibTypeFlags FAppObject;
    public static TypeLibTypeFlags FCanCreate;
    public static TypeLibTypeFlags FLicensed;
    public static TypeLibTypeFlags FPreDeclId;
    public static TypeLibTypeFlags FHidden;
    public static TypeLibTypeFlags FControl;
    public static TypeLibTypeFlags FDual;
    public static TypeLibTypeFlags FNonExtensible;
    public static TypeLibTypeFlags FOleAutomation;
    public static TypeLibTypeFlags FRestricted;
    public static TypeLibTypeFlags FAggregatable;
    public static TypeLibTypeFlags FReplaceable;
    public static TypeLibTypeFlags FDispatchable;
    public static TypeLibTypeFlags FReverseBind;
}
internal enum Microsoft.Cci.TypeMemberVisibility : Enum {
    public int value__;
    public static TypeMemberVisibility Default;
    public static TypeMemberVisibility Assembly;
    public static TypeMemberVisibility Family;
    public static TypeMemberVisibility FamilyAndAssembly;
    public static TypeMemberVisibility FamilyOrAssembly;
    public static TypeMemberVisibility Other;
    public static TypeMemberVisibility Private;
    public static TypeMemberVisibility Public;
    public static TypeMemberVisibility Mask;
}
[ExtensionAttribute]
internal static class Microsoft.Cci.TypeNameSerializer : object {
    [ExtensionAttribute]
internal static string GetSerializedTypeName(ITypeReference typeReference, EmitContext context);
    [ExtensionAttribute]
internal static string GetSerializedTypeName(ITypeReference typeReference, EmitContext context, Boolean& isAssemblyQualified);
    private static void AppendSerializedTypeName(StringBuilder sb, ITypeReference type, Boolean& isAssemQualified, EmitContext context);
    private static void AppendAssemblyQualifierIfNecessary(StringBuilder sb, ITypeReference typeReference, Boolean& isAssemQualified, EmitContext context);
    private static string GetMangledAndEscapedName(INamedTypeReference namedType);
    private static ITypeReference UnwrapTypeReference(ITypeReference typeReference, EmitContext context);
    internal static string BuildQualifiedNamespaceName(INamespace namespace);
}
internal enum Microsoft.Cci.TypeParameterVariance : Enum {
    public int value__;
    public static TypeParameterVariance NonVariant;
    public static TypeParameterVariance Covariant;
    public static TypeParameterVariance Contravariant;
    public static TypeParameterVariance Mask;
}
internal class Microsoft.Cci.TypeSpecComparer : object {
    private MetadataWriter _metadataWriter;
    internal TypeSpecComparer(MetadataWriter metadataWriter);
    public sealed virtual bool Equals(ITypeReference x, ITypeReference y);
    public sealed virtual int GetHashCode(ITypeReference typeReference);
}
internal class Microsoft.Cci.UsedNamespaceOrType : ValueType {
    public string AliasOpt;
    public IAssemblyReference TargetAssemblyOpt;
    public INamespace TargetNamespaceOpt;
    public ITypeReference TargetTypeOpt;
    public string TargetXmlNamespaceOpt;
    private UsedNamespaceOrType(string alias, IAssemblyReference targetAssembly, INamespace targetNamespace, ITypeReference targetType, string targetXmlNamespace);
    internal static UsedNamespaceOrType CreateType(ITypeReference type, string aliasOpt);
    internal static UsedNamespaceOrType CreateNamespace(INamespace namespace, IAssemblyReference assemblyOpt, string aliasOpt);
    internal static UsedNamespaceOrType CreateExternAlias(string alias);
    internal static UsedNamespaceOrType CreateXmlNamespace(string prefix, string xmlNamespace);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UsedNamespaceOrType other);
    public virtual int GetHashCode();
}
internal class Microsoft.Cci.VariantPadding : ValueType {
    public IntPtr Data2;
    public IntPtr Data3;
}
internal class Microsoft.Cci.VariantStructure : ValueType {
    private short _type;
    private long _longValue;
    private VariantPadding _padding;
    private decimal _decimalValue;
    private bool _boolValue;
    private long _intValue;
    private double _doubleValue;
    public VariantStructure(DateTime date);
}
internal abstract class Microsoft.CodeAnalysis.AbstractLookupSymbolsInfo`1 : object {
    private Dictionary`2<string, UniqueSymbolOrArities<TSymbol>> _nameMap;
    public ICollection`1<string> Names { get; }
    public int Count { get; }
    protected AbstractLookupSymbolsInfo`1(IEqualityComparer`1<string> comparer);
    public void AddSymbol(TSymbol symbol, string name, int arity);
    public ICollection`1<string> get_Names();
    public int get_Count();
    public bool TryGetAritiesAndUniqueSymbol(string name, IArityEnumerable& arities, TSymbol& uniqueSymbol);
    public void Clear();
}
internal abstract class Microsoft.CodeAnalysis.AbstractSyntaxNavigator : object {
    private static int None;
    protected abstract virtual Func`2<SyntaxTrivia, bool> GetStepIntoFunction(bool skipped, bool directives, bool docComments);
    private static Func`2<SyntaxToken, bool> GetPredicateFunction(bool includeZeroWidth);
    private static bool Matches(Func`2<SyntaxToken, bool> predicate, SyntaxToken token);
    internal SyntaxToken GetFirstToken(SyntaxNode current, bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    internal SyntaxToken GetLastToken(SyntaxNode current, bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    internal SyntaxToken GetPreviousToken(SyntaxToken current, bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    internal SyntaxToken GetNextToken(SyntaxToken current, bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    internal SyntaxToken GetPreviousToken(SyntaxToken current, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    internal SyntaxToken GetNextToken(SyntaxToken current, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    internal SyntaxToken GetFirstToken(SyntaxNode current, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    internal SyntaxToken GetLastToken(SyntaxNode current, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    private SyntaxToken GetFirstToken(SyntaxTriviaList triviaList, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    private SyntaxToken GetLastToken(SyntaxTriviaList list, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    private bool TryGetLastTokenForStructuredTrivia(SyntaxTrivia trivia, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto, SyntaxToken& token);
    private SyntaxToken GetFirstToken(SyntaxToken token, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    private SyntaxToken GetLastToken(SyntaxToken token, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    internal SyntaxToken GetNextToken(SyntaxTrivia current, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    internal SyntaxToken GetPreviousToken(SyntaxTrivia current, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    private SyntaxToken GetNextToken(SyntaxTrivia current, SyntaxTriviaList list, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto, Boolean& returnNext);
    private SyntaxToken GetPreviousToken(SyntaxTrivia current, SyntaxTriviaList list, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto, Boolean& returnPrevious);
    internal SyntaxToken GetNextToken(SyntaxNode node, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    internal SyntaxToken GetPreviousToken(SyntaxNode node, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    internal SyntaxToken GetNextToken(SyntaxToken current, Func`2<SyntaxToken, bool> predicate, bool searchInsideCurrentTokenTrailingTrivia, Func`2<SyntaxTrivia, bool> stepInto);
    internal SyntaxToken GetPreviousToken(SyntaxToken current, Func`2<SyntaxToken, bool> predicate, bool searchInsideCurrentTokenLeadingTrivia, Func`2<SyntaxTrivia, bool> stepInto);
}
public enum Microsoft.CodeAnalysis.Accessibility : Enum {
    public int value__;
    public static Accessibility NotApplicable;
    public static Accessibility Private;
    public static Accessibility ProtectedAndInternal;
    public static Accessibility ProtectedAndFriend;
    public static Accessibility Protected;
    public static Accessibility Internal;
    public static Accessibility Friend;
    public static Accessibility ProtectedOrInternal;
    public static Accessibility ProtectedOrFriend;
    public static Accessibility Public;
}
public abstract class Microsoft.CodeAnalysis.AdditionalText : object {
    public string Path { get; }
    public abstract virtual string get_Path();
    public abstract virtual SourceText GetText(CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.AdditionalTextFile : AdditionalText {
    private CommandLineSourceFile _sourceFile;
    private CommonCompiler _compiler;
    private SourceText _text;
    private IList`1<DiagnosticInfo> _diagnostics;
    private object _lockObject;
    public string Path { get; }
    internal IList`1<DiagnosticInfo> Diagnostics { get; }
    public AdditionalTextFile(CommandLineSourceFile sourceFile, CommonCompiler compiler);
    public virtual string get_Path();
    public virtual SourceText GetText(CancellationToken cancellationToken);
    internal IList`1<DiagnosticInfo> get_Diagnostics();
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.AnnotationExtensions : object {
    [ExtensionAttribute]
public static TNode WithAdditionalAnnotations(TNode node, SyntaxAnnotation[] annotations);
    [ExtensionAttribute]
public static TNode WithAdditionalAnnotations(TNode node, IEnumerable`1<SyntaxAnnotation> annotations);
    [ExtensionAttribute]
public static TNode WithoutAnnotations(TNode node, SyntaxAnnotation[] annotations);
    [ExtensionAttribute]
public static TNode WithoutAnnotations(TNode node, IEnumerable`1<SyntaxAnnotation> annotations);
    [ExtensionAttribute]
public static TNode WithoutAnnotations(TNode node, string annotationKind);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count,nq}")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.ArrayBuilder`1/DebuggerProxy")]
internal class Microsoft.CodeAnalysis.ArrayBuilder`1 : object {
    private Builder<T> _builder;
    private ObjectPool`1<ArrayBuilder`1<T>> _pool;
    private static ObjectPool`1<ArrayBuilder`1<T>> s_poolInstance;
    public int Count { get; }
    public T Item { get; public set; }
    public ArrayBuilder`1(int size);
    private ArrayBuilder`1(ObjectPool`1<ArrayBuilder`1<T>> pool);
    private static ArrayBuilder`1();
    public ImmutableArray`1<T> ToImmutable();
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public void set_Item(int index, T value);
    public void Add(T item);
    public void Insert(int index, T item);
    public void EnsureCapacity(int capacity);
    public void Clear();
    public bool Contains(T item);
    public int IndexOf(T item);
    public void RemoveAt(int index);
    public void RemoveLast();
    public void ReverseContents();
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(int startIndex, IComparer`1<T> comparer);
    public T[] ToArray();
    public void CopyTo(T[] array, int start);
    public T Last();
    public T First();
    public bool Any();
    public ImmutableArray`1<T> ToImmutableOrNull();
    public ImmutableArray`1<U> ToDowncastedImmutable();
    public ImmutableArray`1<T> ToImmutableAndFree();
    public T[] ToArrayAndFree();
    public void Free();
    public static ArrayBuilder`1<T> GetInstance();
    public static ArrayBuilder`1<T> GetInstance(int capacity);
    public static ArrayBuilder`1<T> GetInstance(int capacity, T fillWithValue);
    public static ObjectPool`1<ArrayBuilder`1<T>> CreatePool();
    public static ObjectPool`1<ArrayBuilder`1<T>> CreatePool(int size);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal Dictionary`2<K, ImmutableArray`1<T>> ToDictionary(Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
    public void AddRange(ArrayBuilder`1<T> items);
    public void AddRange(ArrayBuilder`1<U> items);
    public void AddRange(ImmutableArray`1<T> items);
    public void AddRange(ImmutableArray`1<T> items, int length);
    public void AddRange(IEnumerable`1<T> items);
    public void AddRange(T[] items);
    public void AddRange(T[] items, int length);
    public void Clip(int limit);
    public void ZeroInit(int count);
    public void AddMany(T item, int count);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ArrayBuilderExtensions : object {
    [ExtensionAttribute]
public static bool Any(ArrayBuilder`1<T> builder, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool All(ArrayBuilder`1<T> builder, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ArrayBuilder`1<TItem> items, Func`2<TItem, TResult> map);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ArrayBuilder`1<TItem> items, Func`3<TItem, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static void AddOptional(ArrayBuilder`1<T> builder, T item);
    [ExtensionAttribute]
public static void Push(ArrayBuilder`1<T> builder, T e);
    [ExtensionAttribute]
public static T Pop(ArrayBuilder`1<T> builder);
    [ExtensionAttribute]
public static T Peek(ArrayBuilder`1<T> builder);
}
[DebuggerDisplayAttribute("{Value,nq}")]
internal class Microsoft.CodeAnalysis.ArrayElement`1 : ValueType {
    internal T Value;
    public static T op_Implicit(ArrayElement`1<T> element);
    public static ArrayElement`1[] MakeElementArray(T[] items);
    public static T[] MakeArray(ArrayElement`1[] items);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.AssemblyIdentity : object {
    private AssemblyContentType _contentType;
    private string _name;
    private Version _version;
    private string _cultureName;
    private ImmutableArray`1<byte> _publicKey;
    private ImmutableArray`1<byte> _lazyPublicKeyToken;
    private bool _isRetargetable;
    private string _lazyDisplayName;
    private int _lazyHashCode;
    internal static int PublicKeyTokenSize;
    internal static Version NullVersion;
    private static int MaxPublicKeyBytes;
    private static int PublicKeyTokenBytes;
    public string Name { get; }
    public Version Version { get; }
    public string CultureName { get; }
    public AssemblyNameFlags Flags { get; }
    public AssemblyContentType ContentType { get; }
    public bool HasPublicKey { get; }
    public ImmutableArray`1<byte> PublicKey { get; }
    public ImmutableArray`1<byte> PublicKeyToken { get; }
    public bool IsStrongName { get; }
    public bool IsRetargetable { get; }
    public AssemblyIdentity(string name, Version version, string cultureName, ImmutableArray`1<byte> publicKeyOrToken, bool hasPublicKey, bool isRetargetable, AssemblyContentType contentType);
    internal AssemblyIdentity(string name, Version version, string cultureName, ImmutableArray`1<byte> publicKeyOrToken, bool hasPublicKey);
    internal AssemblyIdentity(string name, Version version, string cultureName, ImmutableArray`1<byte> publicKeyOrToken, bool hasPublicKey, bool isRetargetable, AssemblyContentType contentType, bool noThrow);
    private static AssemblyIdentity();
    private static void InitializeKey(ImmutableArray`1<byte> publicKeyOrToken, bool hasPublicKey, ImmutableArray`1& publicKey, ImmutableArray`1& publicKeyToken);
    internal static bool IsValidCultureName(string name);
    private static bool IsValidName(string name);
    private static bool IsValid(Version value);
    private static bool IsValid(AssemblyContentType value);
    public string get_Name();
    public Version get_Version();
    public string get_CultureName();
    public AssemblyNameFlags get_Flags();
    public AssemblyContentType get_ContentType();
    public bool get_HasPublicKey();
    public ImmutableArray`1<byte> get_PublicKey();
    public ImmutableArray`1<byte> get_PublicKeyToken();
    public bool get_IsStrongName();
    public bool get_IsRetargetable();
    internal static bool IsFullName(AssemblyIdentityParts parts);
    public static bool op_Equality(AssemblyIdentity left, AssemblyIdentity right);
    public static bool op_Inequality(AssemblyIdentity left, AssemblyIdentity right);
    public sealed virtual bool Equals(AssemblyIdentity obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal static ImmutableArray`1<byte> CalculatePublicKeyToken(ImmutableArray`1<byte> publicKey);
    internal static Nullable`1<bool> MemberwiseEqual(AssemblyIdentity x, AssemblyIdentity y);
    internal static bool KeysEqual(AssemblyIdentity x, AssemblyIdentity y);
    public static AssemblyIdentity FromAssemblyDefinition(Assembly assembly);
    internal static AssemblyIdentity FromAssemblyDefinition(AssemblyName name);
    public string GetDisplayName(bool fullKey);
    public virtual string ToString();
    private string BuildDisplayName(bool fullKey);
    private static void AppendKey(StringBuilder sb, ImmutableArray`1<byte> key);
    private string GetDebuggerDisplay();
    public static bool TryParseDisplayName(string displayName, AssemblyIdentity& identity);
    public static bool TryParseDisplayName(string displayName, AssemblyIdentity& identity, AssemblyIdentityParts& parts);
    private static bool TryParseNameToken(string displayName, Int32& position, String& value);
    private static bool IsNameTokenTerminator(char c);
    private static bool IsQuote(char c);
    internal static Version ToVersion(ulong version);
    internal static bool TryParseVersion(string str, UInt64& result, AssemblyIdentityParts& parts);
    private static bool TryParsePublicKey(string value, ImmutableArray`1& key);
    private static bool TryParsePublicKeyToken(string value, ImmutableArray`1& token);
    private static bool TryParseHexBytes(string value, ImmutableArray`1& result);
    internal static int HexValue(char c);
    private static bool IsWhiteSpace(char c);
    private static void EscapeName(StringBuilder result, string name);
    private static bool TryUnescape(string str, int start, int end, String& value);
    private static bool Unescape(StringBuilder sb, string str, Int32& i);
}
public class Microsoft.CodeAnalysis.AssemblyIdentityComparer : object {
    [CompilerGeneratedAttribute]
private static AssemblyIdentityComparer <Default>k__BackingField;
    public static AssemblyIdentityComparer Default { get; }
    public static StringComparer SimpleNameComparer { get; }
    public static StringComparer CultureComparer { get; }
    private static AssemblyIdentityComparer();
    [CompilerGeneratedAttribute]
public static AssemblyIdentityComparer get_Default();
    public static StringComparer get_SimpleNameComparer();
    public static StringComparer get_CultureComparer();
    public bool ReferenceMatchesDefinition(string referenceDisplayName, AssemblyIdentity definition);
    public bool ReferenceMatchesDefinition(AssemblyIdentity reference, AssemblyIdentity definition);
    public ComparisonResult Compare(AssemblyIdentity reference, AssemblyIdentity definition);
    internal ComparisonResult Compare(AssemblyIdentity reference, string referenceDisplayName, AssemblyIdentity definition, Boolean& unificationApplied, bool ignoreVersion);
    private static Nullable`1<bool> TriviallyEquivalent(AssemblyIdentity x, AssemblyIdentity y);
    internal virtual bool ApplyUnificationPolicies(AssemblyIdentity& reference, AssemblyIdentity& definition, AssemblyIdentityParts referenceParts, Boolean& isFxAssembly);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.AssemblyIdentityExtensions : object {
    [ExtensionAttribute]
internal static bool IsWindowsComponent(AssemblyIdentity identity);
    [ExtensionAttribute]
internal static bool IsWindowsRuntime(AssemblyIdentity identity);
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.AssemblyIdentityParts : Enum {
    public int value__;
    public static AssemblyIdentityParts Name;
    public static AssemblyIdentityParts Version;
    public static AssemblyIdentityParts VersionMajor;
    public static AssemblyIdentityParts VersionMinor;
    public static AssemblyIdentityParts VersionBuild;
    public static AssemblyIdentityParts VersionRevision;
    public static AssemblyIdentityParts Culture;
    public static AssemblyIdentityParts PublicKey;
    public static AssemblyIdentityParts PublicKeyToken;
    public static AssemblyIdentityParts PublicKeyOrToken;
    public static AssemblyIdentityParts Retargetability;
    public static AssemblyIdentityParts ContentType;
    public static AssemblyIdentityParts Unknown;
}
public class Microsoft.CodeAnalysis.AssemblyMetadata : Metadata {
    private Func`2<string, ModuleMetadata> _moduleFactoryOpt;
    private ImmutableArray`1<ModuleMetadata> _initialModules;
    private Data _lazyData;
    private ImmutableArray`1<ModuleMetadata> _lazyPublishedModules;
    internal WeakList`1<IAssemblySymbol> CachedSymbols;
    public MetadataImageKind Kind { get; }
    private AssemblyMetadata(AssemblyMetadata other);
    internal AssemblyMetadata(ImmutableArray`1<ModuleMetadata> modules);
    internal AssemblyMetadata(ModuleMetadata manifestModule, Func`2<string, ModuleMetadata> moduleFactory);
    public static AssemblyMetadata CreateFromImage(ImmutableArray`1<byte> peImage);
    public static AssemblyMetadata CreateFromImage(IEnumerable`1<byte> peImage);
    public static AssemblyMetadata CreateFromStream(Stream peStream, bool leaveOpen);
    public static AssemblyMetadata CreateFromStream(Stream peStream, PEStreamOptions options);
    public static AssemblyMetadata CreateFromFile(string path);
    internal static AssemblyMetadata CreateFromFile(ModuleMetadata manifestModule, string path);
    public static AssemblyMetadata Create(ModuleMetadata module);
    public static AssemblyMetadata Create(ImmutableArray`1<ModuleMetadata> modules);
    public static AssemblyMetadata Create(IEnumerable`1<ModuleMetadata> modules);
    public static AssemblyMetadata Create(ModuleMetadata[] modules);
    internal AssemblyMetadata Copy();
    protected virtual Metadata CommonCopy();
    public ImmutableArray`1<ModuleMetadata> GetModules();
    internal PEAssembly GetAssembly();
    private Data GetOrCreateData();
    public virtual void Dispose();
    internal bool IsValidAssembly();
    public virtual MetadataImageKind get_Kind();
    public PortableExecutableReference GetReference(DocumentationProvider documentation, ImmutableArray`1<string> aliases, bool embedInteropTypes, string filePath, string display);
}
internal class Microsoft.CodeAnalysis.AssemblyPortabilityPolicy : ValueType {
    public bool SuppressSilverlightPlatformAssembliesPortability;
    public bool SuppressSilverlightLibraryAssembliesPortability;
    private static XmlReaderSettings s_xmlSettings;
    public AssemblyPortabilityPolicy(bool suppressSilverlightPlatformAssembliesPortability, bool suppressSilverlightLibraryAssembliesPortability);
    private static AssemblyPortabilityPolicy();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AssemblyPortabilityPolicy other);
    public virtual int GetHashCode();
    private static bool ReadToChild(XmlReader reader, int depth, string elementName, string elementNamespace);
    internal static AssemblyPortabilityPolicy LoadFromXml(Stream input);
}
internal class Microsoft.CodeAnalysis.AssemblyReferenceResolver : MetadataReferenceResolver {
    internal MetadataFileReferenceResolver PathResolver;
    internal MetadataFileReferenceProvider Provider;
    public AssemblyReferenceResolver(MetadataFileReferenceResolver pathResolver, MetadataFileReferenceProvider provider);
    public virtual ImmutableArray`1<PortableExecutableReference> ResolveReference(string reference, string baseFilePath, MetadataReferenceProperties properties);
    public virtual bool Equals(object other);
    public bool Equals(AssemblyReferenceResolver other);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.AssemblyVersion : ValueType {
    private ushort _major;
    private ushort _minor;
    private ushort _build;
    private ushort _revision;
    public int Major { get; }
    public int Minor { get; }
    public int Build { get; }
    public int Revision { get; }
    public AssemblyVersion(ushort major, ushort minor, ushort build, ushort revision);
    public int get_Major();
    public int get_Minor();
    public int get_Build();
    public int get_Revision();
    private ulong ToInteger();
    public sealed virtual int CompareTo(AssemblyVersion other);
    public sealed virtual bool Equals(AssemblyVersion other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyVersion left, AssemblyVersion right);
    public static bool op_Inequality(AssemblyVersion left, AssemblyVersion right);
    public static bool op_LessThan(AssemblyVersion left, AssemblyVersion right);
    public static bool op_LessThanOrEqual(AssemblyVersion left, AssemblyVersion right);
    public static bool op_GreaterThan(AssemblyVersion left, AssemblyVersion right);
    public static bool op_GreaterThanOrEqual(AssemblyVersion left, AssemblyVersion right);
    public static AssemblyVersion op_Explicit(Version version);
    public static Version op_Explicit(AssemblyVersion version);
}
public abstract class Microsoft.CodeAnalysis.AttributeData : object {
    public INamedTypeSymbol AttributeClass { get; }
    protected INamedTypeSymbol CommonAttributeClass { get; }
    public IMethodSymbol AttributeConstructor { get; }
    protected IMethodSymbol CommonAttributeConstructor { get; }
    public SyntaxReference ApplicationSyntaxReference { get; }
    protected SyntaxReference CommonApplicationSyntaxReference { get; }
    public ImmutableArray`1<TypedConstant> ConstructorArguments { get; }
    protected internal ImmutableArray`1<TypedConstant> CommonConstructorArguments { get; }
    public ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> NamedArguments { get; }
    protected internal ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> CommonNamedArguments { get; }
    internal bool IsConditionallyOmitted { get; }
    internal bool HasErrors { get; }
    public INamedTypeSymbol get_AttributeClass();
    protected abstract virtual INamedTypeSymbol get_CommonAttributeClass();
    public IMethodSymbol get_AttributeConstructor();
    protected abstract virtual IMethodSymbol get_CommonAttributeConstructor();
    public SyntaxReference get_ApplicationSyntaxReference();
    protected abstract virtual SyntaxReference get_CommonApplicationSyntaxReference();
    public ImmutableArray`1<TypedConstant> get_ConstructorArguments();
    protected internal abstract virtual ImmutableArray`1<TypedConstant> get_CommonConstructorArguments();
    public ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> get_NamedArguments();
    protected internal abstract virtual ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> get_CommonNamedArguments();
    internal virtual bool get_IsConditionallyOmitted();
    internal virtual bool get_HasErrors();
    internal static bool IsTargetEarlyAttribute(INamedTypeSymbol attributeType, int attributeArgCount, AttributeDescription description);
    internal T GetConstructorArgument(int i, SpecialType specialType);
    internal T DecodeNamedArgument(string name, SpecialType specialType, T defaultValue);
    private static T DecodeNamedArgument(ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArguments, string name, SpecialType specialType, T defaultValue);
    private static int IndexOfNamedArgument(ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArguments, string name);
    internal ConstantValue DecodeDecimalConstantValue();
    internal ConstantValue DecodeDateTimeConstantValue();
    internal ObsoleteAttributeData DecodeObsoleteAttribute();
    internal ObsoleteAttributeData DecodeDeprecatedAttribute();
    internal static void DecodeMethodImplAttribute(DecodeWellKnownAttributeArguments`3& arguments, CommonMessageProvider messageProvider);
    internal static void DecodeStructLayoutAttribute(DecodeWellKnownAttributeArguments`3& arguments, CharSet defaultCharSet, int defaultAutoLayoutSize, CommonMessageProvider messageProvider);
    internal AttributeUsageInfo DecodeAttributeUsageAttribute();
    internal static AttributeUsageInfo DecodeAttributeUsageAttribute(TypedConstant positionalArg, ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArgs);
}
internal class Microsoft.CodeAnalysis.AttributeDescription : ValueType {
    public string Namespace;
    public string Name;
    public Byte[][] Signatures;
    public bool MatchIgnoringCase;
    private static byte Void;
    private static byte Boolean;
    private static byte Char;
    private static byte SByte;
    private static byte Byte;
    private static byte Int16;
    private static byte UInt16;
    private static byte Int32;
    private static byte UInt32;
    private static byte Int64;
    private static byte UInt64;
    private static byte Single;
    private static byte Double;
    private static byte String;
    private static byte Object;
    private static byte SzArray;
    private static byte TypeHandle;
    internal static ImmutableArray`1<TypeHandleTargetInfo> TypeHandleTargets;
    private static Byte[] s_signature_HasThis_Void;
    private static Byte[] s_signature_HasThis_Void_Int16;
    private static Byte[] s_signature_HasThis_Void_Int32;
    private static Byte[] s_signature_HasThis_Void_Int32_Int32_Int32;
    private static Byte[] s_signature_HasThis_Void_UInt32;
    private static Byte[] s_signature_HasThis_Void_Int32_Int32;
    private static Byte[] s_signature_HasThis_Void_Int32_Int32_Int32_Int32;
    private static Byte[] s_signature_HasThis_Void_String;
    private static Byte[] s_signature_HasThis_Void_Object;
    private static Byte[] s_signature_HasThis_Void_String_String;
    private static Byte[] s_signature_HasThis_Void_String_Boolean;
    private static Byte[] s_signature_HasThis_Void_String_String_String;
    private static Byte[] s_signature_HasThis_Void_String_String_String_String;
    private static Byte[] s_signature_HasThis_Void_AttributeTargets;
    private static Byte[] s_signature_HasThis_Void_AssemblyNameFlags;
    private static Byte[] s_signature_HasThis_Void_MethodImplOptions;
    private static Byte[] s_signature_HasThis_Void_CharSet;
    private static Byte[] s_signature_HasThis_Void_LayoutKind;
    private static Byte[] s_signature_HasThis_Void_UnmanagedType;
    private static Byte[] s_signature_HasThis_Void_TypeLibTypeFlags;
    private static Byte[] s_signature_HasThis_Void_ClassInterfaceType;
    private static Byte[] s_signature_HasThis_Void_ComInterfaceType;
    private static Byte[] s_signature_HasThis_Void_CompilationRelaxations;
    private static Byte[] s_signature_HasThis_Void_DebuggingModes;
    private static Byte[] s_signature_HasThis_Void_SecurityCriticalScope;
    private static Byte[] s_signature_HasThis_Void_CallingConvention;
    private static Byte[] s_signature_HasThis_Void_AssemblyHashAlgorithm;
    private static Byte[] s_signature_HasThis_Void_Int64;
    private static Byte[] s_signature_HasThis_Void_UInt8_UInt8_UInt32_UInt32_UInt32;
    private static Byte[] s_signature_HasThis_Void_UIn8_UInt8_Int32_Int32_Int32;
    private static Byte[] s_signature_HasThis_Void_Boolean;
    private static Byte[] s_signature_HasThis_Void_Boolean_Boolean;
    private static Byte[] s_signature_HasThis_Void_Boolean_TransactionOption;
    private static Byte[] s_signature_HasThis_Void_Boolean_TransactionOption_Int32;
    private static Byte[] s_signature_HasThis_Void_Boolean_TransactionOption_Int32_Boolean;
    private static Byte[] s_signature_HasThis_Void_SecurityAction;
    private static Byte[] s_signature_HasThis_Void_Type;
    private static Byte[] s_signature_HasThis_Void_Type_Type;
    private static Byte[] s_signature_HasThis_Void_Type_Type_Type;
    private static Byte[] s_signature_HasThis_Void_Type_Type_Type_Type;
    private static Byte[] s_signature_HasThis_Void_Type_Int32;
    private static Byte[] s_signature_HasThis_Void_SzArray_Boolean;
    private static Byte[] s_signature_HasThis_Void_String_DeprecationType_UInt32;
    private static Byte[] s_signature_HasThis_Void_String_DeprecationType_UInt32_Platform;
    private static Byte[] s_signature_HasThis_Void_String_DeprecationType_UInt32_Type;
    private static Byte[][] s_signaturesOfTypeIdentifierAttribute;
    private static Byte[][] s_signaturesOfStandardModuleAttribute;
    private static Byte[][] s_signaturesOfExtensionAttribute;
    private static Byte[][] s_signaturesOfAttributeUsage;
    private static Byte[][] s_signaturesOfAssemblySignatureKeyAttribute;
    private static Byte[][] s_signaturesOfAssemblyKeyFileAttribute;
    private static Byte[][] s_signaturesOfAssemblyKeyNameAttribute;
    private static Byte[][] s_signaturesOfAssemblyDelaySignAttribute;
    private static Byte[][] s_signaturesOfAssemblyVersionAttribute;
    private static Byte[][] s_signaturesOfAssemblyFileVersionAttribute;
    private static Byte[][] s_signaturesOfAssemblyTitleAttribute;
    private static Byte[][] s_signaturesOfAssemblyDescriptionAttribute;
    private static Byte[][] s_signaturesOfAssemblyCultureAttribute;
    private static Byte[][] s_signaturesOfAssemblyCompanyAttribute;
    private static Byte[][] s_signaturesOfAssemblyProductAttribute;
    private static Byte[][] s_signaturesOfAssemblyInformationalVersionAttribute;
    private static Byte[][] s_signaturesOfAssemblyCopyrightAttribute;
    private static Byte[][] s_signaturesOfSatelliteContractVersionAttribute;
    private static Byte[][] s_signaturesOfAssemblyTrademarkAttribute;
    private static Byte[][] s_signaturesOfAssemblyFlagsAttribute;
    private static Byte[][] s_signaturesOfDefaultMemberAttribute;
    private static Byte[][] s_signaturesOfAccessedThroughPropertyAttribute;
    private static Byte[][] s_signaturesOfIndexerNameAttribute;
    private static Byte[][] s_signaturesOfInternalsVisibleToAttribute;
    private static Byte[][] s_signaturesOfOptionalAttribute;
    private static Byte[][] s_signaturesOfDefaultParameterValueAttribute;
    private static Byte[][] s_signaturesOfDateTimeConstantAttribute;
    private static Byte[][] s_signaturesOfDecimalConstantAttribute;
    private static Byte[][] s_signaturesOfIUnknownConstantAttribute;
    private static Byte[][] s_signaturesOfCallerFilePathAttribute;
    private static Byte[][] s_signaturesOfCallerLineNumberAttribute;
    private static Byte[][] s_signaturesOfCallerMemberNameAttribute;
    private static Byte[][] s_signaturesOfIDispatchConstantAttribute;
    private static Byte[][] s_signaturesOfParamArrayAttribute;
    private static Byte[][] s_signaturesOfDllImportAttribute;
    private static Byte[][] s_signaturesOfUnverifiableCodeAttribute;
    private static Byte[][] s_signaturesOfSecurityPermissionAttribute;
    private static Byte[][] s_signaturesOfCoClassAttribute;
    private static Byte[][] s_signaturesOfComImportAttribute;
    private static Byte[][] s_signaturesOfGuidAttribute;
    private static Byte[][] s_signaturesOfCLSCompliantAttribute;
    private static Byte[][] s_signaturesOfMethodImplAttribute;
    private static Byte[][] s_signaturesOfPreserveSigAttribute;
    private static Byte[][] s_signaturesOfDefaultCharSetAttribute;
    private static Byte[][] s_signaturesOfSpecialNameAttribute;
    private static Byte[][] s_signaturesOfNonSerializedAttribute;
    private static Byte[][] s_signaturesOfFieldOffsetAttribute;
    private static Byte[][] s_signaturesOfSerializableAttribute;
    private static Byte[][] s_signaturesOfInAttribute;
    private static Byte[][] s_signaturesOfOutAttribute;
    private static Byte[][] s_signaturesOfFixedBufferAttribute;
    private static Byte[][] s_signaturesOfSuppressUnmanagedCodeSecurityAttribute;
    private static Byte[][] s_signaturesOfPrincipalPermissionAttribute;
    private static Byte[][] s_signaturesOfPermissionSetAttribute;
    private static Byte[][] s_signaturesOfStructLayoutAttribute;
    private static Byte[][] s_signaturesOfMarshalAsAttribute;
    private static Byte[][] s_signaturesOfTypeLibTypeAttribute;
    private static Byte[][] s_signaturesOfWebMethodAttribute;
    private static Byte[][] s_signaturesOfHostProtectionAttribute;
    private static Byte[][] s_signaturesOfVisualBasicEmbedded;
    private static Byte[][] s_signaturesOfVisualBasicComClassAttribute;
    private static Byte[][] s_signaturesOfClassInterfaceAttribute;
    private static Byte[][] s_signaturesOfInterfaceTypeAttribute;
    private static Byte[][] s_signaturesOfCompilationRelaxationsAttribute;
    private static Byte[][] s_signaturesOfDebuggableAttribute;
    private static Byte[][] s_signaturesOfComSourceInterfacesAttribute;
    private static Byte[][] s_signaturesOfComVisibleAttribute;
    private static Byte[][] s_signaturesOfConditionalAttribute;
    private static Byte[][] s_signaturesOfTypeLibVersionAttribute;
    private static Byte[][] s_signaturesOfComCompatibleVersionAttribute;
    private static Byte[][] s_signaturesOfWindowsRuntimeImportAttribute;
    private static Byte[][] s_signaturesOfDynamicSecurityMethodAttribute;
    private static Byte[][] s_signaturesOfRequiredAttributeAttribute;
    private static Byte[][] s_signaturesOfAsyncStateMachineAttribute;
    private static Byte[][] s_signaturesOfIteratorStateMachineAttribute;
    private static Byte[][] s_signaturesOfRuntimeCompatibilityAttribute;
    private static Byte[][] s_signaturesOfTypeForwardedToAttribute;
    private static Byte[][] s_signaturesOfSTAThreadAttribute;
    private static Byte[][] s_signaturesOfMTAThreadAttribute;
    private static Byte[][] s_signaturesOfOptionCompareAttribute;
    private static Byte[][] s_signaturesOfObsoleteAttribute;
    private static Byte[][] s_signaturesOfDynamicAttribute;
    private static Byte[][] s_signaturesOfDebuggerHiddenAttribute;
    private static Byte[][] s_signaturesOfDebuggerNonUserCodeAttribute;
    private static Byte[][] s_signaturesOfDebuggerStepperBoundaryAttribute;
    private static Byte[][] s_signaturesOfDebuggerStepThroughAttribute;
    private static Byte[][] s_signaturesOfSecurityCriticalAttribute;
    private static Byte[][] s_signaturesOfSecuritySafeCriticalAttribute;
    private static Byte[][] s_signaturesOfDesignerGeneratedAttribute;
    private static Byte[][] s_signaturesOfMyGroupCollectionAttribute;
    private static Byte[][] s_signaturesOfComEventInterfaceAttribute;
    private static Byte[][] s_signaturesOfBestFitMappingAttribute;
    private static Byte[][] s_signaturesOfFlagsAttribute;
    private static Byte[][] s_signaturesOfLCIDConversionAttribute;
    private static Byte[][] s_signaturesOfUnmanagedFunctionPointerAttribute;
    private static Byte[][] s_signaturesOfPrimaryInteropAssemblyAttribute;
    private static Byte[][] s_signaturesOfImportedFromTypeLibAttribute;
    private static Byte[][] s_signaturesOfDefaultEventAttribute;
    private static Byte[][] s_signaturesOfAssemblyConfigurationAttribute;
    private static Byte[][] s_signaturesOfAssemblyAlgorithmIdAttribute;
    private static Byte[][] s_signaturesOfDeprecatedAttribute;
    internal static AttributeDescription OptionalAttribute;
    internal static AttributeDescription ComImportAttribute;
    internal static AttributeDescription AttributeUsageAttribute;
    internal static AttributeDescription ConditionalAttribute;
    internal static AttributeDescription CaseInsensitiveExtensionAttribute;
    internal static AttributeDescription CaseSensitiveExtensionAttribute;
    internal static AttributeDescription InternalsVisibleToAttribute;
    internal static AttributeDescription AssemblySignatureKeyAttribute;
    internal static AttributeDescription AssemblyKeyFileAttribute;
    internal static AttributeDescription AssemblyKeyNameAttribute;
    internal static AttributeDescription ParamArrayAttribute;
    internal static AttributeDescription DefaultMemberAttribute;
    internal static AttributeDescription IndexerNameAttribute;
    internal static AttributeDescription AssemblyDelaySignAttribute;
    internal static AttributeDescription AssemblyVersionAttribute;
    internal static AttributeDescription AssemblyFileVersionAttribute;
    internal static AttributeDescription AssemblyTitleAttribute;
    internal static AttributeDescription AssemblyDescriptionAttribute;
    internal static AttributeDescription AssemblyCultureAttribute;
    internal static AttributeDescription AssemblyCompanyAttribute;
    internal static AttributeDescription AssemblyProductAttribute;
    internal static AttributeDescription AssemblyInformationalVersionAttribute;
    internal static AttributeDescription AssemblyCopyrightAttribute;
    internal static AttributeDescription SatelliteContractVersionAttribute;
    internal static AttributeDescription AssemblyTrademarkAttribute;
    internal static AttributeDescription AssemblyFlagsAttribute;
    internal static AttributeDescription DecimalConstantAttribute;
    internal static AttributeDescription IUnknownConstantAttribute;
    internal static AttributeDescription CallerFilePathAttribute;
    internal static AttributeDescription CallerLineNumberAttribute;
    internal static AttributeDescription CallerMemberNameAttribute;
    internal static AttributeDescription IDispatchConstantAttribute;
    internal static AttributeDescription DefaultParameterValueAttribute;
    internal static AttributeDescription UnverifiableCodeAttribute;
    internal static AttributeDescription SecurityPermissionAttribute;
    internal static AttributeDescription DllImportAttribute;
    internal static AttributeDescription MethodImplAttribute;
    internal static AttributeDescription PreserveSigAttribute;
    internal static AttributeDescription DefaultCharSetAttribute;
    internal static AttributeDescription SpecialNameAttribute;
    internal static AttributeDescription SerializableAttribute;
    internal static AttributeDescription NonSerializedAttribute;
    internal static AttributeDescription StructLayoutAttribute;
    internal static AttributeDescription FieldOffsetAttribute;
    internal static AttributeDescription FixedBufferAttribute;
    internal static AttributeDescription MarshalAsAttribute;
    internal static AttributeDescription InAttribute;
    internal static AttributeDescription OutAttribute;
    internal static AttributeDescription CoClassAttribute;
    internal static AttributeDescription GuidAttribute;
    internal static AttributeDescription CLSCompliantAttribute;
    internal static AttributeDescription HostProtectionAttribute;
    internal static AttributeDescription SuppressUnmanagedCodeSecurityAttribute;
    internal static AttributeDescription PrincipalPermissionAttribute;
    internal static AttributeDescription PermissionSetAttribute;
    internal static AttributeDescription TypeIdentifierAttribute;
    internal static AttributeDescription VisualBasicEmbeddedAttribute;
    internal static AttributeDescription VisualBasicComClassAttribute;
    internal static AttributeDescription StandardModuleAttribute;
    internal static AttributeDescription OptionCompareAttribute;
    internal static AttributeDescription AccessedThroughPropertyAttribute;
    internal static AttributeDescription WebMethodAttribute;
    internal static AttributeDescription DateTimeConstantAttribute;
    internal static AttributeDescription ClassInterfaceAttribute;
    internal static AttributeDescription ComSourceInterfacesAttribute;
    internal static AttributeDescription ComVisibleAttribute;
    internal static AttributeDescription DispIdAttribute;
    internal static AttributeDescription TypeLibVersionAttribute;
    internal static AttributeDescription ComCompatibleVersionAttribute;
    internal static AttributeDescription InterfaceTypeAttribute;
    internal static AttributeDescription WindowsRuntimeImportAttribute;
    internal static AttributeDescription DynamicSecurityMethodAttribute;
    internal static AttributeDescription RequiredAttributeAttribute;
    internal static AttributeDescription AsyncStateMachineAttribute;
    internal static AttributeDescription IteratorStateMachineAttribute;
    internal static AttributeDescription CompilationRelaxationsAttribute;
    internal static AttributeDescription RuntimeCompatibilityAttribute;
    internal static AttributeDescription DebuggableAttribute;
    internal static AttributeDescription TypeForwardedToAttribute;
    internal static AttributeDescription STAThreadAttribute;
    internal static AttributeDescription MTAThreadAttribute;
    internal static AttributeDescription ObsoleteAttribute;
    internal static AttributeDescription TypeLibTypeAttribute;
    internal static AttributeDescription DynamicAttribute;
    internal static AttributeDescription DebuggerHiddenAttribute;
    internal static AttributeDescription DebuggerNonUserCodeAttribute;
    internal static AttributeDescription DebuggerStepperBoundaryAttribute;
    internal static AttributeDescription DebuggerStepThroughAttribute;
    internal static AttributeDescription SecurityCriticalAttribute;
    internal static AttributeDescription SecuritySafeCriticalAttribute;
    internal static AttributeDescription DesignerGeneratedAttribute;
    internal static AttributeDescription MyGroupCollectionAttribute;
    internal static AttributeDescription ComEventInterfaceAttribute;
    internal static AttributeDescription BestFitMappingAttribute;
    internal static AttributeDescription FlagsAttribute;
    internal static AttributeDescription LCIDConversionAttribute;
    internal static AttributeDescription UnmanagedFunctionPointerAttribute;
    internal static AttributeDescription PrimaryInteropAssemblyAttribute;
    internal static AttributeDescription ImportedFromTypeLibAttribute;
    internal static AttributeDescription DefaultEventAttribute;
    internal static AttributeDescription AssemblyConfigurationAttribute;
    internal static AttributeDescription AssemblyAlgorithmIdAttribute;
    internal static AttributeDescription DeprecatedAttribute;
    public string FullName { get; }
    public AttributeDescription(string namespace, string name, Byte[][] signatures, bool matchIgnoringCase);
    private static AttributeDescription();
    public string get_FullName();
    public virtual string ToString();
    internal int GetParameterCount(int signatureIndex);
}
internal class Microsoft.CodeAnalysis.AttributeUsageInfo : ValueType {
    private PackedAttributeUsage _flags;
    internal static AttributeUsageInfo Default;
    internal static AttributeUsageInfo Null;
    public bool IsNull { get; }
    internal AttributeTargets ValidTargets { get; }
    internal bool AllowMultiple { get; }
    internal bool Inherited { get; }
    internal bool HasValidAttributeTargets { get; }
    internal AttributeUsageInfo(AttributeTargets validTargets, bool allowMultiple, bool inherited);
    private static AttributeUsageInfo();
    public bool get_IsNull();
    internal AttributeTargets get_ValidTargets();
    internal bool get_AllowMultiple();
    internal bool get_Inherited();
    public static bool op_Equality(AttributeUsageInfo left, AttributeUsageInfo right);
    public static bool op_Inequality(AttributeUsageInfo left, AttributeUsageInfo right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AttributeUsageInfo other);
    public virtual int GetHashCode();
    internal bool get_HasValidAttributeTargets();
    internal object GetValidTargetsErrorArgument();
    private static string GetErrorDisplayNameResourceId(AttributeTargets target);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.BitVector : ValueType {
    private static UInt32[] s_emptyArray;
    private static BitVector s_nullValue;
    private static BitVector s_emptyValue;
    private static int Log2BitsPerWord;
    internal static int BitsPerWord;
    private static UInt32 ZeroWord;
    private UInt32 _bits0;
    private UInt32[] _bits;
    private int _capacity;
    public int Capacity { get; }
    public bool IsNull { get; }
    public static BitVector Null { get; }
    public static BitVector Empty { get; }
    public bool Item { get; public set; }
    private BitVector(UInt32 bits0, UInt32[] bits, int capacity);
    private static BitVector();
    public sealed virtual bool Equals(BitVector other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static int WordsForCapacity(int capacity);
    public int get_Capacity();
    [ConditionalAttribute("DEBUG_BITARRAY")]
private void Check();
    public void EnsureCapacity(int newCapacity);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.BitVector/<Words>d__18")]
internal IEnumerable`1<UInt32> Words();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.BitVector/<TrueBits>d__19")]
public IEnumerable`1<int> TrueBits();
    public static BitVector Create(int capacity);
    public static BitVector AllSet(int capacity);
    public BitVector Clone();
    public bool get_IsNull();
    public static BitVector get_Null();
    public static BitVector get_Empty();
    public bool IntersectWith(BitVector other);
    public void UnionWith(BitVector other);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    public void Clear();
}
internal static class Microsoft.CodeAnalysis.Boxes : object {
    public static object BoxedTrue;
    public static object BoxedFalse;
    public static object BoxedByteZero;
    public static object BoxedSByteZero;
    public static object BoxedInt16Zero;
    public static object BoxedUInt16Zero;
    public static object BoxedInt32Zero;
    public static object BoxedInt32One;
    public static object BoxedUInt32Zero;
    public static object BoxedInt64Zero;
    public static object BoxedUInt64Zero;
    public static object BoxedSingleZero;
    public static object BoxedDoubleZero;
    public static object BoxedDecimalZero;
    private static Object[] s_boxedAsciiChars;
    private static Boxes();
    public static object Box(bool b);
    public static object Box(byte b);
    public static object Box(sbyte sb);
    public static object Box(short s);
    public static object Box(ushort us);
    public static object Box(int i);
    public static object Box(UInt32 u);
    public static object Box(long l);
    public static object Box(ulong ul);
    public static object Box(float f);
    public static object Box(double d);
    public static object Box(char c);
    public static object Box(decimal d);
}
internal abstract class Microsoft.CodeAnalysis.CachingBase`1 : object {
    protected int mask;
    protected TEntry[] entries;
    internal CachingBase`1(int size);
    private static int AlignSize(int size);
}
internal class Microsoft.CodeAnalysis.CachingFactory`2 : CachingBase`1<Entry<TKey, TValue>> {
    private int _size;
    private Func`2<TKey, TValue> _valueFactory;
    private Func`2<TKey, int> _keyHash;
    private Func`3<TKey, TValue, bool> _keyValueEquality;
    public CachingFactory`2(int size, Func`2<TKey, TValue> valueFactory, Func`2<TKey, int> keyHash, Func`3<TKey, TValue, bool> keyValueEquality);
    public void Add(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public TValue GetOrMakeValue(TKey key);
    private int GetKeyHash(TKey key);
}
internal class Microsoft.CodeAnalysis.CachingIdentityFactory`2 : CachingBase`1<Entry<TKey, TValue>> {
    private Func`2<TKey, TValue> _valueFactory;
    private ObjectPool`1<CachingIdentityFactory`2<TKey, TValue>> _pool;
    public CachingIdentityFactory`2(int size, Func`2<TKey, TValue> valueFactory);
    public CachingIdentityFactory`2(int size, Func`2<TKey, TValue> valueFactory, ObjectPool`1<CachingIdentityFactory`2<TKey, TValue>> pool);
    public void Add(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public TValue GetOrMakeValue(TKey key);
    public static ObjectPool`1<CachingIdentityFactory`2<TKey, TValue>> CreatePool(int size, Func`2<TKey, TValue> valueFactory);
    public void Free();
}
public enum Microsoft.CodeAnalysis.CandidateReason : Enum {
    public int value__;
    public static CandidateReason None;
    public static CandidateReason NotATypeOrNamespace;
    public static CandidateReason NotAnEvent;
    public static CandidateReason NotAWithEventsMember;
    public static CandidateReason NotAnAttributeType;
    public static CandidateReason WrongArity;
    public static CandidateReason NotCreatable;
    public static CandidateReason NotReferencable;
    public static CandidateReason Inaccessible;
    public static CandidateReason NotAValue;
    public static CandidateReason NotAVariable;
    public static CandidateReason NotInvocable;
    public static CandidateReason StaticInstanceMismatch;
    public static CandidateReason OverloadResolutionFailure;
    public static CandidateReason LateBound;
    public static CandidateReason Ambiguous;
    public static CandidateReason MemberGroup;
}
public static class Microsoft.CodeAnalysis.CaseInsensitiveComparison : object {
    private static TextInfo s_unicodeCultureTextInfo;
    private static OneToOneUnicodeComparer s_comparer;
    public static StringComparer Comparer { get; }
    private static CaseInsensitiveComparison();
    private static CultureInfo GetUnicodeCulture();
    public static char ToLower(char c);
    private static char ToLowerNonAscii(char c);
    public static StringComparer get_Comparer();
    public static bool Equals(string left, string right);
    public static bool EndsWith(string value, string possibleEnd);
    public static int Compare(string left, string right);
    public static int GetHashCode(string value);
    public static string ToLower(string value);
    public static void ToLower(StringBuilder builder);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.CodeAnalysis.ChildSyntaxList : ValueType {
    private SyntaxNode _node;
    private int _count;
    public int Count { get; }
    public SyntaxNodeOrToken Item { get; }
    internal SyntaxNode Node { get; }
    private SyntaxNodeOrToken[] Nodes { get; }
    internal ChildSyntaxList(SyntaxNode node);
    public sealed virtual int get_Count();
    internal static int CountNodes(GreenNode green);
    public sealed virtual SyntaxNodeOrToken get_Item(int index);
    internal SyntaxNode get_Node();
    private static int Occupancy(GreenNode green);
    internal static SyntaxNodeOrToken ItemInternal(SyntaxNode node, int index);
    internal static SyntaxNodeOrToken ChildThatContainsPosition(SyntaxNode node, int targetPosition);
    internal static SyntaxNode ItemInternalAsNode(SyntaxNode node, int index);
    private SyntaxNodeOrToken[] get_Nodes();
    public bool Any();
    public SyntaxNodeOrToken First();
    public SyntaxNodeOrToken Last();
    public Reversed Reverse();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<SyntaxNodeOrToken> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ChildSyntaxList other);
    public virtual int GetHashCode();
    public static bool op_Equality(ChildSyntaxList list1, ChildSyntaxList list2);
    public static bool op_Inequality(ChildSyntaxList list1, ChildSyntaxList list2);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.CodeAnalysis.CodeAnalysisResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AbsolutePathExpected { get; }
    internal static string AnalyzerExecutionTimeColumnHeader { get; }
    internal static string AnalyzerNameColumnHeader { get; }
    internal static string AnalyzerTotalExecutionTime { get; }
    internal static string ArgumentCannotBeEmpty { get; }
    internal static string ArgumentElementCannotBeNull { get; }
    internal static string ArraysWithMoreThanOneDimensionCannotBeSerialized { get; }
    internal static string Assembly { get; }
    internal static string AssemblyFileNotFound { get; }
    internal static string AssemblyMustHaveAtLeastOneModule { get; }
    internal static string AssemblySigningNotSupported { get; }
    internal static string CannotAliasModule { get; }
    internal static string CannotCreateReferenceToModule { get; }
    internal static string CannotCreateReferenceToSubmission { get; }
    internal static string CannotEmbedInteropTypesFromModule { get; }
    internal static string CantCreateModuleReferenceToAssembly { get; }
    internal static string CantCreateReferenceToDynamicAssembly { get; }
    internal static string ChangesMustBeOrderedAndNotOverlapping { get; }
    internal static string Class1 { get; }
    internal static string CoffResourceInvalidRelocation { get; }
    internal static string CoffResourceInvalidSectionSize { get; }
    internal static string CoffResourceInvalidSymbol { get; }
    internal static string CoffResourceMissingSection { get; }
    internal static string CompilationOptionsMustNotHaveErrors { get; }
    internal static string CompilerAnalyzerFailure { get; }
    internal static string CompilerAnalyzerThrows { get; }
    internal static string CompilerAnalyzerThrowsDescription { get; }
    internal static string Constructor { get; }
    internal static string Delegate1 { get; }
    internal static string DiagnosticIdCantBeNullOrWhitespace { get; }
    internal static string EmptyOrInvalidFileName { get; }
    internal static string EmptyOrInvalidResourceName { get; }
    internal static string EndMustNotBeLessThanStart { get; }
    internal static string Enum1 { get; }
    internal static string Event1 { get; }
    internal static string ExpectedNonEmptyPublicKey { get; }
    internal static string FailedToResolveRuleSetName { get; }
    internal static string Field { get; }
    internal static string FileNotFound { get; }
    internal static string FileSizeExceedsMaximumAllowed { get; }
    internal static string GetMetadataMustReturnInstance { get; }
    internal static string IconStreamUnexpectedFormat { get; }
    internal static string InMemoryAssembly { get; }
    internal static string InMemoryModule { get; }
    internal static string Interface1 { get; }
    internal static string InvalidAlias { get; }
    internal static string InvalidAssemblyName { get; }
    internal static string InvalidCharactersInAssemblyCultureName { get; }
    internal static string InvalidCharactersInAssemblyName { get; }
    internal static string InvalidCompilationOptions { get; }
    internal static string InvalidContentType { get; }
    internal static string InvalidCultureName { get; }
    internal static string InvalidDataAtOffset { get; }
    internal static string InvalidHash { get; }
    internal static string InvalidModuleName { get; }
    internal static string InvalidNodeToTrack { get; }
    internal static string InvalidOutputKindForSubmission { get; }
    internal static string InvalidPublicKey { get; }
    internal static string InvalidPublicKeyToken { get; }
    internal static string InvalidRuleSetInclude { get; }
    internal static string InvalidSizeOfPublicKeyToken { get; }
    internal static string KeepAliveIsNotAnInteger { get; }
    internal static string KeepAliveIsTooSmall { get; }
    internal static string KeepAliveWithoutShared { get; }
    internal static string Method { get; }
    internal static string MismatchedVersion { get; }
    internal static string MissingKeepAlive { get; }
    internal static string MissingListItem { get; }
    internal static string Module { get; }
    internal static string ModuleCopyCannotBeUsedToCreateAssemblyMetadata { get; }
    internal static string MultithreadedAnalyzerExecutionNote { get; }
    internal static string NameCannotBeEmpty { get; }
    internal static string NameCannotStartWithWhitespace { get; }
    internal static string NameContainsInvalidCharacter { get; }
    internal static string NoAnalyzersFound { get; }
    internal static string NoBinderException { get; }
    internal static string NodeOrTokenOutOfSequence { get; }
    internal static string NoReaderException { get; }
    internal static string NotWritableException { get; }
    internal static string OutputKindNotSupported { get; }
    internal static string Parameter { get; }
    internal static string PathReturnedByResolveMetadataFileMustBeAbsolute { get; }
    internal static string PathReturnedByResolveStrongNameKeyFileMustBeAbsolute { get; }
    internal static string PEImageDoesntContainManagedMetadata { get; }
    internal static string PEImageNotAvailable { get; }
    internal static string PreviousSubmissionHasErrors { get; }
    internal static string Property { get; }
    internal static string ReferenceResolverShouldReturnReadableNonNullStream { get; }
    internal static string ResourceDataProviderShouldReturnNonNullStream { get; }
    internal static string ResourceStreamProviderShouldReturnNonNullStream { get; }
    internal static string Return1 { get; }
    internal static string ReturnTypeCannotBeValuePointerbyRefOrOpen { get; }
    internal static string ReturnTypeCannotBeVoidByRefOrOpen { get; }
    internal static string RuleSetBadAttributeValue { get; }
    internal static string RuleSetHasDuplicateRules { get; }
    internal static string RuleSetMissingAttribute { get; }
    internal static string SizeHasToBePositive { get; }
    internal static string SpanDoesNotIncludeEndOfLine { get; }
    internal static string SpanDoesNotIncludeStartOfLine { get; }
    internal static string StartMustNotBeNegative { get; }
    internal static string StreamMustSupportReadAndSeek { get; }
    internal static string StreamMustSupportWrite { get; }
    internal static string Struct1 { get; }
    internal static string SymWriterNotDeterministic { get; }
    internal static string TypeMustBeASubclassOfSyntaxAnnotation { get; }
    internal static string TypeMustBeSameAsHostObjectTypeOfPreviousSubmission { get; }
    internal static string TypeParameter { get; }
    internal static string UnexpectedTypeOfNodeInList { get; }
    internal static string Unresolved { get; }
    internal static string UnsupportedDiagnosticReported { get; }
    internal static string UnsupportedHashAlgorithm { get; }
    internal static string ValueTooLargeToBeRepresented { get; }
    internal static string WinRTIdentityCantBeRetargetable { get; }
    internal static string XmlReferencesNotSupported { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AbsolutePathExpected();
    internal static string get_AnalyzerExecutionTimeColumnHeader();
    internal static string get_AnalyzerNameColumnHeader();
    internal static string get_AnalyzerTotalExecutionTime();
    internal static string get_ArgumentCannotBeEmpty();
    internal static string get_ArgumentElementCannotBeNull();
    internal static string get_ArraysWithMoreThanOneDimensionCannotBeSerialized();
    internal static string get_Assembly();
    internal static string get_AssemblyFileNotFound();
    internal static string get_AssemblyMustHaveAtLeastOneModule();
    internal static string get_AssemblySigningNotSupported();
    internal static string get_CannotAliasModule();
    internal static string get_CannotCreateReferenceToModule();
    internal static string get_CannotCreateReferenceToSubmission();
    internal static string get_CannotEmbedInteropTypesFromModule();
    internal static string get_CantCreateModuleReferenceToAssembly();
    internal static string get_CantCreateReferenceToDynamicAssembly();
    internal static string get_ChangesMustBeOrderedAndNotOverlapping();
    internal static string get_Class1();
    internal static string get_CoffResourceInvalidRelocation();
    internal static string get_CoffResourceInvalidSectionSize();
    internal static string get_CoffResourceInvalidSymbol();
    internal static string get_CoffResourceMissingSection();
    internal static string get_CompilationOptionsMustNotHaveErrors();
    internal static string get_CompilerAnalyzerFailure();
    internal static string get_CompilerAnalyzerThrows();
    internal static string get_CompilerAnalyzerThrowsDescription();
    internal static string get_Constructor();
    internal static string get_Delegate1();
    internal static string get_DiagnosticIdCantBeNullOrWhitespace();
    internal static string get_EmptyOrInvalidFileName();
    internal static string get_EmptyOrInvalidResourceName();
    internal static string get_EndMustNotBeLessThanStart();
    internal static string get_Enum1();
    internal static string get_Event1();
    internal static string get_ExpectedNonEmptyPublicKey();
    internal static string get_FailedToResolveRuleSetName();
    internal static string get_Field();
    internal static string get_FileNotFound();
    internal static string get_FileSizeExceedsMaximumAllowed();
    internal static string get_GetMetadataMustReturnInstance();
    internal static string get_IconStreamUnexpectedFormat();
    internal static string get_InMemoryAssembly();
    internal static string get_InMemoryModule();
    internal static string get_Interface1();
    internal static string get_InvalidAlias();
    internal static string get_InvalidAssemblyName();
    internal static string get_InvalidCharactersInAssemblyCultureName();
    internal static string get_InvalidCharactersInAssemblyName();
    internal static string get_InvalidCompilationOptions();
    internal static string get_InvalidContentType();
    internal static string get_InvalidCultureName();
    internal static string get_InvalidDataAtOffset();
    internal static string get_InvalidHash();
    internal static string get_InvalidModuleName();
    internal static string get_InvalidNodeToTrack();
    internal static string get_InvalidOutputKindForSubmission();
    internal static string get_InvalidPublicKey();
    internal static string get_InvalidPublicKeyToken();
    internal static string get_InvalidRuleSetInclude();
    internal static string get_InvalidSizeOfPublicKeyToken();
    internal static string get_KeepAliveIsNotAnInteger();
    internal static string get_KeepAliveIsTooSmall();
    internal static string get_KeepAliveWithoutShared();
    internal static string get_Method();
    internal static string get_MismatchedVersion();
    internal static string get_MissingKeepAlive();
    internal static string get_MissingListItem();
    internal static string get_Module();
    internal static string get_ModuleCopyCannotBeUsedToCreateAssemblyMetadata();
    internal static string get_MultithreadedAnalyzerExecutionNote();
    internal static string get_NameCannotBeEmpty();
    internal static string get_NameCannotStartWithWhitespace();
    internal static string get_NameContainsInvalidCharacter();
    internal static string get_NoAnalyzersFound();
    internal static string get_NoBinderException();
    internal static string get_NodeOrTokenOutOfSequence();
    internal static string get_NoReaderException();
    internal static string get_NotWritableException();
    internal static string get_OutputKindNotSupported();
    internal static string get_Parameter();
    internal static string get_PathReturnedByResolveMetadataFileMustBeAbsolute();
    internal static string get_PathReturnedByResolveStrongNameKeyFileMustBeAbsolute();
    internal static string get_PEImageDoesntContainManagedMetadata();
    internal static string get_PEImageNotAvailable();
    internal static string get_PreviousSubmissionHasErrors();
    internal static string get_Property();
    internal static string get_ReferenceResolverShouldReturnReadableNonNullStream();
    internal static string get_ResourceDataProviderShouldReturnNonNullStream();
    internal static string get_ResourceStreamProviderShouldReturnNonNullStream();
    internal static string get_Return1();
    internal static string get_ReturnTypeCannotBeValuePointerbyRefOrOpen();
    internal static string get_ReturnTypeCannotBeVoidByRefOrOpen();
    internal static string get_RuleSetBadAttributeValue();
    internal static string get_RuleSetHasDuplicateRules();
    internal static string get_RuleSetMissingAttribute();
    internal static string get_SizeHasToBePositive();
    internal static string get_SpanDoesNotIncludeEndOfLine();
    internal static string get_SpanDoesNotIncludeStartOfLine();
    internal static string get_StartMustNotBeNegative();
    internal static string get_StreamMustSupportReadAndSeek();
    internal static string get_StreamMustSupportWrite();
    internal static string get_Struct1();
    internal static string get_SymWriterNotDeterministic();
    internal static string get_TypeMustBeASubclassOfSyntaxAnnotation();
    internal static string get_TypeMustBeSameAsHostObjectTypeOfPreviousSubmission();
    internal static string get_TypeParameter();
    internal static string get_UnexpectedTypeOfNodeInList();
    internal static string get_Unresolved();
    internal static string get_UnsupportedDiagnosticReported();
    internal static string get_UnsupportedHashAlgorithm();
    internal static string get_ValueTooLargeToBeRepresented();
    internal static string get_WinRTIdentityCantBeRetargetable();
    internal static string get_XmlReferencesNotSupported();
}
internal class Microsoft.CodeAnalysis.CodeAnalysisResourcesLocalizableErrorArgument : ValueType {
    private string _targetResourceId;
    internal CodeAnalysisResourcesLocalizableErrorArgument(string targetResourceId);
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
internal abstract class Microsoft.CodeAnalysis.CodeGen.ArrayMethod : object {
    private ImmutableArray`1<ArrayMethodParameterInfo> _parameters;
    protected IArrayTypeReference arrayType;
    public string Name { get; }
    public bool ReturnValueIsByRef { get; }
    public bool AcceptsExtraArguments { get; }
    public ushort GenericParameterCount { get; }
    public bool IsGeneric { get; }
    public ImmutableArray`1<IParameterTypeInformation> ExtraParameters { get; }
    public IGenericMethodInstanceReference AsGenericMethodInstanceReference { get; }
    public ISpecializedMethodReference AsSpecializedMethodReference { get; }
    public CallingConvention CallingConvention { get; }
    public ushort ParameterCount { get; }
    public ImmutableArray`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    protected ArrayMethod(IArrayTypeReference arrayType);
    public abstract virtual string get_Name();
    public abstract virtual ITypeReference GetType(EmitContext context);
    public virtual bool get_ReturnValueIsByRef();
    protected virtual ImmutableArray`1<ArrayMethodParameterInfo> MakeParameters();
    public sealed virtual ImmutableArray`1<IParameterTypeInformation> GetParameters(EmitContext context);
    public sealed virtual bool get_AcceptsExtraArguments();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual IMethodDefinition GetResolvedMethod(EmitContext context);
    public sealed virtual ImmutableArray`1<IParameterTypeInformation> get_ExtraParameters();
    public sealed virtual IGenericMethodInstanceReference get_AsGenericMethodInstanceReference();
    public sealed virtual ISpecializedMethodReference get_AsSpecializedMethodReference();
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual ImmutableArray`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual ITypeReference GetContainingType(EmitContext context);
    public sealed virtual IEnumerable`1<ICustomAttribute> GetAttributes(EmitContext context);
    public sealed virtual void Dispatch(MetadataVisitor visitor);
    public sealed virtual IDefinition AsDefinition(EmitContext context);
    public virtual string ToString();
}
internal class Microsoft.CodeAnalysis.CodeGen.ArrayMethodParameterInfo : object {
    private ushort _index;
    private static ArrayMethodParameterInfo s_index0;
    private static ArrayMethodParameterInfo s_index1;
    private static ArrayMethodParameterInfo s_index2;
    private static ArrayMethodParameterInfo s_index3;
    public ImmutableArray`1<ICustomModifier> CustomModifiers { get; }
    public bool IsByReference { get; }
    public bool IsModified { get; }
    public bool HasByRefBeforeCustomModifiers { get; }
    public ushort Index { get; }
    protected ArrayMethodParameterInfo(ushort index);
    private static ArrayMethodParameterInfo();
    public static ArrayMethodParameterInfo GetIndexParameter(ushort index);
    public sealed virtual ImmutableArray`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual bool get_IsByReference();
    public bool get_IsModified();
    public sealed virtual bool get_HasByRefBeforeCustomModifiers();
    public virtual ITypeReference GetType(EmitContext context);
    public sealed virtual ushort get_Index();
}
internal class Microsoft.CodeAnalysis.CodeGen.ArrayMethods : object {
    private ConcurrentDictionary`2<ValueTuple`2<byte, IArrayTypeReference>, ArrayMethod> _dict;
    public ArrayMethod GetArrayConstructor(IArrayTypeReference arrayType);
    public ArrayMethod GetArrayGet(IArrayTypeReference arrayType);
    public ArrayMethod GetArraySet(IArrayTypeReference arrayType);
    public ArrayMethod GetArrayAddress(IArrayTypeReference arrayType);
    private ArrayMethod GetArrayMethod(IArrayTypeReference arrayType, ArrayMethodKind id);
    private static ArrayMethod MakeArrayMethod(IArrayTypeReference arrayType, ArrayMethodKind id);
}
internal class Microsoft.CodeAnalysis.CodeGen.ArraySetValueParameterInfo : ArrayMethodParameterInfo {
    private IArrayTypeReference _arrayType;
    internal ArraySetValueParameterInfo(ushort index, IArrayTypeReference arrayType);
    public virtual ITypeReference GetType(EmitContext context);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo : ValueType {
    public int SyntaxOffset;
    public DebugId ClosureId;
    public ClosureDebugInfo(int syntaxOffset, DebugId closureId);
    public sealed virtual bool Equals(ClosureDebugInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal string GetDebuggerDisplay();
}
internal class Microsoft.CodeAnalysis.CodeGen.CompilationTestData : object {
    public ConcurrentDictionary`2<string, MethodData> Methods;
    public IModule Module;
    public Func`1<object> SymWriterFactory;
}
internal class Microsoft.CodeAnalysis.CodeGen.DebugDocumentProvider : MulticastDelegate {
    public DebugDocumentProvider(object object, IntPtr method);
    public virtual DebugSourceDocument Invoke(string path, string basePath);
    public virtual IAsyncResult BeginInvoke(string path, string basePath, AsyncCallback callback, object object);
    public virtual DebugSourceDocument EndInvoke(IAsyncResult result);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.CodeGen.DebugId : ValueType {
    public static int UndefinedOrdinal;
    public int Ordinal;
    public int Generation;
    public DebugId(int ordinal, int generation);
    public sealed virtual bool Equals(DebugId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal string GetDebuggerDisplay();
}
internal abstract class Microsoft.CodeAnalysis.CodeGen.DefaultTypeDef : object {
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsComObject { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSerializable { get; }
    public bool IsSpecialName { get; }
    public bool IsWindowsRuntimeImport { get; }
    public bool IsSealed { get; }
    public IEnumerable`1<SecurityAttribute> SecurityAttributes { get; }
    public CharSet StringFormat { get; }
    public bool IsEnum { get; }
    public TypeDefinitionHandle TypeDef { get; }
    public IGenericMethodParameterReference AsGenericMethodParameterReference { get; }
    public IGenericTypeInstanceReference AsGenericTypeInstanceReference { get; }
    public IGenericTypeParameterReference AsGenericTypeParameterReference { get; }
    public INamespaceTypeReference AsNamespaceTypeReference { get; }
    public ISpecializedNestedTypeReference AsSpecializedNestedTypeReference { get; }
    public INestedTypeReference AsNestedTypeReference { get; }
    public bool MangleName { get; }
    public ushort Alignment { get; }
    public LayoutKind Layout { get; }
    public UInt32 SizeOf { get; }
    public bool IsValueType { get; }
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<MethodImplementation> GetExplicitImplementationOverrides(EmitContext context);
    public virtual IEnumerable`1<IFieldDefinition> GetFields(EmitContext context);
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<ITypeReference> Interfaces(EmitContext context);
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsWindowsRuntimeImport();
    public sealed virtual bool get_IsSealed();
    public virtual IEnumerable`1<IMethodDefinition> GetMethods(EmitContext context);
    public virtual IEnumerable`1<INestedTypeDefinition> GetNestedTypes(EmitContext context);
    public sealed virtual IEnumerable`1<IPropertyDefinition> GetProperties(EmitContext context);
    public sealed virtual IEnumerable`1<SecurityAttribute> get_SecurityAttributes();
    public sealed virtual CharSet get_StringFormat();
    public virtual IEnumerable`1<ICustomAttribute> GetAttributes(EmitContext context);
    public sealed virtual IDefinition AsDefinition(EmitContext context);
    public sealed virtual bool get_IsEnum();
    public sealed virtual ITypeDefinition GetResolvedType(EmitContext context);
    public sealed virtual PrimitiveTypeCode TypeCode(EmitContext context);
    public sealed virtual TypeDefinitionHandle get_TypeDef();
    public sealed virtual IGenericMethodParameterReference get_AsGenericMethodParameterReference();
    public sealed virtual IGenericTypeInstanceReference get_AsGenericTypeInstanceReference();
    public sealed virtual IGenericTypeParameterReference get_AsGenericTypeParameterReference();
    public virtual INamespaceTypeDefinition AsNamespaceTypeDefinition(EmitContext context);
    public virtual INamespaceTypeReference get_AsNamespaceTypeReference();
    public sealed virtual ISpecializedNestedTypeReference get_AsSpecializedNestedTypeReference();
    public virtual INestedTypeDefinition AsNestedTypeDefinition(EmitContext context);
    public virtual INestedTypeReference get_AsNestedTypeReference();
    public sealed virtual ITypeDefinition AsTypeDefinition(EmitContext context);
    public sealed virtual bool get_MangleName();
    public virtual ushort get_Alignment();
    public virtual ITypeReference GetBaseClass(EmitContext context);
    public virtual LayoutKind get_Layout();
    public virtual UInt32 get_SizeOf();
    public virtual void Dispatch(MetadataVisitor visitor);
    public virtual bool get_IsValueType();
}
internal class Microsoft.CodeAnalysis.CodeGen.ExplicitSizeStruct : DefaultTypeDef {
    private UInt32 _size;
    private INamedTypeDefinition _containingType;
    private ITypeReference _sysValueType;
    public ushort Alignment { get; }
    public LayoutKind Layout { get; }
    public UInt32 SizeOf { get; }
    public string Name { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public bool IsValueType { get; }
    public INestedTypeReference AsNestedTypeReference { get; }
    internal ExplicitSizeStruct(UInt32 size, PrivateImplementationDetails containingType, ITypeReference sysValueType);
    public virtual string ToString();
    public virtual ushort get_Alignment();
    public virtual ITypeReference GetBaseClass(EmitContext context);
    public virtual LayoutKind get_Layout();
    public virtual UInt32 get_SizeOf();
    public virtual void Dispatch(MetadataVisitor visitor);
    public sealed virtual string get_Name();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public virtual bool get_IsValueType();
    public sealed virtual ITypeReference GetContainingType(EmitContext context);
    public virtual INestedTypeDefinition AsNestedTypeDefinition(EmitContext context);
    public virtual INestedTypeReference get_AsNestedTypeReference();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.CodeGen.ILBuilder : object {
    private OptimizationLevel _optimizations;
    internal LocalSlotManager LocalSlotManager;
    private LocalScopeManager _scopeManager;
    internal ITokenDeferral module;
    internal BasicBlock leaderBlock;
    private EmitState _emitState;
    private BasicBlock _lastCompleteBlock;
    private BasicBlock _currentBlock;
    private SyntaxTree _lastSeqPointTree;
    private SmallDictionary`2<object, LabelInfo> _labelInfos;
    private int _instructionCountAtLastLabel;
    internal Byte[] RealizedIL;
    internal ImmutableArray`1<ExceptionHandlerRegion> RealizedExceptionHandlers;
    internal SequencePointList RealizedSequencePoints;
    public ArrayBuilder`1<RawSequencePoint> SeqPointsOpt;
    private ArrayBuilder`1<ILMarker> _allocatedILMarkers;
    private bool _pendingBlockCreate;
    private int _initialHiddenSequencePointMarker;
    [CompilerGeneratedAttribute]
private bool <HasDynamicLocal>k__BackingField;
    private ExceptionHandlerScope EnclosingExceptionHandler { get; }
    internal bool InExceptionHandler { get; }
    internal ushort MaxStack { get; }
    internal int InstructionsEmitted { get; }
    internal bool HasDynamicLocal { get; private set; }
    internal bool IsStackEmpty { get; }
    internal ILBuilder(ITokenDeferral module, LocalSlotManager localSlotManager, OptimizationLevel optimizations);
    private BasicBlock GetCurrentBlock();
    private void CreateBlock();
    private SwitchBlock CreateSwitchBlock();
    private void UpdatesForCreatedBlock(BasicBlock block);
    private void CreateBlockIfPending();
    private void EndBlock();
    private void ReconcileTrailingMarkers();
    private ExceptionHandlerScope get_EnclosingExceptionHandler();
    internal bool get_InExceptionHandler();
    internal void Realize();
    internal ImmutableArray`1<LocalScope> GetAllScopes();
    internal ImmutableArray`1<StateMachineHoistedLocalScope> GetHoistedLocalScopes();
    internal void FreeBasicBlocks();
    internal ushort get_MaxStack();
    internal int get_InstructionsEmitted();
    private void MarkReachableBlocks();
    private static void PushReachableBlockToProcess(ArrayBuilder`1<BasicBlock> reachableBlocks, BasicBlock block);
    private static void MarkReachableFrom(ArrayBuilder`1<BasicBlock> reachableBlocks, BasicBlock block);
    private static void MarkReachableFromBranch(ArrayBuilder`1<BasicBlock> reachableBlocks, BasicBlock block);
    private static void RedirectBranchToBlockedDestination(BasicBlock block, object blockedDest);
    private static object BlockedBranchDestination(BasicBlock src, BasicBlock dest);
    private static object BlockedBranchDestinationSlow(ExceptionHandlerScope destHandler, ExceptionHandlerScope srcHandler);
    private static void MarkReachableFromTry(ArrayBuilder`1<BasicBlock> reachableBlocks, BasicBlock block);
    private static void MarkReachableFromSwitch(ArrayBuilder`1<BasicBlock> reachableBlocks, BasicBlock block);
    private bool OptimizeLabels();
    private bool ForwardLabelsNoLeaving();
    private bool ForwardLabelsAllowLeaving();
    private static bool CanMoveLabelToAnotherHandler(ExceptionHandlerScope currentHandler, ExceptionHandlerScope newHandler);
    private bool DropUnreachableBlocks();
    private void MarkAllBlocksUnreachable();
    private void ComputeOffsets();
    private void RewriteSpecialBlocks();
    private static bool IsSpecialEndHandlerBlock(BasicBlock block);
    private void RewriteBranchesAcrossExceptionHandlers();
    private bool ComputeOffsetsAndAdjustBranches();
    private void RealizeBlocks();
    private void RealizeSequencePoints();
    internal void DefineSequencePoint(SyntaxTree syntaxTree, TextSpan span);
    internal void DefineHiddenSequencePoint();
    internal void DefineInitialHiddenSequencePoint();
    internal void SetInitialDebugDocument(SyntaxTree initialSequencePointTree);
    [ConditionalAttribute("DEBUG")]
internal void AssertStackEmpty();
    internal bool IsJustPastLabel();
    internal void OpenLocalScope(ScopeType scopeType, ITypeReference exceptionType);
    internal bool PossiblyDefinedOutsideOfTry(LocalDefinition local);
    internal void MarkFilterConditionEnd();
    internal void CloseLocalScope();
    internal void OpenStateMachineScope();
    internal void DefineUserDefinedStateMachineHoistedLocal(int slotIndex);
    internal void CloseStateMachineScope();
    internal void AddLocalToScope(LocalDefinition local);
    internal void AddLocalConstantToScope(LocalConstantDefinition localConstant);
    [CompilerGeneratedAttribute]
internal bool get_HasDynamicLocal();
    [CompilerGeneratedAttribute]
private void set_HasDynamicLocal(bool value);
    internal ILBuilder GetSnapshot();
    private bool AllBlocks(Func`2<BasicBlock, bool> predicate);
    internal int AllocateILMarker();
    public int GetILOffsetFromMarker(int ilMarker);
    private string GetDebuggerDisplay();
    public void EmitNumericConversion(PrimitiveTypeCode fromPredefTypeKind, PrimitiveTypeCode toPredefTypeKind, bool checked);
    internal void AdjustStack(int stackAdjustment);
    internal bool get_IsStackEmpty();
    internal void EmitOpCode(ILOpCode code);
    internal void EmitOpCode(ILOpCode code, int stackAdjustment);
    internal void EmitToken(string value);
    internal void EmitToken(IReference value, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    internal void EmitArrayBlockInitializer(ImmutableArray`1<byte> data, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    internal void MarkLabel(object label);
    internal void EmitBranch(ILOpCode code, object label, ILOpCode revOpCode);
    internal void EmitStringSwitchJumpTable(KeyValuePair`2[] caseLabels, object fallThroughLabel, LocalOrParameter key, LocalDefinition keyHash, EmitStringCompareAndBranch emitStringCondBranchDelegate, GetStringHashCode computeStringHashcodeDelegate);
    internal void EmitIntegerSwitchJumpTable(KeyValuePair`2[] caseLabels, object fallThroughLabel, LocalOrParameter key, PrimitiveTypeCode keyTypeCode);
    internal void EmitSwitch(Object[] labels);
    internal void EmitRet(bool isVoid);
    internal void EmitThrow(bool isRethrow);
    private void EmitEndFinally();
    private BasicBlock FinishFilterCondition();
    internal void EmitArrayCreation(IArrayTypeReference arrayType, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    internal void EmitArrayElementLoad(IArrayTypeReference arrayType, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    internal void EmitArrayElementAddress(IArrayTypeReference arrayType, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    internal void EmitArrayElementStore(IArrayTypeReference arrayType, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    internal void EmitLoad(LocalOrParameter localOrParameter);
    internal void EmitLocalLoad(LocalDefinition local);
    internal void EmitLocalStore(LocalDefinition local);
    internal void EmitLocalAddress(LocalDefinition local);
    internal void EmitLoadArgumentOpcode(int argNumber);
    internal void EmitLoadArgumentAddrOpcode(int argNumber);
    internal void EmitStoreArgumentOpcode(int argNumber);
    internal void EmitConstantValue(ConstantValue value);
    internal void EmitIntConstant(int value);
    internal void EmitBoolConstant(bool value);
    internal void EmitByteConstant(byte value);
    internal void EmitSByteConstant(sbyte value);
    internal void EmitShortConstant(short value);
    internal void EmitUShortConstant(ushort value);
    internal void EmitLongConstant(long value);
    internal void EmitSingleConstant(float value);
    internal void EmitDoubleConstant(double value);
    internal void EmitNullConstant();
    internal void EmitStringConstant(string value);
    private void EmitInt8(sbyte int8);
    private void EmitInt32(int int32);
    private void EmitInt64(long int64);
    private void EmitFloat(float floatValue);
    private void EmitDouble(double doubleValue);
    private static void WriteOpCode(BinaryWriter writer, ILOpCode code);
    private BinaryWriter GetCurrentStream();
}
internal enum Microsoft.CodeAnalysis.CodeGen.ILOpCode : Enum {
    public ushort value__;
    public static ILOpCode Nop;
    public static ILOpCode Break;
    public static ILOpCode Ldarg_0;
    public static ILOpCode Ldarg_1;
    public static ILOpCode Ldarg_2;
    public static ILOpCode Ldarg_3;
    public static ILOpCode Ldloc_0;
    public static ILOpCode Ldloc_1;
    public static ILOpCode Ldloc_2;
    public static ILOpCode Ldloc_3;
    public static ILOpCode Stloc_0;
    public static ILOpCode Stloc_1;
    public static ILOpCode Stloc_2;
    public static ILOpCode Stloc_3;
    public static ILOpCode Ldarg_s;
    public static ILOpCode Ldarga_s;
    public static ILOpCode Starg_s;
    public static ILOpCode Ldloc_s;
    public static ILOpCode Ldloca_s;
    public static ILOpCode Stloc_s;
    public static ILOpCode Ldnull;
    public static ILOpCode Ldc_i4_m1;
    public static ILOpCode Ldc_i4_0;
    public static ILOpCode Ldc_i4_1;
    public static ILOpCode Ldc_i4_2;
    public static ILOpCode Ldc_i4_3;
    public static ILOpCode Ldc_i4_4;
    public static ILOpCode Ldc_i4_5;
    public static ILOpCode Ldc_i4_6;
    public static ILOpCode Ldc_i4_7;
    public static ILOpCode Ldc_i4_8;
    public static ILOpCode Ldc_i4_s;
    public static ILOpCode Ldc_i4;
    public static ILOpCode Ldc_i8;
    public static ILOpCode Ldc_r4;
    public static ILOpCode Ldc_r8;
    public static ILOpCode Dup;
    public static ILOpCode Pop;
    public static ILOpCode Jmp;
    public static ILOpCode Call;
    public static ILOpCode Calli;
    public static ILOpCode Ret;
    public static ILOpCode Br_s;
    public static ILOpCode Brfalse_s;
    public static ILOpCode Brtrue_s;
    public static ILOpCode Beq_s;
    public static ILOpCode Bge_s;
    public static ILOpCode Bgt_s;
    public static ILOpCode Ble_s;
    public static ILOpCode Blt_s;
    public static ILOpCode Bne_un_s;
    public static ILOpCode Bge_un_s;
    public static ILOpCode Bgt_un_s;
    public static ILOpCode Ble_un_s;
    public static ILOpCode Blt_un_s;
    public static ILOpCode Br;
    public static ILOpCode Brfalse;
    public static ILOpCode Brtrue;
    public static ILOpCode Beq;
    public static ILOpCode Bge;
    public static ILOpCode Bgt;
    public static ILOpCode Ble;
    public static ILOpCode Blt;
    public static ILOpCode Bne_un;
    public static ILOpCode Bge_un;
    public static ILOpCode Bgt_un;
    public static ILOpCode Ble_un;
    public static ILOpCode Blt_un;
    public static ILOpCode Switch;
    public static ILOpCode Ldind_i1;
    public static ILOpCode Ldind_u1;
    public static ILOpCode Ldind_i2;
    public static ILOpCode Ldind_u2;
    public static ILOpCode Ldind_i4;
    public static ILOpCode Ldind_u4;
    public static ILOpCode Ldind_i8;
    public static ILOpCode Ldind_i;
    public static ILOpCode Ldind_r4;
    public static ILOpCode Ldind_r8;
    public static ILOpCode Ldind_ref;
    public static ILOpCode Stind_ref;
    public static ILOpCode Stind_i1;
    public static ILOpCode Stind_i2;
    public static ILOpCode Stind_i4;
    public static ILOpCode Stind_i8;
    public static ILOpCode Stind_r4;
    public static ILOpCode Stind_r8;
    public static ILOpCode Add;
    public static ILOpCode Sub;
    public static ILOpCode Mul;
    public static ILOpCode Div;
    public static ILOpCode Div_un;
    public static ILOpCode Rem;
    public static ILOpCode Rem_un;
    public static ILOpCode And;
    public static ILOpCode Or;
    public static ILOpCode Xor;
    public static ILOpCode Shl;
    public static ILOpCode Shr;
    public static ILOpCode Shr_un;
    public static ILOpCode Neg;
    public static ILOpCode Not;
    public static ILOpCode Conv_i1;
    public static ILOpCode Conv_i2;
    public static ILOpCode Conv_i4;
    public static ILOpCode Conv_i8;
    public static ILOpCode Conv_r4;
    public static ILOpCode Conv_r8;
    public static ILOpCode Conv_u4;
    public static ILOpCode Conv_u8;
    public static ILOpCode Callvirt;
    public static ILOpCode Cpobj;
    public static ILOpCode Ldobj;
    public static ILOpCode Ldstr;
    public static ILOpCode Newobj;
    public static ILOpCode Castclass;
    public static ILOpCode Isinst;
    public static ILOpCode Conv_r_un;
    public static ILOpCode Unbox;
    public static ILOpCode Throw;
    public static ILOpCode Ldfld;
    public static ILOpCode Ldflda;
    public static ILOpCode Stfld;
    public static ILOpCode Ldsfld;
    public static ILOpCode Ldsflda;
    public static ILOpCode Stsfld;
    public static ILOpCode Stobj;
    public static ILOpCode Conv_ovf_i1_un;
    public static ILOpCode Conv_ovf_i2_un;
    public static ILOpCode Conv_ovf_i4_un;
    public static ILOpCode Conv_ovf_i8_un;
    public static ILOpCode Conv_ovf_u1_un;
    public static ILOpCode Conv_ovf_u2_un;
    public static ILOpCode Conv_ovf_u4_un;
    public static ILOpCode Conv_ovf_u8_un;
    public static ILOpCode Conv_ovf_i_un;
    public static ILOpCode Conv_ovf_u_un;
    public static ILOpCode Box;
    public static ILOpCode Newarr;
    public static ILOpCode Ldlen;
    public static ILOpCode Ldelema;
    public static ILOpCode Ldelem_i1;
    public static ILOpCode Ldelem_u1;
    public static ILOpCode Ldelem_i2;
    public static ILOpCode Ldelem_u2;
    public static ILOpCode Ldelem_i4;
    public static ILOpCode Ldelem_u4;
    public static ILOpCode Ldelem_i8;
    public static ILOpCode Ldelem_i;
    public static ILOpCode Ldelem_r4;
    public static ILOpCode Ldelem_r8;
    public static ILOpCode Ldelem_ref;
    public static ILOpCode Stelem_i;
    public static ILOpCode Stelem_i1;
    public static ILOpCode Stelem_i2;
    public static ILOpCode Stelem_i4;
    public static ILOpCode Stelem_i8;
    public static ILOpCode Stelem_r4;
    public static ILOpCode Stelem_r8;
    public static ILOpCode Stelem_ref;
    public static ILOpCode Ldelem;
    public static ILOpCode Stelem;
    public static ILOpCode Unbox_any;
    public static ILOpCode Conv_ovf_i1;
    public static ILOpCode Conv_ovf_u1;
    public static ILOpCode Conv_ovf_i2;
    public static ILOpCode Conv_ovf_u2;
    public static ILOpCode Conv_ovf_i4;
    public static ILOpCode Conv_ovf_u4;
    public static ILOpCode Conv_ovf_i8;
    public static ILOpCode Conv_ovf_u8;
    public static ILOpCode Refanyval;
    public static ILOpCode Ckfinite;
    public static ILOpCode Mkrefany;
    public static ILOpCode Ldtoken;
    public static ILOpCode Conv_u2;
    public static ILOpCode Conv_u1;
    public static ILOpCode Conv_i;
    public static ILOpCode Conv_ovf_i;
    public static ILOpCode Conv_ovf_u;
    public static ILOpCode Add_ovf;
    public static ILOpCode Add_ovf_un;
    public static ILOpCode Mul_ovf;
    public static ILOpCode Mul_ovf_un;
    public static ILOpCode Sub_ovf;
    public static ILOpCode Sub_ovf_un;
    public static ILOpCode Endfinally;
    public static ILOpCode Leave;
    public static ILOpCode Leave_s;
    public static ILOpCode Stind_i;
    public static ILOpCode Conv_u;
    public static ILOpCode Arglist;
    public static ILOpCode Ceq;
    public static ILOpCode Cgt;
    public static ILOpCode Cgt_un;
    public static ILOpCode Clt;
    public static ILOpCode Clt_un;
    public static ILOpCode Ldftn;
    public static ILOpCode Ldvirtftn;
    public static ILOpCode Ldarg;
    public static ILOpCode Ldarga;
    public static ILOpCode Starg;
    public static ILOpCode Ldloc;
    public static ILOpCode Ldloca;
    public static ILOpCode Stloc;
    public static ILOpCode Localloc;
    public static ILOpCode Endfilter;
    public static ILOpCode Unaligned;
    public static ILOpCode Volatile;
    public static ILOpCode Tail;
    public static ILOpCode Initobj;
    public static ILOpCode Constrained;
    public static ILOpCode Cpblk;
    public static ILOpCode Initblk;
    public static ILOpCode Rethrow;
    public static ILOpCode Sizeof;
    public static ILOpCode Refanytype;
    public static ILOpCode Readonly;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeGen.ILOpCodeExtensions : object {
    [ExtensionAttribute]
public static int Size(ILOpCode opcode);
    [ExtensionAttribute]
public static int BranchOperandSize(ILOpCode opcode);
    [ExtensionAttribute]
public static ILOpCode GetShortOpcode(ILOpCode opcode);
    [ExtensionAttribute]
public static ILOpCode GetLeaveOpcode(ILOpCode opcode);
    [ExtensionAttribute]
public static bool HasVariableStackBehavior(ILOpCode opcode);
    [ExtensionAttribute]
public static bool IsControlTransfer(ILOpCode opcode);
    [ExtensionAttribute]
public static bool IsBranchToLabel(ILOpCode opcode);
    [ExtensionAttribute]
public static bool IsConditionalBranch(ILOpCode opcode);
    [ExtensionAttribute]
public static bool IsRelationalBranch(ILOpCode opcode);
    [ExtensionAttribute]
public static bool CanFallThrough(ILOpCode opcode);
    [ExtensionAttribute]
public static int NetStackBehavior(ILOpCode opcode);
    [ExtensionAttribute]
public static int StackPopCount(ILOpCode opcode);
    [ExtensionAttribute]
public static int StackPushCount(ILOpCode opcode);
}
internal interface Microsoft.CodeAnalysis.CodeGen.ITokenDeferral {
    public ArrayMethods ArrayMethods { get; }
    public abstract virtual UInt32 GetFakeStringTokenForIL(string value);
    public abstract virtual UInt32 GetFakeSymbolTokenForIL(IReference value, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    public abstract virtual IFieldReference GetFieldForData(ImmutableArray`1<byte> data, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    public abstract virtual IMethodReference GetInitArrayHelper();
    public abstract virtual string GetStringFromToken(UInt32 token);
    public abstract virtual IReference GetReferenceFromToken(UInt32 token);
    public abstract virtual ArrayMethods get_ArrayMethods();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo : ValueType {
    public int SyntaxOffset;
    public int ClosureOrdinal;
    public DebugId LambdaId;
    public static int StaticClosureOrdinal;
    public static int ThisOnlyClosureOrdinal;
    public static int MinClosureOrdinal;
    public LambdaDebugInfo(int syntaxOffset, DebugId lambdaId, int closureOrdinal);
    public sealed virtual bool Equals(LambdaDebugInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal string GetDebuggerDisplay();
}
internal class Microsoft.CodeAnalysis.CodeGen.LocalConstantDefinition : object {
    private string _name;
    private Location _location;
    private IMetadataConstant _compileTimeValue;
    private bool _isDynamic;
    private ImmutableArray`1<TypedConstant> _dynamicTransformFlags;
    public string Name { get; }
    public Location Location { get; }
    public IMetadataConstant CompileTimeValue { get; }
    public ITypeReference Type { get; }
    public bool IsConstant { get; }
    public ImmutableArray`1<ICustomModifier> CustomModifiers { get; }
    public bool IsModified { get; }
    public bool IsPinned { get; }
    public bool IsReference { get; }
    public LocalSlotConstraints Constraints { get; }
    public bool IsDynamic { get; }
    public UInt32 PdbAttributes { get; }
    public ImmutableArray`1<TypedConstant> DynamicTransformFlags { get; }
    public int SlotIndex { get; }
    public Byte[] Signature { get; }
    public LocalSlotDebugInfo SlotInfo { get; }
    public LocalConstantDefinition(string name, Location location, IMetadataConstant compileTimeValue, bool isDynamic, ImmutableArray`1<TypedConstant> dynamicTransformFlags);
    public sealed virtual string get_Name();
    public sealed virtual Location get_Location();
    public sealed virtual IMetadataConstant get_CompileTimeValue();
    public sealed virtual ITypeReference get_Type();
    public bool get_IsConstant();
    public sealed virtual ImmutableArray`1<ICustomModifier> get_CustomModifiers();
    public bool get_IsModified();
    public sealed virtual bool get_IsPinned();
    public sealed virtual bool get_IsReference();
    public sealed virtual LocalSlotConstraints get_Constraints();
    public sealed virtual bool get_IsDynamic();
    public sealed virtual UInt32 get_PdbAttributes();
    public sealed virtual ImmutableArray`1<TypedConstant> get_DynamicTransformFlags();
    public sealed virtual int get_SlotIndex();
    public sealed virtual Byte[] get_Signature();
    public sealed virtual LocalSlotDebugInfo get_SlotInfo();
}
internal class Microsoft.CodeAnalysis.CodeGen.LocalDebugId : ValueType {
    public int SyntaxOffset;
    public int Ordinal;
    public static LocalDebugId None;
    public bool IsNone { get; }
    private LocalDebugId(bool isNone);
    public LocalDebugId(int syntaxOffset, int ordinal);
    private static LocalDebugId();
    public bool get_IsNone();
    public sealed virtual bool Equals(LocalDebugId other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.CodeGen.LocalDefinition : object {
    private ILocalSymbol _symbolOpt;
    private string _nameOpt;
    private ITypeReference _type;
    private LocalSlotConstraints _constraints;
    private int _slot;
    private bool _isDynamic;
    private LocalSlotDebugInfo _slotInfo;
    private UInt32 _pdbAttributes;
    private ImmutableArray`1<TypedConstant> _dynamicTransformFlags;
    public ILocalSymbol SymbolOpt { get; }
    public Location Location { get; }
    public int SlotIndex { get; }
    public IMetadataConstant CompileTimeValue { get; }
    public ImmutableArray`1<ICustomModifier> CustomModifiers { get; }
    public bool IsConstant { get; }
    public bool IsModified { get; }
    public LocalSlotConstraints Constraints { get; }
    public bool IsPinned { get; }
    public bool IsReference { get; }
    public bool IsDynamic { get; }
    public UInt32 PdbAttributes { get; }
    public ImmutableArray`1<TypedConstant> DynamicTransformFlags { get; }
    public ITypeReference Type { get; }
    public string Name { get; }
    public Byte[] Signature { get; }
    public LocalSlotDebugInfo SlotInfo { get; }
    public LocalDefinition(ILocalSymbol symbolOpt, string nameOpt, ITypeReference type, int slot, SynthesizedLocalKind synthesizedKind, LocalDebugId id, UInt32 pdbAttributes, LocalSlotConstraints constraints, bool isDynamic, ImmutableArray`1<TypedConstant> dynamicTransformFlags);
    internal string GetDebuggerDisplay();
    public ILocalSymbol get_SymbolOpt();
    public sealed virtual Location get_Location();
    public sealed virtual int get_SlotIndex();
    public sealed virtual IMetadataConstant get_CompileTimeValue();
    public sealed virtual ImmutableArray`1<ICustomModifier> get_CustomModifiers();
    public bool get_IsConstant();
    public bool get_IsModified();
    public sealed virtual LocalSlotConstraints get_Constraints();
    public sealed virtual bool get_IsPinned();
    public sealed virtual bool get_IsReference();
    public sealed virtual bool get_IsDynamic();
    public sealed virtual UInt32 get_PdbAttributes();
    public sealed virtual ImmutableArray`1<TypedConstant> get_DynamicTransformFlags();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual string get_Name();
    public sealed virtual Byte[] get_Signature();
    public sealed virtual LocalSlotDebugInfo get_SlotInfo();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.CodeGen.LocalOrParameter : ValueType {
    public LocalDefinition Local;
    public int ParameterIndex;
    private LocalOrParameter(LocalDefinition local, int parameterIndex);
    public static LocalOrParameter op_Implicit(LocalDefinition local);
    public static LocalOrParameter op_Implicit(int parameterIndex);
    private string GetDebuggerDisplay();
}
internal class Microsoft.CodeAnalysis.CodeGen.LocalSlotDebugInfo : ValueType {
    public SynthesizedLocalKind SynthesizedKind;
    public LocalDebugId Id;
    public LocalSlotDebugInfo(SynthesizedLocalKind synthesizedKind, LocalDebugId id);
    public sealed virtual bool Equals(LocalSlotDebugInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class Microsoft.CodeAnalysis.CodeGen.LocalSlotManager : object {
    private Dictionary`2<ILocalSymbol, LocalDefinition> _localMap;
    private KeyedStack`2<LocalSignature, LocalDefinition> _freeSlots;
    private ArrayBuilder`1<ILocalDefinition> _lazyAllLocals;
    private VariableSlotAllocator _slotAllocatorOpt;
    private Dictionary`2<ILocalSymbol, LocalDefinition> LocalMap { get; }
    private KeyedStack`2<LocalSignature, LocalDefinition> FreeSlots { get; }
    public LocalSlotManager(VariableSlotAllocator slotAllocatorOpt);
    private Dictionary`2<ILocalSymbol, LocalDefinition> get_LocalMap();
    private KeyedStack`2<LocalSignature, LocalDefinition> get_FreeSlots();
    internal LocalDefinition DeclareLocal(ITypeReference type, ILocalSymbolInternal symbol, string name, SynthesizedLocalKind kind, LocalDebugId id, UInt32 pdbAttributes, LocalSlotConstraints constraints, bool isDynamic, ImmutableArray`1<TypedConstant> dynamicTransformFlags, bool isSlotReusable);
    internal LocalDefinition GetLocal(ILocalSymbol symbol);
    internal void FreeLocal(ILocalSymbol symbol);
    internal LocalDefinition AllocateSlot(ITypeReference type, LocalSlotConstraints constraints, ImmutableArray`1<TypedConstant> dynamicTransformFlags);
    private LocalDefinition DeclareLocalImpl(ITypeReference type, ILocalSymbolInternal symbolOpt, string nameOpt, SynthesizedLocalKind kind, LocalDebugId id, UInt32 pdbAttributes, LocalSlotConstraints constraints, bool isDynamic, ImmutableArray`1<TypedConstant> dynamicTransformFlags);
    internal void FreeSlot(LocalDefinition slot);
    public ImmutableArray`1<ILocalDefinition> LocalsInOrder();
}
internal class Microsoft.CodeAnalysis.CodeGen.MappedField : object {
    private INamedTypeDefinition _containingType;
    private ITypeReference _type;
    private ImmutableArray`1<byte> _block;
    private string _name;
    public ImmutableArray`1<byte> MappedData { get; }
    public bool IsCompileTimeConstant { get; }
    public bool IsNotSerialized { get; }
    public bool IsReadOnly { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsMarshalledExplicitly { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public ImmutableArray`1<byte> MarshallingDescriptor { get; }
    public UInt32 Offset { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public string Name { get; }
    public bool IsContextualNamedEntity { get; }
    public ISpecializedFieldReference AsSpecializedFieldReference { get; }
    public IMetadataConstant Constant { get; }
    internal MappedField(string name, INamedTypeDefinition containingType, ITypeReference type, ImmutableArray`1<byte> block);
    public virtual string ToString();
    public sealed virtual IMetadataConstant GetCompileTimeValue(EmitContext context);
    public sealed virtual ImmutableArray`1<byte> get_MappedData();
    public sealed virtual bool get_IsCompileTimeConstant();
    public sealed virtual bool get_IsNotSerialized();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsMarshalledExplicitly();
    public sealed virtual IMarshallingInformation get_MarshallingInformation();
    public sealed virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    public sealed virtual UInt32 get_Offset();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeReference GetContainingType(EmitContext context);
    public sealed virtual IEnumerable`1<ICustomAttribute> GetAttributes(EmitContext context);
    public sealed virtual void Dispatch(MetadataVisitor visitor);
    public sealed virtual IDefinition AsDefinition(EmitContext context);
    public sealed virtual string get_Name();
    public sealed virtual bool get_IsContextualNamedEntity();
    public sealed virtual ITypeReference GetType(EmitContext context);
    public sealed virtual IFieldDefinition GetResolvedField(EmitContext context);
    public sealed virtual ISpecializedFieldReference get_AsSpecializedFieldReference();
    public IMetadataConstant get_Constant();
}
internal class Microsoft.CodeAnalysis.CodeGen.MetadataConstant : object {
    private ITypeReference _type;
    private object _value;
    private object Microsoft.Cci.IMetadataConstant.Value { get; }
    private ITypeReference Microsoft.Cci.IMetadataExpression.Type { get; }
    public MetadataConstant(ITypeReference type, object value);
    private sealed virtual override object Microsoft.Cci.IMetadataConstant.get_Value();
    private sealed virtual override void Microsoft.Cci.IMetadataExpression.Dispatch(MetadataVisitor visitor);
    private sealed virtual override ITypeReference Microsoft.Cci.IMetadataExpression.get_Type();
    [ConditionalAttribute("DEBUG")]
internal static void AssertValidConstant(object value);
}
internal class Microsoft.CodeAnalysis.CodeGen.MetadataCreateArray : object {
    private IArrayTypeReference _arrayType;
    private ITypeReference _elementType;
    private ImmutableArray`1<IMetadataExpression> _initializers;
    private ITypeReference Microsoft.Cci.IMetadataCreateArray.ElementType { get; }
    private UInt32 Microsoft.Cci.IMetadataCreateArray.ElementCount { get; }
    private IEnumerable`1<IMetadataExpression> Microsoft.Cci.IMetadataCreateArray.Elements { get; }
    private ITypeReference Microsoft.Cci.IMetadataExpression.Type { get; }
    public MetadataCreateArray(IArrayTypeReference arrayType, ITypeReference elementType, ImmutableArray`1<IMetadataExpression> initializers);
    private sealed virtual override ITypeReference Microsoft.Cci.IMetadataCreateArray.get_ElementType();
    private sealed virtual override UInt32 Microsoft.Cci.IMetadataCreateArray.get_ElementCount();
    private sealed virtual override IEnumerable`1<IMetadataExpression> Microsoft.Cci.IMetadataCreateArray.get_Elements();
    private sealed virtual override void Microsoft.Cci.IMetadataExpression.Dispatch(MetadataVisitor visitor);
    private sealed virtual override ITypeReference Microsoft.Cci.IMetadataExpression.get_Type();
}
internal class Microsoft.CodeAnalysis.CodeGen.MetadataNamedArgument : object {
    private ISymbol _entity;
    private ITypeReference _type;
    private IMetadataExpression _value;
    private string Microsoft.Cci.IMetadataNamedArgument.ArgumentName { get; }
    private IMetadataExpression Microsoft.Cci.IMetadataNamedArgument.ArgumentValue { get; }
    private bool Microsoft.Cci.IMetadataNamedArgument.IsField { get; }
    private ITypeReference Microsoft.Cci.IMetadataExpression.Type { get; }
    public MetadataNamedArgument(ISymbol entity, ITypeReference type, IMetadataExpression value);
    private sealed virtual override string Microsoft.Cci.IMetadataNamedArgument.get_ArgumentName();
    private sealed virtual override IMetadataExpression Microsoft.Cci.IMetadataNamedArgument.get_ArgumentValue();
    private sealed virtual override bool Microsoft.Cci.IMetadataNamedArgument.get_IsField();
    private sealed virtual override void Microsoft.Cci.IMetadataExpression.Dispatch(MetadataVisitor visitor);
    private sealed virtual override ITypeReference Microsoft.Cci.IMetadataExpression.get_Type();
}
internal class Microsoft.CodeAnalysis.CodeGen.MetadataTypeOf : object {
    private ITypeReference _typeToGet;
    private ITypeReference _systemType;
    public ITypeReference TypeToGet { get; }
    private ITypeReference Microsoft.Cci.IMetadataExpression.Type { get; }
    public MetadataTypeOf(ITypeReference typeToGet, ITypeReference systemType);
    public sealed virtual ITypeReference get_TypeToGet();
    private sealed virtual override void Microsoft.Cci.IMetadataExpression.Dispatch(MetadataVisitor visitor);
    private sealed virtual override ITypeReference Microsoft.Cci.IMetadataExpression.get_Type();
}
internal class Microsoft.CodeAnalysis.CodeGen.MethodBody : object {
    private IMethodDefinition _parent;
    private Byte[] _ilBits;
    private ushort _maxStack;
    private ImmutableArray`1<ILocalDefinition> _locals;
    private ImmutableArray`1<ExceptionHandlerRegion> _exceptionHandlers;
    private SequencePointList _sequencePoints;
    private DebugDocumentProvider _debugDocumentProvider;
    private ImmutableArray`1<LocalScope> _localScopes;
    private IImportScope _importScopeOpt;
    private string _stateMachineTypeNameOpt;
    private ImmutableArray`1<StateMachineHoistedLocalScope> _stateMachineHoistedLocalScopes;
    private bool _hasDynamicLocalVariables;
    private AsyncMethodBodyDebugInfo _asyncMethodDebugInfo;
    private DebugId _methodId;
    private ImmutableArray`1<EncHoistedLocalInfo> _stateMachineHoistedLocalSlots;
    private ImmutableArray`1<LambdaDebugInfo> _lambdaDebugInfo;
    private ImmutableArray`1<ClosureDebugInfo> _closureDebugInfo;
    private ImmutableArray`1<ITypeReference> _stateMachineAwaiterSlots;
    private ImmutableArray`1<ExceptionHandlerRegion> Microsoft.Cci.IMethodBody.ExceptionRegions { get; }
    private bool Microsoft.Cci.IMethodBody.LocalsAreZeroed { get; }
    private ImmutableArray`1<ILocalDefinition> Microsoft.Cci.IMethodBody.LocalVariables { get; }
    private IMethodDefinition Microsoft.Cci.IMethodBody.MethodDefinition { get; }
    private AsyncMethodBodyDebugInfo Microsoft.Cci.IMethodBody.AsyncDebugInfo { get; }
    private ushort Microsoft.Cci.IMethodBody.MaxStack { get; }
    public Byte[] IL { get; }
    public bool HasAnySequencePoints { get; }
    private ImmutableArray`1<LocalScope> Microsoft.Cci.IMethodBody.LocalScopes { get; }
    private IImportScope Microsoft.Cci.IMethodBody.ImportScope { get; }
    private string Microsoft.Cci.IMethodBody.StateMachineTypeName { get; }
    private ImmutableArray`1<StateMachineHoistedLocalScope> Microsoft.Cci.IMethodBody.StateMachineHoistedLocalScopes { get; }
    private ImmutableArray`1<EncHoistedLocalInfo> Microsoft.Cci.IMethodBody.StateMachineHoistedLocalSlots { get; }
    private ImmutableArray`1<ITypeReference> Microsoft.Cci.IMethodBody.StateMachineAwaiterSlots { get; }
    private bool Microsoft.Cci.IMethodBody.HasDynamicLocalVariables { get; }
    public DebugId MethodId { get; }
    public ImmutableArray`1<LambdaDebugInfo> LambdaDebugInfo { get; }
    public ImmutableArray`1<ClosureDebugInfo> ClosureDebugInfo { get; }
    public MethodBody(Byte[] ilBits, ushort maxStack, IMethodDefinition parent, DebugId methodId, ImmutableArray`1<ILocalDefinition> locals, SequencePointList sequencePoints, DebugDocumentProvider debugDocumentProvider, ImmutableArray`1<ExceptionHandlerRegion> exceptionHandlers, ImmutableArray`1<LocalScope> localScopes, bool hasDynamicLocalVariables, IImportScope importScopeOpt, ImmutableArray`1<LambdaDebugInfo> lambdaDebugInfo, ImmutableArray`1<ClosureDebugInfo> closureDebugInfo, string stateMachineTypeNameOpt, ImmutableArray`1<StateMachineHoistedLocalScope> stateMachineHoistedLocalScopes, ImmutableArray`1<EncHoistedLocalInfo> stateMachineHoistedLocalSlots, ImmutableArray`1<ITypeReference> stateMachineAwaiterSlots, AsyncMethodBodyDebugInfo asyncMethodDebugInfo);
    private sealed virtual override void Microsoft.Cci.IMethodBody.Dispatch(MetadataVisitor visitor);
    private sealed virtual override ImmutableArray`1<ExceptionHandlerRegion> Microsoft.Cci.IMethodBody.get_ExceptionRegions();
    private sealed virtual override bool Microsoft.Cci.IMethodBody.get_LocalsAreZeroed();
    private sealed virtual override ImmutableArray`1<ILocalDefinition> Microsoft.Cci.IMethodBody.get_LocalVariables();
    private sealed virtual override IMethodDefinition Microsoft.Cci.IMethodBody.get_MethodDefinition();
    private sealed virtual override AsyncMethodBodyDebugInfo Microsoft.Cci.IMethodBody.get_AsyncDebugInfo();
    private sealed virtual override ushort Microsoft.Cci.IMethodBody.get_MaxStack();
    public sealed virtual Byte[] get_IL();
    public sealed virtual ImmutableArray`1<SequencePoint> GetSequencePoints();
    public sealed virtual bool get_HasAnySequencePoints();
    public sealed virtual ImmutableArray`1<SequencePoint> GetLocations();
    private sealed virtual override ImmutableArray`1<LocalScope> Microsoft.Cci.IMethodBody.get_LocalScopes();
    private sealed virtual override IImportScope Microsoft.Cci.IMethodBody.get_ImportScope();
    private sealed virtual override string Microsoft.Cci.IMethodBody.get_StateMachineTypeName();
    private sealed virtual override ImmutableArray`1<StateMachineHoistedLocalScope> Microsoft.Cci.IMethodBody.get_StateMachineHoistedLocalScopes();
    private sealed virtual override ImmutableArray`1<EncHoistedLocalInfo> Microsoft.Cci.IMethodBody.get_StateMachineHoistedLocalSlots();
    private sealed virtual override ImmutableArray`1<ITypeReference> Microsoft.Cci.IMethodBody.get_StateMachineAwaiterSlots();
    private sealed virtual override bool Microsoft.Cci.IMethodBody.get_HasDynamicLocalVariables();
    public sealed virtual DebugId get_MethodId();
    public sealed virtual ImmutableArray`1<LambdaDebugInfo> get_LambdaDebugInfo();
    public sealed virtual ImmutableArray`1<ClosureDebugInfo> get_ClosureDebugInfo();
}
internal class Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference : object {
    private ICustomAttribute _sourceAttribute;
    private string _resolvedPermissionSetFilePath;
    internal static string FilePropertyName;
    internal static string HexPropertyName;
    public int ArgumentCount { get; }
    public ushort NamedArgumentCount { get; }
    public bool AllowMultiple { get; }
    public PermissionSetAttributeWithFileReference(ICustomAttribute sourceAttribute, string resolvedPermissionSetFilePath);
    private static PermissionSetAttributeWithFileReference();
    public sealed virtual ImmutableArray`1<IMetadataExpression> GetArguments(EmitContext context);
    public sealed virtual IMethodReference Constructor(EmitContext context);
    public sealed virtual ImmutableArray`1<IMetadataNamedArgument> GetNamedArguments(EmitContext context);
    internal static string ConvertToHex(Stream stream);
    private static char ConvertHexToChar(int b);
    public sealed virtual int get_ArgumentCount();
    public sealed virtual ushort get_NamedArgumentCount();
    public sealed virtual ITypeReference GetType(EmitContext context);
    public sealed virtual bool get_AllowMultiple();
}
internal class Microsoft.CodeAnalysis.CodeGen.PermissionSetFileReadException : Exception {
    private string _file;
    public string FileName { get; }
    public string PropertyName { get; }
    public PermissionSetFileReadException(string message, string file);
    public string get_FileName();
    public string get_PropertyName();
}
internal class Microsoft.CodeAnalysis.CodeGen.PrivateImplementationDetails : DefaultTypeDef {
    internal static string SynthesizedStringHashFunctionName;
    private IModule _moduleBuilder;
    private ITypeReference _systemObject;
    private ITypeReference _systemValueType;
    private ITypeReference _systemInt8Type;
    private ITypeReference _systemInt16Type;
    private ITypeReference _systemInt32Type;
    private ITypeReference _systemInt64Type;
    private ICustomAttribute _compilerGeneratedAttribute;
    private string _name;
    private int _frozen;
    private ImmutableArray`1<MappedField> _orderedMappedFields;
    private ConcurrentDictionary`2<ImmutableArray`1<byte>, MappedField> _mappedFields;
    private ImmutableArray`1<IMethodDefinition> _orderedSynthesizedMethods;
    private ConcurrentDictionary`2<string, IMethodDefinition> _synthesizedMethods;
    private ImmutableArray`1<ITypeReference> _orderedProxyTypes;
    private ConcurrentDictionary`2<UInt32, ITypeReference> _proxyTypes;
    private bool IsFrozen { get; }
    public INamespaceTypeReference AsNamespaceTypeReference { get; }
    public string Name { get; }
    public bool IsPublic { get; }
    public string NamespaceName { get; }
    internal PrivateImplementationDetails(IModule moduleBuilder, string moduleName, int submissionSlotIndex, ITypeReference systemObject, ITypeReference systemValueType, ITypeReference systemInt8Type, ITypeReference systemInt16Type, ITypeReference systemInt32Type, ITypeReference systemInt64Type, ICustomAttribute compilerGeneratedAttribute);
    private static string GetClassName(string moduleName, int submissionSlotIndex, bool isNetModule);
    internal void Freeze();
    private bool get_IsFrozen();
    internal IFieldReference CreateDataField(ImmutableArray`1<byte> data);
    private ITypeReference GetStorageStruct(UInt32 size);
    internal bool TryAddSynthesizedMethod(IMethodDefinition method);
    public virtual IEnumerable`1<IFieldDefinition> GetFields(EmitContext context);
    public virtual IEnumerable`1<IMethodDefinition> GetMethods(EmitContext context);
    internal IMethodDefinition GetMethod(string name);
    public virtual IEnumerable`1<INestedTypeDefinition> GetNestedTypes(EmitContext context);
    public virtual string ToString();
    public virtual ITypeReference GetBaseClass(EmitContext context);
    public virtual IEnumerable`1<ICustomAttribute> GetAttributes(EmitContext context);
    public virtual void Dispatch(MetadataVisitor visitor);
    public virtual INamespaceTypeDefinition AsNamespaceTypeDefinition(EmitContext context);
    public virtual INamespaceTypeReference get_AsNamespaceTypeReference();
    public sealed virtual string get_Name();
    public sealed virtual bool get_IsPublic();
    public sealed virtual IUnitReference GetUnit(EmitContext context);
    public sealed virtual string get_NamespaceName();
    internal static string GenerateDataFieldName(ImmutableArray`1<byte> data);
    private static char Hexchar(int x);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.CodeGen.RawSequencePoint : ValueType {
    internal SyntaxTree SyntaxTree;
    internal int ILMarker;
    internal TextSpan Span;
    internal static TextSpan HiddenSequencePointSpan;
    internal RawSequencePoint(SyntaxTree syntaxTree, int ilMarker, TextSpan span);
    private static RawSequencePoint();
    private string GetDebuggerDisplay();
}
internal static class Microsoft.CodeAnalysis.CodeGen.ReferenceDependencyWalker : object {
    public static void VisitReference(IReference reference, EmitContext context);
    private static void VisitTypeReference(ITypeReference typeReference, EmitContext context);
    private static void VisitMethodReference(IMethodReference methodReference, EmitContext context);
    private static void VisitParameters(ImmutableArray`1<IParameterTypeInformation> parameters, EmitContext context);
    private static void VisitFieldReference(IFieldReference fieldReference, EmitContext context);
}
internal enum Microsoft.CodeAnalysis.CodeGen.ScopeType : Enum {
    public int value__;
    public static ScopeType Variable;
    public static ScopeType TryCatchFinally;
    public static ScopeType Try;
    public static ScopeType Catch;
    public static ScopeType Filter;
    public static ScopeType Finally;
    public static ScopeType Fault;
    public static ScopeType StateMachineVariable;
}
internal class Microsoft.CodeAnalysis.CodeGen.SequencePointList : object {
    internal static int HiddenSequencePointLine;
    private SyntaxTree _tree;
    private OffsetAndSpan[] _points;
    private SequencePointList _next;
    private static SequencePointList s_empty;
    public bool IsEmpty { get; }
    private SequencePointList(SyntaxTree tree, OffsetAndSpan[] points);
    private static SequencePointList();
    public static SequencePointList Create(ArrayBuilder`1<RawSequencePoint> seqPointBuilder, ILBuilder builder);
    public bool get_IsEmpty();
    private static OffsetAndSpan[] GetSubArray(ArrayBuilder`1<RawSequencePoint> seqPointBuilder, int start, int length, ILBuilder builder);
    public ImmutableArray`1<SequencePoint> GetSequencePoints(DebugDocumentProvider documentProvider);
}
internal class Microsoft.CodeAnalysis.CodeGen.SignatureOnlyLocalDefinition : object {
    private Byte[] _signature;
    private int _slot;
    public IMetadataConstant CompileTimeValue { get; }
    public ImmutableArray`1<ICustomModifier> CustomModifiers { get; }
    public ImmutableArray`1<TypedConstant> DynamicTransformFlags { get; }
    public UInt32 PdbAttributes { get; }
    public bool IsDynamic { get; }
    public bool IsPinned { get; }
    public bool IsReference { get; }
    public LocalSlotConstraints Constraints { get; }
    public Location Location { get; }
    public string Name { get; }
    public int SlotIndex { get; }
    public ITypeReference Type { get; }
    public Byte[] Signature { get; }
    public LocalSlotDebugInfo SlotInfo { get; }
    internal SignatureOnlyLocalDefinition(Byte[] signature, int slot);
    public sealed virtual IMetadataConstant get_CompileTimeValue();
    public sealed virtual ImmutableArray`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual ImmutableArray`1<TypedConstant> get_DynamicTransformFlags();
    public sealed virtual UInt32 get_PdbAttributes();
    public sealed virtual bool get_IsDynamic();
    public sealed virtual bool get_IsPinned();
    public sealed virtual bool get_IsReference();
    public sealed virtual LocalSlotConstraints get_Constraints();
    public sealed virtual Location get_Location();
    public sealed virtual string get_Name();
    public sealed virtual int get_SlotIndex();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual Byte[] get_Signature();
    public sealed virtual LocalSlotDebugInfo get_SlotInfo();
}
internal class Microsoft.CodeAnalysis.CodeGen.StringTokenMap : object {
    private ConcurrentDictionary`2<string, UInt32> _itemToToken;
    private ArrayBuilder`1<string> _items;
    public UInt32 GetOrAddTokenFor(string item);
    private UInt32 AddItem(string item);
    public string GetItem(UInt32 token);
    public IEnumerable`1<string> GetAllItems();
    public IEnumerable`1<string> GetAllItemsAndCount(Int32& count);
}
internal class Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter : ValueType {
    private ILBuilder _builder;
    private LocalOrParameter _key;
    private PrimitiveTypeCode _keyTypeCode;
    private object _fallThroughLabel;
    private ImmutableArray`1<KeyValuePair`2<ConstantValue, object>> _sortedCaseLabels;
    private static int LinearSearchThreshold;
    internal SwitchIntegralJumpTableEmitter(ILBuilder builder, KeyValuePair`2[] caseLabels, object fallThroughLabel, PrimitiveTypeCode keyTypeCode, LocalOrParameter key);
    internal void EmitJumpTable();
    private static int CompareIntegralSwitchLabels(KeyValuePair`2<ConstantValue, object> first, KeyValuePair`2<ConstantValue, object> second);
    private ImmutableArray`1<SwitchBucket> GenerateSwitchBuckets(int startLabelIndex, int endLabelIndex);
    private SwitchBucket CreateNextBucket(int startLabelIndex, int endLabelIndex);
    private void EmitSwitchBucketsLinearLeaf(ImmutableArray`1<SwitchBucket> switchBuckets, int low, int high);
    private void EmitSwitchBuckets(ImmutableArray`1<SwitchBucket> switchBuckets, int low, int high);
    private void EmitSwitchBucket(SwitchBucket switchBucket, object bucketFallThroughLabel);
    private Object[] CreateBucketLabels(SwitchBucket switchBucket);
    private void EmitCondBranchForSwitch(ILOpCode branchCode, ConstantValue constant, object targetLabel);
    private void EmitEqBranchForSwitch(ConstantValue constant, object targetLabel);
    private static ILOpCode GetReverseBranchCode(ILOpCode branchCode);
    private void EmitNormalizedSwitchKey(ConstantValue startConstant, ConstantValue endConstant, object bucketFallThroughLabel);
    private void EmitRangeCheckIfNeeded(ConstantValue startConstant, ConstantValue endConstant, object bucketFallThroughLabel);
}
internal class Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter : ValueType {
    private ILBuilder _builder;
    private LocalOrParameter _key;
    private KeyValuePair`2[] _caseLabels;
    private object _fallThroughLabel;
    private EmitStringCompareAndBranch _emitStringCondBranchDelegate;
    private GetStringHashCode _computeStringHashcodeDelegate;
    private LocalDefinition _keyHash;
    internal SwitchStringJumpTableEmitter(ILBuilder builder, LocalOrParameter key, KeyValuePair`2[] caseLabels, object fallThroughLabel, LocalDefinition keyHash, EmitStringCompareAndBranch emitStringCondBranchDelegate, GetStringHashCode computeStringHashcodeDelegate);
    internal void EmitJumpTable();
    private void EmitHashTableSwitch();
    private Dictionary`2<UInt32, object> EmitHashBucketJumpTable(Dictionary`2<UInt32, List`1<KeyValuePair`2<ConstantValue, object>>> stringHashMap);
    private void EmitNonHashTableSwitch(KeyValuePair`2[] labels);
    private void EmitCondBranchForStringSwitch(ConstantValue stringConstant, object targetLabel);
    private static Dictionary`2<UInt32, List`1<KeyValuePair`2<ConstantValue, object>>> ComputeStringHashMap(KeyValuePair`2[] caseLabels, GetStringHashCode computeStringHashcodeDelegate);
    internal static bool ShouldGenerateHashTableSwitch(CommonPEModuleBuilder module, int labelsCount);
    private static bool ShouldGenerateHashTableSwitch(int labelsCount);
}
internal class Microsoft.CodeAnalysis.CodeGen.SynthesizedLocalOrdinalsDispenser : object {
    private PooledDictionary`2<long, int> _lazyMap;
    private static long MakeKey(SynthesizedLocalKind localKind, int syntaxOffset);
    public void Free();
    public int AssignLocalOrdinal(SynthesizedLocalKind localKind, int syntaxOffset);
}
internal class Microsoft.CodeAnalysis.CodeGen.TokenMap`1 : object {
    private ConcurrentDictionary`2<T, UInt32> _itemIdentityToToken;
    private Dictionary`2<T, UInt32> _itemToToken;
    private ArrayBuilder`1<T> _items;
    public UInt32 GetOrAddTokenFor(T item, Boolean& referenceAdded);
    private UInt32 AddItem(T item, Boolean& referenceAdded);
    public T GetItem(UInt32 token);
    public IEnumerable`1<T> GetAllItems();
    public IEnumerable`1<T> GetAllItemsAndCount(Int32& count);
}
internal abstract class Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator : object {
    public string PreviousStateMachineTypeName { get; }
    public int PreviousHoistedLocalSlotCount { get; }
    public int PreviousAwaiterSlotCount { get; }
    public Nullable`1<DebugId> MethodId { get; }
    public abstract virtual void AddPreviousLocals(ArrayBuilder`1<ILocalDefinition> builder);
    public abstract virtual LocalDefinition GetPreviousLocal(ITypeReference type, ILocalSymbolInternal symbol, string nameOpt, SynthesizedLocalKind kind, LocalDebugId id, UInt32 pdbAttributes, LocalSlotConstraints constraints, bool isDynamic, ImmutableArray`1<TypedConstant> dynamicTransformFlags);
    public abstract virtual string get_PreviousStateMachineTypeName();
    public abstract virtual bool TryGetPreviousHoistedLocalSlotIndex(SyntaxNode currentDeclarator, ITypeReference currentType, SynthesizedLocalKind synthesizedKind, LocalDebugId currentId, Int32& slotIndex);
    public abstract virtual int get_PreviousHoistedLocalSlotCount();
    public abstract virtual bool TryGetPreviousAwaiterSlotIndex(ITypeReference currentType, Int32& slotIndex);
    public abstract virtual int get_PreviousAwaiterSlotCount();
    public abstract virtual Nullable`1<DebugId> get_MethodId();
    public abstract virtual bool TryGetPreviousClosure(SyntaxNode closureSyntax, DebugId& closureId);
    public abstract virtual bool TryGetPreviousLambda(SyntaxNode lambdaOrLambdaBodySyntax, bool isLambdaBody, DebugId& lambdaId);
}
internal class Microsoft.CodeAnalysis.CodeGen.Win32Resource : object {
    private Byte[] _data;
    private UInt32 _codePage;
    private UInt32 _languageId;
    private int _id;
    private string _name;
    private int _typeId;
    private string _typeName;
    public string TypeName { get; }
    public int TypeId { get; }
    public string Name { get; }
    public int Id { get; }
    public UInt32 LanguageId { get; }
    public UInt32 CodePage { get; }
    public IEnumerable`1<byte> Data { get; }
    internal Win32Resource(Byte[] data, UInt32 codePage, UInt32 languageId, int id, string name, int typeId, string typeName);
    public sealed virtual string get_TypeName();
    public sealed virtual int get_TypeId();
    public sealed virtual string get_Name();
    public sealed virtual int get_Id();
    public sealed virtual UInt32 get_LanguageId();
    public sealed virtual UInt32 get_CodePage();
    public sealed virtual IEnumerable`1<byte> get_Data();
}
internal static class Microsoft.CodeAnalysis.COFFResourceReader : object {
    private static void ConfirmSectionValues(SectionHeader hdr, long fileSize);
    internal static ResourceSection ReadWin32ResourcesFromCOFF(Stream stream);
}
internal class Microsoft.CodeAnalysis.Collections.ByteSequenceComparer : object {
    internal static ByteSequenceComparer Instance;
    private static ByteSequenceComparer();
    internal static bool Equals(ImmutableArray`1<byte> x, ImmutableArray`1<byte> y);
    internal static bool Equals(Byte[] x, Byte[] y);
    internal static int GetHashCode(Byte[] x);
    internal static int GetHashCode(ImmutableArray`1<byte> x);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Byte[]>.Equals(Byte[] x, Byte[] y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Byte[]>.GetHashCode(Byte[] x);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Collections.Immutable.ImmutableArray<System.Byte>>.Equals(ImmutableArray`1<byte> x, ImmutableArray`1<byte> y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Collections.Immutable.ImmutableArray<System.Byte>>.GetHashCode(ImmutableArray`1<byte> x);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.CachingDictionary`2 : object {
    private Func`2<TKey, ImmutableArray`1<TElement>> _getElementsOfKey;
    private Func`2<IEqualityComparer`1<TKey>, HashSet`1<TKey>> _getKeys;
    private IEqualityComparer`1<TKey> _comparer;
    private IDictionary`2<TKey, ImmutableArray`1<TElement>> _map;
    private static ImmutableArray`1<TElement> s_emptySentinel;
    public ImmutableArray`1<TElement> Item { get; }
    public int Count { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public CachingDictionary`2(Func`2<TKey, ImmutableArray`1<TElement>> getElementsOfKey, Func`2<IEqualityComparer`1<TKey>, HashSet`1<TKey>> getKeys, IEqualityComparer`1<TKey> comparer);
    private static CachingDictionary`2();
    public bool Contains(TKey key);
    public ImmutableArray`1<TElement> get_Item(TKey key);
    public int get_Count();
    public IEnumerable`1<TKey> get_Keys();
    public void AddValues(ArrayBuilder`1<TElement> array);
    private ConcurrentDictionary`2<TKey, ImmutableArray`1<TElement>> CreateConcurrentDictionary();
    private IDictionary`2<TKey, ImmutableArray`1<TElement>> CreateDictionaryForFullyPopulatedMap(int capacity);
    private ImmutableArray`1<TElement> GetOrCreateValue(TKey key);
    private ImmutableArray`1<TElement> AddToConcurrentMap(ConcurrentDictionary`2<TKey, ImmutableArray`1<TElement>> map, TKey key);
    private static bool IsNotFullyPopulatedMap(IDictionary`2<TKey, ImmutableArray`1<TElement>> existingMap);
    private IDictionary`2<TKey, ImmutableArray`1<TElement>> CreateFullyPopulatedMap(IDictionary`2<TKey, ImmutableArray`1<TElement>> existingMap);
    private IDictionary`2<TKey, ImmutableArray`1<TElement>> EnsureFullyPopulated();
}
internal class Microsoft.CodeAnalysis.Collections.ImmutableMemoryStream : Stream {
    private ImmutableArray`1<byte> _array;
    private int _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal ImmutableMemoryStream(ImmutableArray`1<byte> array);
    public ImmutableArray`1<byte> GetBuffer();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class Microsoft.CodeAnalysis.Collections.KeyedStack`2 : object {
    private Dictionary`2<T, Stack`1<R>> _dict;
    public void Push(T key, R value);
    public bool TryPop(T key, R& value);
}
internal class Microsoft.CodeAnalysis.Collections.OrderedSet`1 : object {
    private HashSet`1<T> _set;
    private ArrayBuilder`1<T> _list;
    public int Count { get; }
    public OrderedSet`1(IEnumerable`1<T> items);
    public void AddRange(IEnumerable`1<T> items);
    public bool Add(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool Contains(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Clear();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2 : object {
    private ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> _pool;
    private static ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> s_poolInstance;
    private PooledDictionary`2<K, object> _dictionary;
    public bool IsEmpty { get; }
    public ImmutableArray`1<V> Item { get; }
    public ICollection`1<K> Keys { get; }
    private OrderPreservingMultiDictionary`2(ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> pool);
    private static OrderPreservingMultiDictionary`2();
    public void Free();
    public static ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> CreatePool();
    public static OrderPreservingMultiDictionary`2<K, V> GetInstance();
    private void EnsureDictionary();
    public bool get_IsEmpty();
    public void Add(K k, V v);
    public void AddRange(K k, ImmutableArray`1<V> values);
    public int GetCountForKey(K k);
    public bool ContainsKey(K k);
    public ImmutableArray`1<V> get_Item(K k);
    public ICollection`1<K> get_Keys();
}
internal class Microsoft.CodeAnalysis.Collections.PooledDictionary`2 : Dictionary`2<K, V> {
    private ObjectPool`1<PooledDictionary`2<K, V>> _pool;
    private static ObjectPool`1<PooledDictionary`2<K, V>> s_poolInstance;
    private PooledDictionary`2(ObjectPool`1<PooledDictionary`2<K, V>> pool);
    private static PooledDictionary`2();
    public void Free();
    public static ObjectPool`1<PooledDictionary`2<K, V>> CreatePool();
    public static PooledDictionary`2<K, V> GetInstance();
}
internal class Microsoft.CodeAnalysis.Collections.PooledHashSet`1 : HashSet`1<T> {
    private ObjectPool`1<PooledHashSet`1<T>> _pool;
    private static ObjectPool`1<PooledHashSet`1<T>> s_poolInstance;
    private PooledHashSet`1(ObjectPool`1<PooledHashSet`1<T>> pool);
    private static PooledHashSet`1();
    public void Free();
    public static ObjectPool`1<PooledHashSet`1<T>> CreatePool();
    public static PooledHashSet`1<T> GetInstance();
}
internal class Microsoft.CodeAnalysis.Collections.PooledStringBuilder : object {
    public StringBuilder Builder;
    private ObjectPool`1<PooledStringBuilder> _pool;
    private static ObjectPool`1<PooledStringBuilder> s_poolInstance;
    public int Length { get; }
    private PooledStringBuilder(ObjectPool`1<PooledStringBuilder> pool);
    private static PooledStringBuilder();
    public int get_Length();
    public void Free();
    [ObsoleteAttribute("Consider calling ToStringAndFree instead.")]
public string ToString();
    public string ToStringAndFree();
    public string ToStringAndFree(int startIndex, int length);
    public static ObjectPool`1<PooledStringBuilder> CreatePool();
    public static PooledStringBuilder GetInstance();
    public static StringBuilder op_Implicit(PooledStringBuilder obj);
}
internal class Microsoft.CodeAnalysis.Collections.SmallConcurrentSetOfInts : object {
    private int _v1;
    private int _v2;
    private int _v3;
    private int _v4;
    private SmallConcurrentSetOfInts _next;
    private static int unoccupied;
    private SmallConcurrentSetOfInts(int initialValue);
    public bool Contains(int i);
    private static bool Contains(SmallConcurrentSetOfInts set, int i);
    public bool Add(int i);
    private static bool Add(SmallConcurrentSetOfInts set, int i);
    private static bool AddHelper(Int32& slot, int i, Boolean& added);
}
public class Microsoft.CodeAnalysis.CommandLineAnalyzerReference : ValueType {
    private string _path;
    public string FilePath { get; }
    public CommandLineAnalyzerReference(string path);
    public string get_FilePath();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CommandLineAnalyzerReference other);
    public virtual int GetHashCode();
}
public abstract class Microsoft.CodeAnalysis.CommandLineArguments : object {
    [CompilerGeneratedAttribute]
private bool <IsInteractive>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ReferencePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <KeyFileSearchPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Utf8Output>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompilationName>k__BackingField;
    [CompilerGeneratedAttribute]
private EmitOptions <EmitOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PdbPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmitPdb>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentationPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorLogPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppConfigPath>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Diagnostic> <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CommandLineReference> <MetadataReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CommandLineAnalyzerReference> <AnalyzerReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CommandLineSourceFile> <AdditionalFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportAnalyzer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisplayLogo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisplayHelp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Win32ResourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Win32Icon>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Win32Manifest>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoWin32Manifest>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ResourceDescription> <ManifestResources>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceHashAlgorithm <ChecksumAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ScriptArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CommandLineSourceFile> <SourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TouchedFilesPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrintFullPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <PreferredUILang>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <SqmSessionGuid>k__BackingField;
    internal bool IsInteractive { get; internal set; }
    public string BaseDirectory { get; internal set; }
    public ImmutableArray`1<string> ReferencePaths { get; internal set; }
    public ImmutableArray`1<string> KeyFileSearchPaths { get; internal set; }
    public bool Utf8Output { get; internal set; }
    public string CompilationName { get; internal set; }
    public EmitOptions EmitOptions { get; internal set; }
    public string OutputFileName { get; internal set; }
    public string PdbPath { get; internal set; }
    public bool EmitPdb { get; internal set; }
    public string OutputDirectory { get; internal set; }
    public string DocumentationPath { get; internal set; }
    public string ErrorLogPath { get; internal set; }
    public string AppConfigPath { get; internal set; }
    public ImmutableArray`1<Diagnostic> Errors { get; internal set; }
    public ImmutableArray`1<CommandLineReference> MetadataReferences { get; internal set; }
    public ImmutableArray`1<CommandLineAnalyzerReference> AnalyzerReferences { get; internal set; }
    public ImmutableArray`1<CommandLineSourceFile> AdditionalFiles { get; internal set; }
    public bool ReportAnalyzer { get; internal set; }
    public bool DisplayLogo { get; internal set; }
    public bool DisplayHelp { get; internal set; }
    public string Win32ResourceFile { get; internal set; }
    public string Win32Icon { get; internal set; }
    public string Win32Manifest { get; internal set; }
    public bool NoWin32Manifest { get; internal set; }
    public ImmutableArray`1<ResourceDescription> ManifestResources { get; internal set; }
    public Encoding Encoding { get; internal set; }
    public SourceHashAlgorithm ChecksumAlgorithm { get; internal set; }
    internal ImmutableArray`1<string> ScriptArguments { get; internal set; }
    public ImmutableArray`1<CommandLineSourceFile> SourceFiles { get; internal set; }
    public string TouchedFilesPath { get; internal set; }
    public bool PrintFullPaths { get; internal set; }
    public ParseOptions ParseOptions { get; }
    public CompilationOptions CompilationOptions { get; }
    protected ParseOptions ParseOptionsCore { get; }
    protected CompilationOptions CompilationOptionsCore { get; }
    public CultureInfo PreferredUILang { get; internal set; }
    internal Guid SqmSessionGuid { get; internal set; }
    [CompilerGeneratedAttribute]
internal bool get_IsInteractive();
    [CompilerGeneratedAttribute]
internal void set_IsInteractive(bool value);
    [CompilerGeneratedAttribute]
public string get_BaseDirectory();
    [CompilerGeneratedAttribute]
internal void set_BaseDirectory(string value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ReferencePaths();
    [CompilerGeneratedAttribute]
internal void set_ReferencePaths(ImmutableArray`1<string> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_KeyFileSearchPaths();
    [CompilerGeneratedAttribute]
internal void set_KeyFileSearchPaths(ImmutableArray`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_Utf8Output();
    [CompilerGeneratedAttribute]
internal void set_Utf8Output(bool value);
    [CompilerGeneratedAttribute]
public string get_CompilationName();
    [CompilerGeneratedAttribute]
internal void set_CompilationName(string value);
    [CompilerGeneratedAttribute]
public EmitOptions get_EmitOptions();
    [CompilerGeneratedAttribute]
internal void set_EmitOptions(EmitOptions value);
    [CompilerGeneratedAttribute]
public string get_OutputFileName();
    [CompilerGeneratedAttribute]
internal void set_OutputFileName(string value);
    [CompilerGeneratedAttribute]
public string get_PdbPath();
    [CompilerGeneratedAttribute]
internal void set_PdbPath(string value);
    [CompilerGeneratedAttribute]
public bool get_EmitPdb();
    [CompilerGeneratedAttribute]
internal void set_EmitPdb(bool value);
    [CompilerGeneratedAttribute]
public string get_OutputDirectory();
    [CompilerGeneratedAttribute]
internal void set_OutputDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_DocumentationPath();
    [CompilerGeneratedAttribute]
internal void set_DocumentationPath(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorLogPath();
    [CompilerGeneratedAttribute]
internal void set_ErrorLogPath(string value);
    [CompilerGeneratedAttribute]
public string get_AppConfigPath();
    [CompilerGeneratedAttribute]
internal void set_AppConfigPath(string value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<Diagnostic> get_Errors();
    [CompilerGeneratedAttribute]
internal void set_Errors(ImmutableArray`1<Diagnostic> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CommandLineReference> get_MetadataReferences();
    [CompilerGeneratedAttribute]
internal void set_MetadataReferences(ImmutableArray`1<CommandLineReference> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CommandLineAnalyzerReference> get_AnalyzerReferences();
    [CompilerGeneratedAttribute]
internal void set_AnalyzerReferences(ImmutableArray`1<CommandLineAnalyzerReference> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CommandLineSourceFile> get_AdditionalFiles();
    [CompilerGeneratedAttribute]
internal void set_AdditionalFiles(ImmutableArray`1<CommandLineSourceFile> value);
    [CompilerGeneratedAttribute]
public bool get_ReportAnalyzer();
    [CompilerGeneratedAttribute]
internal void set_ReportAnalyzer(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisplayLogo();
    [CompilerGeneratedAttribute]
internal void set_DisplayLogo(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisplayHelp();
    [CompilerGeneratedAttribute]
internal void set_DisplayHelp(bool value);
    [CompilerGeneratedAttribute]
public string get_Win32ResourceFile();
    [CompilerGeneratedAttribute]
internal void set_Win32ResourceFile(string value);
    [CompilerGeneratedAttribute]
public string get_Win32Icon();
    [CompilerGeneratedAttribute]
internal void set_Win32Icon(string value);
    [CompilerGeneratedAttribute]
public string get_Win32Manifest();
    [CompilerGeneratedAttribute]
internal void set_Win32Manifest(string value);
    [CompilerGeneratedAttribute]
public bool get_NoWin32Manifest();
    [CompilerGeneratedAttribute]
internal void set_NoWin32Manifest(bool value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ResourceDescription> get_ManifestResources();
    [CompilerGeneratedAttribute]
internal void set_ManifestResources(ImmutableArray`1<ResourceDescription> value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
internal void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public SourceHashAlgorithm get_ChecksumAlgorithm();
    [CompilerGeneratedAttribute]
internal void set_ChecksumAlgorithm(SourceHashAlgorithm value);
    [CompilerGeneratedAttribute]
internal ImmutableArray`1<string> get_ScriptArguments();
    [CompilerGeneratedAttribute]
internal void set_ScriptArguments(ImmutableArray`1<string> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CommandLineSourceFile> get_SourceFiles();
    [CompilerGeneratedAttribute]
internal void set_SourceFiles(ImmutableArray`1<CommandLineSourceFile> value);
    [CompilerGeneratedAttribute]
public string get_TouchedFilesPath();
    [CompilerGeneratedAttribute]
internal void set_TouchedFilesPath(string value);
    [CompilerGeneratedAttribute]
public bool get_PrintFullPaths();
    [CompilerGeneratedAttribute]
internal void set_PrintFullPaths(bool value);
    public ParseOptions get_ParseOptions();
    public CompilationOptions get_CompilationOptions();
    protected abstract virtual ParseOptions get_ParseOptionsCore();
    protected abstract virtual CompilationOptions get_CompilationOptionsCore();
    [CompilerGeneratedAttribute]
public CultureInfo get_PreferredUILang();
    [CompilerGeneratedAttribute]
internal void set_PreferredUILang(CultureInfo value);
    [CompilerGeneratedAttribute]
internal Guid get_SqmSessionGuid();
    [CompilerGeneratedAttribute]
internal void set_SqmSessionGuid(Guid value);
    public IEnumerable`1<MetadataReference> ResolveMetadataReferences(MetadataReferenceResolver metadataResolver);
    internal IEnumerable`1<MetadataReference> ResolveMetadataReferences(MetadataReferenceResolver metadataResolver, List`1<DiagnosticInfo> diagnosticsOpt, CommonMessageProvider messageProviderOpt);
    internal virtual bool ResolveMetadataReferences(MetadataReferenceResolver metadataResolver, List`1<DiagnosticInfo> diagnosticsOpt, CommonMessageProvider messageProviderOpt, List`1<MetadataReference> resolved);
    internal static ImmutableArray`1<PortableExecutableReference> ResolveMetadataReference(CommandLineReference cmdReference, MetadataReferenceResolver metadataResolver, List`1<DiagnosticInfo> diagnosticsOpt, CommonMessageProvider messageProviderOpt);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CommandLineArguments/<ResolveAnalyzerReferences>d__149")]
public IEnumerable`1<AnalyzerReference> ResolveAnalyzerReferences(IAnalyzerAssemblyLoader analyzerLoader);
    internal ImmutableArray`1<DiagnosticAnalyzer> ResolveAnalyzersFromArguments(string language, List`1<DiagnosticInfo> diagnostics, CommonMessageProvider messageProvider, TouchedFileLogger touchedFiles, IAnalyzerAssemblyLoader analyzerLoader);
    private AnalyzerFileReference ResolveAnalyzerReference(CommandLineAnalyzerReference reference, IAnalyzerAssemblyLoader analyzerLoader);
}
public abstract class Microsoft.CodeAnalysis.CommandLineParser : object {
    private CommonMessageProvider _messageProvider;
    private bool _isInteractive;
    private static Char[] s_searchPatterTrimChars;
    private static Char[] s_resourceSeparators;
    private static Char[] s_pathSeparators;
    private static Char[] s_wildcards;
    internal CommonMessageProvider MessageProvider { get; }
    internal bool IsInteractive { get; }
    internal string RegularFileExtension { get; }
    internal string ScriptFileExtension { get; }
    internal static string MismatchedVersionErrorText { get; }
    internal CommandLineParser(CommonMessageProvider messageProvider, bool isInteractive);
    private static CommandLineParser();
    internal CommonMessageProvider get_MessageProvider();
    internal bool get_IsInteractive();
    internal abstract virtual string get_RegularFileExtension();
    internal abstract virtual string get_ScriptFileExtension();
    internal virtual TextReader CreateTextFileReader(string fullPath);
    internal virtual IEnumerable`1<string> EnumerateFiles(string directory, string fileNamePattern, object searchOption);
    internal abstract virtual CommandLineArguments CommonParse(IEnumerable`1<string> args, string baseDirectory, string sdkDirectory, string additionalReferenceDirectories);
    public CommandLineArguments Parse(IEnumerable`1<string> args, string baseDirectory, string sdkDirectory, string additionalReferenceDirectories);
    internal static bool TryParseOption(string arg, String& name, String& value);
    internal static void ParseAndNormalizeFile(string unquoted, string baseDirectory, String& outputFileName, String& outputDirectory, String& invalidPath);
    internal static string RemoveTrailingSpacesAndDots(string path);
    internal void ParseOutputFile(string value, IList`1<Diagnostic> errors, string baseDirectory, String& outputFileName, String& outputDirectory);
    internal string ParsePdbPath(string value, IList`1<Diagnostic> errors, string baseDirectory);
    internal string ParseGenericPathToFile(string unquoted, IList`1<Diagnostic> errors, string baseDirectory, bool generateDiagnostic);
    internal void FlattenArgs(IEnumerable`1<string> rawArguments, IList`1<Diagnostic> diagnostics, List`1<string> processedArgs, List`1<string> scriptArgs, string baseDirectory, List`1<string> responsePaths);
    internal static bool TryParseClientArgs(IEnumerable`1<string> args, List`1& parsedArgs, Boolean& containsShared, String& keepAliveValue, String& errorMessage);
    internal static string get_MismatchedVersionErrorText();
    internal IEnumerable`1<string> ParseResponseFile(string fullPath, IList`1<Diagnostic> errors);
    internal static IEnumerable`1<string> ParseResponseLines(IEnumerable`1<string> lines);
    internal static void ParseResourceDescription(string resourceDescriptor, string baseDirectory, bool skipLeadingSeparators, String& filePath, String& fullPath, String& fileName, String& resourceName, String& accessibility);
    internal static string RemoveAllQuotes(string arg);
    public static IEnumerable`1<string> SplitCommandLineIntoArguments(string commandLine, bool removeHashComments);
    private static string UnquoteAndUnescape(string v);
    private static bool IsCommandLineDelimiter(char c);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CommandLineParser/<Split>d__34")]
private static IEnumerable`1<string> Split(string str, Func`2<char, bool> splitHere);
    private static string NormalizeBackslashes(string input);
    private static void AddBackslashes(StringBuilder builder, int count);
    internal static IEnumerable`1<string> ParseSeparatedPaths(string str);
    internal static IEnumerable`1<string> ParseSeparatedStrings(string str, Char[] separators, StringSplitOptions options);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CommandLineParser/<ResolveRelativePaths>d__41")]
internal IEnumerable`1<string> ResolveRelativePaths(IEnumerable`1<string> paths, string baseDirectory, IList`1<Diagnostic> errors);
    private CommandLineSourceFile ToCommandLineSourceFile(string resolvedPath);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CommandLineParser/<ParseFileArgument>d__43")]
internal IEnumerable`1<CommandLineSourceFile> ParseFileArgument(string arg, string baseDirectory, IList`1<Diagnostic> errors);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CommandLineParser/<ParseAdditionalFileArgument>d__44")]
internal IEnumerable`1<CommandLineSourceFile> ParseAdditionalFileArgument(string value, string baseDirectory, IList`1<Diagnostic> errors);
    internal IEnumerable`1<CommandLineSourceFile> ParseRecurseArgument(string arg, string baseDirectory, IList`1<Diagnostic> errors);
    internal Encoding TryParseEncodingName(string arg);
    internal SourceHashAlgorithm TryParseHashAlgorithmName(string arg);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CommandLineParser/<ExpandFileNamePattern>d__48")]
private IEnumerable`1<CommandLineSourceFile> ExpandFileNamePattern(string path, string baseDirectory, object searchOption, IList`1<Diagnostic> errors);
    internal abstract virtual void GenerateErrorForNoFilesFoundInRecurse(string path, IList`1<Diagnostic> errors);
    internal ReportDiagnostic GetDiagnosticOptionsFromRulesetFile(Dictionary`2<string, ReportDiagnostic> diagnosticOptions, IList`1<Diagnostic> diagnostics, string path, string baseDirectory);
    internal static bool TryParseUInt64(string value, UInt64& result);
    internal static bool TryParseUInt16(string value, UInt16& result);
}
public class Microsoft.CodeAnalysis.CommandLineReference : ValueType {
    private string _reference;
    private MetadataReferenceProperties _properties;
    public string Reference { get; }
    public MetadataReferenceProperties Properties { get; }
    internal CommandLineReference(string reference, MetadataReferenceProperties properties);
    public string get_Reference();
    public MetadataReferenceProperties get_Properties();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CommandLineReference other);
    public virtual int GetHashCode();
}
public class Microsoft.CodeAnalysis.CommandLineSourceFile : ValueType {
    private string _path;
    private bool _isScript;
    public string Path { get; }
    public bool IsScript { get; }
    internal CommandLineSourceFile(string path, bool isScript);
    public string get_Path();
    public bool get_IsScript();
}
internal class Microsoft.CodeAnalysis.CommonAssemblyWellKnownAttributeData`1 : WellKnownAttributeData {
    private string _assemblySignatureKeyAttributeSetting;
    private ThreeState _assemblyDelaySignAttributeSetting;
    private string _assemblyKeyFileAttributeSetting;
    private string _assemblyKeyContainerAttributeSetting;
    private Version _assemblyVersionAttributeSetting;
    private string _assemblyFileVersionAttributeSetting;
    private string _assemblyTitleAttributeSetting;
    private string _assemblyDescriptionAttributeSetting;
    private string _assemblyCultureAttributeSetting;
    private string _assemblyCompanyAttributeSetting;
    private string _assemblyProductAttributeSetting;
    private string _assemblyInformationalVersionAttributeSetting;
    private string _assemblyCopyrightAttributeSetting;
    private string _assemblyTrademarkAttributeSetting;
    private AssemblyNameFlags _assemblyFlagsAttributeSetting;
    private Nullable`1<AssemblyHashAlgorithm> _assemblyAlgorithmIdAttributeSetting;
    private bool _hasCompilationRelaxationsAttribute;
    private Nullable`1<bool> _runtimeCompatibilityWrapNonExceptionThrows;
    internal static bool WrapNonExceptionThrowsDefault;
    private bool _hasDebuggableAttribute;
    private SecurityWellKnownAttributeData _lazySecurityAttributeData;
    private HashSet`1<TNamedTypeSymbol> _forwardedTypes;
    public string AssemblySignatureKeyAttributeSetting { get; public set; }
    public ThreeState AssemblyDelaySignAttributeSetting { get; public set; }
    public string AssemblyKeyFileAttributeSetting { get; public set; }
    public string AssemblyKeyContainerAttributeSetting { get; public set; }
    public Version AssemblyVersionAttributeSetting { get; public set; }
    public string AssemblyFileVersionAttributeSetting { get; public set; }
    public string AssemblyTitleAttributeSetting { get; public set; }
    public string AssemblyDescriptionAttributeSetting { get; public set; }
    public string AssemblyCultureAttributeSetting { get; public set; }
    public string AssemblyCompanyAttributeSetting { get; public set; }
    public string AssemblyProductAttributeSetting { get; public set; }
    public string AssemblyInformationalVersionAttributeSetting { get; public set; }
    public string AssemblyCopyrightAttributeSetting { get; public set; }
    public string AssemblyTrademarkAttributeSetting { get; public set; }
    public AssemblyNameFlags AssemblyFlagsAttributeSetting { get; public set; }
    public Nullable`1<AssemblyHashAlgorithm> AssemblyAlgorithmIdAttributeSetting { get; public set; }
    public bool HasCompilationRelaxationsAttribute { get; public set; }
    public bool HasRuntimeCompatibilityAttribute { get; }
    public bool RuntimeCompatibilityWrapNonExceptionThrows { get; public set; }
    public bool HasDebuggableAttribute { get; public set; }
    public SecurityWellKnownAttributeData SecurityInformation { get; }
    public HashSet`1<TNamedTypeSymbol> ForwardedTypes { get; public set; }
    public string get_AssemblySignatureKeyAttributeSetting();
    public void set_AssemblySignatureKeyAttributeSetting(string value);
    public ThreeState get_AssemblyDelaySignAttributeSetting();
    public void set_AssemblyDelaySignAttributeSetting(ThreeState value);
    public string get_AssemblyKeyFileAttributeSetting();
    public void set_AssemblyKeyFileAttributeSetting(string value);
    public string get_AssemblyKeyContainerAttributeSetting();
    public void set_AssemblyKeyContainerAttributeSetting(string value);
    public Version get_AssemblyVersionAttributeSetting();
    public void set_AssemblyVersionAttributeSetting(Version value);
    public string get_AssemblyFileVersionAttributeSetting();
    public void set_AssemblyFileVersionAttributeSetting(string value);
    public string get_AssemblyTitleAttributeSetting();
    public void set_AssemblyTitleAttributeSetting(string value);
    public string get_AssemblyDescriptionAttributeSetting();
    public void set_AssemblyDescriptionAttributeSetting(string value);
    public string get_AssemblyCultureAttributeSetting();
    public void set_AssemblyCultureAttributeSetting(string value);
    public string get_AssemblyCompanyAttributeSetting();
    public void set_AssemblyCompanyAttributeSetting(string value);
    public string get_AssemblyProductAttributeSetting();
    public void set_AssemblyProductAttributeSetting(string value);
    public string get_AssemblyInformationalVersionAttributeSetting();
    public void set_AssemblyInformationalVersionAttributeSetting(string value);
    public string get_AssemblyCopyrightAttributeSetting();
    public void set_AssemblyCopyrightAttributeSetting(string value);
    public string get_AssemblyTrademarkAttributeSetting();
    public void set_AssemblyTrademarkAttributeSetting(string value);
    public AssemblyNameFlags get_AssemblyFlagsAttributeSetting();
    public void set_AssemblyFlagsAttributeSetting(AssemblyNameFlags value);
    public Nullable`1<AssemblyHashAlgorithm> get_AssemblyAlgorithmIdAttributeSetting();
    public void set_AssemblyAlgorithmIdAttributeSetting(Nullable`1<AssemblyHashAlgorithm> value);
    public bool get_HasCompilationRelaxationsAttribute();
    public void set_HasCompilationRelaxationsAttribute(bool value);
    public bool get_HasRuntimeCompatibilityAttribute();
    public bool get_RuntimeCompatibilityWrapNonExceptionThrows();
    public void set_RuntimeCompatibilityWrapNonExceptionThrows(bool value);
    public bool get_HasDebuggableAttribute();
    public void set_HasDebuggableAttribute(bool value);
    private sealed virtual override SecurityWellKnownAttributeData Microsoft.CodeAnalysis.ISecurityAttributeTarget.GetOrCreateData();
    public SecurityWellKnownAttributeData get_SecurityInformation();
    public HashSet`1<TNamedTypeSymbol> get_ForwardedTypes();
    public void set_ForwardedTypes(HashSet`1<TNamedTypeSymbol> value);
}
internal class Microsoft.CodeAnalysis.CommonAttributeDataComparer : object {
    public static CommonAttributeDataComparer Instance;
    private static CommonAttributeDataComparer();
    public sealed virtual bool Equals(AttributeData attr1, AttributeData attr2);
    public sealed virtual int GetHashCode(AttributeData attr);
    private static int GetHashCodeForConstructorArguments(ImmutableArray`1<TypedConstant> constructorArguments);
    private static int GetHashCodeForNamedArguments(ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArguments);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CommonAttributeDataExtensions : object {
    [ExtensionAttribute]
public static bool TryGetGuidAttributeValue(AttributeData attrData, String& guidString);
}
internal abstract class Microsoft.CodeAnalysis.CommonCompiler : object {
    internal static int Failed;
    internal static int Succeeded;
    private string _clientDirectory;
    [CompilerGeneratedAttribute]
private CommonMessageProvider <MessageProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandLineArguments <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IAnalyzerAssemblyLoader <AnalyzerLoader>k__BackingField;
    private HashSet`1<Diagnostic> _reportedDiagnostics;
    private Func`5<string, object, object, object, Stream> _fileOpen;
    public CommonMessageProvider MessageProvider { get; }
    public CommandLineArguments Arguments { get; }
    public IAnalyzerAssemblyLoader AnalyzerLoader { get; private set; }
    public DiagnosticFormatter DiagnosticFormatter { get; }
    internal Func`5<string, object, object, object, Stream> FileOpen { get; internal set; }
    protected CultureInfo Culture { get; }
    public CommonCompiler(CommandLineParser parser, string responseFile, String[] args, string clientDirectory, string baseDirectory, string sdkDirectory, string additionalReferenceDirectories, IAnalyzerAssemblyLoader analyzerLoader);
    [CompilerGeneratedAttribute]
public CommonMessageProvider get_MessageProvider();
    [CompilerGeneratedAttribute]
public CommandLineArguments get_Arguments();
    [CompilerGeneratedAttribute]
public IAnalyzerAssemblyLoader get_AnalyzerLoader();
    [CompilerGeneratedAttribute]
private void set_AnalyzerLoader(IAnalyzerAssemblyLoader value);
    public abstract virtual DiagnosticFormatter get_DiagnosticFormatter();
    public abstract virtual Compilation CreateCompilation(TextWriter consoleOutput, TouchedFileLogger touchedFilesLogger, ErrorLogger errorLogger);
    public abstract virtual void PrintLogo(TextWriter consoleOutput);
    public abstract virtual void PrintHelp(TextWriter consoleOutput);
    internal abstract virtual string GetToolName();
    protected abstract virtual UInt32 GetSqmAppID();
    protected abstract virtual bool TryGetCompilerDiagnosticCode(string diagnosticId, UInt32& code);
    protected abstract virtual void CompilerSpecificSqm(IVsSqmMulti sqm, UInt32 sqmSession);
    protected abstract virtual ImmutableArray`1<DiagnosticAnalyzer> ResolveAnalyzersFromArguments(List`1<DiagnosticInfo> diagnostics, CommonMessageProvider messageProvider, TouchedFileLogger touchedFiles);
    internal abstract virtual bool SuppressDefaultResponseFile(IEnumerable`1<string> args);
    internal string GetAssemblyFileVersion();
    internal Version GetAssemblyVersion();
    internal virtual MetadataFileReferenceProvider GetMetadataProvider();
    internal virtual MetadataFileReferenceResolver GetExternalMetadataResolver(TouchedFileLogger touchedFiles);
    internal List`1<MetadataReference> ResolveMetadataReferences(MetadataFileReferenceResolver externalReferenceResolver, MetadataFileReferenceProvider metadataProvider, List`1<DiagnosticInfo> diagnostics, AssemblyIdentityComparer assemblyIdentityComparer, TouchedFileLogger touchedFiles, MetadataFileReferenceResolver& referenceDirectiveResolver);
    internal SourceText ReadFileContent(CommandLineSourceFile file, IList`1<DiagnosticInfo> diagnostics, Encoding encoding, SourceHashAlgorithm checksumAlgorithm);
    internal SourceText ReadFileContent(CommandLineSourceFile file, IList`1<DiagnosticInfo> diagnostics, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, String& normalizedFilePath);
    private DiagnosticInfo ToFileReadDiagnostics(Exception e, CommandLineSourceFile file);
    public bool ReportErrors(IEnumerable`1<Diagnostic> diagnostics, TextWriter consoleOutput, ErrorLogger errorLogger);
    public bool ReportErrors(IEnumerable`1<DiagnosticInfo> diagnostics, TextWriter consoleOutput, ErrorLogger errorLogger);
    protected virtual void PrintError(DiagnosticInfo diagnostic, TextWriter consoleOutput);
    public ErrorLogger GetErrorLogger(TextWriter consoleOutput, CancellationToken cancellationToken);
    public virtual int Run(TextWriter consoleOutput, CancellationToken cancellationToken);
    private int RunCore(TextWriter consoleOutput, ErrorLogger errorLogger, CancellationToken cancellationToken);
    protected virtual ImmutableArray`1<AdditionalTextFile> ResolveAdditionalFilesFromArguments(List`1<DiagnosticInfo> diagnostics, CommonMessageProvider messageProvider, TouchedFileLogger touchedFilesLogger);
    private static void ReportAnalyzerExecutionTime(TextWriter consoleOutput, AnalyzerDriver analyzerDriver, CultureInfo culture, bool isConcurrentBuild);
    private void GenerateSqmData(CompilationOptions compilationOptions, ImmutableArray`1<Diagnostic> diagnostics);
    protected virtual string GetOutputFileName(Compilation compilation, CancellationToken cancellationToken);
    internal Func`5<string, object, object, object, Stream> get_FileOpen();
    internal void set_FileOpen(Func`5<string, object, object, object, Stream> value);
    private Stream OpenFile(string filePath, TextWriter consoleOutput, object mode, object access, object share);
    protected Stream GetWin32Resources(CommandLineArguments arguments, Compilation compilation, IEnumerable`1& errors);
    internal static Stream GetWin32ResourcesInternal(CommonMessageProvider messageProvider, CommandLineArguments arguments, Compilation compilation, IEnumerable`1& errors);
    private static Stream OpenManifestStream(CommonMessageProvider messageProvider, OutputKind outputKind, CommandLineArguments arguments, List`1<DiagnosticInfo> errorList);
    private static Stream OpenStream(CommonMessageProvider messageProvider, string path, string baseDirectory, int errorCode, IList`1<DiagnosticInfo> errors);
    private static string ResolveRelativePath(CommonMessageProvider messageProvider, string path, string baseDirectory, IList`1<DiagnosticInfo> errors);
    internal static bool TryGetCompilerDiagnosticCode(string diagnosticId, string expectedPrefix, UInt32& code);
    protected virtual CultureInfo get_Culture();
}
internal class Microsoft.CodeAnalysis.CommonDiagnosticComparer : object {
    public sealed virtual bool Equals(Diagnostic x, Diagnostic y);
    public sealed virtual int GetHashCode(Diagnostic obj);
}
internal class Microsoft.CodeAnalysis.CommonEventEarlyWellKnownAttributeData : EarlyWellKnownAttributeData {
    private ObsoleteAttributeData _obsoleteAttributeData;
    public ObsoleteAttributeData ObsoleteAttributeData { get; public set; }
    public ObsoleteAttributeData get_ObsoleteAttributeData();
    public void set_ObsoleteAttributeData(ObsoleteAttributeData value);
}
internal class Microsoft.CodeAnalysis.CommonEventWellKnownAttributeData : WellKnownAttributeData {
    private bool _hasSpecialNameAttribute;
    public bool HasSpecialNameAttribute { get; public set; }
    public bool get_HasSpecialNameAttribute();
    public void set_HasSpecialNameAttribute(bool value);
}
internal class Microsoft.CodeAnalysis.CommonFieldEarlyWellKnownAttributeData : EarlyWellKnownAttributeData {
    private ObsoleteAttributeData _obsoleteAttributeData;
    public ObsoleteAttributeData ObsoleteAttributeData { get; public set; }
    public ObsoleteAttributeData get_ObsoleteAttributeData();
    public void set_ObsoleteAttributeData(ObsoleteAttributeData value);
}
internal class Microsoft.CodeAnalysis.CommonFieldWellKnownAttributeData : WellKnownAttributeData {
    private int _offset;
    private static int Uninitialized;
    private ConstantValue _constValue;
    private bool _hasSpecialNameAttribute;
    private bool _hasNonSerializedAttribute;
    private MarshalPseudoCustomAttributeData _lazyMarshalAsData;
    public Nullable`1<int> Offset { get; }
    public ConstantValue ConstValue { get; public set; }
    public bool HasSpecialNameAttribute { get; public set; }
    public bool HasNonSerializedAttribute { get; public set; }
    public MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    public void SetFieldOffset(int offset);
    public Nullable`1<int> get_Offset();
    public ConstantValue get_ConstValue();
    public void set_ConstValue(ConstantValue value);
    public bool get_HasSpecialNameAttribute();
    public void set_HasSpecialNameAttribute(bool value);
    public bool get_HasNonSerializedAttribute();
    public void set_HasNonSerializedAttribute(bool value);
    private sealed virtual override MarshalPseudoCustomAttributeData Microsoft.CodeAnalysis.IMarshalAsAttributeTarget.GetOrCreateData();
    public MarshalPseudoCustomAttributeData get_MarshallingInformation();
}
internal abstract class Microsoft.CodeAnalysis.CommonMessageProvider : object {
    public string CodePrefix { get; }
    public Type ErrorCodeType { get; }
    public int ERR_FailedToCreateTempFile { get; }
    public int ERR_NoScriptsSpecified { get; }
    public int ERR_OpenResponseFile { get; }
    public int FTL_InputFileNameTooLong { get; }
    public int ERR_FileNotFound { get; }
    public int ERR_NoSourceFile { get; }
    public int ERR_CantOpenFileWrite { get; }
    public int ERR_OutputWriteFailed { get; }
    public int WRN_NoConfigNotOnCommandLine { get; }
    public int ERR_BinaryFile { get; }
    public int WRN_UnableToLoadAnalyzer { get; }
    public int INF_UnableToLoadSomeTypesInAnalyzer { get; }
    public int WRN_AnalyzerCannotBeCreated { get; }
    public int WRN_NoAnalyzerInAssembly { get; }
    public int ERR_CantReadRulesetFile { get; }
    public int ERR_CompileCancelled { get; }
    public int ERR_BadCompilationOptionValue { get; }
    public int ERR_InvalidDebugInformationFormat { get; }
    public int ERR_InvalidFileAlignment { get; }
    public int ERR_InvalidSubsystemVersion { get; }
    public int ERR_InvalidOutputName { get; }
    public int ERR_MetadataFileNotAssembly { get; }
    public int ERR_MetadataFileNotModule { get; }
    public int ERR_InvalidAssemblyMetadata { get; }
    public int ERR_InvalidModuleMetadata { get; }
    public int ERR_ErrorOpeningAssemblyFile { get; }
    public int ERR_ErrorOpeningModuleFile { get; }
    public int ERR_MetadataFileNotFound { get; }
    public int ERR_MetadataReferencesNotSupported { get; }
    public int ERR_LinkedNetmoduleMetadataMustProvideFullPEImage { get; }
    public int ERR_PublicKeyFileFailure { get; }
    public int ERR_PublicKeyContainerFailure { get; }
    public int ERR_CantReadResource { get; }
    public int ERR_CantOpenWin32Resource { get; }
    public int ERR_CantOpenWin32Manifest { get; }
    public int ERR_CantOpenWin32Icon { get; }
    public int ERR_BadWin32Resource { get; }
    public int ERR_ErrorBuildingWin32Resource { get; }
    public int ERR_ResourceNotUnique { get; }
    public int ERR_ResourceFileNameNotUnique { get; }
    public int ERR_ResourceInModule { get; }
    public int ERR_PermissionSetAttributeFileReadError { get; }
    public int WRN_PdbUsingNameTooLong { get; }
    public int WRN_PdbLocalNameTooLong { get; }
    public int ERR_PdbWritingFailed { get; }
    public int ERR_MetadataNameTooLong { get; }
    public int ERR_EncReferenceToAddedMember { get; }
    public abstract virtual DiagnosticSeverity GetSeverity(int code);
    public abstract virtual string LoadMessage(int code, CultureInfo language);
    public abstract virtual LocalizableString GetTitle(int code);
    public abstract virtual LocalizableString GetDescription(int code);
    public abstract virtual LocalizableString GetMessageFormat(int code);
    public abstract virtual string GetHelpLink(int code);
    public abstract virtual string GetCategory(int code);
    public abstract virtual string get_CodePrefix();
    public abstract virtual int GetWarningLevel(int code);
    public abstract virtual Type get_ErrorCodeType();
    public Diagnostic CreateDiagnostic(int code, Location location);
    public abstract virtual Diagnostic CreateDiagnostic(int code, Location location, Object[] args);
    public abstract virtual string GetMessagePrefix(string id, DiagnosticSeverity severity, bool isWarningAsError, CultureInfo culture);
    public abstract virtual string ConvertSymbolToString(int errorCode, ISymbol symbol);
    public string GetIdForErrorCode(int errorCode);
    public abstract virtual ReportDiagnostic GetDiagnosticReport(DiagnosticInfo diagnosticInfo, CompilationOptions options);
    public DiagnosticInfo FilterDiagnosticInfo(DiagnosticInfo diagnosticInfo, CompilationOptions options);
    public abstract virtual int get_ERR_FailedToCreateTempFile();
    public abstract virtual int get_ERR_NoScriptsSpecified();
    public abstract virtual int get_ERR_OpenResponseFile();
    public abstract virtual int get_FTL_InputFileNameTooLong();
    public abstract virtual int get_ERR_FileNotFound();
    public abstract virtual int get_ERR_NoSourceFile();
    public abstract virtual int get_ERR_CantOpenFileWrite();
    public abstract virtual int get_ERR_OutputWriteFailed();
    public abstract virtual int get_WRN_NoConfigNotOnCommandLine();
    public abstract virtual int get_ERR_BinaryFile();
    public abstract virtual int get_WRN_UnableToLoadAnalyzer();
    public abstract virtual int get_INF_UnableToLoadSomeTypesInAnalyzer();
    public abstract virtual int get_WRN_AnalyzerCannotBeCreated();
    public abstract virtual int get_WRN_NoAnalyzerInAssembly();
    public abstract virtual int get_ERR_CantReadRulesetFile();
    public abstract virtual int get_ERR_CompileCancelled();
    public abstract virtual int get_ERR_BadCompilationOptionValue();
    public abstract virtual int get_ERR_InvalidDebugInformationFormat();
    public abstract virtual int get_ERR_InvalidFileAlignment();
    public abstract virtual int get_ERR_InvalidSubsystemVersion();
    public abstract virtual int get_ERR_InvalidOutputName();
    public abstract virtual int get_ERR_MetadataFileNotAssembly();
    public abstract virtual int get_ERR_MetadataFileNotModule();
    public abstract virtual int get_ERR_InvalidAssemblyMetadata();
    public abstract virtual int get_ERR_InvalidModuleMetadata();
    public abstract virtual int get_ERR_ErrorOpeningAssemblyFile();
    public abstract virtual int get_ERR_ErrorOpeningModuleFile();
    public abstract virtual int get_ERR_MetadataFileNotFound();
    public abstract virtual int get_ERR_MetadataReferencesNotSupported();
    public abstract virtual int get_ERR_LinkedNetmoduleMetadataMustProvideFullPEImage();
    public abstract virtual void ReportDuplicateMetadataReferenceStrong(DiagnosticBag diagnostics, Location location, MetadataReference reference, AssemblyIdentity identity, MetadataReference equivalentReference, AssemblyIdentity equivalentIdentity);
    public abstract virtual void ReportDuplicateMetadataReferenceWeak(DiagnosticBag diagnostics, Location location, MetadataReference reference, AssemblyIdentity identity, MetadataReference equivalentReference, AssemblyIdentity equivalentIdentity);
    public abstract virtual int get_ERR_PublicKeyFileFailure();
    public abstract virtual int get_ERR_PublicKeyContainerFailure();
    public abstract virtual int get_ERR_CantReadResource();
    public abstract virtual int get_ERR_CantOpenWin32Resource();
    public abstract virtual int get_ERR_CantOpenWin32Manifest();
    public abstract virtual int get_ERR_CantOpenWin32Icon();
    public abstract virtual int get_ERR_BadWin32Resource();
    public abstract virtual int get_ERR_ErrorBuildingWin32Resource();
    public abstract virtual int get_ERR_ResourceNotUnique();
    public abstract virtual int get_ERR_ResourceFileNameNotUnique();
    public abstract virtual int get_ERR_ResourceInModule();
    public abstract virtual int get_ERR_PermissionSetAttributeFileReadError();
    public abstract virtual int get_WRN_PdbUsingNameTooLong();
    public abstract virtual int get_WRN_PdbLocalNameTooLong();
    public abstract virtual int get_ERR_PdbWritingFailed();
    public abstract virtual int get_ERR_MetadataNameTooLong();
    public abstract virtual int get_ERR_EncReferenceToAddedMember();
    public abstract virtual void ReportInvalidAttributeArgument(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int parameterIndex, AttributeData attribute);
    public abstract virtual void ReportInvalidNamedArgument(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int namedArgumentIndex, ITypeSymbol attributeClass, string parameterName);
    public abstract virtual void ReportParameterNotValidForType(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int namedArgumentIndex);
    public abstract virtual void ReportMarshalUnmanagedTypeNotValidForFields(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int parameterIndex, string unmanagedTypeName, AttributeData attribute);
    public abstract virtual void ReportMarshalUnmanagedTypeOnlyValidForFields(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int parameterIndex, string unmanagedTypeName, AttributeData attribute);
    public abstract virtual void ReportAttributeParameterRequired(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, string parameterName);
    public abstract virtual void ReportAttributeParameterRequired(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, string parameterName1, string parameterName2);
}
internal class Microsoft.CodeAnalysis.CommonMethodEarlyWellKnownAttributeData : EarlyWellKnownAttributeData {
    private ImmutableArray`1<string> _lazyConditionalSymbols;
    private ObsoleteAttributeData _obsoleteAttributeData;
    public ImmutableArray`1<string> ConditionalSymbols { get; }
    public ObsoleteAttributeData ObsoleteAttributeData { get; public set; }
    public void AddConditionalSymbol(string name);
    public ImmutableArray`1<string> get_ConditionalSymbols();
    public ObsoleteAttributeData get_ObsoleteAttributeData();
    public void set_ObsoleteAttributeData(ObsoleteAttributeData value);
}
internal class Microsoft.CodeAnalysis.CommonMethodWellKnownAttributeData : WellKnownAttributeData {
    private bool _preserveSigFirstWriteWins;
    private DllImportData _platformInvokeInfo;
    private bool _dllImportPreserveSig;
    private int _dllImportIndex;
    private int _methodImplIndex;
    private MethodImplAttributes _attributes;
    private int _preserveSigIndex;
    private bool _hasSpecialNameAttribute;
    private bool _hasDynamicSecurityMethodAttribute;
    private bool _hasSuppressUnmanagedCodeSecurityAttribute;
    private SecurityWellKnownAttributeData _lazySecurityAttributeData;
    public DllImportData DllImportPlatformInvokeData { get; }
    public MethodImplAttributes MethodImplAttributes { get; }
    public bool HasSpecialNameAttribute { get; public set; }
    public bool HasDynamicSecurityMethodAttribute { get; public set; }
    public bool HasSuppressUnmanagedCodeSecurityAttribute { get; public set; }
    internal bool HasDeclarativeSecurity { get; }
    public SecurityWellKnownAttributeData SecurityInformation { get; }
    public CommonMethodWellKnownAttributeData(bool preserveSigFirstWriteWins);
    public void SetPreserveSignature(int attributeIndex);
    public void SetMethodImplementation(int attributeIndex, MethodImplAttributes attributes);
    public void SetDllImport(int attributeIndex, string moduleName, string entryPointName, PInvokeAttributes flags, bool preserveSig);
    public DllImportData get_DllImportPlatformInvokeData();
    public MethodImplAttributes get_MethodImplAttributes();
    public bool get_HasSpecialNameAttribute();
    public void set_HasSpecialNameAttribute(bool value);
    public bool get_HasDynamicSecurityMethodAttribute();
    public void set_HasDynamicSecurityMethodAttribute(bool value);
    public bool get_HasSuppressUnmanagedCodeSecurityAttribute();
    public void set_HasSuppressUnmanagedCodeSecurityAttribute(bool value);
    private sealed virtual override SecurityWellKnownAttributeData Microsoft.CodeAnalysis.ISecurityAttributeTarget.GetOrCreateData();
    internal bool get_HasDeclarativeSecurity();
    public SecurityWellKnownAttributeData get_SecurityInformation();
}
internal class Microsoft.CodeAnalysis.CommonModuleCompilationState : object {
    private bool _frozen;
    internal bool Frozen { get; }
    internal void Freeze();
    internal bool get_Frozen();
}
internal class Microsoft.CodeAnalysis.CommonModuleWellKnownAttributeData : WellKnownAttributeData {
    private bool _hasDebuggableAttribute;
    private byte _defaultCharacterSet;
    public bool HasDebuggableAttribute { get; public set; }
    internal CharSet DefaultCharacterSet { get; internal set; }
    internal bool HasDefaultCharSetAttribute { get; }
    public bool get_HasDebuggableAttribute();
    public void set_HasDebuggableAttribute(bool value);
    internal CharSet get_DefaultCharacterSet();
    internal void set_DefaultCharacterSet(CharSet value);
    internal bool get_HasDefaultCharSetAttribute();
    internal static bool IsValidCharSet(CharSet value);
}
internal abstract class Microsoft.CodeAnalysis.CommonParameterEarlyWellKnownAttributeData : EarlyWellKnownAttributeData {
    private ConstantValue _defaultParameterValue;
    private bool _hasCallerLineNumberAttribute;
    private bool _hasCallerFilePathAttribute;
    private bool _hasCallerMemberNameAttribute;
    public ConstantValue DefaultParameterValue { get; public set; }
    public bool HasCallerLineNumberAttribute { get; public set; }
    public bool HasCallerFilePathAttribute { get; public set; }
    public bool HasCallerMemberNameAttribute { get; public set; }
    public ConstantValue get_DefaultParameterValue();
    public void set_DefaultParameterValue(ConstantValue value);
    public bool get_HasCallerLineNumberAttribute();
    public void set_HasCallerLineNumberAttribute(bool value);
    public bool get_HasCallerFilePathAttribute();
    public void set_HasCallerFilePathAttribute(bool value);
    public bool get_HasCallerMemberNameAttribute();
    public void set_HasCallerMemberNameAttribute(bool value);
}
internal class Microsoft.CodeAnalysis.CommonParameterWellKnownAttributeData : WellKnownAttributeData {
    private bool _hasOutAttribute;
    private bool _hasInAttribute;
    private MarshalPseudoCustomAttributeData _lazyMarshalAsData;
    private bool _hasIDispatchConstantAttribute;
    private bool _hasIUnknownConstantAttribute;
    public bool HasOutAttribute { get; public set; }
    public bool HasInAttribute { get; public set; }
    public MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    public bool HasIDispatchConstantAttribute { get; public set; }
    public bool HasIUnknownConstantAttribute { get; public set; }
    public bool get_HasOutAttribute();
    public void set_HasOutAttribute(bool value);
    public bool get_HasInAttribute();
    public void set_HasInAttribute(bool value);
    private sealed virtual override MarshalPseudoCustomAttributeData Microsoft.CodeAnalysis.IMarshalAsAttributeTarget.GetOrCreateData();
    public MarshalPseudoCustomAttributeData get_MarshallingInformation();
    public bool get_HasIDispatchConstantAttribute();
    public void set_HasIDispatchConstantAttribute(bool value);
    public bool get_HasIUnknownConstantAttribute();
    public void set_HasIUnknownConstantAttribute(bool value);
}
internal class Microsoft.CodeAnalysis.CommonPropertyEarlyWellKnownAttributeData : EarlyWellKnownAttributeData {
    private ObsoleteAttributeData _obsoleteAttributeData;
    public ObsoleteAttributeData ObsoleteAttributeData { get; public set; }
    public ObsoleteAttributeData get_ObsoleteAttributeData();
    public void set_ObsoleteAttributeData(ObsoleteAttributeData value);
}
internal class Microsoft.CodeAnalysis.CommonPropertyWellKnownAttributeData : WellKnownAttributeData {
    private bool _hasSpecialNameAttribute;
    public bool HasSpecialNameAttribute { get; public set; }
    public bool get_HasSpecialNameAttribute();
    public void set_HasSpecialNameAttribute(bool value);
}
internal abstract class Microsoft.CodeAnalysis.CommonReferenceManager : object {
    internal static object SymbolCacheAndReferenceManagerStateGuard;
    private static CommonReferenceManager();
    internal abstract virtual IEnumerable`1<KeyValuePair`2<MetadataReference, IAssemblySymbol>> GetReferencedAssemblies();
    internal abstract virtual bool TryGetReferencedAssemblySymbol(MetadataReference reference, IAssemblySymbol& symbol, ImmutableArray`1& aliases);
}
internal abstract class Microsoft.CodeAnalysis.CommonReferenceManager`2 : CommonReferenceManager {
    internal string SimpleAssemblyName;
    internal AssemblyIdentityComparer IdentityComparer;
    internal Dictionary`2<MetadataReference, object> ObservedMetadata;
    private int _isBound;
    private ThreeState _lazyHasCircularReference;
    private Dictionary`2<MetadataReference, ReferencedAssembly<TCompilation, TAssemblySymbol>> _lazyReferencedAssembliesMap;
    private Dictionary`2<MetadataReference, int> _lazyReferencedModuleIndexMap;
    private IDictionary`2<string, MetadataReference> _lazyReferenceDirectiveMap;
    private ImmutableArray`1<MetadataReference> _lazyDirectiveReferences;
    private ImmutableArray`1<Diagnostic> _lazyDiagnostics;
    private TAssemblySymbol _lazyCorLibraryOpt;
    private ImmutableArray`1<PEModule> _lazyReferencedModules;
    private ImmutableArray`1<ModuleReferences`1<TAssemblySymbol>> _lazyReferencedModulesReferences;
    private ImmutableArray`1<TAssemblySymbol> _lazyReferencedAssemblies;
    private ImmutableArray`1<UnifiedAssembly`1<TAssemblySymbol>> _lazyUnifiedAssemblies;
    protected CommonMessageProvider MessageProvider { get; }
    internal ImmutableArray`1<Diagnostic> Diagnostics { get; }
    internal bool HasCircularReference { get; }
    internal Dictionary`2<MetadataReference, ReferencedAssembly<TCompilation, TAssemblySymbol>> ReferencedAssembliesMap { get; }
    internal Dictionary`2<MetadataReference, int> ReferencedModuleIndexMap { get; }
    internal IDictionary`2<string, MetadataReference> ReferenceDirectiveMap { get; }
    internal ImmutableArray`1<MetadataReference> DirectiveReferences { get; }
    internal TAssemblySymbol CorLibraryOpt { get; }
    internal ImmutableArray`1<PEModule> ReferencedModules { get; }
    internal ImmutableArray`1<ModuleReferences`1<TAssemblySymbol>> ReferencedModulesReferences { get; }
    internal ImmutableArray`1<TAssemblySymbol> ReferencedAssemblies { get; }
    internal ImmutableArray`1<UnifiedAssembly`1<TAssemblySymbol>> UnifiedAssemblies { get; }
    internal bool IsBound { get; }
    internal IEnumerable`1<string> ExternAliases { get; }
    public CommonReferenceManager`2(string simpleAssemblyName, AssemblyIdentityComparer identityComparer, Dictionary`2<MetadataReference, object> observedMetadata);
    internal BoundInputAssembly[] Bind(ImmutableArray`1<AssemblyData<TCompilation, TAssemblySymbol>> assemblies, Boolean& hasCircularReference, Int32& corLibraryIndex);
    private bool ReuseAssemblySymbolsWithNoPiaLocalTypes(BoundInputAssembly[] boundInputs, TAssemblySymbol[] candidateInputAssemblySymbols, ImmutableArray`1<AssemblyData<TCompilation, TAssemblySymbol>> assemblies, int corLibraryIndex);
    private void ReuseAssemblySymbols(BoundInputAssembly[] boundInputs, TAssemblySymbol[] candidateInputAssemblySymbols, ImmutableArray`1<AssemblyData<TCompilation, TAssemblySymbol>> assemblies, int corLibraryIndex);
    private static bool CheckCircularReference(BoundInputAssembly[] boundInputs);
    private static int IndexOfCorLibrary(ImmutableArray`1<AssemblyData<TCompilation, TAssemblySymbol>> assemblies);
    internal static bool InternalsMayBeVisibleToAssemblyBeingCompiled(string compilationName, PEAssembly assembly);
    protected abstract virtual TAssemblySymbol[] GetActualBoundReferencesUsedBy(TAssemblySymbol assemblySymbol);
    protected abstract virtual ImmutableArray`1<TAssemblySymbol> GetNoPiaResolutionAssemblies(TAssemblySymbol candidateAssembly);
    protected abstract virtual bool IsLinked(TAssemblySymbol candidateAssembly);
    protected abstract virtual TAssemblySymbol GetCorLibrary(TAssemblySymbol candidateAssembly);
    protected abstract virtual CommonMessageProvider get_MessageProvider();
    protected abstract virtual AssemblyData<TCompilation, TAssemblySymbol> CreateAssemblyDataForFile(PEAssembly assembly, WeakList`1<IAssemblySymbol> cachedSymbols, DocumentationProvider documentationProvider, string sourceAssemblySimpleName, MetadataImportOptions importOptions, bool embedInteropTypes);
    protected abstract virtual AssemblyData<TCompilation, TAssemblySymbol> CreateAssemblyDataForCompilation(CompilationReference compilationReference);
    protected abstract virtual bool CheckPropertiesConsistency(MetadataReference primaryReference, MetadataReference duplicateReference, DiagnosticBag diagnostics);
    protected abstract virtual bool WeakIdentityPropertiesEquivalent(AssemblyIdentity identity1, AssemblyIdentity identity2);
    protected ImmutableArray`1<ResolvedReference<TCompilation, TAssemblySymbol>> ResolveMetadataReferences(TCompilation compilation, ImmutableArray`1& references, IDictionary`2& boundReferenceDirectiveMap, ImmutableArray`1& boundReferenceDirectives, ImmutableArray`1& assemblies, ImmutableArray`1& modules, DiagnosticBag diagnostics);
    private static ImmutableArray`1<string> GetAliases(MetadataReference reference, Dictionary`2<MetadataReference, ArrayBuilder`1<string>> aliasMap);
    private Metadata GetMetadata(PortableExecutableReference peReference, CommonMessageProvider messageProvider, Location location, DiagnosticBag diagnostics);
    private bool TryGetObservedMetadata(PortableExecutableReference peReference, DiagnosticBag diagnostics, Metadata& metadata);
    private void MergeReferenceProperties(MetadataReference primaryReference, MetadataReference newReference, DiagnosticBag diagnostics, Dictionary`2& aliasMap);
    private static void AddAssembly(AssemblyData<TCompilation, TAssemblySymbol> data, int referenceIndex, ResolvedReference[] referenceMap, ArrayBuilder`1& assemblies);
    private static void AddModule(PEModule module, int referenceIndex, ResolvedReference[] referenceMap, ArrayBuilder`1& modules);
    private MetadataReference TryAddAssembly(AssemblyIdentity identity, MetadataReference boundReference, DiagnosticBag diagnostics, Location location, Dictionary`2& referencesBySimpleName);
    protected void GetCompilationReferences(TCompilation compilation, DiagnosticBag diagnostics, ImmutableArray`1& references, IDictionary`2& boundReferenceDirectives, ImmutableArray`1& referenceDirectiveLocations);
    private static PortableExecutableReference ResolveReferenceDirective(string reference, Location location, TCompilation compilation);
    internal static AssemblyReferenceBinding[] ResolveReferencedAssemblies(ImmutableArray`1<AssemblyIdentity> references, ImmutableArray`1<AssemblyData<TCompilation, TAssemblySymbol>> definitions, AssemblyIdentityComparer assemblyIdentityComparer, bool okToResolveAgainstCompilationBeingCreated);
    internal static AssemblyReferenceBinding<TCompilation, TAssemblySymbol> ResolveReferencedAssembly(AssemblyIdentity reference, ImmutableArray`1<AssemblyData<TCompilation, TAssemblySymbol>> definitions, AssemblyIdentityComparer assemblyIdentityComparer, bool okToResolveAgainstCompilationBeingCreated);
    internal ImmutableArray`1<Diagnostic> get_Diagnostics();
    internal bool get_HasCircularReference();
    internal Dictionary`2<MetadataReference, ReferencedAssembly<TCompilation, TAssemblySymbol>> get_ReferencedAssembliesMap();
    internal Dictionary`2<MetadataReference, int> get_ReferencedModuleIndexMap();
    internal IDictionary`2<string, MetadataReference> get_ReferenceDirectiveMap();
    internal ImmutableArray`1<MetadataReference> get_DirectiveReferences();
    internal TAssemblySymbol get_CorLibraryOpt();
    internal ImmutableArray`1<PEModule> get_ReferencedModules();
    internal ImmutableArray`1<ModuleReferences`1<TAssemblySymbol>> get_ReferencedModulesReferences();
    internal ImmutableArray`1<TAssemblySymbol> get_ReferencedAssemblies();
    internal ImmutableArray`1<UnifiedAssembly`1<TAssemblySymbol>> get_UnifiedAssemblies();
    [ConditionalAttribute("DEBUG")]
internal void AssertUnbound();
    [ConditionalAttribute("DEBUG")]
internal void AssertBound();
    [ConditionalAttribute("DEBUG")]
internal void AssertCanReuseForCompilation(TCompilation compilation);
    internal bool get_IsBound();
    internal void InitializeNoLock(Dictionary`2<MetadataReference, ReferencedAssembly<TCompilation, TAssemblySymbol>> referencedAssembliesMap, Dictionary`2<MetadataReference, int> referencedModulesMap, IDictionary`2<string, MetadataReference> boundReferenceDirectiveMap, ImmutableArray`1<MetadataReference> boundReferenceDirectives, bool containsCircularReferences, ImmutableArray`1<Diagnostic> diagnostics, TAssemblySymbol corLibraryOpt, ImmutableArray`1<PEModule> referencedModules, ImmutableArray`1<ModuleReferences`1<TAssemblySymbol>> referencedModulesReferences, ImmutableArray`1<TAssemblySymbol> referencedAssemblies, ImmutableArray`1<UnifiedAssembly`1<TAssemblySymbol>> unifiedAssemblies);
    internal IEnumerable`1<string> get_ExternAliases();
    internal sealed virtual IEnumerable`1<KeyValuePair`2<MetadataReference, IAssemblySymbol>> GetReferencedAssemblies();
    internal sealed virtual bool TryGetReferencedAssemblySymbol(MetadataReference reference, IAssemblySymbol& symbol, ImmutableArray`1& aliases);
    internal TAssemblySymbol GetReferencedAssemblySymbol(MetadataReference reference);
    internal int GetReferencedModuleIndex(MetadataReference reference);
}
internal class Microsoft.CodeAnalysis.CommonReturnTypeWellKnownAttributeData : WellKnownAttributeData {
    private MarshalPseudoCustomAttributeData _lazyMarshalAsData;
    public MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    private sealed virtual override MarshalPseudoCustomAttributeData Microsoft.CodeAnalysis.IMarshalAsAttributeTarget.GetOrCreateData();
    public MarshalPseudoCustomAttributeData get_MarshallingInformation();
}
internal class Microsoft.CodeAnalysis.CommonTypeEarlyWellKnownAttributeData : EarlyWellKnownAttributeData {
    private AttributeUsageInfo _attributeUsageInfo;
    private bool _hasComImportAttribute;
    private ImmutableArray`1<string> _lazyConditionalSymbols;
    private ObsoleteAttributeData _obsoleteAttributeData;
    public AttributeUsageInfo AttributeUsageInfo { get; public set; }
    public bool HasComImportAttribute { get; public set; }
    public ImmutableArray`1<string> ConditionalSymbols { get; }
    public ObsoleteAttributeData ObsoleteAttributeData { get; public set; }
    public AttributeUsageInfo get_AttributeUsageInfo();
    public void set_AttributeUsageInfo(AttributeUsageInfo value);
    public bool get_HasComImportAttribute();
    public void set_HasComImportAttribute(bool value);
    public void AddConditionalSymbol(string name);
    public ImmutableArray`1<string> get_ConditionalSymbols();
    public ObsoleteAttributeData get_ObsoleteAttributeData();
    public void set_ObsoleteAttributeData(ObsoleteAttributeData value);
}
internal class Microsoft.CodeAnalysis.CommonTypeWellKnownAttributeData : WellKnownAttributeData {
    private bool _hasSpecialNameAttribute;
    private bool _hasSerializableAttribute;
    private bool _hasDefaultMemberAttribute;
    private bool _hasSuppressUnmanagedCodeSecurityAttribute;
    private SecurityWellKnownAttributeData _lazySecurityAttributeData;
    private bool _hasWindowsRuntimeImportAttribute;
    private string _guidString;
    private TypeLayout _layout;
    private CharSet _charSet;
    private bool _hasSecurityCriticalAttributes;
    public bool HasSpecialNameAttribute { get; public set; }
    public bool HasSerializableAttribute { get; public set; }
    public bool HasDefaultMemberAttribute { get; public set; }
    public bool HasSuppressUnmanagedCodeSecurityAttribute { get; public set; }
    internal bool HasDeclarativeSecurity { get; }
    public SecurityWellKnownAttributeData SecurityInformation { get; }
    public bool HasWindowsRuntimeImportAttribute { get; public set; }
    public string GuidString { get; public set; }
    public bool HasStructLayoutAttribute { get; }
    public TypeLayout Layout { get; }
    public CharSet MarshallingCharSet { get; }
    public bool HasSecurityCriticalAttributes { get; public set; }
    public bool get_HasSpecialNameAttribute();
    public void set_HasSpecialNameAttribute(bool value);
    public bool get_HasSerializableAttribute();
    public void set_HasSerializableAttribute(bool value);
    public bool get_HasDefaultMemberAttribute();
    public void set_HasDefaultMemberAttribute(bool value);
    public bool get_HasSuppressUnmanagedCodeSecurityAttribute();
    public void set_HasSuppressUnmanagedCodeSecurityAttribute(bool value);
    private sealed virtual override SecurityWellKnownAttributeData Microsoft.CodeAnalysis.ISecurityAttributeTarget.GetOrCreateData();
    internal bool get_HasDeclarativeSecurity();
    public SecurityWellKnownAttributeData get_SecurityInformation();
    public bool get_HasWindowsRuntimeImportAttribute();
    public void set_HasWindowsRuntimeImportAttribute(bool value);
    public string get_GuidString();
    public void set_GuidString(string value);
    public void SetStructLayout(TypeLayout layout, CharSet charSet);
    public bool get_HasStructLayoutAttribute();
    public TypeLayout get_Layout();
    public CharSet get_MarshallingCharSet();
    public bool get_HasSecurityCriticalAttributes();
    public void set_HasSecurityCriticalAttributes(bool value);
}
public abstract class Microsoft.CodeAnalysis.Compilation : object {
    internal ImmutableDictionary`2<SyntaxTree, int> syntaxTreeOrdinalMap;
    private SmallDictionary`2<int, bool> _lazyMakeWellKnownTypeMissingMap;
    private SmallDictionary`2<int, bool> _lazyMakeMemberMissingMap;
    private Dictionary`2<string, string> _lazyFeatures;
    internal static string UnspecifiedModuleAssemblyName;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    private int _lazySubmissionSlotIndex;
    private static int SubmissionSlotIndexNotApplicable;
    private static int SubmissionSlotIndexToBeAllocated;
    [CompilerGeneratedAttribute]
private Type <SubmissionReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <HostObjectType>k__BackingField;
    internal AsyncQueue`1<CompilationEvent> EventQueue;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<MetadataReference> <ExternalReferences>k__BackingField;
    internal static CompilationStage DefaultDiagnosticsStage;
    private ConcurrentDictionary`2<SyntaxTree, SmallConcurrentSetOfInts> _lazyTreeToUsedImportDirectivesMap;
    private static Func`2<SyntaxTree, SmallConcurrentSetOfInts> s_createSetCallback;
    private WeakList`1<IAssemblySymbol> _retargetingAssemblySymbols;
    public bool IsCaseSensitive { get; }
    public string Language { get; }
    public string AssemblyName { get; }
    public CompilationOptions Options { get; }
    protected CompilationOptions CommonOptions { get; }
    internal bool IsSubmission { get; }
    internal Type SubmissionReturnType { get; }
    internal Type HostObjectType { get; }
    internal Compilation PreviousSubmission { get; }
    internal Compilation CommonPreviousSubmission { get; }
    public IEnumerable`1<SyntaxTree> SyntaxTrees { get; }
    protected IEnumerable`1<SyntaxTree> CommonSyntaxTrees { get; }
    public ImmutableArray`1<MetadataReference> ExternalReferences { get; }
    public ImmutableArray`1<MetadataReference> DirectiveReferences { get; }
    internal IEnumerable`1<ReferenceDirective> ReferenceDirectives { get; }
    internal IDictionary`2<string, MetadataReference> ReferenceDirectiveMap { get; }
    public IEnumerable`1<MetadataReference> References { get; }
    public IEnumerable`1<AssemblyIdentity> ReferencedAssemblyNames { get; }
    public IAssemblySymbol Assembly { get; }
    protected IAssemblySymbol CommonAssembly { get; }
    public IModuleSymbol SourceModule { get; }
    protected IModuleSymbol CommonSourceModule { get; }
    public INamespaceSymbol GlobalNamespace { get; }
    protected INamespaceSymbol CommonGlobalNamespace { get; }
    internal CommonAnonymousTypeManager CommonAnonymousTypeManager { get; }
    public INamedTypeSymbol ObjectType { get; }
    protected INamedTypeSymbol CommonObjectType { get; }
    public ITypeSymbol DynamicType { get; }
    protected ITypeSymbol CommonDynamicType { get; }
    internal INamedTypeSymbol ScriptClass { get; }
    internal INamedTypeSymbol CommonScriptClass { get; }
    internal CommonMessageProvider MessageProvider { get; }
    internal bool HasStrongName { get; }
    internal bool IsRealSigned { get; }
    internal bool IsDelaySigned { get; }
    internal StrongNameKeys StrongNameKeys { get; }
    private ConcurrentDictionary`2<SyntaxTree, SmallConcurrentSetOfInts> TreeToUsedImportDirectivesMap { get; }
    internal WeakList`1<IAssemblySymbol> RetargetingAssemblySymbols { get; }
    internal Compilation(string name, ImmutableArray`1<MetadataReference> references, Type submissionReturnType, Type hostObjectType, bool isSubmission, ImmutableDictionary`2<SyntaxTree, int> syntaxTreeOrdinalMap, AsyncQueue`1<CompilationEvent> eventQueue);
    private static Compilation();
    public abstract virtual bool get_IsCaseSensitive();
    internal abstract virtual AnalyzerDriver AnalyzerForLanguage(ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerManager analyzerManager, CancellationToken cancellationToken);
    public abstract virtual string get_Language();
    internal static void ValidateSubmissionParameters(Compilation previousSubmission, Type returnType, Type& hostObjectType);
    internal static void CheckSubmissionOptions(CompilationOptions options);
    public Compilation Clone();
    protected abstract virtual Compilation CommonClone();
    internal abstract virtual Compilation WithEventQueue(AsyncQueue`1<CompilationEvent> eventQueue);
    public SemanticModel GetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility);
    protected abstract virtual SemanticModel CommonGetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility);
    public abstract virtual INamedTypeSymbol CreateErrorTypeSymbol(INamespaceOrTypeSymbol container, string name, int arity);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    internal static void CheckAssemblyName(string assemblyName);
    internal string MakeSourceAssemblySimpleName();
    internal string MakeSourceModuleName();
    public Compilation WithAssemblyName(string assemblyName);
    protected abstract virtual Compilation CommonWithAssemblyName(string outputName);
    public CompilationOptions get_Options();
    protected abstract virtual CompilationOptions get_CommonOptions();
    public Compilation WithOptions(CompilationOptions options);
    protected abstract virtual Compilation CommonWithOptions(CompilationOptions options);
    internal bool get_IsSubmission();
    internal int GetSubmissionSlotIndex();
    [CompilerGeneratedAttribute]
internal Type get_SubmissionReturnType();
    internal static bool IsValidSubmissionReturnType(Type type);
    [CompilerGeneratedAttribute]
internal Type get_HostObjectType();
    internal static bool IsValidHostObjectType(Type type);
    internal ITypeSymbol GetSubmissionResultType(Boolean& hasValue);
    internal abstract virtual ITypeSymbol CommonGetSubmissionResultType(Boolean& hasValue);
    internal Compilation get_PreviousSubmission();
    internal abstract virtual Compilation get_CommonPreviousSubmission();
    internal Compilation WithPreviousSubmission(Compilation newPreviousSubmission);
    internal abstract virtual Compilation CommonWithPreviousSubmission(Compilation newPreviousSubmission);
    public IEnumerable`1<SyntaxTree> get_SyntaxTrees();
    protected abstract virtual IEnumerable`1<SyntaxTree> get_CommonSyntaxTrees();
    public Compilation AddSyntaxTrees(SyntaxTree[] trees);
    public Compilation AddSyntaxTrees(IEnumerable`1<SyntaxTree> trees);
    protected abstract virtual Compilation CommonAddSyntaxTrees(IEnumerable`1<SyntaxTree> trees);
    public Compilation RemoveSyntaxTrees(SyntaxTree[] trees);
    public Compilation RemoveSyntaxTrees(IEnumerable`1<SyntaxTree> trees);
    protected abstract virtual Compilation CommonRemoveSyntaxTrees(IEnumerable`1<SyntaxTree> trees);
    public Compilation RemoveAllSyntaxTrees();
    protected abstract virtual Compilation CommonRemoveAllSyntaxTrees();
    public Compilation ReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree);
    protected abstract virtual Compilation CommonReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree);
    public bool ContainsSyntaxTree(SyntaxTree syntaxTree);
    protected abstract virtual bool CommonContainsSyntaxTree(SyntaxTree syntaxTree);
    internal static ImmutableArray`1<MetadataReference> ValidateReferences(IEnumerable`1<MetadataReference> references);
    internal CommonReferenceManager GetBoundReferenceManager();
    internal abstract virtual CommonReferenceManager CommonGetBoundReferenceManager();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<MetadataReference> get_ExternalReferences();
    public abstract virtual ImmutableArray`1<MetadataReference> get_DirectiveReferences();
    internal abstract virtual IEnumerable`1<ReferenceDirective> get_ReferenceDirectives();
    internal abstract virtual IDictionary`2<string, MetadataReference> get_ReferenceDirectiveMap();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Compilation/<get_References>d__87")]
public IEnumerable`1<MetadataReference> get_References();
    public abstract virtual CompilationReference ToMetadataReference(ImmutableArray`1<string> aliases, bool embedInteropTypes);
    public Compilation WithReferences(IEnumerable`1<MetadataReference> newReferences);
    public Compilation WithReferences(MetadataReference[] newReferences);
    protected abstract virtual Compilation CommonWithReferences(IEnumerable`1<MetadataReference> newReferences);
    public Compilation AddReferences(MetadataReference[] references);
    public Compilation AddReferences(IEnumerable`1<MetadataReference> references);
    public Compilation RemoveReferences(MetadataReference[] references);
    public Compilation RemoveReferences(IEnumerable`1<MetadataReference> references);
    public Compilation RemoveAllReferences();
    public Compilation ReplaceReference(MetadataReference oldReference, MetadataReference newReference);
    public ISymbol GetAssemblyOrModuleSymbol(MetadataReference reference);
    protected abstract virtual ISymbol CommonGetAssemblyOrModuleSymbol(MetadataReference reference);
    public MetadataReference GetMetadataReference(IAssemblySymbol assemblySymbol);
    protected abstract virtual MetadataReference CommonGetMetadataReference(IAssemblySymbol assemblySymbol);
    public abstract virtual IEnumerable`1<AssemblyIdentity> get_ReferencedAssemblyNames();
    public IAssemblySymbol get_Assembly();
    protected abstract virtual IAssemblySymbol get_CommonAssembly();
    public IModuleSymbol get_SourceModule();
    protected abstract virtual IModuleSymbol get_CommonSourceModule();
    public INamespaceSymbol get_GlobalNamespace();
    protected abstract virtual INamespaceSymbol get_CommonGlobalNamespace();
    public INamespaceSymbol GetCompilationNamespace(INamespaceSymbol namespaceSymbol);
    protected abstract virtual INamespaceSymbol CommonGetCompilationNamespace(INamespaceSymbol namespaceSymbol);
    internal abstract virtual CommonAnonymousTypeManager get_CommonAnonymousTypeManager();
    public IMethodSymbol GetEntryPoint(CancellationToken cancellationToken);
    protected abstract virtual IMethodSymbol CommonGetEntryPoint(CancellationToken cancellationToken);
    public INamedTypeSymbol GetSpecialType(SpecialType specialType);
    internal abstract virtual bool IsSystemTypeReference(ITypeSymbol type);
    protected abstract virtual INamedTypeSymbol CommonGetSpecialType(SpecialType specialType);
    internal abstract virtual ISymbol CommonGetWellKnownTypeMember(WellKnownMember member);
    internal abstract virtual bool IsAttributeType(ITypeSymbol type);
    public INamedTypeSymbol get_ObjectType();
    protected abstract virtual INamedTypeSymbol get_CommonObjectType();
    public ITypeSymbol get_DynamicType();
    protected abstract virtual ITypeSymbol get_CommonDynamicType();
    internal INamedTypeSymbol get_ScriptClass();
    internal abstract virtual INamedTypeSymbol get_CommonScriptClass();
    public IArrayTypeSymbol CreateArrayTypeSymbol(ITypeSymbol elementType, int rank);
    protected abstract virtual IArrayTypeSymbol CommonCreateArrayTypeSymbol(ITypeSymbol elementType, int rank);
    public IPointerTypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType);
    protected abstract virtual IPointerTypeSymbol CommonCreatePointerTypeSymbol(ITypeSymbol elementType);
    public INamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName);
    protected abstract virtual INamedTypeSymbol CommonGetTypeByMetadataName(string metadataName);
    public abstract virtual ImmutableArray`1<Diagnostic> GetParseDiagnostics(CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<Diagnostic> GetDeclarationDiagnostics(CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<Diagnostic> GetMethodBodyDiagnostics(CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<Diagnostic> GetDiagnostics(CancellationToken cancellationToken);
    internal abstract virtual CommonMessageProvider get_MessageProvider();
    internal abstract virtual bool FilterAndAppendAndFreeDiagnostics(DiagnosticBag accumulator, DiagnosticBag& incoming);
    internal abstract virtual Diagnostic FilterDiagnostic(Diagnostic diagnostic);
    public Stream CreateDefaultWin32Resources(bool versionResource, bool noManifest, Stream manifestContents, Stream iconInIcoFormat);
    internal static void AppendNullResource(Stream resourceStream);
    protected abstract virtual void AppendDefaultVersionResource(Stream resourceStream);
    internal Win32ResourceForm DetectWin32ResourceForm(Stream win32Resources);
    internal ResourceSection MakeWin32ResourcesFromCOFF(Stream win32Resources, DiagnosticBag diagnostics);
    internal List`1<Win32Resource> MakeWin32ResourceList(Stream win32Resources, DiagnosticBag diagnostics);
    internal void ReportManifestResourceDuplicates(IEnumerable`1<ResourceDescription> manifestResources, IEnumerable`1<string> addedModuleNames, IEnumerable`1<string> addedModuleResourceNames, DiagnosticBag diagnostics);
    internal ModulePropertiesForSerialization ConstructModuleSerializationProperties(EmitOptions emitOptions, string targetRuntimeVersion, Guid moduleVersionId);
    internal bool get_HasStrongName();
    internal bool get_IsRealSigned();
    internal abstract virtual bool HasCodeToEmit();
    internal abstract virtual bool get_IsDelaySigned();
    internal abstract virtual StrongNameKeys get_StrongNameKeys();
    internal abstract virtual CommonPEModuleBuilder CreateModuleBuilder(EmitOptions emitOptions, IEnumerable`1<ResourceDescription> manifestResources, Func`2<IAssemblySymbol, AssemblyIdentity> assemblySymbolMapper, CompilationTestData testData, DiagnosticBag diagnostics, CancellationToken cancellationToken);
    internal abstract virtual bool CompileImpl(CommonPEModuleBuilder moduleBuilder, Stream win32Resources, Stream xmlDocStream, bool emittingPdb, DiagnosticBag diagnostics, Predicate`1<ISymbol> filterOpt, CancellationToken cancellationToken);
    internal bool Compile(CommonPEModuleBuilder moduleBuilder, Stream win32Resources, Stream xmlDocStream, bool emittingPdb, DiagnosticBag diagnostics, Predicate`1<ISymbol> filterOpt, CancellationToken cancellationToken);
    internal void EnsureAnonymousTypeTemplates(CancellationToken cancellationToken);
    public EmitResult Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1<ResourceDescription> manifestResources, EmitOptions options, CancellationToken cancellationToken);
    internal EmitResult Emit(EmitStreamProvider peStreamProvider, EmitStreamProvider pdbStreamProvider, EmitStreamProvider xmlDocumentationStreamProvider, EmitStreamProvider win32ResourcesProvider, IEnumerable`1<ResourceDescription> manifestResources, EmitOptions options, Func`1<ImmutableArray`1<Diagnostic>> getHostDiagnostics, CancellationToken cancellationToken);
    internal EmitResult Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1<ResourceDescription> manifestResources, EmitOptions options, CompilationTestData testData, Func`1<ImmutableArray`1<Diagnostic>> getHostDiagnostics, CancellationToken cancellationToken);
    public EmitDifferenceResult EmitDifference(EmitBaseline baseline, IEnumerable`1<SemanticEdit> edits, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection`1<MethodDefinitionHandle> updatedMethods, CancellationToken cancellationToken);
    public EmitDifferenceResult EmitDifference(EmitBaseline baseline, IEnumerable`1<SemanticEdit> edits, Func`2<ISymbol, bool> isAddedSymbol, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection`1<MethodDefinitionHandle> updatedMethods, CancellationToken cancellationToken);
    internal abstract virtual EmitDifferenceResult EmitDifference(EmitBaseline baseline, IEnumerable`1<SemanticEdit> edits, Func`2<ISymbol, bool> isAddedSymbol, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection`1<MethodDefinitionHandle> updatedMethodHandles, CompilationTestData testData, CancellationToken cancellationToken);
    internal EmitResult Emit(EmitStreamProvider peStreamProvider, EmitStreamProvider pdbStreamProvider, EmitStreamProvider xmlDocumentationStreamProvider, EmitStreamProvider win32ResourcesStreamProvider, IEnumerable`1<ResourceDescription> manifestResources, EmitOptions options, CompilationTestData testData, Func`1<ImmutableArray`1<Diagnostic>> getHostDiagnostics, CancellationToken cancellationToken);
    private static EmitResult ToEmitResultAndFree(DiagnosticBag diagnostics, bool success);
    internal bool SerializeToPeStream(CommonPEModuleBuilder moduleBeingBuilt, EmitStreamProvider peStreamProvider, EmitStreamProvider pdbStreamProvider, Func`1<object> testSymWriterFactory, DiagnosticBag diagnostics, bool metadataOnly, CancellationToken cancellationToken);
    internal EmitBaseline SerializeToDeltaStreams(CommonPEModuleBuilder moduleBeingBuilt, EmitBaseline baseline, DefinitionMap definitionMap, SymbolChanges changes, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection`1<MethodDefinitionHandle> updatedMethods, DiagnosticBag diagnostics, Func`1<object> testSymWriterFactory, CancellationToken cancellationToken);
    internal string Feature(string p);
    private ConcurrentDictionary`2<SyntaxTree, SmallConcurrentSetOfInts> get_TreeToUsedImportDirectivesMap();
    internal void MarkImportDirectiveAsUsed(SyntaxNode node);
    internal void MarkImportDirectiveAsUsed(SyntaxTree syntaxTree, int position);
    internal bool IsImportDirectiveUsed(SyntaxTree syntaxTree, int position);
    internal int CompareSyntaxTreeOrdering(SyntaxTree tree1, SyntaxTree tree2);
    internal int GetSyntaxTreeOrdinal(SyntaxTree tree);
    internal abstract virtual int CompareSourceLocations(Location loc1, Location loc2);
    internal TLocation FirstSourceLocation(TLocation first, TLocation second);
    internal TLocation FirstSourceLocation(ImmutableArray`1<TLocation> locations);
    internal string GetMessage(CompilationStage stage);
    internal string GetMessage(ITypeSymbol source, ITypeSymbol destination);
    public abstract virtual bool ContainsSymbolsWithName(Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<ISymbol> GetSymbolsWithName(Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    internal void MakeMemberMissing(WellKnownMember member);
    internal void MakeMemberMissing(SpecialMember member);
    internal bool IsMemberMissing(WellKnownMember member);
    internal bool IsMemberMissing(SpecialMember member);
    private void MakeMemberMissing(int member);
    private bool IsMemberMissing(int member);
    internal void MakeTypeMissing(WellKnownType type);
    internal bool IsTypeMissing(WellKnownType type);
    internal void CacheRetargetingAssemblySymbolNoLock(IAssemblySymbol assembly);
    internal void AddRetargetingAssemblySymbolsNoLock(List`1<T> result);
    internal WeakList`1<IAssemblySymbol> get_RetargetingAssemblySymbols();
}
public abstract class Microsoft.CodeAnalysis.CompilationOptions : object {
    [CompilerGeneratedAttribute]
private OutputKind <OutputKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScriptClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MainTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<byte> <CryptoPublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CryptoKeyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CryptoKeyContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <DelaySign>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckOverflow>k__BackingField;
    [CompilerGeneratedAttribute]
private Platform <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private OptimizationLevel <OptimizationLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private ReportDiagnostic <GeneralDiagnosticOption>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WarningLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConcurrentBuild>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExtendedCustomDebugInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataImportOptions <MetadataImportOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, ReportDiagnostic> <SpecificDiagnosticOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataReferenceResolver <MetadataReferenceResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlReferenceResolver <XmlReferenceResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceReferenceResolver <SourceReferenceResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private StrongNameProvider <StrongNameProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyIdentityComparer <AssemblyIdentityComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Features>k__BackingField;
    private Lazy`1<ImmutableArray`1<Diagnostic>> _lazyErrors;
    public OutputKind OutputKind { get; protected set; }
    public string ModuleName { get; protected set; }
    public string ScriptClassName { get; protected set; }
    public string MainTypeName { get; protected set; }
    public ImmutableArray`1<byte> CryptoPublicKey { get; protected set; }
    public string CryptoKeyFile { get; protected set; }
    public string CryptoKeyContainer { get; protected set; }
    public Nullable`1<bool> DelaySign { get; protected set; }
    public bool CheckOverflow { get; protected set; }
    public Platform Platform { get; protected set; }
    public OptimizationLevel OptimizationLevel { get; protected set; }
    public ReportDiagnostic GeneralDiagnosticOption { get; protected set; }
    public int WarningLevel { get; protected set; }
    public bool ConcurrentBuild { get; protected set; }
    internal bool ExtendedCustomDebugInformation { get; private set; }
    unknown bool ExtendedCustomDebugInformation_internal_protected_set {internal set; }
    internal MetadataImportOptions MetadataImportOptions { get; private set; }
    unknown MetadataImportOptions MetadataImportOptions_internal_protected_set {internal set; }
    public ImmutableDictionary`2<string, ReportDiagnostic> SpecificDiagnosticOptions { get; protected set; }
    public MetadataReferenceResolver MetadataReferenceResolver { get; protected set; }
    public XmlReferenceResolver XmlReferenceResolver { get; protected set; }
    public SourceReferenceResolver SourceReferenceResolver { get; protected set; }
    public StrongNameProvider StrongNameProvider { get; protected set; }
    public AssemblyIdentityComparer AssemblyIdentityComparer { get; protected set; }
    protected internal ImmutableArray`1<string> Features { get; protected set; }
    internal bool EnableEditAndContinue { get; }
    public ImmutableArray`1<Diagnostic> Errors { get; }
    internal CompilationOptions(OutputKind outputKind, string moduleName, string mainTypeName, string scriptClassName, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray`1<byte> cryptoPublicKey, Nullable`1<bool> delaySign, OptimizationLevel optimizationLevel, bool checkOverflow, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, ImmutableDictionary`2<string, ReportDiagnostic> specificDiagnosticOptions, bool concurrentBuild, bool extendedCustomDebugInformation, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider, MetadataImportOptions metadataImportOptions, ImmutableArray`1<string> features);
    [CompilerGeneratedAttribute]
public OutputKind get_OutputKind();
    [CompilerGeneratedAttribute]
protected void set_OutputKind(OutputKind value);
    [CompilerGeneratedAttribute]
public string get_ModuleName();
    [CompilerGeneratedAttribute]
protected void set_ModuleName(string value);
    [CompilerGeneratedAttribute]
public string get_ScriptClassName();
    [CompilerGeneratedAttribute]
protected void set_ScriptClassName(string value);
    [CompilerGeneratedAttribute]
public string get_MainTypeName();
    [CompilerGeneratedAttribute]
protected void set_MainTypeName(string value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<byte> get_CryptoPublicKey();
    [CompilerGeneratedAttribute]
protected void set_CryptoPublicKey(ImmutableArray`1<byte> value);
    [CompilerGeneratedAttribute]
public string get_CryptoKeyFile();
    [CompilerGeneratedAttribute]
protected void set_CryptoKeyFile(string value);
    [CompilerGeneratedAttribute]
public string get_CryptoKeyContainer();
    [CompilerGeneratedAttribute]
protected void set_CryptoKeyContainer(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_DelaySign();
    [CompilerGeneratedAttribute]
protected void set_DelaySign(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_CheckOverflow();
    [CompilerGeneratedAttribute]
protected void set_CheckOverflow(bool value);
    [CompilerGeneratedAttribute]
public Platform get_Platform();
    [CompilerGeneratedAttribute]
protected void set_Platform(Platform value);
    [CompilerGeneratedAttribute]
public OptimizationLevel get_OptimizationLevel();
    [CompilerGeneratedAttribute]
protected void set_OptimizationLevel(OptimizationLevel value);
    [CompilerGeneratedAttribute]
public ReportDiagnostic get_GeneralDiagnosticOption();
    [CompilerGeneratedAttribute]
protected void set_GeneralDiagnosticOption(ReportDiagnostic value);
    [CompilerGeneratedAttribute]
public int get_WarningLevel();
    [CompilerGeneratedAttribute]
protected void set_WarningLevel(int value);
    [CompilerGeneratedAttribute]
public bool get_ConcurrentBuild();
    [CompilerGeneratedAttribute]
protected void set_ConcurrentBuild(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ExtendedCustomDebugInformation();
    [CompilerGeneratedAttribute]
private void set_ExtendedCustomDebugInformation(bool value);
    internal void set_ExtendedCustomDebugInformation_internal_protected_set(bool value);
    [CompilerGeneratedAttribute]
internal MetadataImportOptions get_MetadataImportOptions();
    [CompilerGeneratedAttribute]
private void set_MetadataImportOptions(MetadataImportOptions value);
    internal void set_MetadataImportOptions_internal_protected_set(MetadataImportOptions value);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, ReportDiagnostic> get_SpecificDiagnosticOptions();
    [CompilerGeneratedAttribute]
protected void set_SpecificDiagnosticOptions(ImmutableDictionary`2<string, ReportDiagnostic> value);
    [CompilerGeneratedAttribute]
public MetadataReferenceResolver get_MetadataReferenceResolver();
    [CompilerGeneratedAttribute]
protected void set_MetadataReferenceResolver(MetadataReferenceResolver value);
    [CompilerGeneratedAttribute]
public XmlReferenceResolver get_XmlReferenceResolver();
    [CompilerGeneratedAttribute]
protected void set_XmlReferenceResolver(XmlReferenceResolver value);
    [CompilerGeneratedAttribute]
public SourceReferenceResolver get_SourceReferenceResolver();
    [CompilerGeneratedAttribute]
protected void set_SourceReferenceResolver(SourceReferenceResolver value);
    [CompilerGeneratedAttribute]
public StrongNameProvider get_StrongNameProvider();
    [CompilerGeneratedAttribute]
protected void set_StrongNameProvider(StrongNameProvider value);
    [CompilerGeneratedAttribute]
public AssemblyIdentityComparer get_AssemblyIdentityComparer();
    [CompilerGeneratedAttribute]
protected void set_AssemblyIdentityComparer(AssemblyIdentityComparer value);
    [CompilerGeneratedAttribute]
protected internal ImmutableArray`1<string> get_Features();
    [CompilerGeneratedAttribute]
protected void set_Features(ImmutableArray`1<string> value);
    internal bool CanReuseCompilationReferenceManager(CompilationOptions other);
    internal bool get_EnableEditAndContinue();
    internal static bool IsValidFileAlignment(int value);
    public CompilationOptions WithGeneralDiagnosticOption(ReportDiagnostic value);
    public CompilationOptions WithSpecificDiagnosticOptions(ImmutableDictionary`2<string, ReportDiagnostic> value);
    public CompilationOptions WithSpecificDiagnosticOptions(IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> value);
    public CompilationOptions WithOutputKind(OutputKind kind);
    public CompilationOptions WithPlatform(Platform platform);
    public CompilationOptions WithOptimizationLevel(OptimizationLevel value);
    public CompilationOptions WithXmlReferenceResolver(XmlReferenceResolver resolver);
    public CompilationOptions WithSourceReferenceResolver(SourceReferenceResolver resolver);
    public CompilationOptions WithMetadataReferenceResolver(MetadataReferenceResolver resolver);
    public CompilationOptions WithAssemblyIdentityComparer(AssemblyIdentityComparer comparer);
    public CompilationOptions WithStrongNameProvider(StrongNameProvider provider);
    internal CompilationOptions WithFeatures(ImmutableArray`1<string> features);
    protected abstract virtual CompilationOptions CommonWithOutputKind(OutputKind kind);
    protected abstract virtual CompilationOptions CommonWithPlatform(Platform platform);
    protected abstract virtual CompilationOptions CommonWithOptimizationLevel(OptimizationLevel value);
    protected abstract virtual CompilationOptions CommonWithXmlReferenceResolver(XmlReferenceResolver resolver);
    protected abstract virtual CompilationOptions CommonWithSourceReferenceResolver(SourceReferenceResolver resolver);
    protected abstract virtual CompilationOptions CommonWithMetadataReferenceResolver(MetadataReferenceResolver resolver);
    protected abstract virtual CompilationOptions CommonWithAssemblyIdentityComparer(AssemblyIdentityComparer comparer);
    protected abstract virtual CompilationOptions CommonWithStrongNameProvider(StrongNameProvider provider);
    protected abstract virtual CompilationOptions CommonWithGeneralDiagnosticOption(ReportDiagnostic generalDiagnosticOption);
    protected abstract virtual CompilationOptions CommonWithSpecificDiagnosticOptions(ImmutableDictionary`2<string, ReportDiagnostic> specificDiagnosticOptions);
    protected abstract virtual CompilationOptions CommonWithSpecificDiagnosticOptions(IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> specificDiagnosticOptions);
    protected abstract virtual CompilationOptions CommonWithFeatures(ImmutableArray`1<string> features);
    internal abstract virtual void ValidateOptions(ArrayBuilder`1<Diagnostic> builder);
    public ImmutableArray`1<Diagnostic> get_Errors();
    public abstract virtual bool Equals(object obj);
    protected bool EqualsHelper(CompilationOptions other);
    public abstract virtual int GetHashCode();
    protected int GetHashCodeHelper();
    public static bool op_Equality(CompilationOptions left, CompilationOptions right);
    public static bool op_Inequality(CompilationOptions left, CompilationOptions right);
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Diagnostic> <.ctor>b__97_0();
}
public abstract class Microsoft.CodeAnalysis.CompilationReference : MetadataReference {
    public Compilation Compilation { get; }
    internal Compilation CompilationCore { get; }
    public string Display { get; }
    internal CompilationReference(MetadataReferenceProperties properties);
    public Compilation get_Compilation();
    internal abstract virtual Compilation get_CompilationCore();
    internal static MetadataReferenceProperties GetProperties(Compilation compilation, ImmutableArray`1<string> aliases, bool embedInteropTypes);
    public CompilationReference WithAliases(IEnumerable`1<string> aliases);
    public CompilationReference WithAliases(ImmutableArray`1<string> aliases);
    public CompilationReference WithEmbedInteropTypes(bool value);
    public CompilationReference WithProperties(MetadataReferenceProperties properties);
    internal sealed virtual MetadataReference WithPropertiesImplReturningMetadataReference(MetadataReferenceProperties properties);
    internal abstract virtual CompilationReference WithPropertiesImpl(MetadataReferenceProperties properties);
    public virtual string get_Display();
}
internal enum Microsoft.CodeAnalysis.CompilationStage : Enum {
    public int value__;
    public static CompilationStage Parse;
    public static CompilationStage Declare;
    public static CompilationStage Compile;
    public static CompilationStage Emit;
}
internal class Microsoft.CodeAnalysis.ConcurrentCache`2 : CachingBase`1<Entry<TKey, TValue>> {
    public ConcurrentCache`2(int size);
    public bool TryAdd(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ConsListExtensions : object {
    [ExtensionAttribute]
public static ConsList`1<T> Prepend(ConsList`1<T> list, T head);
    [ExtensionAttribute]
public static bool ContainsReference(ConsList`1<T> list, T element);
}
internal abstract class Microsoft.CodeAnalysis.ConstantValue : object {
    public static ConstantValue NotAvailable;
    public ConstantValueTypeDiscriminator Discriminator { get; }
    internal SpecialType SpecialType { get; }
    public string StringValue { get; }
    public bool BooleanValue { get; }
    public sbyte SByteValue { get; }
    public byte ByteValue { get; }
    public short Int16Value { get; }
    public ushort UInt16Value { get; }
    public int Int32Value { get; }
    public UInt32 UInt32Value { get; }
    public long Int64Value { get; }
    public ulong UInt64Value { get; }
    public char CharValue { get; }
    public decimal DecimalValue { get; }
    public DateTime DateTimeValue { get; }
    public double DoubleValue { get; }
    public float SingleValue { get; }
    public bool IsDefaultValue { get; }
    public static ConstantValue Bad { get; }
    public static ConstantValue Null { get; }
    public static ConstantValue Nothing { get; }
    public static ConstantValue Unset { get; }
    public static ConstantValue True { get; }
    public static ConstantValue False { get; }
    public object Value { get; }
    public bool IsIntegral { get; }
    public bool IsNegativeNumeric { get; }
    public bool IsNumeric { get; }
    public bool IsUnsigned { get; }
    public bool IsBoolean { get; }
    public bool IsChar { get; }
    public bool IsString { get; }
    public bool IsDecimal { get; }
    public bool IsDateTime { get; }
    public bool IsFloating { get; }
    public bool IsBad { get; }
    public bool IsNull { get; }
    public bool IsNothing { get; }
    public abstract virtual ConstantValueTypeDiscriminator get_Discriminator();
    internal abstract virtual SpecialType get_SpecialType();
    public virtual string get_StringValue();
    public virtual bool get_BooleanValue();
    public virtual sbyte get_SByteValue();
    public virtual byte get_ByteValue();
    public virtual short get_Int16Value();
    public virtual ushort get_UInt16Value();
    public virtual int get_Int32Value();
    public virtual UInt32 get_UInt32Value();
    public virtual long get_Int64Value();
    public virtual ulong get_UInt64Value();
    public virtual char get_CharValue();
    public virtual decimal get_DecimalValue();
    public virtual DateTime get_DateTimeValue();
    public virtual double get_DoubleValue();
    public virtual float get_SingleValue();
    public virtual bool get_IsDefaultValue();
    public static ConstantValue get_Bad();
    public static ConstantValue get_Null();
    public static ConstantValue get_Nothing();
    public static ConstantValue get_Unset();
    public static ConstantValue get_True();
    public static ConstantValue get_False();
    public static ConstantValue Create(string value);
    public static ConstantValue Create(char value);
    public static ConstantValue Create(sbyte value);
    public static ConstantValue Create(byte value);
    public static ConstantValue Create(short value);
    public static ConstantValue Create(ushort value);
    public static ConstantValue Create(int value);
    public static ConstantValue Create(UInt32 value);
    public static ConstantValue Create(long value);
    public static ConstantValue Create(ulong value);
    public static ConstantValue Create(bool value);
    public static ConstantValue Create(float value);
    public static ConstantValue CreateSingle(double value);
    public static ConstantValue Create(double value);
    public static ConstantValue Create(decimal value);
    public static ConstantValue Create(DateTime value);
    public static ConstantValue Create(object value, SpecialType st);
    public static ConstantValue CreateSizeOf(SpecialType st);
    public static ConstantValue Create(object value, ConstantValueTypeDiscriminator discriminator);
    public static ConstantValue Default(SpecialType st);
    public static ConstantValue Default(ConstantValueTypeDiscriminator discriminator);
    internal static ConstantValueTypeDiscriminator GetDiscriminator(SpecialType st);
    private static SpecialType GetSpecialType(ConstantValueTypeDiscriminator discriminator);
    public object get_Value();
    public static bool IsIntegralType(ConstantValueTypeDiscriminator discriminator);
    public bool get_IsIntegral();
    public bool get_IsNegativeNumeric();
    public bool get_IsNumeric();
    public static bool IsUnsignedIntegralType(ConstantValueTypeDiscriminator discriminator);
    public bool get_IsUnsigned();
    public static bool IsBooleanType(ConstantValueTypeDiscriminator discriminator);
    public bool get_IsBoolean();
    public static bool IsCharType(ConstantValueTypeDiscriminator discriminator);
    public bool get_IsChar();
    public static bool IsStringType(ConstantValueTypeDiscriminator discriminator);
    public bool get_IsString();
    public static bool IsDecimalType(ConstantValueTypeDiscriminator discriminator);
    public bool get_IsDecimal();
    public static bool IsDateTimeType(ConstantValueTypeDiscriminator discriminator);
    public bool get_IsDateTime();
    public static bool IsFloatingType(ConstantValueTypeDiscriminator discriminator);
    public bool get_IsFloating();
    public bool get_IsBad();
    public bool get_IsNull();
    public bool get_IsNothing();
    public void Serialize(BinaryWriter to);
    public virtual string ToString();
    internal virtual string GetValueToDisplay();
    public virtual bool Equals(ConstantValue other);
    public static bool op_Equality(ConstantValue left, ConstantValue right);
    public static bool op_Inequality(ConstantValue left, ConstantValue right);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal enum Microsoft.CodeAnalysis.ConstantValueTypeDiscriminator : Enum {
    public byte value__;
    public static ConstantValueTypeDiscriminator Nothing;
    public static ConstantValueTypeDiscriminator Null;
    public static ConstantValueTypeDiscriminator Bad;
    public static ConstantValueTypeDiscriminator SByte;
    public static ConstantValueTypeDiscriminator Byte;
    public static ConstantValueTypeDiscriminator Int16;
    public static ConstantValueTypeDiscriminator UInt16;
    public static ConstantValueTypeDiscriminator Int32;
    public static ConstantValueTypeDiscriminator UInt32;
    public static ConstantValueTypeDiscriminator Int64;
    public static ConstantValueTypeDiscriminator UInt64;
    public static ConstantValueTypeDiscriminator Char;
    public static ConstantValueTypeDiscriminator Boolean;
    public static ConstantValueTypeDiscriminator Single;
    public static ConstantValueTypeDiscriminator Double;
    public static ConstantValueTypeDiscriminator String;
    public static ConstantValueTypeDiscriminator Decimal;
    public static ConstantValueTypeDiscriminator DateTime;
}
public abstract class Microsoft.CodeAnalysis.ControlFlowAnalysis : object {
    public ImmutableArray`1<SyntaxNode> EntryPoints { get; }
    public ImmutableArray`1<SyntaxNode> ExitPoints { get; }
    public bool EndPointIsReachable { get; }
    public bool StartPointIsReachable { get; }
    public ImmutableArray`1<SyntaxNode> ReturnStatements { get; }
    public bool Succeeded { get; }
    public abstract virtual ImmutableArray`1<SyntaxNode> get_EntryPoints();
    public abstract virtual ImmutableArray`1<SyntaxNode> get_ExitPoints();
    public abstract virtual bool get_EndPointIsReachable();
    public abstract virtual bool get_StartPointIsReachable();
    public abstract virtual ImmutableArray`1<SyntaxNode> get_ReturnStatements();
    public abstract virtual bool get_Succeeded();
}
internal abstract class Microsoft.CodeAnalysis.CryptographicHashProvider : object {
    private ImmutableArray`1<byte> _lazySHA1Hash;
    private ImmutableArray`1<byte> _lazySHA256Hash;
    private ImmutableArray`1<byte> _lazySHA384Hash;
    private ImmutableArray`1<byte> _lazySHA512Hash;
    private ImmutableArray`1<byte> _lazyMD5Hash;
    internal static int Sha1HashSize;
    internal abstract virtual ImmutableArray`1<byte> ComputeHash(HashAlgorithm algorithm);
    internal ImmutableArray`1<byte> GetHash(AssemblyHashAlgorithm algorithmId);
    internal static int GetHashSize(SourceHashAlgorithm algorithmId);
    internal static HashAlgorithm TryGetAlgorithm(SourceHashAlgorithm algorithmId);
    internal static HashAlgorithm TryGetAlgorithm(AssemblyHashAlgorithm algorithmId);
    internal static bool IsSupportedAlgorithm(AssemblyHashAlgorithm algorithmId);
    private ImmutableArray`1<byte> GetHash(ImmutableArray`1& lazyHash, HashAlgorithm algorithm);
    internal static ImmutableArray`1<byte> ComputeSha1(Stream stream);
    internal static ImmutableArray`1<byte> ComputeSha1(ImmutableArray`1<byte> bytes);
    internal static ImmutableArray`1<byte> ComputeSha1(Byte[] bytes);
}
internal class Microsoft.CodeAnalysis.CustomAttributesBag`1 : object {
    private ImmutableArray`1<T> _customAttributes;
    private WellKnownAttributeData _decodedWellKnownAttributeData;
    private EarlyWellKnownAttributeData _earlyDecodedWellKnownAttributeData;
    private int _state;
    public static CustomAttributesBag`1<T> Empty;
    public bool IsEmpty { get; }
    public ImmutableArray`1<T> Attributes { get; }
    public WellKnownAttributeData DecodedWellKnownAttributeData { get; }
    public EarlyWellKnownAttributeData EarlyDecodedWellKnownAttributeData { get; }
    private CustomAttributeBagCompletionPart<T> State { get; private set; }
    internal bool IsSealed { get; }
    internal bool IsEarlyDecodedWellKnownAttributeDataComputed { get; }
    internal bool IsDecodedWellKnownAttributeDataComputed { get; }
    private CustomAttributesBag`1(CustomAttributeBagCompletionPart<T> part, ImmutableArray`1<T> customAttributes);
    private static CustomAttributesBag`1();
    public static CustomAttributesBag`1<T> WithEmptyData();
    public bool get_IsEmpty();
    public bool SetEarlyDecodedWellKnownAttributeData(EarlyWellKnownAttributeData data);
    public bool SetDecodedWellKnownAttributeData(WellKnownAttributeData data);
    public bool SetAttributes(ImmutableArray`1<T> newCustomAttributes);
    public ImmutableArray`1<T> get_Attributes();
    public WellKnownAttributeData get_DecodedWellKnownAttributeData();
    public EarlyWellKnownAttributeData get_EarlyDecodedWellKnownAttributeData();
    private CustomAttributeBagCompletionPart<T> get_State();
    private void set_State(CustomAttributeBagCompletionPart<T> value);
    private void NotePartComplete(CustomAttributeBagCompletionPart<T> part);
    internal bool IsPartComplete(CustomAttributeBagCompletionPart<T> part);
    internal bool get_IsSealed();
    internal bool get_IsEarlyDecodedWellKnownAttributeDataComputed();
    internal bool get_IsDecodedWellKnownAttributeDataComputed();
}
public abstract class Microsoft.CodeAnalysis.CustomModifier : object {
    public bool IsOptional { get; }
    public INamedTypeSymbol Modifier { get; }
    private bool Microsoft.Cci.ICustomModifier.IsOptional { get; }
    public abstract virtual bool get_IsOptional();
    public abstract virtual INamedTypeSymbol get_Modifier();
    private sealed virtual override bool Microsoft.Cci.ICustomModifier.get_IsOptional();
    private sealed virtual override ITypeReference Microsoft.Cci.ICustomModifier.GetModifier(EmitContext context);
}
internal class Microsoft.CodeAnalysis.CvtResFile : object {
    private static ushort RT_DLGINCLUDE;
    internal static List`1<RESOURCE> ReadResFile(Stream stream);
    private static RESOURCE_STRING ReadStringOrID(BinaryReader fhIn);
}
public abstract class Microsoft.CodeAnalysis.DataFlowAnalysis : object {
    public ImmutableArray`1<ISymbol> VariablesDeclared { get; }
    public ImmutableArray`1<ISymbol> DataFlowsIn { get; }
    public ImmutableArray`1<ISymbol> DataFlowsOut { get; }
    public ImmutableArray`1<ISymbol> AlwaysAssigned { get; }
    public ImmutableArray`1<ISymbol> ReadInside { get; }
    public ImmutableArray`1<ISymbol> WrittenInside { get; }
    public ImmutableArray`1<ISymbol> ReadOutside { get; }
    public ImmutableArray`1<ISymbol> WrittenOutside { get; }
    public ImmutableArray`1<ISymbol> Captured { get; }
    public ImmutableArray`1<ISymbol> UnsafeAddressTaken { get; }
    public bool Succeeded { get; }
    public abstract virtual ImmutableArray`1<ISymbol> get_VariablesDeclared();
    public abstract virtual ImmutableArray`1<ISymbol> get_DataFlowsIn();
    public abstract virtual ImmutableArray`1<ISymbol> get_DataFlowsOut();
    public abstract virtual ImmutableArray`1<ISymbol> get_AlwaysAssigned();
    public abstract virtual ImmutableArray`1<ISymbol> get_ReadInside();
    public abstract virtual ImmutableArray`1<ISymbol> get_WrittenInside();
    public abstract virtual ImmutableArray`1<ISymbol> get_ReadOutside();
    public abstract virtual ImmutableArray`1<ISymbol> get_WrittenOutside();
    public abstract virtual ImmutableArray`1<ISymbol> get_Captured();
    public abstract virtual ImmutableArray`1<ISymbol> get_UnsafeAddressTaken();
    public abstract virtual bool get_Succeeded();
}
internal class Microsoft.CodeAnalysis.DeclarationComputer : object {
    internal static DeclarationInfo GetDeclarationInfo(SemanticModel model, SyntaxNode node, bool getSymbol, IEnumerable`1<SyntaxNode> executableCodeBlocks, CancellationToken cancellationToken);
    internal static DeclarationInfo GetDeclarationInfo(SemanticModel model, SyntaxNode node, bool getSymbol, CancellationToken cancellationToken);
    internal static DeclarationInfo GetDeclarationInfo(SemanticModel model, SyntaxNode node, bool getSymbol, SyntaxNode executableCodeBlock, CancellationToken cancellationToken);
    internal static DeclarationInfo GetDeclarationInfo(SemanticModel model, SyntaxNode node, bool getSymbol, CancellationToken cancellationToken, SyntaxNode[] executableCodeBlocks);
}
internal class Microsoft.CodeAnalysis.DeclarationInfo : ValueType {
    private SyntaxNode _declaredNode;
    private ImmutableArray`1<SyntaxNode> _executableCodeBlocks;
    private ISymbol _declaredSymbol;
    public SyntaxNode DeclaredNode { get; }
    public ImmutableArray`1<SyntaxNode> ExecutableCodeBlocks { get; }
    public ISymbol DeclaredSymbol { get; }
    internal DeclarationInfo(SyntaxNode declaredNode, ImmutableArray`1<SyntaxNode> executableCodeBlocks, ISymbol declaredSymbol);
    public SyntaxNode get_DeclaredNode();
    public ImmutableArray`1<SyntaxNode> get_ExecutableCodeBlocks();
    public ISymbol get_DeclaredSymbol();
}
internal class Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3 : ValueType {
    private WellKnownAttributeData _lazyDecodeData;
    [CompilerGeneratedAttribute]
private TAttributeSyntax <AttributeSyntaxOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private TAttributeData <Attribute>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AttributesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticBag <Diagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private TAttributeLocation <SymbolPart>k__BackingField;
    public bool HasDecodedData { get; }
    public WellKnownAttributeData DecodedData { get; }
    public TAttributeSyntax AttributeSyntaxOpt { get; public set; }
    public TAttributeData Attribute { get; public set; }
    public int Index { get; public set; }
    public int AttributesCount { get; public set; }
    public DiagnosticBag Diagnostics { get; public set; }
    public TAttributeLocation SymbolPart { get; public set; }
    public T GetOrCreateData();
    public bool get_HasDecodedData();
    public WellKnownAttributeData get_DecodedData();
    [CompilerGeneratedAttribute]
public TAttributeSyntax get_AttributeSyntaxOpt();
    [CompilerGeneratedAttribute]
public void set_AttributeSyntaxOpt(TAttributeSyntax value);
    [CompilerGeneratedAttribute]
public TAttributeData get_Attribute();
    [CompilerGeneratedAttribute]
public void set_Attribute(TAttributeData value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
public int get_AttributesCount();
    [CompilerGeneratedAttribute]
public void set_AttributesCount(int value);
    [CompilerGeneratedAttribute]
public DiagnosticBag get_Diagnostics();
    [CompilerGeneratedAttribute]
public void set_Diagnostics(DiagnosticBag value);
    [CompilerGeneratedAttribute]
public TAttributeLocation get_SymbolPart();
    [CompilerGeneratedAttribute]
public void set_SymbolPart(TAttributeLocation value);
}
public class Microsoft.CodeAnalysis.DesktopAssemblyIdentityComparer : AssemblyIdentityComparer {
    [CompilerGeneratedAttribute]
private static DesktopAssemblyIdentityComparer <Default>k__BackingField;
    internal AssemblyPortabilityPolicy policy;
    private static ImmutableArray`1<byte> s_NETCF_PUBLIC_KEY_TOKEN_1;
    private static ImmutableArray`1<byte> s_NETCF_PUBLIC_KEY_TOKEN_2;
    private static ImmutableArray`1<byte> s_NETCF_PUBLIC_KEY_TOKEN_3;
    private static ImmutableArray`1<byte> s_SQL_PUBLIC_KEY_TOKEN;
    private static ImmutableArray`1<byte> s_SQL_MOBILE_PUBLIC_KEY_TOKEN;
    private static ImmutableArray`1<byte> s_ECMA_PUBLICKEY_STR_L;
    private static ImmutableArray`1<byte> s_SHAREDLIB_PUBLICKEY_STR_L;
    private static ImmutableArray`1<byte> s_MICROSOFT_PUBLICKEY_STR_L;
    private static ImmutableArray`1<byte> s_SILVERLIGHT_PLATFORM_PUBLICKEY_STR_L;
    private static ImmutableArray`1<byte> s_SILVERLIGHT_PUBLICKEY_STR_L;
    private static ImmutableArray`1<byte> s_RIA_SERVICES_KEY_TOKEN;
    private static AssemblyVersion s_VER_VS_COMPATIBILITY_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion s_VER_VS_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion s_VER_SQL_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion s_VER_LINQ_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion s_VER_LINQ_ASSEMBLYVERSION_STR_2_L;
    private static AssemblyVersion s_VER_SQL_ORCAS_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion s_VER_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion s_VER_VC_STLCLR_ASSEMBLYVERSION_STR_L;
    private static string NULL;
    private static bool TRUE;
    private static FrameworkRetargetingDictionary s_arRetargetPolicy;
    private static FrameworkAssemblyDictionary s_arFxPolicy;
    public static DesktopAssemblyIdentityComparer Default { get; }
    internal AssemblyPortabilityPolicy PortabilityPolicy { get; }
    internal DesktopAssemblyIdentityComparer(AssemblyPortabilityPolicy policy);
    private static DesktopAssemblyIdentityComparer();
    [CompilerGeneratedAttribute]
public static DesktopAssemblyIdentityComparer get_Default();
    public static DesktopAssemblyIdentityComparer LoadFromXml(Stream input);
    internal AssemblyPortabilityPolicy get_PortabilityPolicy();
    internal virtual bool ApplyUnificationPolicies(AssemblyIdentity& reference, AssemblyIdentity& definition, AssemblyIdentityParts referenceParts, Boolean& isFxAssembly);
    private static bool IsFrameworkAssembly(AssemblyIdentity identity);
    private static bool IsRetargetableAssembly(AssemblyIdentity identity);
    private static bool IsOptionallyRetargetableAssembly(AssemblyIdentity identity);
    private static bool IsTriviallyNonRetargetable(AssemblyIdentity identity);
    private static void IsRetargetableAssembly(AssemblyIdentity identity, Boolean& retargetable, Boolean& portable);
    private static AssemblyIdentity Retarget(AssemblyIdentity identity);
    private AssemblyIdentity Port(AssemblyIdentity identity);
}
public class Microsoft.CodeAnalysis.DesktopStrongNameProvider : StrongNameProvider {
    private ImmutableArray`1<string> _keyFileSearchPaths;
    internal Func`1<IClrStrongName> TestStrongNameInterfaceFactory;
    private static Tuple`2<Byte[], ImmutableArray`1<byte>> s_lastSeenKeyPair;
    public DesktopStrongNameProvider(ImmutableArray`1<string> keyFileSearchPaths);
    internal virtual bool FileExists(string fullPath);
    internal virtual Byte[] ReadAllBytes(string fullPath);
    internal string ResolveStrongNameKeyFile(string path);
    internal virtual Stream CreateInputStream();
    internal virtual StrongNameKeys CreateKeys(string keyFilePath, string keyContainerName, CommonMessageProvider messageProvider);
    private void ReadKeysFromContainer(string keyContainer, ImmutableArray`1& publicKey);
    private void ReadKeysFromPath(string fullPath, ImmutableArray`1& keyPair, ImmutableArray`1& publicKey);
    internal virtual void SignAssembly(StrongNameKeys keys, Stream inputStream, Stream outputStream);
    internal IClrStrongName GetStrongNameInterface();
    internal ImmutableArray`1<byte> GetPublicKey(string keyContainer);
    private static UInt32 GET_ALG_CLASS(UInt32 x);
    internal static bool IsPublicKeyBlob(Byte[] keyFileContents);
    internal ImmutableArray`1<byte> GetPublicKey(Byte[] keyFileContents);
    private void Sign(string filePath, string keyName);
    private void Sign(string filePath, ImmutableArray`1<byte> keyPair);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public abstract class Microsoft.CodeAnalysis.Diagnostic : object {
    internal static string CompilerDiagnosticCategory;
    internal static int HighestValidWarningLevel;
    public DiagnosticDescriptor Descriptor { get; }
    public string Id { get; }
    internal string Category { get; }
    public DiagnosticSeverity DefaultSeverity { get; }
    public DiagnosticSeverity Severity { get; }
    public int WarningLevel { get; }
    internal bool IsEnabledByDefault { get; }
    public bool IsWarningAsError { get; }
    public Location Location { get; }
    public IReadOnlyList`1<Location> AdditionalLocations { get; }
    internal IReadOnlyList`1<string> CustomTags { get; }
    public ImmutableDictionary`2<string, string> Properties { get; }
    internal int Code { get; }
    internal IReadOnlyList`1<object> Arguments { get; }
    public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, Object[] messageArgs);
    public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, IEnumerable`1<Location> additionalLocations, Object[] messageArgs);
    public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, IEnumerable`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    public static Diagnostic Create(string id, string category, LocalizableString message, DiagnosticSeverity severity, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, int warningLevel, LocalizableString title, LocalizableString description, string helpLink, Location location, IEnumerable`1<Location> additionalLocations, IEnumerable`1<string> customTags, ImmutableDictionary`2<string, string> properties);
    internal static Diagnostic Create(CommonMessageProvider messageProvider, int errorCode);
    internal static Diagnostic Create(CommonMessageProvider messageProvider, int errorCode, Object[] arguments);
    internal static Diagnostic Create(DiagnosticInfo info);
    public abstract virtual DiagnosticDescriptor get_Descriptor();
    public abstract virtual string get_Id();
    internal virtual string get_Category();
    public abstract virtual string GetMessage(IFormatProvider formatProvider);
    public virtual DiagnosticSeverity get_DefaultSeverity();
    public abstract virtual DiagnosticSeverity get_Severity();
    public abstract virtual int get_WarningLevel();
    internal virtual bool get_IsEnabledByDefault();
    public bool get_IsWarningAsError();
    public abstract virtual Location get_Location();
    public abstract virtual IReadOnlyList`1<Location> get_AdditionalLocations();
    internal virtual IReadOnlyList`1<string> get_CustomTags();
    public virtual ImmutableDictionary`2<string, string> get_Properties();
    private sealed virtual override string System.IFormattable.ToString(string ignored, IFormatProvider formatProvider);
    public virtual string ToString();
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
    public abstract virtual bool Equals(Diagnostic obj);
    private string GetDebuggerDisplay();
    internal abstract virtual Diagnostic WithLocation(Location location);
    internal abstract virtual Diagnostic WithSeverity(DiagnosticSeverity severity);
    internal virtual int get_Code();
    internal virtual IReadOnlyList`1<object> get_Arguments();
    internal bool ContainsLocation(SyntaxTree tree, Nullable`1<TextSpan> filterSpanWithinTree);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostic/<GetDiagnosticLocationsWithinTree>d__48")]
private IEnumerable`1<Location> GetDiagnosticLocationsWithinTree(SyntaxTree tree);
    internal Diagnostic WithReportDiagnostic(ReportDiagnostic reportAction);
    internal static int GetDefaultWarningLevel(DiagnosticSeverity severity);
    internal virtual bool IsNotConfigurable();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.DiagnosticBag/DebuggerProxy")]
internal class Microsoft.CodeAnalysis.DiagnosticBag : object {
    private ConcurrentQueue`1<Diagnostic> _lazyBag;
    private static ObjectPool`1<DiagnosticBag> s_poolInstance;
    public bool IsEmptyWithoutResolution { get; }
    private ConcurrentQueue`1<Diagnostic> Bag { get; }
    private static DiagnosticBag();
    public bool get_IsEmptyWithoutResolution();
    public bool HasAnyErrors();
    internal bool HasAnyResolvedErrors();
    public void Add(Diagnostic diag);
    public void AddRange(ImmutableArray`1<T> diagnostics);
    public void AddRange(IEnumerable`1<Diagnostic> diagnostics);
    public void AddRange(DiagnosticBag bag);
    public void AddRangeAndFree(DiagnosticBag bag);
    public ImmutableArray`1<TDiagnostic> ToReadOnlyAndFree();
    public ImmutableArray`1<Diagnostic> ToReadOnlyAndFree();
    public ImmutableArray`1<TDiagnostic> ToReadOnly();
    public ImmutableArray`1<Diagnostic> ToReadOnly();
    private static ImmutableArray`1<TDiagnostic> ToReadOnlyCore(ConcurrentQueue`1<Diagnostic> oldBag);
    public IEnumerable`1<Diagnostic> AsEnumerable();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.DiagnosticBag/<AsEnumerableFiltered>d__16")]
private IEnumerable`1<Diagnostic> AsEnumerableFiltered();
    internal IEnumerable`1<Diagnostic> AsEnumerableWithoutResolution();
    public virtual string ToString();
    private ConcurrentQueue`1<Diagnostic> get_Bag();
    internal void Clear();
    internal static DiagnosticBag GetInstance();
    internal void Free();
    private static ObjectPool`1<DiagnosticBag> CreatePool(int size);
    private string GetDebuggerDisplay();
}
public class Microsoft.CodeAnalysis.DiagnosticDescriptor : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalizableString <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalizableString <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpLinkUri>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalizableString <MessageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticSeverity <DefaultSeverity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabledByDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <CustomTags>k__BackingField;
    public string Id { get; }
    public LocalizableString Title { get; }
    public LocalizableString Description { get; }
    public string HelpLinkUri { get; }
    public LocalizableString MessageFormat { get; }
    public string Category { get; }
    public DiagnosticSeverity DefaultSeverity { get; }
    public bool IsEnabledByDefault { get; }
    public IEnumerable`1<string> CustomTags { get; }
    public DiagnosticDescriptor(string id, string title, string messageFormat, string category, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, string description, string helpLinkUri, String[] customTags);
    public DiagnosticDescriptor(string id, LocalizableString title, LocalizableString messageFormat, string category, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, LocalizableString description, string helpLinkUri, String[] customTags);
    internal DiagnosticDescriptor(string id, LocalizableString title, LocalizableString messageFormat, string category, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, LocalizableString description, string helpLinkUri, ImmutableArray`1<string> customTags);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public LocalizableString get_Title();
    [CompilerGeneratedAttribute]
public LocalizableString get_Description();
    [CompilerGeneratedAttribute]
public string get_HelpLinkUri();
    [CompilerGeneratedAttribute]
public LocalizableString get_MessageFormat();
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public DiagnosticSeverity get_DefaultSeverity();
    [CompilerGeneratedAttribute]
public bool get_IsEnabledByDefault();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_CustomTags();
    public sealed virtual bool Equals(DiagnosticDescriptor other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal bool IsNotConfigurable();
}
public class Microsoft.CodeAnalysis.DiagnosticFormatter : object {
    internal static DiagnosticFormatter Instance;
    private static DiagnosticFormatter();
    public virtual string Format(Diagnostic diagnostic, IFormatProvider formatter);
    internal virtual string FormatSourcePath(string path, string basePath, IFormatProvider formatter);
    internal virtual string FormatSourceSpan(LinePositionSpan span, IFormatProvider formatter);
    internal string GetMessagePrefix(Diagnostic diagnostic);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.DiagnosticInfo : object {
    private CommonMessageProvider _messageProvider;
    private int _errorCode;
    private DiagnosticSeverity _defaultSeverity;
    private DiagnosticSeverity _effectiveSeverity;
    private Object[] _arguments;
    private static ImmutableDictionary`2<int, DiagnosticDescriptor> s_errorCodeToDescriptorMap;
    private static ImmutableArray`1<string> s_compilerErrorCustomTags;
    private static ImmutableArray`1<string> s_compilerNonErrorCustomTags;
    public int Code { get; }
    public DiagnosticDescriptor Descriptor { get; }
    public DiagnosticSeverity Severity { get; }
    public DiagnosticSeverity DefaultSeverity { get; }
    public int WarningLevel { get; }
    public bool IsWarningAsError { get; }
    public string Category { get; }
    internal ImmutableArray`1<string> CustomTags { get; }
    public IReadOnlyList`1<Location> AdditionalLocations { get; }
    public string MessageIdentifier { get; }
    internal Object[] Arguments { get; }
    internal CommonMessageProvider MessageProvider { get; }
    internal DiagnosticInfo(CommonMessageProvider messageProvider, int errorCode);
    internal DiagnosticInfo(CommonMessageProvider messageProvider, int errorCode, Object[] arguments);
    private DiagnosticInfo(DiagnosticInfo original, DiagnosticSeverity overridenSeverity);
    internal DiagnosticInfo(CommonMessageProvider messageProvider, bool isWarningAsError, int errorCode, Object[] arguments);
    protected DiagnosticInfo(ObjectReader reader);
    private static DiagnosticInfo();
    internal static DiagnosticDescriptor GetDescriptor(int errorCode, CommonMessageProvider messageProvider);
    private static DiagnosticDescriptor GetOrCreateDescriptor(int errorCode, DiagnosticSeverity defaultSeverity, CommonMessageProvider messageProvider);
    private static DiagnosticDescriptor CreateDescriptor(int errorCode, DiagnosticSeverity defaultSeverity, CommonMessageProvider messageProvider);
    [ConditionalAttribute("DEBUG")]
internal static void AssertMessageSerializable(Object[] args);
    internal DiagnosticInfo GetInstanceWithSeverity(DiagnosticSeverity severity);
    private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    protected virtual void WriteTo(ObjectWriter writer);
    private sealed virtual override Func`2<ObjectReader, object> Roslyn.Utilities.IObjectReadable.GetReader();
    protected virtual Func`2<ObjectReader, object> GetReader();
    public int get_Code();
    public DiagnosticDescriptor get_Descriptor();
    public DiagnosticSeverity get_Severity();
    public DiagnosticSeverity get_DefaultSeverity();
    public int get_WarningLevel();
    public bool get_IsWarningAsError();
    public string get_Category();
    internal ImmutableArray`1<string> get_CustomTags();
    private static ImmutableArray`1<string> GetCustomTags(DiagnosticSeverity defaultSeverity);
    internal bool IsNotConfigurable();
    public virtual IReadOnlyList`1<Location> get_AdditionalLocations();
    public string get_MessageIdentifier();
    public virtual string GetMessage(IFormatProvider formatProvider);
    protected Object[] GetArgumentsToUse(IFormatProvider formatProvider);
    private Object[] InitializeArgumentListIfNeeded(Object[] argumentsToUse);
    internal Object[] get_Arguments();
    internal CommonMessageProvider get_MessageProvider();
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private string GetDebuggerDisplay();
    internal virtual DiagnosticInfo GetResolvedInfo();
}
public abstract class Microsoft.CodeAnalysis.Diagnostics.AnalysisContext : object {
    public abstract virtual void RegisterCompilationStartAction(Action`1<CompilationStartAnalysisContext> action);
    public abstract virtual void RegisterCompilationAction(Action`1<CompilationAnalysisContext> action);
    public abstract virtual void RegisterSemanticModelAction(Action`1<SemanticModelAnalysisContext> action);
    public void RegisterSymbolAction(Action`1<SymbolAnalysisContext> action, SymbolKind[] symbolKinds);
    public abstract virtual void RegisterSymbolAction(Action`1<SymbolAnalysisContext> action, ImmutableArray`1<SymbolKind> symbolKinds);
    public abstract virtual void RegisterCodeBlockStartAction(Action`1<CodeBlockStartAnalysisContext`1<TLanguageKindEnum>> action);
    public abstract virtual void RegisterCodeBlockAction(Action`1<CodeBlockAnalysisContext> action);
    public abstract virtual void RegisterSyntaxTreeAction(Action`1<SyntaxTreeAnalysisContext> action);
    public void RegisterSyntaxNodeAction(Action`1<SyntaxNodeAnalysisContext> action, TLanguageKindEnum[] syntaxKinds);
    public abstract virtual void RegisterSyntaxNodeAction(Action`1<SyntaxNodeAnalysisContext> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
}
internal abstract class Microsoft.CodeAnalysis.Diagnostics.AnalyzerAction : object {
    private DiagnosticAnalyzer _analyzer;
    internal DiagnosticAnalyzer Analyzer { get; }
    internal AnalyzerAction(DiagnosticAnalyzer analyzer);
    internal DiagnosticAnalyzer get_Analyzer();
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerActions : object {
    private ImmutableArray`1<CompilationStartAnalyzerAction> _compilationStartActions;
    private ImmutableArray`1<CompilationAnalyzerAction> _compilationEndActions;
    private ImmutableArray`1<CompilationAnalyzerAction> _compilationActions;
    private ImmutableArray`1<SyntaxTreeAnalyzerAction> _syntaxTreeActions;
    private ImmutableArray`1<SemanticModelAnalyzerAction> _semanticModelActions;
    private ImmutableArray`1<SymbolAnalyzerAction> _symbolActions;
    private ImmutableArray`1<AnalyzerAction> _codeBlockStartActions;
    private ImmutableArray`1<CodeBlockAnalyzerAction> _codeBlockEndActions;
    private ImmutableArray`1<CodeBlockAnalyzerAction> _codeBlockActions;
    private ImmutableArray`1<AnalyzerAction> _syntaxNodeActions;
    public int CompilationStartActionsCount { get; }
    public int CompilationEndActionsCount { get; }
    public int CompilationActionsCount { get; }
    public int SyntaxTreeActionsCount { get; }
    public int SemanticModelActionsCount { get; }
    public int SymbolActionsCount { get; }
    public int SyntaxNodeActionsCount { get; }
    public int CodeBlockStartActionsCount { get; }
    public int CodeBlockEndActionsCount { get; }
    public int CodeBlockActionsCount { get; }
    internal ImmutableArray`1<CompilationStartAnalyzerAction> CompilationStartActions { get; }
    internal ImmutableArray`1<CompilationAnalyzerAction> CompilationEndActions { get; }
    internal ImmutableArray`1<CompilationAnalyzerAction> CompilationActions { get; }
    internal ImmutableArray`1<SyntaxTreeAnalyzerAction> SyntaxTreeActions { get; }
    internal ImmutableArray`1<SemanticModelAnalyzerAction> SemanticModelActions { get; }
    internal ImmutableArray`1<SymbolAnalyzerAction> SymbolActions { get; }
    internal ImmutableArray`1<CodeBlockAnalyzerAction> CodeBlockEndActions { get; }
    internal ImmutableArray`1<CodeBlockAnalyzerAction> CodeBlockActions { get; }
    public int get_CompilationStartActionsCount();
    public int get_CompilationEndActionsCount();
    public int get_CompilationActionsCount();
    public int get_SyntaxTreeActionsCount();
    public int get_SemanticModelActionsCount();
    public int get_SymbolActionsCount();
    public int get_SyntaxNodeActionsCount();
    public int get_CodeBlockStartActionsCount();
    public int get_CodeBlockEndActionsCount();
    public int get_CodeBlockActionsCount();
    internal ImmutableArray`1<CompilationStartAnalyzerAction> get_CompilationStartActions();
    internal ImmutableArray`1<CompilationAnalyzerAction> get_CompilationEndActions();
    internal ImmutableArray`1<CompilationAnalyzerAction> get_CompilationActions();
    internal ImmutableArray`1<SyntaxTreeAnalyzerAction> get_SyntaxTreeActions();
    internal ImmutableArray`1<SemanticModelAnalyzerAction> get_SemanticModelActions();
    internal ImmutableArray`1<SymbolAnalyzerAction> get_SymbolActions();
    internal ImmutableArray`1<CodeBlockAnalyzerAction> get_CodeBlockEndActions();
    internal ImmutableArray`1<CodeBlockAnalyzerAction> get_CodeBlockActions();
    internal ImmutableArray`1<CodeBlockStartAnalyzerAction`1<TLanguageKindEnum>> GetCodeBlockStartActions();
    internal ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>> GetSyntaxNodeActions();
    internal void AddCompilationStartAction(CompilationStartAnalyzerAction action);
    internal void AddCompilationEndAction(CompilationAnalyzerAction action);
    internal void AddCompilationAction(CompilationAnalyzerAction action);
    internal void AddSyntaxTreeAction(SyntaxTreeAnalyzerAction action);
    internal void AddSemanticModelAction(SemanticModelAnalyzerAction action);
    internal void AddSymbolAction(SymbolAnalyzerAction action);
    internal void AddCodeBlockStartAction(CodeBlockStartAnalyzerAction`1<TLanguageKindEnum> action);
    internal void AddCodeBlockEndAction(CodeBlockAnalyzerAction action);
    internal void AddCodeBlockAction(CodeBlockAnalyzerAction action);
    internal void AddSyntaxNodeAction(SyntaxNodeAnalyzerAction`1<TLanguageKindEnum> action);
    public AnalyzerActions Append(AnalyzerActions otherActions);
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerAnalysisContext : AnalysisContext {
    private DiagnosticAnalyzer _analyzer;
    private HostSessionStartAnalysisScope _scope;
    public AnalyzerAnalysisContext(DiagnosticAnalyzer analyzer, HostSessionStartAnalysisScope scope);
    public virtual void RegisterCompilationStartAction(Action`1<CompilationStartAnalysisContext> action);
    public virtual void RegisterCompilationAction(Action`1<CompilationAnalysisContext> action);
    public virtual void RegisterSyntaxTreeAction(Action`1<SyntaxTreeAnalysisContext> action);
    public virtual void RegisterSemanticModelAction(Action`1<SemanticModelAnalysisContext> action);
    public virtual void RegisterSymbolAction(Action`1<SymbolAnalysisContext> action, ImmutableArray`1<SymbolKind> symbolKinds);
    public virtual void RegisterCodeBlockStartAction(Action`1<CodeBlockStartAnalysisContext`1<TLanguageKindEnum>> action);
    public virtual void RegisterCodeBlockAction(Action`1<CodeBlockAnalysisContext> action);
    public virtual void RegisterSyntaxNodeAction(Action`1<SyntaxNodeAnalysisContext> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerCodeBlockStartAnalysisContext`1 : CodeBlockStartAnalysisContext`1<TLanguageKindEnum> {
    private DiagnosticAnalyzer _analyzer;
    private HostCodeBlockStartAnalysisScope`1<TLanguageKindEnum> _scope;
    internal AnalyzerCodeBlockStartAnalysisContext`1(DiagnosticAnalyzer analyzer, HostCodeBlockStartAnalysisScope`1<TLanguageKindEnum> scope, SyntaxNode codeBlock, ISymbol owningSymbol, SemanticModel semanticModel, AnalyzerOptions options, CancellationToken cancellationToken);
    public virtual void RegisterCodeBlockEndAction(Action`1<CodeBlockAnalysisContext> action);
    public virtual void RegisterSyntaxNodeAction(Action`1<SyntaxNodeAnalysisContext> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerCompilationStartAnalysisContext : CompilationStartAnalysisContext {
    private DiagnosticAnalyzer _analyzer;
    private HostCompilationStartAnalysisScope _scope;
    public AnalyzerCompilationStartAnalysisContext(DiagnosticAnalyzer analyzer, HostCompilationStartAnalysisScope scope, Compilation compilation, AnalyzerOptions options, CancellationToken cancellationToken);
    public virtual void RegisterCompilationEndAction(Action`1<CompilationAnalysisContext> action);
    public virtual void RegisterSyntaxTreeAction(Action`1<SyntaxTreeAnalysisContext> action);
    public virtual void RegisterSemanticModelAction(Action`1<SemanticModelAnalysisContext> action);
    public virtual void RegisterSymbolAction(Action`1<SymbolAnalysisContext> action, ImmutableArray`1<SymbolKind> symbolKinds);
    public virtual void RegisterCodeBlockStartAction(Action`1<CodeBlockStartAnalysisContext`1<TLanguageKindEnum>> action);
    public virtual void RegisterCodeBlockAction(Action`1<CodeBlockAnalysisContext> action);
    public virtual void RegisterSyntaxNodeAction(Action`1<SyntaxNodeAnalysisContext> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
}
internal abstract class Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver : object {
    internal static ConditionalWeakTable`2<Compilation, SuppressMessageAttributeState> SuppressMessageStateByCompilation;
    private static int MaxSymbolKind;
    private ImmutableArray`1<DiagnosticAnalyzer> _analyzers;
    private CancellationTokenRegistration _queueRegistration;
    protected AnalyzerManager analyzerManager;
    private Compilation _compilation;
    protected AnalyzerExecutor analyzerExecutor;
    internal AnalyzerActions analyzerActions;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<ImmutableArray`1<SymbolAnalyzerAction>>> _symbolActionsByKind;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<SemanticModelAnalyzerAction>> _semanticModelActionsMap;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CompilationAnalyzerAction>> _compilationActionsMap;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CompilationAnalyzerAction>> _compilationEndActionsMap;
    private Task _primaryTask;
    private int _workerCount;
    [CompilerGeneratedAttribute]
private AsyncQueue`1<CompilationEvent> <CompilationEventQueue>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncQueue`1<Diagnostic> <DiagnosticQueue>k__BackingField;
    public AsyncQueue`1<CompilationEvent> CompilationEventQueue { get; }
    public AsyncQueue`1<Diagnostic> DiagnosticQueue { get; }
    public Task WhenCompletedTask { get; }
    internal ImmutableDictionary`2<DiagnosticAnalyzer, TimeSpan> AnalyzerExecutionTimes { get; }
    protected AnalyzerDriver(ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerManager analyzerManager, CancellationToken cancellationToken);
    private static AnalyzerDriver();
    [CompilerGeneratedAttribute]
public AsyncQueue`1<CompilationEvent> get_CompilationEventQueue();
    [CompilerGeneratedAttribute]
public AsyncQueue`1<Diagnostic> get_DiagnosticQueue();
    private void Initialize(Compilation comp, AnalyzerExecutor analyzerExecutor, CancellationToken cancellationToken);
    private Task ExecuteSyntaxTreeActions(CancellationToken cancellationToken);
    public static AnalyzerDriver Create(Compilation compilation, ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerOptions options, AnalyzerManager analyzerManager, Action`1<Diagnostic> addExceptionDiagnostic, bool reportAnalyzer, Compilation& newCompilation, CancellationToken cancellationToken);
    internal static AnalyzerDriver Create(Compilation compilation, ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerOptions options, AnalyzerManager analyzerManager, Action`3<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, bool reportAnalyzer, Compilation& newCompilation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver/<GetDiagnosticsAsync>d__25")]
public Task`1<ImmutableArray`1<Diagnostic>> GetDiagnosticsAsync();
    public Task get_WhenCompletedTask();
    internal ImmutableDictionary`2<DiagnosticAnalyzer, TimeSpan> get_AnalyzerExecutionTimes();
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<ImmutableArray`1<SymbolAnalyzerAction>>> MakeSymbolActionsByKind();
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<SemanticModelAnalyzerAction>> MakeSemanticModelActionsByAnalyzer();
    private static ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CompilationAnalyzerAction>> MakeCompilationActionsByAnalyzer(ImmutableArray`1<CompilationAnalyzerAction> compilationActions);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver/<ProcessCompilationEventsAsync>d__33")]
private Task ProcessCompilationEventsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver/<ProcessCompilationEventsCoreAsync>d__34")]
private Task`1<CompilationCompletedEvent> ProcessCompilationEventsCoreAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver/<ProcessEventAsync>d__35")]
private Task ProcessEventAsync(CompilationEvent e, CancellationToken cancellationToken);
    private Task ProcessEventCoreAsync(CompilationEvent e, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver/<ProcessSymbolDeclaredAsync>d__37")]
private Task ProcessSymbolDeclaredAsync(SymbolDeclaredCompilationEvent symbolEvent, CancellationToken cancellationToken);
    private void AddTasksForExecutingSymbolActions(SymbolDeclaredCompilationEvent symbolEvent, IDictionary`2<DiagnosticAnalyzer, ArrayBuilder`1<Action>> actionsMap, CancellationToken cancellationToken);
    private void ExecuteSymbolActionsForAnalyzer(ISymbol symbol, DiagnosticAnalyzer analyzer, ImmutableArray`1<ImmutableArray`1<SymbolAnalyzerAction>> actionsByKind, Action`1<Diagnostic> addDiagnosticForSymbol, CancellationToken cancellationToken);
    protected static void AddAnalyzerActionsExecutor(IDictionary`2<DiagnosticAnalyzer, ArrayBuilder`1<Action>> map, DiagnosticAnalyzer analyzer, Action executeAnalyzerActions);
    protected abstract virtual void AddTasksForExecutingDeclaringReferenceActions(SymbolDeclaredCompilationEvent symbolEvent, IDictionary`2<DiagnosticAnalyzer, ArrayBuilder`1<Action>> actionsMap, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver/<ProcessCompilationUnitCompletedAsync>d__42")]
private Task ProcessCompilationUnitCompletedAsync(CompilationUnitCompletedEvent completedEvent, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver/<ProcessCompilationCompletedAsync>d__43")]
private Task ProcessCompilationCompletedAsync(CompilationCompletedEvent endEvent, CancellationToken cancellationToken);
    private Task ExecuteCompilationActionsAsync(ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CompilationAnalyzerAction>> compilationActionsMap, CancellationToken cancellationToken);
    internal static Action`1<Diagnostic> GetDiagnosticSinkWithSuppression(Action`1<Diagnostic> addDiagnosticCore, Compilation compilation, ISymbol symbolOpt);
    private static Diagnostic GetFilteredDiagnostic(Diagnostic diagnostic, Compilation compilation, ISymbol symbolOpt);
    private static Task`1<AnalyzerActions> GetAnalyzerActionsAsync(ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerManager analyzerManager, AnalyzerExecutor analyzerExecutor);
    internal static bool IsDiagnosticAnalyzerSuppressed(DiagnosticAnalyzer analyzer, CompilationOptions options, AnalyzerManager analyzerManager, AnalyzerExecutor analyzerExecutor);
    private static bool IsCompilerAnalyzer(DiagnosticAnalyzer analyzer);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <Initialize>b__20_0(Task`1<AnalyzerActions> t);
    [CompilerGeneratedAttribute]
private bool <Initialize>b__20_2(Task c);
    [CompilerGeneratedAttribute]
private void <.ctor>b__24_0();
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1 : AnalyzerDriver {
    private Func`2<SyntaxNode, TLanguageKindEnum> _getKind;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableDictionary`2<TLanguageKindEnum, ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>>>> _lazyNodeActionsByKind;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CodeBlockStartAnalyzerAction`1<TLanguageKindEnum>>> _lazyCodeBlockStartActionsByAnalyzer;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CodeBlockAnalyzerAction>> _lazyCodeBlockEndActionsByAnalyzer;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CodeBlockAnalyzerAction>> _lazyCodeBlockActionsByAnalyzer;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableDictionary`2<TLanguageKindEnum, ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>>>> NodeActionsByKind { get; }
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CodeBlockStartAnalyzerAction`1<TLanguageKindEnum>>> CodeBlockStartActionsByAnalyzer { get; }
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CodeBlockAnalyzerAction>> CodeBlockEndActionsByAnalyzer { get; }
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CodeBlockAnalyzerAction>> CodeBlockActionsByAnalyzer { get; }
    internal AnalyzerDriver`1(ImmutableArray`1<DiagnosticAnalyzer> analyzers, Func`2<SyntaxNode, TLanguageKindEnum> getKind, AnalyzerManager analyzerManager, CancellationToken cancellationToken);
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableDictionary`2<TLanguageKindEnum, ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>>>> get_NodeActionsByKind();
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CodeBlockStartAnalyzerAction`1<TLanguageKindEnum>>> get_CodeBlockStartActionsByAnalyzer();
    private static ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CodeBlockAnalyzerAction>> GetCodeBlockActionsByAnalyzer(ImmutableDictionary`2& lazyCodeBlockActionsByAnalyzer, ImmutableArray`1<CodeBlockAnalyzerAction> codeBlockActions);
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CodeBlockAnalyzerAction>> get_CodeBlockEndActionsByAnalyzer();
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CodeBlockAnalyzerAction>> get_CodeBlockActionsByAnalyzer();
    protected virtual void AddTasksForExecutingDeclaringReferenceActions(SymbolDeclaredCompilationEvent symbolEvent, IDictionary`2<DiagnosticAnalyzer, ArrayBuilder`1<Action>> actionsMap, CancellationToken cancellationToken);
    private void AddTasksForExecutingDeclaringReferenceActions(SyntaxReference decl, SymbolDeclaredCompilationEvent symbolEvent, IDictionary`2<DiagnosticAnalyzer, ArrayBuilder`1<Action>> actionsMap, bool shouldExecuteSyntaxNodeActions, bool shouldExecuteCodeBlockActions, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1/<GetCodeBlockActions>d__18")]
private IEnumerable`1<CodeBlockAnalyzerActions<TLanguageKindEnum>> GetCodeBlockActions();
    private static ImmutableArray`1<SyntaxNode> GetSyntaxNodesToAnalyze(SyntaxNode declaredNode, ISymbol declaredSymbol, IEnumerable`1<DeclarationInfo> declarationsInNode, SemanticModel semanticModel, AnalyzerExecutor analyzerExecutor);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1/<GetSyntaxNodesToAnalyze>d__20")]
private static IEnumerable`1<SyntaxNode> GetSyntaxNodesToAnalyze(SyntaxNode declaredNode, HashSet`1<SyntaxNode> descendantDeclsToSkip);
}
internal static class Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriverResources : object {
    internal static string AnalyzerFailure { get; }
    internal static string AnalyzerThrows { get; }
    internal static string AnalyzerThrowsDescription { get; }
    internal static string ArgumentElementCannotBeNull { get; }
    internal static string ArgumentCannotBeEmpty { get; }
    internal static string UnsupportedDiagnosticReported { get; }
    internal static string get_AnalyzerFailure();
    internal static string get_AnalyzerThrows();
    internal static string get_AnalyzerThrowsDescription();
    internal static string get_ArgumentElementCannotBeNull();
    internal static string get_ArgumentCannotBeEmpty();
    internal static string get_UnsupportedDiagnosticReported();
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor : object {
    private static string AnalyzerExceptionDiagnosticId;
    private static string DiagnosticCategory;
    private Compilation _compilation;
    private AnalyzerOptions _analyzerOptions;
    private Action`1<Diagnostic> _addDiagnostic;
    private Action`3<Exception, DiagnosticAnalyzer, Diagnostic> _onAnalyzerException;
    private AnalyzerManager _analyzerManager;
    private Func`2<DiagnosticAnalyzer, bool> _isCompilerAnalyzer;
    private Func`2<DiagnosticAnalyzer, object> _getAnalyzerGateOpt;
    private ConcurrentDictionary`2<DiagnosticAnalyzer, TimeSpan> _analyzerExecutionTimeMapOpt;
    private CancellationToken _cancellationToken;
    internal Compilation Compilation { get; }
    internal AnalyzerOptions AnalyzerOptions { get; }
    internal CancellationToken CancellationToken { get; }
    internal Action`3<Exception, DiagnosticAnalyzer, Diagnostic> OnAnalyzerException { get; }
    internal ImmutableDictionary`2<DiagnosticAnalyzer, TimeSpan> AnalyzerExecutionTimes { get; }
    private AnalyzerExecutor(Compilation compilation, AnalyzerOptions analyzerOptions, Action`1<Diagnostic> addDiagnostic, Action`3<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, Func`2<DiagnosticAnalyzer, bool> isCompilerAnalyzer, AnalyzerManager analyzerManager, Func`2<DiagnosticAnalyzer, object> getAnalyzerGateOpt, bool logExecutionTime, CancellationToken cancellationToken);
    public static AnalyzerExecutor Create(Compilation compilation, AnalyzerOptions analyzerOptions, Action`1<Diagnostic> addDiagnostic, Action`3<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, Func`2<DiagnosticAnalyzer, bool> isCompilerAnalyzer, AnalyzerManager analyzerManager, Func`2<DiagnosticAnalyzer, object> getAnalyzerGate, bool logExecutionTime, CancellationToken cancellationToken);
    public static AnalyzerExecutor CreateForSupportedDiagnostics(Action`3<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, AnalyzerManager analyzerManager, bool logExecutionTime, CancellationToken cancellationToken);
    internal Compilation get_Compilation();
    internal AnalyzerOptions get_AnalyzerOptions();
    internal CancellationToken get_CancellationToken();
    internal Action`3<Exception, DiagnosticAnalyzer, Diagnostic> get_OnAnalyzerException();
    internal ImmutableDictionary`2<DiagnosticAnalyzer, TimeSpan> get_AnalyzerExecutionTimes();
    public void ExecuteInitializeMethod(DiagnosticAnalyzer analyzer, HostSessionStartAnalysisScope sessionScope);
    public void ExecuteCompilationStartActions(ImmutableArray`1<CompilationStartAnalyzerAction> actions, HostCompilationStartAnalysisScope compilationScope);
    public void ExecuteCompilationActions(ImmutableArray`1<CompilationAnalyzerAction> compilationActions);
    public void ExecuteSymbolActions(AnalyzerActions actions, IEnumerable`1<ISymbol> symbols);
    public void ExecuteSymbolActions(ImmutableArray`1<SymbolAnalyzerAction> symbolActions, IEnumerable`1<ISymbol> symbols);
    public void ExecuteSymbolActions(ImmutableArray`1<SymbolAnalyzerAction> symbolActions, ISymbol symbol, Action`1<Diagnostic> overriddenAddDiagnostic);
    public void ExecuteSemanticModelActions(AnalyzerActions actions, SemanticModel semanticModel);
    public void ExecuteSemanticModelActions(ImmutableArray`1<SemanticModelAnalyzerAction> semanticModelActions, SemanticModel semanticModel);
    public void ExecuteSyntaxTreeActions(AnalyzerActions actions, SyntaxTree tree);
    public void ExecuteSyntaxTreeActions(ImmutableArray`1<SyntaxTreeAnalyzerAction> syntaxTreeActions, SyntaxTree tree);
    public void ExecuteSyntaxNodeActions(AnalyzerActions actions, IEnumerable`1<SyntaxNode> nodes, SemanticModel semanticModel, Func`2<SyntaxNode, TLanguageKindEnum> getKind);
    private void ExecuteSyntaxNodeAction(SyntaxNodeAnalyzerAction`1<TLanguageKindEnum> syntaxNodeAction, SyntaxNode node, SemanticModel semanticModel);
    public void ExecuteCodeBlockActions(AnalyzerActions actions, IEnumerable`1<DeclarationInfo> declarationsInNode, SemanticModel semanticModel, Func`2<SyntaxNode, TLanguageKindEnum> getKind);
    internal void ExecuteCodeBlockActions(IEnumerable`1<CodeBlockStartAnalyzerAction`1<TLanguageKindEnum>> codeBlockStartActions, IEnumerable`1<CodeBlockAnalyzerAction> codeBlockActions, IEnumerable`1<CodeBlockAnalyzerAction> codeBlockEndActions, SyntaxNode declaredNode, ISymbol declaredSymbol, ImmutableArray`1<SyntaxNode> executableCodeBlocks, SemanticModel semanticModel, Func`2<SyntaxNode, TLanguageKindEnum> getKind);
    private void ExecuteCodeBlockActions(PooledHashSet`1<CodeBlockAnalyzerAction> blockActions, SyntaxNode declaredNode, ISymbol declaredSymbol, SemanticModel semanticModel);
    internal static ImmutableDictionary`2<TLanguageKindEnum, ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>>> GetNodeActionsByKind(IEnumerable`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>> nodeActions);
    internal void ExecuteSyntaxNodeActions(IEnumerable`1<SyntaxNode> nodesToAnalyze, IDictionary`2<TLanguageKindEnum, ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>>> nodeActionsByKind, SemanticModel model, Func`2<SyntaxNode, TLanguageKindEnum> getKind);
    internal static bool CanHaveExecutableCodeBlock(ISymbol symbol);
    internal void ExecuteAndCatchIfThrows(DiagnosticAnalyzer analyzer, Action analyze);
    private void ExecuteAndCatchIfThrows_NoLock(DiagnosticAnalyzer analyzer, Action analyze);
    internal static bool IsCanceled(Exception ex, CancellationToken cancellationToken);
    internal static Diagnostic GetAnalyzerExceptionDiagnostic(DiagnosticAnalyzer analyzer, Exception e);
    internal static bool IsAnalyzerExceptionDiagnostic(Diagnostic diagnostic);
    internal static bool AreEquivalentAnalyzerExceptionDiagnostics(Diagnostic exceptionDiagnostic, Diagnostic other);
    private bool IsSupportedDiagnostic(DiagnosticAnalyzer analyzer, Diagnostic diagnostic);
}
public class Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference : AnalyzerReference {
    private string _fullPath;
    private IAnalyzerAssemblyLoader _assemblyLoader;
    private string _lazyDisplay;
    private object _lazyIdentity;
    private ImmutableArray`1<DiagnosticAnalyzer> _lazyAllAnalyzers;
    private ImmutableDictionary`2<string, ImmutableArray`1<DiagnosticAnalyzer>> _lazyAnalyzersPerLanguage;
    private Assembly _lazyAssembly;
    private static string s_diagnosticNamespaceName;
    private ImmutableDictionary`2<string, ImmutableHashSet`1<string>> _lazyAnalyzerTypeNameMap;
    [CompilerGeneratedAttribute]
private EventHandler`1<AnalyzerLoadFailureEventArgs> AnalyzerLoadFailed;
    public string FullPath { get; }
    public string Display { get; }
    public object Id { get; }
    public AnalyzerFileReference(string fullPath, IAnalyzerAssemblyLoader assemblyLoader);
    private static AnalyzerFileReference();
    [CompilerGeneratedAttribute]
public void add_AnalyzerLoadFailed(EventHandler`1<AnalyzerLoadFailureEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AnalyzerLoadFailed(EventHandler`1<AnalyzerLoadFailureEventArgs> value);
    public virtual ImmutableArray`1<DiagnosticAnalyzer> GetAnalyzersForAllLanguages();
    private static ImmutableArray`1<DiagnosticAnalyzer> CreateAnalyzersForAllLanguages(AnalyzerFileReference reference);
    public virtual ImmutableArray`1<DiagnosticAnalyzer> GetAnalyzers(string language);
    private static ImmutableArray`1<DiagnosticAnalyzer> CreateLanguageSpecificAnalyzers(string language, AnalyzerFileReference reference);
    public virtual string get_FullPath();
    public virtual string get_Display();
    public virtual object get_Id();
    private void InitializeDisplayAndId();
    internal void AddAnalyzers(Builder<string, ImmutableArray`1<DiagnosticAnalyzer>> builder);
    internal void AddAnalyzers(Builder<DiagnosticAnalyzer> builder, string language);
    private IEnumerable`1<DiagnosticAnalyzer> GetLanguageSpecificAnalyzers(Assembly analyzerAssembly, ImmutableDictionary`2<string, ImmutableHashSet`1<string>> analyzerTypeNameMap, string language, Boolean& reportedError);
    private static IEnumerable`1<string> GetLanguageSpecificAnalyzerTypeNames(ImmutableDictionary`2<string, ImmutableHashSet`1<string>> analyzerTypeNameMap, string language);
    private IEnumerable`1<DiagnosticAnalyzer> GetAnalyzersForTypeNames(Assembly analyzerAssembly, IEnumerable`1<string> analyzerTypeNames, Boolean& reportedError);
    internal ImmutableDictionary`2<string, ImmutableHashSet`1<string>> GetAnalyzerTypeNameMap();
    private static ImmutableDictionary`2<string, ImmutableHashSet`1<string>> GetAnalyzerTypeNameMap(string fullPath);
    private static IEnumerable`1<string> GetSupportedLanguages(TypeDefinition typeDef, PEModule peModule);
    private static IEnumerable`1<string> GetSupportedLanguages(PEModule peModule, CustomAttributeHandle customAttrHandle);
    private static bool IsDiagnosticAnalyzerAttribute(PEModule peModule, CustomAttributeHandle customAttrHandle);
    private static string GetFullyQualifiedTypeName(TypeDefinition typeDef, PEModule peModule);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AnalyzerReference other);
    public virtual int GetHashCode();
    public Assembly GetAssembly();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.Diagnostics.AnalyzerImageReference : AnalyzerReference {
    private ImmutableArray`1<DiagnosticAnalyzer> _analyzers;
    private string _fullPath;
    private string _display;
    private string _id;
    public string FullPath { get; }
    public string Display { get; }
    public object Id { get; }
    public AnalyzerImageReference(ImmutableArray`1<DiagnosticAnalyzer> analyzers, string fullPath, string display);
    public virtual ImmutableArray`1<DiagnosticAnalyzer> GetAnalyzersForAllLanguages();
    public virtual ImmutableArray`1<DiagnosticAnalyzer> GetAnalyzers(string language);
    public virtual string get_FullPath();
    public virtual string get_Display();
    public virtual object get_Id();
    private string GetDebuggerDisplay();
}
public class Microsoft.CodeAnalysis.Diagnostics.AnalyzerLoadFailureEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private FailureErrorCode <ErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public string TypeName { get; }
    public string Message { get; }
    public FailureErrorCode ErrorCode { get; }
    public Exception Exception { get; }
    public AnalyzerLoadFailureEventArgs(FailureErrorCode errorCode, string message, Exception exceptionOpt, string typeNameOpt);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public FailureErrorCode get_ErrorCode();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager : object {
    public static AnalyzerManager Instance;
    private ConcurrentDictionary`2<DiagnosticAnalyzer, Task`1<HostSessionStartAnalysisScope>> _sessionScopeMap;
    private ConcurrentDictionary`2<AnalyzerAndOptions, ConditionalWeakTable`2<Compilation, Task`1<HostCompilationStartAnalysisScope>>> _compilationScopeMap;
    private ConcurrentDictionary`2<DiagnosticAnalyzer, Tuple`2<ImmutableArray`1<DiagnosticDescriptor>, EventHandler`1<Exception>>> _descriptorCache;
    private static AnalyzerManager();
    private Task`1<HostCompilationStartAnalysisScope> GetCompilationAnalysisScopeCoreAsync(AnalyzerAndOptions analyzerAndOptions, HostSessionStartAnalysisScope sessionScope, AnalyzerExecutor analyzerExecutor);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager/<GetCompilationAnalysisScopeAsync>d__5")]
private Task`1<HostCompilationStartAnalysisScope> GetCompilationAnalysisScopeAsync(DiagnosticAnalyzer analyzer, HostSessionStartAnalysisScope sessionScope, AnalyzerExecutor analyzerExecutor);
    private Task`1<HostSessionStartAnalysisScope> GetSessionAnalysisScopeCoreAsync(DiagnosticAnalyzer analyzer, AnalyzerExecutor analyzerExecutor);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager/<GetSessionAnalysisScopeAsync>d__7")]
private Task`1<HostSessionStartAnalysisScope> GetSessionAnalysisScopeAsync(DiagnosticAnalyzer analyzer, AnalyzerExecutor analyzerExecutor);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager/<GetAnalyzerActionsAsync>d__8")]
public Task`1<AnalyzerActions> GetAnalyzerActionsAsync(DiagnosticAnalyzer analyzer, AnalyzerExecutor analyzerExecutor);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager/<GetAnalyzerHasDependentCompilationEndAsync>d__9")]
public Task`1<bool> GetAnalyzerHasDependentCompilationEndAsync(DiagnosticAnalyzer analyzer, AnalyzerExecutor analyzerExecutor);
    public ImmutableArray`1<DiagnosticDescriptor> GetSupportedDiagnosticDescriptors(DiagnosticAnalyzer analyzer, AnalyzerExecutor analyzerExecutor);
    internal void ClearAnalyzerState(ImmutableArray`1<DiagnosticAnalyzer> analyzers);
    private void ClearDescriptorState(DiagnosticAnalyzer analyzer);
    private void ClearAnalysisScopeState(DiagnosticAnalyzer analyzer);
    internal bool IsSupportedDiagnostic(DiagnosticAnalyzer analyzer, Diagnostic diagnostic, Func`2<DiagnosticAnalyzer, bool> isCompilerAnalyzer, AnalyzerExecutor analyzerExecutor);
    internal bool IsDiagnosticAnalyzerSuppressed(DiagnosticAnalyzer analyzer, CompilationOptions options, Func`2<DiagnosticAnalyzer, bool> isCompilerAnalyzer, AnalyzerExecutor analyzerExecutor);
    internal static bool HasNotConfigurableTag(IEnumerable`1<string> customTags);
}
public class Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions : object {
    internal static AnalyzerOptions Empty;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<AdditionalText> <AdditionalFiles>k__BackingField;
    public ImmutableArray`1<AdditionalText> AdditionalFiles { get; }
    public AnalyzerOptions(ImmutableArray`1<AdditionalText> additionalFiles);
    private static AnalyzerOptions();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<AdditionalText> get_AdditionalFiles();
    public AnalyzerOptions WithAdditionalFiles(ImmutableArray`1<AdditionalText> additionalFiles);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference : object {
    public string FullPath { get; }
    public string Display { get; }
    public object Id { get; }
    public abstract virtual string get_FullPath();
    public virtual string get_Display();
    public abstract virtual object get_Id();
    public abstract virtual ImmutableArray`1<DiagnosticAnalyzer> GetAnalyzersForAllLanguages();
    public abstract virtual ImmutableArray`1<DiagnosticAnalyzer> GetAnalyzers(string language);
}
internal class Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1 : object {
    private TaskCompletionSource`1<bool> _whenCompleted;
    private Queue`1<TElement> _data;
    private Queue`1<TaskCompletionSource`1<TElement>> _waiters;
    private bool _completed;
    private object SyncObject { get; }
    public int Count { get; }
    public bool IsCompleted { get; }
    public Task WhenCompletedTask { get; }
    private object get_SyncObject();
    public int get_Count();
    public void Enqueue(TElement value);
    public bool TryEnqueue(TElement value);
    private bool EnqueueCore(TElement value);
    public bool TryDequeue(TElement& d);
    public bool get_IsCompleted();
    public void Complete();
    public bool TryComplete();
    private bool CompleteCore();
    public Task get_WhenCompletedTask();
    public Task`1<TElement> DequeueAsync(CancellationToken cancellationToken);
    private static Task`1<T> WithCancellation(Task`1<T> task, CancellationToken cancellationToken);
    private Task`1<TElement> DequeueAsyncCore();
}
public class Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext : ValueType {
    private SyntaxNode _codeBlock;
    private ISymbol _owningSymbol;
    private SemanticModel _semanticModel;
    private AnalyzerOptions _options;
    private Action`1<Diagnostic> _reportDiagnostic;
    private Func`2<Diagnostic, bool> _isSupportedDiagnostic;
    private CancellationToken _cancellationToken;
    public SyntaxNode CodeBlock { get; }
    public ISymbol OwningSymbol { get; }
    public SemanticModel SemanticModel { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    public CodeBlockAnalysisContext(SyntaxNode codeBlock, ISymbol owningSymbol, SemanticModel semanticModel, AnalyzerOptions options, Action`1<Diagnostic> reportDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);
    public SyntaxNode get_CodeBlock();
    public ISymbol get_OwningSymbol();
    public SemanticModel get_SemanticModel();
    public AnalyzerOptions get_Options();
    public CancellationToken get_CancellationToken();
    public void ReportDiagnostic(Diagnostic diagnostic);
}
internal class Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalyzerAction : AnalyzerAction {
    private Action`1<CodeBlockAnalysisContext> _action;
    public Action`1<CodeBlockAnalysisContext> Action { get; }
    public CodeBlockAnalyzerAction(Action`1<CodeBlockAnalysisContext> action, DiagnosticAnalyzer analyzer);
    public Action`1<CodeBlockAnalysisContext> get_Action();
}
public abstract class Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext`1 : object {
    private SyntaxNode _codeBlock;
    private ISymbol _owningSymbol;
    private SemanticModel _semanticModel;
    private AnalyzerOptions _options;
    private CancellationToken _cancellationToken;
    public SyntaxNode CodeBlock { get; }
    public ISymbol OwningSymbol { get; }
    public SemanticModel SemanticModel { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    protected CodeBlockStartAnalysisContext`1(SyntaxNode codeBlock, ISymbol owningSymbol, SemanticModel semanticModel, AnalyzerOptions options, CancellationToken cancellationToken);
    public SyntaxNode get_CodeBlock();
    public ISymbol get_OwningSymbol();
    public SemanticModel get_SemanticModel();
    public AnalyzerOptions get_Options();
    public CancellationToken get_CancellationToken();
    public abstract virtual void RegisterCodeBlockEndAction(Action`1<CodeBlockAnalysisContext> action);
    public void RegisterSyntaxNodeAction(Action`1<SyntaxNodeAnalysisContext> action, TLanguageKindEnum[] syntaxKinds);
    public abstract virtual void RegisterSyntaxNodeAction(Action`1<SyntaxNodeAnalysisContext> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
}
internal class Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalyzerAction`1 : AnalyzerAction {
    private Action`1<CodeBlockStartAnalysisContext`1<TLanguageKindEnum>> _action;
    public Action`1<CodeBlockStartAnalysisContext`1<TLanguageKindEnum>> Action { get; }
    public CodeBlockStartAnalyzerAction`1(Action`1<CodeBlockStartAnalysisContext`1<TLanguageKindEnum>> action, DiagnosticAnalyzer analyzer);
    public Action`1<CodeBlockStartAnalysisContext`1<TLanguageKindEnum>> get_Action();
}
public class Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisContext : ValueType {
    private Compilation _compilation;
    private AnalyzerOptions _options;
    private Action`1<Diagnostic> _reportDiagnostic;
    private Func`2<Diagnostic, bool> _isSupportedDiagnostic;
    private CancellationToken _cancellationToken;
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    public CompilationAnalysisContext(Compilation compilation, AnalyzerOptions options, Action`1<Diagnostic> reportDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);
    public Compilation get_Compilation();
    public AnalyzerOptions get_Options();
    public CancellationToken get_CancellationToken();
    public void ReportDiagnostic(Diagnostic diagnostic);
}
internal class Microsoft.CodeAnalysis.Diagnostics.CompilationAnalyzerAction : AnalyzerAction {
    private Action`1<CompilationAnalysisContext> _action;
    public Action`1<CompilationAnalysisContext> Action { get; }
    public CompilationAnalyzerAction(Action`1<CompilationAnalysisContext> action, DiagnosticAnalyzer analyzer);
    public Action`1<CompilationAnalysisContext> get_Action();
}
internal class Microsoft.CodeAnalysis.Diagnostics.CompilationCompletedEvent : CompilationEvent {
    public CompilationCompletedEvent(Compilation compilation);
    public virtual string ToString();
}
internal abstract class Microsoft.CodeAnalysis.Diagnostics.CompilationEvent : object {
    [CompilerGeneratedAttribute]
private Compilation <Compilation>k__BackingField;
    public Compilation Compilation { get; }
    internal CompilationEvent(Compilation compilation);
    [CompilerGeneratedAttribute]
public Compilation get_Compilation();
    public virtual void FlushCache();
}
public abstract class Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext : object {
    private Compilation _compilation;
    private AnalyzerOptions _options;
    private CancellationToken _cancellationToken;
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    protected CompilationStartAnalysisContext(Compilation compilation, AnalyzerOptions options, CancellationToken cancellationToken);
    public Compilation get_Compilation();
    public AnalyzerOptions get_Options();
    public CancellationToken get_CancellationToken();
    public abstract virtual void RegisterCompilationEndAction(Action`1<CompilationAnalysisContext> action);
    public abstract virtual void RegisterSemanticModelAction(Action`1<SemanticModelAnalysisContext> action);
    public void RegisterSymbolAction(Action`1<SymbolAnalysisContext> action, SymbolKind[] symbolKinds);
    public abstract virtual void RegisterSymbolAction(Action`1<SymbolAnalysisContext> action, ImmutableArray`1<SymbolKind> symbolKinds);
    public abstract virtual void RegisterCodeBlockStartAction(Action`1<CodeBlockStartAnalysisContext`1<TLanguageKindEnum>> action);
    public abstract virtual void RegisterCodeBlockAction(Action`1<CodeBlockAnalysisContext> action);
    public abstract virtual void RegisterSyntaxTreeAction(Action`1<SyntaxTreeAnalysisContext> action);
    public void RegisterSyntaxNodeAction(Action`1<SyntaxNodeAnalysisContext> action, TLanguageKindEnum[] syntaxKinds);
    public abstract virtual void RegisterSyntaxNodeAction(Action`1<SyntaxNodeAnalysisContext> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
}
internal class Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalyzerAction : AnalyzerAction {
    private Action`1<CompilationStartAnalysisContext> _action;
    public Action`1<CompilationStartAnalysisContext> Action { get; }
    public CompilationStartAnalyzerAction(Action`1<CompilationStartAnalysisContext> action, DiagnosticAnalyzer analyzer);
    public Action`1<CompilationStartAnalysisContext> get_Action();
}
internal class Microsoft.CodeAnalysis.Diagnostics.CompilationStartedEvent : CompilationEvent {
    public CompilationStartedEvent(Compilation compilation);
    public virtual string ToString();
}
internal class Microsoft.CodeAnalysis.Diagnostics.CompilationUnitCompletedEvent : CompilationEvent {
    private WeakReference`1<SemanticModel> _weakModel;
    [CompilerGeneratedAttribute]
private SyntaxTree <CompilationUnit>k__BackingField;
    public SemanticModel SemanticModel { get; private set; }
    public SyntaxTree CompilationUnit { get; }
    public CompilationUnitCompletedEvent(Compilation compilation, SyntaxTree compilationUnit);
    public SemanticModel get_SemanticModel();
    private void set_SemanticModel(SemanticModel value);
    public virtual void FlushCache();
    [CompilerGeneratedAttribute]
public SyntaxTree get_CompilationUnit();
    public virtual string ToString();
}
public class Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers : object {
    private AnalyzerDriver _driver;
    private Compilation _compilation;
    private CancellationToken _cancellationToken;
    private ConcurrentSet`1<Diagnostic> _exceptionDiagnostics;
    public Compilation Compilation { get; }
    public CompilationWithAnalyzers(Compilation compilation, ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerOptions options, CancellationToken cancellationToken);
    public Compilation get_Compilation();
    private static void VerifyAnalyzersArgument(ImmutableArray`1<DiagnosticAnalyzer> analyzers);
    private void AddExceptionDiagnostic(Diagnostic diagnostic);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAnalyzerDiagnosticsAsync>d__9")]
public Task`1<ImmutableArray`1<Diagnostic>> GetAnalyzerDiagnosticsAsync();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAllDiagnosticsAsync>d__10")]
public Task`1<ImmutableArray`1<Diagnostic>> GetAllDiagnosticsAsync();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetEffectiveDiagnostics>d__11")]
public static IEnumerable`1<Diagnostic> GetEffectiveDiagnostics(IEnumerable`1<Diagnostic> diagnostics, Compilation compilation);
    public static bool IsDiagnosticAnalyzerSuppressed(DiagnosticAnalyzer analyzer, CompilationOptions options, Action`3<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException);
    public static void ClearAnalyzerState(ImmutableArray`1<DiagnosticAnalyzer> analyzers);
}
internal abstract class Microsoft.CodeAnalysis.Diagnostics.CompilerDiagnosticAnalyzer : DiagnosticAnalyzer {
    private static string Origin;
    private static string Syntactic;
    private static string Declaration;
    private static ImmutableDictionary`2<string, string> s_syntactic;
    private static ImmutableDictionary`2<string, string> s_declaration;
    internal CommonMessageProvider MessageProvider { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CompilerDiagnosticAnalyzer();
    internal abstract virtual CommonMessageProvider get_MessageProvider();
    internal abstract virtual ImmutableArray`1<int> GetSupportedErrorCodes();
    public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalysisContextHelpers : object {
    internal static void VerifyArguments(Action`1<TContext> action);
    internal static void VerifyArguments(Action`1<TContext> action, ImmutableArray`1<SymbolKind> symbolKinds);
    internal static void VerifyArguments(Action`1<TContext> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
    internal static void VerifyArguments(Diagnostic diagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic);
    private static void VerifyAction(Action`1<TContext> action);
    private static void VerifySymbolKinds(ImmutableArray`1<SymbolKind> symbolKinds);
    private static void VerifySyntaxKinds(ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
}
public abstract class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer : object {
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public abstract virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public abstract virtual void Initialize(AnalysisContext context);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual string ToString();
}
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Languages>k__BackingField;
    public String[] Languages { get; }
    public DiagnosticAnalyzerAttribute(string firstLanguage, String[] additionalLanguages);
    [CompilerGeneratedAttribute]
public String[] get_Languages();
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerExtensions : object {
    [ExtensionAttribute]
public static CompilationWithAnalyzers WithAnalyzers(Compilation compilation, ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerOptions options, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Diagnostics.HostAnalysisScope : object {
    private ImmutableArray`1<CompilationAnalyzerAction> _compilationActions;
    private ImmutableArray`1<CompilationAnalyzerAction> _compilationEndActions;
    private ImmutableArray`1<SemanticModelAnalyzerAction> _semanticModelActions;
    private ImmutableArray`1<SyntaxTreeAnalyzerAction> _syntaxTreeActions;
    private ImmutableArray`1<SymbolAnalyzerAction> _symbolActions;
    private ImmutableArray`1<AnalyzerAction> _codeBlockStartActions;
    private ImmutableArray`1<CodeBlockAnalyzerAction> _codeBlockEndActions;
    private ImmutableArray`1<CodeBlockAnalyzerAction> _codeBlockActions;
    private ImmutableArray`1<AnalyzerAction> _syntaxNodeActions;
    private Dictionary`2<DiagnosticAnalyzer, AnalyzerActions> _analyzerActions;
    public ImmutableArray`1<CompilationAnalyzerAction> CompilationActions { get; }
    public ImmutableArray`1<CompilationAnalyzerAction> CompilationEndActions { get; }
    public ImmutableArray`1<SemanticModelAnalyzerAction> SemanticModelActions { get; }
    public ImmutableArray`1<SyntaxTreeAnalyzerAction> SyntaxTreeActions { get; }
    public ImmutableArray`1<SymbolAnalyzerAction> SymbolActions { get; }
    public ImmutableArray`1<CodeBlockAnalyzerAction> CodeBlockEndActions { get; }
    public ImmutableArray`1<CodeBlockAnalyzerAction> CodeBlockActions { get; }
    public bool HasCodeBlockEndActions { get; }
    public bool HasCodeBlockActions { get; }
    public ImmutableArray`1<CompilationAnalyzerAction> get_CompilationActions();
    public virtual ImmutableArray`1<CompilationAnalyzerAction> get_CompilationEndActions();
    public virtual ImmutableArray`1<SemanticModelAnalyzerAction> get_SemanticModelActions();
    public virtual ImmutableArray`1<SyntaxTreeAnalyzerAction> get_SyntaxTreeActions();
    public virtual ImmutableArray`1<SymbolAnalyzerAction> get_SymbolActions();
    public virtual ImmutableArray`1<CodeBlockAnalyzerAction> get_CodeBlockEndActions();
    public virtual ImmutableArray`1<CodeBlockAnalyzerAction> get_CodeBlockActions();
    public virtual bool get_HasCodeBlockEndActions();
    public virtual bool get_HasCodeBlockActions();
    public virtual bool HasCodeBlockStartActions();
    public virtual ImmutableArray`1<CodeBlockStartAnalyzerAction`1<TLanguageKindEnum>> GetCodeBlockStartActions();
    public virtual ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>> GetSyntaxNodeActions();
    public virtual AnalyzerActions GetAnalyzerActions(DiagnosticAnalyzer analyzer);
    public void RegisterCompilationAction(DiagnosticAnalyzer analyzer, Action`1<CompilationAnalysisContext> action);
    public void RegisterCompilationEndAction(DiagnosticAnalyzer analyzer, Action`1<CompilationAnalysisContext> action);
    public void RegisterSemanticModelAction(DiagnosticAnalyzer analyzer, Action`1<SemanticModelAnalysisContext> action);
    public void RegisterSyntaxTreeAction(DiagnosticAnalyzer analyzer, Action`1<SyntaxTreeAnalysisContext> action);
    public void RegisterSymbolAction(DiagnosticAnalyzer analyzer, Action`1<SymbolAnalysisContext> action, ImmutableArray`1<SymbolKind> symbolKinds);
    public void RegisterCodeBlockStartAction(DiagnosticAnalyzer analyzer, Action`1<CodeBlockStartAnalysisContext`1<TLanguageKindEnum>> action);
    public void RegisterCodeBlockEndAction(DiagnosticAnalyzer analyzer, Action`1<CodeBlockAnalysisContext> action);
    public void RegisterCodeBlockAction(DiagnosticAnalyzer analyzer, Action`1<CodeBlockAnalysisContext> action);
    public void RegisterSyntaxNodeAction(DiagnosticAnalyzer analyzer, Action`1<SyntaxNodeAnalysisContext> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
    protected AnalyzerActions GetOrCreateAnalyzerActions(DiagnosticAnalyzer analyzer);
}
internal class Microsoft.CodeAnalysis.Diagnostics.HostCodeBlockStartAnalysisScope`1 : object {
    private ImmutableArray`1<CodeBlockAnalyzerAction> _codeBlockEndActions;
    private ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>> _syntaxNodeActions;
    public ImmutableArray`1<CodeBlockAnalyzerAction> CodeBlockEndActions { get; }
    public ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>> SyntaxNodeActions { get; }
    public ImmutableArray`1<CodeBlockAnalyzerAction> get_CodeBlockEndActions();
    public ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>> get_SyntaxNodeActions();
    public void RegisterCodeBlockEndAction(DiagnosticAnalyzer analyzer, Action`1<CodeBlockAnalysisContext> action);
    public void RegisterSyntaxNodeAction(DiagnosticAnalyzer analyzer, Action`1<SyntaxNodeAnalysisContext> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
}
internal class Microsoft.CodeAnalysis.Diagnostics.HostCompilationStartAnalysisScope : HostAnalysisScope {
    private HostSessionStartAnalysisScope _sessionScope;
    public ImmutableArray`1<CompilationAnalyzerAction> CompilationEndActions { get; }
    public ImmutableArray`1<SemanticModelAnalyzerAction> SemanticModelActions { get; }
    public ImmutableArray`1<SyntaxTreeAnalyzerAction> SyntaxTreeActions { get; }
    public ImmutableArray`1<SymbolAnalyzerAction> SymbolActions { get; }
    public ImmutableArray`1<CodeBlockAnalyzerAction> CodeBlockEndActions { get; }
    public ImmutableArray`1<CodeBlockAnalyzerAction> CodeBlockActions { get; }
    public bool HasCodeBlockEndActions { get; }
    public bool HasCodeBlockActions { get; }
    public HostCompilationStartAnalysisScope(HostSessionStartAnalysisScope sessionScope);
    public virtual ImmutableArray`1<CompilationAnalyzerAction> get_CompilationEndActions();
    public virtual ImmutableArray`1<SemanticModelAnalyzerAction> get_SemanticModelActions();
    public virtual ImmutableArray`1<SyntaxTreeAnalyzerAction> get_SyntaxTreeActions();
    public virtual ImmutableArray`1<SymbolAnalyzerAction> get_SymbolActions();
    public virtual ImmutableArray`1<CodeBlockAnalyzerAction> get_CodeBlockEndActions();
    public virtual ImmutableArray`1<CodeBlockAnalyzerAction> get_CodeBlockActions();
    public virtual bool get_HasCodeBlockEndActions();
    public virtual bool get_HasCodeBlockActions();
    public virtual bool HasCodeBlockStartActions();
    public virtual ImmutableArray`1<CodeBlockStartAnalyzerAction`1<TLanguageKindEnum>> GetCodeBlockStartActions();
    public virtual ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>> GetSyntaxNodeActions();
    public virtual AnalyzerActions GetAnalyzerActions(DiagnosticAnalyzer analyzer);
    public AnalyzerActions GetCompilationOnlyAnalyzerActions(DiagnosticAnalyzer analyzer);
}
internal class Microsoft.CodeAnalysis.Diagnostics.HostSessionStartAnalysisScope : HostAnalysisScope {
    private ImmutableArray`1<CompilationStartAnalyzerAction> _compilationStartActions;
    public ImmutableArray`1<CompilationStartAnalyzerAction> CompilationStartActions { get; }
    public ImmutableArray`1<CompilationStartAnalyzerAction> get_CompilationStartActions();
    public void RegisterCompilationStartAction(DiagnosticAnalyzer analyzer, Action`1<CompilationStartAnalysisContext> action);
}
public class Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext : ValueType {
    private SemanticModel _semanticModel;
    private AnalyzerOptions _options;
    private Action`1<Diagnostic> _reportDiagnostic;
    private Func`2<Diagnostic, bool> _isSupportedDiagnostic;
    private CancellationToken _cancellationToken;
    public SemanticModel SemanticModel { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    public SemanticModelAnalysisContext(SemanticModel semanticModel, AnalyzerOptions options, Action`1<Diagnostic> reportDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);
    public SemanticModel get_SemanticModel();
    public AnalyzerOptions get_Options();
    public CancellationToken get_CancellationToken();
    public void ReportDiagnostic(Diagnostic diagnostic);
}
internal class Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalyzerAction : AnalyzerAction {
    private Action`1<SemanticModelAnalysisContext> _action;
    public Action`1<SemanticModelAnalysisContext> Action { get; }
    public SemanticModelAnalyzerAction(Action`1<SemanticModelAnalysisContext> action, DiagnosticAnalyzer analyzer);
    public Action`1<SemanticModelAnalysisContext> get_Action();
}
internal class Microsoft.CodeAnalysis.Diagnostics.SuppressMessageAttributeState : object {
    private static SmallDictionary`2<string, TargetScope> s_suppressMessageScopeTypes;
    private Compilation _compilation;
    private GlobalSuppressions _lazyGlobalSuppressions;
    private ConcurrentDictionary`2<ISymbol, ImmutableArray`1<string>> _localSuppressionsBySymbol;
    private ISymbol _lazySuppressMessageAttribute;
    private static string s_suppressionPrefix;
    private ISymbol SuppressMessageAttribute { get; }
    public SuppressMessageAttributeState(Compilation compilation);
    private static SuppressMessageAttributeState();
    public bool IsDiagnosticSuppressed(Diagnostic diagnostic, ISymbol symbolOpt);
    private bool IsDiagnosticSuppressed(string id, ISymbol symbol);
    private bool IsDiagnosticSuppressed(string id, Location location);
    private bool IsDiagnosticGloballySuppressed(string id, ISymbol symbolOpt);
    private bool IsDiagnosticLocallySuppressed(string id, ISymbol symbol);
    private ISymbol get_SuppressMessageAttribute();
    private void DecodeGlobalSuppressMessageAttributes();
    private ImmutableArray`1<string> DecodeSuppressMessageAttributes(ISymbol symbol);
    private static void DecodeGlobalSuppressMessageAttributes(Compilation compilation, ISymbol symbol, ISymbol suppressMessageAttribute, GlobalSuppressions globalSuppressions);
    internal static IEnumerable`1<ISymbol> ResolveTargetSymbols(Compilation compilation, string target, TargetScope scope);
    private static bool TryDecodeSuppressMessageAttributeData(AttributeData attribute, SuppressMessageInfo& info);
    [CompilerGeneratedAttribute]
private bool <DecodeSuppressMessageAttributes>b__15_0(AttributeData a);
}
public class Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext : ValueType {
    private ISymbol _symbol;
    private Compilation _compilation;
    private AnalyzerOptions _options;
    private Action`1<Diagnostic> _reportDiagnostic;
    private Func`2<Diagnostic, bool> _isSupportedDiagnostic;
    private CancellationToken _cancellationToken;
    public ISymbol Symbol { get; }
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    public SymbolAnalysisContext(ISymbol symbol, Compilation compilation, AnalyzerOptions options, Action`1<Diagnostic> reportDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);
    public ISymbol get_Symbol();
    public Compilation get_Compilation();
    public AnalyzerOptions get_Options();
    public CancellationToken get_CancellationToken();
    public void ReportDiagnostic(Diagnostic diagnostic);
}
internal class Microsoft.CodeAnalysis.Diagnostics.SymbolAnalyzerAction : AnalyzerAction {
    private Action`1<SymbolAnalysisContext> _action;
    private ImmutableArray`1<SymbolKind> _kinds;
    public Action`1<SymbolAnalysisContext> Action { get; }
    public ImmutableArray`1<SymbolKind> Kinds { get; }
    public SymbolAnalyzerAction(Action`1<SymbolAnalysisContext> action, ImmutableArray`1<SymbolKind> kinds, DiagnosticAnalyzer analyzer);
    public Action`1<SymbolAnalysisContext> get_Action();
    public ImmutableArray`1<SymbolKind> get_Kinds();
}
internal class Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent : CompilationEvent {
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    private Lazy`1<SemanticModel> _lazySemanticModel;
    private SemanticModel _semanticModel;
    private WeakReference`1<SemanticModel> _weakModel;
    private object _gate;
    private static SymbolDisplayFormat s_displayFormat;
    public ISymbol Symbol { get; }
    public SymbolDeclaredCompilationEvent(Compilation compilation, ISymbol symbol);
    public SymbolDeclaredCompilationEvent(Compilation compilation, ISymbol symbol, Lazy`1<SemanticModel> lazySemanticModel);
    private static SymbolDeclaredCompilationEvent();
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    public SemanticModel SemanticModel(SyntaxReference reference);
    public virtual void FlushCache();
    public virtual string ToString();
}
public class Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext : ValueType {
    private SyntaxNode _node;
    private SemanticModel _semanticModel;
    private AnalyzerOptions _options;
    private Action`1<Diagnostic> _reportDiagnostic;
    private Func`2<Diagnostic, bool> _isSupportedDiagnostic;
    private CancellationToken _cancellationToken;
    public SyntaxNode Node { get; }
    public SemanticModel SemanticModel { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    public SyntaxNodeAnalysisContext(SyntaxNode node, SemanticModel semanticModel, AnalyzerOptions options, Action`1<Diagnostic> reportDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);
    public SyntaxNode get_Node();
    public SemanticModel get_SemanticModel();
    public AnalyzerOptions get_Options();
    public CancellationToken get_CancellationToken();
    public void ReportDiagnostic(Diagnostic diagnostic);
}
internal class Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalyzerAction`1 : AnalyzerAction {
    private Action`1<SyntaxNodeAnalysisContext> _action;
    private ImmutableArray`1<TLanguageKindEnum> _kinds;
    public Action`1<SyntaxNodeAnalysisContext> Action { get; }
    public ImmutableArray`1<TLanguageKindEnum> Kinds { get; }
    public SyntaxNodeAnalyzerAction`1(Action`1<SyntaxNodeAnalysisContext> action, ImmutableArray`1<TLanguageKindEnum> kinds, DiagnosticAnalyzer analyzer);
    public Action`1<SyntaxNodeAnalysisContext> get_Action();
    public ImmutableArray`1<TLanguageKindEnum> get_Kinds();
}
public class Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext : ValueType {
    private SyntaxTree _tree;
    private AnalyzerOptions _options;
    private Action`1<Diagnostic> _reportDiagnostic;
    private Func`2<Diagnostic, bool> _isSupportedDiagnostic;
    private CancellationToken _cancellationToken;
    public SyntaxTree Tree { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    public SyntaxTreeAnalysisContext(SyntaxTree tree, AnalyzerOptions options, Action`1<Diagnostic> reportDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);
    public SyntaxTree get_Tree();
    public AnalyzerOptions get_Options();
    public CancellationToken get_CancellationToken();
    public void ReportDiagnostic(Diagnostic diagnostic);
}
internal class Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalyzerAction : AnalyzerAction {
    private Action`1<SyntaxTreeAnalysisContext> _action;
    public Action`1<SyntaxTreeAnalysisContext> Action { get; }
    public SyntaxTreeAnalyzerAction(Action`1<SyntaxTreeAnalysisContext> action, DiagnosticAnalyzer analyzer);
    public Action`1<SyntaxTreeAnalysisContext> get_Action();
}
public class Microsoft.CodeAnalysis.Diagnostics.UnresolvedAnalyzerReference : AnalyzerReference {
    private string _unresolvedPath;
    public string Display { get; }
    public string FullPath { get; }
    public object Id { get; }
    public UnresolvedAnalyzerReference(string unresolvedPath);
    public virtual string get_Display();
    public virtual string get_FullPath();
    public virtual object get_Id();
    public virtual ImmutableArray`1<DiagnosticAnalyzer> GetAnalyzersForAllLanguages();
    public virtual ImmutableArray`1<DiagnosticAnalyzer> GetAnalyzers(string language);
}
public enum Microsoft.CodeAnalysis.DiagnosticSeverity : Enum {
    public int value__;
    public static DiagnosticSeverity Hidden;
    public static DiagnosticSeverity Info;
    public static DiagnosticSeverity Warning;
    public static DiagnosticSeverity Error;
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.DiagnosticWithInfo : Diagnostic {
    private DiagnosticInfo _info;
    private Location _location;
    public Location Location { get; }
    public IReadOnlyList`1<Location> AdditionalLocations { get; }
    internal IReadOnlyList`1<string> CustomTags { get; }
    public DiagnosticDescriptor Descriptor { get; }
    public string Id { get; }
    internal string Category { get; }
    internal int Code { get; }
    public DiagnosticSeverity Severity { get; }
    public DiagnosticSeverity DefaultSeverity { get; }
    internal bool IsEnabledByDefault { get; }
    public int WarningLevel { get; }
    internal IReadOnlyList`1<object> Arguments { get; }
    public DiagnosticInfo Info { get; }
    internal bool HasLazyInfo { get; }
    internal DiagnosticWithInfo(DiagnosticInfo info, Location location);
    public virtual Location get_Location();
    public virtual IReadOnlyList`1<Location> get_AdditionalLocations();
    internal virtual IReadOnlyList`1<string> get_CustomTags();
    public virtual DiagnosticDescriptor get_Descriptor();
    public virtual string get_Id();
    internal virtual string get_Category();
    internal sealed virtual int get_Code();
    public sealed virtual DiagnosticSeverity get_Severity();
    public sealed virtual DiagnosticSeverity get_DefaultSeverity();
    internal sealed virtual bool get_IsEnabledByDefault();
    public sealed virtual int get_WarningLevel();
    public virtual string GetMessage(IFormatProvider formatProvider);
    internal virtual IReadOnlyList`1<object> get_Arguments();
    public DiagnosticInfo get_Info();
    internal bool get_HasLazyInfo();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual bool Equals(Diagnostic obj);
    private string GetDebuggerDisplay();
    internal virtual Diagnostic WithLocation(Location location);
    internal virtual Diagnostic WithSeverity(DiagnosticSeverity severity);
    internal sealed virtual bool IsNotConfigurable();
}
public class Microsoft.CodeAnalysis.DllImportData : object {
    private string _moduleName;
    private string _entryPointName;
    private PInvokeAttributes _flags;
    public string ModuleName { get; }
    public string EntryPointName { get; }
    private PInvokeAttributes Microsoft.Cci.IPlatformInvokeInformation.Flags { get; }
    public bool ExactSpelling { get; }
    public CharSet CharacterSet { get; }
    public bool SetLastError { get; }
    public CallingConvention CallingConvention { get; }
    public Nullable`1<bool> BestFitMapping { get; }
    public Nullable`1<bool> ThrowOnUnmappableCharacter { get; }
    internal DllImportData(string moduleName, string entryPointName, PInvokeAttributes flags);
    public sealed virtual string get_ModuleName();
    public sealed virtual string get_EntryPointName();
    private sealed virtual override PInvokeAttributes Microsoft.Cci.IPlatformInvokeInformation.get_Flags();
    public bool get_ExactSpelling();
    public CharSet get_CharacterSet();
    public bool get_SetLastError();
    public CallingConvention get_CallingConvention();
    public Nullable`1<bool> get_BestFitMapping();
    public Nullable`1<bool> get_ThrowOnUnmappableCharacter();
    internal static PInvokeAttributes MakeFlags(bool noMangle, CharSet charSet, bool setLastError, CallingConvention callingConvention, Nullable`1<bool> useBestFit, Nullable`1<bool> throwOnUnmappable);
}
public static class Microsoft.CodeAnalysis.DocumentationCommentId : object {
    private static ListPool`1<ISymbol> s_symbolListPool;
    private static ListPool`1<INamespaceOrTypeSymbol> s_namespaceOrTypeListPool;
    private static DocumentationCommentId();
    public static string CreateDeclarationId(ISymbol symbol);
    public static string CreateReferenceId(ISymbol symbol);
    public static ImmutableArray`1<ISymbol> GetSymbolsForDeclarationId(string id, Compilation compilation);
    private static bool TryGetSymbolsForDeclarationId(string id, Compilation compilation, List`1<ISymbol> results);
    public static ISymbol GetFirstSymbolForDeclarationId(string id, Compilation compilation);
    public static ImmutableArray`1<ISymbol> GetSymbolsForReferenceId(string id, Compilation compilation);
    private static bool TryGetSymbolsForReferenceId(string id, Compilation compilation, List`1<ISymbol> results);
    public static ISymbol GetFirstSymbolForReferenceId(string id, Compilation compilation);
    private static int GetTotalTypeParameterCount(INamedTypeSymbol symbol);
    private static string EncodeName(string name);
    private static string EncodePropertyName(string name);
    private static string DecodePropertyName(string name, string language);
}
internal class Microsoft.CodeAnalysis.DocumentationCommentIncludeCache : CachingFactory`2<string, KeyValuePair`2<string, XDocument>> {
    private static int Size;
    [CompilerGeneratedAttribute]
private static int <CacheMissCount>k__BackingField;
    private static XmlReaderSettings s_xmlSettings;
    internal static int CacheMissCount { get; private set; }
    public DocumentationCommentIncludeCache(XmlReferenceResolver resolver);
    private static DocumentationCommentIncludeCache();
    [CompilerGeneratedAttribute]
internal static int get_CacheMissCount();
    [CompilerGeneratedAttribute]
private static void set_CacheMissCount(int value);
    public XDocument GetOrMakeDocument(string resolvedPath);
    private static KeyValuePair`2<string, XDocument> MakeValue(XmlReferenceResolver resolver, string resolvedPath);
    private static int KeyHashCode(string resolvedPath);
    private static bool KeyValueEquality(string resolvedPath, KeyValuePair`2<string, XDocument> pathAndDocument);
}
public enum Microsoft.CodeAnalysis.DocumentationMode : Enum {
    public byte value__;
    public static DocumentationMode None;
    public static DocumentationMode Parse;
    public static DocumentationMode Diagnose;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.DocumentationModeEnumBounds : object {
    [ExtensionAttribute]
internal static bool IsValid(DocumentationMode value);
}
public abstract class Microsoft.CodeAnalysis.DocumentationProvider : object {
    [CompilerGeneratedAttribute]
private static DocumentationProvider <Default>k__BackingField;
    public static DocumentationProvider Default { get; }
    private static DocumentationProvider();
    [CompilerGeneratedAttribute]
public static DocumentationProvider get_Default();
    protected internal abstract virtual string GetDocumentationForSymbol(string documentationMemberID, CultureInfo preferredCulture, CancellationToken cancellationToken);
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4 : ValueType {
    private EarlyWellKnownAttributeData _lazyDecodeData;
    [CompilerGeneratedAttribute]
private TEarlyBinder <Binder>k__BackingField;
    [CompilerGeneratedAttribute]
private TNamedTypeSymbol <AttributeType>k__BackingField;
    [CompilerGeneratedAttribute]
private TAttributeSyntax <AttributeSyntax>k__BackingField;
    [CompilerGeneratedAttribute]
private TAttributeLocation <SymbolPart>k__BackingField;
    public bool HasDecodedData { get; }
    public EarlyWellKnownAttributeData DecodedData { get; }
    public TEarlyBinder Binder { get; public set; }
    public TNamedTypeSymbol AttributeType { get; public set; }
    public TAttributeSyntax AttributeSyntax { get; public set; }
    public TAttributeLocation SymbolPart { get; public set; }
    public T GetOrCreateData();
    public bool get_HasDecodedData();
    public EarlyWellKnownAttributeData get_DecodedData();
    [CompilerGeneratedAttribute]
public TEarlyBinder get_Binder();
    [CompilerGeneratedAttribute]
public void set_Binder(TEarlyBinder value);
    [CompilerGeneratedAttribute]
public TNamedTypeSymbol get_AttributeType();
    [CompilerGeneratedAttribute]
public void set_AttributeType(TNamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public TAttributeSyntax get_AttributeSyntax();
    [CompilerGeneratedAttribute]
public void set_AttributeSyntax(TAttributeSyntax value);
    [CompilerGeneratedAttribute]
public TAttributeLocation get_SymbolPart();
    [CompilerGeneratedAttribute]
public void set_SymbolPart(TAttributeLocation value);
}
internal abstract class Microsoft.CodeAnalysis.EarlyWellKnownAttributeData : WellKnownAttributeData {
}
internal class Microsoft.CodeAnalysis.EmbeddedResource : ValueType {
    public UInt32 Offset;
    public ManifestResourceAttributes Attributes;
    public string Name;
    internal EmbeddedResource(UInt32 offset, ManifestResourceAttributes attributes, string name);
}
internal class Microsoft.CodeAnalysis.Emit.AddedOrChangedMethodInfo : ValueType {
    public DebugId MethodId;
    public ImmutableArray`1<EncLocalInfo> Locals;
    public ImmutableArray`1<LambdaDebugInfo> LambdaDebugInfo;
    public ImmutableArray`1<ClosureDebugInfo> ClosureDebugInfo;
    public string StateMachineTypeNameOpt;
    public ImmutableArray`1<EncHoistedLocalInfo> StateMachineHoistedLocalSlotsOpt;
    public ImmutableArray`1<ITypeReference> StateMachineAwaiterSlotsOpt;
    public AddedOrChangedMethodInfo(DebugId methodId, ImmutableArray`1<EncLocalInfo> locals, ImmutableArray`1<LambdaDebugInfo> lambdaDebugInfo, ImmutableArray`1<ClosureDebugInfo> closureDebugInfo, string stateMachineTypeNameOpt, ImmutableArray`1<EncHoistedLocalInfo> stateMachineHoistedLocalSlotsOpt, ImmutableArray`1<ITypeReference> stateMachineAwaiterSlotsOpt);
    public AddedOrChangedMethodInfo MapTypes(SymbolMatcher map);
    private static EncLocalInfo MapLocalInfo(EncLocalInfo info, SymbolMatcher map);
    private static EncHoistedLocalInfo MapHoistedLocalSlot(EncHoistedLocalInfo info, SymbolMatcher map);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.Emit.AnonymousTypeKey : ValueType {
    internal bool IsDelegate;
    internal ImmutableArray`1<AnonymousTypeKeyField> Fields;
    internal AnonymousTypeKey(ImmutableArray`1<AnonymousTypeKeyField> fields, bool isDelegate);
    public sealed virtual bool Equals(AnonymousTypeKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private string GetDebuggerDisplay();
}
internal class Microsoft.CodeAnalysis.Emit.AnonymousTypeKeyField : ValueType {
    internal string Name;
    internal bool IsKey;
    internal bool IgnoreCase;
    public AnonymousTypeKeyField(string name, bool isKey, bool ignoreCase);
    public sealed virtual bool Equals(AnonymousTypeKeyField other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DebuggerDisplayAttribute("{Name, nq}")]
internal class Microsoft.CodeAnalysis.Emit.AnonymousTypeValue : ValueType {
    public string Name;
    public int UniqueIndex;
    public ITypeDefinition Type;
    public AnonymousTypeValue(string name, int uniqueIndex, ITypeDefinition type);
}
internal abstract class Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder : object {
    internal EmitOptions EmitOptions { get; }
    internal IMethodReference EntryPoint { get; }
    internal bool SupportsPrivateImplClass { get; }
    internal Compilation CommonCompilation { get; }
    internal CommonModuleCompilationState CommonModuleCompilationState { get; }
    internal CommonEmbeddedTypesManager CommonEmbeddedTypesManagerOpt { get; }
    internal abstract virtual EmitOptions get_EmitOptions();
    internal abstract virtual IAssemblyReference Translate(IAssemblySymbol symbol, DiagnosticBag diagnostics);
    internal abstract virtual ITypeReference Translate(ITypeSymbol symbol, SyntaxNode syntaxOpt, DiagnosticBag diagnostics);
    internal abstract virtual IMethodReference get_EntryPoint();
    internal abstract virtual bool get_SupportsPrivateImplClass();
    internal abstract virtual ImmutableArray`1<INamespaceTypeDefinition> GetAnonymousTypes();
    internal abstract virtual Compilation get_CommonCompilation();
    internal abstract virtual CommonModuleCompilationState get_CommonModuleCompilationState();
    internal abstract virtual void CompilationFinished();
    internal abstract virtual ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> GetSynthesizedMembers();
    internal abstract virtual CommonEmbeddedTypesManager get_CommonEmbeddedTypesManagerOpt();
    internal abstract virtual ITypeReference EncTranslateType(ITypeSymbol type, DiagnosticBag diagnostics);
}
public enum Microsoft.CodeAnalysis.Emit.DebugInformationFormat : Enum {
    public int value__;
    public static DebugInformationFormat Pdb;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Emit.DebugInformationFormatExtensions : object {
    [ExtensionAttribute]
internal static bool IsValid(DebugInformationFormat value);
}
internal abstract class Microsoft.CodeAnalysis.Emit.DefinitionMap : object {
    protected PEModule module;
    protected IReadOnlyDictionary`2<IMethodSymbol, MappedMethod> mappedMethods;
    protected DefinitionMap(PEModule module, IEnumerable`1<SemanticEdit> edits);
    private static IReadOnlyDictionary`2<IMethodSymbol, MappedMethod> GetMappedMethods(IEnumerable`1<SemanticEdit> edits);
    internal abstract virtual IDefinition MapDefinition(IDefinition definition);
    internal bool DefinitionExists(IDefinition definition);
    internal abstract virtual bool TryGetTypeHandle(ITypeDefinition def, TypeDefinitionHandle& handle);
    internal abstract virtual bool TryGetEventHandle(IEventDefinition def, EventDefinitionHandle& handle);
    internal abstract virtual bool TryGetFieldHandle(IFieldDefinition def, FieldDefinitionHandle& handle);
    internal abstract virtual bool TryGetMethodHandle(IMethodDefinition def, MethodDefinitionHandle& handle);
    internal abstract virtual bool TryGetPropertyHandle(IPropertyDefinition def, PropertyDefinitionHandle& handle);
}
internal abstract class Microsoft.CodeAnalysis.Emit.DefinitionMap`1 : DefinitionMap {
    protected TSymbolMatcher mapToMetadata;
    protected TSymbolMatcher mapToPrevious;
    protected DefinitionMap`1(PEModule module, IEnumerable`1<SemanticEdit> edits, TSymbolMatcher mapToMetadata, TSymbolMatcher mapToPrevious);
    internal sealed virtual IDefinition MapDefinition(IDefinition definition);
    private bool TryGetMethodHandle(EmitBaseline baseline, IMethodDefinition def, MethodDefinitionHandle& handle);
    protected static IReadOnlyDictionary`2<SyntaxNode, int> CreateDeclaratorToSyntaxOrdinalMap(ImmutableArray`1<SyntaxNode> declarators);
    protected abstract virtual void GetStateMachineFieldMapFromMetadata(ITypeSymbol stateMachineType, ImmutableArray`1<LocalSlotDebugInfo> localSlotDebugInfo, IReadOnlyDictionary`2& hoistedLocalMap, IReadOnlyDictionary`2& awaiterMap, Int32& awaiterSlotCount);
    protected abstract virtual ImmutableArray`1<EncLocalInfo> TryGetLocalSlotMapFromMetadata(MethodDefinitionHandle handle, EditAndContinueMethodDebugInformation debugInfo);
    protected abstract virtual ITypeSymbol TryGetStateMachineType(EntityHandle methodHandle);
    internal VariableSlotAllocator TryCreateVariableSlotAllocator(EmitBaseline baseline, IMethodSymbol method, IMethodSymbol topLevelMethod);
    private static void MakeLambdaAndClosureMaps(ImmutableArray`1<LambdaDebugInfo> lambdaDebugInfo, ImmutableArray`1<ClosureDebugInfo> closureDebugInfo, IReadOnlyDictionary`2& lambdaMap, IReadOnlyDictionary`2& closureMap);
    private static void GetStateMachineFieldMapFromPreviousCompilation(ImmutableArray`1<EncHoistedLocalInfo> hoistedLocalSlots, ImmutableArray`1<ITypeReference> hoistedAwaiters, IReadOnlyDictionary`2& hoistedLocalMap, IReadOnlyDictionary`2& awaiterMap);
}
internal class Microsoft.CodeAnalysis.Emit.DeltaMetadataWriter : MetadataWriter {
    private EmitBaseline _previousGeneration;
    private Guid _encId;
    private DefinitionMap _definitionMap;
    private SymbolChanges _changes;
    private DefinitionIndex`1<ITypeDefinition> _typeDefs;
    private DefinitionIndex`1<IEventDefinition> _eventDefs;
    private DefinitionIndex`1<IFieldDefinition> _fieldDefs;
    private DefinitionIndex`1<IMethodDefinition> _methodDefs;
    private DefinitionIndex`1<IPropertyDefinition> _propertyDefs;
    private ParameterDefinitionIndex _parameterDefs;
    private List`1<KeyValuePair`2<IMethodDefinition, IParameterDefinition>> _parameterDefList;
    private GenericParameterIndex _genericParameters;
    private EventOrPropertyMapIndex _eventMap;
    private EventOrPropertyMapIndex _propertyMap;
    private MethodImplIndex _methodImpls;
    private HeapOrReferenceIndex`1<IAssemblyReference> _assemblyRefIndex;
    private HeapOrReferenceIndex`1<string> _moduleRefIndex;
    private InstanceAndStructuralReferenceIndex`1<ITypeMemberReference> _memberRefIndex;
    private InstanceAndStructuralReferenceIndex`1<IGenericMethodInstanceReference> _methodSpecIndex;
    private HeapOrReferenceIndex`1<ITypeReference> _typeRefIndex;
    private InstanceAndStructuralReferenceIndex`1<ITypeReference> _typeSpecIndex;
    private HeapOrReferenceIndex`1<UInt32> _standAloneSignatureIndex;
    private Dictionary`2<IMethodDefinition, AddedOrChangedMethodInfo> _addedOrChangedMethods;
    protected ushort Generation { get; }
    protected Guid EncId { get; }
    protected Guid EncBaseId { get; }
    protected bool CompressMetadataStream { get; }
    public DeltaMetadataWriter(EmitContext context, CommonMessageProvider messageProvider, EmitBaseline previousGeneration, Guid encId, DefinitionMap definitionMap, SymbolChanges changes, CancellationToken cancellationToken);
    private static MetadataHeapsBuilder MakeHeapsBuilder(EmitBaseline previousGeneration);
    private ImmutableArray`1<int> GetDeltaTableSizes(ImmutableArray`1<int> rowCounts);
    internal EmitBaseline GetDelta(EmitBaseline baseline, Compilation compilation, Guid encId, MetadataSizes metadataSizes);
    private static IReadOnlyDictionary`2<K, V> AddRange(IReadOnlyDictionary`2<K, V> previous, IReadOnlyDictionary`2<K, V> current, bool replace);
    public void GetMethodTokens(ICollection`1<MethodDefinitionHandle> methods);
    protected virtual ushort get_Generation();
    protected virtual Guid get_EncId();
    protected virtual Guid get_EncBaseId();
    protected virtual bool get_CompressMetadataStream();
    protected virtual UInt32 GetEventDefIndex(IEventDefinition def);
    protected virtual IReadOnlyList`1<IEventDefinition> GetEventDefs();
    protected virtual UInt32 GetFieldDefIndex(IFieldDefinition def);
    protected virtual IReadOnlyList`1<IFieldDefinition> GetFieldDefs();
    protected virtual bool TryGetTypeDefIndex(ITypeDefinition def, UInt32& index);
    protected virtual UInt32 GetTypeDefIndex(ITypeDefinition def);
    protected virtual ITypeDefinition GetTypeDef(int index);
    protected virtual IReadOnlyList`1<ITypeDefinition> GetTypeDefs();
    protected virtual bool TryGetMethodDefIndex(IMethodDefinition def, UInt32& index);
    protected virtual UInt32 GetMethodDefIndex(IMethodDefinition def);
    protected virtual IMethodDefinition GetMethodDef(int index);
    protected virtual IReadOnlyList`1<IMethodDefinition> GetMethodDefs();
    protected virtual UInt32 GetPropertyDefIndex(IPropertyDefinition def);
    protected virtual IReadOnlyList`1<IPropertyDefinition> GetPropertyDefs();
    protected virtual UInt32 GetParameterDefIndex(IParameterDefinition def);
    protected virtual IReadOnlyList`1<IParameterDefinition> GetParameterDefs();
    protected virtual IReadOnlyList`1<IGenericParameter> GetGenericParameters();
    protected virtual UInt32 GetFieldDefIndex(INamedTypeDefinition typeDef);
    protected virtual UInt32 GetMethodDefIndex(INamedTypeDefinition typeDef);
    protected virtual UInt32 GetParameterDefIndex(IMethodDefinition methodDef);
    protected virtual UInt32 GetOrAddAssemblyRefIndex(IAssemblyReference reference);
    protected virtual IReadOnlyList`1<IAssemblyReference> GetAssemblyRefs();
    protected virtual UInt32 GetOrAddModuleRefIndex(string reference);
    protected virtual IReadOnlyList`1<string> GetModuleRefs();
    protected virtual UInt32 GetOrAddMemberRefIndex(ITypeMemberReference reference);
    protected virtual IReadOnlyList`1<ITypeMemberReference> GetMemberRefs();
    protected virtual UInt32 GetOrAddMethodSpecIndex(IGenericMethodInstanceReference reference);
    protected virtual IReadOnlyList`1<IGenericMethodInstanceReference> GetMethodSpecs();
    protected virtual bool TryGetTypeRefIndex(ITypeReference reference, UInt32& index);
    protected virtual UInt32 GetOrAddTypeRefIndex(ITypeReference reference);
    protected virtual IReadOnlyList`1<ITypeReference> GetTypeRefs();
    protected virtual UInt32 GetOrAddTypeSpecIndex(ITypeReference reference);
    protected virtual IReadOnlyList`1<ITypeReference> GetTypeSpecs();
    protected virtual UInt32 GetOrAddStandAloneSignatureIndex(UInt32 blobIndex);
    protected virtual IReadOnlyList`1<UInt32> GetStandAloneSignatures();
    protected virtual IEnumerable`1<INamespaceTypeDefinition> GetTopLevelTypes(IModule module);
    protected virtual void CreateIndicesForModule();
    protected virtual void CreateIndicesForNonTypeMembers(ITypeDefinition typeDef);
    private bool AddDefIfNecessary(DefinitionIndex`1<T> defIndex, T def);
    protected virtual ReferenceIndexer CreateReferenceVisitor();
    protected virtual void ReportReferencesToAddedSymbols();
    private void ReportReferencesToAddedSymbol(ISymbol symbolOpt);
    protected virtual UInt32 SerializeLocalVariablesSignature(IMethodBody body);
    private EncLocalInfo CreateEncLocalInfo(ILocalDefinition localDef, Byte[] signature);
    protected virtual void PopulateEncLogTableRows(List`1<EncLogRow> table, ImmutableArray`1<int> rowCounts);
    private void PopulateEncLogTableEventsOrProperties(List`1<EncLogRow> table, DefinitionIndex`1<T> index, UInt32 tokenType, EncFuncCode addCode, EventOrPropertyMapIndex map, UInt32 mapTokenType);
    private void PopulateEncLogTableFieldsOrMethods(List`1<EncLogRow> table, DefinitionIndex`1<T> index, UInt32 tokenType, EncFuncCode addCode);
    private void PopulateEncLogTableParameters(List`1<EncLogRow> table);
    private static void PopulateEncLogTableRows(List`1<EncLogRow> table, DefinitionIndex`1<T> index, UInt32 tokenType);
    private static void PopulateEncLogTableRows(List`1<EncLogRow> table, TableIndex tableIndex, ImmutableArray`1<int> previousSizes, ImmutableArray`1<int> deltaSizes);
    private static void PopulateEncLogTableRows(List`1<EncLogRow> table, UInt32 tokenType, UInt32 firstRowId, int nTokens);
    protected virtual void PopulateEncMapTableRows(List`1<EncMapRow> table, ImmutableArray`1<int> rowCounts);
    private static void AddReferencedTokens(ArrayBuilder`1<UInt32> builder, TableIndex tableIndex, ImmutableArray`1<int> previousSizes, ImmutableArray`1<int> deltaSizes);
    private static void AddReferencedTokens(ArrayBuilder`1<UInt32> builder, UInt32 tokenType, UInt32 firstRowId, int nTokens);
    private static void AddDefinitionTokens(ArrayBuilder`1<UInt32> tokens, DefinitionIndex`1<T> index, UInt32 tokenType);
    protected virtual void PopulateEventMapTableRows(List`1<EventMapRow> table);
    protected virtual void PopulatePropertyMapTableRows(List`1<PropertyMapRow> table);
    private bool TryGetExistingTypeDefIndex(ITypeDefinition item, UInt32& index);
    private bool TryGetExistingEventDefIndex(IEventDefinition item, UInt32& index);
    private bool TryGetExistingFieldDefIndex(IFieldDefinition item, UInt32& index);
    private bool TryGetExistingMethodDefIndex(IMethodDefinition item, UInt32& index);
    private bool TryGetExistingPropertyDefIndex(IPropertyDefinition item, UInt32& index);
    private bool TryGetExistingEventMapIndex(UInt32 item, UInt32& index);
    private bool TryGetExistingPropertyMapIndex(UInt32 item, UInt32& index);
    private bool TryGetExistingMethodImplIndex(MethodImplKey item, UInt32& index);
}
public class Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation : ValueType {
    internal int MethodOrdinal;
    internal ImmutableArray`1<LocalSlotDebugInfo> LocalSlots;
    internal ImmutableArray`1<LambdaDebugInfo> Lambdas;
    internal ImmutableArray`1<ClosureDebugInfo> Closures;
    private static byte SyntaxOffsetBaseline;
    internal EditAndContinueMethodDebugInformation(int methodOrdinal, ImmutableArray`1<LocalSlotDebugInfo> localSlots, ImmutableArray`1<ClosureDebugInfo> closures, ImmutableArray`1<LambdaDebugInfo> lambdas);
    public static EditAndContinueMethodDebugInformation Create(ImmutableArray`1<byte> compressedSlotMap, ImmutableArray`1<byte> compressedLambdaMap);
    private static InvalidDataException CreateInvalidDataException(ImmutableArray`1<byte> data, int offset);
    private static ImmutableArray`1<LocalSlotDebugInfo> UncompressSlotMap(ImmutableArray`1<byte> compressedSlotMap);
    internal void SerializeLocalSlots(BinaryWriter writer);
    private static void UncompressLambdaMap(ImmutableArray`1<byte> compressedLambdaMap, Int32& methodOrdinal, ImmutableArray`1& closures, ImmutableArray`1& lambdas);
    internal void SerializeLambdaMap(BinaryWriter writer);
}
public class Microsoft.CodeAnalysis.Emit.EmitBaseline : object {
    private static ImmutableArray`1<int> s_emptyTableSizes;
    [CompilerGeneratedAttribute]
private EmitBaseline <InitialBaseline>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleMetadata <OriginalMetadata>k__BackingField;
    internal MetadataSymbols LazyMetadataSymbols;
    internal Compilation Compilation;
    internal CommonPEModuleBuilder PEModuleBuilder;
    internal Guid ModuleVersionId;
    internal int Ordinal;
    internal Guid EncId;
    internal IReadOnlyDictionary`2<ITypeDefinition, UInt32> TypesAdded;
    internal IReadOnlyDictionary`2<IEventDefinition, UInt32> EventsAdded;
    internal IReadOnlyDictionary`2<IFieldDefinition, UInt32> FieldsAdded;
    internal IReadOnlyDictionary`2<IMethodDefinition, UInt32> MethodsAdded;
    internal IReadOnlyDictionary`2<IPropertyDefinition, UInt32> PropertiesAdded;
    internal IReadOnlyDictionary`2<UInt32, UInt32> EventMapAdded;
    internal IReadOnlyDictionary`2<UInt32, UInt32> PropertyMapAdded;
    internal IReadOnlyDictionary`2<MethodImplKey, UInt32> MethodImplsAdded;
    internal ImmutableArray`1<int> TableEntriesAdded;
    internal int BlobStreamLengthAdded;
    internal int StringStreamLengthAdded;
    internal int UserStringStreamLengthAdded;
    internal int GuidStreamLengthAdded;
    internal IReadOnlyDictionary`2<UInt32, AddedOrChangedMethodInfo> AddedOrChangedMethods;
    internal Func`2<MethodDefinitionHandle, EditAndContinueMethodDebugInformation> DebugInformationProvider;
    internal ImmutableArray`1<int> TableSizes;
    internal IReadOnlyDictionary`2<UInt32, UInt32> TypeToEventMap;
    internal IReadOnlyDictionary`2<UInt32, UInt32> TypeToPropertyMap;
    internal IReadOnlyDictionary`2<MethodImplKey, UInt32> MethodImpls;
    private IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> _anonymousTypeMap;
    internal ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> SynthesizedMembers;
    internal EmitBaseline InitialBaseline { get; }
    public ModuleMetadata OriginalMetadata { get; }
    internal IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> AnonymousTypeMap { get; }
    internal MetadataReader MetadataReader { get; }
    internal int BlobStreamLength { get; }
    internal int StringStreamLength { get; }
    internal int UserStringStreamLength { get; }
    internal int GuidStreamLength { get; }
    private EmitBaseline(EmitBaseline initialBaseline, ModuleMetadata module, Compilation compilation, CommonPEModuleBuilder moduleBuilder, Guid moduleVersionId, int ordinal, Guid encId, IReadOnlyDictionary`2<ITypeDefinition, UInt32> typesAdded, IReadOnlyDictionary`2<IEventDefinition, UInt32> eventsAdded, IReadOnlyDictionary`2<IFieldDefinition, UInt32> fieldsAdded, IReadOnlyDictionary`2<IMethodDefinition, UInt32> methodsAdded, IReadOnlyDictionary`2<IPropertyDefinition, UInt32> propertiesAdded, IReadOnlyDictionary`2<UInt32, UInt32> eventMapAdded, IReadOnlyDictionary`2<UInt32, UInt32> propertyMapAdded, IReadOnlyDictionary`2<MethodImplKey, UInt32> methodImplsAdded, ImmutableArray`1<int> tableEntriesAdded, int blobStreamLengthAdded, int stringStreamLengthAdded, int userStringStreamLengthAdded, int guidStreamLengthAdded, IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> anonymousTypeMap, ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> synthesizedMembers, IReadOnlyDictionary`2<UInt32, AddedOrChangedMethodInfo> methodsAddedOrChanged, Func`2<MethodDefinitionHandle, EditAndContinueMethodDebugInformation> debugInformationProvider, IReadOnlyDictionary`2<UInt32, UInt32> typeToEventMap, IReadOnlyDictionary`2<UInt32, UInt32> typeToPropertyMap, IReadOnlyDictionary`2<MethodImplKey, UInt32> methodImpls);
    private static EmitBaseline();
    public static EmitBaseline CreateInitialBaseline(ModuleMetadata module, Func`2<MethodDefinitionHandle, EditAndContinueMethodDebugInformation> debugInformationProvider);
    [CompilerGeneratedAttribute]
internal EmitBaseline get_InitialBaseline();
    [CompilerGeneratedAttribute]
public ModuleMetadata get_OriginalMetadata();
    internal EmitBaseline With(Compilation compilation, CommonPEModuleBuilder moduleBuilder, int ordinal, Guid encId, IReadOnlyDictionary`2<ITypeDefinition, UInt32> typesAdded, IReadOnlyDictionary`2<IEventDefinition, UInt32> eventsAdded, IReadOnlyDictionary`2<IFieldDefinition, UInt32> fieldsAdded, IReadOnlyDictionary`2<IMethodDefinition, UInt32> methodsAdded, IReadOnlyDictionary`2<IPropertyDefinition, UInt32> propertiesAdded, IReadOnlyDictionary`2<UInt32, UInt32> eventMapAdded, IReadOnlyDictionary`2<UInt32, UInt32> propertyMapAdded, IReadOnlyDictionary`2<MethodImplKey, UInt32> methodImplsAdded, ImmutableArray`1<int> tableEntriesAdded, int blobStreamLengthAdded, int stringStreamLengthAdded, int userStringStreamLengthAdded, int guidStreamLengthAdded, IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> anonymousTypeMap, ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> synthesizedMembers, IReadOnlyDictionary`2<UInt32, AddedOrChangedMethodInfo> addedOrChangedMethods, Func`2<MethodDefinitionHandle, EditAndContinueMethodDebugInformation> debugInformationProvider);
    internal IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> get_AnonymousTypeMap();
    internal MetadataReader get_MetadataReader();
    internal int get_BlobStreamLength();
    internal int get_StringStreamLength();
    internal int get_UserStringStreamLength();
    internal int get_GuidStreamLength();
    private static ImmutableArray`1<int> CalculateTableSizes(MetadataReader reader, ImmutableArray`1<int> delta);
    private static Dictionary`2<UInt32, UInt32> CalculateTypePropertyMap(MetadataReader reader);
    private static Dictionary`2<UInt32, UInt32> CalculateTypeEventMap(MetadataReader reader);
    private static Dictionary`2<MethodImplKey, UInt32> CalculateMethodImpls(MetadataReader reader);
    internal int GetNextAnonymousTypeIndex(bool fromDelegates);
}
internal class Microsoft.CodeAnalysis.Emit.EmitContext : ValueType {
    public IModule Module;
    public SyntaxNode SyntaxNodeOpt;
    public DiagnosticBag Diagnostics;
    public CommonPEModuleBuilder ModuleBuilder { get; }
    public EmitContext(IModule module, SyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    public CommonPEModuleBuilder get_ModuleBuilder();
}
public class Microsoft.CodeAnalysis.Emit.EmitDifferenceResult : EmitResult {
    private EmitBaseline _baseline;
    public EmitBaseline Baseline { get; }
    internal EmitDifferenceResult(bool success, ImmutableArray`1<Diagnostic> diagnostics, EmitBaseline baseline);
    public EmitBaseline get_Baseline();
}
public class Microsoft.CodeAnalysis.Emit.EmitOptions : object {
    internal static EmitOptions Default;
    [CompilerGeneratedAttribute]
private bool <EmitMetadataOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TolerateErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludePrivateMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private SubsystemVersion <SubsystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HighEntropyVirtualAddressSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <BaseAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private DebugInformationFormat <DebugInformationFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputNameOverride>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PdbFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeMetadataVersion>k__BackingField;
    public bool EmitMetadataOnly { get; private set; }
    public bool TolerateErrors { get; private set; }
    public bool IncludePrivateMembers { get; private set; }
    public SubsystemVersion SubsystemVersion { get; private set; }
    public int FileAlignment { get; private set; }
    public bool HighEntropyVirtualAddressSpace { get; private set; }
    public ulong BaseAddress { get; private set; }
    public DebugInformationFormat DebugInformationFormat { get; private set; }
    public string OutputNameOverride { get; private set; }
    public string PdbFilePath { get; private set; }
    public string RuntimeMetadataVersion { get; private set; }
    public EmitOptions(bool metadataOnly, DebugInformationFormat debugInformationFormat, string pdbFilePath, string outputNameOverride, int fileAlignment, ulong baseAddress, bool highEntropyVirtualAddressSpace, SubsystemVersion subsystemVersion, string runtimeMetadataVersion, bool tolerateErrors, bool includePrivateMembers);
    private EmitOptions(EmitOptions other);
    private static EmitOptions();
    [CompilerGeneratedAttribute]
public bool get_EmitMetadataOnly();
    [CompilerGeneratedAttribute]
private void set_EmitMetadataOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_TolerateErrors();
    [CompilerGeneratedAttribute]
private void set_TolerateErrors(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludePrivateMembers();
    [CompilerGeneratedAttribute]
private void set_IncludePrivateMembers(bool value);
    [CompilerGeneratedAttribute]
public SubsystemVersion get_SubsystemVersion();
    [CompilerGeneratedAttribute]
private void set_SubsystemVersion(SubsystemVersion value);
    [CompilerGeneratedAttribute]
public int get_FileAlignment();
    [CompilerGeneratedAttribute]
private void set_FileAlignment(int value);
    [CompilerGeneratedAttribute]
public bool get_HighEntropyVirtualAddressSpace();
    [CompilerGeneratedAttribute]
private void set_HighEntropyVirtualAddressSpace(bool value);
    [CompilerGeneratedAttribute]
public ulong get_BaseAddress();
    [CompilerGeneratedAttribute]
private void set_BaseAddress(ulong value);
    [CompilerGeneratedAttribute]
public DebugInformationFormat get_DebugInformationFormat();
    [CompilerGeneratedAttribute]
private void set_DebugInformationFormat(DebugInformationFormat value);
    [CompilerGeneratedAttribute]
public string get_OutputNameOverride();
    [CompilerGeneratedAttribute]
private void set_OutputNameOverride(string value);
    [CompilerGeneratedAttribute]
public string get_PdbFilePath();
    [CompilerGeneratedAttribute]
private void set_PdbFilePath(string value);
    [CompilerGeneratedAttribute]
public string get_RuntimeMetadataVersion();
    [CompilerGeneratedAttribute]
private void set_RuntimeMetadataVersion(string value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EmitOptions other);
    public virtual int GetHashCode();
    public static bool op_Equality(EmitOptions left, EmitOptions right);
    public static bool op_Inequality(EmitOptions left, EmitOptions right);
    internal void ValidateOptions(DiagnosticBag diagnostics, CommonMessageProvider messageProvider);
    internal static bool IsValidFileAlignment(int value);
    public EmitOptions WithEmitMetadataOnly(bool value);
    public EmitOptions WithPdbFilePath(string path);
    public EmitOptions WithOutputNameOverride(string outputName);
    public EmitOptions WithDebugInformationFormat(DebugInformationFormat format);
    public EmitOptions WithFileAlignment(int value);
    public EmitOptions WithBaseAddress(ulong value);
    public EmitOptions WithHighEntropyVirtualAddressSpace(bool value);
    public EmitOptions WithSubsystemVersion(SubsystemVersion subsystemVersion);
    public EmitOptions WithRuntimeMetadataVersion(string version);
    public EmitOptions WithTolerateErrors(bool value);
    public EmitOptions WithIncludePrivateMembers(bool value);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.Emit.EmitResult : object {
    private bool _success;
    private ImmutableArray`1<Diagnostic> _diagnostics;
    public bool Success { get; }
    public ImmutableArray`1<Diagnostic> Diagnostics { get; }
    internal EmitResult(bool success, ImmutableArray`1<Diagnostic> diagnostics);
    public bool get_Success();
    public ImmutableArray`1<Diagnostic> get_Diagnostics();
    protected virtual string GetDebuggerDisplay();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.Emit.EncHoistedLocalInfo : ValueType {
    public LocalSlotDebugInfo SlotInfo;
    public ITypeReference Type;
    public bool IsUnused { get; }
    public EncHoistedLocalInfo(bool ignored);
    public EncHoistedLocalInfo(LocalSlotDebugInfo slotInfo, ITypeReference type);
    public bool get_IsUnused();
    public sealed virtual bool Equals(EncHoistedLocalInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private string GetDebuggerDisplay();
}
internal class Microsoft.CodeAnalysis.Emit.EncHoistedLocalMetadata : ValueType {
    public string Name;
    public ITypeReference Type;
    public SynthesizedLocalKind SynthesizedKind;
    public EncHoistedLocalMetadata(string name, ITypeReference type, SynthesizedLocalKind synthesizedKind);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.Emit.EncLocalInfo : ValueType {
    public LocalSlotDebugInfo SlotInfo;
    public ITypeReference Type;
    public LocalSlotConstraints Constraints;
    public Byte[] Signature;
    public bool isUnused;
    public bool IsDefault { get; }
    public bool IsUnused { get; }
    public EncLocalInfo(Byte[] signature);
    public EncLocalInfo(LocalSlotDebugInfo slotInfo, ITypeReference type, LocalSlotConstraints constraints, Byte[] signature);
    public bool get_IsDefault();
    public bool get_IsUnused();
    public sealed virtual bool Equals(EncLocalInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private string GetDebuggerDisplay();
}
internal class Microsoft.CodeAnalysis.Emit.EncVariableSlotAllocator : VariableSlotAllocator {
    private SymbolMatcher _symbolMap;
    private Func`2<SyntaxNode, SyntaxNode> _syntaxMapOpt;
    private IMethodSymbolInternal _previousTopLevelMethod;
    private DebugId _methodId;
    private IReadOnlyDictionary`2<EncLocalInfo, int> _previousLocalSlots;
    private ImmutableArray`1<EncLocalInfo> _previousLocals;
    private string _stateMachineTypeNameOpt;
    private int _hoistedLocalSlotCount;
    private IReadOnlyDictionary`2<EncHoistedLocalInfo, int> _hoistedLocalSlotsOpt;
    private int _awaiterCount;
    private IReadOnlyDictionary`2<ITypeReference, int> _awaiterMapOpt;
    private IReadOnlyDictionary`2<int, KeyValuePair`2<DebugId, int>> _lambdaMapOpt;
    private IReadOnlyDictionary`2<int, DebugId> _closureMapOpt;
    public Nullable`1<DebugId> MethodId { get; }
    public string PreviousStateMachineTypeName { get; }
    public int PreviousHoistedLocalSlotCount { get; }
    public int PreviousAwaiterSlotCount { get; }
    public EncVariableSlotAllocator(SymbolMatcher symbolMap, Func`2<SyntaxNode, SyntaxNode> syntaxMapOpt, IMethodSymbolInternal previousTopLevelMethod, DebugId methodId, ImmutableArray`1<EncLocalInfo> previousLocals, IReadOnlyDictionary`2<int, KeyValuePair`2<DebugId, int>> lambdaMapOpt, IReadOnlyDictionary`2<int, DebugId> closureMapOpt, string stateMachineTypeNameOpt, int hoistedLocalSlotCount, IReadOnlyDictionary`2<EncHoistedLocalInfo, int> hoistedLocalSlotsOpt, int awaiterCount, IReadOnlyDictionary`2<ITypeReference, int> awaiterMapOpt);
    public virtual Nullable`1<DebugId> get_MethodId();
    private int CalculateSyntaxOffsetInPreviousMethod(int position, SyntaxTree tree);
    public virtual void AddPreviousLocals(ArrayBuilder`1<ILocalDefinition> builder);
    private bool TryGetPreviousLocalId(SyntaxNode currentDeclarator, LocalDebugId currentId, LocalDebugId& previousId);
    public virtual LocalDefinition GetPreviousLocal(ITypeReference currentType, ILocalSymbolInternal currentLocalSymbol, string nameOpt, SynthesizedLocalKind kind, LocalDebugId id, UInt32 pdbAttributes, LocalSlotConstraints constraints, bool isDynamic, ImmutableArray`1<TypedConstant> dynamicTransformFlags);
    public virtual string get_PreviousStateMachineTypeName();
    public virtual bool TryGetPreviousHoistedLocalSlotIndex(SyntaxNode currentDeclarator, ITypeReference currentType, SynthesizedLocalKind synthesizedKind, LocalDebugId currentId, Int32& slotIndex);
    public virtual int get_PreviousHoistedLocalSlotCount();
    public virtual int get_PreviousAwaiterSlotCount();
    public virtual bool TryGetPreviousAwaiterSlotIndex(ITypeReference currentType, Int32& slotIndex);
    private bool TryGetPreviousSyntaxOffset(SyntaxNode currentSyntax, Int32& previousSyntaxOffset);
    private bool TryGetPreviousLambdaSyntaxOffset(SyntaxNode lambdaOrLambdaBodySyntax, bool isLambdaBody, Int32& previousSyntaxOffset);
    public virtual bool TryGetPreviousClosure(SyntaxNode scopeSyntax, DebugId& closureId);
    public virtual bool TryGetPreviousLambda(SyntaxNode lambdaOrLambdaBodySyntax, bool isLambdaBody, DebugId& lambdaId);
}
internal class Microsoft.CodeAnalysis.Emit.ErrorType : object {
    public static ErrorType Singleton;
    private static string s_name;
    private string Microsoft.Cci.INamespaceTypeReference.NamespaceName { get; }
    private ushort Microsoft.Cci.INamedTypeReference.GenericParameterCount { get; }
    private bool Microsoft.Cci.INamedTypeReference.MangleName { get; }
    private bool Microsoft.Cci.ITypeReference.IsEnum { get; }
    private bool Microsoft.Cci.ITypeReference.IsValueType { get; }
    private TypeDefinitionHandle Microsoft.Cci.ITypeReference.TypeDef { get; }
    private IGenericMethodParameterReference Microsoft.Cci.ITypeReference.AsGenericMethodParameterReference { get; }
    private IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.AsGenericTypeInstanceReference { get; }
    private IGenericTypeParameterReference Microsoft.Cci.ITypeReference.AsGenericTypeParameterReference { get; }
    private INamespaceTypeReference Microsoft.Cci.ITypeReference.AsNamespaceTypeReference { get; }
    private INestedTypeReference Microsoft.Cci.ITypeReference.AsNestedTypeReference { get; }
    private ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.AsSpecializedNestedTypeReference { get; }
    private string Microsoft.Cci.INamedEntity.Name { get; }
    private static ErrorType();
    private sealed virtual override IUnitReference Microsoft.Cci.INamespaceTypeReference.GetUnit(EmitContext context);
    private sealed virtual override string Microsoft.Cci.INamespaceTypeReference.get_NamespaceName();
    private sealed virtual override ushort Microsoft.Cci.INamedTypeReference.get_GenericParameterCount();
    private sealed virtual override bool Microsoft.Cci.INamedTypeReference.get_MangleName();
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsEnum();
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsValueType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.GetResolvedType(EmitContext context);
    private sealed virtual override PrimitiveTypeCode Microsoft.Cci.ITypeReference.TypeCode(EmitContext context);
    private sealed virtual override TypeDefinitionHandle Microsoft.Cci.ITypeReference.get_TypeDef();
    private sealed virtual override IGenericMethodParameterReference Microsoft.Cci.ITypeReference.get_AsGenericMethodParameterReference();
    private sealed virtual override IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.get_AsGenericTypeInstanceReference();
    private sealed virtual override IGenericTypeParameterReference Microsoft.Cci.ITypeReference.get_AsGenericTypeParameterReference();
    private sealed virtual override INamespaceTypeDefinition Microsoft.Cci.ITypeReference.AsNamespaceTypeDefinition(EmitContext context);
    private sealed virtual override INamespaceTypeReference Microsoft.Cci.ITypeReference.get_AsNamespaceTypeReference();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.ITypeReference.AsNestedTypeDefinition(EmitContext context);
    private sealed virtual override INestedTypeReference Microsoft.Cci.ITypeReference.get_AsNestedTypeReference();
    private sealed virtual override ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.get_AsSpecializedNestedTypeReference();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.AsTypeDefinition(EmitContext context);
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.GetAttributes(EmitContext context);
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
    private sealed virtual override string Microsoft.Cci.INamedEntity.get_Name();
}
internal interface Microsoft.CodeAnalysis.Emit.IPEDeltaAssemblyBuilder {
    public abstract virtual void OnCreatedIndices(DiagnosticBag diagnostics);
    public abstract virtual IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> GetAnonymousTypeMap();
}
internal class Microsoft.CodeAnalysis.Emit.MethodImplKey : ValueType {
    internal UInt32 ImplementingMethod;
    internal int Index;
    internal MethodImplKey(UInt32 implementingMethod, int index);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MethodImplKey other);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.Emit.ModulePropertiesForSerialization : object {
    public ushort FileAlignment;
    public string TargetRuntimeVersion;
    public Platform Platform;
    public byte MetadataFormatMajorVersion;
    public byte MetadataFormatMinorVersion;
    public Guid PersistentIdentifier;
    public bool ILOnly;
    public bool TrackDebugData;
    public ulong BaseAddress;
    public ulong SizeOfHeapReserve;
    public ulong SizeOfHeapCommit;
    public ulong SizeOfStackReserve;
    public ulong SizeOfStackCommit;
    public bool EnableHighEntropyVA;
    public bool StrongNameSigned;
    public bool ConfigureToExecuteInAppContainer;
    public SubsystemVersion SubsystemVersion;
    public static ulong DefaultExeBaseAddress32Bit;
    public static ulong DefaultExeBaseAddress64Bit;
    public static ulong DefaultDllBaseAddress32Bit;
    public static ulong DefaultDllBaseAddress64Bit;
    public static ulong DefaultSizeOfHeapReserve32Bit;
    public static ulong DefaultSizeOfHeapReserve64Bit;
    public static ulong DefaultSizeOfHeapCommit32Bit;
    public static ulong DefaultSizeOfHeapCommit64Bit;
    public static ulong DefaultSizeOfStackReserve32Bit;
    public static ulong DefaultSizeOfStackReserve64Bit;
    public static ulong DefaultSizeOfStackCommit32Bit;
    public static ulong DefaultSizeOfStackCommit64Bit;
    public static ushort DefaultFileAlignment32Bit;
    public static ushort DefaultFileAlignment64Bit;
    public static Platform DefaultPlatform;
    internal ushort DllCharacteristics { get; }
    internal Machine Machine { get; }
    internal bool RequiresStartupStub { get; }
    internal ModulePropertiesForSerialization(Guid persistentIdentifier, ushort fileAlignment, string targetRuntimeVersion, Platform platform, bool trackDebugData, ulong baseAddress, ulong sizeOfHeapReserve, ulong sizeOfHeapCommit, ulong sizeOfStackReserve, ulong sizeOfStackCommit, bool enableHighEntropyVA, bool strongNameSigned, bool configureToExecuteInAppContainer, SubsystemVersion subsystemVersion);
    internal ushort get_DllCharacteristics();
    internal Machine get_Machine();
    internal bool get_RequiresStartupStub();
}
internal abstract class Microsoft.CodeAnalysis.Emit.NoPia.CommonEmbeddedTypesManager : object {
    public bool IsFrozen { get; }
    public abstract virtual bool get_IsFrozen();
    public abstract virtual ImmutableArray`1<INamespaceTypeDefinition> GetTypes(DiagnosticBag diagnostics, HashSet`1<string> namesOfTopLevelTypes);
}
internal abstract class Microsoft.CodeAnalysis.Emit.NoPia.EmbeddedTypesManager`21 : CommonEmbeddedTypesManager {
    public TPEModuleBuilder ModuleBeingBuilt;
    public ConcurrentDictionary`2<TNamedTypeSymbol, TEmbeddedType> EmbeddedTypesMap;
    public ConcurrentDictionary`2<TFieldSymbol, TEmbeddedField> EmbeddedFieldsMap;
    public ConcurrentDictionary`2<TMethodSymbol, TEmbeddedMethod> EmbeddedMethodsMap;
    public ConcurrentDictionary`2<TPropertySymbol, TEmbeddedProperty> EmbeddedPropertiesMap;
    public ConcurrentDictionary`2<TEventSymbol, TEmbeddedEvent> EmbeddedEventsMap;
    private ImmutableArray`1<TEmbeddedType> _frozen;
    public bool IsFrozen { get; }
    protected EmbeddedTypesManager`21(TPEModuleBuilder moduleBeingBuilt);
    public virtual bool get_IsFrozen();
    public virtual ImmutableArray`1<INamespaceTypeDefinition> GetTypes(DiagnosticBag diagnostics, HashSet`1<string> namesOfTopLevelTypes);
    private bool HasNameConflict(HashSet`1<string> namesOfTopLevelTypes, TEmbeddedType type, DiagnosticBag diagnostics);
    internal abstract virtual int GetTargetAttributeSignatureIndex(TSymbol underlyingSymbol, TAttributeData attrData, AttributeDescription description);
    internal bool IsTargetAttribute(TSymbol underlyingSymbol, TAttributeData attrData, AttributeDescription description);
    internal abstract virtual TAttributeData CreateSynthesizedAttribute(WellKnownMember constructor, TAttributeData attrData, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal abstract virtual void ReportIndirectReferencesToLinkedAssemblies(TAssemblySymbol assembly, DiagnosticBag diagnostics);
    protected abstract virtual void OnGetTypesCompleted(ImmutableArray`1<TEmbeddedType> types, DiagnosticBag diagnostics);
    protected abstract virtual void ReportNameCollisionBetweenEmbeddedTypes(TEmbeddedType typeA, TEmbeddedType typeB, DiagnosticBag diagnostics);
    protected abstract virtual void ReportNameCollisionWithAlreadyDeclaredType(TEmbeddedType type, DiagnosticBag diagnostics);
    protected void EmbedReferences(ITypeDefinitionMember embeddedMember, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    protected abstract virtual TEmbeddedType GetEmbeddedTypeForMember(TSymbol member, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal abstract virtual TEmbeddedField EmbedField(TEmbeddedType type, TFieldSymbol field, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal abstract virtual TEmbeddedMethod EmbedMethod(TEmbeddedType type, TMethodSymbol method, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal abstract virtual TEmbeddedProperty EmbedProperty(TEmbeddedType type, TPropertySymbol property, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal abstract virtual TEmbeddedEvent EmbedEvent(TEmbeddedType type, TEventSymbol event, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, bool isUsedForComAwareEventBinding);
    internal IFieldReference EmbedFieldIfNeedTo(TFieldSymbol fieldSymbol, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal IMethodReference EmbedMethodIfNeedTo(TMethodSymbol methodSymbol, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal void EmbedEventIfNeedTo(TEventSymbol eventSymbol, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, bool isUsedForComAwareEventBinding);
    internal void EmbedPropertyIfNeedTo(TPropertySymbol propertySymbol, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.Emit.NoPia.VtblGap : object {
    public ITypeDefinition ContainingType;
    private string _name;
    private IEnumerable`1<IGenericMethodParameter> Microsoft.Cci.IMethodDefinition.GenericParameters { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsImplicitlyDeclared { get; }
    private bool Microsoft.Cci.IMethodDefinition.HasDeclarativeSecurity { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsAbstract { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsAccessCheckedOnOverride { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsConstructor { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsExternal { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsHiddenBySignature { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsNewSlot { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsPlatformInvoke { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsRuntimeSpecial { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsSealed { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsSpecialName { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsStatic { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsVirtual { get; }
    private ImmutableArray`1<IParameterDefinition> Microsoft.Cci.IMethodDefinition.Parameters { get; }
    private IPlatformInvokeInformation Microsoft.Cci.IMethodDefinition.PlatformInvokeData { get; }
    private bool Microsoft.Cci.IMethodDefinition.RequiresSecurityObject { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IMethodDefinition.ReturnValueAttributes { get; }
    private bool Microsoft.Cci.IMethodDefinition.ReturnValueIsMarshalledExplicitly { get; }
    private IMarshallingInformation Microsoft.Cci.IMethodDefinition.ReturnValueMarshallingInformation { get; }
    private ImmutableArray`1<byte> Microsoft.Cci.IMethodDefinition.ReturnValueMarshallingDescriptor { get; }
    private IEnumerable`1<SecurityAttribute> Microsoft.Cci.IMethodDefinition.SecurityAttributes { get; }
    private ITypeDefinition Microsoft.Cci.ITypeDefinitionMember.ContainingTypeDefinition { get; }
    private INamespace Microsoft.Cci.IMethodDefinition.ContainingNamespace { get; }
    private TypeMemberVisibility Microsoft.Cci.ITypeDefinitionMember.Visibility { get; }
    private string Microsoft.Cci.INamedEntity.Name { get; }
    private bool Microsoft.Cci.IMethodReference.AcceptsExtraArguments { get; }
    private ushort Microsoft.Cci.IMethodReference.GenericParameterCount { get; }
    private bool Microsoft.Cci.IMethodReference.IsGeneric { get; }
    private ImmutableArray`1<IParameterTypeInformation> Microsoft.Cci.IMethodReference.ExtraParameters { get; }
    private IGenericMethodInstanceReference Microsoft.Cci.IMethodReference.AsGenericMethodInstanceReference { get; }
    private ISpecializedMethodReference Microsoft.Cci.IMethodReference.AsSpecializedMethodReference { get; }
    private CallingConvention Microsoft.Cci.ISignature.CallingConvention { get; }
    private ushort Microsoft.Cci.ISignature.ParameterCount { get; }
    private ImmutableArray`1<ICustomModifier> Microsoft.Cci.ISignature.ReturnValueCustomModifiers { get; }
    private bool Microsoft.Cci.ISignature.ReturnValueIsByRef { get; }
    public VtblGap(ITypeDefinition containingType, string name);
    private sealed virtual override IMethodBody Microsoft.Cci.IMethodDefinition.GetBody(EmitContext context);
    private sealed virtual override IEnumerable`1<IGenericMethodParameter> Microsoft.Cci.IMethodDefinition.get_GenericParameters();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsImplicitlyDeclared();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_HasDeclarativeSecurity();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsAbstract();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsAccessCheckedOnOverride();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsConstructor();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsExternal();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsHiddenBySignature();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsNewSlot();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsPlatformInvoke();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsRuntimeSpecial();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsSealed();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsSpecialName();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsStatic();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsVirtual();
    private sealed virtual override MethodImplAttributes Microsoft.Cci.IMethodDefinition.GetImplementationAttributes(EmitContext context);
    private sealed virtual override ImmutableArray`1<IParameterDefinition> Microsoft.Cci.IMethodDefinition.get_Parameters();
    private sealed virtual override IPlatformInvokeInformation Microsoft.Cci.IMethodDefinition.get_PlatformInvokeData();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_RequiresSecurityObject();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IMethodDefinition.get_ReturnValueAttributes();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_ReturnValueIsMarshalledExplicitly();
    private sealed virtual override IMarshallingInformation Microsoft.Cci.IMethodDefinition.get_ReturnValueMarshallingInformation();
    private sealed virtual override ImmutableArray`1<byte> Microsoft.Cci.IMethodDefinition.get_ReturnValueMarshallingDescriptor();
    private sealed virtual override IEnumerable`1<SecurityAttribute> Microsoft.Cci.IMethodDefinition.get_SecurityAttributes();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeDefinitionMember.get_ContainingTypeDefinition();
    private sealed virtual override INamespace Microsoft.Cci.IMethodDefinition.get_ContainingNamespace();
    private sealed virtual override TypeMemberVisibility Microsoft.Cci.ITypeDefinitionMember.get_Visibility();
    private sealed virtual override ITypeReference Microsoft.Cci.ITypeMemberReference.GetContainingType(EmitContext context);
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.GetAttributes(EmitContext context);
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
    private sealed virtual override string Microsoft.Cci.INamedEntity.get_Name();
    private sealed virtual override bool Microsoft.Cci.IMethodReference.get_AcceptsExtraArguments();
    private sealed virtual override ushort Microsoft.Cci.IMethodReference.get_GenericParameterCount();
    private sealed virtual override bool Microsoft.Cci.IMethodReference.get_IsGeneric();
    private sealed virtual override IMethodDefinition Microsoft.Cci.IMethodReference.GetResolvedMethod(EmitContext context);
    private sealed virtual override ImmutableArray`1<IParameterTypeInformation> Microsoft.Cci.IMethodReference.get_ExtraParameters();
    private sealed virtual override IGenericMethodInstanceReference Microsoft.Cci.IMethodReference.get_AsGenericMethodInstanceReference();
    private sealed virtual override ISpecializedMethodReference Microsoft.Cci.IMethodReference.get_AsSpecializedMethodReference();
    private sealed virtual override CallingConvention Microsoft.Cci.ISignature.get_CallingConvention();
    private sealed virtual override ushort Microsoft.Cci.ISignature.get_ParameterCount();
    private sealed virtual override ImmutableArray`1<IParameterTypeInformation> Microsoft.Cci.ISignature.GetParameters(EmitContext context);
    private sealed virtual override ImmutableArray`1<ICustomModifier> Microsoft.Cci.ISignature.get_ReturnValueCustomModifiers();
    private sealed virtual override bool Microsoft.Cci.ISignature.get_ReturnValueIsByRef();
    private sealed virtual override ITypeReference Microsoft.Cci.ISignature.GetType(EmitContext context);
}
internal abstract class Microsoft.CodeAnalysis.Emit.PEModuleBuilder`9 : CommonPEModuleBuilder {
    private RootModuleType _rootModuleType;
    private TSourceModuleSymbol _sourceModule;
    private TCompilation _compilation;
    private OutputKind _outputKind;
    private EmitOptions _emitOptions;
    private ModulePropertiesForSerialization _serializationProperties;
    private ConcurrentCache`2<ValueTuple`2<string, string>, string> _normalizedPathsCache;
    protected Func`2<TAssemblySymbol, AssemblyIdentity> assemblySymbolMapper;
    private TokenMap`1<IReference> _referencesInILMap;
    private StringTokenMap _stringsInILMap;
    private ConcurrentDictionary`2<TMethodSymbol, IMethodBody> _methodBodyMap;
    private TMethodSymbol _entryPoint;
    private PrivateImplementationDetails _privateImplementationDetails;
    private ArrayMethods _lazyArrayMethods;
    private HashSet`1<string> _namesOfTopLevelTypes;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IWin32Resource> <Win32Resources>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceSection <Win32ResourceSection>k__BackingField;
    internal IEnumerable`1<ResourceDescription> ManifestResources;
    internal TModuleCompilationState CompilationState;
    private ConcurrentDictionary`2<string, DebugSourceDocument> _debugDocuments;
    private ImmutableArray`1<AssemblyReferenceAlias> _lazyAssemblyReferenceAliases;
    private ConcurrentDictionary`2<TNamedTypeSymbol, SynthesizedDefinitions<TCompilation, TSourceModuleSymbol, TAssemblySymbol, TTypeSymbol, TNamedTypeSymbol, TMethodSymbol, TSyntaxNode, TEmbeddedTypesManager, TModuleCompilationState>> _synthesizedDefs;
    private IEnumerable`1<ManagedResource> _lazyManagedResources;
    private IEnumerable`1<IWin32Resource> Win32Resources { get; internal set; }
    private ResourceSection Win32ResourceSection { get; internal set; }
    public TEmbeddedTypesManager EmbeddedTypesManagerOpt { get; }
    public int CurrentGenerationOrdinal { get; }
    internal EmitOptions EmitOptions { get; }
    internal string ModuleName { get; }
    internal string Name { get; }
    internal TAssemblySymbol CorLibrary { get; }
    internal byte LinkerMajorVersion { get; }
    internal byte LinkerMinorVersion { get; }
    protected bool HaveDeterminedTopLevelTypes { get; }
    internal OutputKind OutputKind { get; }
    internal TSourceModuleSymbol SourceModule { get; }
    internal TCompilation Compilation { get; }
    internal Compilation CommonCompilation { get; }
    internal CommonModuleCompilationState CommonModuleCompilationState { get; }
    internal CommonEmbeddedTypesManager CommonEmbeddedTypesManagerOpt { get; }
    internal IMethodReference EntryPoint { get; }
    public ArrayMethods ArrayMethods { get; }
    internal PrivateImplementationDetails PrivateImplClass { get; }
    internal bool SupportsPrivateImplClass { get; }
    private ushort Microsoft.Cci.IModule.MajorSubsystemVersion { get; }
    private ushort Microsoft.Cci.IModule.MinorSubsystemVersion { get; }
    private byte Microsoft.Cci.IModule.LinkerMajorVersion { get; }
    private byte Microsoft.Cci.IModule.LinkerMinorVersion { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IModule.AssemblyAttributes { get; }
    private IEnumerable`1<SecurityAttribute> Microsoft.Cci.IModule.AssemblySecurityAttributes { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IModule.ModuleAttributes { get; }
    private bool Microsoft.Cci.IModule.GenerateVisualBasicStylePdb { get; }
    protected bool GenerateVisualBasicStylePdb { get; }
    private IEnumerable`1<string> Microsoft.Cci.IModule.LinkedAssembliesDebugInfo { get; }
    protected IEnumerable`1<string> LinkedAssembliesDebugInfo { get; }
    private string Microsoft.Cci.IModule.DefaultNamespace { get; }
    protected string DefaultNamespace { get; }
    private IMethodReference Microsoft.Cci.IModule.EntryPoint { get; }
    private IAssembly Microsoft.Cci.IModule.AsAssembly { get; }
    private ulong Microsoft.Cci.IModule.BaseAddress { get; }
    private ushort Microsoft.Cci.IModule.DllCharacteristics { get; }
    private UInt32 Microsoft.Cci.IModule.FileAlignment { get; }
    private bool Microsoft.Cci.IModule.ILOnly { get; }
    private ModuleKind Microsoft.Cci.IModule.Kind { get; }
    private byte Microsoft.Cci.IModule.MetadataFormatMajorVersion { get; }
    private byte Microsoft.Cci.IModule.MetadataFormatMinorVersion { get; }
    private string Microsoft.Cci.IModule.ModuleName { get; }
    private IEnumerable`1<IModuleReference> Microsoft.Cci.IModule.ModuleReferences { get; }
    private Guid Microsoft.Cci.IModule.PersistentIdentifier { get; }
    private bool Microsoft.Cci.IModule.StrongNameSigned { get; }
    private Machine Microsoft.Cci.IModule.Machine { get; }
    private bool Microsoft.Cci.IModule.RequiresStartupStub { get; }
    private bool Microsoft.Cci.IModule.Prefers32bits { get; }
    private bool Microsoft.Cci.IModule.RequiresAmdInstructionSet { get; }
    private bool Microsoft.Cci.IModule.Requires32bits { get; }
    private bool Microsoft.Cci.IModule.Requires64bits { get; }
    private ulong Microsoft.Cci.IModule.SizeOfHeapCommit { get; }
    private ulong Microsoft.Cci.IModule.SizeOfHeapReserve { get; }
    private ulong Microsoft.Cci.IModule.SizeOfStackCommit { get; }
    private ulong Microsoft.Cci.IModule.SizeOfStackReserve { get; }
    private string Microsoft.Cci.IModule.TargetRuntimeVersion { get; }
    private bool Microsoft.Cci.IModule.TrackDebugData { get; }
    private ResourceSection Microsoft.Cci.IModule.Win32ResourceSection { get; }
    private IEnumerable`1<IWin32Resource> Microsoft.Cci.IModule.Win32Resources { get; }
    private int Microsoft.Cci.IModule.HintNumberOfMethodDefinitions { get; }
    private string Microsoft.Cci.INamedEntity.Name { get; }
    protected PEModuleBuilder`9(TCompilation compilation, TSourceModuleSymbol sourceModule, ModulePropertiesForSerialization serializationProperties, IEnumerable`1<ResourceDescription> manifestResources, OutputKind outputKind, Func`2<TAssemblySymbol, AssemblyIdentity> assemblySymbolMapper, EmitOptions emitOptions, TModuleCompilationState compilationState);
    [CompilerGeneratedAttribute]
internal void set_Win32Resources(IEnumerable`1<IWin32Resource> value);
    [CompilerGeneratedAttribute]
private IEnumerable`1<IWin32Resource> get_Win32Resources();
    [CompilerGeneratedAttribute]
internal void set_Win32ResourceSection(ResourceSection value);
    [CompilerGeneratedAttribute]
private ResourceSection get_Win32ResourceSection();
    public abstract virtual TEmbeddedTypesManager get_EmbeddedTypesManagerOpt();
    public abstract virtual int get_CurrentGenerationOrdinal();
    internal sealed virtual void CompilationFinished();
    internal virtual EmitOptions get_EmitOptions();
    internal abstract virtual string get_ModuleName();
    internal abstract virtual string get_Name();
    internal abstract virtual TAssemblySymbol get_CorLibrary();
    internal abstract virtual byte get_LinkerMajorVersion();
    internal abstract virtual byte get_LinkerMinorVersion();
    internal abstract virtual IEnumerable`1<ICustomAttribute> GetSourceAssemblyAttributes();
    internal abstract virtual IEnumerable`1<SecurityAttribute> GetSourceAssemblySecurityAttributes();
    internal abstract virtual IEnumerable`1<ICustomAttribute> GetSourceModuleAttributes();
    internal abstract virtual ICustomAttribute SynthesizeAttribute(WellKnownMember attributeConstructor);
    internal abstract virtual INamedTypeReference GetSystemType(TSyntaxNode syntaxOpt, DiagnosticBag diagnostics);
    internal abstract virtual INamedTypeReference GetSpecialType(SpecialType specialType, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal sealed virtual ITypeReference EncTranslateType(ITypeSymbol type, DiagnosticBag diagnostics);
    internal virtual ITypeReference EncTranslateLocalVariableType(TTypeSymbol type, DiagnosticBag diagnostics);
    protected bool get_HaveDeterminedTopLevelTypes();
    protected bool ContainsTopLevelType(string fullEmittedName);
    internal abstract virtual IEnumerable`1<INamespaceTypeDefinition> GetTopLevelTypesCore(EmitContext context);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Emit.PEModuleBuilder`9/<GetTopLevelTypes>d__57")]
private IEnumerable`1<INamespaceTypeDefinition> GetTopLevelTypes(EmitContext context);
    internal abstract virtual IAssemblyReference Translate(TAssemblySymbol symbol, DiagnosticBag diagnostics);
    internal abstract virtual ITypeReference Translate(TTypeSymbol symbol, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal sealed virtual IAssemblyReference Translate(IAssemblySymbol symbol, DiagnosticBag diagnostics);
    internal sealed virtual ITypeReference Translate(ITypeSymbol symbol, SyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal OutputKind get_OutputKind();
    internal TSourceModuleSymbol get_SourceModule();
    internal TCompilation get_Compilation();
    internal sealed virtual Compilation get_CommonCompilation();
    internal sealed virtual CommonModuleCompilationState get_CommonModuleCompilationState();
    internal sealed virtual CommonEmbeddedTypesManager get_CommonEmbeddedTypesManagerOpt();
    internal sealed virtual IMethodReference get_EntryPoint();
    internal void SetEntryPoint(TMethodSymbol value);
    internal MetadataConstant CreateConstant(TTypeSymbol type, object value, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    private static void AddTopLevelType(HashSet`1<string> names, INamespaceTypeDefinition type);
    private static void VisitTopLevelType(NoPiaReferenceIndexer noPiaIndexer, INamespaceTypeDefinition type);
    private ImmutableArray`1<AssemblyReferenceAlias> CalculateAssemblyReferenceAliases(EmitContext context);
    public void AddSynthesizedDefinition(TNamedTypeSymbol container, INestedTypeDefinition nestedType);
    internal abstract virtual IEnumerable`1<INestedTypeDefinition> GetSynthesizedNestedTypes(TNamedTypeSymbol container);
    public IEnumerable`1<INestedTypeDefinition> GetSynthesizedTypes(TNamedTypeSymbol container);
    private SynthesizedDefinitions<TCompilation, TSourceModuleSymbol, TAssemblySymbol, TTypeSymbol, TNamedTypeSymbol, TMethodSymbol, TSyntaxNode, TEmbeddedTypesManager, TModuleCompilationState> GetCacheOfSynthesizedDefinitions(TNamedTypeSymbol container, bool addIfNotFound);
    public void AddSynthesizedDefinition(TNamedTypeSymbol container, IMethodDefinition method);
    public IEnumerable`1<IMethodDefinition> GetSynthesizedMethods(TNamedTypeSymbol container);
    public void AddSynthesizedDefinition(TNamedTypeSymbol container, IPropertyDefinition property);
    public IEnumerable`1<IPropertyDefinition> GetSynthesizedProperties(TNamedTypeSymbol container);
    public void AddSynthesizedDefinition(TNamedTypeSymbol container, IFieldDefinition field);
    public IEnumerable`1<IFieldDefinition> GetSynthesizedFields(TNamedTypeSymbol container);
    internal virtual ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> GetSynthesizedMembers();
    public ImmutableArray`1<ITypeDefinitionMember> GetSynthesizedMembers(ITypeDefinition container);
    private sealed virtual override IFieldReference Microsoft.CodeAnalysis.CodeGen.ITokenDeferral.GetFieldForData(ImmutableArray`1<byte> data, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    public abstract virtual IMethodReference GetInitArrayHelper();
    public sealed virtual ArrayMethods get_ArrayMethods();
    public sealed virtual UInt32 GetFakeSymbolTokenForIL(IReference symbol, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    public sealed virtual IReference GetReferenceFromToken(UInt32 token);
    public sealed virtual UInt32 GetFakeStringTokenForIL(string str);
    public sealed virtual string GetStringFromToken(UInt32 token);
    private sealed virtual override IEnumerable`1<IReference> Microsoft.Cci.IModule.ReferencesInIL(Int32& count);
    internal PrivateImplementationDetails GetPrivateImplClass(TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal PrivateImplementationDetails get_PrivateImplClass();
    internal virtual bool get_SupportsPrivateImplClass();
    internal IMethodBody GetMethodBody(TMethodSymbol methodSymbol);
    public void SetMethodBody(TMethodSymbol methodSymbol, IMethodBody body);
    public virtual void Dispatch(MetadataVisitor visitor);
    private sealed virtual override ushort Microsoft.Cci.IModule.get_MajorSubsystemVersion();
    private sealed virtual override ushort Microsoft.Cci.IModule.get_MinorSubsystemVersion();
    private sealed virtual override byte Microsoft.Cci.IModule.get_LinkerMajorVersion();
    private sealed virtual override byte Microsoft.Cci.IModule.get_LinkerMinorVersion();
    private sealed virtual override IEnumerable`1<INamespaceTypeDefinition> Microsoft.Cci.IModule.GetTopLevelTypes(EmitContext context);
    public abstract virtual IEnumerable`1<ITypeExport> GetExportedTypes(EmitContext context);
    private sealed virtual override ITypeReference Microsoft.Cci.IModule.GetPlatformType(PlatformType platformType, EmitContext context);
    protected abstract virtual bool IsPlatformType(ITypeReference typeRef, PlatformType platformType);
    private sealed virtual override bool Microsoft.Cci.IModule.IsPlatformType(ITypeReference typeRef, PlatformType platformType);
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IModule.get_AssemblyAttributes();
    private sealed virtual override IEnumerable`1<SecurityAttribute> Microsoft.Cci.IModule.get_AssemblySecurityAttributes();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IModule.get_ModuleAttributes();
    private sealed virtual override ImmutableArray`1<AssemblyReferenceAlias> Microsoft.Cci.IModule.GetAssemblyReferenceAliases(EmitContext context);
    private sealed virtual override bool Microsoft.Cci.IModule.get_GenerateVisualBasicStylePdb();
    protected abstract virtual bool get_GenerateVisualBasicStylePdb();
    private sealed virtual override IEnumerable`1<string> Microsoft.Cci.IModule.get_LinkedAssembliesDebugInfo();
    protected abstract virtual IEnumerable`1<string> get_LinkedAssembliesDebugInfo();
    private sealed virtual override ImmutableArray`1<UsedNamespaceOrType> Microsoft.Cci.IModule.GetImports();
    protected abstract virtual ImmutableArray`1<UsedNamespaceOrType> GetImports();
    private sealed virtual override string Microsoft.Cci.IModule.get_DefaultNamespace();
    protected abstract virtual string get_DefaultNamespace();
    private sealed virtual override IMethodReference Microsoft.Cci.IModule.get_EntryPoint();
    protected abstract virtual IAssemblyReference GetCorLibraryReferenceToEmit(EmitContext context);
    protected abstract virtual MultiDictionary`2<DebugSourceDocument, DefinitionWithLocation> GetSymbolToLocationMap();
    private sealed virtual override MultiDictionary`2<DebugSourceDocument, DefinitionWithLocation> Microsoft.Cci.IModule.GetSymbolToLocationMap();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Emit.PEModuleBuilder`9/<Microsoft-Cci-IModule-GetAssemblyReferences>d__151")]
private sealed virtual override IEnumerable`1<IAssemblyReference> Microsoft.Cci.IModule.GetAssemblyReferences(EmitContext context);
    protected abstract virtual IEnumerable`1<IAssemblyReference> GetAssemblyReferencesFromAddedModules(DiagnosticBag diagnostics);
    private sealed virtual override IEnumerable`1<ManagedResource> Microsoft.Cci.IModule.GetResources(EmitContext context);
    protected abstract virtual void AddEmbeddedResourcesFromAddedModules(ArrayBuilder`1<ManagedResource> builder, DiagnosticBag diagnostics);
    private sealed virtual override IAssembly Microsoft.Cci.IModule.get_AsAssembly();
    private sealed virtual override IAssemblyReference Microsoft.Cci.IModule.GetCorLibrary(EmitContext context);
    private sealed virtual override ulong Microsoft.Cci.IModule.get_BaseAddress();
    private sealed virtual override IAssembly Microsoft.Cci.IModule.GetContainingAssembly(EmitContext context);
    private sealed virtual override IAssemblyReference Microsoft.Cci.IModuleReference.GetContainingAssembly(EmitContext context);
    private sealed virtual override ushort Microsoft.Cci.IModule.get_DllCharacteristics();
    private sealed virtual override UInt32 Microsoft.Cci.IModule.get_FileAlignment();
    private sealed virtual override IEnumerable`1<string> Microsoft.Cci.IModule.GetStrings();
    private sealed virtual override bool Microsoft.Cci.IModule.get_ILOnly();
    private sealed virtual override ModuleKind Microsoft.Cci.IModule.get_Kind();
    private sealed virtual override byte Microsoft.Cci.IModule.get_MetadataFormatMajorVersion();
    private sealed virtual override byte Microsoft.Cci.IModule.get_MetadataFormatMinorVersion();
    private sealed virtual override string Microsoft.Cci.IModule.get_ModuleName();
    private sealed virtual override IEnumerable`1<IModuleReference> Microsoft.Cci.IModule.get_ModuleReferences();
    private sealed virtual override Guid Microsoft.Cci.IModule.get_PersistentIdentifier();
    private sealed virtual override bool Microsoft.Cci.IModule.get_StrongNameSigned();
    private sealed virtual override Machine Microsoft.Cci.IModule.get_Machine();
    private sealed virtual override bool Microsoft.Cci.IModule.get_RequiresStartupStub();
    private sealed virtual override bool Microsoft.Cci.IModule.get_Prefers32bits();
    private sealed virtual override bool Microsoft.Cci.IModule.get_RequiresAmdInstructionSet();
    private sealed virtual override bool Microsoft.Cci.IModule.get_Requires32bits();
    private sealed virtual override bool Microsoft.Cci.IModule.get_Requires64bits();
    private sealed virtual override ulong Microsoft.Cci.IModule.get_SizeOfHeapCommit();
    private sealed virtual override ulong Microsoft.Cci.IModule.get_SizeOfHeapReserve();
    private sealed virtual override ulong Microsoft.Cci.IModule.get_SizeOfStackCommit();
    private sealed virtual override ulong Microsoft.Cci.IModule.get_SizeOfStackReserve();
    private sealed virtual override string Microsoft.Cci.IModule.get_TargetRuntimeVersion();
    private sealed virtual override bool Microsoft.Cci.IModule.get_TrackDebugData();
    private sealed virtual override ResourceSection Microsoft.Cci.IModule.get_Win32ResourceSection();
    private sealed virtual override IEnumerable`1<IWin32Resource> Microsoft.Cci.IModule.get_Win32Resources();
    private sealed virtual override int Microsoft.Cci.IModule.get_HintNumberOfMethodDefinitions();
    private sealed virtual override string Microsoft.Cci.INamedEntity.get_Name();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.GetAttributes(EmitContext context);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
    internal void AddDebugDocument(DebugSourceDocument document);
    internal DebugSourceDocument TryGetDebugDocument(string path, string basePath);
    internal DebugSourceDocument TryGetDebugDocumentForNormalizedPath(string normalizedPath);
    internal DebugSourceDocument GetOrAddDebugDocument(string path, string basePath, Func`2<string, DebugSourceDocument> factory);
    internal string NormalizeDebugDocumentPath(string path, string basePath);
}
public class Microsoft.CodeAnalysis.Emit.SemanticEdit : ValueType {
    [CompilerGeneratedAttribute]
private SemanticEditKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <OldSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <NewSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<SyntaxNode, SyntaxNode> <SyntaxMap>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveLocalVariables>k__BackingField;
    public SemanticEditKind Kind { get; }
    public ISymbol OldSymbol { get; }
    public ISymbol NewSymbol { get; }
    public Func`2<SyntaxNode, SyntaxNode> SyntaxMap { get; }
    public bool PreserveLocalVariables { get; }
    public SemanticEdit(SemanticEditKind kind, ISymbol oldSymbol, ISymbol newSymbol, Func`2<SyntaxNode, SyntaxNode> syntaxMap, bool preserveLocalVariables);
    [CompilerGeneratedAttribute]
public SemanticEditKind get_Kind();
    [CompilerGeneratedAttribute]
public ISymbol get_OldSymbol();
    [CompilerGeneratedAttribute]
public ISymbol get_NewSymbol();
    [CompilerGeneratedAttribute]
public Func`2<SyntaxNode, SyntaxNode> get_SyntaxMap();
    [CompilerGeneratedAttribute]
public bool get_PreserveLocalVariables();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SemanticEdit other);
}
public enum Microsoft.CodeAnalysis.Emit.SemanticEditKind : Enum {
    public int value__;
    public static SemanticEditKind None;
    public static SemanticEditKind Update;
    public static SemanticEditKind Insert;
    public static SemanticEditKind Delete;
}
internal enum Microsoft.CodeAnalysis.Emit.SymbolChange : Enum {
    public int value__;
    public static SymbolChange None;
    public static SymbolChange ContainsChanges;
    public static SymbolChange Updated;
    public static SymbolChange Added;
}
internal class Microsoft.CodeAnalysis.Emit.SymbolChanges : object {
    private DefinitionMap _definitionMap;
    private IReadOnlyDictionary`2<ISymbol, SymbolChange> _changes;
    private Func`2<ISymbol, bool> _isAddedSymbol;
    public SymbolChanges(DefinitionMap definitionMap, IEnumerable`1<SemanticEdit> edits, Func`2<ISymbol, bool> isAddedSymbol);
    public bool IsAdded(ISymbol symbol);
    public bool RequiresCompilation(ISymbol symbol);
    public SymbolChange GetChange(IDefinition def);
    private SymbolChange GetChange(ISymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Emit.SymbolChanges/<GetTopLevelTypes>d__8")]
public IEnumerable`1<INamespaceTypeDefinition> GetTopLevelTypes(EmitContext context);
    private static IReadOnlyDictionary`2<ISymbol, SymbolChange> CalculateChanges(IEnumerable`1<SemanticEdit> edits);
    private static void AddContainingTypes(Dictionary`2<ISymbol, SymbolChange> changes, ISymbol symbol);
    private static ISymbol GetContainingSymbol(ISymbol symbol);
}
internal abstract class Microsoft.CodeAnalysis.Emit.SymbolMatcher : object {
    public abstract virtual ITypeReference MapReference(ITypeReference reference);
    public abstract virtual IDefinition MapDefinition(IDefinition reference);
    public EmitBaseline MapBaselineToCompilation(EmitBaseline baseline, Compilation targetCompilation, CommonPEModuleBuilder targetModuleBuilder, ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> mappedSynthesizedMembers);
    private IReadOnlyDictionary`2<K, V> MapDefinitions(IReadOnlyDictionary`2<K, V> items);
    private IReadOnlyDictionary`2<UInt32, AddedOrChangedMethodInfo> MapAddedOrChangedMethods(IReadOnlyDictionary`2<UInt32, AddedOrChangedMethodInfo> addedOrChangedMethods);
    private IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> MapAnonymousTypes(IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> anonymousTypeMap);
    internal ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> MapSynthesizedMembers(ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> previousMembers, ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> newMembers);
}
internal class Microsoft.CodeAnalysis.Emit.TypeExport`1 : object {
    public TypeSymbol AliasedType;
    private ITypeReference Microsoft.Cci.ITypeExport.ExportedType { get; }
    public TypeExport`1(TypeSymbol aliasedType);
    private sealed virtual override ITypeReference Microsoft.Cci.ITypeExport.get_ExportedType();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.GetAttributes(EmitContext context);
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext m);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.EnumBounds : object {
    [ExtensionAttribute]
internal static bool IsValid(OptimizationLevel value);
    [ExtensionAttribute]
internal static bool IsValid(Platform value);
    [ExtensionAttribute]
internal static bool Requires64Bit(Platform value);
    [ExtensionAttribute]
internal static bool Requires32Bit(Platform value);
    [ExtensionAttribute]
internal static bool RequiresAmdInstructionSet(Platform value);
    [ExtensionAttribute]
internal static bool IsValid(MetadataImageKind kind);
    [ExtensionAttribute]
internal static bool IsValid(OutputKind value);
    [ExtensionAttribute]
internal static string GetDefaultExtension(OutputKind kind);
    [ExtensionAttribute]
internal static bool IsApplication(OutputKind kind);
    [ExtensionAttribute]
internal static bool IsNetModule(OutputKind kind);
    [ExtensionAttribute]
internal static bool IsWindowsRuntime(OutputKind kind);
    [ExtensionAttribute]
internal static bool IsValid(SymbolDisplayPartKind value);
}
internal static class Microsoft.CodeAnalysis.EnumConstantHelper : object {
    internal static EnumOverflowKind OffsetValue(ConstantValue constantValue, UInt32 offset, ConstantValue& offsetValue);
    private static EnumOverflowKind CheckOverflow(long maxOffset, long previous, UInt32 offset);
    private static EnumOverflowKind CheckOverflow(ulong maxOffset, ulong previous, UInt32 offset);
    private static EnumOverflowKind CheckOverflow(ulong maxOffset, UInt32 offset);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.EnumerableExtensions : object {
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, V> ToImmutableDictionaryOrEmpty(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, V> ToImmutableDictionaryOrEmpty(IEnumerable`1<KeyValuePair`2<K, V>> items, IEqualityComparer`1<K> keyComparer);
    [ExtensionAttribute]
internal static IList`1<IList`1<T>> Transpose(IEnumerable`1<IEnumerable`1<T>> data);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.EnumerableExtensions/<TransposeInternal>d__3`1")]
[ExtensionAttribute]
private static IEnumerable`1<IList`1<T>> TransposeInternal(IEnumerable`1<IEnumerable`1<T>> data);
    [ExtensionAttribute]
internal static void AddAllValues(IDictionary`2<K, ImmutableArray`1<T>> data, ArrayBuilder`1<T> builder);
    [ExtensionAttribute]
internal static Dictionary`2<K, ImmutableArray`1<T>> ToDictionary(IEnumerable`1<T> data, Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
    [ExtensionAttribute]
internal static TSource AsSingleton(IEnumerable`1<TSource> source);
}
internal enum Microsoft.CodeAnalysis.EnumOverflowKind : Enum {
    public int value__;
    public static EnumOverflowKind NoOverflow;
    public static EnumOverflowKind OverflowReport;
    public static EnumOverflowKind OverflowIgnore;
}
internal class Microsoft.CodeAnalysis.ErrorLogger : object {
    internal static string OutputFormatVersion;
    private static string indentDelta;
    private static char groupStartChar;
    private static char groupEndChar;
    private static char listStartChar;
    private static char listEndChar;
    private StreamWriter _writer;
    private string _currentIndent;
    private bool _reportedAnyIssues;
    public ErrorLogger(Stream stream, string toolName, string toolFileVersion, Version toolAssemblyVersion);
    private void WriteHeader(string toolName, string toolFileVersion, Version toolAssemblyVersion);
    private Value GetToolInfo(string toolName, string toolFileVersion, Version toolAssemblyVersion);
    private string GetToolFileVersionSubStr(string toolFileVersion);
    internal static void LogDiagnostic(Diagnostic diagnostic, CultureInfo culture, ErrorLogger errorLogger);
    private void LogIssue(Issue issue);
    private Value GetIssueValue(Issue issue);
    private Value GetLocationsValue(Location location, IReadOnlyList`1<Location> additionalLocations);
    private Value GetLocationValue(Location location);
    private Value GetSpanInfoValue(FileLinePositionSpan lineSpan);
    private Value GetPropertiesValue(Issue issue);
    private void WriteKeyValuePair(KeyValuePair`2<string, Value> kvp, bool isFirst);
    private void WriteKeyValuePair(string key, Value value, bool isFirst);
    private void WriteSimpleKeyValuePair(string key, string value, bool isFirst);
    private void WriteKey(string key, bool isFirst);
    private void WriteValue(Value value, bool isFirst, bool valueInList);
    private void WriteValue(string value);
    private void WriteValue(int value);
    private void StartNewEntry(bool isFirst);
    private void StartGroup();
    private void EndGroup();
    private void StartList();
    private void EndList();
    private void StartGroupOrListCommon(char startChar);
    private void EndGroupOrListCommon(char endChar);
    private void IncreaseIndentation();
    private void DecreaseIndentation();
    private KeyValuePair`2<string, Value> CreateSimpleKeyValuePair(string key, string value);
    private KeyValuePair`2<string, Value> CreateSimpleKeyValuePair(string key, int value);
    public sealed virtual void Dispose();
}
internal class Microsoft.CodeAnalysis.ExternalFileLocation : Location {
    private TextSpan _sourceSpan;
    private FileLinePositionSpan _lineSpan;
    public TextSpan SourceSpan { get; }
    public LocationKind Kind { get; }
    internal ExternalFileLocation(string filePath, TextSpan sourceSpan, LinePositionSpan lineSpan);
    public virtual TextSpan get_SourceSpan();
    public virtual FileLinePositionSpan GetLineSpan();
    public virtual FileLinePositionSpan GetMappedLineSpan();
    public virtual LocationKind get_Kind();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ExternalFileLocation obj);
    public virtual int GetHashCode();
}
internal static class Microsoft.CodeAnalysis.FailFast : object {
    [DebuggerHiddenAttribute]
internal static void OnFatalException(Exception exception);
    [ConditionalAttribute("DEBUG")]
[DebuggerHiddenAttribute]
internal static void Assert(bool condition, string message);
}
internal static class Microsoft.CodeAnalysis.FatalError : object {
    private static Action`1<Exception> s_fatalHandler;
    private static Action`1<Exception> s_nonFatalHandler;
    private static Exception s_reportedException;
    private static string s_reportedExceptionMessage;
    public static Action`1<Exception> Handler { get; public set; }
    public static Action`1<Exception> NonFatalHandler { get; public set; }
    public static Action`1<Exception> get_Handler();
    public static void set_Handler(Action`1<Exception> value);
    public static Action`1<Exception> get_NonFatalHandler();
    public static void set_NonFatalHandler(Action`1<Exception> value);
    public static void OverwriteHandler(Action`1<Exception> value);
    [DebuggerHiddenAttribute]
public static bool ReportUnlessCanceled(Exception exception);
    [DebuggerHiddenAttribute]
public static bool ReportWithoutCrashUnlessCanceled(Exception exception);
    [DebuggerHiddenAttribute]
public static bool ReportUnlessNotImplemented(Exception exception);
    [DebuggerHiddenAttribute]
public static bool Report(Exception exception);
    [DebuggerHiddenAttribute]
public static bool ReportWithoutCrash(Exception exception);
    private static void Report(Exception exception, Action`1<Exception> handler);
}
public class Microsoft.CodeAnalysis.FileLinePositionSpan : ValueType {
    private string _path;
    private LinePositionSpan _span;
    private bool _hasMappedPath;
    public string Path { get; }
    public bool HasMappedPath { get; }
    public LinePosition StartLinePosition { get; }
    public LinePosition EndLinePosition { get; }
    public LinePositionSpan Span { get; }
    public bool IsValid { get; }
    public FileLinePositionSpan(string path, LinePosition start, LinePosition end);
    public FileLinePositionSpan(string path, LinePositionSpan span);
    internal FileLinePositionSpan(string path, LinePositionSpan span, bool hasMappedPath);
    public string get_Path();
    public bool get_HasMappedPath();
    public LinePosition get_StartLinePosition();
    public LinePosition get_EndLinePosition();
    public LinePositionSpan get_Span();
    public bool get_IsValid();
    public sealed virtual bool Equals(FileLinePositionSpan other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.FileSystemExtensions : object {
    [ExtensionAttribute]
public static EmitResult Emit(Compilation compilation, string outputPath, string pdbPath, string xmlDocPath, string win32ResourcesPath, IEnumerable`1<ResourceDescription> manifestResources, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FormattedSymbol : object {
    private ISymbol _symbol;
    private SymbolDisplayFormat _symbolDisplayFormat;
    internal FormattedSymbol(ISymbol symbol, SymbolDisplayFormat symbolDisplayFormat);
    public virtual string ToString();
}
internal class Microsoft.CodeAnalysis.FormattedSymbolList : object {
    private IEnumerable`1<ISymbol> _symbols;
    private SymbolDisplayFormat _symbolDisplayFormat;
    internal FormattedSymbolList(IEnumerable`1<ISymbol> symbols, SymbolDisplayFormat symbolDisplayFormat);
    public virtual string ToString();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal abstract class Microsoft.CodeAnalysis.GreenNode : object {
    internal static int ListKind;
    private ushort _kind;
    protected NodeFlags flags;
    private byte _slotCount;
    private int _fullWidth;
    private static ConditionalWeakTable`2<GreenNode, DiagnosticInfo[]> s_diagnosticsTable;
    private static ConditionalWeakTable`2<GreenNode, SyntaxAnnotation[]> s_annotationsTable;
    private static DiagnosticInfo[] s_noDiagnostics;
    private static SyntaxAnnotation[] s_noAnnotations;
    private static IEnumerable`1<SyntaxAnnotation> s_noAnnotationsEnumerable;
    private static ushort ExtendedSerializationInfoMask;
    internal static int MaxCachedChildNum;
    public string Language { get; }
    public int RawKind { get; }
    public bool IsList { get; }
    public string KindText { get; }
    public bool IsStructuredTrivia { get; }
    public bool IsDirective { get; }
    public bool IsToken { get; }
    public int SlotCount { get; protected set; }
    internal NodeFlags Flags { get; }
    internal bool IsMissing { get; }
    internal bool ParsedInAsync { get; }
    internal bool ParsedInQuery { get; }
    internal bool ParsedInIterator { get; }
    public bool ContainsSkippedText { get; }
    public bool ContainsStructuredTrivia { get; }
    public bool ContainsDirectives { get; }
    public bool ContainsDiagnostics { get; }
    public bool ContainsAnnotations { get; }
    public int FullWidth { get; protected set; }
    public int Width { get; }
    public bool HasLeadingTrivia { get; }
    public bool HasTrailingTrivia { get; }
    public int RawContextualKind { get; }
    public AbstractSyntaxNavigator Navigator { get; }
    internal bool IsCacheable { get; }
    protected GreenNode(ushort kind);
    protected GreenNode(ushort kind, int fullWidth);
    protected GreenNode(ushort kind, DiagnosticInfo[] diagnostics, int fullWidth);
    protected GreenNode(ushort kind, DiagnosticInfo[] diagnostics);
    protected GreenNode(ushort kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    protected GreenNode(ushort kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations, int fullWidth);
    internal GreenNode(ObjectReader reader);
    private static GreenNode();
    private string GetDebuggerDisplay();
    protected void AdjustFlagsAndWidth(GreenNode node);
    public abstract virtual string get_Language();
    public int get_RawKind();
    public bool get_IsList();
    public abstract virtual string get_KindText();
    public virtual bool get_IsStructuredTrivia();
    public virtual bool get_IsDirective();
    public virtual bool get_IsToken();
    public int get_SlotCount();
    protected void set_SlotCount(int value);
    internal abstract virtual GreenNode GetSlot(int index);
    protected virtual int GetSlotCount();
    public abstract virtual int GetSlotOffset(int index);
    public virtual int FindSlotIndexContainingOffset(int offset);
    internal NodeFlags get_Flags();
    internal void SetFlags(NodeFlags flags);
    internal void ClearFlags(NodeFlags flags);
    internal bool get_IsMissing();
    internal bool get_ParsedInAsync();
    internal bool get_ParsedInQuery();
    internal bool get_ParsedInIterator();
    public bool get_ContainsSkippedText();
    public bool get_ContainsStructuredTrivia();
    public bool get_ContainsDirectives();
    public bool get_ContainsDiagnostics();
    public bool get_ContainsAnnotations();
    public int get_FullWidth();
    protected void set_FullWidth(int value);
    public virtual int get_Width();
    public virtual int GetLeadingTriviaWidth();
    public virtual int GetTrailingTriviaWidth();
    public bool get_HasLeadingTrivia();
    public bool get_HasTrailingTrivia();
    private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    internal virtual void WriteTo(ObjectWriter writer);
    private sealed virtual override Func`2<ObjectReader, object> Roslyn.Utilities.IObjectReadable.GetReader();
    internal abstract virtual Func`2<ObjectReader, object> GetReader();
    public bool HasAnnotations(string annotationKind);
    public bool HasAnnotations(IEnumerable`1<string> annotationKinds);
    public bool HasAnnotation(SyntaxAnnotation annotation);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(string annotationKind);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.GreenNode/<GetAnnotationsSlow>d__83")]
private static IEnumerable`1<SyntaxAnnotation> GetAnnotationsSlow(SyntaxAnnotation[] annotations, string annotationKind);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(IEnumerable`1<string> annotationKinds);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.GreenNode/<GetAnnotationsSlow>d__85")]
private static IEnumerable`1<SyntaxAnnotation> GetAnnotationsSlow(SyntaxAnnotation[] annotations, IEnumerable`1<string> annotationKinds);
    public SyntaxAnnotation[] GetAnnotations();
    internal abstract virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal DiagnosticInfo[] GetDiagnostics();
    internal abstract virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    public abstract virtual string ToFullString();
    public virtual void WriteTo(TextWriter writer);
    protected internal virtual void WriteTo(TextWriter writer, bool leading, bool trailing);
    public virtual int get_RawContextualKind();
    public virtual object GetValue();
    public virtual string GetValueText();
    public virtual GreenNode GetLeadingTriviaCore();
    public virtual GreenNode GetTrailingTriviaCore();
    public abstract virtual AbstractSyntaxNavigator get_Navigator();
    public virtual GreenNode WithLeadingTrivia(GreenNode trivia);
    public virtual GreenNode WithTrailingTrivia(GreenNode trivia);
    internal GreenNode GetFirstTerminal();
    internal GreenNode GetLastTerminal();
    internal GreenNode GetLastNonmissingTerminal();
    public virtual bool IsEquivalentTo(GreenNode other);
    private static bool EquivalentToInternal(GreenNode node1, GreenNode node2);
    public abstract virtual SyntaxNode GetStructure(SyntaxTrivia parentTrivia);
    public abstract virtual GreenNode CreateList(IEnumerable`1<GreenNode> nodes, bool alwaysCreateListNode);
    public abstract virtual SyntaxToken CreateSeparator(SyntaxNode element);
    public abstract virtual bool IsTriviaWithEndOfLine();
    public SyntaxNode CreateRed();
    internal abstract virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    internal bool get_IsCacheable();
    internal int GetCacheHash();
    internal bool IsCacheEquivalent(int kind, NodeFlags flags, GreenNode child1);
    internal bool IsCacheEquivalent(int kind, NodeFlags flags, GreenNode child1, GreenNode child2);
    internal bool IsCacheEquivalent(int kind, NodeFlags flags, GreenNode child1, GreenNode child2, GreenNode child3);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.GreenNodeExtensions : object {
    [ExtensionAttribute]
public static TNode WithAnnotationsGreen(TNode node, IEnumerable`1<SyntaxAnnotation> annotations);
    [ExtensionAttribute]
public static TNode WithAdditionalAnnotationsGreen(TNode node, IEnumerable`1<SyntaxAnnotation> annotations);
    [ExtensionAttribute]
public static TNode WithoutAnnotationsGreen(TNode node, IEnumerable`1<SyntaxAnnotation> annotations);
    [ExtensionAttribute]
public static TNode WithDiagnosticsGreen(TNode node, DiagnosticInfo[] diagnostics);
    [ExtensionAttribute]
public static TNode WithoutDiagnosticsGreen(TNode node);
}
internal class Microsoft.CodeAnalysis.Grouping`2 : object {
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    private IEnumerable`1<TElement> _elements;
    public TKey Key { get; }
    public Grouping`2(TKey key, IEnumerable`1<TElement> elements);
    public Grouping`2(KeyValuePair`2<TKey, IEnumerable`1<TElement>> pair);
    [CompilerGeneratedAttribute]
public sealed virtual TKey get_Key();
    public sealed virtual IEnumerator`1<TElement> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.HashSetExtensions : object {
    [ExtensionAttribute]
internal static bool IsNullOrEmpty(HashSet`1<T> hashSet);
}
public interface Microsoft.CodeAnalysis.IAliasSymbol {
    public INamespaceOrTypeSymbol Target { get; }
    public abstract virtual INamespaceOrTypeSymbol get_Target();
}
public interface Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader {
    public abstract virtual Assembly LoadFromPath(string fullPath);
    public abstract virtual void AddDependencyLocation(string fullPath);
}
public interface Microsoft.CodeAnalysis.IArrayTypeSymbol {
    public int Rank { get; }
    public ITypeSymbol ElementType { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public abstract virtual int get_Rank();
    public abstract virtual ITypeSymbol get_ElementType();
    public abstract virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public abstract virtual bool Equals(IArrayTypeSymbol other);
}
public interface Microsoft.CodeAnalysis.IAssemblySymbol {
    public bool IsInteractive { get; }
    public AssemblyIdentity Identity { get; }
    public INamespaceSymbol GlobalNamespace { get; }
    public IEnumerable`1<IModuleSymbol> Modules { get; }
    public ICollection`1<string> TypeNames { get; }
    public ICollection`1<string> NamespaceNames { get; }
    public bool MightContainExtensionMethods { get; }
    public abstract virtual bool get_IsInteractive();
    public abstract virtual AssemblyIdentity get_Identity();
    public abstract virtual INamespaceSymbol get_GlobalNamespace();
    public abstract virtual IEnumerable`1<IModuleSymbol> get_Modules();
    public abstract virtual ICollection`1<string> get_TypeNames();
    public abstract virtual ICollection`1<string> get_NamespaceNames();
    public abstract virtual bool GivesAccessTo(IAssemblySymbol toAssembly);
    public abstract virtual INamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName);
    public abstract virtual bool get_MightContainExtensionMethods();
    public abstract virtual INamedTypeSymbol ResolveForwardedType(string fullyQualifiedMetadataName);
}
internal class Microsoft.CodeAnalysis.IdentifierCollection : object {
    private Dictionary`2<string, object> _map;
    public IdentifierCollection(IEnumerable`1<string> identifiers);
    public void AddIdentifiers(IEnumerable`1<string> identifiers);
    public void AddIdentifier(string identifier);
    private void AddAdditionalSpelling(string identifier, object value);
    private void AddInitialSpelling(string identifier);
    public bool ContainsIdentifier(string identifier, bool caseSensitive);
    private bool CaseInsensitiveContains(string identifier);
    private bool CaseSensitiveContains(string identifier);
    public ICollection`1<string> AsCaseSensitiveCollection();
    public ICollection`1<string> AsCaseInsensitiveCollection();
}
public interface Microsoft.CodeAnalysis.IDynamicTypeSymbol {
}
public interface Microsoft.CodeAnalysis.IErrorTypeSymbol {
    public ImmutableArray`1<ISymbol> CandidateSymbols { get; }
    public CandidateReason CandidateReason { get; }
    public abstract virtual ImmutableArray`1<ISymbol> get_CandidateSymbols();
    public abstract virtual CandidateReason get_CandidateReason();
}
public interface Microsoft.CodeAnalysis.IEventSymbol {
    public ITypeSymbol Type { get; }
    public bool IsWindowsRuntimeEvent { get; }
    public IMethodSymbol AddMethod { get; }
    public IMethodSymbol RemoveMethod { get; }
    public IMethodSymbol RaiseMethod { get; }
    public IEventSymbol OriginalDefinition { get; }
    public IEventSymbol OverriddenEvent { get; }
    public ImmutableArray`1<IEventSymbol> ExplicitInterfaceImplementations { get; }
    public abstract virtual ITypeSymbol get_Type();
    public abstract virtual bool get_IsWindowsRuntimeEvent();
    public abstract virtual IMethodSymbol get_AddMethod();
    public abstract virtual IMethodSymbol get_RemoveMethod();
    public abstract virtual IMethodSymbol get_RaiseMethod();
    public abstract virtual IEventSymbol get_OriginalDefinition();
    public abstract virtual IEventSymbol get_OverriddenEvent();
    public abstract virtual ImmutableArray`1<IEventSymbol> get_ExplicitInterfaceImplementations();
}
public interface Microsoft.CodeAnalysis.IFieldSymbol {
    public ISymbol AssociatedSymbol { get; }
    public bool IsConst { get; }
    public bool IsReadOnly { get; }
    public bool IsVolatile { get; }
    public ITypeSymbol Type { get; }
    public bool HasConstantValue { get; }
    public object ConstantValue { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public IFieldSymbol OriginalDefinition { get; }
    public abstract virtual ISymbol get_AssociatedSymbol();
    public abstract virtual bool get_IsConst();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsVolatile();
    public abstract virtual ITypeSymbol get_Type();
    public abstract virtual bool get_HasConstantValue();
    public abstract virtual object get_ConstantValue();
    public abstract virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public abstract virtual IFieldSymbol get_OriginalDefinition();
}
public interface Microsoft.CodeAnalysis.ILabelSymbol {
    public IMethodSymbol ContainingMethod { get; }
    public abstract virtual IMethodSymbol get_ContainingMethod();
}
public interface Microsoft.CodeAnalysis.ILocalSymbol {
    public ITypeSymbol Type { get; }
    public bool IsConst { get; }
    public bool HasConstantValue { get; }
    public object ConstantValue { get; }
    public bool IsFunctionValue { get; }
    public abstract virtual ITypeSymbol get_Type();
    public abstract virtual bool get_IsConst();
    public abstract virtual bool get_HasConstantValue();
    public abstract virtual object get_ConstantValue();
    public abstract virtual bool get_IsFunctionValue();
}
internal interface Microsoft.CodeAnalysis.ILocalSymbolInternal {
    public bool IsImportedFromMetadata { get; }
    public SynthesizedLocalKind SynthesizedKind { get; }
    public abstract virtual bool get_IsImportedFromMetadata();
    public abstract virtual SynthesizedLocalKind get_SynthesizedKind();
    public abstract virtual SyntaxNode GetDeclaratorSyntax();
}
internal interface Microsoft.CodeAnalysis.IMarshalAsAttributeTarget {
    public abstract virtual MarshalPseudoCustomAttributeData GetOrCreateData();
}
internal interface Microsoft.CodeAnalysis.IMessageSerializable {
}
public interface Microsoft.CodeAnalysis.IMethodSymbol {
    public MethodKind MethodKind { get; }
    public int Arity { get; }
    public bool IsGenericMethod { get; }
    public bool IsExtensionMethod { get; }
    public bool IsAsync { get; }
    public bool IsVararg { get; }
    public bool IsCheckedBuiltin { get; }
    public bool HidesBaseMethodsByName { get; }
    public bool ReturnsVoid { get; }
    public ITypeSymbol ReturnType { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public IMethodSymbol ConstructedFrom { get; }
    public IMethodSymbol OriginalDefinition { get; }
    public IMethodSymbol OverriddenMethod { get; }
    public ITypeSymbol ReceiverType { get; }
    public IMethodSymbol ReducedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> ExplicitInterfaceImplementations { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public ISymbol AssociatedSymbol { get; }
    public IMethodSymbol PartialDefinitionPart { get; }
    public IMethodSymbol PartialImplementationPart { get; }
    public INamedTypeSymbol AssociatedAnonymousDelegate { get; }
    public abstract virtual MethodKind get_MethodKind();
    public abstract virtual int get_Arity();
    public abstract virtual bool get_IsGenericMethod();
    public abstract virtual bool get_IsExtensionMethod();
    public abstract virtual bool get_IsAsync();
    public abstract virtual bool get_IsVararg();
    public abstract virtual bool get_IsCheckedBuiltin();
    public abstract virtual bool get_HidesBaseMethodsByName();
    public abstract virtual bool get_ReturnsVoid();
    public abstract virtual ITypeSymbol get_ReturnType();
    public abstract virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public abstract virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    public abstract virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    public abstract virtual IMethodSymbol get_ConstructedFrom();
    public abstract virtual IMethodSymbol get_OriginalDefinition();
    public abstract virtual IMethodSymbol get_OverriddenMethod();
    public abstract virtual ITypeSymbol get_ReceiverType();
    public abstract virtual IMethodSymbol get_ReducedFrom();
    public abstract virtual ITypeSymbol GetTypeInferredDuringReduction(ITypeParameterSymbol reducedFromTypeParameter);
    public abstract virtual IMethodSymbol ReduceExtensionMethod(ITypeSymbol receiverType);
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_ExplicitInterfaceImplementations();
    public abstract virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public abstract virtual ImmutableArray`1<AttributeData> GetReturnTypeAttributes();
    public abstract virtual ISymbol get_AssociatedSymbol();
    public abstract virtual IMethodSymbol Construct(ITypeSymbol[] typeArguments);
    public abstract virtual IMethodSymbol get_PartialDefinitionPart();
    public abstract virtual IMethodSymbol get_PartialImplementationPart();
    public abstract virtual DllImportData GetDllImportData();
    public abstract virtual INamedTypeSymbol get_AssociatedAnonymousDelegate();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ImmutableArrayExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutable(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrEmpty(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrNull(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutable(T[] items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrNull(T[] items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrEmpty(T[] items);
    [ExtensionAttribute]
public static ImmutableArray`1<byte> ToImmutable(MemoryStream stream);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`2<TItem, TResult> map);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`3<TItem, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`4<TItem, int, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static ImmutableArray`1<T> WhereAsArray(ImmutableArray`1<T> array, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static ImmutableArray`1<TBase> Cast(ImmutableArray`1<TDerived> items);
    [ExtensionAttribute]
public static bool SetEquals(ImmutableArray`1<T> array1, ImmutableArray`1<T> array2, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static ImmutableArray`1<T> NullToEmpty(ImmutableArray`1<T> array);
    [ExtensionAttribute]
public static ImmutableArray`1<T> Distinct(ImmutableArray`1<T> array, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool HasAnyErrors(ImmutableArray`1<T> diagnostics);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> DeOrder(ImmutableArray`1<T> array);
    [ExtensionAttribute]
internal static ImmutableArray`1<TValue> Flatten(Dictionary`2<TKey, ImmutableArray`1<TValue>> dictionary, IComparer`1<TValue> comparer);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, ImmutableArray`1<T> second);
    [ExtensionAttribute]
internal static bool HasDuplicates(ImmutableArray`1<T> array, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int Count(ImmutableArray`1<T> items, Func`2<T, bool> predicate);
}
public interface Microsoft.CodeAnalysis.IModuleSymbol {
    public INamespaceSymbol GlobalNamespace { get; }
    public ImmutableArray`1<AssemblyIdentity> ReferencedAssemblies { get; }
    public ImmutableArray`1<IAssemblySymbol> ReferencedAssemblySymbols { get; }
    public abstract virtual INamespaceSymbol get_GlobalNamespace();
    public abstract virtual INamespaceSymbol GetModuleNamespace(INamespaceSymbol namespaceSymbol);
    public abstract virtual ImmutableArray`1<AssemblyIdentity> get_ReferencedAssemblies();
    public abstract virtual ImmutableArray`1<IAssemblySymbol> get_ReferencedAssemblySymbols();
}
public interface Microsoft.CodeAnalysis.INamedTypeSymbol {
    public int Arity { get; }
    public bool IsGenericType { get; }
    public bool IsUnboundGenericType { get; }
    public bool IsScriptClass { get; }
    public bool IsImplicitClass { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public INamedTypeSymbol OriginalDefinition { get; }
    public IMethodSymbol DelegateInvokeMethod { get; }
    public INamedTypeSymbol EnumUnderlyingType { get; }
    public INamedTypeSymbol ConstructedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> InstanceConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> StaticConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> Constructors { get; }
    public ISymbol AssociatedSymbol { get; }
    public bool MightContainExtensionMethods { get; }
    public abstract virtual int get_Arity();
    public abstract virtual bool get_IsGenericType();
    public abstract virtual bool get_IsUnboundGenericType();
    public abstract virtual bool get_IsScriptClass();
    public abstract virtual bool get_IsImplicitClass();
    public abstract virtual IEnumerable`1<string> get_MemberNames();
    public abstract virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    public abstract virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public abstract virtual INamedTypeSymbol get_OriginalDefinition();
    public abstract virtual IMethodSymbol get_DelegateInvokeMethod();
    public abstract virtual INamedTypeSymbol get_EnumUnderlyingType();
    public abstract virtual INamedTypeSymbol get_ConstructedFrom();
    public abstract virtual INamedTypeSymbol Construct(ITypeSymbol[] typeArguments);
    public abstract virtual INamedTypeSymbol ConstructUnboundGenericType();
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_InstanceConstructors();
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_StaticConstructors();
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_Constructors();
    public abstract virtual ISymbol get_AssociatedSymbol();
    public abstract virtual bool get_MightContainExtensionMethods();
}
public interface Microsoft.CodeAnalysis.INamespaceOrTypeSymbol {
    public bool IsNamespace { get; }
    public bool IsType { get; }
    public abstract virtual ImmutableArray`1<ISymbol> GetMembers();
    public abstract virtual ImmutableArray`1<ISymbol> GetMembers(string name);
    public abstract virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers();
    public abstract virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers(string name);
    public abstract virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers(string name, int arity);
    public abstract virtual bool get_IsNamespace();
    public abstract virtual bool get_IsType();
}
public interface Microsoft.CodeAnalysis.INamespaceSymbol {
    public bool IsGlobalNamespace { get; }
    public NamespaceKind NamespaceKind { get; }
    public Compilation ContainingCompilation { get; }
    public ImmutableArray`1<INamespaceSymbol> ConstituentNamespaces { get; }
    public abstract virtual IEnumerable`1<INamespaceOrTypeSymbol> GetMembers();
    public abstract virtual IEnumerable`1<INamespaceOrTypeSymbol> GetMembers(string name);
    public abstract virtual IEnumerable`1<INamespaceSymbol> GetNamespaceMembers();
    public abstract virtual bool get_IsGlobalNamespace();
    public abstract virtual NamespaceKind get_NamespaceKind();
    public abstract virtual Compilation get_ContainingCompilation();
    public abstract virtual ImmutableArray`1<INamespaceSymbol> get_ConstituentNamespaces();
}
internal static class Microsoft.CodeAnalysis.InternalDiagnosticSeverity : object {
    public static DiagnosticSeverity Unknown;
    public static DiagnosticSeverity Void;
}
internal static class Microsoft.CodeAnalysis.InternalErrorCode : object {
    public static int Unknown;
    public static int Void;
}
internal static class Microsoft.CodeAnalysis.InternalSymbolDisplayPartKind : object {
    private static SymbolDisplayPartKind base;
    public static SymbolDisplayPartKind Arity;
    public static SymbolDisplayPartKind Other;
}
internal static class Microsoft.CodeAnalysis.InternalUtilities.AssemblyLocationLightUp : object {
    private static Lazy`1<Func`2<Assembly, string>> s_lazyLocationGetter;
    private static AssemblyLocationLightUp();
    internal static string GetAssemblyLocation(Assembly assembly);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache`2 : object {
    private int _capacity;
    private Dictionary`2<K, CacheValue<K, V>> _cache;
    private LinkedList`1<K> _nodeList;
    private object _lockObject;
    internal IEnumerable`1<KeyValuePair`2<K, V>> TestingEnumerable { get; }
    public V Item { get; public set; }
    public ConcurrentLruCache`2(int capacity);
    public ConcurrentLruCache`2(KeyValuePair`2[] array);
    internal IEnumerable`1<KeyValuePair`2<K, V>> get_TestingEnumerable();
    public void Add(K key, V value);
    private void MoveNodeToTop(LinkedListNode`1<K> node);
    private void UnsafeEvictLastNode();
    private void UnsafeAddNodeToTop(K key, V value);
    private void UnsafeAdd(K key, V value, bool throwExceptionIfKeyExists);
    public V get_Item(K key);
    public void set_Item(K key, V value);
    public bool TryGetValue(K key, V& value);
    public bool UnsafeTryGetValue(K key, V& value);
    public V GetOrAdd(K key, V value);
}
internal static class Microsoft.CodeAnalysis.Interop.ClrStrongName : object {
    private static object nCreateInterface(Guid clsid, Guid riid);
    internal static IClrStrongName GetInstance();
    internal static string GetRuntimeVersion();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("D332DB9E-B9B3-4125-8207-A14884F53216")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.CodeAnalysis.Interop.IClrMetaHost {
    public abstract virtual object GetRuntime(string version, Guid interfaceId);
    public abstract virtual int GetVersionFromFile(string filePath, StringBuilder buffer, Int32& bufferLength);
    public abstract virtual object EnumerateInstalledRuntimes();
    public abstract virtual object EnumerateLoadedRuntimes(IntPtr processHandle);
    public abstract virtual int Reserved01(IntPtr reserved1);
    public abstract virtual object QueryLegacyV2RuntimeBinding(Guid interfaceId);
    public abstract virtual void ExitProcess(int exitCode);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("BD39D1D2-BA2F-486A-89B0-B4B0CB466891")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.CodeAnalysis.Interop.IClrRuntimeInfo {
    public abstract virtual int GetVersionString(StringBuilder buffer, Int32& bufferLength);
    public abstract virtual int GetRuntimeDirectory(StringBuilder buffer, Int32& bufferLength);
    public abstract virtual bool IsLoaded(IntPtr processHandle);
    public abstract virtual int LoadErrorString(int resourceId, StringBuilder buffer, Int32& bufferLength);
    public abstract virtual IntPtr LoadLibrary(string dllName);
    public abstract virtual IntPtr GetProcAddress(string procName);
    public abstract virtual object GetInterface(Guid coClassId, Guid interfaceId);
    public abstract virtual bool IsLoadable();
    public abstract virtual void SetDefaultStartupFlags(int startupFlags, string hostConfigFile);
    public abstract virtual int GetDefaultStartupFlags(Int32& startupFlags, StringBuilder hostConfigFile, Int32& hostConfigFileLength);
    public abstract virtual void BindAsLegacyV2Runtime();
    public abstract virtual void IsStarted(Boolean& started, Int32& startupFlags);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("9FD93CCF-3280-4391-B3A9-96E1CDE77C8D")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.CodeAnalysis.Interop.IClrStrongName {
    public abstract virtual void GetHashFromAssemblyFile(string pszFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual void GetHashFromAssemblyFileW(string pwzFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual void GetHashFromBlob(IntPtr pbBlob, int cchBlob, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual void GetHashFromFile(string pszFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual void GetHashFromFileW(string pwzFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual void GetHashFromHandle(IntPtr hFile, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int StrongNameCompareAssemblies(string pwzAssembly1, string pwzAssembly2);
    public abstract virtual void StrongNameFreeBuffer(IntPtr pbMemory);
    public abstract virtual void StrongNameGetBlob(string pwzFilePath, Byte[] pbBlob, Int32& pcbBlob);
    public abstract virtual void StrongNameGetBlobFromImage(IntPtr pbBase, int dwLength, Byte[] pbBlob, Int32& pcbBlob);
    public abstract virtual void StrongNameGetPublicKey(string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    public abstract virtual int StrongNameHashSize(int ulHashAlg);
    public abstract virtual void StrongNameKeyDelete(string pwzKeyContainer);
    public abstract virtual void StrongNameKeyGen(string pwzKeyContainer, int dwFlags, IntPtr& ppbKeyBlob, Int32& pcbKeyBlob);
    public abstract virtual void StrongNameKeyGenEx(string pwzKeyContainer, int dwFlags, int dwKeySize, IntPtr& ppbKeyBlob, Int32& pcbKeyBlob);
    public abstract virtual void StrongNameKeyInstall(string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob);
    public abstract virtual void StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, Byte[] ppbSignatureBlob, Int32& pcbSignatureBlob);
    public abstract virtual void StrongNameSignatureGenerationEx(string wszFilePath, string wszKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, IntPtr& ppbSignatureBlob, Int32& pcbSignatureBlob, int dwFlags);
    public abstract virtual void StrongNameSignatureSize(IntPtr pbPublicKeyBlob, int cbPublicKeyBlob, Int32& pcbSize);
    public abstract virtual int StrongNameSignatureVerification(string pwzFilePath, int dwInFlags);
    public abstract virtual byte StrongNameSignatureVerificationEx(string pwzFilePath, byte fForceVerification);
    public abstract virtual int StrongNameSignatureVerificationFromImage(IntPtr pbBase, int dwLength, int dwInFlags);
    public abstract virtual void StrongNameTokenFromAssembly(string pwzFilePath, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
    public abstract virtual void StrongNameTokenFromAssemblyEx(string pwzFilePath, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    public abstract virtual void StrongNameTokenFromPublicKey(IntPtr pbPublicKeyBlob, int cbPublicKeyBlob, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
}
internal class Microsoft.CodeAnalysis.InvalidRuleSetException : Exception {
    public InvalidRuleSetException(string message);
    public InvalidRuleSetException(string message, Exception inner);
}
public interface Microsoft.CodeAnalysis.IParameterSymbol {
    public RefKind RefKind { get; }
    public bool IsParams { get; }
    public bool IsOptional { get; }
    public bool IsThis { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public int Ordinal { get; }
    public bool HasExplicitDefaultValue { get; }
    public object ExplicitDefaultValue { get; }
    public IParameterSymbol OriginalDefinition { get; }
    public abstract virtual RefKind get_RefKind();
    public abstract virtual bool get_IsParams();
    public abstract virtual bool get_IsOptional();
    public abstract virtual bool get_IsThis();
    public abstract virtual ITypeSymbol get_Type();
    public abstract virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public abstract virtual int get_Ordinal();
    public abstract virtual bool get_HasExplicitDefaultValue();
    public abstract virtual object get_ExplicitDefaultValue();
    public abstract virtual IParameterSymbol get_OriginalDefinition();
}
public interface Microsoft.CodeAnalysis.IPointerTypeSymbol {
    public ITypeSymbol PointedAtType { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public abstract virtual ITypeSymbol get_PointedAtType();
    public abstract virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
}
public interface Microsoft.CodeAnalysis.IPreprocessingSymbol {
}
public interface Microsoft.CodeAnalysis.IPropertySymbol {
    public bool IsIndexer { get; }
    public bool IsReadOnly { get; }
    public bool IsWriteOnly { get; }
    public bool IsWithEvents { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public IMethodSymbol GetMethod { get; }
    public IMethodSymbol SetMethod { get; }
    public IPropertySymbol OriginalDefinition { get; }
    public IPropertySymbol OverriddenProperty { get; }
    public ImmutableArray`1<IPropertySymbol> ExplicitInterfaceImplementations { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public abstract virtual bool get_IsIndexer();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsWriteOnly();
    public abstract virtual bool get_IsWithEvents();
    public abstract virtual ITypeSymbol get_Type();
    public abstract virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    public abstract virtual IMethodSymbol get_GetMethod();
    public abstract virtual IMethodSymbol get_SetMethod();
    public abstract virtual IPropertySymbol get_OriginalDefinition();
    public abstract virtual IPropertySymbol get_OverriddenProperty();
    public abstract virtual ImmutableArray`1<IPropertySymbol> get_ExplicitInterfaceImplementations();
    public abstract virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
}
public interface Microsoft.CodeAnalysis.IRangeVariableSymbol {
}
internal interface Microsoft.CodeAnalysis.ISecurityAttributeTarget {
    public abstract virtual SecurityWellKnownAttributeData GetOrCreateData();
}
public interface Microsoft.CodeAnalysis.IStructuredTriviaSyntax {
    public SyntaxTrivia ParentTrivia { get; }
    public abstract virtual SyntaxTrivia get_ParentTrivia();
}
[InternalImplementationOnlyAttribute]
public interface Microsoft.CodeAnalysis.ISymbol {
    public SymbolKind Kind { get; }
    public string Language { get; }
    public string Name { get; }
    public string MetadataName { get; }
    public ISymbol ContainingSymbol { get; }
    public IAssemblySymbol ContainingAssembly { get; }
    public IModuleSymbol ContainingModule { get; }
    public INamedTypeSymbol ContainingType { get; }
    public INamespaceSymbol ContainingNamespace { get; }
    public bool IsDefinition { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    public bool IsImplicitlyDeclared { get; }
    public bool CanBeReferencedByName { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ISymbol OriginalDefinition { get; }
    public bool HasUnsupportedMetadata { get; }
    public abstract virtual SymbolKind get_Kind();
    public abstract virtual string get_Language();
    public abstract virtual string get_Name();
    public abstract virtual string get_MetadataName();
    public abstract virtual ISymbol get_ContainingSymbol();
    public abstract virtual IAssemblySymbol get_ContainingAssembly();
    public abstract virtual IModuleSymbol get_ContainingModule();
    public abstract virtual INamedTypeSymbol get_ContainingType();
    public abstract virtual INamespaceSymbol get_ContainingNamespace();
    public abstract virtual bool get_IsDefinition();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsVirtual();
    public abstract virtual bool get_IsOverride();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsSealed();
    public abstract virtual bool get_IsExtern();
    public abstract virtual bool get_IsImplicitlyDeclared();
    public abstract virtual bool get_CanBeReferencedByName();
    public abstract virtual ImmutableArray`1<Location> get_Locations();
    public abstract virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public abstract virtual ImmutableArray`1<AttributeData> GetAttributes();
    public abstract virtual Accessibility get_DeclaredAccessibility();
    public abstract virtual ISymbol get_OriginalDefinition();
    public abstract virtual void Accept(SymbolVisitor visitor);
    public abstract virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public abstract virtual string GetDocumentationCommentId();
    public abstract virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    public abstract virtual string ToDisplayString(SymbolDisplayFormat format);
    public abstract virtual ImmutableArray`1<SymbolDisplayPart> ToDisplayParts(SymbolDisplayFormat format);
    public abstract virtual string ToMinimalDisplayString(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    public abstract virtual ImmutableArray`1<SymbolDisplayPart> ToMinimalDisplayParts(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    public abstract virtual bool get_HasUnsupportedMetadata();
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.ISymbolExtensions : object {
    [ExtensionAttribute]
public static IMethodSymbol GetConstructedReducedFrom(IMethodSymbol method);
}
internal interface Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol {
    public IMethodSymbol Method { get; }
    public bool HasMethodBodyDependency { get; }
    public abstract virtual IMethodSymbol get_Method();
    public abstract virtual bool get_HasMethodBodyDependency();
}
public interface Microsoft.CodeAnalysis.ITypeParameterSymbol {
    public int Ordinal { get; }
    public VarianceKind Variance { get; }
    public TypeParameterKind TypeParameterKind { get; }
    public IMethodSymbol DeclaringMethod { get; }
    public INamedTypeSymbol DeclaringType { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public bool HasConstructorConstraint { get; }
    public ImmutableArray`1<ITypeSymbol> ConstraintTypes { get; }
    public ITypeParameterSymbol OriginalDefinition { get; }
    public ITypeParameterSymbol ReducedFrom { get; }
    public abstract virtual int get_Ordinal();
    public abstract virtual VarianceKind get_Variance();
    public abstract virtual TypeParameterKind get_TypeParameterKind();
    public abstract virtual IMethodSymbol get_DeclaringMethod();
    public abstract virtual INamedTypeSymbol get_DeclaringType();
    public abstract virtual bool get_HasReferenceTypeConstraint();
    public abstract virtual bool get_HasValueTypeConstraint();
    public abstract virtual bool get_HasConstructorConstraint();
    public abstract virtual ImmutableArray`1<ITypeSymbol> get_ConstraintTypes();
    public abstract virtual ITypeParameterSymbol get_OriginalDefinition();
    public abstract virtual ITypeParameterSymbol get_ReducedFrom();
}
public interface Microsoft.CodeAnalysis.ITypeSymbol {
    public TypeKind TypeKind { get; }
    public INamedTypeSymbol BaseType { get; }
    public ImmutableArray`1<INamedTypeSymbol> Interfaces { get; }
    public ImmutableArray`1<INamedTypeSymbol> AllInterfaces { get; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    public bool IsAnonymousType { get; }
    public ITypeSymbol OriginalDefinition { get; }
    public SpecialType SpecialType { get; }
    public abstract virtual TypeKind get_TypeKind();
    public abstract virtual INamedTypeSymbol get_BaseType();
    public abstract virtual ImmutableArray`1<INamedTypeSymbol> get_Interfaces();
    public abstract virtual ImmutableArray`1<INamedTypeSymbol> get_AllInterfaces();
    public abstract virtual bool get_IsReferenceType();
    public abstract virtual bool get_IsValueType();
    public abstract virtual bool get_IsAnonymousType();
    public abstract virtual ITypeSymbol get_OriginalDefinition();
    public abstract virtual SpecialType get_SpecialType();
    public abstract virtual ISymbol FindImplementationForInterfaceMember(ISymbol interfaceMember);
}
public static class Microsoft.CodeAnalysis.LanguageNames : object {
    public static string CSharp;
    public static string VisualBasic;
}
internal abstract class Microsoft.CodeAnalysis.LineDirectiveMap`1 : object {
    protected LineMappingEntry[] Entries;
    protected LineDirectiveMap`1(SyntaxTree syntaxTree);
    protected abstract virtual bool ShouldAddDirective(TDirective directive);
    protected abstract virtual LineMappingEntry<TDirective> GetEntry(TDirective directive, SourceText sourceText, LineMappingEntry<TDirective> previous);
    protected abstract virtual LineMappingEntry<TDirective> InitializeFirstEntry();
    public FileLinePositionSpan TranslateSpan(SourceText sourceText, string treeFilePath, TextSpan span);
    protected FileLinePositionSpan TranslateSpan(LineMappingEntry<TDirective> entry, string treeFilePath, LinePosition unmappedStartPos, LinePosition unmappedEndPos);
    public abstract virtual LineVisibility GetLineVisibility(SourceText sourceText, int position);
    internal abstract virtual FileLinePositionSpan TranslateSpanAndVisibility(SourceText sourceText, string treeFilePath, TextSpan span, Boolean& isHiddenPosition);
    public bool HasAnyHiddenRegions();
    protected LineMappingEntry<TDirective> FindEntry(int lineNumber);
    protected int FindEntryIndex(int lineNumber);
    private LineMappingEntry[] CreateEntryMap(SourceText sourceText, IEnumerable`1<TDirective> directives);
}
public enum Microsoft.CodeAnalysis.LineVisibility : Enum {
    public int value__;
    public static LineVisibility BeforeFirstLineDirective;
    public static LineVisibility Hidden;
    public static LineVisibility Visible;
}
internal class Microsoft.CodeAnalysis.LocalInfo`1 : ValueType {
    internal Byte[] SignatureOpt;
    internal TypeSymbol Type;
    internal ImmutableArray`1<ModifierInfo`1<TypeSymbol>> CustomModifiers;
    internal LocalSlotConstraints Constraints;
    public bool IsByRef { get; }
    public bool IsPinned { get; }
    internal LocalInfo`1(TypeSymbol type, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers, LocalSlotConstraints constraints, Byte[] signatureOpt);
    internal LocalInfo`1<TypeSymbol> WithSignature(Byte[] signature);
    public bool get_IsByRef();
    public bool get_IsPinned();
}
public class Microsoft.CodeAnalysis.LocalizableResourceString : LocalizableString {
    private string _nameOfLocalizableResource;
    private ResourceManager _resourceManager;
    private Type _resourceSource;
    private String[] _formatArguments;
    public LocalizableResourceString(string nameOfLocalizableResource, ResourceManager resourceManager, Type resourceSource);
    public LocalizableResourceString(string nameOfLocalizableResource, ResourceManager resourceManager, Type resourceSource, String[] formatArguments);
    private LocalizableResourceString(ObjectReader reader);
    private sealed virtual override Func`2<ObjectReader, object> Roslyn.Utilities.IObjectReadable.GetReader();
    private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    protected virtual string GetText(IFormatProvider formatProvider);
    protected virtual bool AreEqual(object other);
    protected virtual int GetHash();
}
public abstract class Microsoft.CodeAnalysis.LocalizableString : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<Exception> OnException;
    [CompilerGeneratedAttribute]
public void add_OnException(EventHandler`1<Exception> value);
    [CompilerGeneratedAttribute]
public void remove_OnException(EventHandler`1<Exception> value);
    public string ToString(IFormatProvider formatProvider);
    public static string op_Explicit(LocalizableString localizableResource);
    public static LocalizableString op_Implicit(string fixedResource);
    public sealed virtual string ToString();
    private sealed virtual override string System.IFormattable.ToString(string ignored, IFormatProvider formatProvider);
    public sealed virtual int GetHashCode();
    public sealed virtual bool Equals(object other);
    public sealed virtual bool Equals(LocalizableString other);
    protected abstract virtual string GetText(IFormatProvider formatProvider);
    protected abstract virtual int GetHash();
    protected abstract virtual bool AreEqual(object other);
    private void RaiseOnException(Exception ex);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.LocalSlotConstraints : Enum {
    public byte value__;
    public static LocalSlotConstraints None;
    public static LocalSlotConstraints ByRef;
    public static LocalSlotConstraints Pinned;
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public abstract class Microsoft.CodeAnalysis.Location : object {
    public LocationKind Kind { get; }
    public bool IsInSource { get; }
    public bool IsInMetadata { get; }
    public SyntaxTree SourceTree { get; }
    public IModuleSymbol MetadataModule { get; }
    public TextSpan SourceSpan { get; }
    public static Location None { get; }
    public abstract virtual LocationKind get_Kind();
    public bool get_IsInSource();
    public bool get_IsInMetadata();
    public virtual SyntaxTree get_SourceTree();
    public virtual IModuleSymbol get_MetadataModule();
    public virtual TextSpan get_SourceSpan();
    public virtual FileLinePositionSpan GetLineSpan();
    public virtual FileLinePositionSpan GetMappedLineSpan();
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(Location left, Location right);
    public static bool op_Inequality(Location left, Location right);
    protected virtual string GetDebuggerDisplay();
    public static Location get_None();
    public static Location Create(SyntaxTree syntaxTree, TextSpan textSpan);
    public static Location Create(string filePath, TextSpan textSpan, LinePositionSpan lineSpan);
}
public enum Microsoft.CodeAnalysis.LocationKind : Enum {
    public byte value__;
    public static LocationKind None;
    public static LocationKind SourceFile;
    public static LocationKind MetadataFile;
    public static LocationKind XmlFile;
    public static LocationKind ExternalFile;
}
internal static class Microsoft.CodeAnalysis.MarshalAsAttributeDecoder`4 : object {
    internal static void Decode(DecodeWellKnownAttributeArguments`3& arguments, AttributeTargets target, CommonMessageProvider messageProvider);
    private static UnmanagedType DecodeMarshalAsType(AttributeData attribute);
    private static void DecodeMarshalAsCustom(DecodeWellKnownAttributeArguments`3& arguments, CommonMessageProvider messageProvider);
    private static void DecodeMarshalAsComInterface(DecodeWellKnownAttributeArguments`3& arguments, UnmanagedType unmanagedType, CommonMessageProvider messageProvider);
    private static void DecodeMarshalAsArray(DecodeWellKnownAttributeArguments`3& arguments, CommonMessageProvider messageProvider, bool isFixed);
    private static void DecodeMarshalAsSafeArray(DecodeWellKnownAttributeArguments`3& arguments, CommonMessageProvider messageProvider);
    private static void DecodeMarshalAsFixedString(DecodeWellKnownAttributeArguments`3& arguments, CommonMessageProvider messageProvider);
}
internal class Microsoft.CodeAnalysis.MarshalPseudoCustomAttributeData : object {
    private UnmanagedType _marshalType;
    private int _marshalArrayElementType;
    private int _marshalArrayElementCount;
    private int _marshalParameterIndex;
    private object _marshalTypeNameOrSymbol;
    private string _marshalCookie;
    internal static int Invalid;
    private static UnmanagedType InvalidUnmanagedType;
    private static VarEnum InvalidVariantType;
    internal static int MaxMarshalInteger;
    public UnmanagedType UnmanagedType { get; }
    private int Microsoft.Cci.IMarshallingInformation.IidParameterIndex { get; }
    private string Microsoft.Cci.IMarshallingInformation.CustomMarshallerRuntimeArgument { get; }
    private int Microsoft.Cci.IMarshallingInformation.NumberOfElements { get; }
    private short Microsoft.Cci.IMarshallingInformation.ParamIndex { get; }
    private UnmanagedType Microsoft.Cci.IMarshallingInformation.ElementType { get; }
    private VarEnum Microsoft.Cci.IMarshallingInformation.SafeArrayElementSubtype { get; }
    internal void SetMarshalAsCustom(object typeSymbolOrName, string cookie);
    internal void SetMarshalAsComInterface(UnmanagedType unmanagedType, Nullable`1<int> parameterIndex);
    internal void SetMarshalAsArray(Nullable`1<UnmanagedType> elementType, Nullable`1<int> elementCount, Nullable`1<short> parameterIndex);
    internal void SetMarshalAsFixedArray(Nullable`1<UnmanagedType> elementType, Nullable`1<int> elementCount);
    internal void SetMarshalAsSafeArray(Nullable`1<VarEnum> elementType, ITypeSymbol elementTypeSymbol);
    internal void SetMarshalAsFixedString(int elementCount);
    internal void SetMarshalAsSimpleType(UnmanagedType type);
    public sealed virtual UnmanagedType get_UnmanagedType();
    private sealed virtual override int Microsoft.Cci.IMarshallingInformation.get_IidParameterIndex();
    private sealed virtual override object Microsoft.Cci.IMarshallingInformation.GetCustomMarshaller(EmitContext context);
    private sealed virtual override string Microsoft.Cci.IMarshallingInformation.get_CustomMarshallerRuntimeArgument();
    private sealed virtual override int Microsoft.Cci.IMarshallingInformation.get_NumberOfElements();
    private sealed virtual override short Microsoft.Cci.IMarshallingInformation.get_ParamIndex();
    private sealed virtual override UnmanagedType Microsoft.Cci.IMarshallingInformation.get_ElementType();
    private sealed virtual override VarEnum Microsoft.Cci.IMarshallingInformation.get_SafeArrayElementSubtype();
    private sealed virtual override ITypeReference Microsoft.Cci.IMarshallingInformation.GetSafeArrayElementUserDefinedSubtype(EmitContext context);
    internal MarshalPseudoCustomAttributeData WithTranslatedTypes(Func`3<TTypeSymbol, TArg, TTypeSymbol> translator, TArg arg);
    internal ITypeSymbol TryGetSafeArrayElementUserDefinedSubtype();
}
public abstract class Microsoft.CodeAnalysis.Metadata : object {
    internal bool IsImageOwner;
    public MetadataImageKind Kind { get; }
    internal Metadata(bool isImageOwner);
    public abstract virtual MetadataImageKind get_Kind();
    public abstract virtual void Dispose();
    protected abstract virtual Metadata CommonCopy();
    public Metadata Copy();
}
internal abstract class Microsoft.CodeAnalysis.MetadataDecoder`5 : TypeNameDecoder`2<ModuleSymbol, TypeSymbol> {
    public PEModule Module;
    private AssemblyIdentity _containingAssemblyIdentity;
    internal MetadataDecoder`5(PEModule module, AssemblyIdentity containingAssemblyIdentity, SymbolFactory`2<ModuleSymbol, TypeSymbol> factory, ModuleSymbol moduleSymbol);
    internal TypeSymbol GetTypeOfToken(EntityHandle token);
    internal TypeSymbol GetTypeOfToken(EntityHandle token, Boolean& isNoPiaLocalType);
    private TypeSymbol GetTypeOfTypeSpec(TypeSpecificationHandle typeSpec);
    private TypeSymbol DecodeTypeOrThrow(BlobReader& ppSig, Boolean& refersToNoPiaLocalType);
    private TypeSymbol DecodeTypeOrThrow(BlobReader& ppSig, SignatureTypeCode typeCode, Boolean& refersToNoPiaLocalType);
    private TypeSymbol ResolveSignatureTypeHandleOrThrow(BlobReader& ppSig, Boolean& isNoPiaLocalType);
    private TypeSymbol GetTypeOfTypeRef(TypeReferenceHandle typeRef, Boolean& isNoPiaLocalType);
    private TypeSymbol GetTypeByNameOrThrow(MetadataTypeName& fullName, EntityHandle tokenResolutionScope, Boolean& isNoPiaLocalType);
    private TypeSymbol GetTypeOfTypeDef(TypeDefinitionHandle typeDef);
    private TypeSymbol GetTypeOfTypeDef(TypeDefinitionHandle typeDef, Boolean& isNoPiaLocalType, bool isContainingType);
    private ImmutableArray`1<ModifierInfo`1<TypeSymbol>> DecodeModifiersOrThrow(BlobReader& signatureReader, SignatureTypeCode& typeCode);
    private static bool IsAcceptableModOptModifier(EntityHandle token, TypeSymbol modifier);
    internal ImmutableArray`1<LocalInfo`1<TypeSymbol>> DecodeLocalSignatureOrThrow(BlobReader& signatureReader);
    internal LocalInfo`1<TypeSymbol> DecodeLocalVariableOrThrow(BlobReader& signatureReader);
    internal bool TryGetLocals(MethodDefinitionHandle handle, ImmutableArray`1& localInfo);
    private void DecodeParameterOrThrow(BlobReader& signatureReader, ParamInfo`1& info);
    internal ParamInfo`1[] GetSignatureForMethod(MethodDefinitionHandle methodDef, SignatureHeader& signatureHeader, BadImageFormatException& metadataException, bool setParamHandles);
    internal static void GetSignatureCountsOrThrow(PEModule module, MethodDefinitionHandle methodDef, Int32& parameterCount, Int32& typeParameterCount);
    internal ParamInfo`1[] GetSignatureForProperty(PropertyDefinitionHandle handle, SignatureHeader& signatureHeader, BadImageFormatException& BadImageFormatException);
    internal SignatureHeader GetSignatureHeaderForProperty(PropertyDefinitionHandle handle);
    private void DecodeCustomAttributeParameterTypeOrThrow(BlobReader& sigReader, SerializationTypeCode& typeCode, TypeSymbol& type, SerializationTypeCode& elementTypeCode, TypeSymbol& elementType, bool isElementType);
    private void DecodeCustomAttributeFieldOrPropTypeOrThrow(BlobReader& argReader, SerializationTypeCode& typeCode, TypeSymbol& type, SerializationTypeCode& elementTypeCode, TypeSymbol& elementType, bool isElementType);
    private TypedConstant DecodeCustomAttributeFixedArgumentOrThrow(BlobReader& sigReader, BlobReader& argReader);
    private TypedConstant DecodeCustomAttributeElementOrThrow(BlobReader& argReader, SerializationTypeCode typeCode, TypeSymbol type);
    private TypedConstant DecodeCustomAttributeElementArrayOrThrow(BlobReader& argReader, SerializationTypeCode elementTypeCode, TypeSymbol elementType, TypeSymbol arrayType);
    private TypedConstant DecodeCustomAttributePrimitiveElementOrThrow(BlobReader& argReader, SerializationTypeCode typeCode, TypeSymbol type);
    private static TypedConstantKind GetPrimitiveOrEnumTypedConstantKind(TypeSymbol type);
    private KeyValuePair`2<string, TypedConstant> DecodeCustomAttributeNamedArgumentOrThrow(BlobReader& argReader);
    internal bool IsTargetAttribute(CustomAttributeHandle customAttribute, string namespaceName, string typeName, bool ignoreCase);
    internal int GetTargetAttributeSignatureIndex(CustomAttributeHandle customAttribute, AttributeDescription description);
    internal bool GetCustomAttribute(CustomAttributeHandle handle, TypedConstant[]& positionalArgs, KeyValuePair`2[]& namedArgs);
    internal bool GetCustomAttribute(CustomAttributeHandle handle, TypeSymbol& attributeClass, MethodSymbol& attributeCtor);
    internal bool GetCustomAttributeWellKnownType(CustomAttributeHandle handle, WellKnownType& wellKnownAttribute);
    private TypeSymbol[] DecodeMethodSpecTypeArgumentsOrThrow(BlobHandle signature);
    internal BlobReader DecodeSignatureHeaderOrThrow(BlobHandle signature, SignatureHeader& signatureHeader);
    internal static BlobReader DecodeSignatureHeaderOrThrow(PEModule module, BlobHandle signature, SignatureHeader& signatureHeader);
    protected ParamInfo`1[] DecodeSignatureParametersOrThrow(BlobReader& signatureReader, SignatureHeader signatureHeader, Int32& typeParameterCount);
    private static void GetSignatureCountsOrThrow(BlobReader& signatureReader, SignatureHeader signatureHeader, Int32& parameterCount, Int32& typeParameterCount);
    internal TypeSymbol DecodeFieldSignature(FieldDefinitionHandle fieldHandle, Boolean& isVolatile, ImmutableArray`1& customModifiers);
    protected TypeSymbol DecodeFieldSignature(BlobReader& signatureReader, Boolean& isVolatile, ImmutableArray`1& customModifiers);
    internal ImmutableArray`1<MethodSymbol> GetExplicitlyOverriddenMethods(TypeDefinitionHandle implementingTypeDef, MethodDefinitionHandle implementingMethodDef, TypeSymbol implementingTypeSymbol);
    private MethodSymbol FindMethodSymbolInSuperType(TypeDefinitionHandle searchTypeDef, MethodDefinitionHandle targetMethodDef);
    private void EnqueueTypeDefInterfacesAndBaseTypeOrThrow(Queue`1<TypeDefinitionHandle> typeDefsToSearch, Queue`1<TypeSymbol> typeSymbolsToSearch, TypeDefinitionHandle searchTypeDef);
    private void EnqueueTypeToken(Queue`1<TypeDefinitionHandle> typeDefsToSearch, Queue`1<TypeSymbol> typeSymbolsToSearch, EntityHandle typeToken);
    protected abstract virtual void EnqueueTypeSymbolInterfacesAndBaseTypes(Queue`1<TypeDefinitionHandle> typeDefsToSearch, Queue`1<TypeSymbol> typeSymbolsToSearch, TypeSymbol typeSymbol);
    protected abstract virtual void EnqueueTypeSymbol(Queue`1<TypeDefinitionHandle> typeDefsToSearch, Queue`1<TypeSymbol> typeSymbolsToSearch, TypeSymbol typeSymbol);
    protected abstract virtual MethodSymbol FindMethodSymbolInType(TypeSymbol type, MethodDefinitionHandle methodDef);
    protected abstract virtual FieldSymbol FindFieldSymbolInType(TypeSymbol type, FieldDefinitionHandle fieldDef);
    internal abstract virtual Symbol GetSymbolForMemberRef(MemberReferenceHandle memberRef, TypeSymbol implementingTypeSymbol, bool methodsOnly);
    internal MethodSymbol GetMethodSymbolForMemberRef(MemberReferenceHandle methodRef, TypeSymbol implementingTypeSymbol);
    internal FieldSymbol GetFieldSymbolForMemberRef(MemberReferenceHandle methodRef, TypeSymbol implementingTypeSymbol);
    protected virtual bool IsContainingAssembly(AssemblyIdentity identity);
    protected abstract virtual MethodDefinitionHandle GetMethodHandle(MethodSymbol method);
    protected abstract virtual ConcurrentDictionary`2<TypeDefinitionHandle, TypeSymbol> GetTypeHandleToTypeMap();
    protected abstract virtual ConcurrentDictionary`2<TypeReferenceHandle, TypeSymbol> GetTypeRefHandleToTypeMap();
    protected abstract virtual TypeSymbol SubstituteNoPiaLocalType(TypeDefinitionHandle typeDef, MetadataTypeName& name, string interfaceGuid, string scope, string identifier);
    protected abstract virtual TypeSymbol LookupTopLevelTypeDefSymbol(string moduleName, MetadataTypeName& emittedName, Boolean& isNoPiaLocalType);
    protected abstract virtual TypeSymbol GetGenericTypeParamSymbol(int position);
    protected abstract virtual TypeSymbol GetGenericMethodTypeParamSymbol(int position);
    private static TypedConstant CreateArrayTypedConstant(TypeSymbol type, ImmutableArray`1<TypedConstant> array);
    private static TypedConstant CreateTypedConstant(TypeSymbol type, TypedConstantKind kind, object value);
    private static TypedConstant CreateTypedConstant(TypeSymbol type, TypedConstantKind kind, bool value);
    internal Symbol GetSymbolForILToken(EntityHandle token);
    internal TypeSymbol GetMemberRefTypeSymbol(MemberReferenceHandle memberRef);
    internal MethodSymbol GetMethodSymbolForMethodDefOrMemberRef(EntityHandle memberToken, TypeSymbol container);
    internal FieldSymbol GetFieldSymbolForFieldDefOrMemberRef(EntityHandle memberToken, TypeSymbol container);
    internal bool DoPropertySignaturesMatch(ParamInfo`1[] signature1, ParamInfo`1[] signature2, bool comparingToSetter, bool compareParamByRef, bool compareReturnType);
    internal bool DoesSignatureMatchEvent(TypeSymbol eventType, ParamInfo`1[] methodParams);
}
internal class Microsoft.CodeAnalysis.MetadataFileReferenceProvider : object {
    public static MetadataFileReferenceProvider Default;
    private static MetadataFileReferenceProvider();
    public virtual PortableExecutableReference GetReference(string path, MetadataReferenceProperties properties);
}
internal class Microsoft.CodeAnalysis.MetadataFileReferenceResolver : object {
    public static MetadataFileReferenceResolver Default;
    private ImmutableArray`1<string> _searchPaths;
    private string _baseDirectory;
    public ImmutableArray`1<string> SearchPaths { get; }
    public string BaseDirectory { get; }
    public MetadataFileReferenceResolver(ImmutableArray`1<string> searchPaths, string baseDirectory);
    public MetadataFileReferenceResolver(IEnumerable`1<string> searchPaths, string baseDirectory);
    private static MetadataFileReferenceResolver();
    internal static void ValidateSearchPaths(ImmutableArray`1<string> paths, string argName);
    public ImmutableArray`1<string> get_SearchPaths();
    public string get_BaseDirectory();
    public virtual string ResolveReference(string reference, string baseFilePath);
    internal string ResolveReferenceChecked(string reference, string baseFilePath);
    protected virtual bool FileExists(string fullPath);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class Microsoft.CodeAnalysis.MetadataHelpers : object {
    public static char DotDelimiter;
    public static string DotDelimiterString;
    public static char GenericTypeNameManglingChar;
    private static string GenericTypeNameManglingString;
    public static int MaxStringLengthForParamSize;
    public static int MaxStringLengthForIntToStringConversion;
    public static string SystemString;
    public static char MangledNameRegionStartChar;
    public static char MangledNameRegionEndChar;
    private static String[] s_aritySuffixesOneToNine;
    private static ImmutableArray`1<string> s_splitQualifiedNameSystem;
    private static MetadataHelpers();
    internal static AssemblyQualifiedTypeName DecodeTypeName(string s);
    internal static string GetAritySuffix(int arity);
    internal static string ComposeAritySuffixedMetadataName(string name, int arity);
    internal static int InferTypeArityFromMetadataName(string emittedTypeName);
    private static short InferTypeArityFromMetadataName(string emittedTypeName, Int32& suffixStartsAt);
    internal static string InferTypeArityAndUnmangleMetadataName(string emittedTypeName, Int16& arity);
    internal static string UnmangleMetadataNameForArity(string emittedTypeName, int arity);
    internal static ImmutableArray`1<string> SplitQualifiedName(string name);
    internal static string SplitQualifiedName(string pstrName, String& qualifier);
    internal static string BuildQualifiedName(string qualifier, string name);
    public static void GetInfoForImmediateNamespaceMembers(int namespaceNameLength, IEnumerable`1<IGrouping`2<string, TypeDefinitionHandle>> typesByNS, StringComparer nameComparer, IEnumerable`1& types, IEnumerable`1& namespaces);
    private static string ExtractSimpleNameOfChildNamespace(int parentNamespaceNameLength, string fullName);
    internal static bool IsValidMetadataIdentifier(string str);
    internal static bool IsValidUnicodeString(string str);
    internal static void ValidateAssemblyOrModuleName(string name, string argumentName);
    internal static bool IsValidAssemblyOrModuleName(string name);
    internal static Exception CheckAssemblyOrModuleName(string name, string argumentName);
    internal static bool IsValidMetadataFileName(string name);
    internal static bool SplitNameEqualsFullyQualifiedName(string namespaceName, string typeName, string fullyQualified);
    internal static bool IsValidPublicKey(ImmutableArray`1<byte> bytes);
    internal static string MangleForTypeNameIfNeeded(string moduleName);
}
public enum Microsoft.CodeAnalysis.MetadataImageKind : Enum {
    public byte value__;
    public static MetadataImageKind Assembly;
    public static MetadataImageKind Module;
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.MetadataImageReference : PortableExecutableReference {
    private string _display;
    private Metadata _metadata;
    public string Display { get; }
    internal MetadataImageReference(Metadata metadata, MetadataReferenceProperties properties, DocumentationProvider documentation, string filePath, string display);
    protected virtual Metadata GetMetadataImpl();
    protected virtual DocumentationProvider CreateDocumentationProvider();
    protected virtual PortableExecutableReference WithPropertiesImpl(MetadataReferenceProperties properties);
    public virtual string get_Display();
    private string GetDebuggerDisplay();
}
internal enum Microsoft.CodeAnalysis.MetadataImportOptions : Enum {
    public byte value__;
    public static MetadataImportOptions Public;
    public static MetadataImportOptions Internal;
    public static MetadataImportOptions All;
}
internal class Microsoft.CodeAnalysis.MetadataLocation : Location {
    private IModuleSymbol _module;
    public LocationKind Kind { get; }
    public IModuleSymbol MetadataModule { get; }
    internal MetadataLocation(IModuleSymbol module);
    public virtual LocationKind get_Kind();
    public virtual IModuleSymbol get_MetadataModule();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MetadataLocation other);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.MetadataReaderExtensions : object {
    [ExtensionAttribute]
internal static bool GetWinMdVersion(MetadataReader reader, Int32& majorVersion, Int32& minorVersion);
    [ExtensionAttribute]
internal static AssemblyIdentity ReadAssemblyIdentityOrThrow(MetadataReader reader);
    [ExtensionAttribute]
internal static ImmutableArray`1<AssemblyIdentity> GetReferencedAssembliesOrThrow(MetadataReader reader);
    [ExtensionAttribute]
internal static Guid GetModuleVersionIdOrThrow(MetadataReader reader);
    [ExtensionAttribute]
private static AssemblyIdentity CreateAssemblyIdentityOrThrow(MetadataReader reader, Version version, AssemblyFlags flags, BlobHandle publicKey, StringHandle name, StringHandle culture, bool isReference);
    [ExtensionAttribute]
internal static bool DeclaresTheObjectClass(MetadataReader reader);
    [ExtensionAttribute]
private static bool IsSystemObjectOrThrow(MetadataReader reader, TypeDefinition typeDef);
}
public abstract class Microsoft.CodeAnalysis.MetadataReference : object {
    [CompilerGeneratedAttribute]
private MetadataReferenceProperties <Properties>k__BackingField;
    public MetadataReferenceProperties Properties { get; }
    public string Display { get; }
    internal bool IsUnresolved { get; }
    internal MetadataReference(MetadataReferenceProperties properties);
    [CompilerGeneratedAttribute]
public MetadataReferenceProperties get_Properties();
    public virtual string get_Display();
    internal virtual bool get_IsUnresolved();
    public MetadataReference WithAliases(IEnumerable`1<string> aliases);
    public MetadataReference WithEmbedInteropTypes(bool value);
    public MetadataReference WithAliases(ImmutableArray`1<string> aliases);
    public MetadataReference WithProperties(MetadataReferenceProperties properties);
    internal abstract virtual MetadataReference WithPropertiesImplReturningMetadataReference(MetadataReferenceProperties properties);
    public static PortableExecutableReference CreateFromImage(ImmutableArray`1<byte> peImage, MetadataReferenceProperties properties, DocumentationProvider documentation, string filePath);
    public static PortableExecutableReference CreateFromImage(IEnumerable`1<byte> peImage, MetadataReferenceProperties properties, DocumentationProvider documentation, string filePath);
    public static PortableExecutableReference CreateFromStream(Stream peStream, MetadataReferenceProperties properties, DocumentationProvider documentation, string filePath);
    public static PortableExecutableReference CreateFromFile(string path, MetadataReferenceProperties properties, DocumentationProvider documentation);
    [ObsoleteAttribute("Use CreateFromFile(assembly.Location) instead", "True")]
[EditorBrowsableAttribute("1")]
public static MetadataReference CreateFromAssembly(Assembly assembly);
    internal static MetadataReference CreateFromAssemblyInternal(Assembly assembly);
    [ObsoleteAttribute("Use CreateFromFile(assembly.Location) instead", "True")]
[EditorBrowsableAttribute("1")]
public static MetadataReference CreateFromAssembly(Assembly assembly, MetadataReferenceProperties properties, DocumentationProvider documentation);
    internal static MetadataReference CreateFromAssemblyInternal(Assembly assembly, MetadataReferenceProperties properties, DocumentationProvider documentation);
}
public class Microsoft.CodeAnalysis.MetadataReferenceProperties : ValueType {
    private MetadataImageKind _kind;
    private ImmutableArray`1<string> _aliases;
    private bool _embedInteropTypes;
    public static MetadataReferenceProperties Module { get; }
    public static MetadataReferenceProperties Assembly { get; }
    public MetadataImageKind Kind { get; }
    public static string GlobalAlias { get; }
    public ImmutableArray`1<string> Aliases { get; }
    public bool EmbedInteropTypes { get; }
    public MetadataReferenceProperties(MetadataImageKind kind, ImmutableArray`1<string> aliases, bool embedInteropTypes);
    public static MetadataReferenceProperties get_Module();
    public static MetadataReferenceProperties get_Assembly();
    public MetadataReferenceProperties WithAliases(IEnumerable`1<string> aliases);
    public MetadataReferenceProperties WithAliases(ImmutableArray`1<string> aliases);
    public MetadataReferenceProperties WithEmbedInteropTypes(bool embedInteropTypes);
    public MetadataImageKind get_Kind();
    public static string get_GlobalAlias();
    public ImmutableArray`1<string> get_Aliases();
    public bool get_EmbedInteropTypes();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MetadataReferenceProperties other);
    public virtual int GetHashCode();
    public static bool op_Equality(MetadataReferenceProperties left, MetadataReferenceProperties right);
    public static bool op_Inequality(MetadataReferenceProperties left, MetadataReferenceProperties right);
}
public abstract class Microsoft.CodeAnalysis.MetadataReferenceResolver : object {
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual ImmutableArray`1<PortableExecutableReference> ResolveReference(string reference, string baseFilePath, MetadataReferenceProperties properties);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.MetadataTypeCodeExtensions : object {
    [ExtensionAttribute]
internal static SpecialType ToSpecialType(SignatureTypeCode typeCode);
    [ExtensionAttribute]
internal static bool HasShortFormSignatureEncoding(SpecialType type);
    [ExtensionAttribute]
internal static SerializationTypeCode ToSerializationType(SpecialType specialType);
}
internal class Microsoft.CodeAnalysis.MetadataTypeName : ValueType {
    private string _fullName;
    private string _namespaceName;
    private string _typeName;
    private string _unmangledTypeName;
    private short _inferredArity;
    private short _forcedArity;
    private bool _useCLSCompliantNameArityEncoding;
    private ImmutableArray`1<string> _namespaceSegments;
    public string FullName { get; }
    public string NamespaceName { get; }
    public string TypeName { get; }
    public string UnmangledTypeName { get; }
    public int InferredArity { get; }
    public bool IsMangled { get; }
    public bool UseCLSCompliantNameArityEncoding { get; }
    public int ForcedArity { get; }
    public ImmutableArray`1<string> NamespaceSegments { get; }
    public bool IsNull { get; }
    public static MetadataTypeName FromFullName(string fullName, bool useCLSCompliantNameArityEncoding, int forcedArity);
    public static MetadataTypeName FromNamespaceAndTypeName(string namespaceName, string typeName, bool useCLSCompliantNameArityEncoding, int forcedArity);
    public static MetadataTypeName FromTypeName(string typeName, bool useCLSCompliantNameArityEncoding, int forcedArity);
    public string get_FullName();
    public string get_NamespaceName();
    public string get_TypeName();
    public string get_UnmangledTypeName();
    public int get_InferredArity();
    public bool get_IsMangled();
    public bool get_UseCLSCompliantNameArityEncoding();
    public int get_ForcedArity();
    public ImmutableArray`1<string> get_NamespaceSegments();
    public bool get_IsNull();
    public virtual string ToString();
    public Key ToKey();
}
public enum Microsoft.CodeAnalysis.MethodKind : Enum {
    public int value__;
    public static MethodKind AnonymousFunction;
    public static MethodKind LambdaMethod;
    public static MethodKind Constructor;
    public static MethodKind Conversion;
    public static MethodKind DelegateInvoke;
    public static MethodKind Destructor;
    public static MethodKind EventAdd;
    public static MethodKind EventRaise;
    public static MethodKind EventRemove;
    public static MethodKind ExplicitInterfaceImplementation;
    public static MethodKind UserDefinedOperator;
    public static MethodKind Ordinary;
    public static MethodKind PropertyGet;
    public static MethodKind PropertySet;
    public static MethodKind ReducedExtension;
    public static MethodKind StaticConstructor;
    public static MethodKind SharedConstructor;
    public static MethodKind BuiltinOperator;
    public static MethodKind DeclareMethod;
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.ModelExtensions : object {
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSpeculativeSymbolInfo(SemanticModel semanticModel, int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    [ExtensionAttribute]
public static TypeInfo GetTypeInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IAliasSymbol GetAliasInfo(SemanticModel semanticModel, SyntaxNode nameSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IAliasSymbol GetSpeculativeAliasInfo(SemanticModel semanticModel, int position, SyntaxNode nameSyntax, SpeculativeBindingOption bindingOption);
    [ExtensionAttribute]
public static TypeInfo GetSpeculativeTypeInfo(SemanticModel semanticModel, int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    [ExtensionAttribute]
public static ISymbol GetDeclaredSymbol(SemanticModel semanticModel, SyntaxNode declaration, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> GetMemberGroup(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ControlFlowAnalysis AnalyzeControlFlow(SemanticModel semanticModel, SyntaxNode firstStatement, SyntaxNode lastStatement);
    [ExtensionAttribute]
public static ControlFlowAnalysis AnalyzeControlFlow(SemanticModel semanticModel, SyntaxNode statement);
    [ExtensionAttribute]
public static DataFlowAnalysis AnalyzeDataFlow(SemanticModel semanticModel, SyntaxNode firstStatement, SyntaxNode lastStatement);
    [ExtensionAttribute]
public static DataFlowAnalysis AnalyzeDataFlow(SemanticModel semanticModel, SyntaxNode statementOrExpression);
}
internal class Microsoft.CodeAnalysis.ModifierInfo`1 : ValueType {
    internal bool IsOptional;
    internal TypeSymbol Modifier;
    public ModifierInfo`1(bool isOptional, TypeSymbol modifier);
}
internal class Microsoft.CodeAnalysis.ModuleCompilationState`2 : CommonModuleCompilationState {
    private Dictionary`2<TMethodSymbol, TNamedTypeSymbol> _lazyStateMachineTypes;
    internal void SetStateMachineType(TMethodSymbol method, TNamedTypeSymbol stateMachineClass);
    internal bool TryGetStateMachineType(TMethodSymbol method, TNamedTypeSymbol& stateMachineType);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ModuleExtensions : object {
    private static string VTableGapMethodNamePrefix;
    [ExtensionAttribute]
public static bool ShouldImportNestedType(PEModule module, TypeDefinitionHandle typeDef);
    [ExtensionAttribute]
public static bool ShouldImportField(PEModule module, FieldDefinitionHandle field, MetadataImportOptions importOptions);
    public static bool ShouldImportField(FieldAttributes flags, MetadataImportOptions importOptions);
    [ExtensionAttribute]
public static bool ShouldImportMethod(PEModule module, MethodDefinitionHandle methodDef, MetadataImportOptions importOptions);
    public static int GetVTableGapSize(string emittedMethodName);
    public static string GetVTableGapName(int sequenceNumber, int countOfSlots);
}
public class Microsoft.CodeAnalysis.ModuleMetadata : Metadata {
    private bool _isDisposed;
    private PEModule _module;
    internal bool IsDisposed { get; }
    internal PEModule Module { get; }
    public string Name { get; }
    public MetadataImageKind Kind { get; }
    internal MetadataReader MetadataReader { get; }
    private ModuleMetadata(PEReader peReader);
    private ModuleMetadata(IntPtr metadata, int size, bool includeEmbeddedInteropTypes);
    private ModuleMetadata(ModuleMetadata metadata);
    public static ModuleMetadata CreateFromMetadata(IntPtr metadata, int size);
    internal static ModuleMetadata CreateFromMetadata(IntPtr metadata, int size, bool includeEmbeddedInteropTypes);
    public static ModuleMetadata CreateFromImage(IntPtr peImage, int size);
    public static ModuleMetadata CreateFromImage(IEnumerable`1<byte> peImage);
    public static ModuleMetadata CreateFromImage(ImmutableArray`1<byte> peImage);
    public static ModuleMetadata CreateFromStream(Stream peStream, bool leaveOpen);
    public static ModuleMetadata CreateFromStream(Stream peStream, PEStreamOptions options);
    public static ModuleMetadata CreateFromFile(string path);
    internal ModuleMetadata Copy();
    protected virtual Metadata CommonCopy();
    public virtual void Dispose();
    internal bool get_IsDisposed();
    internal PEModule get_Module();
    public string get_Name();
    public Guid GetModuleVersionId();
    public virtual MetadataImageKind get_Kind();
    public ImmutableArray`1<string> GetModuleNames();
    internal MetadataReader get_MetadataReader();
    public PortableExecutableReference GetReference(DocumentationProvider documentation, string filePath, string display);
}
internal class Microsoft.CodeAnalysis.ModuleReferences`1 : object {
    public ImmutableArray`1<AssemblyIdentity> Names;
    public ImmutableArray`1<TAssemblySymbol> Symbols;
    public ImmutableArray`1<UnifiedAssembly`1<TAssemblySymbol>> UnifiedAssemblies;
    public ModuleReferences`1(ImmutableArray`1<AssemblyIdentity> names, ImmutableArray`1<TAssemblySymbol> symbols, ImmutableArray`1<UnifiedAssembly`1<TAssemblySymbol>> unifiedAssemblies);
}
public enum Microsoft.CodeAnalysis.NamespaceKind : Enum {
    public int value__;
    public static NamespaceKind Module;
    public static NamespaceKind Assembly;
    public static NamespaceKind Compilation;
}
internal class Microsoft.CodeAnalysis.NoLocation : Location {
    public static Location Singleton;
    public LocationKind Kind { get; }
    private static NoLocation();
    public virtual LocationKind get_Kind();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ObjectDisplayExtensions : object {
    [ExtensionAttribute]
internal static bool IncludesOption(ObjectDisplayOptions options, ObjectDisplayOptions flag);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.ObjectDisplayOptions : Enum {
    public int value__;
    public static ObjectDisplayOptions None;
    public static ObjectDisplayOptions IncludeCodePoints;
    public static ObjectDisplayOptions IncludeTypeSuffix;
    public static ObjectDisplayOptions UseHexadecimalNumbers;
    public static ObjectDisplayOptions UseQuotes;
}
internal class Microsoft.CodeAnalysis.ObsoleteAttributeData : object {
    private string _message;
    private bool _isError;
    public static ObsoleteAttributeData Uninitialized;
    public bool IsError { get; }
    public string Message { get; }
    internal bool IsUninitialized { get; }
    public ObsoleteAttributeData(string message, bool isError);
    private static ObsoleteAttributeData();
    public bool get_IsError();
    public string get_Message();
    internal bool get_IsUninitialized();
}
public enum Microsoft.CodeAnalysis.OptimizationLevel : Enum {
    public int value__;
    public static OptimizationLevel Debug;
    public static OptimizationLevel Release;
}
public class Microsoft.CodeAnalysis.Optional`1 : ValueType {
    private bool _hasValue;
    private T _value;
    public bool HasValue { get; }
    public T Value { get; }
    public Optional`1(T value);
    public bool get_HasValue();
    public T get_Value();
    public static Optional`1<T> op_Implicit(T value);
}
public enum Microsoft.CodeAnalysis.OutputKind : Enum {
    public int value__;
    public static OutputKind ConsoleApplication;
    public static OutputKind WindowsApplication;
    public static OutputKind DynamicallyLinkedLibrary;
    public static OutputKind NetModule;
    public static OutputKind WindowsRuntimeMetadata;
    public static OutputKind WindowsRuntimeApplication;
}
internal class Microsoft.CodeAnalysis.ParamInfo`1 : ValueType {
    internal bool IsByRef;
    internal bool HasByRefBeforeCustomModifiers;
    internal TypeSymbol Type;
    internal ParameterHandle Handle;
    internal ImmutableArray`1<ModifierInfo`1<TypeSymbol>> CustomModifiers;
}
public abstract class Microsoft.CodeAnalysis.ParseOptions : object {
    [CompilerGeneratedAttribute]
private SourceCodeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentationMode <DocumentationMode>k__BackingField;
    public SourceCodeKind Kind { get; protected set; }
    public DocumentationMode DocumentationMode { get; protected set; }
    public IReadOnlyDictionary`2<string, string> Features { get; }
    public IEnumerable`1<string> PreprocessorSymbolNames { get; }
    internal ParseOptions(SourceCodeKind kind, DocumentationMode documentationMode);
    [CompilerGeneratedAttribute]
public SourceCodeKind get_Kind();
    [CompilerGeneratedAttribute]
protected void set_Kind(SourceCodeKind value);
    [CompilerGeneratedAttribute]
public DocumentationMode get_DocumentationMode();
    [CompilerGeneratedAttribute]
protected void set_DocumentationMode(DocumentationMode value);
    internal ParseOptions WithKind(SourceCodeKind kind);
    internal abstract virtual ParseOptions CommonWithKind(SourceCodeKind kind);
    public ParseOptions WithDocumentationMode(DocumentationMode documentationMode);
    protected abstract virtual ParseOptions CommonWithDocumentationMode(DocumentationMode documentationMode);
    public ParseOptions WithFeatures(IEnumerable`1<KeyValuePair`2<string, string>> features);
    protected abstract virtual ParseOptions CommonWithFeatures(IEnumerable`1<KeyValuePair`2<string, string>> features);
    public abstract virtual IReadOnlyDictionary`2<string, string> get_Features();
    public abstract virtual IEnumerable`1<string> get_PreprocessorSymbolNames();
    public abstract virtual bool Equals(object obj);
    protected bool EqualsHelper(ParseOptions other);
    public abstract virtual int GetHashCode();
    protected int GetHashCodeHelper();
    private static int HashFeatures(IReadOnlyDictionary`2<string, string> features);
    public static bool op_Equality(ParseOptions left, ParseOptions right);
    public static bool op_Inequality(ParseOptions left, ParseOptions right);
}
internal class Microsoft.CodeAnalysis.PEAssembly : object {
    internal ImmutableArray`1<AssemblyIdentity> AssemblyReferences;
    internal ImmutableArray`1<int> ModuleReferenceCounts;
    private ImmutableArray`1<PEModule> _modules;
    private AssemblyIdentity _identity;
    private ThreeState _lazyContainsNoPiaLocalTypes;
    private ThreeState _lazyDeclaresTheObjectClass;
    private AssemblyMetadata _owner;
    private Dictionary`2<string, List`1<ImmutableArray`1<byte>>> _lazyInternalsVisibleToMap;
    internal EntityHandle Handle { get; }
    internal PEModule ManifestModule { get; }
    internal ImmutableArray`1<PEModule> Modules { get; }
    internal AssemblyIdentity Identity { get; }
    internal bool DeclaresTheObjectClass { get; }
    internal PEAssembly(AssemblyMetadata owner, ImmutableArray`1<PEModule> modules);
    internal EntityHandle get_Handle();
    internal PEModule get_ManifestModule();
    internal ImmutableArray`1<PEModule> get_Modules();
    internal AssemblyIdentity get_Identity();
    internal bool ContainsNoPiaLocalTypes();
    private Dictionary`2<string, List`1<ImmutableArray`1<byte>>> BuildInternalsVisibleToMap();
    internal IEnumerable`1<ImmutableArray`1<byte>> GetInternalsVisibleToPublicKeys(string simpleName);
    internal bool get_DeclaresTheObjectClass();
}
internal class Microsoft.CodeAnalysis.PEModule : object {
    private PEReader _peReaderOpt;
    private IntPtr _metadataPointerOpt;
    private int _metadataSizeOpt;
    private MetadataReader _lazyMetadataReader;
    private ImmutableArray`1<AssemblyIdentity> _lazyAssemblyReferences;
    private Dictionary`2<string, AssemblyReferenceHandle> _lazyForwardedTypesToAssemblyMap;
    private Lazy`1<IdentifierCollection> _lazyTypeNameCollection;
    private Lazy`1<IdentifierCollection> _lazyNamespaceNameCollection;
    private string _lazyName;
    private bool _isDisposed;
    private ThreeState _lazyContainsNoPiaLocalTypes;
    private Int32[] _lazyNoPiaLocalTypeCheckBitMap;
    private ConcurrentDictionary`2<TypeDefinitionHandle, AttributeInfo> _lazyTypeDefToTypeIdentifierMap;
    private CryptographicHashProvider _hashesOpt;
    private static AttributeValueExtractor`1<string> s_attributeStringValueExtractor;
    private static AttributeValueExtractor`1<StringAndInt> s_attributeStringAndIntValueExtractor;
    private static AttributeValueExtractor`1<short> s_attributeShortValueExtractor;
    private static AttributeValueExtractor`1<int> s_attributeIntValueExtractor;
    private static AttributeValueExtractor`1<long> s_attributeLongValueExtractor;
    private static AttributeValueExtractor`1<decimal> s_decimalValueInDecimalConstantAttributeExtractor;
    private static AttributeValueExtractor`1<ImmutableArray`1<bool>> s_attributeBoolArrayValueExtractor;
    private static AttributeValueExtractor`1<ObsoleteAttributeData> s_attributeObsoleteDataExtractor;
    private static AttributeValueExtractor`1<ObsoleteAttributeData> s_attributeDeprecatedDataExtractor;
    private static ImmutableArray`1<bool> s_simpleDynamicTransforms;
    internal bool IsDisposed { get; }
    internal PEReader PEReaderOpt { get; }
    internal MetadataReader MetadataReader { get; }
    internal bool IsManifestModule { get; }
    internal bool IsLinkedModule { get; }
    internal bool IsCOFFOnly { get; }
    internal Machine Machine { get; }
    internal bool Bit32Required { get; }
    internal string Name { get; }
    public ImmutableArray`1<AssemblyIdentity> ReferencedAssemblies { get; }
    internal string MetadataVersion { get; }
    internal IdentifierCollection TypeNames { get; }
    internal IdentifierCollection NamespaceNames { get; }
    internal bool HasIL { get; }
    internal bool IsEntireImageAvailable { get; }
    internal PEModule(PEReader peReader, IntPtr metadataOpt, int metadataSizeOpt, bool includeEmbeddedInteropTypes);
    private static PEModule();
    internal bool get_IsDisposed();
    public sealed virtual void Dispose();
    internal PEReader get_PEReaderOpt();
    internal MetadataReader get_MetadataReader();
    private void InitializeMetadataReader();
    private static void ThrowMetadataDisposed();
    internal bool get_IsManifestModule();
    internal bool get_IsLinkedModule();
    internal bool get_IsCOFFOnly();
    internal Machine get_Machine();
    internal bool get_Bit32Required();
    internal ImmutableArray`1<byte> GetHash(AssemblyHashAlgorithm algorithmId);
    internal string get_Name();
    internal Guid GetModuleVersionIdOrThrow();
    internal ImmutableArray`1<string> GetMetadataModuleNamesOrThrow();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.PEModule/<GetReferencedManagedModulesOrThrow>d__50")]
internal IEnumerable`1<string> GetReferencedManagedModulesOrThrow();
    internal ImmutableArray`1<EmbeddedResource> GetEmbeddedResourcesOrThrow();
    public string GetModuleRefNameOrThrow(ModuleReferenceHandle moduleRef);
    public ImmutableArray`1<AssemblyIdentity> get_ReferencedAssemblies();
    internal string get_MetadataVersion();
    internal BlobReader GetMemoryReaderOrThrow(BlobHandle blob);
    internal string GetFullNameOrThrow(StringHandle namespaceHandle, StringHandle nameHandle);
    internal AssemblyIdentity ReadAssemblyIdentityOrThrow();
    public TypeDefinitionHandle GetContainingTypeOrThrow(TypeDefinitionHandle typeDef);
    public string GetTypeDefNameOrThrow(TypeDefinitionHandle typeDef);
    public string GetTypeDefNamespaceOrThrow(TypeDefinitionHandle typeDef);
    public EntityHandle GetTypeDefExtendsOrThrow(TypeDefinitionHandle typeDef);
    public TypeAttributes GetTypeDefFlagsOrThrow(TypeDefinitionHandle typeDef);
    public GenericParameterHandleCollection GetTypeDefGenericParamsOrThrow(TypeDefinitionHandle typeDef);
    public bool HasGenericParametersOrThrow(TypeDefinitionHandle typeDef);
    public void GetTypeDefPropsOrThrow(TypeDefinitionHandle typeDef, String& name, String& namespace, TypeAttributes& flags, EntityHandle& extends);
    internal bool IsNestedTypeDefOrThrow(TypeDefinitionHandle typeDef);
    private static bool IsNestedTypeDefOrThrow(MetadataReader metadataReader, TypeDefinitionHandle typeDef);
    internal bool IsInterfaceOrThrow(TypeDefinitionHandle typeDef);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.PEModule/<GetTypeDefsOrThrow>d__72")]
private IEnumerable`1<TypeDefToNamespace> GetTypeDefsOrThrow(bool topLevelOnly);
    internal IEnumerable`1<IGrouping`2<string, TypeDefinitionHandle>> GroupTypesByNamespaceOrThrow(StringComparer nameComparer);
    private void GetTypeNamespaceNamesOrThrow(Dictionary`2<string, ArrayBuilder`1<TypeDefinitionHandle>> namespaces);
    private void GetForwardedTypeNamespaceNamesOrThrow(Dictionary`2<string, ArrayBuilder`1<TypeDefinitionHandle>> namespaces);
    private IdentifierCollection ComputeTypeNameCollection();
    private IdentifierCollection ComputeNamespaceNameCollection();
    internal ImmutableArray`1<TypeDefinitionHandle> GetNestedTypeDefsOrThrow(TypeDefinitionHandle container);
    internal MethodImplementationHandleCollection GetMethodImplementationsOrThrow(TypeDefinitionHandle typeDef);
    internal InterfaceImplementationHandleCollection GetInterfaceImplementationsOrThrow(TypeDefinitionHandle typeDef);
    internal MethodDefinitionHandleCollection GetMethodsOfTypeOrThrow(TypeDefinitionHandle typeDef);
    internal PropertyDefinitionHandleCollection GetPropertiesOfTypeOrThrow(TypeDefinitionHandle typeDef);
    internal EventDefinitionHandleCollection GetEventsOfTypeOrThrow(TypeDefinitionHandle typeDef);
    internal FieldDefinitionHandleCollection GetFieldsOfTypeOrThrow(TypeDefinitionHandle typeDef);
    internal EntityHandle GetBaseTypeOfTypeOrThrow(TypeDefinitionHandle typeDef);
    internal TypeLayout GetTypeLayout(TypeDefinitionHandle typeDef);
    internal bool IsNoPiaLocalType(TypeDefinitionHandle typeDef);
    internal bool HasParamsAttribute(EntityHandle token);
    internal bool HasExtensionAttribute(EntityHandle token, bool ignoreCase);
    internal bool HasVisualBasicEmbeddedAttribute(EntityHandle token);
    internal bool HasDefaultMemberAttribute(EntityHandle token, String& memberName);
    internal bool HasGuidAttribute(EntityHandle token, String& guidValue);
    internal bool HasFixedBufferAttribute(EntityHandle token, String& elementTypeName, Int32& bufferSize);
    internal bool HasAccessedThroughPropertyAttribute(EntityHandle token, String& propertyName);
    internal bool HasRequiredAttributeAttribute(EntityHandle token);
    internal bool HasAttribute(EntityHandle token, AttributeDescription description);
    internal CustomAttributeHandle GetAttributeHandle(EntityHandle token, AttributeDescription description);
    internal bool HasDynamicAttribute(EntityHandle token, ImmutableArray`1& dynamicTransforms);
    internal bool HasDeprecatedOrObsoleteAttribute(EntityHandle token, ObsoleteAttributeData& obsoleteData);
    internal CustomAttributeHandle GetAttributeUsageAttributeHandle(EntityHandle token);
    internal bool HasInterfaceTypeAttribute(EntityHandle token, ComInterfaceType& interfaceType);
    internal bool HasTypeLibTypeAttribute(EntityHandle token, TypeLibTypeFlags& flags);
    internal bool HasDateTimeConstantAttribute(EntityHandle token, ConstantValue& defaultValue);
    internal bool HasDecimalConstantAttribute(EntityHandle token, ConstantValue& defaultValue);
    internal ImmutableArray`1<string> GetInternalsVisibleToAttributeValues(EntityHandle token);
    internal ImmutableArray`1<string> GetConditionalAttributeValues(EntityHandle token);
    private ArrayBuilder`1<string> ExtractStringValuesFromAttributes(List`1<AttributeInfo> attrInfos);
    private bool TryExtractObsoleteDataFromAttribute(AttributeInfo attributeInfo, ObsoleteAttributeData& obsoleteData);
    private bool TryExtractDeprecatedDataFromAttribute(AttributeInfo attributeInfo, ObsoleteAttributeData& obsoleteData);
    private bool TryExtractInterfaceTypeFromAttribute(AttributeInfo attributeInfo, ComInterfaceType& interfaceType);
    private static bool IsValidComInterfaceType(int comInterfaceType);
    private bool TryExtractTypeLibTypeFromAttribute(AttributeInfo info, TypeLibTypeFlags& flags);
    internal bool TryExtractStringValueFromAttribute(CustomAttributeHandle handle, String& value);
    private bool TryExtractLongValueFromAttribute(CustomAttributeHandle handle, Int64& value);
    private bool TryExtractDecimalValueFromDecimalConstantAttribute(CustomAttributeHandle handle, Decimal& value);
    private bool TryExtractStringAndIntValueFromAttribute(CustomAttributeHandle handle, String& stringValue, Int32& intValue);
    private bool TryExtractBoolArrayValueFromAttribute(CustomAttributeHandle handle, ImmutableArray`1& value);
    private bool TryExtractValueFromAttribute(CustomAttributeHandle handle, T& value, AttributeValueExtractor`1<T> valueExtractor);
    internal bool HasStringValuedAttribute(EntityHandle token, AttributeDescription description, String& value);
    private bool HasStringAndIntValuedAttribute(EntityHandle token, AttributeDescription description, String& stringValue, Int32& intValue);
    internal bool IsNoPiaLocalType(TypeDefinitionHandle typeDef, String& interfaceGuid, String& scope, String& identifier);
    internal static bool CrackObsoleteAttributeData(ObsoleteAttributeData& value, BlobReader& sig);
    internal static bool CrackDeprecatedAttributeData(ObsoleteAttributeData& value, BlobReader& sig);
    private static bool CrackStringAndIntInAttributeValue(StringAndInt& value, BlobReader& sig);
    internal static bool CrackStringInAttributeValue(String& value, BlobReader& sig);
    internal static bool CrackStringArrayInAttributeValue(ImmutableArray`1& value, BlobReader& sig);
    internal static bool CrackByteInAttributeValue(Byte& value, BlobReader& sig);
    internal static bool CrackShortInAttributeValue(Int16& value, BlobReader& sig);
    internal static bool CrackIntInAttributeValue(Int32& value, BlobReader& sig);
    internal static bool CrackLongInAttributeValue(Int64& value, BlobReader& sig);
    internal static bool CrackDecimalInDecimalConstantAttribute(Decimal& value, BlobReader& sig);
    internal static bool CrackBoolArrayInAttributeValue(ImmutableArray`1& value, BlobReader& sig);
    internal List`1<AttributeInfo> FindTargetAttributes(EntityHandle hasAttribute, AttributeDescription description);
    private AttributeInfo FindTargetAttribute(EntityHandle hasAttribute, AttributeDescription description);
    internal static AttributeInfo FindTargetAttribute(MetadataReader metadataReader, EntityHandle hasAttribute, AttributeDescription description);
    internal AttributeInfo FindLastTargetAttribute(EntityHandle hasAttribute, AttributeDescription description);
    internal int GetParamArrayCountOrThrow(EntityHandle hasAttribute);
    private bool IsNoPiaLocalType(TypeDefinitionHandle typeDef, AttributeInfo& attributeInfo);
    private void RegisterNoPiaLocalType(TypeDefinitionHandle typeDef, CustomAttributeHandle customAttribute, int signatureIndex);
    private void RecordNoPiaLocalTypeCheck(TypeDefinitionHandle typeDef);
    private int IsTypeIdentifierAttribute(CustomAttributeHandle customAttribute);
    internal bool IsTargetAttribute(CustomAttributeHandle customAttribute, string namespaceName, string typeName, EntityHandle& ctor, bool ignoreCase);
    private static bool IsTargetAttribute(MetadataReader metadataReader, CustomAttributeHandle customAttribute, string namespaceName, string typeName, EntityHandle& ctor, bool ignoreCase);
    internal AssemblyReferenceHandle GetAssemblyRef(string assemblyName);
    internal EntityHandle GetTypeRef(EntityHandle resolutionScope, string namespaceName, string typeName);
    public void GetTypeRefPropsOrThrow(TypeReferenceHandle handle, String& name, String& namespace, EntityHandle& resolutionScope);
    internal int GetTargetAttributeSignatureIndex(CustomAttributeHandle customAttribute, AttributeDescription description);
    private static int GetTargetAttributeSignatureIndex(MetadataReader metadataReader, CustomAttributeHandle customAttribute, AttributeDescription description);
    internal bool GetTypeAndConstructor(CustomAttributeHandle customAttribute, EntityHandle& ctorType, EntityHandle& attributeCtor);
    private static bool GetTypeAndConstructor(MetadataReader metadataReader, CustomAttributeHandle customAttribute, EntityHandle& ctorType, EntityHandle& attributeCtor);
    internal bool GetAttributeNamespaceAndName(EntityHandle typeDefOrRef, StringHandle& namespaceHandle, StringHandle& nameHandle);
    private static bool GetAttributeNamespaceAndName(MetadataReader metadataReader, EntityHandle typeDefOrRef, StringHandle& namespaceHandle, StringHandle& nameHandle);
    internal void PretendThereArentNoPiaLocalTypes();
    internal bool ContainsNoPiaLocalTypes();
    internal BlobReader GetTypeSpecificationSignatureReaderOrThrow(TypeSpecificationHandle typeSpec);
    internal void GetMethodSpecificationOrThrow(MethodSpecificationHandle handle, EntityHandle& method, BlobHandle& instantiation);
    internal void GetGenericParamPropsOrThrow(GenericParameterHandle handle, String& name, GenericParameterAttributes& flags);
    internal EntityHandle[] GetGenericParamConstraintsOrThrow(GenericParameterHandle genericParam);
    internal string GetMethodDefNameOrThrow(MethodDefinitionHandle methodDef);
    internal BlobHandle GetMethodSignatureOrThrow(MethodDefinitionHandle methodDef);
    private static BlobHandle GetMethodSignatureOrThrow(MetadataReader metadataReader, MethodDefinitionHandle methodDef);
    internal BlobHandle GetMethodSignatureOrThrow(EntityHandle methodDefOrRef);
    private static BlobHandle GetMethodSignatureOrThrow(MetadataReader metadataReader, EntityHandle methodDefOrRef);
    public MethodAttributes GetMethodDefFlagsOrThrow(MethodDefinitionHandle methodDef);
    internal TypeDefinitionHandle FindContainingTypeOrThrow(MethodDefinitionHandle methodDef);
    internal TypeDefinitionHandle FindContainingTypeOrThrow(FieldDefinitionHandle fieldDef);
    internal EntityHandle GetContainingTypeOrThrow(MemberReferenceHandle memberRef);
    public void GetMethodDefPropsOrThrow(MethodDefinitionHandle methodDef, String& name, MethodImplAttributes& implFlags, MethodAttributes& flags, Int32& rva);
    internal void GetMethodImplPropsOrThrow(MethodImplementationHandle methodImpl, EntityHandle& body, EntityHandle& declaration);
    internal GenericParameterHandleCollection GetGenericParametersForMethodOrThrow(MethodDefinitionHandle methodDef);
    internal ParameterHandleCollection GetParametersOfMethodOrThrow(MethodDefinitionHandle methodDef);
    internal DllImportData GetDllImportData(MethodDefinitionHandle methodDef);
    public string GetMemberRefNameOrThrow(MemberReferenceHandle memberRef);
    private static string GetMemberRefNameOrThrow(MetadataReader metadataReader, MemberReferenceHandle memberRef);
    internal BlobHandle GetSignatureOrThrow(MemberReferenceHandle memberRef);
    private static BlobHandle GetSignatureOrThrow(MetadataReader metadataReader, MemberReferenceHandle memberRef);
    public void GetMemberRefPropsOrThrow(MemberReferenceHandle memberRef, EntityHandle& class, String& name, Byte[]& signature);
    internal void GetParamPropsOrThrow(ParameterHandle parameterDef, String& name, ParameterAttributes& flags);
    internal int GetParameterSequenceNumberOrThrow(ParameterHandle param);
    internal string GetPropertyDefNameOrThrow(PropertyDefinitionHandle propertyDef);
    internal BlobHandle GetPropertySignatureOrThrow(PropertyDefinitionHandle propertyDef);
    internal void GetPropertyDefPropsOrThrow(PropertyDefinitionHandle propertyDef, String& name, PropertyAttributes& flags);
    internal string GetEventDefNameOrThrow(EventDefinitionHandle eventDef);
    internal void GetEventDefPropsOrThrow(EventDefinitionHandle eventDef, String& name, EventAttributes& flags, EntityHandle& type);
    public string GetFieldDefNameOrThrow(FieldDefinitionHandle fieldDef);
    internal BlobHandle GetFieldSignatureOrThrow(FieldDefinitionHandle fieldDef);
    public FieldAttributes GetFieldDefFlagsOrThrow(FieldDefinitionHandle fieldDef);
    public void GetFieldDefPropsOrThrow(FieldDefinitionHandle fieldDef, String& name, FieldAttributes& flags);
    internal ConstantValue GetParamDefaultValue(ParameterHandle param);
    internal ConstantValue GetConstantFieldValue(FieldDefinitionHandle fieldDef);
    public CustomAttributeHandleCollection GetCustomAttributesOrThrow(EntityHandle handle);
    public BlobHandle GetCustomAttributeValueOrThrow(CustomAttributeHandle handle);
    private BlobHandle GetMarshallingDescriptorHandleOrThrow(EntityHandle fieldOrParameterToken);
    internal UnmanagedType GetMarshallingType(EntityHandle fieldOrParameterToken);
    internal ImmutableArray`1<byte> GetMarshallingDescriptor(EntityHandle fieldOrParameterToken);
    internal Nullable`1<int> GetFieldOffset(FieldDefinitionHandle fieldDef);
    private ConstantValue GetConstantValueOrThrow(ConstantHandle handle);
    internal AssemblyReferenceHandle GetAssemblyForForwardedType(string fullName, bool ignoreCase, String& matchedName);
    internal IEnumerable`1<KeyValuePair`2<string, AssemblyReferenceHandle>> GetForwardedTypes();
    private void EnsureForwardTypeToAssemblyMap();
    internal IdentifierCollection get_TypeNames();
    internal IdentifierCollection get_NamespaceNames();
    internal PropertyAccessors GetPropertyMethodsOrThrow(PropertyDefinitionHandle propertyDef);
    internal EventAccessors GetEventMethodsOrThrow(EventDefinitionHandle eventDef);
    internal int GetAssemblyReferenceIndexOrThrow(AssemblyReferenceHandle assemblyRef);
    internal static bool IsNested(TypeAttributes flags);
    internal bool get_HasIL();
    internal bool get_IsEntireImageAvailable();
    internal MethodBodyBlock GetMethodBodyOrThrow(MethodDefinitionHandle methodHandle);
    private static bool StringEquals(MetadataReader metadataReader, StringHandle nameHandle, string name, bool ignoreCase);
    [CompilerGeneratedAttribute]
private <>f__AnonymousType6`2<TypeDefToNamespace, string> <ComputeTypeNameCollection>b__78_0(TypeDefToNamespace typeDef);
    [CompilerGeneratedAttribute]
private string <ComputeNamespaceNameCollection>b__79_1(TypeDefToNamespace id);
}
public enum Microsoft.CodeAnalysis.Platform : Enum {
    public int value__;
    public static Platform AnyCpu;
    public static Platform X86;
    public static Platform X64;
    public static Platform Itanium;
    public static Platform AnyCpu32BitPreferred;
    public static Platform Arm;
}
public abstract class Microsoft.CodeAnalysis.PortableExecutableReference : MetadataReference {
    private string _filePath;
    private DocumentationProvider _lazyDocumentation;
    public string Display { get; }
    public string FilePath { get; }
    internal DocumentationProvider DocumentationProvider { get; }
    protected PortableExecutableReference(MetadataReferenceProperties properties, string fullPath, DocumentationProvider initialDocumentation);
    public virtual string get_Display();
    public string get_FilePath();
    internal DocumentationProvider get_DocumentationProvider();
    protected abstract virtual DocumentationProvider CreateDocumentationProvider();
    public PortableExecutableReference WithAliases(IEnumerable`1<string> aliases);
    public PortableExecutableReference WithAliases(ImmutableArray`1<string> aliases);
    public PortableExecutableReference WithEmbedInteropTypes(bool value);
    public PortableExecutableReference WithProperties(MetadataReferenceProperties properties);
    internal sealed virtual MetadataReference WithPropertiesImplReturningMetadataReference(MetadataReferenceProperties properties);
    protected abstract virtual PortableExecutableReference WithPropertiesImpl(MetadataReferenceProperties properties);
    protected abstract virtual Metadata GetMetadataImpl();
    internal Metadata GetMetadata();
    internal static Diagnostic ExceptionToDiagnostic(Exception e, CommonMessageProvider messageProvider, Location location, string display, MetadataImageKind kind);
}
public class Microsoft.CodeAnalysis.PreprocessingSymbolInfo : ValueType {
    internal static PreprocessingSymbolInfo None;
    [CompilerGeneratedAttribute]
private IPreprocessingSymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefined>k__BackingField;
    public IPreprocessingSymbol Symbol { get; }
    public bool IsDefined { get; }
    internal PreprocessingSymbolInfo(IPreprocessingSymbol symbol, bool isDefined);
    private static PreprocessingSymbolInfo();
    [CompilerGeneratedAttribute]
public IPreprocessingSymbol get_Symbol();
    [CompilerGeneratedAttribute]
public bool get_IsDefined();
    public sealed virtual bool Equals(PreprocessingSymbolInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.PrimitiveTypeCodeExtensions : object {
    [ExtensionAttribute]
public static bool IsNumeric(PrimitiveTypeCode kind);
    [ExtensionAttribute]
public static bool IsIntegral(PrimitiveTypeCode kind);
    [ExtensionAttribute]
public static bool Is64BitIntegral(PrimitiveTypeCode kind);
    [ExtensionAttribute]
public static bool IsSigned(PrimitiveTypeCode kind);
    [ExtensionAttribute]
public static bool IsUnsigned(PrimitiveTypeCode kind);
    [ExtensionAttribute]
public static bool IsFloatingPoint(PrimitiveTypeCode kind);
    [ExtensionAttribute]
public static ConstantValueTypeDiscriminator GetConstantValueTypeDiscriminator(PrimitiveTypeCode type);
}
internal class Microsoft.CodeAnalysis.ReadOnlyUnmanagedMemoryStream : Stream {
    private object _memoryOwner;
    private IntPtr _data;
    private int _length;
    private int _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ReadOnlyUnmanagedMemoryStream(object memoryOwner, IntPtr data, int length);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class Microsoft.CodeAnalysis.ReferenceDirective : ValueType {
    public string File;
    public Location Location;
    public ReferenceDirective(string file, Location location);
}
public enum Microsoft.CodeAnalysis.RefKind : Enum {
    public byte value__;
    public static RefKind None;
    public static RefKind Ref;
    public static RefKind Out;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.RefKindExtensions : object {
    [ExtensionAttribute]
internal static string ToDisplayString(RefKind kind);
    [ExtensionAttribute]
internal static string ToPrefix(RefKind kind);
}
public enum Microsoft.CodeAnalysis.ReportDiagnostic : Enum {
    public int value__;
    public static ReportDiagnostic Default;
    public static ReportDiagnostic Error;
    public static ReportDiagnostic Warn;
    public static ReportDiagnostic Info;
    public static ReportDiagnostic Hidden;
    public static ReportDiagnostic Suppress;
}
internal class Microsoft.CodeAnalysis.RESOURCE : object {
    internal RESOURCE_STRING pstringType;
    internal RESOURCE_STRING pstringName;
    internal UInt32 DataSize;
    internal UInt32 HeaderSize;
    internal UInt32 DataVersion;
    internal ushort MemoryFlags;
    internal ushort LanguageId;
    internal UInt32 Version;
    internal UInt32 Characteristics;
    internal Byte[] data;
}
internal class Microsoft.CodeAnalysis.RESOURCE_STRING : object {
    internal ushort Ordinal;
    internal string theString;
}
public class Microsoft.CodeAnalysis.ResourceDescription : object {
    internal string ResourceName;
    internal string FileName;
    internal bool IsPublic;
    internal Func`1<Stream> DataProvider;
    private CryptographicHashProvider _hashes;
    internal bool IsEmbedded { get; }
    private string Microsoft.Cci.IFileReference.FileName { get; }
    private bool Microsoft.Cci.IFileReference.HasMetadata { get; }
    public ResourceDescription(string resourceName, Func`1<Stream> dataProvider, bool isPublic);
    public ResourceDescription(string resourceName, string fileName, Func`1<Stream> dataProvider, bool isPublic);
    internal ResourceDescription(string resourceName, string fileName, Func`1<Stream> dataProvider, bool isPublic, bool isEmbedded, bool checkArgs);
    internal bool get_IsEmbedded();
    internal ManagedResource ToManagedResource(IModule moduleBeingBuilt);
    private sealed virtual override ImmutableArray`1<byte> Microsoft.Cci.IFileReference.GetHashValue(AssemblyHashAlgorithm algorithmId);
    private sealed virtual override string Microsoft.Cci.IFileReference.get_FileName();
    private sealed virtual override bool Microsoft.Cci.IFileReference.get_HasMetadata();
}
internal class Microsoft.CodeAnalysis.ResourceException : Exception {
    internal ResourceException(string name, Exception inner);
}
public class Microsoft.CodeAnalysis.RuleSet : object {
    private string _filePath;
    private ReportDiagnostic _generalDiagnosticOption;
    private ImmutableDictionary`2<string, ReportDiagnostic> _specificDiagnosticOptions;
    private ImmutableArray`1<RuleSetInclude> _includes;
    public string FilePath { get; }
    public ReportDiagnostic GeneralDiagnosticOption { get; }
    public ImmutableDictionary`2<string, ReportDiagnostic> SpecificDiagnosticOptions { get; }
    public ImmutableArray`1<RuleSetInclude> Includes { get; }
    public RuleSet(string filePath, ReportDiagnostic generalOption, ImmutableDictionary`2<string, ReportDiagnostic> specificOptions, ImmutableArray`1<RuleSetInclude> includes);
    public string get_FilePath();
    public ReportDiagnostic get_GeneralDiagnosticOption();
    public ImmutableDictionary`2<string, ReportDiagnostic> get_SpecificDiagnosticOptions();
    public ImmutableArray`1<RuleSetInclude> get_Includes();
    public RuleSet WithEffectiveAction(ReportDiagnostic action);
    private RuleSet GetEffectiveRuleSet(HashSet`1<string> includedRulesetPaths);
    private ImmutableArray`1<string> GetEffectiveIncludes();
    private void GetEffectiveIncludesCore(Builder<string> arrayBuilder);
    private static bool IsStricterThan(ReportDiagnostic action1, ReportDiagnostic action2);
    public static RuleSet LoadEffectiveRuleSetFromFile(string filePath);
    public static ImmutableArray`1<string> GetEffectiveIncludesFromFile(string filePath);
    public static ReportDiagnostic GetDiagnosticOptionsFromRulesetFile(string rulesetFileFullPath, Dictionary`2& specificDiagnosticOptions);
    internal static ReportDiagnostic GetDiagnosticOptionsFromRulesetFile(Dictionary`2<string, ReportDiagnostic> diagnosticOptions, string path, string baseDirectory, IList`1<Diagnostic> diagnosticsOpt, CommonMessageProvider messageProviderOpt);
    private static ReportDiagnostic GetDiagnosticOptionsFromRulesetFile(Dictionary`2<string, ReportDiagnostic> diagnosticOptions, string resolvedPath, IList`1<Diagnostic> diagnosticsOpt, CommonMessageProvider messageProviderOpt);
}
public class Microsoft.CodeAnalysis.RuleSetInclude : object {
    private string _includePath;
    private ReportDiagnostic _action;
    public string IncludePath { get; }
    public ReportDiagnostic Action { get; }
    public RuleSetInclude(string includePath, ReportDiagnostic action);
    public string get_IncludePath();
    public ReportDiagnostic get_Action();
    public RuleSet LoadRuleSet(RuleSet parent);
    private string GetIncludePath(RuleSet parent);
}
internal class Microsoft.CodeAnalysis.RuleSetProcessor : object {
    private static string RuleSetNodeName;
    private static string RuleSetNameAttributeName;
    private static string RuleSetDescriptionAttributeName;
    private static string RuleSetToolsVersionAttributeName;
    private static string RulesNodeName;
    private static string RulesAnalyzerIdAttributeName;
    private static string RulesNamespaceAttributeName;
    private static string RuleNodeName;
    private static string RuleIdAttributeName;
    private static string IncludeNodeName;
    private static string IncludePathAttributeName;
    private static string IncludeAllNodeName;
    private static string RuleActionAttributeName;
    private static string RuleActionNoneValue;
    private static string RuleActionHiddenValue;
    private static string RuleActionInfoValue;
    private static string RuleActionWarningValue;
    private static string RuleActionErrorValue;
    private static string RuleActionDefaultValue;
    public static RuleSet LoadFromFile(string filePath);
    private static RuleSet ReadRuleSet(XElement ruleSetNode, string filePath);
    private static List`1<KeyValuePair`2<string, ReportDiagnostic>> ReadRules(XElement rulesNode);
    private static KeyValuePair`2<string, ReportDiagnostic> ReadRule(XElement ruleNode, string analyzer, string space);
    private static RuleSetInclude ReadRuleSetInclude(XElement includeNode);
    private static ReportDiagnostic ReadAction(XElement node, bool allowDefault);
    private static ReportDiagnostic ReadIncludeAll(XElement includeAllNode);
    private static string ReadNonEmptyAttribute(XElement node, string attributeName);
    private static XmlReaderSettings GetDefaultXmlReaderSettings();
    private static void ValidateAttribute(XElement node, string attributeName);
}
internal class Microsoft.CodeAnalysis.RuntimeMembers.MemberDescriptor : ValueType {
    public MemberFlags Flags;
    public byte DeclaringTypeId;
    public ushort Arity;
    public string Name;
    public ImmutableArray`1<byte> Signature;
    public string DeclaringTypeMetadataName { get; }
    public MemberDescriptor(MemberFlags Flags, byte DeclaringTypeId, string Name, ImmutableArray`1<byte> Signature, ushort Arity);
    public string get_DeclaringTypeMetadataName();
    internal static ImmutableArray`1<MemberDescriptor> InitializeFromStream(Stream stream, String[] nameTable);
    private static void ParseMethodOrPropertySignature(Builder<byte> builder, Stream stream);
    private static void ParseType(Builder<byte> builder, Stream stream, bool allowByRef);
    private static void ParseGenericTypeInstance(Builder<byte> builder, Stream stream);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.RuntimeMembers.MemberFlags : Enum {
    public byte value__;
    public static MemberFlags Method;
    public static MemberFlags Field;
    public static MemberFlags Constructor;
    public static MemberFlags PropertyGet;
    public static MemberFlags Property;
    public static MemberFlags KindMask;
    public static MemberFlags Static;
    public static MemberFlags Virtual;
}
internal abstract class Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5 : object {
    public bool MatchFieldSignature(FieldSymbol field, ImmutableArray`1<byte> signature);
    public bool MatchPropertySignature(PropertySymbol property, ImmutableArray`1<byte> signature);
    public bool MatchMethodSignature(MethodSymbol method, ImmutableArray`1<byte> signature);
    private bool MatchParameter(ParameterSymbol parameter, ImmutableArray`1<byte> signature, Int32& position);
    private bool MatchType(TypeSymbol type, ImmutableArray`1<byte> signature, Int32& position);
    protected abstract virtual TypeSymbol GetGenericTypeArgument(TypeSymbol type, int argumentIndex);
    protected abstract virtual TypeSymbol GetGenericTypeDefinition(TypeSymbol type);
    protected abstract virtual bool IsGenericMethodTypeParam(TypeSymbol type, int paramPosition);
    protected abstract virtual bool IsGenericTypeParam(TypeSymbol type, int paramPosition);
    protected abstract virtual TypeSymbol GetPointedToType(TypeSymbol type);
    protected abstract virtual TypeSymbol GetSZArrayElementType(TypeSymbol type);
    protected abstract virtual bool MatchArrayRank(TypeSymbol type, int countOfDimensions);
    protected abstract virtual TypeSymbol GetArrayElementType(TypeSymbol type);
    protected abstract virtual bool MatchTypeToTypeId(TypeSymbol type, int typeId);
    protected abstract virtual TypeSymbol GetReturnType(MethodSymbol method);
    protected abstract virtual ImmutableArray`1<ParameterSymbol> GetParameters(MethodSymbol method);
    protected abstract virtual TypeSymbol GetPropertyType(PropertySymbol property);
    protected abstract virtual ImmutableArray`1<ParameterSymbol> GetParameters(PropertySymbol property);
    protected abstract virtual TypeSymbol GetParamType(ParameterSymbol parameter);
    protected abstract virtual bool IsByRefParam(ParameterSymbol parameter);
    protected abstract virtual TypeSymbol GetFieldType(FieldSymbol field);
}
internal class Microsoft.CodeAnalysis.SecurityWellKnownAttributeData : object {
    private Byte[] _lazySecurityActions;
    private String[] _lazyPathsForPermissionSetFixup;
    public void SetSecurityAttribute(int attributeIndex, SecurityAction action, int totalSourceAttributes);
    public void SetPathForPermissionSetAttributeFixup(int attributeIndex, string resolvedFilePath, int totalSourceAttributes);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SecurityWellKnownAttributeData/<GetSecurityAttributes>d__4`1")]
public IEnumerable`1<SecurityAttribute> GetSecurityAttributes(ImmutableArray`1<T> customAttributes);
}
public abstract class Microsoft.CodeAnalysis.SemanticModel : object {
    public string Language { get; }
    public Compilation Compilation { get; }
    protected Compilation CompilationCore { get; }
    public SyntaxTree SyntaxTree { get; }
    protected SyntaxTree SyntaxTreeCore { get; }
    public bool IgnoresAccessibility { get; }
    public bool IsSpeculativeSemanticModel { get; }
    public int OriginalPositionForSpeculation { get; }
    public SemanticModel ParentModel { get; }
    protected SemanticModel ParentModelCore { get; }
    public abstract virtual string get_Language();
    public Compilation get_Compilation();
    protected abstract virtual Compilation get_CompilationCore();
    public SyntaxTree get_SyntaxTree();
    protected abstract virtual SyntaxTree get_SyntaxTreeCore();
    public virtual bool get_IgnoresAccessibility();
    internal SymbolInfo GetSymbolInfo(SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual SymbolInfo GetSymbolInfoCore(SyntaxNode node, CancellationToken cancellationToken);
    internal SymbolInfo GetSpeculativeSymbolInfo(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    protected abstract virtual SymbolInfo GetSpeculativeSymbolInfoCore(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    internal TypeInfo GetSpeculativeTypeInfo(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    protected abstract virtual TypeInfo GetSpeculativeTypeInfoCore(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    internal TypeInfo GetTypeInfo(SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual TypeInfo GetTypeInfoCore(SyntaxNode node, CancellationToken cancellationToken);
    internal IAliasSymbol GetAliasInfo(SyntaxNode nameSyntax, CancellationToken cancellationToken);
    protected abstract virtual IAliasSymbol GetAliasInfoCore(SyntaxNode nameSyntax, CancellationToken cancellationToken);
    public abstract virtual bool get_IsSpeculativeSemanticModel();
    public abstract virtual int get_OriginalPositionForSpeculation();
    public SemanticModel get_ParentModel();
    protected abstract virtual SemanticModel get_ParentModelCore();
    internal IAliasSymbol GetSpeculativeAliasInfo(int position, SyntaxNode nameSyntax, SpeculativeBindingOption bindingOption);
    protected abstract virtual IAliasSymbol GetSpeculativeAliasInfoCore(int position, SyntaxNode nameSyntax, SpeculativeBindingOption bindingOption);
    public abstract virtual ImmutableArray`1<Diagnostic> GetSyntaxDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<Diagnostic> GetDeclarationDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<Diagnostic> GetMethodBodyDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<Diagnostic> GetDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    internal ISymbol GetDeclaredSymbolForNode(SyntaxNode declaration, CancellationToken cancellationToken);
    protected abstract virtual ISymbol GetDeclaredSymbolCore(SyntaxNode declaration, CancellationToken cancellationToken);
    internal ImmutableArray`1<ISymbol> GetDeclaredSymbolsForNode(SyntaxNode declaration, CancellationToken cancellationToken);
    protected abstract virtual ImmutableArray`1<ISymbol> GetDeclaredSymbolsCore(SyntaxNode declaration, CancellationToken cancellationToken);
    public ImmutableArray`1<ISymbol> LookupSymbols(int position, INamespaceOrTypeSymbol container, string name, bool includeReducedExtensionMethods);
    protected abstract virtual ImmutableArray`1<ISymbol> LookupSymbolsCore(int position, INamespaceOrTypeSymbol container, string name, bool includeReducedExtensionMethods);
    public ImmutableArray`1<ISymbol> LookupBaseMembers(int position, string name);
    protected abstract virtual ImmutableArray`1<ISymbol> LookupBaseMembersCore(int position, string name);
    public ImmutableArray`1<ISymbol> LookupStaticMembers(int position, INamespaceOrTypeSymbol container, string name);
    protected abstract virtual ImmutableArray`1<ISymbol> LookupStaticMembersCore(int position, INamespaceOrTypeSymbol container, string name);
    public ImmutableArray`1<ISymbol> LookupNamespacesAndTypes(int position, INamespaceOrTypeSymbol container, string name);
    protected abstract virtual ImmutableArray`1<ISymbol> LookupNamespacesAndTypesCore(int position, INamespaceOrTypeSymbol container, string name);
    public ImmutableArray`1<ISymbol> LookupLabels(int position, string name);
    protected abstract virtual ImmutableArray`1<ISymbol> LookupLabelsCore(int position, string name);
    internal ControlFlowAnalysis AnalyzeControlFlow(SyntaxNode firstStatement, SyntaxNode lastStatement);
    protected abstract virtual ControlFlowAnalysis AnalyzeControlFlowCore(SyntaxNode firstStatement, SyntaxNode lastStatement);
    internal ControlFlowAnalysis AnalyzeControlFlow(SyntaxNode statement);
    protected abstract virtual ControlFlowAnalysis AnalyzeControlFlowCore(SyntaxNode statement);
    internal DataFlowAnalysis AnalyzeDataFlow(SyntaxNode firstStatement, SyntaxNode lastStatement);
    protected abstract virtual DataFlowAnalysis AnalyzeDataFlowCore(SyntaxNode firstStatement, SyntaxNode lastStatement);
    internal DataFlowAnalysis AnalyzeDataFlow(SyntaxNode statementOrExpression);
    protected abstract virtual DataFlowAnalysis AnalyzeDataFlowCore(SyntaxNode statementOrExpression);
    public Optional`1<object> GetConstantValue(SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual Optional`1<object> GetConstantValueCore(SyntaxNode node, CancellationToken cancellationToken);
    internal ImmutableArray`1<ISymbol> GetMemberGroup(SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual ImmutableArray`1<ISymbol> GetMemberGroupCore(SyntaxNode node, CancellationToken cancellationToken);
    public ISymbol GetEnclosingSymbol(int position, CancellationToken cancellationToken);
    protected abstract virtual ISymbol GetEnclosingSymbolCore(int position, CancellationToken cancellationToken);
    public bool IsAccessible(int position, ISymbol symbol);
    protected abstract virtual bool IsAccessibleCore(int position, ISymbol symbol);
    public bool IsEventUsableAsField(int position, IEventSymbol eventSymbol);
    protected abstract virtual bool IsEventUsableAsFieldCore(int position, IEventSymbol eventSymbol);
    public PreprocessingSymbolInfo GetPreprocessingSymbolInfo(SyntaxNode nameSyntax);
    protected abstract virtual PreprocessingSymbolInfo GetPreprocessingSymbolInfoCore(SyntaxNode nameSyntax);
    internal abstract virtual ImmutableArray`1<DeclarationInfo> GetDeclarationsInSpan(TextSpan span, bool getSymbol, CancellationToken cancellationToken);
    internal abstract virtual ImmutableArray`1<DeclarationInfo> GetDeclarationsInNode(SyntaxNode node, bool getSymbol, CancellationToken cancellationToken, Nullable`1<int> levelsToCompute);
    protected internal virtual SyntaxNode GetTopmostNodeForDiagnosticAnalysis(ISymbol symbol, SyntaxNode declaringSyntax);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.CodeAnalysis.SeparatedSyntaxList`1 : ValueType {
    private SyntaxNodeOrTokenList _list;
    private int _count;
    private int _separatorCount;
    internal SyntaxNode Node { get; }
    public int Count { get; }
    public int SeparatorCount { get; }
    public TNode Item { get; }
    public TextSpan FullSpan { get; }
    public TextSpan Span { get; }
    private TNode[] Nodes { get; }
    private SyntaxNodeOrToken[] NodesWithSeparators { get; }
    internal SeparatedSyntaxList`1(SyntaxNodeOrTokenList list);
    internal SeparatedSyntaxList`1(SyntaxNode node, int index);
    [ConditionalAttribute("DEBUG")]
private static void Validate(SyntaxNodeOrTokenList list);
    internal SyntaxNode get_Node();
    public sealed virtual int get_Count();
    public int get_SeparatorCount();
    public sealed virtual TNode get_Item(int index);
    public SyntaxToken GetSeparator(int index);
    public IEnumerable`1<SyntaxToken> GetSeparators();
    public TextSpan get_FullSpan();
    public TextSpan get_Span();
    public virtual string ToString();
    public string ToFullString();
    public TNode First();
    public TNode FirstOrDefault();
    public TNode Last();
    public TNode LastOrDefault();
    public bool Contains(TNode node);
    public int IndexOf(TNode node);
    public int IndexOf(Func`2<TNode, bool> predicate);
    internal int IndexOf(int rawKind);
    public int LastIndexOf(TNode node);
    public int LastIndexOf(Func`2<TNode, bool> predicate);
    public bool Any();
    public SyntaxNodeOrTokenList GetWithSeparators();
    public static bool op_Equality(SeparatedSyntaxList`1<TNode> left, SeparatedSyntaxList`1<TNode> right);
    public static bool op_Inequality(SeparatedSyntaxList`1<TNode> left, SeparatedSyntaxList`1<TNode> right);
    public sealed virtual bool Equals(SeparatedSyntaxList`1<TNode> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public SeparatedSyntaxList`1<TNode> Add(TNode node);
    public SeparatedSyntaxList`1<TNode> AddRange(IEnumerable`1<TNode> nodes);
    public SeparatedSyntaxList`1<TNode> Insert(int index, TNode node);
    public SeparatedSyntaxList`1<TNode> InsertRange(int index, IEnumerable`1<TNode> nodes);
    private static bool KeepSeparatorWithPreviousNode(SyntaxToken separator);
    public SeparatedSyntaxList`1<TNode> RemoveAt(int index);
    public SeparatedSyntaxList`1<TNode> Remove(TNode node);
    public SeparatedSyntaxList`1<TNode> Replace(TNode nodeInList, TNode newNode);
    public SeparatedSyntaxList`1<TNode> ReplaceRange(TNode nodeInList, IEnumerable`1<TNode> newNodes);
    public SeparatedSyntaxList`1<TNode> ReplaceSeparator(SyntaxToken separatorToken, SyntaxToken newSeparator);
    private TNode[] get_Nodes();
    private SyntaxNodeOrToken[] get_NodesWithSeparators();
    public Enumerator<TNode> GetEnumerator();
    private sealed virtual override IEnumerator`1<TNode> System.Collections.Generic.IEnumerable<TNode>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.SmallDictionary`2 : object {
    private AvlNode<K, V> _root;
    private IEqualityComparer`1<K> _comparer;
    public static SmallDictionary`2<K, V> Empty;
    public V Item { get; public set; }
    public KeyCollection<K, V> Keys { get; }
    public ValueCollection<K, V> Values { get; }
    public SmallDictionary`2(IEqualityComparer`1<K> comparer);
    public SmallDictionary`2(SmallDictionary`2<K, V> other, IEqualityComparer`1<K> comparer);
    private static SmallDictionary`2();
    private bool CompareKeys(K k1, K k2);
    private int GetHashCode(K k);
    public bool TryGetValue(K key, V& value);
    public void Add(K key, V value);
    public V get_Item(K key);
    public void set_Item(K key, V value);
    public bool ContainsKey(K key);
    [ConditionalAttribute("DEBUG")]
internal void AssertBalanced();
    private bool TryGetValue(int hashCode, K key, V& value);
    private bool GetFromList(Node<K, V> next, K key, V& value);
    private void Insert(int hashCode, K key, V value, bool add);
    private static AvlNode<K, V> LeftSimple(AvlNode<K, V> unbalanced);
    private static AvlNode<K, V> RightSimple(AvlNode<K, V> unbalanced);
    private static AvlNode<K, V> LeftComplex(AvlNode<K, V> unbalanced);
    private static AvlNode<K, V> RightComplex(AvlNode<K, V> unbalanced);
    private void HandleInsert(AvlNode<K, V> node, AvlNode<K, V> parent, K key, V value, bool add);
    private void AddNode(AvlNode<K, V> node, AvlNode<K, V> parent, K key, V value);
    public KeyCollection<K, V> get_Keys();
    public ValueCollection<K, V> get_Values();
    public Enumerator<K, V> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<K, V>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,V>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private int HeightApprox();
}
public enum Microsoft.CodeAnalysis.SourceCodeKind : Enum {
    public int value__;
    public static SourceCodeKind Regular;
    public static SourceCodeKind Script;
    public static SourceCodeKind Interactive;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SourceCodeKindExtensions : object {
    [ExtensionAttribute]
internal static bool IsValid(SourceCodeKind value);
}
public class Microsoft.CodeAnalysis.SourceFileResolver : SourceReferenceResolver {
    [CompilerGeneratedAttribute]
private static SourceFileResolver <Default>k__BackingField;
    private string _baseDirectory;
    private ImmutableArray`1<string> _searchPaths;
    public static SourceFileResolver Default { get; }
    public string BaseDirectory { get; }
    public ImmutableArray`1<string> SearchPaths { get; }
    public SourceFileResolver(IEnumerable`1<string> searchPaths, string baseDirectory);
    public SourceFileResolver(ImmutableArray`1<string> searchPaths, string baseDirectory);
    private static SourceFileResolver();
    [CompilerGeneratedAttribute]
public static SourceFileResolver get_Default();
    public string get_BaseDirectory();
    public ImmutableArray`1<string> get_SearchPaths();
    public virtual string NormalizePath(string path, string baseFilePath);
    public virtual string ResolveReference(string path, string baseFilePath);
    public virtual Stream OpenRead(string resolvedPath);
    protected virtual bool FileExists(string resolvedPath);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.SourceLocation : Location {
    private SyntaxTree _syntaxTree;
    private TextSpan _span;
    public LocationKind Kind { get; }
    public TextSpan SourceSpan { get; }
    public SyntaxTree SourceTree { get; }
    public SourceLocation(SyntaxTree syntaxTree, TextSpan span);
    public SourceLocation(SyntaxNode node);
    public SourceLocation(SyntaxToken token);
    public SourceLocation(SyntaxNodeOrToken nodeOrToken);
    public SourceLocation(SyntaxTrivia trivia);
    public SourceLocation(SyntaxReference syntaxRef);
    public virtual LocationKind get_Kind();
    public virtual TextSpan get_SourceSpan();
    public virtual SyntaxTree get_SourceTree();
    public virtual FileLinePositionSpan GetLineSpan();
    public virtual FileLinePositionSpan GetMappedLineSpan();
    public sealed virtual bool Equals(SourceLocation other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected virtual string GetDebuggerDisplay();
}
public abstract class Microsoft.CodeAnalysis.SourceReferenceResolver : object {
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual string NormalizePath(string path, string baseFilePath);
    public abstract virtual string ResolveReference(string path, string baseFilePath);
    public abstract virtual Stream OpenRead(string resolvedPath);
    internal Stream OpenReadChecked(string fullPath);
}
internal enum Microsoft.CodeAnalysis.SpecialMember : Enum {
    public int value__;
    public static SpecialMember System_String__CtorSZArrayChar;
    public static SpecialMember System_String__ConcatStringString;
    public static SpecialMember System_String__ConcatStringStringString;
    public static SpecialMember System_String__ConcatStringStringStringString;
    public static SpecialMember System_String__ConcatStringArray;
    public static SpecialMember System_String__ConcatObject;
    public static SpecialMember System_String__ConcatObjectObject;
    public static SpecialMember System_String__ConcatObjectObjectObject;
    public static SpecialMember System_String__ConcatObjectArray;
    public static SpecialMember System_String__op_Equality;
    public static SpecialMember System_String__op_Inequality;
    public static SpecialMember System_String__Length;
    public static SpecialMember System_String__Chars;
    public static SpecialMember System_String__Format;
    public static SpecialMember System_Delegate__Combine;
    public static SpecialMember System_Delegate__Remove;
    public static SpecialMember System_Delegate__op_Equality;
    public static SpecialMember System_Delegate__op_Inequality;
    public static SpecialMember System_Decimal__Zero;
    public static SpecialMember System_Decimal__MinusOne;
    public static SpecialMember System_Decimal__One;
    public static SpecialMember System_Decimal__CtorInt32;
    public static SpecialMember System_Decimal__CtorUInt32;
    public static SpecialMember System_Decimal__CtorInt64;
    public static SpecialMember System_Decimal__CtorUInt64;
    public static SpecialMember System_Decimal__CtorSingle;
    public static SpecialMember System_Decimal__CtorDouble;
    public static SpecialMember System_Decimal__CtorInt32Int32Int32BooleanByte;
    public static SpecialMember System_Decimal__op_Addition;
    public static SpecialMember System_Decimal__op_Subtraction;
    public static SpecialMember System_Decimal__op_Multiply;
    public static SpecialMember System_Decimal__op_Division;
    public static SpecialMember System_Decimal__op_Modulus;
    public static SpecialMember System_Decimal__op_UnaryNegation;
    public static SpecialMember System_Decimal__op_Increment;
    public static SpecialMember System_Decimal__op_Decrement;
    public static SpecialMember System_Decimal__NegateDecimal;
    public static SpecialMember System_Decimal__RemainderDecimalDecimal;
    public static SpecialMember System_Decimal__AddDecimalDecimal;
    public static SpecialMember System_Decimal__SubtractDecimalDecimal;
    public static SpecialMember System_Decimal__MultiplyDecimalDecimal;
    public static SpecialMember System_Decimal__DivideDecimalDecimal;
    public static SpecialMember System_Decimal__ModuloDecimalDecimal;
    public static SpecialMember System_Decimal__CompareDecimalDecimal;
    public static SpecialMember System_Decimal__op_Equality;
    public static SpecialMember System_Decimal__op_Inequality;
    public static SpecialMember System_Decimal__op_GreaterThan;
    public static SpecialMember System_Decimal__op_GreaterThanOrEqual;
    public static SpecialMember System_Decimal__op_LessThan;
    public static SpecialMember System_Decimal__op_LessThanOrEqual;
    public static SpecialMember System_Decimal__op_Implicit_FromByte;
    public static SpecialMember System_Decimal__op_Implicit_FromChar;
    public static SpecialMember System_Decimal__op_Implicit_FromInt16;
    public static SpecialMember System_Decimal__op_Implicit_FromInt32;
    public static SpecialMember System_Decimal__op_Implicit_FromInt64;
    public static SpecialMember System_Decimal__op_Implicit_FromSByte;
    public static SpecialMember System_Decimal__op_Implicit_FromUInt16;
    public static SpecialMember System_Decimal__op_Implicit_FromUInt32;
    public static SpecialMember System_Decimal__op_Implicit_FromUInt64;
    public static SpecialMember System_Decimal__op_Explicit_ToByte;
    public static SpecialMember System_Decimal__op_Explicit_ToUInt16;
    public static SpecialMember System_Decimal__op_Explicit_ToSByte;
    public static SpecialMember System_Decimal__op_Explicit_ToInt16;
    public static SpecialMember System_Decimal__op_Explicit_ToSingle;
    public static SpecialMember System_Decimal__op_Explicit_ToDouble;
    public static SpecialMember System_Decimal__op_Explicit_ToChar;
    public static SpecialMember System_Decimal__op_Explicit_ToUInt64;
    public static SpecialMember System_Decimal__op_Explicit_ToInt32;
    public static SpecialMember System_Decimal__op_Explicit_ToUInt32;
    public static SpecialMember System_Decimal__op_Explicit_ToInt64;
    public static SpecialMember System_Decimal__op_Explicit_FromDouble;
    public static SpecialMember System_Decimal__op_Explicit_FromSingle;
    public static SpecialMember System_DateTime__MinValue;
    public static SpecialMember System_DateTime__CtorInt64;
    public static SpecialMember System_DateTime__CompareDateTimeDateTime;
    public static SpecialMember System_DateTime__op_Equality;
    public static SpecialMember System_DateTime__op_Inequality;
    public static SpecialMember System_DateTime__op_GreaterThan;
    public static SpecialMember System_DateTime__op_GreaterThanOrEqual;
    public static SpecialMember System_DateTime__op_LessThan;
    public static SpecialMember System_DateTime__op_LessThanOrEqual;
    public static SpecialMember System_Collections_IEnumerable__GetEnumerator;
    public static SpecialMember System_Collections_IEnumerator__Current;
    public static SpecialMember System_Collections_IEnumerator__get_Current;
    public static SpecialMember System_Collections_IEnumerator__MoveNext;
    public static SpecialMember System_Collections_IEnumerator__Reset;
    public static SpecialMember System_Collections_Generic_IEnumerable_T__GetEnumerator;
    public static SpecialMember System_Collections_Generic_IEnumerator_T__Current;
    public static SpecialMember System_Collections_Generic_IEnumerator_T__get_Current;
    public static SpecialMember System_IDisposable__Dispose;
    public static SpecialMember System_Array__Length;
    public static SpecialMember System_Array__LongLength;
    public static SpecialMember System_Array__GetLowerBound;
    public static SpecialMember System_Array__GetUpperBound;
    public static SpecialMember System_Object__GetHashCode;
    public static SpecialMember System_Object__Equals;
    public static SpecialMember System_Object__ToString;
    public static SpecialMember System_Object__ReferenceEquals;
    public static SpecialMember System_IntPtr__op_Explicit_ToPointer;
    public static SpecialMember System_IntPtr__op_Explicit_ToInt32;
    public static SpecialMember System_IntPtr__op_Explicit_ToInt64;
    public static SpecialMember System_IntPtr__op_Explicit_FromPointer;
    public static SpecialMember System_IntPtr__op_Explicit_FromInt32;
    public static SpecialMember System_IntPtr__op_Explicit_FromInt64;
    public static SpecialMember System_UIntPtr__op_Explicit_ToPointer;
    public static SpecialMember System_UIntPtr__op_Explicit_ToUInt32;
    public static SpecialMember System_UIntPtr__op_Explicit_ToUInt64;
    public static SpecialMember System_UIntPtr__op_Explicit_FromPointer;
    public static SpecialMember System_UIntPtr__op_Explicit_FromUInt32;
    public static SpecialMember System_UIntPtr__op_Explicit_FromUInt64;
    public static SpecialMember System_Nullable_T_GetValueOrDefault;
    public static SpecialMember System_Nullable_T_get_Value;
    public static SpecialMember System_Nullable_T_get_HasValue;
    public static SpecialMember System_Nullable_T__ctor;
    public static SpecialMember System_Nullable_T__op_Implicit_FromT;
    public static SpecialMember System_Nullable_T__op_Explicit_ToT;
    public static SpecialMember Count;
}
internal static class Microsoft.CodeAnalysis.SpecialMembers : object {
    private static ImmutableArray`1<MemberDescriptor> s_descriptors;
    private static SpecialMembers();
    public static MemberDescriptor GetDescriptor(SpecialMember member);
}
public enum Microsoft.CodeAnalysis.SpecialType : Enum {
    public sbyte value__;
    public static SpecialType None;
    public static SpecialType System_Object;
    public static SpecialType System_Enum;
    public static SpecialType System_MulticastDelegate;
    public static SpecialType System_Delegate;
    public static SpecialType System_ValueType;
    public static SpecialType System_Void;
    public static SpecialType System_Boolean;
    public static SpecialType System_Char;
    public static SpecialType System_SByte;
    public static SpecialType System_Byte;
    public static SpecialType System_Int16;
    public static SpecialType System_UInt16;
    public static SpecialType System_Int32;
    public static SpecialType System_UInt32;
    public static SpecialType System_Int64;
    public static SpecialType System_UInt64;
    public static SpecialType System_Decimal;
    public static SpecialType System_Single;
    public static SpecialType System_Double;
    public static SpecialType System_String;
    public static SpecialType System_IntPtr;
    public static SpecialType System_UIntPtr;
    public static SpecialType System_Array;
    public static SpecialType System_Collections_IEnumerable;
    public static SpecialType System_Collections_Generic_IEnumerable_T;
    public static SpecialType System_Collections_Generic_IList_T;
    public static SpecialType System_Collections_Generic_ICollection_T;
    public static SpecialType System_Collections_IEnumerator;
    public static SpecialType System_Collections_Generic_IEnumerator_T;
    public static SpecialType System_Collections_Generic_IReadOnlyList_T;
    public static SpecialType System_Collections_Generic_IReadOnlyCollection_T;
    public static SpecialType System_Nullable_T;
    public static SpecialType System_DateTime;
    public static SpecialType System_Runtime_CompilerServices_IsVolatile;
    public static SpecialType System_IDisposable;
    public static SpecialType System_TypedReference;
    public static SpecialType System_ArgIterator;
    public static SpecialType System_RuntimeArgumentHandle;
    public static SpecialType System_RuntimeFieldHandle;
    public static SpecialType System_RuntimeMethodHandle;
    public static SpecialType System_RuntimeTypeHandle;
    public static SpecialType System_IAsyncResult;
    public static SpecialType System_AsyncCallback;
    public static SpecialType Count;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SpecialTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsClrInteger(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsBlittable(SpecialType specialType);
    [ExtensionAttribute]
public static int SizeInBytes(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsPrimitiveRecursiveStruct(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsValidEnumUnderlyingType(SpecialType specialType);
    public static SpecialType FromRuntimeTypeOfLiteralValue(object value);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SpecialTypes : object {
    private static String[] s_emittedNames;
    private static Dictionary`2<string, SpecialType> s_nameToTypeIdMap;
    private static PrimitiveTypeCode[] s_typeIdToTypeCodeMap;
    private static SpecialType[] s_typeCodeToTypeIdMap;
    private static SpecialTypes();
    [ExtensionAttribute]
public static string GetMetadataName(SpecialType id);
    public static SpecialType GetTypeFromMetadataName(string metadataName);
    public static SpecialType GetTypeFromMetadataName(PrimitiveTypeCode typeCode);
    public static PrimitiveTypeCode GetTypeCode(SpecialType typeId);
}
public enum Microsoft.CodeAnalysis.SpeculativeBindingOption : Enum {
    public int value__;
    public static SpeculativeBindingOption BindAsExpression;
    public static SpeculativeBindingOption BindAsTypeOrNamespace;
}
internal static class Microsoft.CodeAnalysis.StaticCast`1 : object {
    internal static ImmutableArray`1<T> From(ImmutableArray`1<TDerived> from);
}
internal class Microsoft.CodeAnalysis.StrongNameKeys : object {
    internal ImmutableArray`1<byte> KeyPair;
    internal ImmutableArray`1<byte> PublicKey;
    internal Diagnostic DiagnosticOpt;
    internal string KeyContainer;
    internal string KeyFilePath;
    internal static StrongNameKeys None;
    internal bool CanSign { get; }
    internal bool CanProvideStrongName { get; }
    internal StrongNameKeys(Diagnostic diagnostic);
    internal StrongNameKeys(ImmutableArray`1<byte> keyPair, ImmutableArray`1<byte> publicKey, string keyContainerName, string keyFilePath);
    private static StrongNameKeys();
    internal static StrongNameKeys Create(ImmutableArray`1<byte> publicKey, CommonMessageProvider messageProvider);
    internal static StrongNameKeys Create(StrongNameProvider providerOpt, string keyFilePath, string keyContainerName, CommonMessageProvider messageProvider);
    internal bool get_CanSign();
    internal bool get_CanProvideStrongName();
    internal static Diagnostic GetError(string keyFilePath, string keyContainerName, object message, CommonMessageProvider messageProvider);
    internal static Diagnostic GetContainerError(CommonMessageProvider messageProvider, string name, object message);
    internal static Diagnostic GetKeyFileError(CommonMessageProvider messageProvider, string path, object message);
    internal static bool IsValidPublicKeyString(string publicKey);
}
public abstract class Microsoft.CodeAnalysis.StrongNameProvider : object {
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    internal abstract virtual Stream CreateInputStream();
    internal abstract virtual StrongNameKeys CreateKeys(string keyFilePath, string keyContainerName, CommonMessageProvider messageProvider);
    internal abstract virtual void SignAssembly(StrongNameKeys keys, Stream inputStream, Stream outputStream);
}
public class Microsoft.CodeAnalysis.SubsystemVersion : ValueType {
    [CompilerGeneratedAttribute]
private int <Major>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Minor>k__BackingField;
    public int Major { get; }
    public int Minor { get; }
    public static SubsystemVersion None { get; }
    public static SubsystemVersion Windows2000 { get; }
    public static SubsystemVersion WindowsXP { get; }
    public static SubsystemVersion WindowsVista { get; }
    public static SubsystemVersion Windows7 { get; }
    public static SubsystemVersion Windows8 { get; }
    public bool IsValid { get; }
    private SubsystemVersion(int major, int minor);
    [CompilerGeneratedAttribute]
public int get_Major();
    [CompilerGeneratedAttribute]
public int get_Minor();
    public static SubsystemVersion get_None();
    public static SubsystemVersion get_Windows2000();
    public static SubsystemVersion get_WindowsXP();
    public static SubsystemVersion get_WindowsVista();
    public static SubsystemVersion get_Windows7();
    public static SubsystemVersion get_Windows8();
    public static bool TryParse(string str, SubsystemVersion& version);
    public static SubsystemVersion Create(int major, int minor);
    internal static SubsystemVersion Default(OutputKind outputKind, Platform platform);
    public bool get_IsValid();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(SubsystemVersion other);
    public virtual string ToString();
}
internal static class Microsoft.CodeAnalysis.SwitchConstantValueHelper : object {
    public static bool IsValidSwitchCaseLabelConstant(ConstantValue constant);
    public static int CompareSwitchCaseLabelConstants(ConstantValue first, ConstantValue second);
}
internal abstract class Microsoft.CodeAnalysis.SymbolDisplay.AbstractSymbolDisplayVisitor`1 : SymbolVisitor {
    protected ArrayBuilder`1<SymbolDisplayPart> builder;
    protected SymbolDisplayFormat format;
    protected bool isFirstSymbolVisited;
    protected TSemanticModel semanticModelOpt;
    protected int positionOpt;
    private AbstractSymbolDisplayVisitor`1<TSemanticModel> _lazyNotFirstVisitor;
    protected AbstractSymbolDisplayVisitor`1<TSemanticModel> NotFirstVisitor { get; }
    protected bool IsMinimizing { get; }
    protected AbstractSymbolDisplayVisitor`1(ArrayBuilder`1<SymbolDisplayPart> builder, SymbolDisplayFormat format, bool isFirstSymbolVisited, TSemanticModel semanticModelOpt, int positionOpt);
    protected AbstractSymbolDisplayVisitor`1<TSemanticModel> get_NotFirstVisitor();
    protected abstract virtual AbstractSymbolDisplayVisitor`1<TSemanticModel> MakeNotFirstVisitor();
    protected abstract virtual void AddLiteralValue(SpecialType type, object value);
    protected abstract virtual void AddExplicitlyCastedLiteralValue(INamedTypeSymbol namedType, SpecialType type, object value);
    protected abstract virtual void AddSpace();
    protected abstract virtual void AddBitwiseOr();
    protected void AddNonNullConstantValue(ITypeSymbol type, object constantValue, bool preferNumericValueOrExpandedFlagsForEnum);
    private void AddEnumConstantValue(INamedTypeSymbol enumType, object constantValue, bool preferNumericValueOrExpandedFlags);
    private static bool IsFlagsEnum(ITypeSymbol typeSymbol);
    private void AddFlagsEnumConstantValue(INamedTypeSymbol enumType, object constantValue, bool preferNumericValueOrExpandedFlags);
    private void AddFlagsEnumConstantValue(INamedTypeSymbol enumType, object constantValue, ArrayBuilder`1<EnumField> allFieldsAndValues, ArrayBuilder`1<EnumField> usedFieldsAndValues, bool preferNumericValueOrExpandedFlags);
    private static void GetSortedEnumFields(INamedTypeSymbol enumType, ArrayBuilder`1<EnumField> enumFields);
    private void AddNonFlagsEnumConstantValue(INamedTypeSymbol enumType, object constantValue);
    protected abstract virtual bool ShouldRestrictMinimallyQualifyLookupToNamespacesAndTypes();
    protected bool get_IsMinimizing();
    protected bool NameBoundSuccessfullyToSameSymbol(INamedTypeSymbol symbol);
    private static ISymbol SingleSymbolWithArity(ImmutableArray`1<ISymbol> candidates, int desiredArity);
    protected static ITypeSymbol GetSymbolType(ISymbol symbol);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions : Enum {
    public int value__;
    public static SymbolDisplayCompilerInternalOptions None;
    public static SymbolDisplayCompilerInternalOptions UseMetadataMethodNames;
    public static SymbolDisplayCompilerInternalOptions UseArityForGenericTypes;
    public static SymbolDisplayCompilerInternalOptions FlagMissingMetadataTypes;
    public static SymbolDisplayCompilerInternalOptions IncludeScriptType;
    public static SymbolDisplayCompilerInternalOptions IncludeCustomModifiers;
    public static SymbolDisplayCompilerInternalOptions ReverseArrayRankSpecifiers;
}
public enum Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle : Enum {
    public int value__;
    public static SymbolDisplayDelegateStyle NameOnly;
    public static SymbolDisplayDelegateStyle NameAndParameters;
    public static SymbolDisplayDelegateStyle NameAndSignature;
}
public enum Microsoft.CodeAnalysis.SymbolDisplayExtensionMethodStyle : Enum {
    public int value__;
    public static SymbolDisplayExtensionMethodStyle Default;
    public static SymbolDisplayExtensionMethodStyle InstanceMethod;
    public static SymbolDisplayExtensionMethodStyle StaticMethod;
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.SymbolDisplayExtensions : object {
    [ExtensionAttribute]
public static string ToDisplayString(ImmutableArray`1<SymbolDisplayPart> parts);
    [ExtensionAttribute]
internal static bool IncludesOption(SymbolDisplayCompilerInternalOptions options, SymbolDisplayCompilerInternalOptions flag);
    [ExtensionAttribute]
internal static bool IncludesOption(SymbolDisplayGenericsOptions options, SymbolDisplayGenericsOptions flag);
    [ExtensionAttribute]
internal static bool IncludesOption(SymbolDisplayMemberOptions options, SymbolDisplayMemberOptions flag);
    [ExtensionAttribute]
internal static bool IncludesOption(SymbolDisplayMiscellaneousOptions options, SymbolDisplayMiscellaneousOptions flag);
    [ExtensionAttribute]
internal static bool IncludesOption(SymbolDisplayParameterOptions options, SymbolDisplayParameterOptions flag);
    [ExtensionAttribute]
internal static bool IncludesOption(SymbolDisplayKindOptions options, SymbolDisplayKindOptions flag);
    [ExtensionAttribute]
internal static bool IncludesOption(SymbolDisplayLocalOptions options, SymbolDisplayLocalOptions flag);
}
public class Microsoft.CodeAnalysis.SymbolDisplayFormat : object {
    [CompilerGeneratedAttribute]
private static SymbolDisplayFormat <CSharpErrorMessageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private static SymbolDisplayFormat <CSharpShortErrorMessageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private static SymbolDisplayFormat <VisualBasicErrorMessageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private static SymbolDisplayFormat <VisualBasicShortErrorMessageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private static SymbolDisplayFormat <FullyQualifiedFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private static SymbolDisplayFormat <MinimallyQualifiedFormat>k__BackingField;
    internal static SymbolDisplayFormat TestFormat;
    internal static SymbolDisplayFormat QualifiedNameOnlyFormat;
    internal static SymbolDisplayFormat QualifiedNameArityFormat;
    internal static SymbolDisplayFormat ShortFormat;
    internal static SymbolDisplayFormat ILVisualizationFormat;
    internal static SymbolDisplayFormat ExplicitInterfaceImplementationFormat;
    [CompilerGeneratedAttribute]
private SymbolDisplayGlobalNamespaceStyle <GlobalNamespaceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayTypeQualificationStyle <TypeQualificationStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayGenericsOptions <GenericsOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayMemberOptions <MemberOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayParameterOptions <ParameterOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayDelegateStyle <DelegateStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayExtensionMethodStyle <ExtensionMethodStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayPropertyStyle <PropertyStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayLocalOptions <LocalOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayKindOptions <KindOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayMiscellaneousOptions <MiscellaneousOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayCompilerInternalOptions <CompilerInternalOptions>k__BackingField;
    public static SymbolDisplayFormat CSharpErrorMessageFormat { get; }
    public static SymbolDisplayFormat CSharpShortErrorMessageFormat { get; }
    public static SymbolDisplayFormat VisualBasicErrorMessageFormat { get; }
    public static SymbolDisplayFormat VisualBasicShortErrorMessageFormat { get; }
    public static SymbolDisplayFormat FullyQualifiedFormat { get; }
    public static SymbolDisplayFormat MinimallyQualifiedFormat { get; }
    public SymbolDisplayGlobalNamespaceStyle GlobalNamespaceStyle { get; }
    public SymbolDisplayTypeQualificationStyle TypeQualificationStyle { get; }
    public SymbolDisplayGenericsOptions GenericsOptions { get; }
    public SymbolDisplayMemberOptions MemberOptions { get; }
    public SymbolDisplayParameterOptions ParameterOptions { get; }
    public SymbolDisplayDelegateStyle DelegateStyle { get; }
    public SymbolDisplayExtensionMethodStyle ExtensionMethodStyle { get; }
    public SymbolDisplayPropertyStyle PropertyStyle { get; }
    public SymbolDisplayLocalOptions LocalOptions { get; }
    public SymbolDisplayKindOptions KindOptions { get; }
    public SymbolDisplayMiscellaneousOptions MiscellaneousOptions { get; }
    internal SymbolDisplayCompilerInternalOptions CompilerInternalOptions { get; }
    public SymbolDisplayFormat(SymbolDisplayGlobalNamespaceStyle globalNamespaceStyle, SymbolDisplayTypeQualificationStyle typeQualificationStyle, SymbolDisplayGenericsOptions genericsOptions, SymbolDisplayMemberOptions memberOptions, SymbolDisplayDelegateStyle delegateStyle, SymbolDisplayExtensionMethodStyle extensionMethodStyle, SymbolDisplayParameterOptions parameterOptions, SymbolDisplayPropertyStyle propertyStyle, SymbolDisplayLocalOptions localOptions, SymbolDisplayKindOptions kindOptions, SymbolDisplayMiscellaneousOptions miscellaneousOptions);
    internal SymbolDisplayFormat(SymbolDisplayCompilerInternalOptions compilerInternalOptions, SymbolDisplayGlobalNamespaceStyle globalNamespaceStyle, SymbolDisplayTypeQualificationStyle typeQualificationStyle, SymbolDisplayGenericsOptions genericsOptions, SymbolDisplayMemberOptions memberOptions, SymbolDisplayParameterOptions parameterOptions, SymbolDisplayDelegateStyle delegateStyle, SymbolDisplayExtensionMethodStyle extensionMethodStyle, SymbolDisplayPropertyStyle propertyStyle, SymbolDisplayLocalOptions localOptions, SymbolDisplayKindOptions kindOptions, SymbolDisplayMiscellaneousOptions miscellaneousOptions);
    private static SymbolDisplayFormat();
    [CompilerGeneratedAttribute]
public static SymbolDisplayFormat get_CSharpErrorMessageFormat();
    [CompilerGeneratedAttribute]
public static SymbolDisplayFormat get_CSharpShortErrorMessageFormat();
    [CompilerGeneratedAttribute]
public static SymbolDisplayFormat get_VisualBasicErrorMessageFormat();
    [CompilerGeneratedAttribute]
public static SymbolDisplayFormat get_VisualBasicShortErrorMessageFormat();
    [CompilerGeneratedAttribute]
public static SymbolDisplayFormat get_FullyQualifiedFormat();
    [CompilerGeneratedAttribute]
public static SymbolDisplayFormat get_MinimallyQualifiedFormat();
    [CompilerGeneratedAttribute]
public SymbolDisplayGlobalNamespaceStyle get_GlobalNamespaceStyle();
    [CompilerGeneratedAttribute]
public SymbolDisplayTypeQualificationStyle get_TypeQualificationStyle();
    [CompilerGeneratedAttribute]
public SymbolDisplayGenericsOptions get_GenericsOptions();
    [CompilerGeneratedAttribute]
public SymbolDisplayMemberOptions get_MemberOptions();
    [CompilerGeneratedAttribute]
public SymbolDisplayParameterOptions get_ParameterOptions();
    [CompilerGeneratedAttribute]
public SymbolDisplayDelegateStyle get_DelegateStyle();
    [CompilerGeneratedAttribute]
public SymbolDisplayExtensionMethodStyle get_ExtensionMethodStyle();
    [CompilerGeneratedAttribute]
public SymbolDisplayPropertyStyle get_PropertyStyle();
    [CompilerGeneratedAttribute]
public SymbolDisplayLocalOptions get_LocalOptions();
    [CompilerGeneratedAttribute]
public SymbolDisplayKindOptions get_KindOptions();
    [CompilerGeneratedAttribute]
public SymbolDisplayMiscellaneousOptions get_MiscellaneousOptions();
    [CompilerGeneratedAttribute]
internal SymbolDisplayCompilerInternalOptions get_CompilerInternalOptions();
    public SymbolDisplayFormat WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions options);
    public SymbolDisplayFormat AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions options);
    public SymbolDisplayFormat WithGenericsOptions(SymbolDisplayGenericsOptions options);
    public SymbolDisplayFormat AddGenericsOptions(SymbolDisplayGenericsOptions options);
    public SymbolDisplayFormat WithMemberOptions(SymbolDisplayMemberOptions options);
    public SymbolDisplayFormat AddMemberOptions(SymbolDisplayMemberOptions options);
    public SymbolDisplayFormat RemoveMemberOptions(SymbolDisplayMemberOptions options);
    public SymbolDisplayFormat WithKindOptions(SymbolDisplayKindOptions options);
    public SymbolDisplayFormat AddKindOptions(SymbolDisplayKindOptions options);
    public SymbolDisplayFormat RemoveKindOptions(SymbolDisplayKindOptions options);
    public SymbolDisplayFormat WithParameterOptions(SymbolDisplayParameterOptions options);
    public SymbolDisplayFormat AddParameterOptions(SymbolDisplayParameterOptions options);
    public SymbolDisplayFormat RemoveParameterOptions(SymbolDisplayParameterOptions options);
    public SymbolDisplayFormat WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle style);
    public SymbolDisplayFormat WithLocalOptions(SymbolDisplayLocalOptions options);
    public SymbolDisplayFormat AddLocalOptions(SymbolDisplayLocalOptions options);
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions : Enum {
    public int value__;
    public static SymbolDisplayGenericsOptions None;
    public static SymbolDisplayGenericsOptions IncludeTypeParameters;
    public static SymbolDisplayGenericsOptions IncludeTypeConstraints;
    public static SymbolDisplayGenericsOptions IncludeVariance;
}
public enum Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle : Enum {
    public int value__;
    public static SymbolDisplayGlobalNamespaceStyle Omitted;
    public static SymbolDisplayGlobalNamespaceStyle OmittedAsContaining;
    public static SymbolDisplayGlobalNamespaceStyle Included;
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.SymbolDisplayKindOptions : Enum {
    public int value__;
    public static SymbolDisplayKindOptions None;
    public static SymbolDisplayKindOptions IncludeNamespaceKeyword;
    public static SymbolDisplayKindOptions IncludeTypeKeyword;
    public static SymbolDisplayKindOptions IncludeMemberKeyword;
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.SymbolDisplayLocalOptions : Enum {
    public int value__;
    public static SymbolDisplayLocalOptions None;
    public static SymbolDisplayLocalOptions IncludeType;
    public static SymbolDisplayLocalOptions IncludeConstantValue;
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.SymbolDisplayMemberOptions : Enum {
    public int value__;
    public static SymbolDisplayMemberOptions None;
    public static SymbolDisplayMemberOptions IncludeType;
    public static SymbolDisplayMemberOptions IncludeModifiers;
    public static SymbolDisplayMemberOptions IncludeAccessibility;
    public static SymbolDisplayMemberOptions IncludeExplicitInterface;
    public static SymbolDisplayMemberOptions IncludeParameters;
    public static SymbolDisplayMemberOptions IncludeContainingType;
    public static SymbolDisplayMemberOptions IncludeConstantValue;
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions : Enum {
    public int value__;
    public static SymbolDisplayMiscellaneousOptions None;
    public static SymbolDisplayMiscellaneousOptions UseSpecialTypes;
    public static SymbolDisplayMiscellaneousOptions EscapeKeywordIdentifiers;
    public static SymbolDisplayMiscellaneousOptions UseAsterisksInMultiDimensionalArrays;
    public static SymbolDisplayMiscellaneousOptions UseErrorTypeSymbolName;
    public static SymbolDisplayMiscellaneousOptions RemoveAttributeSuffix;
    public static SymbolDisplayMiscellaneousOptions ExpandNullable;
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.SymbolDisplayParameterOptions : Enum {
    public int value__;
    public static SymbolDisplayParameterOptions None;
    public static SymbolDisplayParameterOptions IncludeExtensionThis;
    public static SymbolDisplayParameterOptions IncludeParamsRefOut;
    public static SymbolDisplayParameterOptions IncludeType;
    public static SymbolDisplayParameterOptions IncludeName;
    public static SymbolDisplayParameterOptions IncludeDefaultValue;
    public static SymbolDisplayParameterOptions IncludeOptionalBrackets;
}
public class Microsoft.CodeAnalysis.SymbolDisplayPart : ValueType {
    private static string KindKey;
    private static string TextKey;
    private SymbolDisplayPartKind _kind;
    private string _text;
    private ISymbol _symbol;
    public SymbolDisplayPartKind Kind { get; }
    public ISymbol Symbol { get; }
    public SymbolDisplayPart(SymbolDisplayPartKind kind, ISymbol symbol, string text);
    public SymbolDisplayPartKind get_Kind();
    public ISymbol get_Symbol();
    public virtual string ToString();
}
public enum Microsoft.CodeAnalysis.SymbolDisplayPartKind : Enum {
    public int value__;
    public static SymbolDisplayPartKind AliasName;
    public static SymbolDisplayPartKind AssemblyName;
    public static SymbolDisplayPartKind ClassName;
    public static SymbolDisplayPartKind DelegateName;
    public static SymbolDisplayPartKind EnumName;
    public static SymbolDisplayPartKind ErrorTypeName;
    public static SymbolDisplayPartKind EventName;
    public static SymbolDisplayPartKind FieldName;
    public static SymbolDisplayPartKind InterfaceName;
    public static SymbolDisplayPartKind Keyword;
    public static SymbolDisplayPartKind LabelName;
    public static SymbolDisplayPartKind LineBreak;
    public static SymbolDisplayPartKind NumericLiteral;
    public static SymbolDisplayPartKind StringLiteral;
    public static SymbolDisplayPartKind LocalName;
    public static SymbolDisplayPartKind MethodName;
    public static SymbolDisplayPartKind ModuleName;
    public static SymbolDisplayPartKind NamespaceName;
    public static SymbolDisplayPartKind Operator;
    public static SymbolDisplayPartKind ParameterName;
    public static SymbolDisplayPartKind PropertyName;
    public static SymbolDisplayPartKind Punctuation;
    public static SymbolDisplayPartKind Space;
    public static SymbolDisplayPartKind StructName;
    public static SymbolDisplayPartKind AnonymousTypeIndicator;
    public static SymbolDisplayPartKind Text;
    public static SymbolDisplayPartKind TypeParameterName;
    public static SymbolDisplayPartKind RangeVariableName;
}
public enum Microsoft.CodeAnalysis.SymbolDisplayPropertyStyle : Enum {
    public int value__;
    public static SymbolDisplayPropertyStyle NameOnly;
    public static SymbolDisplayPropertyStyle ShowReadWriteDescriptor;
}
public enum Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle : Enum {
    public int value__;
    public static SymbolDisplayTypeQualificationStyle NameOnly;
    public static SymbolDisplayTypeQualificationStyle NameAndContainingTypes;
    public static SymbolDisplayTypeQualificationStyle NameAndContainingTypesAndNamespaces;
}
internal abstract class Microsoft.CodeAnalysis.SymbolFactory`2 : object {
    internal abstract virtual TypeSymbol GetUnsupportedMetadataTypeSymbol(ModuleSymbol moduleSymbol, BadImageFormatException exception);
    internal abstract virtual TypeSymbol MakeUnboundIfGeneric(ModuleSymbol moduleSymbol, TypeSymbol type);
    internal abstract virtual TypeSymbol GetSZArrayTypeSymbol(ModuleSymbol moduleSymbol, TypeSymbol elementType, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers);
    internal abstract virtual TypeSymbol GetArrayTypeSymbol(ModuleSymbol moduleSymbol, int rank, TypeSymbol elementType);
    internal abstract virtual TypeSymbol SubstituteTypeParameters(ModuleSymbol moduleSymbol, TypeSymbol generic, ImmutableArray`1<TypeSymbol> arguments, ImmutableArray`1<bool> refersToNoPiaLocalType);
    internal abstract virtual TypeSymbol GetByRefReturnTypeSymbol(ModuleSymbol moduleSymbol, TypeSymbol referencedType);
    internal abstract virtual TypeSymbol MakePointerTypeSymbol(ModuleSymbol moduleSymbol, TypeSymbol type, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers);
    internal abstract virtual TypeSymbol GetSpecialType(ModuleSymbol moduleSymbol, SpecialType specialType);
    internal abstract virtual TypeSymbol GetSystemTypeSymbol(ModuleSymbol moduleSymbol);
    internal abstract virtual TypeSymbol GetEnumUnderlyingType(ModuleSymbol moduleSymbol, TypeSymbol type);
    internal abstract virtual bool IsVolatileModifierType(ModuleSymbol moduleSymbol, TypeSymbol type);
    internal abstract virtual PrimitiveTypeCode GetPrimitiveTypeCode(ModuleSymbol moduleSymbol, TypeSymbol type);
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.SymbolFilter : Enum {
    public int value__;
    public static SymbolFilter None;
    public static SymbolFilter Namespace;
    public static SymbolFilter Type;
    public static SymbolFilter Member;
    public static SymbolFilter TypeAndMember;
    public static SymbolFilter All;
}
public class Microsoft.CodeAnalysis.SymbolInfo : ValueType {
    internal static SymbolInfo None;
    private ImmutableArray`1<ISymbol> _candidateSymbols;
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private CandidateReason <CandidateReason>k__BackingField;
    public ISymbol Symbol { get; }
    public ImmutableArray`1<ISymbol> CandidateSymbols { get; }
    public CandidateReason CandidateReason { get; }
    internal bool IsEmpty { get; }
    internal SymbolInfo(ISymbol symbol);
    internal SymbolInfo(ISymbol symbol, CandidateReason reason);
    internal SymbolInfo(ImmutableArray`1<ISymbol> candidateSymbols, CandidateReason candidateReason);
    internal SymbolInfo(ISymbol symbol, ImmutableArray`1<ISymbol> candidateSymbols, CandidateReason candidateReason);
    private static SymbolInfo();
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    public ImmutableArray`1<ISymbol> get_CandidateSymbols();
    internal ImmutableArray`1<ISymbol> GetAllSymbols();
    [CompilerGeneratedAttribute]
public CandidateReason get_CandidateReason();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SymbolInfo other);
    public virtual int GetHashCode();
    internal bool get_IsEmpty();
}
public enum Microsoft.CodeAnalysis.SymbolKind : Enum {
    public int value__;
    public static SymbolKind Alias;
    public static SymbolKind ArrayType;
    public static SymbolKind Assembly;
    public static SymbolKind DynamicType;
    public static SymbolKind ErrorType;
    public static SymbolKind Event;
    public static SymbolKind Field;
    public static SymbolKind Label;
    public static SymbolKind Local;
    public static SymbolKind Method;
    public static SymbolKind NetModule;
    public static SymbolKind NamedType;
    public static SymbolKind Namespace;
    public static SymbolKind Parameter;
    public static SymbolKind PointerType;
    public static SymbolKind Property;
    public static SymbolKind RangeVariable;
    public static SymbolKind TypeParameter;
    public static SymbolKind Preprocessing;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SymbolKindExtensions : object {
    [ExtensionAttribute]
public static int ToSortOrder(SymbolKind kind);
}
internal abstract class Microsoft.CodeAnalysis.Symbols.CommonAnonymousTypeManager : object {
    private ThreeState _templatesSealed;
    internal bool AreTemplatesSealed { get; }
    internal bool get_AreTemplatesSealed();
    protected void SealTemplates();
}
internal interface Microsoft.CodeAnalysis.Symbols.IMethodSymbolInternal {
    public abstract virtual int CalculateLocalSyntaxOffset(int declaratorPosition, SyntaxTree declaratorTree);
}
public abstract class Microsoft.CodeAnalysis.SymbolVisitor : object {
    public virtual void Visit(ISymbol symbol);
    public virtual void DefaultVisit(ISymbol symbol);
    public virtual void VisitAlias(IAliasSymbol symbol);
    public virtual void VisitArrayType(IArrayTypeSymbol symbol);
    public virtual void VisitAssembly(IAssemblySymbol symbol);
    public virtual void VisitDynamicType(IDynamicTypeSymbol symbol);
    public virtual void VisitEvent(IEventSymbol symbol);
    public virtual void VisitField(IFieldSymbol symbol);
    public virtual void VisitLabel(ILabelSymbol symbol);
    public virtual void VisitLocal(ILocalSymbol symbol);
    public virtual void VisitMethod(IMethodSymbol symbol);
    public virtual void VisitModule(IModuleSymbol symbol);
    public virtual void VisitNamedType(INamedTypeSymbol symbol);
    public virtual void VisitNamespace(INamespaceSymbol symbol);
    public virtual void VisitParameter(IParameterSymbol symbol);
    public virtual void VisitPointerType(IPointerTypeSymbol symbol);
    public virtual void VisitProperty(IPropertySymbol symbol);
    public virtual void VisitRangeVariable(IRangeVariableSymbol symbol);
    public virtual void VisitTypeParameter(ITypeParameterSymbol symbol);
}
public abstract class Microsoft.CodeAnalysis.SymbolVisitor`1 : object {
    public virtual TResult Visit(ISymbol symbol);
    public virtual TResult DefaultVisit(ISymbol symbol);
    public virtual TResult VisitAlias(IAliasSymbol symbol);
    public virtual TResult VisitArrayType(IArrayTypeSymbol symbol);
    public virtual TResult VisitAssembly(IAssemblySymbol symbol);
    public virtual TResult VisitDynamicType(IDynamicTypeSymbol symbol);
    public virtual TResult VisitEvent(IEventSymbol symbol);
    public virtual TResult VisitField(IFieldSymbol symbol);
    public virtual TResult VisitLabel(ILabelSymbol symbol);
    public virtual TResult VisitLocal(ILocalSymbol symbol);
    public virtual TResult VisitMethod(IMethodSymbol symbol);
    public virtual TResult VisitModule(IModuleSymbol symbol);
    public virtual TResult VisitNamedType(INamedTypeSymbol symbol);
    public virtual TResult VisitNamespace(INamespaceSymbol symbol);
    public virtual TResult VisitParameter(IParameterSymbol symbol);
    public virtual TResult VisitPointerType(IPointerTypeSymbol symbol);
    public virtual TResult VisitProperty(IPropertySymbol symbol);
    public virtual TResult VisitRangeVariable(IRangeVariableSymbol symbol);
    public virtual TResult VisitTypeParameter(ITypeParameterSymbol symbol);
}
internal abstract class Microsoft.CodeAnalysis.Syntax.AbstractWarningStateMap : object {
    private WarningStateMapEntry[] _warningStateMapEntries;
    protected AbstractWarningStateMap(SyntaxTree syntaxTree);
    protected abstract virtual WarningStateMapEntry[] CreateWarningStateMapEntries(SyntaxTree syntaxTree);
    public ReportDiagnostic GetWarningState(string id, int position);
    private WarningStateMapEntry GetEntryAtOrBeforePosition(int position);
}
internal abstract class Microsoft.CodeAnalysis.Syntax.TranslationSyntaxReference : SyntaxReference {
    private SyntaxReference _reference;
    public TextSpan Span { get; }
    public SyntaxTree SyntaxTree { get; }
    protected TranslationSyntaxReference(SyntaxReference reference);
    public sealed virtual TextSpan get_Span();
    public sealed virtual SyntaxTree get_SyntaxTree();
    public sealed virtual SyntaxNode GetSyntax(CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode Translate(SyntaxReference reference, CancellationToken cancellationToken);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.SyntaxAnnotation : object {
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <ElasticAnnotation>k__BackingField;
    private long _id;
    private static long s_nextId;
    [CompilerGeneratedAttribute]
private string <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Data>k__BackingField;
    public static SyntaxAnnotation ElasticAnnotation { get; }
    public string Kind { get; }
    public string Data { get; }
    public SyntaxAnnotation(string kind);
    public SyntaxAnnotation(string kind, string data);
    private SyntaxAnnotation(ObjectReader reader);
    private static SyntaxAnnotation();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_ElasticAnnotation();
    [CompilerGeneratedAttribute]
public string get_Kind();
    [CompilerGeneratedAttribute]
public string get_Data();
    private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    private sealed virtual override Func`2<ObjectReader, object> Roslyn.Utilities.IObjectReadable.GetReader();
    private string GetDebuggerDisplay();
    public sealed virtual bool Equals(SyntaxAnnotation other);
    public static bool op_Equality(SyntaxAnnotation left, SyntaxAnnotation right);
    public static bool op_Inequality(SyntaxAnnotation left, SyntaxAnnotation right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.SyntaxDiffer : object {
    private static int InitialStackSize;
    private static int MaxSearchLength;
    private Stack`1<SyntaxNodeOrToken> _oldNodes;
    private Stack`1<SyntaxNodeOrToken> _newNodes;
    private List`1<ChangeRecord> _changes;
    private TextSpan _oldSpan;
    private bool _computeNewText;
    private HashSet`1<GreenNode> _nodeSimilaritySet;
    private HashSet`1<string> _tokenTextSimilaritySet;
    private SyntaxDiffer(SyntaxNode oldNode, SyntaxNode newNode, bool computeNewText);
    internal static IList`1<TextChange> GetTextChanges(SyntaxTree before, SyntaxTree after);
    internal static IList`1<TextChange> GetTextChanges(SyntaxNode oldNode, SyntaxNode newNode);
    private IList`1<TextChange> ComputeTextChangesFromOld();
    internal static IList`1<TextSpan> GetPossiblyDifferentTextSpans(SyntaxTree before, SyntaxTree after);
    internal static IList`1<TextSpan> GetPossiblyDifferentTextSpans(SyntaxNode oldNode, SyntaxNode newNode);
    private IList`1<TextSpan> ComputeSpansInNew();
    private void ComputeChangeRecords();
    private DiffAction GetNextAction();
    private static void ReplaceFirstWithChildren(Stack`1<SyntaxNodeOrToken> stack);
    private void FindBestMatch(Stack`1<SyntaxNodeOrToken> stack, SyntaxNodeOrToken node, Int32& index, Int32& similarity, int startIndex);
    private int GetSimilarity(SyntaxNodeOrToken node1, SyntaxNodeOrToken node2);
    private static bool AreIdentical(SyntaxNodeOrToken node1, SyntaxNodeOrToken node2);
    private static bool AreSimilar(SyntaxNodeOrToken node1, SyntaxNodeOrToken node2);
    private void RecordDeleteOld(int oldNodeCount);
    private void RecordReplaceOldWithNew(int oldNodeCount, int newNodeCount);
    private void RecordInsertNew(int newNodeCount);
    private void RecordChange(ChangeRecord change);
    private static TextSpan GetSpan(Stack`1<SyntaxNodeOrToken> stack, int first, int length);
    private static Stack`1<SyntaxNodeOrToken> Combine(Stack`1<SyntaxNodeOrToken> first, Stack`1<SyntaxNodeOrToken> next);
    private static Stack`1<SyntaxNodeOrToken> CopyFirst(Stack`1<SyntaxNodeOrToken> stack, int n);
    private static SyntaxNodeOrToken[] ToArray(Stack`1<SyntaxNodeOrToken> stack, int n);
    private static void RemoveFirst(Stack`1<SyntaxNodeOrToken> stack, int count);
    private List`1<ChangeRangeWithText> ReduceChanges(List`1<ChangeRecord> changeRecords);
    private static void GetCommonEdgeLengths(StringBuilder oldText, StringBuilder newText, Int32& commonLeadingCount, Int32& commonTrailingCount);
    private static string GetText(Stack`1<SyntaxNodeOrToken> stack);
    private static void CopyText(Stack`1<SyntaxNodeOrToken> stack, StringBuilder builder);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.CodeAnalysis.SyntaxList`1 : ValueType {
    private SyntaxNode _node;
    internal SyntaxNode Node { get; }
    public int Count { get; }
    public TNode Item { get; }
    public TextSpan FullSpan { get; }
    public TextSpan Span { get; }
    private TNode[] Nodes { get; }
    internal SyntaxList`1(SyntaxNode node);
    internal SyntaxNode get_Node();
    public sealed virtual int get_Count();
    public sealed virtual TNode get_Item(int index);
    internal SyntaxNode ItemInternal(int index);
    public TextSpan get_FullSpan();
    public TextSpan get_Span();
    public virtual string ToString();
    public string ToFullString();
    public SyntaxList`1<TNode> Add(TNode node);
    public SyntaxList`1<TNode> AddRange(IEnumerable`1<TNode> nodes);
    public SyntaxList`1<TNode> Insert(int index, TNode node);
    public SyntaxList`1<TNode> InsertRange(int index, IEnumerable`1<TNode> nodes);
    public SyntaxList`1<TNode> RemoveAt(int index);
    public SyntaxList`1<TNode> Remove(TNode node);
    public SyntaxList`1<TNode> Replace(TNode nodeInList, TNode newNode);
    public SyntaxList`1<TNode> ReplaceRange(TNode nodeInList, IEnumerable`1<TNode> newNodes);
    private static SyntaxList`1<TNode> CreateList(List`1<TNode> items);
    private static SyntaxList`1<TNode> CreateList(GreenNode creator, List`1<TNode> items);
    public TNode First();
    public TNode FirstOrDefault();
    public TNode Last();
    public TNode LastOrDefault();
    public bool Any();
    private TNode[] get_Nodes();
    public Enumerator<TNode> GetEnumerator();
    private sealed virtual override IEnumerator`1<TNode> System.Collections.Generic.IEnumerable<TNode>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public static bool op_Equality(SyntaxList`1<TNode> left, SyntaxList`1<TNode> right);
    public static bool op_Inequality(SyntaxList`1<TNode> left, SyntaxList`1<TNode> right);
    public sealed virtual bool Equals(SyntaxList`1<TNode> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static SyntaxList`1<TNode> op_Implicit(SyntaxList`1<SyntaxNode> nodes);
    public static SyntaxList`1<SyntaxNode> op_Implicit(SyntaxList`1<TNode> nodes);
    public int IndexOf(TNode node);
    public int IndexOf(Func`2<TNode, bool> predicate);
    internal int IndexOf(int rawKind);
    public int LastIndexOf(TNode node);
    public int LastIndexOf(Func`2<TNode, bool> predicate);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public abstract class Microsoft.CodeAnalysis.SyntaxNode : object {
    private SyntaxNode _parent;
    internal SyntaxTree _syntaxTree;
    [CompilerGeneratedAttribute]
private GreenNode <Green>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    internal AbstractSyntaxNavigator Navigator { get; }
    public int RawKind { get; }
    protected string KindText { get; }
    public string Language { get; }
    internal GreenNode Green { get; }
    internal int Position { get; }
    internal int EndPosition { get; }
    public SyntaxTree SyntaxTree { get; }
    internal bool IsList { get; }
    public TextSpan FullSpan { get; }
    internal int SlotCount { get; }
    public TextSpan Span { get; }
    public int SpanStart { get; }
    internal int Width { get; }
    internal int FullWidth { get; }
    public bool IsMissing { get; }
    public bool IsStructuredTrivia { get; }
    public bool HasStructuredTrivia { get; }
    public bool ContainsSkippedText { get; }
    public bool ContainsDirectives { get; }
    public bool ContainsDiagnostics { get; }
    public bool HasLeadingTrivia { get; }
    public bool HasTrailingTrivia { get; }
    public SyntaxNode Parent { get; }
    public SyntaxTrivia ParentTrivia { get; }
    internal SyntaxNode ParentOrStructuredTriviaParent { get; }
    public bool ContainsAnnotations { get; }
    protected SyntaxTree SyntaxTreeCore { get; }
    internal SyntaxNode(GreenNode green, SyntaxNode parent, int position);
    internal SyntaxNode(GreenNode green, int position, SyntaxTree syntaxTree);
    internal abstract virtual AbstractSyntaxNavigator get_Navigator();
    private string GetDebuggerDisplay();
    public int get_RawKind();
    protected abstract virtual string get_KindText();
    public abstract virtual string get_Language();
    [CompilerGeneratedAttribute]
internal GreenNode get_Green();
    [CompilerGeneratedAttribute]
internal int get_Position();
    internal int get_EndPosition();
    public SyntaxTree get_SyntaxTree();
    internal bool get_IsList();
    public TextSpan get_FullSpan();
    internal int get_SlotCount();
    public TextSpan get_Span();
    public int get_SpanStart();
    internal int get_Width();
    internal int get_FullWidth();
    internal SyntaxNode GetRed(SyntaxNode& field, int slot);
    internal SyntaxNode GetRedAtZero(SyntaxNode& field);
    protected T GetRed(T& field, int slot);
    protected T GetRedAtZero(T& field);
    internal SyntaxNode GetRedElement(SyntaxNode& element, int slot);
    internal SyntaxNode GetRedElementIfNotToken(SyntaxNode& element);
    internal SyntaxNode GetWeakRedElement(WeakReference`1& slot, int index);
    private SyntaxNode CreateWeakItem(WeakReference`1& slot, int index);
    public abstract virtual string ToString();
    public abstract virtual string ToFullString();
    public abstract virtual void WriteTo(TextWriter writer);
    public SourceText GetText(Encoding encoding, SourceHashAlgorithm checksumAlgorithm);
    public bool IsEquivalentTo(SyntaxNode other);
    public bool get_IsMissing();
    public bool IsPartOfStructuredTrivia();
    public bool get_IsStructuredTrivia();
    public bool get_HasStructuredTrivia();
    public bool get_ContainsSkippedText();
    public bool get_ContainsDirectives();
    public bool get_ContainsDiagnostics();
    public bool Contains(SyntaxNode node);
    public bool get_HasLeadingTrivia();
    public bool get_HasTrailingTrivia();
    internal abstract virtual SyntaxNode GetCachedSlot(int index);
    internal int GetChildIndex(int slot);
    internal virtual int GetChildPosition(int index);
    public Location GetLocation();
    public IEnumerable`1<Diagnostic> GetDiagnostics();
    public SyntaxReference GetReference();
    internal abstract virtual SyntaxNode TryGetCorrespondingLambdaBody(SyntaxNode body);
    internal abstract virtual SyntaxNode GetLambda();
    public SyntaxNode get_Parent();
    public virtual SyntaxTrivia get_ParentTrivia();
    internal SyntaxNode get_ParentOrStructuredTriviaParent();
    public ChildSyntaxList ChildNodesAndTokens();
    public abstract virtual SyntaxNodeOrToken ChildThatContainsPosition(int position);
    internal abstract virtual SyntaxNode GetNodeSlot(int slot);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SyntaxNode/<ChildNodes>d__85")]
public IEnumerable`1<SyntaxNode> ChildNodes();
    public IEnumerable`1<SyntaxNode> Ancestors(bool ascendOutOfTrivia);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SyntaxNode/<AncestorsAndSelf>d__87")]
public IEnumerable`1<SyntaxNode> AncestorsAndSelf(bool ascendOutOfTrivia);
    private static SyntaxNode GetParent(SyntaxNode node, bool ascendOutOfTrivia);
    public TNode FirstAncestorOrSelf(Func`2<TNode, bool> predicate, bool ascendOutOfTrivia);
    public IEnumerable`1<SyntaxNode> DescendantNodes(Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public IEnumerable`1<SyntaxNode> DescendantNodes(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public IEnumerable`1<SyntaxNode> DescendantNodesAndSelf(Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public IEnumerable`1<SyntaxNode> DescendantNodesAndSelf(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public IEnumerable`1<SyntaxNodeOrToken> DescendantNodesAndTokens(Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public IEnumerable`1<SyntaxNodeOrToken> DescendantNodesAndTokens(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public IEnumerable`1<SyntaxNodeOrToken> DescendantNodesAndTokensAndSelf(Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public IEnumerable`1<SyntaxNodeOrToken> DescendantNodesAndTokensAndSelf(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public SyntaxNode FindNode(TextSpan span, bool findInsideTrivia, bool getInnermostNodeForTie);
    public SyntaxToken FindToken(int position, bool findInsideTrivia);
    public SyntaxToken GetFirstToken(bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    public SyntaxToken GetLastToken(bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SyntaxNode/<ChildTokens>d__102")]
public IEnumerable`1<SyntaxToken> ChildTokens();
    public IEnumerable`1<SyntaxToken> DescendantTokens(Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public IEnumerable`1<SyntaxToken> DescendantTokens(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public SyntaxTriviaList GetLeadingTrivia();
    public SyntaxTriviaList GetTrailingTrivia();
    public SyntaxTrivia FindTrivia(int position, bool findInsideTrivia);
    public IEnumerable`1<SyntaxTrivia> DescendantTrivia(Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public IEnumerable`1<SyntaxTrivia> DescendantTrivia(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public bool get_ContainsAnnotations();
    public bool HasAnnotations(string annotationKind);
    public bool HasAnnotations(IEnumerable`1<string> annotationKinds);
    public bool HasAnnotation(SyntaxAnnotation annotation);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(string annotationKind);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(IEnumerable`1<string> annotationKinds);
    internal SyntaxAnnotation[] GetAnnotations();
    public IEnumerable`1<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(string annotationKind);
    public IEnumerable`1<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(String[] annotationKinds);
    public IEnumerable`1<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(SyntaxAnnotation annotation);
    public IEnumerable`1<SyntaxNode> GetAnnotatedNodes(SyntaxAnnotation syntaxAnnotation);
    public IEnumerable`1<SyntaxNode> GetAnnotatedNodes(string annotationKind);
    public IEnumerable`1<SyntaxToken> GetAnnotatedTokens(SyntaxAnnotation syntaxAnnotation);
    public IEnumerable`1<SyntaxToken> GetAnnotatedTokens(string annotationKind);
    public IEnumerable`1<SyntaxTrivia> GetAnnotatedTrivia(string annotationKind);
    public IEnumerable`1<SyntaxTrivia> GetAnnotatedTrivia(String[] annotationKinds);
    public IEnumerable`1<SyntaxTrivia> GetAnnotatedTrivia(SyntaxAnnotation annotation);
    internal SyntaxNode WithAdditionalAnnotationsInternal(IEnumerable`1<SyntaxAnnotation> annotations);
    internal SyntaxNode GetNodeWithoutAnnotations(IEnumerable`1<SyntaxAnnotation> annotations);
    public T CopyAnnotationsTo(T node);
    public bool IsEquivalentTo(SyntaxNode node, bool topLevel);
    public abstract virtual void SerializeTo(Stream stream, CancellationToken cancellationToken);
    protected abstract virtual bool EquivalentToCore(SyntaxNode other);
    protected abstract virtual SyntaxTree get_SyntaxTreeCore();
    protected abstract virtual SyntaxToken FindTokenCore(int position, bool findInsideTrivia);
    protected abstract virtual SyntaxToken FindTokenCore(int position, Func`2<SyntaxTrivia, bool> stepInto);
    protected abstract virtual SyntaxTrivia FindTriviaCore(int position, bool findInsideTrivia);
    protected internal abstract virtual SyntaxNode ReplaceCore(IEnumerable`1<TNode> nodes, Func`3<TNode, TNode, SyntaxNode> computeReplacementNode, IEnumerable`1<SyntaxToken> tokens, Func`3<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken, IEnumerable`1<SyntaxTrivia> trivia, Func`3<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia);
    protected internal abstract virtual SyntaxNode ReplaceNodeInListCore(SyntaxNode originalNode, IEnumerable`1<SyntaxNode> replacementNodes);
    protected internal abstract virtual SyntaxNode InsertNodesInListCore(SyntaxNode nodeInList, IEnumerable`1<SyntaxNode> nodesToInsert, bool insertBefore);
    protected internal abstract virtual SyntaxNode ReplaceTokenInListCore(SyntaxToken originalToken, IEnumerable`1<SyntaxToken> newTokens);
    protected internal abstract virtual SyntaxNode InsertTokensInListCore(SyntaxToken originalToken, IEnumerable`1<SyntaxToken> newTokens, bool insertBefore);
    protected internal abstract virtual SyntaxNode ReplaceTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable`1<SyntaxTrivia> newTrivia);
    protected internal abstract virtual SyntaxNode InsertTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable`1<SyntaxTrivia> newTrivia, bool insertBefore);
    protected internal abstract virtual SyntaxNode RemoveNodesCore(IEnumerable`1<SyntaxNode> nodes, SyntaxRemoveOptions options);
    protected internal abstract virtual SyntaxNode NormalizeWhitespaceCore(string indentation, bool elasticTrivia);
    protected abstract virtual bool IsEquivalentToCore(SyntaxNode node, bool topLevel);
    private IEnumerable`1<SyntaxNode> DescendantNodesImpl(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia, bool includeSelf);
    private IEnumerable`1<SyntaxNodeOrToken> DescendantNodesAndTokensImpl(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia, bool includeSelf);
    private IEnumerable`1<SyntaxTrivia> DescendantTriviaImpl(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    private static bool IsInSpan(TextSpan& span, TextSpan childSpan);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SyntaxNode/<DescendantNodesOnly>d__157")]
private IEnumerable`1<SyntaxNode> DescendantNodesOnly(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool includeSelf);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SyntaxNode/<DescendantNodesAndTokensOnly>d__158")]
private IEnumerable`1<SyntaxNodeOrToken> DescendantNodesAndTokensOnly(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool includeSelf);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SyntaxNode/<DescendantNodesAndTokensIntoTrivia>d__159")]
private IEnumerable`1<SyntaxNodeOrToken> DescendantNodesAndTokensIntoTrivia(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool includeSelf);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SyntaxNode/<DescendantTriviaOnly>d__160")]
private IEnumerable`1<SyntaxTrivia> DescendantTriviaOnly(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SyntaxNode/<DescendantTriviaIntoTrivia>d__161")]
private IEnumerable`1<SyntaxTrivia> DescendantTriviaIntoTrivia(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren);
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.SyntaxNodeExtensions : object {
    internal static string DefaultIndentation;
    private static ConditionalWeakTable`2<SyntaxNode, SyntaxAnnotation> s_nodeToIdMap;
    private static ConditionalWeakTable`2<SyntaxNode, CurrentNodes> s_rootToCurrentNodesMap;
    internal static string IdAnnotationKind;
    private static SyntaxNodeExtensions();
    [ExtensionAttribute]
public static TRoot ReplaceSyntax(TRoot root, IEnumerable`1<SyntaxNode> nodes, Func`3<SyntaxNode, SyntaxNode, SyntaxNode> computeReplacementNode, IEnumerable`1<SyntaxToken> tokens, Func`3<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken, IEnumerable`1<SyntaxTrivia> trivia, Func`3<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia);
    [ExtensionAttribute]
public static TRoot ReplaceNodes(TRoot root, IEnumerable`1<TNode> nodes, Func`3<TNode, TNode, SyntaxNode> computeReplacementNode);
    [ExtensionAttribute]
public static TRoot ReplaceNode(TRoot root, SyntaxNode oldNode, SyntaxNode newNode);
    [ExtensionAttribute]
public static TRoot ReplaceNode(TRoot root, SyntaxNode oldNode, IEnumerable`1<SyntaxNode> newNodes);
    [ExtensionAttribute]
public static TRoot InsertNodesBefore(TRoot root, SyntaxNode nodeInList, IEnumerable`1<SyntaxNode> newNodes);
    [ExtensionAttribute]
public static TRoot InsertNodesAfter(TRoot root, SyntaxNode nodeInList, IEnumerable`1<SyntaxNode> newNodes);
    [ExtensionAttribute]
public static TRoot ReplaceToken(TRoot root, SyntaxToken tokenInList, IEnumerable`1<SyntaxToken> newTokens);
    [ExtensionAttribute]
public static TRoot InsertTokensBefore(TRoot root, SyntaxToken tokenInList, IEnumerable`1<SyntaxToken> newTokens);
    [ExtensionAttribute]
public static TRoot InsertTokensAfter(TRoot root, SyntaxToken tokenInList, IEnumerable`1<SyntaxToken> newTokens);
    [ExtensionAttribute]
public static TRoot ReplaceTrivia(TRoot root, SyntaxTrivia oldTrivia, IEnumerable`1<SyntaxTrivia> newTrivia);
    [ExtensionAttribute]
public static TRoot InsertTriviaBefore(TRoot root, SyntaxTrivia trivia, IEnumerable`1<SyntaxTrivia> newTrivia);
    [ExtensionAttribute]
public static TRoot InsertTriviaAfter(TRoot root, SyntaxTrivia trivia, IEnumerable`1<SyntaxTrivia> newTrivia);
    [ExtensionAttribute]
public static TRoot ReplaceTokens(TRoot root, IEnumerable`1<SyntaxToken> tokens, Func`3<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken);
    [ExtensionAttribute]
public static TRoot ReplaceToken(TRoot root, SyntaxToken oldToken, SyntaxToken newToken);
    [ExtensionAttribute]
public static TRoot ReplaceTrivia(TRoot root, IEnumerable`1<SyntaxTrivia> trivia, Func`3<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia);
    [ExtensionAttribute]
public static TRoot ReplaceTrivia(TRoot root, SyntaxTrivia trivia, SyntaxTrivia newTrivia);
    [ExtensionAttribute]
public static TRoot RemoveNode(TRoot root, SyntaxNode node, SyntaxRemoveOptions options);
    [ExtensionAttribute]
public static TRoot RemoveNodes(TRoot root, IEnumerable`1<SyntaxNode> nodes, SyntaxRemoveOptions options);
    [ExtensionAttribute]
public static TNode NormalizeWhitespace(TNode node, string indentation, bool elasticTrivia);
    [ExtensionAttribute]
public static TSyntax WithTriviaFrom(TSyntax syntax, SyntaxNode node);
    [ExtensionAttribute]
public static TSyntax WithoutTrivia(TSyntax syntax);
    [ExtensionAttribute]
public static TSyntax WithLeadingTrivia(TSyntax node, SyntaxTriviaList trivia);
    [ExtensionAttribute]
public static TSyntax WithLeadingTrivia(TSyntax node, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static TSyntax WithoutLeadingTrivia(TSyntax node);
    [ExtensionAttribute]
public static TSyntax WithLeadingTrivia(TSyntax node, SyntaxTrivia[] trivia);
    [ExtensionAttribute]
public static TSyntax WithTrailingTrivia(TSyntax node, SyntaxTriviaList trivia);
    [ExtensionAttribute]
public static TSyntax WithTrailingTrivia(TSyntax node, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static TSyntax WithoutTrailingTrivia(TSyntax node);
    [ExtensionAttribute]
public static TSyntax WithTrailingTrivia(TSyntax node, SyntaxTrivia[] trivia);
    [ExtensionAttribute]
public static TRoot TrackNodes(TRoot root, IEnumerable`1<SyntaxNode> nodes);
    [ExtensionAttribute]
public static TRoot TrackNodes(TRoot root, SyntaxNode[] nodes);
    [ExtensionAttribute]
public static IEnumerable`1<TNode> GetCurrentNodes(SyntaxNode root, TNode node);
    [ExtensionAttribute]
public static TNode GetCurrentNode(SyntaxNode root, TNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SyntaxNodeExtensions/<GetCurrentNodes>d__37`1")]
[ExtensionAttribute]
public static IEnumerable`1<TNode> GetCurrentNodes(SyntaxNode root, IEnumerable`1<TNode> nodes);
    private static IReadOnlyList`1<SyntaxNode> GetCurrentNodeFromTrueRoots(SyntaxNode trueRoot, SyntaxNode node);
    private static SyntaxAnnotation GetId(SyntaxNode original);
    private static SyntaxNode GetRoot(SyntaxNode node);
    private static bool IsDescendant(SyntaxNode root, SyntaxNode node);
}
internal class Microsoft.CodeAnalysis.SyntaxNodeLocationComparer : object {
    private Compilation _compilation;
    public SyntaxNodeLocationComparer(Compilation compilation);
    public sealed virtual int Compare(SyntaxNode x, SyntaxNode y);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.SyntaxNodeOrToken : ValueType {
    private SyntaxNode _nodeOrParent;
    private GreenNode _token;
    private int _position;
    private int _tokenIndex;
    private string KindText { get; }
    public int RawKind { get; }
    public string Language { get; }
    public bool IsMissing { get; }
    public SyntaxNode Parent { get; }
    internal GreenNode UnderlyingNode { get; }
    internal int Position { get; }
    public bool IsToken { get; }
    public bool IsNode { get; }
    public TextSpan Span { get; }
    public int SpanStart { get; }
    public TextSpan FullSpan { get; }
    public bool HasLeadingTrivia { get; }
    public bool HasTrailingTrivia { get; }
    public bool ContainsDiagnostics { get; }
    public bool ContainsDirectives { get; }
    public bool ContainsAnnotations { get; }
    public SyntaxTree SyntaxTree { get; }
    internal int Width { get; }
    internal int FullWidth { get; }
    internal int EndPosition { get; }
    internal SyntaxNodeOrToken(SyntaxNode node);
    internal SyntaxNodeOrToken(SyntaxNode parent, GreenNode token, int position, int index);
    internal string GetDebuggerDisplay();
    private string get_KindText();
    public int get_RawKind();
    public string get_Language();
    public bool get_IsMissing();
    public SyntaxNode get_Parent();
    internal GreenNode get_UnderlyingNode();
    internal int get_Position();
    public bool get_IsToken();
    public bool get_IsNode();
    public SyntaxToken AsToken();
    public SyntaxNode AsNode();
    public ChildSyntaxList ChildNodesAndTokens();
    public TextSpan get_Span();
    public int get_SpanStart();
    public TextSpan get_FullSpan();
    public virtual string ToString();
    public string ToFullString();
    public void WriteTo(TextWriter writer);
    public bool get_HasLeadingTrivia();
    public SyntaxTriviaList GetLeadingTrivia();
    public bool get_HasTrailingTrivia();
    public SyntaxTriviaList GetTrailingTrivia();
    public SyntaxNodeOrToken WithLeadingTrivia(IEnumerable`1<SyntaxTrivia> trivia);
    public SyntaxNodeOrToken WithLeadingTrivia(SyntaxTrivia[] trivia);
    public SyntaxNodeOrToken WithTrailingTrivia(IEnumerable`1<SyntaxTrivia> trivia);
    public SyntaxNodeOrToken WithTrailingTrivia(SyntaxTrivia[] trivia);
    public bool get_ContainsDiagnostics();
    public IEnumerable`1<Diagnostic> GetDiagnostics();
    public bool get_ContainsDirectives();
    public bool get_ContainsAnnotations();
    public bool HasAnnotations(string annotationKind);
    public bool HasAnnotations(IEnumerable`1<string> annotationKinds);
    public bool HasAnnotation(SyntaxAnnotation annotation);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(string annotationKind);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(IEnumerable`1<string> annotationKinds);
    public SyntaxNodeOrToken WithAdditionalAnnotations(SyntaxAnnotation[] annotations);
    public SyntaxNodeOrToken WithAdditionalAnnotations(IEnumerable`1<SyntaxAnnotation> annotations);
    public SyntaxNodeOrToken WithoutAnnotations(SyntaxAnnotation[] annotations);
    public SyntaxNodeOrToken WithoutAnnotations(IEnumerable`1<SyntaxAnnotation> annotations);
    public SyntaxNodeOrToken WithoutAnnotations(string annotationKind);
    public sealed virtual bool Equals(SyntaxNodeOrToken other);
    public static bool op_Equality(SyntaxNodeOrToken left, SyntaxNodeOrToken right);
    public static bool op_Inequality(SyntaxNodeOrToken left, SyntaxNodeOrToken right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool IsEquivalentTo(SyntaxNodeOrToken other);
    public static SyntaxNodeOrToken op_Implicit(SyntaxToken token);
    public static SyntaxToken op_Explicit(SyntaxNodeOrToken nodeOrToken);
    public static SyntaxNodeOrToken op_Implicit(SyntaxNode node);
    public static SyntaxNode op_Explicit(SyntaxNodeOrToken nodeOrToken);
    public SyntaxTree get_SyntaxTree();
    public Location GetLocation();
    internal IList`1<TDirective> GetDirectives(Func`2<TDirective, bool> filter);
    private static void GetDirectives(SyntaxNodeOrToken node, Func`2<TDirective, bool> filter, List`1& directives);
    private static void GetDirectives(SyntaxNode node, Func`2<TDirective, bool> filter, List`1& directives);
    private static void GetDirectives(SyntaxToken token, Func`2<TDirective, bool> filter, List`1& directives);
    private static void GetDirectives(SyntaxTriviaList trivia, Func`2<TDirective, bool> filter, List`1& directives);
    internal int get_Width();
    internal int get_FullWidth();
    internal int get_EndPosition();
    public static int GetFirstChildIndexSpanningPosition(SyntaxNode node, int position);
    internal static int GetFirstChildIndexSpanningPosition(ChildSyntaxList list, int position);
    public SyntaxNodeOrToken GetNextSibling();
    public SyntaxNodeOrToken GetPreviousSibling();
    private SyntaxNodeOrToken GetNextSiblingFromStart(ChildSyntaxList siblings);
    private SyntaxNodeOrToken GetNextSiblingWithSearch(ChildSyntaxList siblings);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.CodeAnalysis.SyntaxNodeOrTokenList : ValueType {
    private SyntaxNode _node;
    internal int index;
    internal SyntaxNode Node { get; }
    internal int Position { get; }
    internal SyntaxNode Parent { get; }
    public int Count { get; }
    public SyntaxNodeOrToken Item { get; }
    public TextSpan FullSpan { get; }
    public TextSpan Span { get; }
    private SyntaxNodeOrToken[] Nodes { get; }
    internal SyntaxNodeOrTokenList(SyntaxNode node, int index);
    internal SyntaxNode get_Node();
    internal int get_Position();
    internal SyntaxNode get_Parent();
    public sealed virtual int get_Count();
    public SyntaxNodeOrToken get_Item(int index);
    public TextSpan get_FullSpan();
    public TextSpan get_Span();
    public virtual string ToString();
    public string ToFullString();
    public SyntaxNodeOrToken First();
    public SyntaxNodeOrToken FirstOrDefault();
    public SyntaxNodeOrToken Last();
    public SyntaxNodeOrToken LastOrDefault();
    public int IndexOf(SyntaxNodeOrToken nodeOrToken);
    public bool Any();
    internal void CopyTo(int offset, GreenNode[] array, int arrayOffset, int count);
    public SyntaxNodeOrTokenList Add(SyntaxNodeOrToken nodeOrToken);
    public SyntaxNodeOrTokenList AddRange(IEnumerable`1<SyntaxNodeOrToken> nodesOrTokens);
    public SyntaxNodeOrTokenList Insert(int index, SyntaxNodeOrToken nodeOrToken);
    public SyntaxNodeOrTokenList InsertRange(int index, IEnumerable`1<SyntaxNodeOrToken> nodesAndTokens);
    private static SyntaxNodeOrTokenList CreateList(GreenNode creator, List`1<SyntaxNodeOrToken> items);
    public SyntaxNodeOrTokenList RemoveAt(int index);
    public SyntaxNodeOrTokenList Remove(SyntaxNodeOrToken nodeOrTokenInList);
    public SyntaxNodeOrTokenList Replace(SyntaxNodeOrToken nodeOrTokenInList, SyntaxNodeOrToken newNodeOrToken);
    public SyntaxNodeOrTokenList ReplaceRange(SyntaxNodeOrToken nodeOrTokenInList, IEnumerable`1<SyntaxNodeOrToken> newNodesAndTokens);
    private SyntaxNodeOrToken[] get_Nodes();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<SyntaxNodeOrToken> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public static bool op_Equality(SyntaxNodeOrTokenList left, SyntaxNodeOrTokenList right);
    public static bool op_Inequality(SyntaxNodeOrTokenList left, SyntaxNodeOrTokenList right);
    public sealed virtual bool Equals(SyntaxNodeOrTokenList other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class Microsoft.CodeAnalysis.SyntaxReference : object {
    public SyntaxTree SyntaxTree { get; }
    public TextSpan Span { get; }
    public abstract virtual SyntaxTree get_SyntaxTree();
    public abstract virtual TextSpan get_Span();
    public abstract virtual SyntaxNode GetSyntax(CancellationToken cancellationToken);
    public virtual Task`1<SyntaxNode> GetSyntaxAsync(CancellationToken cancellationToken);
    internal Location GetLocation();
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.SyntaxRemoveOptions : Enum {
    public int value__;
    public static SyntaxRemoveOptions KeepNoTrivia;
    public static SyntaxRemoveOptions KeepLeadingTrivia;
    public static SyntaxRemoveOptions KeepTrailingTrivia;
    public static SyntaxRemoveOptions KeepExteriorTrivia;
    public static SyntaxRemoveOptions KeepUnbalancedDirectives;
    public static SyntaxRemoveOptions KeepDirectives;
    public static SyntaxRemoveOptions KeepEndOfLine;
    public static SyntaxRemoveOptions AddElasticMarker;
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.SyntaxToken : ValueType {
    internal static Func`2<SyntaxToken, bool> NonZeroWidth;
    internal static Func`2<SyntaxToken, bool> Any;
    [CompilerGeneratedAttribute]
private SyntaxNode <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private GreenNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public int RawKind { get; }
    public string Language { get; }
    internal int RawContextualKind { get; }
    public SyntaxNode Parent { get; }
    internal GreenNode Node { get; }
    internal int Index { get; }
    internal int Position { get; }
    internal int Width { get; }
    internal int FullWidth { get; }
    public TextSpan Span { get; }
    internal int EndPosition { get; }
    public int SpanStart { get; }
    public TextSpan FullSpan { get; }
    public bool IsMissing { get; }
    public object Value { get; }
    public string ValueText { get; }
    public string Text { get; }
    public bool HasLeadingTrivia { get; }
    public bool HasTrailingTrivia { get; }
    internal int LeadingWidth { get; }
    internal int TrailingWidth { get; }
    public bool ContainsDiagnostics { get; }
    public bool ContainsDirectives { get; }
    public bool HasStructuredTrivia { get; }
    public bool ContainsAnnotations { get; }
    public SyntaxTriviaList LeadingTrivia { get; }
    public SyntaxTriviaList TrailingTrivia { get; }
    public SyntaxTree SyntaxTree { get; }
    internal SyntaxToken(SyntaxNode parent, GreenNode token, int position, int index);
    internal SyntaxToken(GreenNode token);
    private static SyntaxToken();
    private string GetDebuggerDisplay();
    public int get_RawKind();
    public string get_Language();
    internal int get_RawContextualKind();
    [CompilerGeneratedAttribute]
public SyntaxNode get_Parent();
    [CompilerGeneratedAttribute]
internal GreenNode get_Node();
    [CompilerGeneratedAttribute]
internal int get_Index();
    [CompilerGeneratedAttribute]
internal int get_Position();
    internal int get_Width();
    internal int get_FullWidth();
    public TextSpan get_Span();
    internal int get_EndPosition();
    public int get_SpanStart();
    public TextSpan get_FullSpan();
    public bool get_IsMissing();
    public object get_Value();
    public string get_ValueText();
    public string get_Text();
    public virtual string ToString();
    public string ToFullString();
    public void WriteTo(TextWriter writer);
    internal void WriteTo(TextWriter writer, bool leading, bool trailing);
    public bool get_HasLeadingTrivia();
    public bool get_HasTrailingTrivia();
    internal int get_LeadingWidth();
    internal int get_TrailingWidth();
    public bool get_ContainsDiagnostics();
    public bool get_ContainsDirectives();
    public bool IsPartOfStructuredTrivia();
    public bool get_HasStructuredTrivia();
    public bool get_ContainsAnnotations();
    public bool HasAnnotations(string annotationKind);
    public bool HasAnnotations(String[] annotationKinds);
    public bool HasAnnotation(SyntaxAnnotation annotation);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(string annotationKind);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(String[] annotationKinds);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(IEnumerable`1<string> annotationKinds);
    public SyntaxToken WithAdditionalAnnotations(SyntaxAnnotation[] annotations);
    public SyntaxToken WithAdditionalAnnotations(IEnumerable`1<SyntaxAnnotation> annotations);
    public SyntaxToken WithoutAnnotations(SyntaxAnnotation[] annotations);
    public SyntaxToken WithoutAnnotations(IEnumerable`1<SyntaxAnnotation> annotations);
    public SyntaxToken WithoutAnnotations(string annotationKind);
    public SyntaxToken CopyAnnotationsTo(SyntaxToken token);
    public SyntaxTriviaList get_LeadingTrivia();
    public SyntaxTriviaList get_TrailingTrivia();
    public SyntaxToken WithTriviaFrom(SyntaxToken token);
    public SyntaxToken WithLeadingTrivia(SyntaxTriviaList trivia);
    public SyntaxToken WithLeadingTrivia(SyntaxTrivia[] trivia);
    public SyntaxToken WithLeadingTrivia(IEnumerable`1<SyntaxTrivia> trivia);
    public SyntaxToken WithTrailingTrivia(SyntaxTriviaList trivia);
    public SyntaxToken WithTrailingTrivia(SyntaxTrivia[] trivia);
    public SyntaxToken WithTrailingTrivia(IEnumerable`1<SyntaxTrivia> trivia);
    public IEnumerable`1<SyntaxTrivia> GetAllTrivia();
    public static bool op_Equality(SyntaxToken left, SyntaxToken right);
    public static bool op_Inequality(SyntaxToken left, SyntaxToken right);
    public sealed virtual bool Equals(SyntaxToken other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public SyntaxToken GetNextToken(bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    internal SyntaxToken GetNextToken(Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    public SyntaxToken GetPreviousToken(bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    internal SyntaxToken GetPreviousToken(Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    public SyntaxTree get_SyntaxTree();
    public Location GetLocation();
    public IEnumerable`1<Diagnostic> GetDiagnostics();
    public bool IsEquivalentTo(SyntaxToken token);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.CodeAnalysis.SyntaxTokenList : ValueType {
    private SyntaxNode _parent;
    private int _index;
    [CompilerGeneratedAttribute]
private GreenNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    internal GreenNode Node { get; }
    internal int Position { get; }
    public int Count { get; }
    public SyntaxToken Item { get; }
    public TextSpan FullSpan { get; }
    public TextSpan Span { get; }
    private SyntaxToken[] Nodes { get; }
    internal SyntaxTokenList(SyntaxNode parent, GreenNode tokenOrList, int position, int index);
    internal SyntaxTokenList(SyntaxToken token);
    [CompilerGeneratedAttribute]
internal GreenNode get_Node();
    [CompilerGeneratedAttribute]
internal int get_Position();
    public sealed virtual int get_Count();
    public sealed virtual SyntaxToken get_Item(int index);
    public TextSpan get_FullSpan();
    public TextSpan get_Span();
    public virtual string ToString();
    public string ToFullString();
    public SyntaxToken First();
    public SyntaxToken Last();
    public bool Any();
    public Reversed Reverse();
    internal void CopyTo(int offset, GreenNode[] array, int arrayOffset, int count);
    private GreenNode GetGreenNodeAt(int i);
    private static GreenNode GetGreenNodeAt(GreenNode node, int i);
    public int IndexOf(SyntaxToken tokenInList);
    internal int IndexOf(int rawKind);
    public SyntaxTokenList Add(SyntaxToken token);
    public SyntaxTokenList AddRange(IEnumerable`1<SyntaxToken> tokens);
    public SyntaxTokenList Insert(int index, SyntaxToken token);
    public SyntaxTokenList InsertRange(int index, IEnumerable`1<SyntaxToken> tokens);
    public SyntaxTokenList RemoveAt(int index);
    public SyntaxTokenList Remove(SyntaxToken tokenInList);
    public SyntaxTokenList Replace(SyntaxToken tokenInList, SyntaxToken newToken);
    public SyntaxTokenList ReplaceRange(SyntaxToken tokenInList, IEnumerable`1<SyntaxToken> newTokens);
    private SyntaxToken[] get_Nodes();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<SyntaxToken> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public static bool op_Equality(SyntaxTokenList left, SyntaxTokenList right);
    public static bool op_Inequality(SyntaxTokenList left, SyntaxTokenList right);
    public sealed virtual bool Equals(SyntaxTokenList other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static SyntaxTokenList Create(SyntaxToken token);
}
public abstract class Microsoft.CodeAnalysis.SyntaxTree : object {
    private ImmutableArray`1<byte> _lazyChecksum;
    private SourceHashAlgorithm _lazyHashAlgorithm;
    public string FilePath { get; }
    public bool HasCompilationUnitRoot { get; }
    public ParseOptions Options { get; }
    protected ParseOptions OptionsCore { get; }
    public int Length { get; }
    public Encoding Encoding { get; }
    public abstract virtual string get_FilePath();
    public abstract virtual bool get_HasCompilationUnitRoot();
    public ParseOptions get_Options();
    protected abstract virtual ParseOptions get_OptionsCore();
    public abstract virtual int get_Length();
    public abstract virtual bool TryGetText(SourceText& text);
    public abstract virtual SourceText GetText(CancellationToken cancellationToken);
    public abstract virtual Encoding get_Encoding();
    public virtual Task`1<SourceText> GetTextAsync(CancellationToken cancellationToken);
    public bool TryGetRoot(SyntaxNode& root);
    protected abstract virtual bool TryGetRootCore(SyntaxNode& root);
    public SyntaxNode GetRoot(CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode GetRootCore(CancellationToken cancellationToken);
    public Task`1<SyntaxNode> GetRootAsync(CancellationToken cancellationToken);
    protected abstract virtual Task`1<SyntaxNode> GetRootAsyncCore(CancellationToken cancellationToken);
    public abstract virtual SyntaxTree WithChangedText(SourceText newText);
    public abstract virtual IEnumerable`1<Diagnostic> GetDiagnostics(CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<Diagnostic> GetDiagnostics(SyntaxNode node);
    public abstract virtual IEnumerable`1<Diagnostic> GetDiagnostics(SyntaxToken token);
    public abstract virtual IEnumerable`1<Diagnostic> GetDiagnostics(SyntaxTrivia trivia);
    public abstract virtual IEnumerable`1<Diagnostic> GetDiagnostics(SyntaxNodeOrToken nodeOrToken);
    public abstract virtual FileLinePositionSpan GetLineSpan(TextSpan span, CancellationToken cancellationToken);
    public abstract virtual FileLinePositionSpan GetMappedLineSpan(TextSpan span, CancellationToken cancellationToken);
    public virtual LineVisibility GetLineVisibility(int position, CancellationToken cancellationToken);
    internal virtual FileLinePositionSpan GetMappedLineSpanAndVisibility(TextSpan span, Boolean& isHiddenPosition);
    internal string GetDisplayPath(TextSpan span, SourceReferenceResolver resolver);
    internal int GetDisplayLineNumber(TextSpan span);
    public abstract virtual bool HasHiddenRegions();
    public abstract virtual IList`1<TextSpan> GetChangedSpans(SyntaxTree syntaxTree);
    public abstract virtual Location GetLocation(TextSpan span);
    public abstract virtual bool IsEquivalentTo(SyntaxTree tree, bool topLevel);
    public abstract virtual SyntaxReference GetReference(SyntaxNode node);
    public abstract virtual IList`1<TextChange> GetChanges(SyntaxTree oldTree);
    internal ValueTuple`2<ImmutableArray`1<byte>, Guid> GetChecksumAndAlgorithm();
    public abstract virtual SyntaxTree WithRootAndOptions(SyntaxNode root, ParseOptions options);
    public abstract virtual SyntaxTree WithFilePath(string path);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SyntaxTreeExtensions : object {
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
internal static void VerifySource(SyntaxTree tree, IEnumerable`1<TextChangeRange> changes);
    private static int FindFirstDifference(string s1, string s2);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.SyntaxTrivia : ValueType {
    internal static Func`2<SyntaxTrivia, bool> Any;
    [CompilerGeneratedAttribute]
private SyntaxToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private GreenNode <UnderlyingNode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public int RawKind { get; }
    public string Language { get; }
    public SyntaxToken Token { get; }
    internal GreenNode UnderlyingNode { get; }
    internal int Position { get; }
    internal int Index { get; }
    internal int Width { get; }
    internal int FullWidth { get; }
    public TextSpan Span { get; }
    public int SpanStart { get; }
    public TextSpan FullSpan { get; }
    public bool ContainsDiagnostics { get; }
    public bool HasStructure { get; }
    internal bool ContainsAnnotations { get; }
    public bool IsDirective { get; }
    public SyntaxTree SyntaxTree { get; }
    internal SyntaxTrivia(SyntaxToken token, GreenNode triviaNode, int position, int index);
    private static SyntaxTrivia();
    public int get_RawKind();
    private string GetDebuggerDisplay();
    public string get_Language();
    [CompilerGeneratedAttribute]
public SyntaxToken get_Token();
    [CompilerGeneratedAttribute]
internal GreenNode get_UnderlyingNode();
    [CompilerGeneratedAttribute]
internal int get_Position();
    [CompilerGeneratedAttribute]
internal int get_Index();
    internal int get_Width();
    internal int get_FullWidth();
    public TextSpan get_Span();
    public int get_SpanStart();
    public TextSpan get_FullSpan();
    public bool get_ContainsDiagnostics();
    public bool get_HasStructure();
    public bool IsPartOfStructuredTrivia();
    internal bool get_ContainsAnnotations();
    public bool HasAnnotations(string annotationKind);
    public bool HasAnnotations(String[] annotationKinds);
    public bool HasAnnotation(SyntaxAnnotation annotation);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(string annotationKind);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(String[] annotationKinds);
    public bool get_IsDirective();
    public SyntaxNode GetStructure();
    public virtual string ToString();
    public string ToFullString();
    public void WriteTo(TextWriter writer);
    public static bool op_Equality(SyntaxTrivia left, SyntaxTrivia right);
    public static bool op_Inequality(SyntaxTrivia left, SyntaxTrivia right);
    public sealed virtual bool Equals(SyntaxTrivia other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public SyntaxTrivia WithAdditionalAnnotations(SyntaxAnnotation[] annotations);
    public SyntaxTrivia WithAdditionalAnnotations(IEnumerable`1<SyntaxAnnotation> annotations);
    public SyntaxTrivia WithoutAnnotations(SyntaxAnnotation[] annotations);
    public SyntaxTrivia WithoutAnnotations(IEnumerable`1<SyntaxAnnotation> annotations);
    public SyntaxTrivia WithoutAnnotations(string annotationKind);
    public SyntaxTrivia CopyAnnotationsTo(SyntaxTrivia trivia);
    public SyntaxTree get_SyntaxTree();
    public Location GetLocation();
    public IEnumerable`1<Diagnostic> GetDiagnostics();
    public bool IsEquivalentTo(SyntaxTrivia trivia);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.CodeAnalysis.SyntaxTriviaList : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private GreenNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public static SyntaxTriviaList Empty { get; }
    internal SyntaxToken Token { get; }
    internal GreenNode Node { get; }
    internal int Position { get; }
    internal int Index { get; }
    public int Count { get; }
    public SyntaxTrivia Item { get; }
    public TextSpan FullSpan { get; }
    public TextSpan Span { get; }
    private SyntaxTrivia[] Nodes { get; }
    internal SyntaxTriviaList(SyntaxToken token, GreenNode node, int position, int index);
    internal SyntaxTriviaList(SyntaxToken token, GreenNode node);
    internal SyntaxTriviaList(SyntaxTrivia trivia);
    public static SyntaxTriviaList get_Empty();
    [CompilerGeneratedAttribute]
internal SyntaxToken get_Token();
    [CompilerGeneratedAttribute]
internal GreenNode get_Node();
    [CompilerGeneratedAttribute]
internal int get_Position();
    [CompilerGeneratedAttribute]
internal int get_Index();
    public sealed virtual int get_Count();
    public SyntaxTrivia ElementAt(int index);
    public sealed virtual SyntaxTrivia get_Item(int index);
    public TextSpan get_FullSpan();
    public TextSpan get_Span();
    public SyntaxTrivia First();
    public SyntaxTrivia Last();
    public bool Any();
    public Reversed Reverse();
    public Enumerator GetEnumerator();
    public int IndexOf(SyntaxTrivia triviaInList);
    internal int IndexOf(int rawKind);
    public SyntaxTriviaList Add(SyntaxTrivia trivia);
    public SyntaxTriviaList AddRange(IEnumerable`1<SyntaxTrivia> trivia);
    public SyntaxTriviaList Insert(int index, SyntaxTrivia trivia);
    public SyntaxTriviaList InsertRange(int index, IEnumerable`1<SyntaxTrivia> trivia);
    public SyntaxTriviaList RemoveAt(int index);
    public SyntaxTriviaList Remove(SyntaxTrivia triviaInList);
    public SyntaxTriviaList Replace(SyntaxTrivia triviaInList, SyntaxTrivia newTrivia);
    public SyntaxTriviaList ReplaceRange(SyntaxTrivia triviaInList, IEnumerable`1<SyntaxTrivia> newTrivia);
    private SyntaxTrivia[] get_Nodes();
    private sealed virtual override IEnumerator`1<SyntaxTrivia> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private GreenNode GetGreenNodeAt(int i);
    private static GreenNode GetGreenNodeAt(GreenNode node, int i);
    public sealed virtual bool Equals(SyntaxTriviaList other);
    public static bool op_Equality(SyntaxTriviaList left, SyntaxTriviaList right);
    public static bool op_Inequality(SyntaxTriviaList left, SyntaxTriviaList right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal void CopyTo(int offset, SyntaxTrivia[] array, int arrayOffset, int count);
    public virtual string ToString();
    public string ToFullString();
    public static SyntaxTriviaList Create(SyntaxTrivia trivia);
}
public abstract class Microsoft.CodeAnalysis.SyntaxWalker : object {
    [CompilerGeneratedAttribute]
private SyntaxWalkerDepth <Depth>k__BackingField;
    protected SyntaxWalkerDepth Depth { get; }
    protected SyntaxWalker(SyntaxWalkerDepth depth);
    [CompilerGeneratedAttribute]
protected SyntaxWalkerDepth get_Depth();
    public virtual void Visit(SyntaxNode node);
    protected virtual void VisitToken(SyntaxToken token);
    private void VisitLeadingTrivia(SyntaxToken token);
    private void VisitTrailingTrivia(SyntaxToken token);
    protected virtual void VisitTrivia(SyntaxTrivia trivia);
}
public enum Microsoft.CodeAnalysis.SyntaxWalkerDepth : Enum {
    public int value__;
    public static SyntaxWalkerDepth Node;
    public static SyntaxWalkerDepth Token;
    public static SyntaxWalkerDepth Trivia;
    public static SyntaxWalkerDepth StructuredTrivia;
}
internal enum Microsoft.CodeAnalysis.SynthesizedLocalKind : Enum {
    public int value__;
    public static SynthesizedLocalKind OptimizerTemp;
    public static SynthesizedLocalKind LoweringTemp;
    public static SynthesizedLocalKind EmitterTemp;
    public static SynthesizedLocalKind UserDefined;
    public static SynthesizedLocalKind ConditionalBranchDiscriminator;
    public static SynthesizedLocalKind LockTaken;
    public static SynthesizedLocalKind Lock;
    public static SynthesizedLocalKind Using;
    public static SynthesizedLocalKind ForEachEnumerator;
    public static SynthesizedLocalKind ForEachArray;
    public static SynthesizedLocalKind ForEachArrayLimit;
    public static SynthesizedLocalKind ForEachArrayIndex;
    public static SynthesizedLocalKind FixedString;
    public static SynthesizedLocalKind With;
    public static SynthesizedLocalKind ForLimit;
    public static SynthesizedLocalKind ForStep;
    public static SynthesizedLocalKind ForInitialValue;
    public static SynthesizedLocalKind ForDirection;
    public static SynthesizedLocalKind SelectCaseValue;
    public static SynthesizedLocalKind OnErrorActiveHandler;
    public static SynthesizedLocalKind OnErrorResumeTarget;
    public static SynthesizedLocalKind OnErrorCurrentStatement;
    public static SynthesizedLocalKind OnErrorCurrentLine;
    public static SynthesizedLocalKind AsyncMethodReturnValue;
    public static SynthesizedLocalKind StateMachineReturnValue;
    public static SynthesizedLocalKind FunctionReturnValue;
    public static SynthesizedLocalKind TryAwaitPendingException;
    public static SynthesizedLocalKind TryAwaitPendingBranch;
    public static SynthesizedLocalKind TryAwaitPendingCatch;
    public static SynthesizedLocalKind TryAwaitPendingCaughtException;
    public static SynthesizedLocalKind ExceptionFilterAwaitHoistedExceptionLocal;
    public static SynthesizedLocalKind StateMachineCachedState;
    public static SynthesizedLocalKind AwaitSpill;
    public static SynthesizedLocalKind AwaitByRefSpill;
    public static SynthesizedLocalKind LambdaDisplayClass;
    public static SynthesizedLocalKind CachedAnonymousMethodDelegate;
    public static SynthesizedLocalKind XmlInExpressionLambda;
    public static SynthesizedLocalKind Awaiter;
    public static SynthesizedLocalKind MaxValidValueForLocalVariableSerializedToDebugInformation;
    public static SynthesizedLocalKind AwaiterField;
    public static SynthesizedLocalKind DelegateRelaxationReceiver;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SynthesizedLocalKindExtensions : object {
    [ExtensionAttribute]
public static bool IsLongLived(SynthesizedLocalKind kind);
    [ExtensionAttribute]
public static bool MustSurviveStateMachineSuspension(SynthesizedLocalKind kind);
    [ExtensionAttribute]
public static bool IsSlotReusable(SynthesizedLocalKind kind, OptimizationLevel optimizations);
    [ExtensionAttribute]
public static UInt32 PdbAttributes(SynthesizedLocalKind kind);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Text.ChangedText : SourceText {
    private SourceText _oldText;
    private SourceText _newText;
    private ImmutableArray`1<TextChangeRange> _changes;
    public Encoding Encoding { get; }
    public SourceText OldText { get; }
    public SourceText NewText { get; }
    public IEnumerable`1<TextChangeRange> Changes { get; }
    public int Length { get; }
    public char Item { get; }
    public ChangedText(SourceText oldText, ImmutableArray`1<TextChangeRange> changeRanges, ImmutableArray`1<SourceText> segments);
    public virtual Encoding get_Encoding();
    public SourceText get_OldText();
    public SourceText get_NewText();
    public IEnumerable`1<TextChangeRange> get_Changes();
    public virtual int get_Length();
    public virtual char get_Item(int position);
    public virtual string ToString(TextSpan span);
    public virtual SourceText GetSubText(TextSpan span);
    public virtual void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public virtual IReadOnlyList`1<TextChangeRange> GetChangeRanges(SourceText oldText);
    protected virtual TextLineCollection GetLinesCore();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Text.CompositeText : SourceText {
    private ImmutableArray`1<SourceText> _texts;
    private int _length;
    public Encoding Encoding { get; }
    public int Length { get; }
    public char Item { get; }
    public CompositeText(ImmutableArray`1<SourceText> texts);
    public virtual Encoding get_Encoding();
    public virtual int get_Length();
    public virtual char get_Item(int position);
    public virtual SourceText GetSubText(TextSpan span);
    private void GetIndexAndOffset(int position, Int32& index, Int32& offset);
    private bool CheckCopyToArguments(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public virtual void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    internal static void AddSegments(ArrayBuilder`1<SourceText> builder, SourceText text);
}
internal static class Microsoft.CodeAnalysis.Text.EncodedStringText : object {
    private static int LargeObjectHeapLimitInChars;
    private static Encoding s_fallbackEncoding;
    private static Encoding s_defaultEncoding;
    private static EncodedStringText();
    private static Encoding GetDefaultEncoding();
    internal static SourceText Create(Stream stream, Encoding defaultEncoding, SourceHashAlgorithm checksumAlgorithm);
    internal static SourceText Decode(Stream data, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected);
    private static Byte[] TryGetByteArrayFromStream(Stream data);
    private static bool TryGetByteArrayFromMemoryStream(MemoryStream data, Byte[]& buffer);
    private static bool TryGetByteArrayFromFileStream(Stream stream, Byte[]& buffer);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Text.LargeEncodedText : SourceText {
    internal static int ChunkSize;
    private ImmutableArray`1<Char[]> _chunks;
    private Int32[] _chunkStartOffsets;
    private int _length;
    private Encoding _encoding;
    public char Item { get; }
    public Encoding Encoding { get; }
    public int Length { get; }
    private LargeEncodedText(ImmutableArray`1<Char[]> chunks, Encoding encoding, ImmutableArray`1<byte> checksum, SourceHashAlgorithm checksumAlgorithm);
    internal static SourceText Decode(Stream stream, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected);
    private static bool IsBinary(Char[] chunk);
    private int GetIndexFromPosition(int position);
    public virtual char get_Item(int position);
    public virtual Encoding get_Encoding();
    public virtual int get_Length();
    public virtual void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public virtual void Write(TextWriter writer, TextSpan span, CancellationToken cancellationToken);
    protected virtual TextLineCollection GetLinesCore();
    private Int32[] ParseLineStarts();
}
public class Microsoft.CodeAnalysis.Text.LinePosition : ValueType {
    private int _line;
    private int _character;
    public static LinePosition Zero { get; }
    public int Line { get; }
    public int Character { get; }
    public LinePosition(int line, int character);
    internal LinePosition(int character);
    public static LinePosition get_Zero();
    public int get_Line();
    public int get_Character();
    public static bool op_Equality(LinePosition left, LinePosition right);
    public static bool op_Inequality(LinePosition left, LinePosition right);
    public sealed virtual bool Equals(LinePosition other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int CompareTo(LinePosition other);
    public static bool op_GreaterThan(LinePosition left, LinePosition right);
    public static bool op_GreaterThanOrEqual(LinePosition left, LinePosition right);
    public static bool op_LessThan(LinePosition left, LinePosition right);
    public static bool op_LessThanOrEqual(LinePosition left, LinePosition right);
}
public class Microsoft.CodeAnalysis.Text.LinePositionSpan : ValueType {
    private LinePosition _start;
    private LinePosition _end;
    public LinePosition Start { get; }
    public LinePosition End { get; }
    public LinePositionSpan(LinePosition start, LinePosition end);
    public LinePosition get_Start();
    public LinePosition get_End();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(LinePositionSpan other);
    public virtual int GetHashCode();
    public static bool op_Equality(LinePositionSpan left, LinePositionSpan right);
    public static bool op_Inequality(LinePositionSpan left, LinePositionSpan right);
    public virtual string ToString();
}
public enum Microsoft.CodeAnalysis.Text.SourceHashAlgorithm : Enum {
    public int value__;
    public static SourceHashAlgorithm None;
    public static SourceHashAlgorithm Sha1;
    public static SourceHashAlgorithm Sha256;
}
[DefaultMemberAttribute("Item")]
public abstract class Microsoft.CodeAnalysis.Text.SourceText : object {
    private static int CharBufferSize;
    private static int CharBufferCount;
    private static int LargeObjectHeapLimitInChars;
    private static ObjectPool`1<Char[]> s_charArrayPool;
    private SourceHashAlgorithm _checksumAlgorithm;
    private SourceTextContainer _lazyContainer;
    private TextLineCollection _lazyLineInfo;
    private ImmutableArray`1<byte> _lazyChecksum;
    private static Encoding s_utf8EncodingWithNoBOM;
    public SourceHashAlgorithm ChecksumAlgorithm { get; }
    public Encoding Encoding { get; }
    public int Length { get; }
    public char Item { get; }
    public SourceTextContainer Container { get; }
    public TextLineCollection Lines { get; }
    protected SourceText(ImmutableArray`1<byte> checksum, SourceHashAlgorithm checksumAlgorithm, SourceTextContainer container);
    private static SourceText();
    internal static void ValidateChecksumAlgorithm(SourceHashAlgorithm checksumAlgorithm);
    public static SourceText From(string text, Encoding encoding, SourceHashAlgorithm checksumAlgorithm);
    public static SourceText From(Stream stream, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected);
    public static SourceText From(Byte[] buffer, int length, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected);
    private static string Decode(Stream stream, Encoding encoding, Encoding& actualEncoding);
    private static string Decode(Byte[] buffer, int length, Encoding encoding, Encoding& actualEncoding);
    internal static bool IsBinary(string text);
    public SourceHashAlgorithm get_ChecksumAlgorithm();
    public abstract virtual Encoding get_Encoding();
    public abstract virtual int get_Length();
    public abstract virtual char get_Item(int position);
    public abstract virtual void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public virtual SourceTextContainer get_Container();
    internal void CheckSubSpan(TextSpan span);
    public virtual SourceText GetSubText(TextSpan span);
    public SourceText GetSubText(int start);
    public void Write(TextWriter textWriter, CancellationToken cancellationToken);
    public virtual void Write(TextWriter writer, TextSpan span, CancellationToken cancellationToken);
    internal ImmutableArray`1<byte> GetChecksum();
    private static ImmutableArray`1<byte> CalculateChecksum(Stream stream, SourceHashAlgorithm algorithmId);
    private static ImmutableArray`1<byte> CalculateChecksum(Byte[] buffer, int offset, int count, SourceHashAlgorithm algorithmId);
    public virtual string ToString();
    public virtual string ToString(TextSpan span);
    public virtual SourceText WithChanges(IEnumerable`1<TextChange> changes);
    public SourceText WithChanges(TextChange[] changes);
    public SourceText Replace(TextSpan span, string newText);
    public SourceText Replace(int start, int length, string newText);
    public virtual IReadOnlyList`1<TextChangeRange> GetChangeRanges(SourceText oldText);
    public virtual IReadOnlyList`1<TextChange> GetTextChanges(SourceText oldText);
    public TextLineCollection get_Lines();
    protected virtual TextLineCollection GetLinesCore();
    private Int32[] ParseLineStarts();
    public bool ContentEquals(SourceText other);
    protected virtual bool ContentEqualsImpl(SourceText other);
    internal static Encoding TryReadByteOrderMark(Byte[] source, int length, Int32& preambleLength);
}
public abstract class Microsoft.CodeAnalysis.Text.SourceTextContainer : object {
    public SourceText CurrentText { get; }
    public abstract virtual SourceText get_CurrentText();
    [CompilerGeneratedAttribute]
public abstract virtual void add_TextChanged(EventHandler`1<TextChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TextChanged(EventHandler`1<TextChangeEventArgs> value);
}
internal class Microsoft.CodeAnalysis.Text.SourceTextStream : Stream {
    private SourceText _source;
    private Encoder _encoder;
    private int _minimumTargetBufferCount;
    private int _position;
    private int _sourceOffset;
    private Char[] _charBuffer;
    private int _bufferOffset;
    private int _bufferUnreadChars;
    private bool _preambleWritten;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public SourceTextStream(SourceText source, int bufferSize);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    private int WritePreamble(Byte[] buffer, int offset, int count);
    private void FillBuffer();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Text.StringBuilderText : SourceText {
    private StringBuilder _builder;
    private Encoding _encodingOpt;
    public Encoding Encoding { get; }
    internal StringBuilder Builder { get; }
    public int Length { get; }
    public char Item { get; }
    public StringBuilderText(StringBuilder builder, Encoding encodingOpt, SourceHashAlgorithm checksumAlgorithm);
    public virtual Encoding get_Encoding();
    internal StringBuilder get_Builder();
    public virtual int get_Length();
    public virtual char get_Item(int position);
    public virtual string ToString(TextSpan span);
    public virtual void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Text.StringText : SourceText {
    private string _source;
    private Encoding _encodingOpt;
    public Encoding Encoding { get; }
    public string Source { get; }
    public int Length { get; }
    public char Item { get; }
    internal StringText(string source, Encoding encodingOpt, ImmutableArray`1<byte> checksum, SourceHashAlgorithm checksumAlgorithm);
    public virtual Encoding get_Encoding();
    public string get_Source();
    public virtual int get_Length();
    public virtual char get_Item(int position);
    public virtual string ToString(TextSpan span);
    public virtual void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public virtual void Write(TextWriter textWriter, TextSpan span, CancellationToken cancellationToken);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Text.SubText : SourceText {
    [CompilerGeneratedAttribute]
private SourceText <UnderlyingText>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <UnderlyingSpan>k__BackingField;
    public Encoding Encoding { get; }
    public SourceText UnderlyingText { get; }
    public TextSpan UnderlyingSpan { get; }
    public int Length { get; }
    public char Item { get; }
    public SubText(SourceText text, TextSpan span);
    public virtual Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public SourceText get_UnderlyingText();
    [CompilerGeneratedAttribute]
public TextSpan get_UnderlyingSpan();
    public virtual int get_Length();
    public virtual char get_Item(int position);
    public virtual string ToString(TextSpan span);
    public virtual SourceText GetSubText(TextSpan span);
    public virtual void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    private TextSpan GetCompositeSpan(int start, int length);
}
public class Microsoft.CodeAnalysis.Text.TextChange : ValueType {
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewText>k__BackingField;
    public TextSpan Span { get; }
    public string NewText { get; }
    public static IReadOnlyList`1<TextChange> NoChanges { get; }
    public TextChange(TextSpan span, string newText);
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public string get_NewText();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TextChange other);
    public virtual int GetHashCode();
    public static bool op_Equality(TextChange left, TextChange right);
    public static bool op_Inequality(TextChange left, TextChange right);
    public static TextChangeRange op_Implicit(TextChange change);
    public static IReadOnlyList`1<TextChange> get_NoChanges();
}
public class Microsoft.CodeAnalysis.Text.TextChangeEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private SourceText <OldText>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceText <NewText>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<TextChangeRange> <Changes>k__BackingField;
    public SourceText OldText { get; }
    public SourceText NewText { get; }
    public IReadOnlyList`1<TextChangeRange> Changes { get; }
    public TextChangeEventArgs(SourceText oldText, SourceText newText, IEnumerable`1<TextChangeRange> changes);
    public TextChangeEventArgs(SourceText oldText, SourceText newText, TextChangeRange[] changes);
    [CompilerGeneratedAttribute]
public SourceText get_OldText();
    [CompilerGeneratedAttribute]
public SourceText get_NewText();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<TextChangeRange> get_Changes();
}
public class Microsoft.CodeAnalysis.Text.TextChangeRange : ValueType {
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NewLength>k__BackingField;
    public TextSpan Span { get; }
    public int NewLength { get; }
    public static IReadOnlyList`1<TextChangeRange> NoChanges { get; }
    public TextChangeRange(TextSpan span, int newLength);
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public int get_NewLength();
    public sealed virtual bool Equals(TextChangeRange other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TextChangeRange left, TextChangeRange right);
    public static bool op_Inequality(TextChangeRange left, TextChangeRange right);
    public static IReadOnlyList`1<TextChangeRange> get_NoChanges();
    public static TextChangeRange Collapse(IEnumerable`1<TextChangeRange> changes);
}
public class Microsoft.CodeAnalysis.Text.TextLine : ValueType {
    private SourceText _text;
    private int _start;
    private int _endIncludingBreaks;
    public SourceText Text { get; }
    public int LineNumber { get; }
    public int Start { get; }
    public int End { get; }
    private int LineBreakLength { get; }
    public int EndIncludingLineBreak { get; }
    public TextSpan Span { get; }
    public TextSpan SpanIncludingLineBreak { get; }
    private TextLine(SourceText text, int start, int endIncludingBreaks);
    public static TextLine FromSpan(SourceText text, TextSpan span);
    public SourceText get_Text();
    public int get_LineNumber();
    public int get_Start();
    public int get_End();
    private int get_LineBreakLength();
    public int get_EndIncludingLineBreak();
    public TextSpan get_Span();
    public TextSpan get_SpanIncludingLineBreak();
    public virtual string ToString();
    public static bool op_Equality(TextLine left, TextLine right);
    public static bool op_Inequality(TextLine left, TextLine right);
    public sealed virtual bool Equals(TextLine other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public abstract class Microsoft.CodeAnalysis.Text.TextLineCollection : object {
    public int Count { get; }
    public TextLine Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual TextLine get_Item(int index);
    public abstract virtual int IndexOf(int position);
    public virtual TextLine GetLineFromPosition(int position);
    public virtual LinePosition GetLinePosition(int position);
    public LinePositionSpan GetLinePositionSpan(TextSpan span);
    public int GetPosition(LinePosition position);
    public TextSpan GetTextSpan(LinePositionSpan span);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<TextLine> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Text.TextLine>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Microsoft.CodeAnalysis.Text.TextSpan : ValueType {
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Start { get; }
    public int End { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public TextSpan(int start, int length);
    [CompilerGeneratedAttribute]
public int get_Start();
    public int get_End();
    [CompilerGeneratedAttribute]
public int get_Length();
    public bool get_IsEmpty();
    public bool Contains(int position);
    public bool Contains(TextSpan span);
    public bool OverlapsWith(TextSpan span);
    public Nullable`1<TextSpan> Overlap(TextSpan span);
    public bool IntersectsWith(TextSpan span);
    public bool IntersectsWith(int position);
    public Nullable`1<TextSpan> Intersection(TextSpan span);
    public static TextSpan FromBounds(int start, int end);
    public static bool op_Equality(TextSpan left, TextSpan right);
    public static bool op_Inequality(TextSpan left, TextSpan right);
    public sealed virtual bool Equals(TextSpan other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int CompareTo(TextSpan other);
}
internal static class Microsoft.CodeAnalysis.Text.TextUtilities : object {
    internal static int GetLengthOfLineBreak(SourceText text, int index);
    private static int GetLengthOfLineBreakSlow(SourceText text, int index, char c);
    public static void GetStartAndLengthOfLineBreakEndingAt(SourceText text, int index, Int32& startLinebreak, Int32& lengthLinebreak);
    internal static bool IsAnyLineBreakCharacter(char c);
}
internal enum Microsoft.CodeAnalysis.ThreeState : Enum {
    public byte value__;
    public static ThreeState Unknown;
    public static ThreeState False;
    public static ThreeState True;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ThreeStateHelpers : object {
    [ExtensionAttribute]
public static ThreeState ToThreeState(bool value);
    [ExtensionAttribute]
public static bool HasValue(ThreeState value);
    [ExtensionAttribute]
public static bool Value(ThreeState value);
}
internal class Microsoft.CodeAnalysis.TouchedFileLogger : object {
    private ConcurrentSet`1<string> _readFiles;
    private ConcurrentSet`1<string> _writtenFiles;
    public void AddRead(string path);
    public void AddWritten(string path);
    public void AddReadWritten(string path);
    public void WriteReadPaths(TextWriter s);
    public void WriteWrittenPaths(TextWriter s);
}
internal class Microsoft.CodeAnalysis.TreeDumper : object {
    private StringBuilder _sb;
    public static string DumpCompact(TreeDumperNode root);
    private void DoDumpCompact(TreeDumperNode node, string indent);
    public static string DumpXML(TreeDumperNode root, string indent);
    private void DoDumpXML(TreeDumperNode node, string indent, string relativeIndent);
    private static bool IsDefaultImmutableArray(object o);
    private static string DumperString(object o);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.TreeDumperNode : object {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TreeDumperNode> <Children>k__BackingField;
    public object Value { get; }
    public string Text { get; }
    public IEnumerable`1<TreeDumperNode> Children { get; }
    public TreeDumperNode Item { get; }
    public TreeDumperNode(string text, object value, IEnumerable`1<TreeDumperNode> children);
    public TreeDumperNode(string text);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public IEnumerable`1<TreeDumperNode> get_Children();
    public TreeDumperNode get_Item(string child);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.TreeDumperNode/<PreorderTraversal>d__13")]
public IEnumerable`1<KeyValuePair`2<TreeDumperNode, TreeDumperNode>> PreorderTraversal();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.TypeAttributesExtensions : object {
    [ExtensionAttribute]
public static bool IsInterface(TypeAttributes flags);
    [ExtensionAttribute]
public static bool IsWindowsRuntime(TypeAttributes flags);
    [ExtensionAttribute]
public static bool IsPublic(TypeAttributes flags);
    [ExtensionAttribute]
public static bool IsSpecialName(TypeAttributes flags);
    [ExtensionAttribute]
internal static CharSet ToCharSet(TypeAttributes flags);
}
public class Microsoft.CodeAnalysis.TypedConstant : ValueType {
    private TypedConstantKind _kind;
    private ITypeSymbol _type;
    private object _value;
    public TypedConstantKind Kind { get; }
    public ITypeSymbol Type { get; }
    public bool IsNull { get; }
    public object Value { get; }
    public ImmutableArray`1<TypedConstant> Values { get; }
    internal TypedConstant(ITypeSymbol type, TypedConstantKind kind, object value);
    internal TypedConstant(ITypeSymbol type, ImmutableArray`1<TypedConstant> array);
    public TypedConstantKind get_Kind();
    public ITypeSymbol get_Type();
    public bool get_IsNull();
    public object get_Value();
    public ImmutableArray`1<TypedConstant> get_Values();
    internal T DecodeValue(SpecialType specialType);
    internal static TypedConstantKind GetTypedConstantKind(ITypeSymbol type, Compilation compilation);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TypedConstant other);
    public virtual int GetHashCode();
}
public enum Microsoft.CodeAnalysis.TypedConstantKind : Enum {
    public int value__;
    public static TypedConstantKind Error;
    public static TypedConstantKind Primitive;
    public static TypedConstantKind Enum;
    public static TypedConstantKind Type;
    public static TypedConstantKind Array;
}
internal class Microsoft.CodeAnalysis.TypedConstantValue : ValueType {
    private object _value;
    public bool IsNull { get; }
    public ImmutableArray`1<TypedConstant> Array { get; }
    public object Object { get; }
    internal TypedConstantValue(object value);
    internal TypedConstantValue(ImmutableArray`1<TypedConstant> array);
    public bool get_IsNull();
    public ImmutableArray`1<TypedConstant> get_Array();
    public object get_Object();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TypedConstantValue other);
}
public class Microsoft.CodeAnalysis.TypeInfo : ValueType {
    internal static TypeInfo None;
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeSymbol <ConvertedType>k__BackingField;
    public ITypeSymbol Type { get; }
    public ITypeSymbol ConvertedType { get; }
    internal TypeInfo(ITypeSymbol type, ITypeSymbol convertedType);
    private static TypeInfo();
    [CompilerGeneratedAttribute]
public ITypeSymbol get_Type();
    [CompilerGeneratedAttribute]
public ITypeSymbol get_ConvertedType();
    public sealed virtual bool Equals(TypeInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum Microsoft.CodeAnalysis.TypeKind : Enum {
    public byte value__;
    public static TypeKind Unknown;
    public static TypeKind Array;
    public static TypeKind Class;
    public static TypeKind Delegate;
    public static TypeKind Dynamic;
    public static TypeKind Enum;
    public static TypeKind Error;
    public static TypeKind Interface;
    public static TypeKind Module;
    public static TypeKind Pointer;
    public static TypeKind Struct;
    public static TypeKind Structure;
    public static TypeKind TypeParameter;
    public static TypeKind Submission;
}
internal class Microsoft.CodeAnalysis.TypeLayout : ValueType {
    private byte _kind;
    private short _alignment;
    private int _size;
    public LayoutKind Kind { get; }
    public short Alignment { get; }
    public int Size { get; }
    public TypeLayout(LayoutKind kind, int size, byte alignment);
    public LayoutKind get_Kind();
    public short get_Alignment();
    public int get_Size();
    public sealed virtual bool Equals(TypeLayout other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal abstract class Microsoft.CodeAnalysis.TypeNameDecoder`2 : object {
    private SymbolFactory`2<ModuleSymbol, TypeSymbol> _factory;
    protected ModuleSymbol moduleSymbol;
    protected TypeSymbol SystemTypeSymbol { get; }
    internal TypeNameDecoder`2(SymbolFactory`2<ModuleSymbol, TypeSymbol> factory, ModuleSymbol moduleSymbol);
    protected abstract virtual bool IsContainingAssembly(AssemblyIdentity identity);
    protected abstract virtual TypeSymbol LookupTopLevelTypeDefSymbol(MetadataTypeName& emittedName, Boolean& isNoPiaLocalType);
    protected abstract virtual TypeSymbol LookupTopLevelTypeDefSymbol(int referencedAssemblyIndex, MetadataTypeName& emittedName);
    protected abstract virtual TypeSymbol LookupNestedTypeDefSymbol(TypeSymbol container, MetadataTypeName& emittedName);
    protected abstract virtual int GetIndexOfReferencedAssembly(AssemblyIdentity identity);
    internal TypeSymbol GetTypeSymbolForSerializedType(string s);
    protected TypeSymbol GetUnsupportedMetadataTypeSymbol(BadImageFormatException exception);
    protected TypeSymbol GetSZArrayTypeSymbol(TypeSymbol elementType, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers);
    protected TypeSymbol GetArrayTypeSymbol(int rank, TypeSymbol elementType);
    protected TypeSymbol GetByRefReturnTypeSymbol(TypeSymbol referencedType);
    protected TypeSymbol MakePointerTypeSymbol(TypeSymbol type, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers);
    protected TypeSymbol GetSpecialType(SpecialType specialType);
    protected TypeSymbol get_SystemTypeSymbol();
    protected TypeSymbol GetEnumUnderlyingType(TypeSymbol type);
    protected bool IsVolatileModifierType(TypeSymbol type);
    protected PrimitiveTypeCode GetPrimitiveTypeCode(TypeSymbol type);
    protected TypeSymbol SubstituteWithUnboundIfGeneric(TypeSymbol type);
    protected TypeSymbol SubstituteTypeParameters(TypeSymbol genericType, ImmutableArray`1<TypeSymbol> arguments, ImmutableArray`1<bool> refersToNoPiaLocalType);
    internal TypeSymbol GetTypeSymbol(AssemblyQualifiedTypeName fullName, Boolean& refersToNoPiaLocalType);
    private ImmutableArray`1<TypeSymbol> ResolveTypeArguments(AssemblyQualifiedTypeName[] arguments, ImmutableArray`1& refersToNoPiaLocalType);
    private TypeSymbol LookupTopLevelTypeDefSymbol(MetadataTypeName& emittedName, int referencedAssemblyIndex, Boolean& isNoPiaLocalType);
}
public enum Microsoft.CodeAnalysis.TypeParameterKind : Enum {
    public int value__;
    public static TypeParameterKind Type;
    public static TypeParameterKind Method;
    public static TypeParameterKind Cref;
}
internal class Microsoft.CodeAnalysis.UnifiedAssembly`1 : ValueType {
    internal AssemblyIdentity OriginalReference;
    internal TAssemblySymbol TargetAssembly;
    public UnifiedAssembly`1(TAssemblySymbol targetAssembly, AssemblyIdentity originalReference);
}
internal class Microsoft.CodeAnalysis.UnionCollection`1 : object {
    private ImmutableArray`1<ICollection`1<T>> _collections;
    private int _count;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private UnionCollection`1(ImmutableArray`1<ICollection`1<T>> collections);
    public static ICollection`1<T> Create(ICollection`1<T> coll1, ICollection`1<T> coll2);
    public static ICollection`1<T> Create(ImmutableArray`1<TOrig> collections, Func`2<TOrig, ICollection`1<T>> selector);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Microsoft.CodeAnalysis.UnresolvedMetadataReference : MetadataReference {
    [CompilerGeneratedAttribute]
private string <Reference>k__BackingField;
    public string Reference { get; }
    public string Display { get; }
    internal bool IsUnresolved { get; }
    internal UnresolvedMetadataReference(string reference, MetadataReferenceProperties properties);
    [CompilerGeneratedAttribute]
public string get_Reference();
    public virtual string get_Display();
    internal virtual bool get_IsUnresolved();
    internal virtual MetadataReference WithPropertiesImplReturningMetadataReference(MetadataReferenceProperties properties);
}
internal class Microsoft.CodeAnalysis.UnsupportedSignatureContent : Exception {
}
public enum Microsoft.CodeAnalysis.VarianceKind : Enum {
    public short value__;
    public static VarianceKind None;
    public static VarianceKind Out;
    public static VarianceKind In;
}
internal static class Microsoft.CodeAnalysis.VersionHelper : object {
    internal static bool TryParse(string s, Version& version);
    internal static bool TryParseAssemblyVersion(string s, bool allowWildcard, Version& version);
    private static bool TryParse(string s, bool allowWildcard, ushort maxValue, Version& version);
}
internal abstract class Microsoft.CodeAnalysis.WellKnownAttributeData : object {
    public static string StringMissingValue;
    private static WellKnownAttributeData();
    [ConditionalAttribute("DEBUG")]
protected void VerifySealed(bool expected);
    [ConditionalAttribute("DEBUG")]
internal void VerifyDataStored(bool expected);
    [ConditionalAttribute("DEBUG")]
protected void SetDataStored();
    [ConditionalAttribute("DEBUG")]
internal static void Seal(WellKnownAttributeData data);
}
public static class Microsoft.CodeAnalysis.WellKnownDiagnosticTags : object {
    public static string Unnecessary;
    public static string EditAndContinue;
    public static string Build;
    public static string Compiler;
    public static string Telemetry;
    public static string NotConfigurable;
    public static string AnalyzerException;
}
internal enum Microsoft.CodeAnalysis.WellKnownMember : Enum {
    public int value__;
    public static WellKnownMember System_Math__RoundDouble;
    public static WellKnownMember System_Math__PowDoubleDouble;
    public static WellKnownMember System_Array__get_Length;
    public static WellKnownMember System_Array__Empty;
    public static WellKnownMember System_Convert__ToBooleanDecimal;
    public static WellKnownMember System_Convert__ToBooleanInt32;
    public static WellKnownMember System_Convert__ToBooleanUInt32;
    public static WellKnownMember System_Convert__ToBooleanInt64;
    public static WellKnownMember System_Convert__ToBooleanUInt64;
    public static WellKnownMember System_Convert__ToBooleanSingle;
    public static WellKnownMember System_Convert__ToBooleanDouble;
    public static WellKnownMember System_Convert__ToSByteDecimal;
    public static WellKnownMember System_Convert__ToSByteDouble;
    public static WellKnownMember System_Convert__ToSByteSingle;
    public static WellKnownMember System_Convert__ToByteDecimal;
    public static WellKnownMember System_Convert__ToByteDouble;
    public static WellKnownMember System_Convert__ToByteSingle;
    public static WellKnownMember System_Convert__ToInt16Decimal;
    public static WellKnownMember System_Convert__ToInt16Double;
    public static WellKnownMember System_Convert__ToInt16Single;
    public static WellKnownMember System_Convert__ToUInt16Decimal;
    public static WellKnownMember System_Convert__ToUInt16Double;
    public static WellKnownMember System_Convert__ToUInt16Single;
    public static WellKnownMember System_Convert__ToInt32Decimal;
    public static WellKnownMember System_Convert__ToInt32Double;
    public static WellKnownMember System_Convert__ToInt32Single;
    public static WellKnownMember System_Convert__ToUInt32Decimal;
    public static WellKnownMember System_Convert__ToUInt32Double;
    public static WellKnownMember System_Convert__ToUInt32Single;
    public static WellKnownMember System_Convert__ToInt64Decimal;
    public static WellKnownMember System_Convert__ToInt64Double;
    public static WellKnownMember System_Convert__ToInt64Single;
    public static WellKnownMember System_Convert__ToUInt64Decimal;
    public static WellKnownMember System_Convert__ToUInt64Double;
    public static WellKnownMember System_Convert__ToUInt64Single;
    public static WellKnownMember System_Convert__ToSingleDecimal;
    public static WellKnownMember System_Convert__ToDoubleDecimal;
    public static WellKnownMember System_CLSCompliantAttribute__ctor;
    public static WellKnownMember System_FlagsAttribute__ctor;
    public static WellKnownMember System_Guid__ctor;
    public static WellKnownMember System_Type__GetTypeFromCLSID;
    public static WellKnownMember System_Type__GetTypeFromHandle;
    public static WellKnownMember System_Type__Missing;
    public static WellKnownMember System_Reflection_AssemblyKeyFileAttribute__ctor;
    public static WellKnownMember System_Reflection_AssemblyKeyNameAttribute__ctor;
    public static WellKnownMember System_Reflection_MethodBase__GetMethodFromHandle;
    public static WellKnownMember System_Reflection_MethodBase__GetMethodFromHandle2;
    public static WellKnownMember System_Reflection_MethodInfo__CreateDelegate;
    public static WellKnownMember System_Delegate__CreateDelegate;
    public static WellKnownMember System_Delegate__CreateDelegate4;
    public static WellKnownMember System_Reflection_FieldInfo__GetFieldFromHandle;
    public static WellKnownMember System_Reflection_FieldInfo__GetFieldFromHandle2;
    public static WellKnownMember System_Reflection_Missing__Value;
    public static WellKnownMember System_IEquatable_T__Equals;
    public static WellKnownMember System_Collections_Generic_EqualityComparer_T__Equals;
    public static WellKnownMember System_Collections_Generic_EqualityComparer_T__GetHashCode;
    public static WellKnownMember System_Collections_Generic_EqualityComparer_T__get_Default;
    public static WellKnownMember System_AttributeUsageAttribute__ctor;
    public static WellKnownMember System_AttributeUsageAttribute__AllowMultiple;
    public static WellKnownMember System_AttributeUsageAttribute__Inherited;
    public static WellKnownMember System_ParamArrayAttribute__ctor;
    public static WellKnownMember System_STAThreadAttribute__ctor;
    public static WellKnownMember System_Reflection_DefaultMemberAttribute__ctor;
    public static WellKnownMember System_Diagnostics_Debugger__Break;
    public static WellKnownMember System_Diagnostics_DebuggerDisplayAttribute__ctor;
    public static WellKnownMember System_Diagnostics_DebuggerDisplayAttribute__Type;
    public static WellKnownMember System_Diagnostics_DebuggerNonUserCodeAttribute__ctor;
    public static WellKnownMember System_Diagnostics_DebuggerHiddenAttribute__ctor;
    public static WellKnownMember System_Diagnostics_DebuggerBrowsableAttribute__ctor;
    public static WellKnownMember System_Diagnostics_DebuggerStepThroughAttribute__ctor;
    public static WellKnownMember System_Diagnostics_DebuggableAttribute__ctorDebuggingModes;
    public static WellKnownMember System_Diagnostics_DebuggableAttribute_DebuggingModes__Default;
    public static WellKnownMember System_Diagnostics_DebuggableAttribute_DebuggingModes__DisableOptimizations;
    public static WellKnownMember System_Diagnostics_DebuggableAttribute_DebuggingModes__EnableEditAndContinue;
    public static WellKnownMember System_Diagnostics_DebuggableAttribute_DebuggingModes__IgnoreSymbolStoreSequencePoints;
    public static WellKnownMember System_Runtime_InteropServices_UnknownWrapper__ctor;
    public static WellKnownMember System_Runtime_InteropServices_DispatchWrapper__ctor;
    public static WellKnownMember System_Runtime_InteropServices_ClassInterfaceAttribute__ctorClassInterfaceType;
    public static WellKnownMember System_Runtime_InteropServices_CoClassAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_ComAwareEventInfo__ctor;
    public static WellKnownMember System_Runtime_InteropServices_ComAwareEventInfo__AddEventHandler;
    public static WellKnownMember System_Runtime_InteropServices_ComAwareEventInfo__RemoveEventHandler;
    public static WellKnownMember System_Runtime_InteropServices_ComEventInterfaceAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_ComSourceInterfacesAttribute__ctorString;
    public static WellKnownMember System_Runtime_InteropServices_ComVisibleAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_DispIdAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_GuidAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_InterfaceTypeAttribute__ctorComInterfaceType;
    public static WellKnownMember System_Runtime_InteropServices_InterfaceTypeAttribute__ctorInt16;
    public static WellKnownMember System_Runtime_InteropServices_Marshal__GetTypeFromCLSID;
    public static WellKnownMember System_Runtime_InteropServices_TypeIdentifierAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_TypeIdentifierAttribute__ctorStringString;
    public static WellKnownMember System_Runtime_InteropServices_BestFitMappingAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_DefaultParameterValueAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_LCIDConversionAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_UnmanagedFunctionPointerAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T__AddEventHandler;
    public static WellKnownMember System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T__GetOrCreateEventRegistrationTokenTable;
    public static WellKnownMember System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T__InvocationList;
    public static WellKnownMember System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T__RemoveEventHandler;
    public static WellKnownMember System_Runtime_InteropServices_WindowsRuntime_WindowsRuntimeMarshal__AddEventHandler_T;
    public static WellKnownMember System_Runtime_InteropServices_WindowsRuntime_WindowsRuntimeMarshal__RemoveAllEventHandlers;
    public static WellKnownMember System_Runtime_InteropServices_WindowsRuntime_WindowsRuntimeMarshal__RemoveEventHandler_T;
    public static WellKnownMember System_Runtime_CompilerServices_DateTimeConstantAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_DecimalConstantAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_DecimalConstantAttribute__ctorByteByteInt32Int32Int32;
    public static WellKnownMember System_Runtime_CompilerServices_ExtensionAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_CompilerGeneratedAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_AccessedThroughPropertyAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_CompilationRelaxationsAttribute__ctorInt32;
    public static WellKnownMember System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__WrapNonExceptionThrows;
    public static WellKnownMember System_Runtime_CompilerServices_UnsafeValueTypeAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_FixedBufferAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_DynamicAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_DynamicAttribute__ctorTransformFlags;
    public static WellKnownMember System_Runtime_CompilerServices_CallSite_T__Create;
    public static WellKnownMember System_Runtime_CompilerServices_CallSite_T__Target;
    public static WellKnownMember System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValueObject;
    public static WellKnownMember System_Runtime_CompilerServices_RuntimeHelpers__InitializeArrayArrayRuntimeFieldHandle;
    public static WellKnownMember System_Runtime_CompilerServices_RuntimeHelpers__get_OffsetToStringData;
    public static WellKnownMember System_Runtime_ExceptionServices_ExceptionDispatchInfo__Capture;
    public static WellKnownMember System_Runtime_ExceptionServices_ExceptionDispatchInfo__Throw;
    public static WellKnownMember System_Security_UnverifiableCodeAttribute__ctor;
    public static WellKnownMember System_Security_Permissions_SecurityAction__RequestMinimum;
    public static WellKnownMember System_Security_Permissions_SecurityPermissionAttribute__ctor;
    public static WellKnownMember System_Security_Permissions_SecurityPermissionAttribute__SkipVerification;
    public static WellKnownMember System_Activator__CreateInstance;
    public static WellKnownMember System_Activator__CreateInstance_T;
    public static WellKnownMember System_Threading_Interlocked__CompareExchange_T;
    public static WellKnownMember System_Threading_Monitor__Enter;
    public static WellKnownMember System_Threading_Monitor__Enter2;
    public static WellKnownMember System_Threading_Monitor__Exit;
    public static WellKnownMember System_Threading_Thread__CurrentThread;
    public static WellKnownMember System_Threading_Thread__ManagedThreadId;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__BinaryOperation;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__Convert;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__GetIndex;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__GetMember;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__Invoke;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__InvokeConstructor;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__InvokeMember;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__IsEvent;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__SetIndex;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__SetMember;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__UnaryOperation;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_CSharpArgumentInfo__Create;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToDecimalBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToBooleanString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToSByteString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToByteString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToShortString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToUShortString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToIntegerString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToUIntegerString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToLongString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToULongString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToSingleString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToDoubleString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToDecimalString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToDateString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToCharString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToCharArrayRankOneString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringInt32;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringByte;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringUInt32;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringInt64;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringUInt64;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringSingle;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringDouble;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringDecimal;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringDateTime;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringChar;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToBooleanObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToSByteObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToByteObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToShortObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToUShortObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToIntegerObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToUIntegerObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToLongObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToULongObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToSingleObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToDoubleObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToDecimalObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToDateObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToCharObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToCharArrayRankOneObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToGenericParameter_T_Object;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ChangeType;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__PlusObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__NegateObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__NotObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__AndObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__OrObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__XorObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__AddObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__SubtractObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__MultiplyObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__DivideObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__ExponentObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__ModObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__IntDivideObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__LeftShiftObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__RightShiftObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__ConcatenateObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__CompareObjectEqualObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__CompareObjectNotEqualObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__CompareObjectLessObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__CompareObjectLessEqualObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__CompareObjectGreaterEqualObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__CompareObjectGreaterObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__ConditionalCompareObjectEqualObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__ConditionalCompareObjectNotEqualObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__ConditionalCompareObjectLessObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__ConditionalCompareObjectLessEqualObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__ConditionalCompareObjectGreaterEqualObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__ConditionalCompareObjectGreaterObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__CompareStringStringStringBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_EmbeddedOperators__CompareStringStringStringBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_NewLateBinding__LateCall;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_NewLateBinding__LateGet;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_NewLateBinding__LateSet;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_NewLateBinding__LateSetComplex;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_NewLateBinding__LateIndexGet;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_NewLateBinding__LateIndexSet;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_NewLateBinding__LateIndexSetComplex;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_StandardModuleAttribute__ctor;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_StaticLocalInitFlag__ctor;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_StaticLocalInitFlag__State;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_StringType__MidStmtStr;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_IncompleteInitialization__ctor;
    public static WellKnownMember Microsoft_VisualBasic_Embedded__ctor;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Utils__CopyArray;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_LikeOperator__LikeStringStringStringCompareMethod;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_LikeOperator__LikeObjectObjectObjectCompareMethod;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_ProjectData__CreateProjectError;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_ProjectData__SetProjectError;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_ProjectData__SetProjectError_Int32;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_ProjectData__ClearProjectError;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_ProjectData__EndApp;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_ObjectFlowControl_ForLoopControl__ForLoopInitObj;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_ObjectFlowControl_ForLoopControl__ForNextCheckObj;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_ObjectFlowControl__CheckForSyncLockOnValueType;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Versioned__CallByName;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Versioned__IsNumeric;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Versioned__SystemTypeName;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Versioned__TypeName;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Versioned__VbTypeName;
    public static WellKnownMember Microsoft_VisualBasic_Information__IsNumeric;
    public static WellKnownMember Microsoft_VisualBasic_Information__SystemTypeName;
    public static WellKnownMember Microsoft_VisualBasic_Information__TypeName;
    public static WellKnownMember Microsoft_VisualBasic_Information__VbTypeName;
    public static WellKnownMember Microsoft_VisualBasic_Interaction__CallByName;
    public static WellKnownMember System_Runtime_CompilerServices_IAsyncStateMachine_MoveNext;
    public static WellKnownMember System_Runtime_CompilerServices_IAsyncStateMachine_SetStateMachine;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncVoidMethodBuilder__SetException;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncVoidMethodBuilder__SetResult;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncVoidMethodBuilder__AwaitOnCompleted;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncVoidMethodBuilder__AwaitUnsafeOnCompleted;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncVoidMethodBuilder__Start_T;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncVoidMethodBuilder__SetStateMachine;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder__SetException;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder__SetResult;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder__AwaitOnCompleted;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder__AwaitUnsafeOnCompleted;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder__Start_T;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder__SetStateMachine;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder__Task;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T__SetException;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T__SetResult;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T__AwaitOnCompleted;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T__AwaitUnsafeOnCompleted;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T__Start_T;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T__SetStateMachine;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T__Task;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncStateMachineAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_IteratorStateMachineAttribute__ctor;
    public static WellKnownMember Microsoft_VisualBasic_Strings__AscCharInt32;
    public static WellKnownMember Microsoft_VisualBasic_Strings__AscStringInt32;
    public static WellKnownMember Microsoft_VisualBasic_Strings__AscWCharInt32;
    public static WellKnownMember Microsoft_VisualBasic_Strings__AscWStringInt32;
    public static WellKnownMember Microsoft_VisualBasic_Strings__ChrInt32Char;
    public static WellKnownMember Microsoft_VisualBasic_Strings__ChrWInt32Char;
    public static WellKnownMember System_Xml_Linq_XElement__ctor;
    public static WellKnownMember System_Xml_Linq_XElement__ctor2;
    public static WellKnownMember System_Xml_Linq_XNamespace__Get;
    public static WellKnownMember System_Windows_Forms_Application__RunForm;
    public static WellKnownMember System_Environment__CurrentManagedThreadId;
    public static WellKnownMember System_ComponentModel_EditorBrowsableAttribute__ctor;
    public static WellKnownMember System_Runtime_GCLatencyMode__SustainedLowLatency;
    public static WellKnownMember System_String__Format_IFormatProvider;
    public static WellKnownMember Count;
}
public static class Microsoft.CodeAnalysis.WellKnownMemberNames : object {
    public static string EnumBackingFieldName;
    public static string InstanceConstructorName;
    public static string StaticConstructorName;
    public static string Indexer;
    public static string DestructorName;
    public static string DelegateInvokeName;
    public static string DelegateBeginInvokeName;
    public static string DelegateEndInvokeName;
    public static string EntryPointMethodName;
    public static string DefaultScriptClassName;
    public static string ObjectToString;
    public static string ObjectEquals;
    public static string ObjectGetHashCode;
    public static string ImplicitConversionName;
    public static string ExplicitConversionName;
    public static string AdditionOperatorName;
    public static string BitwiseAndOperatorName;
    public static string BitwiseOrOperatorName;
    public static string DecrementOperatorName;
    public static string DivisionOperatorName;
    public static string EqualityOperatorName;
    public static string ExclusiveOrOperatorName;
    public static string FalseOperatorName;
    public static string GreaterThanOperatorName;
    public static string GreaterThanOrEqualOperatorName;
    public static string IncrementOperatorName;
    public static string InequalityOperatorName;
    public static string LeftShiftOperatorName;
    public static string UnsignedLeftShiftOperatorName;
    public static string LessThanOperatorName;
    public static string LessThanOrEqualOperatorName;
    public static string LogicalNotOperatorName;
    public static string LogicalOrOperatorName;
    public static string LogicalAndOperatorName;
    public static string ModulusOperatorName;
    public static string MultiplyOperatorName;
    public static string OnesComplementOperatorName;
    public static string RightShiftOperatorName;
    public static string UnsignedRightShiftOperatorName;
    public static string SubtractionOperatorName;
    public static string TrueOperatorName;
    public static string UnaryNegationOperatorName;
    public static string UnaryPlusOperatorName;
    public static string ConcatenateOperatorName;
    public static string ExponentOperatorName;
    public static string IntegerDivisionOperatorName;
    public static string LikeOperatorName;
    public static string GetEnumeratorMethodName;
    public static string MoveNextMethodName;
    public static string CurrentPropertyName;
    public static string ValuePropertyName;
    public static string CollectionInitializerAddMethodName;
    public static string GetAwaiter;
    public static string IsCompleted;
    public static string GetResult;
    public static string OnCompleted;
}
internal static class Microsoft.CodeAnalysis.WellKnownMembers : object {
    private static ImmutableArray`1<MemberDescriptor> s_descriptors;
    private static WellKnownMembers();
    public static MemberDescriptor GetDescriptor(WellKnownMember member);
    internal static bool IsSynthesizedAttributeOptional(WellKnownMember attributeMember);
}
internal enum Microsoft.CodeAnalysis.WellKnownType : Enum {
    public int value__;
    public static WellKnownType Unknown;
    public static WellKnownType First;
    public static WellKnownType System_Math;
    public static WellKnownType System_Array;
    public static WellKnownType System_Attribute;
    public static WellKnownType System_CLSCompliantAttribute;
    public static WellKnownType System_Convert;
    public static WellKnownType System_Exception;
    public static WellKnownType System_FlagsAttribute;
    public static WellKnownType System_FormattableString;
    public static WellKnownType System_Guid;
    public static WellKnownType System_IFormattable;
    public static WellKnownType System_RuntimeTypeHandle;
    public static WellKnownType System_RuntimeFieldHandle;
    public static WellKnownType System_RuntimeMethodHandle;
    public static WellKnownType System_MarshalByRefObject;
    public static WellKnownType System_Type;
    public static WellKnownType System_Reflection_AssemblyKeyFileAttribute;
    public static WellKnownType System_Reflection_AssemblyKeyNameAttribute;
    public static WellKnownType System_Reflection_MethodInfo;
    public static WellKnownType System_Reflection_ConstructorInfo;
    public static WellKnownType System_Reflection_MethodBase;
    public static WellKnownType System_Reflection_FieldInfo;
    public static WellKnownType System_Reflection_MemberInfo;
    public static WellKnownType System_Reflection_Missing;
    public static WellKnownType System_Runtime_CompilerServices_FormattableStringFactory;
    public static WellKnownType System_Runtime_CompilerServices_RuntimeHelpers;
    public static WellKnownType System_Runtime_ExceptionServices_ExceptionDispatchInfo;
    public static WellKnownType System_Runtime_InteropServices_StructLayoutAttribute;
    public static WellKnownType System_Runtime_InteropServices_UnknownWrapper;
    public static WellKnownType System_Runtime_InteropServices_DispatchWrapper;
    public static WellKnownType System_Runtime_InteropServices_CallingConvention;
    public static WellKnownType System_Runtime_InteropServices_ClassInterfaceAttribute;
    public static WellKnownType System_Runtime_InteropServices_ClassInterfaceType;
    public static WellKnownType System_Runtime_InteropServices_CoClassAttribute;
    public static WellKnownType System_Runtime_InteropServices_ComAwareEventInfo;
    public static WellKnownType System_Runtime_InteropServices_ComEventInterfaceAttribute;
    public static WellKnownType System_Runtime_InteropServices_ComInterfaceType;
    public static WellKnownType System_Runtime_InteropServices_ComSourceInterfacesAttribute;
    public static WellKnownType System_Runtime_InteropServices_ComVisibleAttribute;
    public static WellKnownType System_Runtime_InteropServices_DispIdAttribute;
    public static WellKnownType System_Runtime_InteropServices_GuidAttribute;
    public static WellKnownType System_Runtime_InteropServices_InterfaceTypeAttribute;
    public static WellKnownType System_Runtime_InteropServices_Marshal;
    public static WellKnownType System_Runtime_InteropServices_TypeIdentifierAttribute;
    public static WellKnownType System_Runtime_InteropServices_BestFitMappingAttribute;
    public static WellKnownType System_Runtime_InteropServices_DefaultParameterValueAttribute;
    public static WellKnownType System_Runtime_InteropServices_LCIDConversionAttribute;
    public static WellKnownType System_Runtime_InteropServices_UnmanagedFunctionPointerAttribute;
    public static WellKnownType System_Activator;
    public static WellKnownType System_Threading_Tasks_Task;
    public static WellKnownType System_Threading_Tasks_Task_T;
    public static WellKnownType System_Threading_Interlocked;
    public static WellKnownType System_Threading_Monitor;
    public static WellKnownType System_Threading_Thread;
    public static WellKnownType Microsoft_CSharp_RuntimeBinder_Binder;
    public static WellKnownType Microsoft_CSharp_RuntimeBinder_CSharpArgumentInfo;
    public static WellKnownType Microsoft_CSharp_RuntimeBinder_CSharpArgumentInfoFlags;
    public static WellKnownType Microsoft_CSharp_RuntimeBinder_CSharpBinderFlags;
    public static WellKnownType Microsoft_VisualBasic_CallType;
    public static WellKnownType Microsoft_VisualBasic_Embedded;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_Conversions;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_Operators;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_NewLateBinding;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_EmbeddedOperators;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_StandardModuleAttribute;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_Utils;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_LikeOperator;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_ProjectData;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_ObjectFlowControl;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_ObjectFlowControl_ForLoopControl;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_StaticLocalInitFlag;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_StringType;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_IncompleteInitialization;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_Versioned;
    public static WellKnownType Microsoft_VisualBasic_CompareMethod;
    public static WellKnownType Microsoft_VisualBasic_Strings;
    public static WellKnownType Microsoft_VisualBasic_ErrObject;
    public static WellKnownType Microsoft_VisualBasic_FileSystem;
    public static WellKnownType Microsoft_VisualBasic_ApplicationServices_ApplicationBase;
    public static WellKnownType Microsoft_VisualBasic_ApplicationServices_WindowsFormsApplicationBase;
    public static WellKnownType Microsoft_VisualBasic_Information;
    public static WellKnownType Microsoft_VisualBasic_Interaction;
    public static WellKnownType System_Func_T;
    public static WellKnownType System_Func_T2;
    public static WellKnownType System_Func_T3;
    public static WellKnownType System_Func_T4;
    public static WellKnownType System_Func_T5;
    public static WellKnownType System_Func_T6;
    public static WellKnownType System_Func_T7;
    public static WellKnownType System_Func_T8;
    public static WellKnownType System_Func_T9;
    public static WellKnownType System_Func_T10;
    public static WellKnownType System_Func_T11;
    public static WellKnownType System_Func_T12;
    public static WellKnownType System_Func_T13;
    public static WellKnownType System_Func_T14;
    public static WellKnownType System_Func_T15;
    public static WellKnownType System_Func_T16;
    public static WellKnownType System_Func_T17;
    public static WellKnownType System_Func_TMax;
    public static WellKnownType System_Action;
    public static WellKnownType System_Action_T;
    public static WellKnownType System_Action_T2;
    public static WellKnownType System_Action_T3;
    public static WellKnownType System_Action_T4;
    public static WellKnownType System_Action_T5;
    public static WellKnownType System_Action_T6;
    public static WellKnownType System_Action_T7;
    public static WellKnownType System_Action_T8;
    public static WellKnownType System_Action_T9;
    public static WellKnownType System_Action_T10;
    public static WellKnownType System_Action_T11;
    public static WellKnownType System_Action_T12;
    public static WellKnownType System_Action_T13;
    public static WellKnownType System_Action_T14;
    public static WellKnownType System_Action_T15;
    public static WellKnownType System_Action_T16;
    public static WellKnownType System_Action_TMax;
    public static WellKnownType System_AttributeUsageAttribute;
    public static WellKnownType System_ParamArrayAttribute;
    public static WellKnownType System_NonSerializedAttribute;
    public static WellKnownType System_STAThreadAttribute;
    public static WellKnownType System_Reflection_DefaultMemberAttribute;
    public static WellKnownType System_Runtime_CompilerServices_DateTimeConstantAttribute;
    public static WellKnownType System_Runtime_CompilerServices_DecimalConstantAttribute;
    public static WellKnownType System_Runtime_CompilerServices_IUnknownConstantAttribute;
    public static WellKnownType System_Runtime_CompilerServices_IDispatchConstantAttribute;
    public static WellKnownType System_Runtime_CompilerServices_ExtensionAttribute;
    public static WellKnownType System_Runtime_CompilerServices_INotifyCompletion;
    public static WellKnownType System_Runtime_CompilerServices_InternalsVisibleToAttribute;
    public static WellKnownType System_Runtime_CompilerServices_CompilerGeneratedAttribute;
    public static WellKnownType System_Runtime_CompilerServices_AccessedThroughPropertyAttribute;
    public static WellKnownType System_Runtime_CompilerServices_CompilationRelaxationsAttribute;
    public static WellKnownType System_Runtime_CompilerServices_RuntimeCompatibilityAttribute;
    public static WellKnownType System_Runtime_CompilerServices_UnsafeValueTypeAttribute;
    public static WellKnownType System_Runtime_CompilerServices_FixedBufferAttribute;
    public static WellKnownType System_Runtime_CompilerServices_DynamicAttribute;
    public static WellKnownType System_Runtime_CompilerServices_CallSiteBinder;
    public static WellKnownType System_Runtime_CompilerServices_CallSite;
    public static WellKnownType System_Runtime_CompilerServices_CallSite_T;
    public static WellKnownType System_Runtime_InteropServices_WindowsRuntime_EventRegistrationToken;
    public static WellKnownType System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T;
    public static WellKnownType System_Runtime_InteropServices_WindowsRuntime_WindowsRuntimeMarshal;
    public static WellKnownType Windows_Foundation_IAsyncAction;
    public static WellKnownType Windows_Foundation_IAsyncActionWithProgress_T;
    public static WellKnownType Windows_Foundation_IAsyncOperation_T;
    public static WellKnownType Windows_Foundation_IAsyncOperationWithProgress_T2;
    public static WellKnownType System_Diagnostics_Debugger;
    public static WellKnownType System_Diagnostics_DebuggerDisplayAttribute;
    public static WellKnownType System_Diagnostics_DebuggerNonUserCodeAttribute;
    public static WellKnownType System_Diagnostics_DebuggerHiddenAttribute;
    public static WellKnownType System_Diagnostics_DebuggerBrowsableAttribute;
    public static WellKnownType System_Diagnostics_DebuggerStepThroughAttribute;
    public static WellKnownType System_Diagnostics_DebuggerBrowsableState;
    public static WellKnownType System_Diagnostics_DebuggableAttribute;
    public static WellKnownType System_Diagnostics_DebuggableAttribute__DebuggingModes;
    public static WellKnownType System_ComponentModel_DesignerSerializationVisibilityAttribute;
    public static WellKnownType System_IEquatable_T;
    public static WellKnownType System_Collections_IList;
    public static WellKnownType System_Collections_ICollection;
    public static WellKnownType System_Collections_Generic_EqualityComparer_T;
    public static WellKnownType System_Collections_Generic_List_T;
    public static WellKnownType System_Collections_Generic_IDictionary_KV;
    public static WellKnownType System_Collections_Generic_IReadOnlyDictionary_KV;
    public static WellKnownType System_Collections_ObjectModel_Collection_T;
    public static WellKnownType System_Collections_ObjectModel_ReadOnlyCollection_T;
    public static WellKnownType System_Collections_Specialized_INotifyCollectionChanged;
    public static WellKnownType System_ComponentModel_INotifyPropertyChanged;
    public static WellKnownType System_ComponentModel_EditorBrowsableAttribute;
    public static WellKnownType System_ComponentModel_EditorBrowsableState;
    public static WellKnownType System_Linq_Enumerable;
    public static WellKnownType System_Linq_Expressions_Expression;
    public static WellKnownType System_Linq_Expressions_Expression_T;
    public static WellKnownType System_Linq_Expressions_ParameterExpression;
    public static WellKnownType System_Linq_Expressions_ElementInit;
    public static WellKnownType System_Linq_Expressions_MemberBinding;
    public static WellKnownType System_Linq_Expressions_ExpressionType;
    public static WellKnownType System_Linq_IQueryable;
    public static WellKnownType System_Linq_IQueryable_T;
    public static WellKnownType System_Xml_Linq_Extensions;
    public static WellKnownType System_Xml_Linq_XAttribute;
    public static WellKnownType System_Xml_Linq_XCData;
    public static WellKnownType System_Xml_Linq_XComment;
    public static WellKnownType System_Xml_Linq_XContainer;
    public static WellKnownType System_Xml_Linq_XDeclaration;
    public static WellKnownType System_Xml_Linq_XDocument;
    public static WellKnownType System_Xml_Linq_XElement;
    public static WellKnownType System_Xml_Linq_XName;
    public static WellKnownType System_Xml_Linq_XNamespace;
    public static WellKnownType System_Xml_Linq_XObject;
    public static WellKnownType System_Xml_Linq_XProcessingInstruction;
    public static WellKnownType System_Security_UnverifiableCodeAttribute;
    public static WellKnownType System_Security_Permissions_SecurityAction;
    public static WellKnownType System_Security_Permissions_SecurityAttribute;
    public static WellKnownType System_Security_Permissions_SecurityPermissionAttribute;
    public static WellKnownType System_NotSupportedException;
    public static WellKnownType System_Runtime_CompilerServices_ICriticalNotifyCompletion;
    public static WellKnownType System_Runtime_CompilerServices_IAsyncStateMachine;
    public static WellKnownType System_Runtime_CompilerServices_AsyncVoidMethodBuilder;
    public static WellKnownType System_Runtime_CompilerServices_AsyncTaskMethodBuilder;
    public static WellKnownType System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T;
    public static WellKnownType System_Runtime_CompilerServices_AsyncStateMachineAttribute;
    public static WellKnownType System_Runtime_CompilerServices_IteratorStateMachineAttribute;
    public static WellKnownType System_Windows_Forms_Form;
    public static WellKnownType System_Windows_Forms_Application;
    public static WellKnownType System_Environment;
    public static WellKnownType System_Runtime_GCLatencyMode;
    public static WellKnownType System_IFormatProvider;
    public static WellKnownType Available;
    public static WellKnownType Last;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.WellKnownTypes : object {
    internal static int Count;
    private static String[] s_metadataNames;
    private static Dictionary`2<string, WellKnownType> s_nameToTypeIdMap;
    private static WellKnownTypes();
    [ConditionalAttribute("DEBUG")]
private static void AssertEnumAndTableInSync();
    [ExtensionAttribute]
public static string GetMetadataName(WellKnownType id);
    public static WellKnownType GetTypeFromMetadataName(string metadataName);
    internal static WellKnownType GetWellKnownFunctionDelegate(int invokeArgumentCount);
    internal static WellKnownType GetWellKnownActionDelegate(int invokeArgumentCount);
}
internal static class Microsoft.CodeAnalysis.Win32ResourceConversions : object {
    internal static void AppendIconToResourceStream(Stream resStream, Stream iconStream);
    internal static void AppendVersionToResourceStream(Stream resStream, bool isDll, string fileVersion, string originalFileName, string internalName, string productVersion, Version assemblyVersion, string fileDescription, string legalCopyright, string legalTrademarks, string productName, string comments, string companyName);
    internal static void AppendManifestToResourceStream(Stream resStream, Stream manifestStream, bool isDll);
}
internal static class Microsoft.CodeAnalysis.XmlCharType : object {
    internal static int SurHighStart;
    internal static int SurHighEnd;
    internal static int SurLowStart;
    internal static int SurLowEnd;
    internal static int SurMask;
    internal static int fWhitespace;
    internal static int fLetter;
    internal static int fNCStartNameSC;
    internal static int fNCNameSC;
    internal static int fCharData;
    internal static int fNCNameXml4e;
    internal static int fText;
    internal static int fAttrValue;
    private static string s_PublicIdBitmap;
    private static UInt32 CharPropertiesSize;
    private static int innerSizeBits;
    private static int innerSize;
    private static int innerSizeMask;
    private static Byte[] s_charPropertiesIndex;
    private static Byte[] s_charProperties;
    private static XmlCharType();
    private static byte charProperties(char i);
    public static bool IsWhiteSpace(char ch);
    public static bool IsExtender(char ch);
    public static bool IsNCNameSingleChar(char ch);
    public static bool IsStartNCNameSingleChar(char ch);
    public static bool IsNameSingleChar(char ch);
    public static bool IsStartNameSingleChar(char ch);
    public static bool IsCharData(char ch);
    public static bool IsPubidChar(char ch);
    internal static bool IsTextChar(char ch);
    internal static bool IsAttributeValueChar(char ch);
    public static bool IsLetter(char ch);
    public static bool IsNCNameCharXml4e(char ch);
    public static bool IsStartNCNameCharXml4e(char ch);
    public static bool IsNameCharXml4e(char ch);
    public static bool IsStartNameCharXml4e(char ch);
    public static bool IsDigit(char ch);
    public static bool IsHexDigit(char ch);
    internal static bool IsHighSurrogate(int ch);
    internal static bool IsLowSurrogate(int ch);
    internal static bool IsSurrogate(int ch);
    internal static int CombineSurrogateChar(int lowChar, int highChar);
    internal static void SplitSurrogateChar(int combinedChar, Char& lowChar, Char& highChar);
    internal static bool IsOnlyWhitespace(string str);
    internal static int IsOnlyWhitespaceWithPos(string str);
    internal static int IsOnlyCharData(string str);
    internal static bool IsOnlyDigits(string str, int startPos, int len);
    internal static bool IsOnlyDigits(Char[] chars, int startPos, int len);
    internal static int IsPublicId(string str);
    private static bool InRange(int value, int start, int end);
    internal static bool InRange(char value, char start, char end);
}
internal class Microsoft.CodeAnalysis.XmlDocumentationCommentTextReader : object {
    private XmlReader _reader;
    private Reader _textReader;
    private static ObjectPool`1<XmlDocumentationCommentTextReader> s_pool;
    private static XmlReaderSettings s_xmlSettings;
    private static XmlDocumentationCommentTextReader();
    public static XmlException ParseAndGetException(string text);
    internal XmlException ParseInternal(string text);
}
public class Microsoft.CodeAnalysis.XmlFileResolver : XmlReferenceResolver {
    [CompilerGeneratedAttribute]
private static XmlFileResolver <Default>k__BackingField;
    private string _baseDirectory;
    public static XmlFileResolver Default { get; }
    public string BaseDirectory { get; }
    public XmlFileResolver(string baseDirectory);
    private static XmlFileResolver();
    [CompilerGeneratedAttribute]
public static XmlFileResolver get_Default();
    public string get_BaseDirectory();
    public virtual string ResolveReference(string path, string baseFilePath);
    public virtual Stream OpenRead(string resolvedPath);
    protected virtual bool FileExists(string resolvedPath);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.XmlLocation : Location {
    private FileLinePositionSpan _positionSpan;
    public LocationKind Kind { get; }
    private XmlLocation(string path, int lineNumber, int columnNumber);
    public static XmlLocation Create(XmlException exception, string path);
    public static XmlLocation Create(XObject obj, string path);
    public virtual LocationKind get_Kind();
    public virtual FileLinePositionSpan GetLineSpan();
    public sealed virtual bool Equals(XmlLocation other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class Microsoft.CodeAnalysis.XmlReferenceResolver : object {
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual string ResolveReference(string path, string baseFilePath);
    public abstract virtual Stream OpenRead(string resolvedPath);
    internal Stream OpenReadChecked(string fullPath);
}
[ComVisibleAttribute("False")]
[GuidAttribute("C1F63D0C-4CAE-4907-BE74-EEB75D386ECB")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.VisualStudio.Shell.Interop.IVsSqm {
    public abstract virtual void GetSessionStartTime(FILETIME& time);
    public abstract virtual void GetFlags(UInt32& flags);
    public abstract virtual void SetFlags(UInt32 flags);
    public abstract virtual void ClearFlags(UInt32 flags);
    public abstract virtual void AddItemToStream(UInt32 dataPointID, UInt32 value);
    public abstract virtual void SetDatapoint(UInt32 dataPointID, UInt32 value);
    public abstract virtual void GetDatapoint(UInt32 dataPointID, UInt32& value);
    public abstract virtual void EnterTaggedAssert(UInt32 dwTag, UInt32 dwPossibleBuild, UInt32 dwActualBuild);
    public abstract virtual void RecordCmdData(Guid& pguidCmdGroup, UInt32 dataPointID, UInt32 value);
    public abstract virtual void GetHashOfGuid(Guid& hashGuid, UInt32& resultantHash);
    public abstract virtual void GetHashOfString(string hashString, UInt32& resultantHash);
    public abstract virtual void IncrementDatapoint(UInt32 dataPointID, UInt32 value);
    public abstract virtual void SetDatapointBits(UInt32 dataPointID, UInt32 value);
    public abstract virtual void SetDatapointIfMax(UInt32 dataPointID, UInt32 value);
    public abstract virtual void SetDatapointIfMin(UInt32 dataPointID, UInt32 value);
    public abstract virtual void AddToDatapointAverage(UInt32 dataPointID, UInt32 value);
    public abstract virtual void StartDatapointTimer(UInt32 dataPointID);
    public abstract virtual void RecordDatapointTimer(UInt32 dataPointID);
    public abstract virtual void AccumulateDatapointTimer(UInt32 dataPointID);
    public abstract virtual void AddTimerToDatapointAverage(UInt32 dataPointID);
    public abstract virtual void AddArrayToStream(UInt32 dataPointID, UInt32[] data, int count);
}
[ComVisibleAttribute("False")]
[GuidAttribute("BE5F55EB-F02D-4217-BCB6-A290800AF6C4")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.VisualStudio.Shell.Interop.IVsSqm2 {
    public abstract virtual void SetBoolDatapoint(UInt32 dataPointID, UInt32 fValue);
    public abstract virtual void SetStringDatapoint(UInt32 dataPointID, string strValue);
    public abstract virtual void AddToStreamDWord(UInt32 dataPointID, UInt32 cTuple, UInt32 value);
    public abstract virtual void AddToStreamString(UInt32 dataPointID, UInt32 cTuple, string strValue);
    public abstract virtual void GetObfuscatedString(string input, String& output);
}
[ComVisibleAttribute("False")]
[GuidAttribute("B17A7D4A-C1A3-45A2-B916-826C3ABA067E")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.VisualStudio.Shell.Interop.IVsSqmMulti {
    public abstract virtual bool GetOptInStatus();
    public abstract virtual void UnloadSessions();
    public abstract virtual void EndAllSessionsAndAbortUploads();
    public abstract virtual void BeginSession(UInt32 sessionType, bool alwaysSend, UInt32& sessionHandle);
    public abstract virtual void EndSession(UInt32 sessionHandle);
    public abstract virtual void RegisterSessionHandle(Guid& sessionIdentifier, UInt32 dwSessionHandle);
    public abstract virtual int GetSessionHandleByIdentifier(Guid& sessionIdentifier);
    public abstract virtual void GetSessionStartTime(UInt32 sessionHandle, FILETIME& time);
    public abstract virtual Guid GetGlobalSessionGuid();
    public abstract virtual int GetGlobalSessionHandle();
    public abstract virtual void SetGlobalSessionGuid(Guid& pguidSessionGuid);
    public abstract virtual void GetFlags(UInt32 sessionHandle, UInt32& flags);
    public abstract virtual void SetFlags(UInt32 sessionHandle, UInt32 flags);
    public abstract virtual void ClearFlags(UInt32 sessionHandle, UInt32 flags);
    public abstract virtual void SetDatapoint(UInt32 sessionHandle, UInt32 dataPointID, UInt32 value);
    public abstract virtual void SetBoolDatapoint(UInt32 sessionHandle, UInt32 dataPointID, UInt32 fValue);
    public abstract virtual void SetStringDatapoint(UInt32 sessionHandle, UInt32 dataPointID, string strValue);
    public abstract virtual void SetDatapointBits(UInt32 sessionHandle, UInt32 dataPointID, UInt32 value);
    public abstract virtual void IncrementDatapoint(UInt32 sessionHandle, UInt32 dataPointID, UInt32 value);
    public abstract virtual void SetDatapointIfMax(UInt32 sessionHandle, UInt32 dataPointID, UInt32 value);
    public abstract virtual void SetDatapointIfMin(UInt32 sessionHandle, UInt32 dataPointID, UInt32 value);
    public abstract virtual void AddToDatapointAverage(UInt32 sessionHandle, UInt32 dataPointID, UInt32 value);
    public abstract virtual void StartDatapointTimer(UInt32 sessionHandle, UInt32 dataPointID);
    public abstract virtual void RecordDatapointTimer(UInt32 sessionHandle, UInt32 dataPointID);
    public abstract virtual void AccumulateDatapointTimer(UInt32 sessionHandle, UInt32 dataPointID);
    public abstract virtual void AddTimerToDatapointAverage(UInt32 sessionHandle, UInt32 dataPointID);
    public abstract virtual void AddItemToStream(UInt32 sessionHandle, UInt32 dataPointID, UInt32 value);
    public abstract virtual void AddArrayToStream(UInt32 sessionHandle, UInt32 dataPointID, UInt32[] data, int count);
    public abstract virtual void AddToStreamDWord(UInt32 sessionHandle, UInt32 dataPointID, UInt32 cTuple, UInt32 value);
    public abstract virtual void AddToStreamString(UInt32 sessionHandle, UInt32 dataPointID, UInt32 cTuple, string strValue);
    public abstract virtual void RecordCmdData(UInt32 sessionHandle, Guid& pguidCmdGroup, UInt32 dataPointID, UInt32 value);
    public abstract virtual void GetHashOfGuid(Guid& hashGuid, UInt32& resultantHash);
    public abstract virtual void GetHashOfString(string hashString, UInt32& resultantHash);
    public abstract virtual void SetProperty(UInt32 propid, Guid& varKey, object varValue);
    public abstract virtual void Get64BitHashOfString(string hashString, UInt64& resultantHash);
}
[ComVisibleAttribute("False")]
[GuidAttribute("16be4288-950b-4265-b0dc-280b89ca9979")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.VisualStudio.Shell.Interop.IVsSqmOptinManager {
    public abstract virtual void GetOptinStatus(UInt32& optinStatus, UInt32& preferences);
    public abstract virtual void SetOptinStatus(UInt32 optinStatus);
}
internal static class Microsoft.VisualStudio.Shell.Interop.SqmServiceProvider : object {
    public static UInt32 CSHARP_APPID;
    public static UInt32 BASIC_APPID;
    public static UInt32 DATAID_SQM_ROSLYN_COMPILERTYPE;
    public static UInt32 DATAID_SQM_BUILDVERSION;
    public static UInt32 DATAID_SQM_ROSLYN_SOURCES;
    public static UInt32 DATAID_SQM_ROSLYN_REFERENCES;
    public static UInt32 DATAID_SQM_ROSLYN_ERRORNUMBERS;
    public static UInt32 DATAID_SQM_ROSLYN_WARNINGNUMBERS;
    public static UInt32 DATAID_SQM_ROSLYN_WARNINGLEVEL;
    public static UInt32 DATAID_SQM_ROSLYN_WARNINGASERRORS;
    public static UInt32 DATAID_SQM_ROSLYN_SUPPRESSWARNINGNUMBERS;
    public static UInt32 DATAID_SQM_ROSLYN_WARNASERRORS_NUMBERS;
    public static UInt32 DATAID_SQM_ROSLYN_WARNASWARNINGS_NUMBERS;
    public static UInt32 DATAID_SQM_ROSLYN_OUTPUTKIND;
    public static UInt32 DATAID_SQM_ROSLYN_LANGUAGEVERSION;
    public static UInt32 DATAID_SQM_ROSLYN_EMBEDVBCORE;
    private static Optional`1<QueryServiceDelegate> s_queryService;
    private static object s_guard;
    private static SqmServiceProvider();
    private static IntPtr GetProcAddress(IntPtr moduleHandle, string procName);
    private static IntPtr LoadLibrary(string libPath);
    private static QueryServiceDelegate TryGetSqmServiceDelegateCore(string baseDirectory);
    private static QueryServiceDelegate TryGetSqmServiceDelegate(string baseDirectory);
    public static IVsSqmMulti TryGetSqmService(string baseDirectory);
}
[ComVisibleAttribute("False")]
[GuidAttribute("2508FDF0-EF80-4366-878E-C9F024B8D981")]
internal interface Microsoft.VisualStudio.Shell.Interop.SVsLog {
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ArrayExtensions : object {
    [ExtensionAttribute]
internal static T[] Copy(T[] array, int start, int length);
    [ExtensionAttribute]
internal static bool ValueEquals(UInt32[] array, UInt32[] other);
    [ExtensionAttribute]
internal static T[] InsertAt(T[] array, int position, T item);
    [ExtensionAttribute]
internal static T[] Append(T[] array, T item);
    [ExtensionAttribute]
internal static T[] InsertAt(T[] array, int position, T[] items);
    [ExtensionAttribute]
internal static T[] Append(T[] array, T[] items);
    [ExtensionAttribute]
internal static T[] RemoveAt(T[] array, int position);
    [ExtensionAttribute]
internal static T[] RemoveAt(T[] array, int position, int length);
    [ExtensionAttribute]
internal static T[] ReplaceAt(T[] array, int position, T item);
    [ExtensionAttribute]
internal static T[] ReplaceAt(T[] array, int position, int length, T[] items);
    [ExtensionAttribute]
internal static void ReverseContents(T[] array);
    [ExtensionAttribute]
internal static void ReverseContents(T[] array, int start, int count);
    [ExtensionAttribute]
internal static int BinarySearch(Int32[] array, int value);
    [ExtensionAttribute]
internal static int BinarySearchUpperBound(Int32[] array, int value);
}
internal static class Roslyn.Utilities.AssemblyUtilities : object {
    public static ImmutableArray`1<string> FindAssemblySet(string filePath);
    public static Guid ReadMvid(string filePath);
    public static ImmutableArray`1<string> FindSatelliteAssemblies(string filePath);
    public static ImmutableArray`1<AssemblyIdentity> IdentifyMissingDependencies(string assemblyPath, IEnumerable`1<string> dependencyFilePaths);
    public static AssemblyIdentity GetAssemblyIdentity(string assemblyPath);
}
internal static class Roslyn.Utilities.BitArithmeticUtilities : object {
    public static int CountBits(int v);
    public static int CountBits(UInt32 v);
    public static int CountBits(long v);
    public static int CountBits(ulong v);
    internal static UInt32 Align(UInt32 position, UInt32 alignment);
    internal static int Align(int position, int alignment);
}
internal class Roslyn.Utilities.ComMemoryStream : object {
    private static int ChunkSize;
    private List`1<Byte[]> _chunks;
    private int _position;
    private int _length;
    public void CopyTo(Stream stream);
    private static void ZeroMemory(IntPtr dest, int count);
    private sealed virtual override void Roslyn.Utilities.IUnsafeComStream.Read(IntPtr pv, int cb, IntPtr pcbRead);
    private int SetPosition(int newPos);
    private sealed virtual override void Roslyn.Utilities.IUnsafeComStream.Seek(long dlibMove, int origin, IntPtr plibNewPosition);
    private sealed virtual override void Roslyn.Utilities.IUnsafeComStream.SetSize(long libNewSize);
    private sealed virtual override void Roslyn.Utilities.IUnsafeComStream.Stat(STATSTG& pstatstg, int grfStatFlag);
    private sealed virtual override void Roslyn.Utilities.IUnsafeComStream.Write(IntPtr pv, int cb, IntPtr pcbWritten);
    private sealed virtual override void Roslyn.Utilities.IUnsafeComStream.Commit(int grfCommitFlags);
    private sealed virtual override void Roslyn.Utilities.IUnsafeComStream.Clone(IStream& ppstm);
    private sealed virtual override void Roslyn.Utilities.IUnsafeComStream.CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    private sealed virtual override void Roslyn.Utilities.IUnsafeComStream.LockRegion(long libOffset, long cb, int lockType);
    private sealed virtual override void Roslyn.Utilities.IUnsafeComStream.Revert();
    private sealed virtual override void Roslyn.Utilities.IUnsafeComStream.UnlockRegion(long libOffset, long cb, int lockType);
}
internal static class Roslyn.Utilities.CompilerPathUtilities : object {
    internal static void RequireAbsolutePath(string path, string argumentName);
}
internal class Roslyn.Utilities.ComStreamWrapper : object {
    private Stream _stream;
    public ComStreamWrapper(Stream stream);
    public sealed virtual void Commit(int grfCommitFlags);
    public sealed virtual void Read(Byte[] pv, int cb, IntPtr pcbRead);
    public sealed virtual void Seek(long dlibMove, int origin, IntPtr plibNewPosition);
    public sealed virtual void SetSize(long libNewSize);
    public sealed virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    public sealed virtual void Write(Byte[] pv, int cb, IntPtr pcbWritten);
    public sealed virtual void Clone(IStream& ppstm);
    public sealed virtual void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    public sealed virtual void LockRegion(long libOffset, long cb, int lockType);
    public sealed virtual void Revert();
    public sealed virtual void UnlockRegion(long libOffset, long cb, int lockType);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ConcurrentDictionaryExtensions : object {
    [ExtensionAttribute]
public static void Add(ConcurrentDictionary`2<K, V> dict, K key, V value);
}
internal class Roslyn.Utilities.ConcurrentRecordingObjectBinder : RecordingObjectBinder {
    private ConcurrentDictionary`2<TypeKey, Type> _typeMap;
    private ConcurrentDictionary`2<Type, Func`2<ObjectReader, object>> _readerMap;
    public virtual Type GetType(string assemblyName, string typeName);
    public virtual Func`2<ObjectReader, object> GetReader(Type type);
    private bool HasConstructor(Type type);
    public virtual void Record(Type type);
    public virtual void Record(object instance);
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Roslyn.Utilities.ConcurrentSet`1 : object {
    private static int DefaultConcurrencyLevel;
    private static int DefaultCapacity;
    private ConcurrentDictionary`2<T, byte> _dictionary;
    public int Count { get; }
    public bool IsEmpty { get; }
    public ConcurrentSet`1(IEqualityComparer`1<T> equalityComparer);
    public int get_Count();
    public bool get_IsEmpty();
    public bool Contains(T value);
    public bool Add(T value);
    public bool Remove(T value);
    public void Clear();
    public KeyEnumerator<T> GetEnumerator();
    [IteratorStateMachineAttribute("Roslyn.Utilities.ConcurrentSet`1/<GetEnumeratorImpl>d__15")]
private IEnumerator`1<T> GetEnumeratorImpl();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Roslyn.Utilities.ConsList`1 : object {
    public static ConsList`1<T> Empty;
    private T _head;
    private ConsList`1<T> _tail;
    [DebuggerBrowsableAttribute("0")]
public T Head { get; }
    [DebuggerBrowsableAttribute("0")]
public ConsList`1<T> Tail { get; }
    public ConsList`1(T head, ConsList`1<T> tail);
    private static ConsList`1();
    public T get_Head();
    public ConsList`1<T> get_Tail();
    public bool Any();
    public ConsList`1<T> Push(T value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public Enumerator<T> GetEnumerator();
    public virtual string ToString();
}
internal static class Roslyn.Utilities.CorLightup : object {
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.DecimalUtilities : object {
    [ExtensionAttribute]
public static int GetScale(decimal value);
    [ExtensionAttribute]
public static void GetBits(decimal value, Boolean& isNegative, Byte& scale, UInt32& low, UInt32& mid, UInt32& high);
}
internal static class Roslyn.Utilities.DocumentationCommentXmlNames : object {
    public static string CElementName;
    public static string CodeElementName;
    public static string CompletionListElementName;
    public static string ExampleElementName;
    public static string ExceptionElementName;
    public static string IncludeElementName;
    public static string ListElementName;
    public static string ParaElementName;
    public static string ParameterElementName;
    public static string ParameterReferenceElementName;
    public static string PermissionElementName;
    public static string RemarksElementName;
    public static string ReturnsElementName;
    public static string SeeElementName;
    public static string SeeAlsoElementName;
    public static string SummaryElementName;
    public static string TypeParameterElementName;
    public static string TypeParameterReferenceElementName;
    public static string ValueElementName;
    public static string CrefAttributeName;
    public static string NameAttributeName;
    public static string FileAttributeName;
    public static string PathAttributeName;
    public static string TypeAttributeName;
    public static bool ElementEquals(string name1, string name2, bool fromVb);
    public static bool AttributeEquals(string name1, string name2);
    public static bool Equals(object left, object right);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.EnumerableExtensions : object {
    private static Func`2<object, bool> s_notNullTest;
    private static EnumerableExtensions();
    [ExtensionAttribute]
public static IEnumerable`1<T> Do(IEnumerable`1<T> source, Action`1<T> action);
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> ToReadOnlyCollection(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> source, T value);
    [IteratorStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<ConcatWorker>d__4`1")]
[ExtensionAttribute]
private static IEnumerable`1<T> ConcatWorker(IEnumerable`1<T> source, T value);
    [ExtensionAttribute]
public static bool SetEquals(IEnumerable`1<T> source1, IEnumerable`1<T> source2, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool SetEquals(IEnumerable`1<T> source1, IEnumerable`1<T> source2);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> source, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static Nullable`1<T> FirstOrNullable(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static Nullable`1<T> FirstOrNullable(IEnumerable`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static Nullable`1<T> LastOrNullable(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool IsSingle(IEnumerable`1<T> list);
    [ExtensionAttribute]
public static bool IsEmpty(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(IReadOnlyCollection`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(ICollection`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(string source);
    [ExtensionAttribute]
public static bool IsEmpty(T[] source);
    [ExtensionAttribute]
public static bool IsEmpty(List`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool All(IEnumerable`1<bool> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> Flatten(IEnumerable`1<IEnumerable`1<T>> sequence);
    [ExtensionAttribute]
public static IEnumerable`1<T> OrderBy(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> OrderBy(IEnumerable`1<T> source, Comparison`1<T> compare);
    [ExtensionAttribute]
public static IEnumerable`1<T> Order(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool IsSorted(IEnumerable`1<T> enumerable, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<T> first, IEnumerable`1<T> second, Func`3<T, T, bool> comparer);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<T> sequence, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<string> sequence, string s);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Roslyn.Utilities.EnumField : ValueType {
    public static IComparer`1<EnumField> Comparer;
    public string Name;
    public ulong Value;
    public object IdentityOpt;
    public bool IsDefault { get; }
    public EnumField(string name, ulong value, object identityOpt);
    private static EnumField();
    public bool get_IsDefault();
    private string GetDebuggerDisplay();
    internal static EnumField FindValue(ArrayBuilder`1<EnumField> sortedFields, ulong value);
}
internal static class Roslyn.Utilities.EnumUtilities : object {
    internal static ulong ConvertEnumUnderlyingTypeToUInt64(object value, SpecialType specialType);
}
internal static class Roslyn.Utilities.ExceptionUtilities : object {
    internal static Exception Unreachable { get; }
    internal static Exception UnexpectedValue(object o);
    internal static Exception get_Unreachable();
}
internal class Roslyn.Utilities.FileKey : ValueType {
    public string FullPath;
    public DateTime Timestamp;
    public FileKey(string fullPath, DateTime timestamp);
    public static FileKey Create(string fullPath);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public sealed virtual bool Equals(FileKey other);
}
internal static class Roslyn.Utilities.FileNameUtilities : object {
    private static string DirectorySeparatorStr;
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static char VolumeSeparatorChar;
    internal static bool IsFileName(string path);
    private static int IndexOfExtension(string path);
    internal static string GetExtension(string path);
    private static string RemoveExtension(string path);
    internal static string ChangeExtension(string path, string extension);
    internal static int IndexOfFileName(string path);
    internal static string GetFileName(string path);
}
internal static class Roslyn.Utilities.FileUtilities : object {
    private static Char[] s_invalidPathChars;
    private static FileUtilities();
    internal static string ResolveRelativePath(string path, string basePath, string baseDirectory, IEnumerable`1<string> searchPaths, Func`2<string, bool> fileExists);
    internal static string ResolveRelativePath(string path, string baseDirectory);
    internal static string ResolveRelativePath(string path, string basePath, string baseDirectory);
    private static string ResolveRelativePath(PathKind kind, string path, string basePath, string baseDirectory);
    private static string GetBaseDirectory(string basePath, string baseDirectory);
    internal static string NormalizeRelativePath(string path, string basePath, string baseDirectory);
    internal static string NormalizeAbsolutePath(string path);
    internal static string NormalizeDirectoryPath(string path);
    internal static string TryNormalizeAbsolutePath(string path);
    internal static Stream OpenRead(string fullPath);
    internal static Stream OpenAsyncRead(string fullPath);
    internal static Stream CreateFileStreamChecked(Func`2<string, Stream> factory, string path, string paramName);
    internal static DateTime GetFileTimeStamp(string fullPath);
    internal static Stream OpenFileStream(string path);
}
internal class Roslyn.Utilities.FixedObjectBinder : ObjectBinder {
    private ImmutableDictionary`2<TypeKey, Type> _typeMap;
    private ImmutableDictionary`2<Type, Func`2<ObjectReader, object>> _readerMap;
    public FixedObjectBinder(ImmutableDictionary`2<Type, Func`2<ObjectReader, object>> readerMap);
    public virtual Type GetType(string assemblyName, string typeName);
    public virtual Func`2<ObjectReader, object> GetReader(Type type);
}
internal static class Roslyn.Utilities.Hash : object {
    internal static int FnvOffsetBias;
    internal static int FnvPrime;
    internal static int Combine(int newKey, int currentKey);
    internal static int Combine(bool newKeyPart, int currentKey);
    internal static int Combine(T newKeyPart, int currentKey);
    internal static int CombineValues(IEnumerable`1<T> values, int maxItemsToHash);
    internal static int CombineValues(T[] values, int maxItemsToHash);
    internal static int CombineValues(ImmutableArray`1<T> values, int maxItemsToHash);
    internal static int CombineValues(IEnumerable`1<string> values, StringComparer stringComparer, int maxItemsToHash);
    internal static int GetFNVHashCode(Byte[] data);
    internal static int GetFNVHashCode(Byte* data, int length, Boolean& isAscii);
    internal static int GetFNVHashCode(ImmutableArray`1<byte> data);
    internal static int GetFNVHashCode(string text, int start, int length);
    internal static int GetFNVHashCode(string text, int start);
    internal static int GetFNVHashCode(string text);
    internal static int GetFNVHashCode(StringBuilder text);
    internal static int GetFNVHashCode(Char[] text, int start, int length);
    internal static int GetFNVHashCode(char ch);
    internal static int CombineFNVHash(int hashCode, string text);
    internal static int CombineFNVHash(int hashCode, char ch);
}
internal abstract class Roslyn.Utilities.HashAlgorithm : object {
    private static MethodInfo s_ComputeHash_bytes_Method;
    private static MethodInfo s_ComputeHash_bytesOffsetCount_Method;
    private static MethodInfo s_ComputeHash_stream_Method;
    private static MethodInfo s_TransformBlock_Method;
    private static MethodInfo s_TransformFinalBlock_Method;
    private static MethodInfo s_Hash_PropertyGetter;
    private IDisposable _hashInstance;
    private static string MscorlibAssembly;
    private static string HashingAssembly;
    private static string HashingAlgorithmsAssembly;
    public bool SupportsTransform { get; }
    public Byte[] Hash { get; }
    private static HashAlgorithm();
    protected HashAlgorithm(IDisposable hashInstance);
    protected static MethodInfo LoadAlgorithmCreate(string name);
    private static Type GetType(string typeName, String[] assemblyNames);
    public Byte[] ComputeHash(Byte[] bytes);
    public Byte[] ComputeHash(Byte[] bytes, int offset, int count);
    public Byte[] ComputeHash(Stream stream);
    public bool get_SupportsTransform();
    public void TransformBlock(Byte[] inputBuffer, int inputCount);
    public void TransformFinalBlock(Byte[] inputBuffer, int inputCount);
    public Byte[] get_Hash();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableArrayExtensions : object {
    [ExtensionAttribute]
internal static ImmutableArray`1<T> ToImmutableArrayOrEmpty(IEnumerable`1<T> items);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> ToImmutableArrayOrEmpty(ImmutableArray`1<T> items);
    [ExtensionAttribute]
internal static int BinarySearch(ImmutableArray`1<TElement> array, TValue value, Func`3<TElement, TValue, int> comparer);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableListExtensions : object {
    [ExtensionAttribute]
internal static ImmutableList`1<T> ToImmutableListOrEmpty(T[] items);
    [ExtensionAttribute]
internal static ImmutableList`1<T> ToImmutableListOrEmpty(IEnumerable`1<T> items);
}
internal class Roslyn.Utilities.ImmutableSetWithInsertionOrder`1 : object {
    public static ImmutableSetWithInsertionOrder`1<T> Empty;
    private ImmutableDictionary`2<T, UInt32> _map;
    private UInt32 _nextElementValue;
    public int Count { get; }
    public IEnumerable`1<T> InInsertionOrder { get; }
    private ImmutableSetWithInsertionOrder`1(ImmutableDictionary`2<T, UInt32> map, UInt32 nextElementValue);
    private static ImmutableSetWithInsertionOrder`1();
    public int get_Count();
    public bool Contains(T value);
    public ImmutableSetWithInsertionOrder`1<T> Add(T value);
    public ImmutableSetWithInsertionOrder`1<T> Remove(T value);
    public IEnumerable`1<T> get_InInsertionOrder();
    public virtual string ToString();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class Roslyn.Utilities.InterlockedOperations : object {
    public static T Initialize(T& target, T value);
    public static T Initialize(T& target, T initializedValue, T uninitializedValue);
    public static ImmutableArray`1<T> Initialize(ImmutableArray`1& target, ImmutableArray`1<T> initializedValue);
}
internal interface Roslyn.Utilities.IObjectReadable {
    public abstract virtual Func`2<ObjectReader, object> GetReader();
}
internal interface Roslyn.Utilities.IObjectWritable {
    public abstract virtual void WriteTo(ObjectWriter writer);
}
internal interface Roslyn.Utilities.IReadOnlySet`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool Contains(T item);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ISetExtensions : object {
    [ExtensionAttribute]
public static bool AddAll(ISet`1<T> set, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static bool RemoveAll(ISet`1<T> set, IEnumerable`1<T> values);
}
[GuidAttribute("0000000c-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface Roslyn.Utilities.IUnsafeComStream {
    public abstract virtual void Read(IntPtr pv, int cb, IntPtr pcbRead);
    public abstract virtual void Write(IntPtr pv, int cb, IntPtr pcbWritten);
    public abstract virtual void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition);
    public abstract virtual void SetSize(long libNewSize);
    public abstract virtual void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    public abstract virtual void Commit(int grfCommitFlags);
    public abstract virtual void Revert();
    public abstract virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    public abstract virtual void Clone(IStream& ppstm);
}
internal static class Roslyn.Utilities.KeyValuePair : object {
    public static KeyValuePair`2<K, V> Create(K key, V value);
}
internal class Roslyn.Utilities.MD5CryptoServiceProvider : HashAlgorithm {
    private static MethodInfo s_create;
    private static MD5CryptoServiceProvider();
}
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.MultiDictionary`2 : object {
    private Dictionary`2<K, ValueSet<K, V>> _dictionary;
    public int Count { get; }
    public IEnumerable`1<K> Keys { get; }
    public ValueSet<K, V> Item { get; }
    public MultiDictionary`2(IEqualityComparer`1<K> comparer);
    public MultiDictionary`2(int capacity, IEqualityComparer`1<K> comparer);
    public int get_Count();
    public IEnumerable`1<K> get_Keys();
    public ValueSet<K, V> get_Item(K k);
    public void Add(K k, V v);
    public IEnumerator`1<KeyValuePair`2<K, ValueSet<K, V>>> GetEnumerator();
    public bool ContainsKey(K k);
    internal void Clear();
}
internal abstract class Roslyn.Utilities.ObjectBinder : object {
    public abstract virtual Type GetType(string assemblyName, string typeName);
    public abstract virtual Func`2<ObjectReader, object> GetReader(Type type);
}
internal class Roslyn.Utilities.ObjectPool`1 : object {
    private T _firstItem;
    private Element[] _items;
    private Factory<T> _factory;
    internal ObjectPool`1(Factory<T> factory);
    internal ObjectPool`1(Factory<T> factory, int size);
    private T CreateInstance();
    internal T Allocate();
    private T AllocateSlow();
    internal void Free(T obj);
    private void FreeSlow(T obj);
    [ConditionalAttribute("DEBUG")]
internal void ForgetTrackedObject(T old, T replacement);
    [ConditionalAttribute("DEBUG")]
private void Validate(object obj);
}
internal class Roslyn.Utilities.ObjectReader : ObjectReaderWriterBase {
    private BinaryReader _reader;
    private ObjectReaderData _dataMap;
    private ObjectBinder _binder;
    internal ObjectReader(Stream stream, ObjectReaderData defaultData, ObjectBinder binder);
    public sealed virtual void Dispose();
    public bool ReadBoolean();
    public byte ReadByte();
    public char ReadChar();
    public decimal ReadDecimal();
    public double ReadDouble();
    public float ReadSingle();
    public int ReadInt32();
    public long ReadInt64();
    public sbyte ReadSByte();
    public short ReadInt16();
    public UInt32 ReadUInt32();
    public ulong ReadUInt64();
    public ushort ReadUInt16();
    public DateTime ReadDateTime();
    public UInt32 ReadCompressedUInt();
    public object ReadValue();
    public string ReadString();
    private string ReadString(DataKind kind);
    private string ReadStringLiteral(DataKind kind);
    private Array ReadArray(DataKind kind);
    private Type ReadType();
    private Type ReadType(DataKind kind);
    private object ReadEnum();
    private object ReadObject(DataKind kind);
    private object ReadReadableObject();
    private object CreateInstance(Type type);
    private static Exception NoBinderException(string typeName);
    private static Exception NoReaderException(string typeName);
}
internal class Roslyn.Utilities.ObjectReaderData : object {
    internal static ObjectPool`1<List`1<object>> ListPool;
    private ObjectReaderData _baseData;
    private List`1<object> _values;
    private int _baseDataCount;
    internal ObjectReaderData(Object[] items);
    internal ObjectReaderData(IEnumerable`1<object> items);
    internal ObjectReaderData(ObjectReaderData baseData);
    private static ObjectReaderData();
    public sealed virtual void Dispose();
    public int GetNextId();
    public void AddValue(int id, object value);
    public object GetValue(int id);
}
internal class Roslyn.Utilities.ObjectReaderWriterBase : object {
    internal static byte ByteMarkerMask;
    internal static byte Byte1Marker;
    internal static byte Byte2Marker;
    internal static byte Byte4Marker;
    private static ObjectReaderWriterBase();
}
internal class Roslyn.Utilities.ObjectWriter : ObjectReaderWriterBase {
    private BinaryWriter _writer;
    private ObjectWriterData _dataMap;
    private RecordingObjectBinder _binder;
    private CancellationToken _cancellationToken;
    public ObjectBinder Binder { get; }
    internal ObjectWriter(Stream stream, ObjectWriterData defaultData, RecordingObjectBinder binder, CancellationToken cancellationToken);
    public ObjectBinder get_Binder();
    public sealed virtual void Dispose();
    public void WriteBoolean(bool value);
    public void WriteByte(byte value);
    public void WriteChar(char ch);
    public void WriteDecimal(decimal value);
    public void WriteDouble(double value);
    public void WriteSingle(float value);
    public void WriteInt32(int value);
    public void WriteInt64(long value);
    public void WriteSByte(sbyte value);
    public void WriteInt16(short value);
    public void WriteUInt32(UInt32 value);
    public void WriteUInt64(ulong value);
    public void WriteUInt16(ushort value);
    public void WriteDateTime(DateTime value);
    public void WriteCompressedUInt(UInt32 value);
    public void WriteString(string value);
    public void WriteValue(object value);
    private void WriteEnum(object value, Type enumType);
    private void WriteArray(Array instance);
    private void WriteType(Type type);
    private void WriteObject(object instance);
    private void WriteWritableObject(IObjectWritable instance);
    private static Exception NotWritableException(string typeName);
}
internal class Roslyn.Utilities.ObjectWriterData : object {
    internal static ObjectPool`1<Dictionary`2<object, int>> DictionaryPool;
    private ObjectWriterData _baseData;
    private Dictionary`2<object, int> _valueToIdMap;
    private int _nextId;
    internal ObjectWriterData(Object[] items);
    internal ObjectWriterData(IEnumerable`1<object> items);
    internal ObjectWriterData(ObjectWriterData baseData);
    private static ObjectWriterData();
    public sealed virtual void Dispose();
    public bool TryGetId(object value, Int32& id);
    private int GetNextId();
    public int Add(object value);
}
internal static class Roslyn.Utilities.OneOrMany : object {
    public static OneOrMany`1<T> Create(T one);
    public static OneOrMany`1<T> Create(ImmutableArray`1<T> many);
}
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.OneOrMany`1 : ValueType {
    private T _one;
    private ImmutableArray`1<T> _many;
    public T Item { get; }
    public int Count { get; }
    public OneOrMany`1(T one);
    public OneOrMany`1(ImmutableArray`1<T> many);
    public T get_Item(int index);
    public int get_Count();
}
internal enum Roslyn.Utilities.PathKind : Enum {
    public int value__;
    public static PathKind Empty;
    public static PathKind Relative;
    public static PathKind RelativeToCurrentDirectory;
    public static PathKind RelativeToCurrentParent;
    public static PathKind RelativeToCurrentRoot;
    public static PathKind RelativeToDriveDirectory;
    public static PathKind Absolute;
}
internal static class Roslyn.Utilities.PathUtilities : object {
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static string DirectorySeparatorStr;
    internal static char VolumeSeparatorChar;
    private static bool IsUnixLikePlatform { get; }
    private static PathUtilities();
    private static bool get_IsUnixLikePlatform();
    internal static bool IsDirectorySeparator(char c);
    internal static string GetExtension(string path);
    internal static string ChangeExtension(string path, string extension);
    internal static string RemoveExtension(string path);
    internal static string GetFileName(string path);
    internal static string GetDirectoryName(string path);
    internal static PathKind GetPathKind(string path);
    internal static bool IsAbsolute(string path);
    private static bool IsDriveRootedAbsolutePath(string path);
    internal static string GetPathRoot(string path);
    private static int GetPathRootLength(string path);
    private static int GetUncPathRootLength(string path);
    private static int IndexOfDirectorySeparator(string path, int start);
    private static int IndexOfNonDirectorySeparator(string path, int start);
    internal static string CombineAbsoluteAndRelativePaths(string root, string relativePath);
    internal static string CombinePossiblyRelativeAndRelativePaths(string rootOpt, string relativePath);
    internal static string CombinePathsUnchecked(string root, string relativePath);
    internal static string RemoveTrailingDirectorySeparator(string path);
    internal static bool IsFilePath(string assemblyDisplayNameOrPath);
}
internal static class Roslyn.Utilities.PortableShim : object {
    internal static void Initialize();
    private static void Touch(Type type);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ReaderWriterLockSlimExtensions : object {
    [ExtensionAttribute]
internal static ReadLockExiter DisposableRead(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static WriteLockExiter DisposableWrite(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static void AssertCanRead(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static void AssertCanWrite(ReaderWriterLockSlim lock);
}
internal abstract class Roslyn.Utilities.RecordingObjectBinder : ObjectBinder {
    public abstract virtual void Record(Type type);
    public abstract virtual void Record(object instance);
}
internal class Roslyn.Utilities.ReferenceEqualityComparer : object {
    public static IEqualityComparer`1<object> Instance;
    private static ReferenceEqualityComparer();
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object a, object b);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Object>.GetHashCode(object a);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ReflectionUtil : object {
    public static Type GetTypeFromEither(string contractName, string desktopName);
    public static T FindItem(IEnumerable`1<T> collection, Type[] paramTypes);
    [ExtensionAttribute]
internal static MethodInfo GetDeclaredMethod(TypeInfo typeInfo, string name, Type[] paramTypes);
    [ExtensionAttribute]
internal static ConstructorInfo GetDeclaredConstructor(TypeInfo typeInfo, Type[] paramTypes);
    [ExtensionAttribute]
public static T CreateDelegate(MethodInfo methodInfo);
}
internal class Roslyn.Utilities.SHA1CryptoServiceProvider : HashAlgorithm {
    private static MethodInfo s_create;
    private static SHA1CryptoServiceProvider();
}
internal class Roslyn.Utilities.SHA256CryptoServiceProvider : HashAlgorithm {
    private static MethodInfo s_create;
    private static SHA256CryptoServiceProvider();
}
internal class Roslyn.Utilities.SHA384CryptoServiceProvider : HashAlgorithm {
    private static MethodInfo s_create;
    private static SHA384CryptoServiceProvider();
}
internal class Roslyn.Utilities.SHA512CryptoServiceProvider : HashAlgorithm {
    private static MethodInfo s_create;
    private static SHA512CryptoServiceProvider();
}
internal class Roslyn.Utilities.SimpleRecordingObjectBinder : RecordingObjectBinder {
    private Dictionary`2<TypeKey, Type> _typeMap;
    private Dictionary`2<Type, Func`2<ObjectReader, object>> _readerMap;
    public virtual Type GetType(string assemblyName, string typeName);
    public virtual Func`2<ObjectReader, object> GetReader(Type type);
    private bool HasConstructor(Type type);
    public virtual void Record(Type type);
    public virtual void Record(object instance);
}
internal static class Roslyn.Utilities.SpecializedCollections : object {
    public static Byte[] EmptyBytes;
    public static Object[] EmptyObjects;
    private static SpecializedCollections();
    public static T[] EmptyArray();
    public static IEnumerator`1<T> EmptyEnumerator();
    public static IEnumerable`1<T> EmptyEnumerable();
    public static ICollection`1<T> EmptyCollection();
    public static IList`1<T> EmptyList();
    public static IReadOnlyList`1<T> EmptyReadOnlyList();
    public static ISet`1<T> EmptySet();
    public static IDictionary`2<TKey, TValue> EmptyDictionary();
    public static IEnumerable`1<T> SingletonEnumerable(T value);
    public static ICollection`1<T> SingletonCollection(T value);
    public static IEnumerator`1<T> SingletonEnumerator(T value);
    public static IEnumerable`1<T> ReadOnlyEnumerable(IEnumerable`1<T> values);
    public static ICollection`1<T> ReadOnlyCollection(ICollection`1<T> collection);
    public static ISet`1<T> ReadOnlySet(ISet`1<T> set);
    public static ISet`1<T> ReadOnlySet(IEnumerable`1<T> values);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.StringExtensions : object {
    private static ImmutableArray`1<string> s_lazyNumerals;
    private static Func`2<char, char> s_toLower;
    private static Func`2<char, char> s_toUpper;
    private static StringExtensions();
    internal static string GetNumeral(int number);
    [ExtensionAttribute]
public static string Join(IEnumerable`1<string> source, string separator);
    [ExtensionAttribute]
public static bool LooksLikeInterfaceName(string name);
    [ExtensionAttribute]
public static bool LooksLikeTypeParameterName(string name);
    [ExtensionAttribute]
public static string ToPascalCase(string shortName, bool trimLeadingTypePrefix);
    [ExtensionAttribute]
public static string ToCamelCase(string shortName, bool trimLeadingTypePrefix);
    [ExtensionAttribute]
private static string ConvertCase(string shortName, bool trimLeadingTypePrefix, Func`2<char, char> convert);
    [ExtensionAttribute]
internal static bool IsValidClrTypeName(string name);
    [ExtensionAttribute]
internal static bool IsValidClrNamespaceName(string name);
    [ExtensionAttribute]
internal static string GetWithSingleAttributeSuffix(string name, bool isCaseSensitive);
    [ExtensionAttribute]
internal static bool TryGetWithoutAttributeSuffix(string name, String& result);
    [ExtensionAttribute]
internal static string GetWithoutAttributeSuffix(string name, bool isCaseSensitive);
    [ExtensionAttribute]
internal static bool TryGetWithoutAttributeSuffix(string name, bool isCaseSensitive, String& result);
    [ExtensionAttribute]
internal static bool IsValidUnicodeString(string str);
    [ExtensionAttribute]
internal static string Unquote(string arg);
    [ExtensionAttribute]
internal static string Unquote(string arg, Boolean& quoted);
    [ExtensionAttribute]
internal static int IndexOfBalancedParenthesis(string str, int openingOffset, char closing);
    [ExtensionAttribute]
internal static char First(string arg);
    [ExtensionAttribute]
internal static char Last(string arg);
    [ExtensionAttribute]
internal static bool All(string arg, Predicate`1<char> predicate);
}
internal class Roslyn.Utilities.StringTable : object {
    private static int LocalSizeBits;
    private static int LocalSize;
    private static int LocalSizeMask;
    private static int SharedSizeBits;
    private static int SharedSize;
    private static int SharedSizeMask;
    private static int SharedBucketBits;
    private static int SharedBucketSize;
    private static int SharedBucketSizeMask;
    private Entry[] _localTable;
    private static Entry[] s_sharedTable;
    private int _localRandom;
    private static int s_sharedRandom;
    private ObjectPool`1<StringTable> _pool;
    private static ObjectPool`1<StringTable> s_staticPool;
    private StringTable(ObjectPool`1<StringTable> pool);
    private static StringTable();
    private static ObjectPool`1<StringTable> CreatePool();
    public static StringTable GetInstance();
    public void Free();
    internal string Add(Char[] chars, int start, int len);
    internal string Add(string chars, int start, int len);
    internal string Add(char chars);
    internal string Add(StringBuilder chars);
    internal string Add(string chars);
    private static string FindSharedEntry(Char[] chars, int start, int len, int hashCode);
    private static string FindSharedEntry(string chars, int start, int len, int hashCode);
    private static string FindSharedEntryASCII(int hashCode, Byte* asciiChars, int length);
    private static string FindSharedEntry(char chars, int hashCode);
    private static string FindSharedEntry(StringBuilder chars, int hashCode);
    private static string FindSharedEntry(string chars, int hashCode);
    private string AddItem(Char[] chars, int start, int len, int hashCode);
    private string AddItem(string chars, int start, int len, int hashCode);
    private string AddItem(char chars, int hashCode);
    private string AddItem(StringBuilder chars, int hashCode);
    private void AddCore(string chars, int hashCode);
    private void AddSharedEntry(int hashCode, string text);
    internal static string AddShared(StringBuilder chars);
    private static string AddSharedSlow(int hashCode, StringBuilder builder);
    internal static string AddSharedUTF8(Byte* bytes, int byteCount);
    private static string AddSharedSlow(int hashCode, Byte* utf8Bytes, int byteCount, bool isAscii);
    private static void AddSharedSlow(int hashCode, string text);
    private static int LocalIdxFromHash(int hash);
    private static int SharedIdxFromHash(int hash);
    private int LocalNextRandom();
    private static int SharedNextRandom();
    internal static bool TextEquals(string array, string text, int start, int length);
    internal static bool TextEquals(string array, StringBuilder text);
    internal static bool TextEqualsASCII(string text, Byte* ascii, int length);
    internal static bool TextEquals(string array, Char[] text, int start, int length);
    private static bool TextEqualsCore(string array, Char[] text, int start);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.TextChangeRangeExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<TextChangeRange> Accumulate(Nullable`1<TextChangeRange> accumulatedTextChangeSoFar, IEnumerable`1<TextChangeRange> changesInNextVersion);
}
internal class Roslyn.Utilities.TextKeyedCache`1 : object {
    private static int LocalSizeBits;
    private static int LocalSize;
    private static int LocalSizeMask;
    private static int SharedSizeBits;
    private static int SharedSize;
    private static int SharedSizeMask;
    private static int SharedBucketBits;
    private static int SharedBucketSize;
    private static int SharedBucketSizeMask;
    private LocalEntry[] _localTable;
    private static SharedEntry[] s_sharedTable;
    private SharedEntry[] _sharedTableInst;
    private StringTable _strings;
    private Random _random;
    private ObjectPool`1<TextKeyedCache`1<T>> _pool;
    private static ObjectPool`1<TextKeyedCache`1<T>> s_staticPool;
    private TextKeyedCache`1(ObjectPool`1<TextKeyedCache`1<T>> pool);
    private static TextKeyedCache`1();
    private static ObjectPool`1<TextKeyedCache`1<T>> CreatePool();
    public static TextKeyedCache`1<T> GetInstance();
    public void Free();
    internal T FindItem(Char[] chars, int start, int len, int hashCode);
    private SharedEntryValue<T> FindSharedEntry(Char[] chars, int start, int len, int hashCode);
    internal void AddItem(Char[] chars, int start, int len, int hashCode, T item);
    private void AddSharedEntry(int hashCode, SharedEntryValue<T> e);
    private static int LocalIdxFromHash(int hash);
    private static int SharedIdxFromHash(int hash);
    private int NextRandom();
}
internal static class Roslyn.Utilities.ThreadSafeFlagOperations : object {
    public static bool Set(Int32& flags, int toSet);
    public static bool Clear(Int32& flags, int toClear);
}
internal static class Roslyn.Utilities.UICultureUtilities : object {
    private static string currentUICultureName;
    private static Action`1<CultureInfo> s_setCurrentUICulture;
    private static UICultureUtilities();
    private static bool TryGetCurrentUICultureSetter(Action`1& setter);
    private static bool TryGetCurrentThreadUICultureSetter(Action`1& setter);
    public static Action WithCurrentUICulture(Action action);
    public static Action`1<T> WithCurrentUICulture(Action`1<T> action);
    public static Func`1<T> WithCurrentUICulture(Func`1<T> func);
}
internal static class Roslyn.Utilities.ValueTuple : object {
    public static ValueTuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static ValueTuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
}
internal class Roslyn.Utilities.ValueTuple`2 : ValueType {
    private static EqualityComparer`1<T1> s_comparer1;
    private static EqualityComparer`1<T2> s_comparer2;
    public T1 Item1;
    public T2 Item2;
    public ValueTuple`2(T1 item1, T2 item2);
    private static ValueTuple`2();
    public sealed virtual bool Equals(ValueTuple`2<T1, T2> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ValueTuple`2<T1, T2> left, ValueTuple`2<T1, T2> right);
    public static bool op_Inequality(ValueTuple`2<T1, T2> left, ValueTuple`2<T1, T2> right);
}
internal class Roslyn.Utilities.ValueTuple`3 : ValueType {
    private static EqualityComparer`1<T1> s_comparer1;
    private static EqualityComparer`1<T2> s_comparer2;
    private static EqualityComparer`1<T3> s_comparer3;
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public ValueTuple`3(T1 item1, T2 item2, T3 item3);
    private static ValueTuple`3();
    public sealed virtual bool Equals(ValueTuple`3<T1, T2, T3> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ValueTuple`3<T1, T2, T3> left, ValueTuple`3<T1, T2, T3> right);
    public static bool op_Inequality(ValueTuple`3<T1, T2, T3> left, ValueTuple`3<T1, T2, T3> right);
}
internal class Roslyn.Utilities.WeakList`1 : object {
    private WeakReference`1[] _items;
    private int _size;
    private static int MinimalNonEmptySize;
    public int WeakCount { get; }
    internal WeakReference`1[] TestOnly_UnderlyingArray { get; }
    private void Resize();
    private void Shrink(int firstDead, int alive);
    private static int GetExpandedSize(int baseSize);
    private void Compact(int firstDead, WeakReference`1[] result);
    public int get_WeakCount();
    public WeakReference`1<T> GetWeakReference(int index);
    public void Add(T item);
    [IteratorStateMachineAttribute("Roslyn.Utilities.WeakList`1/<GetEnumerator>d__12")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal WeakReference`1[] get_TestOnly_UnderlyingArray();
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.WeakReferenceExtensions : object {
    [ExtensionAttribute]
public static T GetTarget(WeakReference`1<T> reference);
    [ExtensionAttribute]
public static bool IsNull(WeakReference`1<T> reference);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.XmlUtilities : object {
    [ExtensionAttribute]
internal static TNode Copy(TNode node, bool copyAttributeAnnotations);
    private static void CopyAnnotations(XObject source, XObject target);
    internal static XElement[] TrySelectElements(XNode node, string xpath, String& errorMessage, Boolean& invalidXPath);
}
[AttributeUsageAttribute("1024")]
internal class System.Runtime.CompilerServices.InternalImplementationOnlyAttribute : Attribute {
}
internal class System.Security.SuppressUnmanagedCodeSecurityAttribute : Attribute {
}
