internal abstract class Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`1 : PreciseAbstractFlowPass`1<TLocalState> {
    protected bool trackUnassignments;
    protected AbstractFlowPass`1(CSharpCompilation compilation, Symbol member, BoundNode node, bool trackUnassignments);
    protected AbstractFlowPass`1(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion, bool trackRegions, bool trackUnassignments);
    protected abstract virtual void UnionWith(TLocalState& self, TLocalState& other);
    public virtual BoundNode VisitTryStatement(BoundTryStatement node);
    protected virtual void VisitTryBlock(BoundStatement tryBlock, BoundTryStatement node, TLocalState& tryState);
    protected virtual void VisitCatchBlock(BoundCatchBlock catchBlock, TLocalState& finallyState);
    protected virtual void VisitFinallyBlock(BoundStatement finallyBlock, TLocalState& unsetInFinally);
}
internal class Microsoft.CodeAnalysis.CSharp.AbstractRegionControlFlowPass : ControlFlowPass {
    internal AbstractRegionControlFlowPass(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion);
    public virtual BoundNode Visit(BoundNode node);
    public virtual BoundNode VisitLambda(BoundLambda node);
}
internal class Microsoft.CodeAnalysis.CSharp.AbstractRegionDataFlowPass : DataFlowPass {
    internal AbstractRegionDataFlowPass(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion, HashSet`1<Symbol> initiallyAssignedVariables, HashSet`1<PrefixUnaryExpressionSyntax> unassignedVariableAddressOfSyntaxes, bool trackUnassignments);
    protected virtual ImmutableArray`1<PendingBranch<LocalState>> Scan(Boolean& badRegion);
    public virtual BoundNode VisitLambda(BoundLambda node);
    private void MakeSlots(ImmutableArray`1<ParameterSymbol> parameters);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.AccessCheck : object {
    public static bool IsSymbolAccessible(Symbol symbol, AssemblySymbol within, HashSet`1& useSiteDiagnostics);
    public static bool IsSymbolAccessible(Symbol symbol, NamedTypeSymbol within, HashSet`1& useSiteDiagnostics, TypeSymbol throughTypeOpt);
    public static bool IsSymbolAccessible(Symbol symbol, NamedTypeSymbol within, TypeSymbol throughTypeOpt, Boolean& failedThroughTypeCheck, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    private static bool IsSymbolAccessibleCore(Symbol symbol, Symbol within, TypeSymbol throughTypeOpt, Boolean& failedThroughTypeCheck, CSharpCompilation compilation, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    private static bool IsNamedTypeAccessible(NamedTypeSymbol type, Symbol within, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    private static bool IsNonNestedTypeAccessible(AssemblySymbol assembly, Accessibility declaredAccessibility, Symbol within);
    private static bool IsMemberAccessible(NamedTypeSymbol containingType, Accessibility declaredAccessibility, Symbol within, TypeSymbol throughTypeOpt, Boolean& failedThroughTypeCheck, CSharpCompilation compilation, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    private static bool IsNonPublicMemberAccessible(NamedTypeSymbol containingType, Accessibility declaredAccessibility, Symbol within, TypeSymbol throughTypeOpt, Boolean& failedThroughTypeCheck, CSharpCompilation compilation, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    private static bool IsProtectedSymbolAccessible(NamedTypeSymbol withinType, TypeSymbol throughTypeOpt, NamedTypeSymbol originalContainingType, Boolean& failedThroughTypeCheck, CSharpCompilation compilation, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    private static bool IsPrivateSymbolAccessible(Symbol within, NamedTypeSymbol originalContainingType);
    private static bool IsNestedWithinOriginalContainingType(NamedTypeSymbol withinType, NamedTypeSymbol originalContainingType);
    [ExtensionAttribute]
private static bool InheritsFromIgnoringConstruction(TypeSymbol type, NamedTypeSymbol baseType, CSharpCompilation compilation, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    [ExtensionAttribute]
internal static bool HasInternalAccessTo(AssemblySymbol assembly, AssemblySymbol toAssembly);
    internal static ErrorCode GetProtectedMemberInSealedTypeError(NamedTypeSymbol containingType);
}
internal class Microsoft.CodeAnalysis.CSharp.AliasAndExternAliasDirective : ValueType {
    public AliasSymbol Alias;
    public ExternAliasDirectiveSyntax ExternAliasDirective;
    public AliasAndExternAliasDirective(AliasSymbol alias, ExternAliasDirectiveSyntax externAliasDirective);
}
internal class Microsoft.CodeAnalysis.CSharp.AliasAndUsingDirective : ValueType {
    public AliasSymbol Alias;
    public UsingDirectiveSyntax UsingDirective;
    public AliasAndUsingDirective(AliasSymbol alias, UsingDirectiveSyntax usingDirective);
}
internal class Microsoft.CodeAnalysis.CSharp.AlwaysAssignedWalker : AbstractRegionDataFlowPass {
    private LocalState _endOfRegionState;
    private HashSet`1<LabelSymbol> _labelsInside;
    private AlwaysAssignedWalker(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion);
    internal static IEnumerable`1<Symbol> Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion);
    private List`1<Symbol> Analyze(Boolean& badRegion);
    protected virtual void WriteArgument(BoundExpression arg, RefKind refKind, MethodSymbol method);
    protected virtual void ResolveBranch(PendingBranch<LocalState> pending, LabelSymbol label, BoundStatement target, Boolean& labelStateChanged);
    public virtual BoundNode VisitLabel(BoundLabel node);
    public virtual BoundNode VisitLabeledStatement(BoundLabeledStatement node);
    private void ResolveLabel(BoundNode node, LabelSymbol label);
    protected virtual void EnterRegion();
    protected virtual void LeaveRegion();
}
internal class Microsoft.CodeAnalysis.CSharp.AnalyzedArguments : object {
    public ArrayBuilder`1<BoundExpression> Arguments;
    public ArrayBuilder`1<IdentifierNameSyntax> Names;
    public ArrayBuilder`1<RefKind> RefKinds;
    public bool IsExtensionMethodInvocation;
    private ThreeState _lazyHasDynamicArgument;
    public static ObjectPool`1<AnalyzedArguments> Pool;
    public bool HasDynamicArgument { get; }
    public bool HasErrors { get; }
    private static AnalyzedArguments();
    public void Clear();
    public BoundExpression Argument(int i);
    public string Name(int i);
    public ImmutableArray`1<string> GetNames();
    public RefKind RefKind(int i);
    public bool IsExtensionMethodThisArgument(int i);
    public bool get_HasDynamicArgument();
    public bool get_HasErrors();
    public static AnalyzedArguments GetInstance();
    public void Free();
    private static ObjectPool`1<AnalyzedArguments> CreatePool();
}
internal class Microsoft.CodeAnalysis.CSharp.ArgumentAnalysisResult : ValueType {
    public ImmutableArray`1<int> ArgsToParamsOpt;
    public int ArgumentPosition;
    public int ParameterPosition;
    public ArgumentAnalysisResultKind Kind;
    public bool IsValid { get; }
    private ArgumentAnalysisResult(ArgumentAnalysisResultKind kind, int argumentPosition, int parameterPosition, ImmutableArray`1<int> argsToParamsOpt);
    public int ParameterFromArgument(int arg);
    public bool get_IsValid();
    public static ArgumentAnalysisResult NameUsedForPositional(int argumentPosition);
    public static ArgumentAnalysisResult NoCorrespondingParameter(int argumentPosition);
    public static ArgumentAnalysisResult NoCorrespondingNamedParameter(int argumentPosition);
    public static ArgumentAnalysisResult RequiredParameterMissing(int parameterPosition);
    public static ArgumentAnalysisResult NormalForm(ImmutableArray`1<int> argsToParamsOpt);
    public static ArgumentAnalysisResult ExpandedForm(ImmutableArray`1<int> argsToParamsOpt);
}
internal enum Microsoft.CodeAnalysis.CSharp.ArgumentAnalysisResultKind : Enum {
    public byte value__;
    public static ArgumentAnalysisResultKind Normal;
    public static ArgumentAnalysisResultKind Expanded;
    public static ArgumentAnalysisResultKind NoCorrespondingParameter;
    public static ArgumentAnalysisResultKind FirstInvalid;
    public static ArgumentAnalysisResultKind NoCorrespondingNamedParameter;
    public static ArgumentAnalysisResultKind RequiredParameterMissing;
    public static ArgumentAnalysisResultKind NameUsedForPositional;
}
internal class Microsoft.CodeAnalysis.CSharp.AsyncConstructor : SynthesizedInstanceConstructor {
    private IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.Method { get; }
    private bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.HasMethodBodyDependency { get; }
    internal AsyncConstructor(AsyncStateMachine stateMachineType);
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_Method();
    private sealed virtual override bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_HasMethodBodyDependency();
}
internal class Microsoft.CodeAnalysis.CSharp.AsyncExceptionHandlerRewriter : BoundTreeRewriterWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator {
    private bool _generateDebugInfo;
    private CSharpCompilation _compilation;
    private SyntheticBoundNodeFactory _F;
    private DiagnosticBag _diagnostics;
    private AwaitInFinallyAnalysis _analysis;
    private AwaitCatchFrame _currentAwaitCatchFrame;
    private AwaitFinallyFrame _currentAwaitFinallyFrame;
    private AsyncExceptionHandlerRewriter(MethodSymbol containingMethod, NamedTypeSymbol containingType, SyntheticBoundNodeFactory factory, CSharpCompilation compilation, DiagnosticBag diagnostics, AwaitInFinallyAnalysis analysis);
    public static BoundStatement Rewrite(MethodSymbol containingSymbol, NamedTypeSymbol containingType, BoundStatement statement, TypeCompilationState compilationState, DiagnosticBag diagnostics);
    public virtual BoundNode VisitTryStatement(BoundTryStatement node);
    private BoundBlock PendBranches(AwaitFinallyFrame frame, LocalSymbol pendingBranchVar, LabelSymbol finallyLabel);
    private void PendBranch(ArrayBuilder`1<BoundStatement> bodyStatements, LabelSymbol proxy, int i, LocalSymbol pendingBranchVar, LabelSymbol finallyLabel);
    private BoundStatement UnpendBranches(AwaitFinallyFrame frame, SynthesizedLocal pendingBranchVar, SynthesizedLocal pendingException);
    public virtual BoundNode VisitGotoStatement(BoundGotoStatement node);
    public virtual BoundNode VisitConditionalGoto(BoundConditionalGoto node);
    public virtual BoundNode VisitReturnStatement(BoundReturnStatement node);
    private BoundStatement UnpendException(LocalSymbol pendingExceptionLocal);
    private BoundStatement Rethrow(LocalSymbol obj);
    private BoundStatement RewriteFinalizedRegion(BoundTryStatement node);
    public virtual BoundNode VisitCatchBlock(BoundCatchBlock node);
    private BoundExpression AssignCatchSource(BoundExpression rewrittenSource, AwaitCatchFrame currentAwaitCatchFrame);
    public virtual BoundNode VisitLocal(BoundLocal node);
    public virtual BoundNode VisitThrowStatement(BoundThrowStatement node);
    public virtual BoundNode VisitLambda(BoundLambda node);
    private AwaitFinallyFrame PushFrame(BoundTryStatement statement);
    private void PopFrame();
}
internal class Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection : ValueType {
    internal NamedTypeSymbol BuilderType;
    internal TypeSymbol ResultType;
    internal MethodSymbol SetException;
    internal MethodSymbol SetResult;
    internal MethodSymbol AwaitOnCompleted;
    internal MethodSymbol AwaitUnsafeOnCompleted;
    internal MethodSymbol Start;
    internal MethodSymbol SetStateMachine;
    internal PropertySymbol Task;
    internal AsyncMethodBuilderMemberCollection(NamedTypeSymbol builderType, TypeSymbol resultType, MethodSymbol setException, MethodSymbol setResult, MethodSymbol awaitOnCompleted, MethodSymbol awaitUnsafeOnCompleted, MethodSymbol start, MethodSymbol setStateMachine, PropertySymbol task);
    internal static bool TryCreate(SyntheticBoundNodeFactory F, MethodSymbol method, TypeMap typeMap, AsyncMethodBuilderMemberCollection& collection);
    private static bool TryCreate(SyntheticBoundNodeFactory F, NamedTypeSymbol builderType, TypeSymbol resultType, WellKnownMember setException, WellKnownMember setResult, WellKnownMember awaitOnCompleted, WellKnownMember awaitUnsafeOnCompleted, WellKnownMember start, WellKnownMember setStateMachine, PropertySymbol task, AsyncMethodBuilderMemberCollection& collection);
    private static bool TryGetWellKnownMethodAsMember(SyntheticBoundNodeFactory F, WellKnownMember wellKnownMethod, NamedTypeSymbol containingType, MethodSymbol& methodSymbol);
    private static bool TryGetWellKnownPropertyAsMember(SyntheticBoundNodeFactory F, WellKnownMember wellKnownProperty, NamedTypeSymbol containingType, PropertySymbol& propertySymbol);
}
internal class Microsoft.CodeAnalysis.CSharp.AsyncMethodToStateMachineRewriter : MethodToStateMachineRewriter {
    private MethodSymbol _method;
    private FieldSymbol _asyncMethodBuilderField;
    private AsyncMethodBuilderMemberCollection _asyncMethodBuilderMemberCollection;
    private LabelSymbol _exprReturnLabel;
    private LabelSymbol _exitLabel;
    private LocalSymbol _exprRetValue;
    private LoweredDynamicOperationFactory _dynamicFactory;
    private Dictionary`2<TypeSymbol, FieldSymbol> _awaiterFields;
    private int _nextAwaiterId;
    internal AsyncMethodToStateMachineRewriter(MethodSymbol method, int methodOrdinal, AsyncMethodBuilderMemberCollection asyncMethodBuilderMemberCollection, SyntheticBoundNodeFactory F, FieldSymbol state, FieldSymbol builder, IReadOnlySet`1<Symbol> hoistedVariables, IReadOnlyDictionary`2<Symbol, CapturedSymbolReplacement> nonReusableLocalProxies, SynthesizedLocalOrdinalsDispenser synthesizedLocalOrdinals, VariableSlotAllocator slotAllocatorOpt, int nextFreeHoistedLocalSlot, DiagnosticBag diagnostics);
    private FieldSymbol GetAwaiterField(TypeSymbol awaiterType);
    internal void GenerateMoveNext(BoundStatement body, MethodSymbol moveNextMethod);
    protected virtual BoundStatement GenerateReturn(bool finished);
    public virtual BoundNode VisitExpressionStatement(BoundExpressionStatement node);
    public virtual BoundNode VisitAwaitExpression(BoundAwaitExpression node);
    public virtual BoundNode VisitBadExpression(BoundBadExpression node);
    private BoundBlock VisitAwaitExpression(BoundAwaitExpression node, BoundExpression resultPlace);
    private BoundExpression MakeCallMaybeDynamic(BoundExpression receiver, MethodSymbol methodSymbol, string methodName, bool resultsDiscarded);
    private BoundExpression GenerateGetIsCompleted(LocalSymbol awaiterTemp, MethodSymbol getIsCompletedMethod);
    private BoundBlock GenerateAwaitForIncompleteTask(LocalSymbol awaiterTemp);
    private BoundStatement GenerateAwaitOnCompletedDynamic(LocalSymbol awaiterTemp);
    private BoundStatement GenerateAwaitOnCompleted(TypeSymbol loweredAwaiterType, LocalSymbol awaiterTemp);
    private static ImmutableArray`1<LocalSymbol> SingletonOrPair(LocalSymbol first, LocalSymbol secondOpt);
    public virtual BoundNode VisitReturnStatement(BoundReturnStatement node);
}
internal class Microsoft.CodeAnalysis.CSharp.AsyncRewriter : StateMachineRewriter {
    private AsyncMethodBuilderMemberCollection _asyncMethodBuilderMemberCollection;
    private bool _constructedSuccessfully;
    private int _methodOrdinal;
    private bool _ignoreAccessibility;
    private FieldSymbol _builderField;
    protected bool PreserveInitialParameterValues { get; }
    private AsyncRewriter(BoundStatement body, MethodSymbol method, int methodOrdinal, AsyncStateMachine stateMachineType, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics);
    internal static BoundStatement Rewrite(BoundStatement body, MethodSymbol method, int methodOrdinal, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics, AsyncStateMachine& stateMachineType);
    protected bool VerifyPresenceOfRequiredAPIs();
    private Symbol EnsureWellKnownMember(WellKnownMember member, DiagnosticBag bag);
    protected virtual bool get_PreserveInitialParameterValues();
    protected virtual void GenerateControlFields();
    protected virtual void GenerateMethodImplementations();
    protected virtual void InitializeStateMachine(ArrayBuilder`1<BoundStatement> bodyBuilder, NamedTypeSymbol frameType, LocalSymbol stateMachineLocal);
    protected virtual BoundStatement GenerateStateMachineCreation(LocalSymbol stateMachineVariable, NamedTypeSymbol frameType);
    private void GenerateMoveNext(SynthesizedImplementationMethod moveNextMethod);
}
internal class Microsoft.CodeAnalysis.CSharp.AsyncStateMachine : StateMachineTypeSymbol {
    private TypeKind _typeKind;
    private MethodSymbol _constructor;
    private ImmutableArray`1<NamedTypeSymbol> _interfaces;
    public TypeKind TypeKind { get; }
    internal MethodSymbol Constructor { get; }
    public AsyncStateMachine(VariableSlotAllocator variableAllocatorOpt, TypeCompilationState compilationState, MethodSymbol asyncMethod, int asyncMethodOrdinal, TypeKind typeKind);
    public virtual TypeKind get_TypeKind();
    internal virtual MethodSymbol get_Constructor();
    internal virtual ImmutableArray`1<NamedTypeSymbol> InterfacesNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
}
internal class Microsoft.CodeAnalysis.CSharp.AttributeSemanticModel : MemberSemanticModel {
    private AliasSymbol _aliasOpt;
    private NamedTypeSymbol AttributeType { get; }
    private AttributeSemanticModel(CSharpCompilation compilation, AttributeSyntax syntax, NamedTypeSymbol attributeType, AliasSymbol aliasOpt, Binder rootBinder, SyntaxTreeSemanticModel parentSemanticModelOpt, int speculatedPosition);
    public static AttributeSemanticModel Create(CSharpCompilation compilation, AttributeSyntax syntax, NamedTypeSymbol attributeType, AliasSymbol aliasOpt, Binder rootBinder);
    public static AttributeSemanticModel CreateSpeculative(SyntaxTreeSemanticModel parentSemanticModel, AttributeSyntax syntax, NamedTypeSymbol attributeType, AliasSymbol aliasOpt, Binder rootBinder, int position);
    private NamedTypeSymbol get_AttributeType();
    protected internal virtual CSharpSyntaxNode GetBindableSyntaxNode(CSharpSyntaxNode node);
    internal virtual BoundNode Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, ConstructorInitializerSyntax constructorInitializer, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, EqualsValueClauseSyntax initializer, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, ArrowExpressionClauseSyntax expressionBody, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, StatementSyntax statement, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelForMethodBodyCore(SyntaxTreeSemanticModel parentModel, int position, BaseMethodDeclarationSyntax method, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelForMethodBodyCore(SyntaxTreeSemanticModel parentModel, int position, AccessorDeclarationSyntax accessor, SemanticModel& speculativeModel);
}
public class Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo : ValueType {
    [CompilerGeneratedAttribute]
private IMethodSymbol <GetAwaiterMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IPropertySymbol <IsCompletedProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <GetResultMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDynamic>k__BackingField;
    public IMethodSymbol GetAwaiterMethod { get; }
    public IPropertySymbol IsCompletedProperty { get; }
    public IMethodSymbol GetResultMethod { get; }
    public bool IsDynamic { get; }
    internal AwaitExpressionInfo(IMethodSymbol getAwaiterMethod, IPropertySymbol isCompletedProperty, IMethodSymbol getResultMethod, bool isDynamic);
    [CompilerGeneratedAttribute]
public IMethodSymbol get_GetAwaiterMethod();
    [CompilerGeneratedAttribute]
public IPropertySymbol get_IsCompletedProperty();
    [CompilerGeneratedAttribute]
public IMethodSymbol get_GetResultMethod();
    [CompilerGeneratedAttribute]
public bool get_IsDynamic();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AwaitExpressionInfo other);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.CSharp.AwaitExpressionSpiller : BoundTreeRewriterWithStackGuard {
    private static BoundKind SpillSequenceBuilder;
    private SyntheticBoundNodeFactory _F;
    private PooledDictionary`2<LocalSymbol, LocalSymbol> _tempSubstitution;
    private AwaitExpressionSpiller(MethodSymbol method, CSharpSyntaxNode syntaxNode, TypeCompilationState compilationState, PooledDictionary`2<LocalSymbol, LocalSymbol> tempSubstitution, DiagnosticBag diagnostics);
    internal static BoundStatement Rewrite(BoundStatement body, MethodSymbol method, TypeCompilationState compilationState, DiagnosticBag diagnostics);
    private BoundExpression VisitExpression(BoundSpillSequenceBuilder& builder, BoundExpression expression);
    private static BoundExpression UpdateExpression(BoundSpillSequenceBuilder builder, BoundExpression expression);
    private BoundStatement UpdateStatement(BoundSpillSequenceBuilder builder, BoundStatement statement, bool substituteTemps);
    private BoundExpression Spill(BoundSpillSequenceBuilder builder, BoundExpression expression, RefKind refKind, bool sideEffectsOnly);
    private ImmutableArray`1<BoundExpression> VisitExpressionList(BoundSpillSequenceBuilder& builder, ImmutableArray`1<BoundExpression> args, ImmutableArray`1<RefKind> refKinds, bool forceSpill, bool sideEffectsOnly);
    private void EnterStatement(BoundNode boundStatement);
    public virtual BoundNode VisitSwitchStatement(BoundSwitchStatement node);
    public virtual BoundNode VisitThrowStatement(BoundThrowStatement node);
    public virtual BoundNode VisitExpressionStatement(BoundExpressionStatement node);
    public virtual BoundNode VisitConditionalGoto(BoundConditionalGoto node);
    public virtual BoundNode VisitReturnStatement(BoundReturnStatement node);
    public virtual BoundNode VisitAwaitExpression(BoundAwaitExpression node);
    public virtual BoundNode VisitAddressOfOperator(BoundAddressOfOperator node);
    public virtual BoundNode VisitArgListOperator(BoundArgListOperator node);
    public virtual BoundNode VisitArrayAccess(BoundArrayAccess node);
    public virtual BoundNode VisitArrayCreation(BoundArrayCreation node);
    public virtual BoundNode VisitArrayInitialization(BoundArrayInitialization node);
    public virtual BoundNode VisitArrayLength(BoundArrayLength node);
    public virtual BoundNode VisitAsOperator(BoundAsOperator node);
    public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node);
    public virtual BoundNode VisitBadExpression(BoundBadExpression node);
    public virtual BoundNode VisitUserDefinedConditionalLogicalOperator(BoundUserDefinedConditionalLogicalOperator node);
    public virtual BoundNode VisitBinaryOperator(BoundBinaryOperator node);
    public virtual BoundNode VisitCall(BoundCall node);
    private static RefKind ReceiverSpillRefKind(BoundExpression receiver);
    public virtual BoundNode VisitConditionalOperator(BoundConditionalOperator node);
    public virtual BoundNode VisitConversion(BoundConversion node);
    public virtual BoundNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node);
    public virtual BoundNode VisitFieldAccess(BoundFieldAccess node);
    public virtual BoundNode VisitIsOperator(BoundIsOperator node);
    public virtual BoundNode VisitMakeRefOperator(BoundMakeRefOperator node);
    public virtual BoundNode VisitNullCoalescingOperator(BoundNullCoalescingOperator node);
    public virtual BoundNode VisitLoweredConditionalAccess(BoundLoweredConditionalAccess node);
    public virtual BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node);
    public virtual BoundNode VisitPointerElementAccess(BoundPointerElementAccess node);
    public virtual BoundNode VisitPointerIndirectionOperator(BoundPointerIndirectionOperator node);
    public virtual BoundNode VisitSequence(BoundSequence node);
    private void PromoteAndAddLocals(BoundSpillSequenceBuilder builder, ImmutableArray`1<LocalSymbol> locals);
    public virtual BoundNode VisitUnaryOperator(BoundUnaryOperator node);
}
internal class Microsoft.CodeAnalysis.CSharp.BestIndex : ValueType {
    internal BestIndexKind Kind;
    internal int Best;
    internal int Ambiguous1;
    internal int Ambiguous2;
    private BestIndex(BestIndexKind kind, int best, int ambig1, int ambig2);
    public static BestIndex None();
    public static BestIndex HasBest(int best);
    public static BestIndex IsAmbiguous(int ambig1, int ambig2);
}
internal enum Microsoft.CodeAnalysis.CSharp.BestIndexKind : Enum {
    public int value__;
    public static BestIndexKind None;
    public static BestIndexKind Best;
    public static BestIndexKind Ambiguous;
}
internal class Microsoft.CodeAnalysis.CSharp.BestTypeInferrer : object {
    private ConversionsBase _conversions;
    private BestTypeInferrer(ConversionsBase conversions);
    public static TypeSymbol InferBestType(ImmutableArray`1<TypeSymbol> types, ConversionsBase conversions, HashSet`1& useSiteDiagnostics);
    public static TypeSymbol InferBestType(ImmutableArray`1<BoundExpression> exprs, ConversionsBase conversions, Boolean& hadMultipleCandidates, HashSet`1& useSiteDiagnostics);
    public static TypeSymbol InferBestTypeForConditionalOperator(BoundExpression expr1, BoundExpression expr2, ConversionsBase conversions, Boolean& hadMultipleCandidates, HashSet`1& useSiteDiagnostics);
    private TypeSymbol GetBestType(ImmutableArray`1<TypeSymbol> types, HashSet`1& useSiteDiagnostics);
    private TypeSymbol Better(TypeSymbol type1, TypeSymbol type2, HashSet`1& useSiteDiagnostics);
}
internal enum Microsoft.CodeAnalysis.CSharp.BetterResult : Enum {
    public int value__;
    public static BetterResult Left;
    public static BetterResult Right;
    public static BetterResult Neither;
    public static BetterResult Equal;
}
internal class Microsoft.CodeAnalysis.CSharp.BinaryOperatorAnalysisResult : ValueType {
    public Conversion LeftConversion;
    public Conversion RightConversion;
    public BinaryOperatorSignature Signature;
    public OperatorAnalysisResultKind Kind;
    public bool IsValid { get; }
    public bool HasValue { get; }
    private BinaryOperatorAnalysisResult(OperatorAnalysisResultKind kind, BinaryOperatorSignature signature, Conversion leftConversion, Conversion rightConversion);
    public bool get_IsValid();
    public bool get_HasValue();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static BinaryOperatorAnalysisResult Applicable(BinaryOperatorSignature signature, Conversion leftConversion, Conversion rightConversion);
    public static BinaryOperatorAnalysisResult Inapplicable(BinaryOperatorSignature signature, Conversion leftConversion, Conversion rightConversion);
    public BinaryOperatorAnalysisResult Worse();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind : Enum {
    public int value__;
    public static BinaryOperatorKind TypeMask;
    public static BinaryOperatorKind Int;
    public static BinaryOperatorKind UInt;
    public static BinaryOperatorKind Long;
    public static BinaryOperatorKind ULong;
    public static BinaryOperatorKind Char;
    public static BinaryOperatorKind Float;
    public static BinaryOperatorKind Double;
    public static BinaryOperatorKind Decimal;
    public static BinaryOperatorKind Bool;
    public static BinaryOperatorKind Object;
    public static BinaryOperatorKind String;
    public static BinaryOperatorKind StringAndObject;
    public static BinaryOperatorKind ObjectAndString;
    public static BinaryOperatorKind Enum;
    public static BinaryOperatorKind EnumAndUnderlying;
    public static BinaryOperatorKind UnderlyingAndEnum;
    public static BinaryOperatorKind Delegate;
    public static BinaryOperatorKind Pointer;
    public static BinaryOperatorKind PointerAndInt;
    public static BinaryOperatorKind PointerAndUInt;
    public static BinaryOperatorKind PointerAndLong;
    public static BinaryOperatorKind PointerAndULong;
    public static BinaryOperatorKind IntAndPointer;
    public static BinaryOperatorKind UIntAndPointer;
    public static BinaryOperatorKind LongAndPointer;
    public static BinaryOperatorKind ULongAndPointer;
    public static BinaryOperatorKind NullableNull;
    public static BinaryOperatorKind UserDefined;
    public static BinaryOperatorKind Dynamic;
    public static BinaryOperatorKind OpMask;
    public static BinaryOperatorKind Multiplication;
    public static BinaryOperatorKind Addition;
    public static BinaryOperatorKind Subtraction;
    public static BinaryOperatorKind Division;
    public static BinaryOperatorKind Remainder;
    public static BinaryOperatorKind LeftShift;
    public static BinaryOperatorKind RightShift;
    public static BinaryOperatorKind Equal;
    public static BinaryOperatorKind NotEqual;
    public static BinaryOperatorKind GreaterThan;
    public static BinaryOperatorKind LessThan;
    public static BinaryOperatorKind GreaterThanOrEqual;
    public static BinaryOperatorKind LessThanOrEqual;
    public static BinaryOperatorKind And;
    public static BinaryOperatorKind Xor;
    public static BinaryOperatorKind Or;
    public static BinaryOperatorKind Lifted;
    public static BinaryOperatorKind Logical;
    public static BinaryOperatorKind Checked;
    public static BinaryOperatorKind Error;
    public static BinaryOperatorKind IntMultiplication;
    public static BinaryOperatorKind UIntMultiplication;
    public static BinaryOperatorKind LongMultiplication;
    public static BinaryOperatorKind ULongMultiplication;
    public static BinaryOperatorKind FloatMultiplication;
    public static BinaryOperatorKind DoubleMultiplication;
    public static BinaryOperatorKind DecimalMultiplication;
    public static BinaryOperatorKind UserDefinedMultiplication;
    public static BinaryOperatorKind LiftedIntMultiplication;
    public static BinaryOperatorKind LiftedUIntMultiplication;
    public static BinaryOperatorKind LiftedLongMultiplication;
    public static BinaryOperatorKind LiftedULongMultiplication;
    public static BinaryOperatorKind LiftedFloatMultiplication;
    public static BinaryOperatorKind LiftedDoubleMultiplication;
    public static BinaryOperatorKind LiftedDecimalMultiplication;
    public static BinaryOperatorKind LiftedUserDefinedMultiplication;
    public static BinaryOperatorKind DynamicMultiplication;
    public static BinaryOperatorKind IntDivision;
    public static BinaryOperatorKind UIntDivision;
    public static BinaryOperatorKind LongDivision;
    public static BinaryOperatorKind ULongDivision;
    public static BinaryOperatorKind FloatDivision;
    public static BinaryOperatorKind DoubleDivision;
    public static BinaryOperatorKind DecimalDivision;
    public static BinaryOperatorKind UserDefinedDivision;
    public static BinaryOperatorKind LiftedIntDivision;
    public static BinaryOperatorKind LiftedUIntDivision;
    public static BinaryOperatorKind LiftedLongDivision;
    public static BinaryOperatorKind LiftedULongDivision;
    public static BinaryOperatorKind LiftedFloatDivision;
    public static BinaryOperatorKind LiftedDoubleDivision;
    public static BinaryOperatorKind LiftedDecimalDivision;
    public static BinaryOperatorKind LiftedUserDefinedDivision;
    public static BinaryOperatorKind DynamicDivision;
    public static BinaryOperatorKind IntRemainder;
    public static BinaryOperatorKind UIntRemainder;
    public static BinaryOperatorKind LongRemainder;
    public static BinaryOperatorKind ULongRemainder;
    public static BinaryOperatorKind FloatRemainder;
    public static BinaryOperatorKind DoubleRemainder;
    public static BinaryOperatorKind DecimalRemainder;
    public static BinaryOperatorKind UserDefinedRemainder;
    public static BinaryOperatorKind LiftedIntRemainder;
    public static BinaryOperatorKind LiftedUIntRemainder;
    public static BinaryOperatorKind LiftedLongRemainder;
    public static BinaryOperatorKind LiftedULongRemainder;
    public static BinaryOperatorKind LiftedFloatRemainder;
    public static BinaryOperatorKind LiftedDoubleRemainder;
    public static BinaryOperatorKind LiftedDecimalRemainder;
    public static BinaryOperatorKind LiftedUserDefinedRemainder;
    public static BinaryOperatorKind DynamicRemainder;
    public static BinaryOperatorKind IntAddition;
    public static BinaryOperatorKind UIntAddition;
    public static BinaryOperatorKind LongAddition;
    public static BinaryOperatorKind ULongAddition;
    public static BinaryOperatorKind FloatAddition;
    public static BinaryOperatorKind DoubleAddition;
    public static BinaryOperatorKind DecimalAddition;
    public static BinaryOperatorKind EnumAndUnderlyingAddition;
    public static BinaryOperatorKind UnderlyingAndEnumAddition;
    public static BinaryOperatorKind UserDefinedAddition;
    public static BinaryOperatorKind LiftedIntAddition;
    public static BinaryOperatorKind LiftedUIntAddition;
    public static BinaryOperatorKind LiftedLongAddition;
    public static BinaryOperatorKind LiftedULongAddition;
    public static BinaryOperatorKind LiftedFloatAddition;
    public static BinaryOperatorKind LiftedDoubleAddition;
    public static BinaryOperatorKind LiftedDecimalAddition;
    public static BinaryOperatorKind LiftedEnumAndUnderlyingAddition;
    public static BinaryOperatorKind LiftedUnderlyingAndEnumAddition;
    public static BinaryOperatorKind LiftedUserDefinedAddition;
    public static BinaryOperatorKind PointerAndIntAddition;
    public static BinaryOperatorKind PointerAndUIntAddition;
    public static BinaryOperatorKind PointerAndLongAddition;
    public static BinaryOperatorKind PointerAndULongAddition;
    public static BinaryOperatorKind IntAndPointerAddition;
    public static BinaryOperatorKind UIntAndPointerAddition;
    public static BinaryOperatorKind LongAndPointerAddition;
    public static BinaryOperatorKind ULongAndPointerAddition;
    public static BinaryOperatorKind StringConcatenation;
    public static BinaryOperatorKind StringAndObjectConcatenation;
    public static BinaryOperatorKind ObjectAndStringConcatenation;
    public static BinaryOperatorKind DelegateCombination;
    public static BinaryOperatorKind DynamicAddition;
    public static BinaryOperatorKind IntSubtraction;
    public static BinaryOperatorKind UIntSubtraction;
    public static BinaryOperatorKind LongSubtraction;
    public static BinaryOperatorKind ULongSubtraction;
    public static BinaryOperatorKind FloatSubtraction;
    public static BinaryOperatorKind DoubleSubtraction;
    public static BinaryOperatorKind DecimalSubtraction;
    public static BinaryOperatorKind EnumSubtraction;
    public static BinaryOperatorKind EnumAndUnderlyingSubtraction;
    public static BinaryOperatorKind UnderlyingAndEnumSubtraction;
    public static BinaryOperatorKind UserDefinedSubtraction;
    public static BinaryOperatorKind LiftedIntSubtraction;
    public static BinaryOperatorKind LiftedUIntSubtraction;
    public static BinaryOperatorKind LiftedLongSubtraction;
    public static BinaryOperatorKind LiftedULongSubtraction;
    public static BinaryOperatorKind LiftedFloatSubtraction;
    public static BinaryOperatorKind LiftedDoubleSubtraction;
    public static BinaryOperatorKind LiftedDecimalSubtraction;
    public static BinaryOperatorKind LiftedEnumSubtraction;
    public static BinaryOperatorKind LiftedEnumAndUnderlyingSubtraction;
    public static BinaryOperatorKind LiftedUnderlyingAndEnumSubtraction;
    public static BinaryOperatorKind LiftedUserDefinedSubtraction;
    public static BinaryOperatorKind DelegateRemoval;
    public static BinaryOperatorKind PointerAndIntSubtraction;
    public static BinaryOperatorKind PointerAndUIntSubtraction;
    public static BinaryOperatorKind PointerAndLongSubtraction;
    public static BinaryOperatorKind PointerAndULongSubtraction;
    public static BinaryOperatorKind PointerSubtraction;
    public static BinaryOperatorKind DynamicSubtraction;
    public static BinaryOperatorKind IntLeftShift;
    public static BinaryOperatorKind UIntLeftShift;
    public static BinaryOperatorKind LongLeftShift;
    public static BinaryOperatorKind ULongLeftShift;
    public static BinaryOperatorKind UserDefinedLeftShift;
    public static BinaryOperatorKind LiftedIntLeftShift;
    public static BinaryOperatorKind LiftedUIntLeftShift;
    public static BinaryOperatorKind LiftedLongLeftShift;
    public static BinaryOperatorKind LiftedULongLeftShift;
    public static BinaryOperatorKind LiftedUserDefinedLeftShift;
    public static BinaryOperatorKind DynamicLeftShift;
    public static BinaryOperatorKind IntRightShift;
    public static BinaryOperatorKind UIntRightShift;
    public static BinaryOperatorKind LongRightShift;
    public static BinaryOperatorKind ULongRightShift;
    public static BinaryOperatorKind UserDefinedRightShift;
    public static BinaryOperatorKind LiftedIntRightShift;
    public static BinaryOperatorKind LiftedUIntRightShift;
    public static BinaryOperatorKind LiftedLongRightShift;
    public static BinaryOperatorKind LiftedULongRightShift;
    public static BinaryOperatorKind LiftedUserDefinedRightShift;
    public static BinaryOperatorKind DynamicRightShift;
    public static BinaryOperatorKind IntEqual;
    public static BinaryOperatorKind UIntEqual;
    public static BinaryOperatorKind LongEqual;
    public static BinaryOperatorKind ULongEqual;
    public static BinaryOperatorKind FloatEqual;
    public static BinaryOperatorKind DoubleEqual;
    public static BinaryOperatorKind DecimalEqual;
    public static BinaryOperatorKind BoolEqual;
    public static BinaryOperatorKind EnumEqual;
    public static BinaryOperatorKind NullableNullEqual;
    public static BinaryOperatorKind UserDefinedEqual;
    public static BinaryOperatorKind LiftedIntEqual;
    public static BinaryOperatorKind LiftedUIntEqual;
    public static BinaryOperatorKind LiftedLongEqual;
    public static BinaryOperatorKind LiftedULongEqual;
    public static BinaryOperatorKind LiftedFloatEqual;
    public static BinaryOperatorKind LiftedDoubleEqual;
    public static BinaryOperatorKind LiftedDecimalEqual;
    public static BinaryOperatorKind LiftedBoolEqual;
    public static BinaryOperatorKind LiftedEnumEqual;
    public static BinaryOperatorKind LiftedUserDefinedEqual;
    public static BinaryOperatorKind ObjectEqual;
    public static BinaryOperatorKind StringEqual;
    public static BinaryOperatorKind DelegateEqual;
    public static BinaryOperatorKind PointerEqual;
    public static BinaryOperatorKind DynamicEqual;
    public static BinaryOperatorKind IntNotEqual;
    public static BinaryOperatorKind UIntNotEqual;
    public static BinaryOperatorKind LongNotEqual;
    public static BinaryOperatorKind ULongNotEqual;
    public static BinaryOperatorKind FloatNotEqual;
    public static BinaryOperatorKind DoubleNotEqual;
    public static BinaryOperatorKind DecimalNotEqual;
    public static BinaryOperatorKind BoolNotEqual;
    public static BinaryOperatorKind EnumNotEqual;
    public static BinaryOperatorKind NullableNullNotEqual;
    public static BinaryOperatorKind UserDefinedNotEqual;
    public static BinaryOperatorKind LiftedIntNotEqual;
    public static BinaryOperatorKind LiftedUIntNotEqual;
    public static BinaryOperatorKind LiftedLongNotEqual;
    public static BinaryOperatorKind LiftedULongNotEqual;
    public static BinaryOperatorKind LiftedFloatNotEqual;
    public static BinaryOperatorKind LiftedDoubleNotEqual;
    public static BinaryOperatorKind LiftedDecimalNotEqual;
    public static BinaryOperatorKind LiftedBoolNotEqual;
    public static BinaryOperatorKind LiftedEnumNotEqual;
    public static BinaryOperatorKind LiftedUserDefinedNotEqual;
    public static BinaryOperatorKind ObjectNotEqual;
    public static BinaryOperatorKind StringNotEqual;
    public static BinaryOperatorKind DelegateNotEqual;
    public static BinaryOperatorKind PointerNotEqual;
    public static BinaryOperatorKind DynamicNotEqual;
    public static BinaryOperatorKind IntLessThan;
    public static BinaryOperatorKind UIntLessThan;
    public static BinaryOperatorKind LongLessThan;
    public static BinaryOperatorKind ULongLessThan;
    public static BinaryOperatorKind FloatLessThan;
    public static BinaryOperatorKind DoubleLessThan;
    public static BinaryOperatorKind DecimalLessThan;
    public static BinaryOperatorKind EnumLessThan;
    public static BinaryOperatorKind UserDefinedLessThan;
    public static BinaryOperatorKind LiftedIntLessThan;
    public static BinaryOperatorKind LiftedUIntLessThan;
    public static BinaryOperatorKind LiftedLongLessThan;
    public static BinaryOperatorKind LiftedULongLessThan;
    public static BinaryOperatorKind LiftedFloatLessThan;
    public static BinaryOperatorKind LiftedDoubleLessThan;
    public static BinaryOperatorKind LiftedDecimalLessThan;
    public static BinaryOperatorKind LiftedEnumLessThan;
    public static BinaryOperatorKind LiftedUserDefinedLessThan;
    public static BinaryOperatorKind PointerLessThan;
    public static BinaryOperatorKind DynamicLessThan;
    public static BinaryOperatorKind IntGreaterThan;
    public static BinaryOperatorKind UIntGreaterThan;
    public static BinaryOperatorKind LongGreaterThan;
    public static BinaryOperatorKind ULongGreaterThan;
    public static BinaryOperatorKind FloatGreaterThan;
    public static BinaryOperatorKind DoubleGreaterThan;
    public static BinaryOperatorKind DecimalGreaterThan;
    public static BinaryOperatorKind EnumGreaterThan;
    public static BinaryOperatorKind UserDefinedGreaterThan;
    public static BinaryOperatorKind LiftedIntGreaterThan;
    public static BinaryOperatorKind LiftedUIntGreaterThan;
    public static BinaryOperatorKind LiftedLongGreaterThan;
    public static BinaryOperatorKind LiftedULongGreaterThan;
    public static BinaryOperatorKind LiftedFloatGreaterThan;
    public static BinaryOperatorKind LiftedDoubleGreaterThan;
    public static BinaryOperatorKind LiftedDecimalGreaterThan;
    public static BinaryOperatorKind LiftedEnumGreaterThan;
    public static BinaryOperatorKind LiftedUserDefinedGreaterThan;
    public static BinaryOperatorKind PointerGreaterThan;
    public static BinaryOperatorKind DynamicGreaterThan;
    public static BinaryOperatorKind IntLessThanOrEqual;
    public static BinaryOperatorKind UIntLessThanOrEqual;
    public static BinaryOperatorKind LongLessThanOrEqual;
    public static BinaryOperatorKind ULongLessThanOrEqual;
    public static BinaryOperatorKind FloatLessThanOrEqual;
    public static BinaryOperatorKind DoubleLessThanOrEqual;
    public static BinaryOperatorKind DecimalLessThanOrEqual;
    public static BinaryOperatorKind EnumLessThanOrEqual;
    public static BinaryOperatorKind UserDefinedLessThanOrEqual;
    public static BinaryOperatorKind LiftedIntLessThanOrEqual;
    public static BinaryOperatorKind LiftedUIntLessThanOrEqual;
    public static BinaryOperatorKind LiftedLongLessThanOrEqual;
    public static BinaryOperatorKind LiftedULongLessThanOrEqual;
    public static BinaryOperatorKind LiftedFloatLessThanOrEqual;
    public static BinaryOperatorKind LiftedDoubleLessThanOrEqual;
    public static BinaryOperatorKind LiftedDecimalLessThanOrEqual;
    public static BinaryOperatorKind LiftedEnumLessThanOrEqual;
    public static BinaryOperatorKind LiftedUserDefinedLessThanOrEqual;
    public static BinaryOperatorKind PointerLessThanOrEqual;
    public static BinaryOperatorKind DynamicLessThanOrEqual;
    public static BinaryOperatorKind IntGreaterThanOrEqual;
    public static BinaryOperatorKind UIntGreaterThanOrEqual;
    public static BinaryOperatorKind LongGreaterThanOrEqual;
    public static BinaryOperatorKind ULongGreaterThanOrEqual;
    public static BinaryOperatorKind FloatGreaterThanOrEqual;
    public static BinaryOperatorKind DoubleGreaterThanOrEqual;
    public static BinaryOperatorKind DecimalGreaterThanOrEqual;
    public static BinaryOperatorKind EnumGreaterThanOrEqual;
    public static BinaryOperatorKind UserDefinedGreaterThanOrEqual;
    public static BinaryOperatorKind LiftedIntGreaterThanOrEqual;
    public static BinaryOperatorKind LiftedUIntGreaterThanOrEqual;
    public static BinaryOperatorKind LiftedLongGreaterThanOrEqual;
    public static BinaryOperatorKind LiftedULongGreaterThanOrEqual;
    public static BinaryOperatorKind LiftedFloatGreaterThanOrEqual;
    public static BinaryOperatorKind LiftedDoubleGreaterThanOrEqual;
    public static BinaryOperatorKind LiftedDecimalGreaterThanOrEqual;
    public static BinaryOperatorKind LiftedEnumGreaterThanOrEqual;
    public static BinaryOperatorKind LiftedUserDefinedGreaterThanOrEqual;
    public static BinaryOperatorKind PointerGreaterThanOrEqual;
    public static BinaryOperatorKind DynamicGreaterThanOrEqual;
    public static BinaryOperatorKind IntAnd;
    public static BinaryOperatorKind UIntAnd;
    public static BinaryOperatorKind LongAnd;
    public static BinaryOperatorKind ULongAnd;
    public static BinaryOperatorKind EnumAnd;
    public static BinaryOperatorKind BoolAnd;
    public static BinaryOperatorKind UserDefinedAnd;
    public static BinaryOperatorKind LiftedIntAnd;
    public static BinaryOperatorKind LiftedUIntAnd;
    public static BinaryOperatorKind LiftedLongAnd;
    public static BinaryOperatorKind LiftedULongAnd;
    public static BinaryOperatorKind LiftedEnumAnd;
    public static BinaryOperatorKind LiftedBoolAnd;
    public static BinaryOperatorKind LiftedUserDefinedAnd;
    public static BinaryOperatorKind DynamicAnd;
    public static BinaryOperatorKind LogicalAnd;
    public static BinaryOperatorKind LogicalBoolAnd;
    public static BinaryOperatorKind LogicalUserDefinedAnd;
    public static BinaryOperatorKind DynamicLogicalAnd;
    public static BinaryOperatorKind IntOr;
    public static BinaryOperatorKind UIntOr;
    public static BinaryOperatorKind LongOr;
    public static BinaryOperatorKind ULongOr;
    public static BinaryOperatorKind EnumOr;
    public static BinaryOperatorKind BoolOr;
    public static BinaryOperatorKind UserDefinedOr;
    public static BinaryOperatorKind LiftedIntOr;
    public static BinaryOperatorKind LiftedUIntOr;
    public static BinaryOperatorKind LiftedLongOr;
    public static BinaryOperatorKind LiftedULongOr;
    public static BinaryOperatorKind LiftedEnumOr;
    public static BinaryOperatorKind LiftedBoolOr;
    public static BinaryOperatorKind LiftedUserDefinedOr;
    public static BinaryOperatorKind DynamicOr;
    public static BinaryOperatorKind LogicalOr;
    public static BinaryOperatorKind LogicalBoolOr;
    public static BinaryOperatorKind LogicalUserDefinedOr;
    public static BinaryOperatorKind DynamicLogicalOr;
    public static BinaryOperatorKind IntXor;
    public static BinaryOperatorKind UIntXor;
    public static BinaryOperatorKind LongXor;
    public static BinaryOperatorKind ULongXor;
    public static BinaryOperatorKind EnumXor;
    public static BinaryOperatorKind BoolXor;
    public static BinaryOperatorKind UserDefinedXor;
    public static BinaryOperatorKind LiftedIntXor;
    public static BinaryOperatorKind LiftedUIntXor;
    public static BinaryOperatorKind LiftedLongXor;
    public static BinaryOperatorKind LiftedULongXor;
    public static BinaryOperatorKind LiftedEnumXor;
    public static BinaryOperatorKind LiftedBoolXor;
    public static BinaryOperatorKind LiftedUserDefinedXor;
    public static BinaryOperatorKind DynamicXor;
}
internal class Microsoft.CodeAnalysis.CSharp.BinaryOperatorOverloadResolutionResult : object {
    public ArrayBuilder`1<BinaryOperatorAnalysisResult> Results;
    public static ObjectPool`1<BinaryOperatorOverloadResolutionResult> Pool;
    public BinaryOperatorAnalysisResult Best { get; }
    private static BinaryOperatorOverloadResolutionResult();
    public bool AnyValid();
    public int GetValidCount();
    public BinaryOperatorAnalysisResult get_Best();
    public static BinaryOperatorOverloadResolutionResult GetInstance();
    public void Free();
    private static ObjectPool`1<BinaryOperatorOverloadResolutionResult> CreatePool();
}
internal class Microsoft.CodeAnalysis.CSharp.BinaryOperatorSignature : ValueType {
    public static BinaryOperatorSignature Error;
    public TypeSymbol LeftType;
    public TypeSymbol RightType;
    public TypeSymbol ReturnType;
    public MethodSymbol Method;
    public BinaryOperatorKind Kind;
    public Nullable`1<int> Priority;
    public BinaryOperatorSignature(BinaryOperatorKind kind, TypeSymbol leftType, TypeSymbol rightType, TypeSymbol returnType, MethodSymbol method);
    private static BinaryOperatorSignature();
    public virtual string ToString();
    public sealed virtual bool Equals(BinaryOperatorSignature other);
    public static bool op_Equality(BinaryOperatorSignature x, BinaryOperatorSignature y);
    public static bool op_Inequality(BinaryOperatorSignature x, BinaryOperatorSignature y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.CSharp.Binder : object {
    [CompilerGeneratedAttribute]
private CSharpCompilation <Compilation>k__BackingField;
    private Binder _next;
    internal BinderFlags Flags;
    private Conversions _lazyConversions;
    private OverloadResolution _lazyOverloadResolution;
    private static Func`2<PropertySymbol, bool> s_isIndexedPropertyWithNonOptionalArguments;
    private static SymbolDisplayFormat s_propertyGroupFormat;
    private static string transparentIdentifierPrefix;
    private static Func`2<Symbol, MethodSymbol> s_toMethodSymbolFunc;
    private static Func`2<Symbol, PropertySymbol> s_toPropertySymbolFunc;
    internal CSharpCompilation Compilation { get; }
    internal bool IsSemanticModelBinder { get; }
    internal bool IsEarlyAttributeBinder { get; }
    protected SyntaxNode EnclosingNameofArgument { get; }
    protected internal Binder Next { get; }
    protected OverflowChecks CheckOverflow { get; }
    protected bool CheckOverflowAtRuntime { get; }
    internal bool CheckOverflowAtCompileTime { get; }
    internal Symbol ContainingMemberOrLambda { get; }
    internal bool IsInMethodBody { get; }
    internal bool IsDirectlyInIterator { get; }
    internal bool IsIndirectlyInIterator { get; }
    internal GeneratedLabelSymbol BreakLabel { get; }
    internal GeneratedLabelSymbol ContinueLabel { get; }
    public ConsList`1<LocalSymbol> ImplicitlyTypedLocalsBeingBound { get; }
    internal ImportChain ImportChain { get; }
    internal NamedTypeSymbol ContainingType { get; }
    internal bool BindingTopLevelScriptCode { get; }
    internal ConstantFieldsInProgress ConstantFieldsInProgress { get; }
    internal ConsList`1<FieldSymbol> FieldsBeingBound { get; }
    internal LocalSymbol LocalInProgress { get; }
    internal BoundExpression ConditionalReceiverExpression { get; }
    internal Conversions Conversions { get; }
    internal OverloadResolution OverloadResolution { get; }
    private bool ContextForbidsAwait { get; }
    internal bool InFieldInitializer { get; }
    internal bool InParameterDefaultValue { get; }
    protected bool InConstructorInitializer { get; }
    internal bool InAttributeArgument { get; }
    internal bool InCref { get; }
    protected bool InCrefButNotParameterOrReturnType { get; }
    internal bool SupportsExtensionMethods { get; }
    internal ImmutableHashSet`1<Symbol> LockedOrDisposedVariables { get; }
    internal ImmutableArray`1<LocalSymbol> Locals { get; }
    internal ImmutableArray`1<LabelSymbol> Labels { get; }
    private bool ShouldCheckConstraints { get; }
    internal bool InUnsafeRegion { get; }
    internal Binder(CSharpCompilation compilation);
    internal Binder(Binder next);
    protected Binder(Binder next, BinderFlags flags);
    private static Binder();
    [CompilerGeneratedAttribute]
internal CSharpCompilation get_Compilation();
    internal bool get_IsSemanticModelBinder();
    internal bool get_IsEarlyAttributeBinder();
    protected virtual SyntaxNode get_EnclosingNameofArgument();
    protected internal Binder get_Next();
    protected OverflowChecks get_CheckOverflow();
    protected bool get_CheckOverflowAtRuntime();
    internal bool get_CheckOverflowAtCompileTime();
    internal virtual Binder GetBinder(CSharpSyntaxNode node);
    internal virtual ImmutableArray`1<LocalSymbol> GetDeclaredLocalsForScope(CSharpSyntaxNode node);
    internal virtual Symbol get_ContainingMemberOrLambda();
    internal virtual bool get_IsInMethodBody();
    internal virtual bool get_IsDirectlyInIterator();
    internal virtual bool get_IsIndirectlyInIterator();
    internal virtual GeneratedLabelSymbol get_BreakLabel();
    internal virtual GeneratedLabelSymbol get_ContinueLabel();
    internal virtual TypeSymbol GetIteratorElementType(YieldStatementSyntax node, DiagnosticBag diagnostics);
    public virtual ConsList`1<LocalSymbol> get_ImplicitlyTypedLocalsBeingBound();
    internal virtual ImportChain get_ImportChain();
    internal virtual Imports GetImports(ConsList`1<Symbol> basesBeingResolved);
    internal NamedTypeSymbol get_ContainingType();
    internal bool get_BindingTopLevelScriptCode();
    internal virtual ConstantFieldsInProgress get_ConstantFieldsInProgress();
    internal virtual ConsList`1<FieldSymbol> get_FieldsBeingBound();
    internal virtual LocalSymbol get_LocalInProgress();
    internal virtual BoundExpression get_ConditionalReceiverExpression();
    internal Conversions get_Conversions();
    internal OverloadResolution get_OverloadResolution();
    internal static void Error(DiagnosticBag diagnostics, DiagnosticInfo info, CSharpSyntaxNode syntax);
    internal static void Error(DiagnosticBag diagnostics, DiagnosticInfo info, Location location);
    internal static void Error(DiagnosticBag diagnostics, ErrorCode code, CSharpSyntaxNode syntax);
    internal static void Error(DiagnosticBag diagnostics, ErrorCode code, CSharpSyntaxNode syntax, Object[] args);
    internal static void Error(DiagnosticBag diagnostics, ErrorCode code, SyntaxToken token);
    internal static void Error(DiagnosticBag diagnostics, ErrorCode code, SyntaxToken token, Object[] args);
    internal static void Error(DiagnosticBag diagnostics, ErrorCode code, SyntaxNodeOrToken syntax);
    internal static void Error(DiagnosticBag diagnostics, ErrorCode code, SyntaxNodeOrToken syntax, Object[] args);
    internal static void Error(DiagnosticBag diagnostics, ErrorCode code, Location location);
    internal static void Error(DiagnosticBag diagnostics, ErrorCode code, Location location, Object[] args);
    internal void ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics, Symbol symbol, SyntaxNodeOrToken node, bool hasBaseReceiver);
    internal void ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics, Conversion conversion, SyntaxNodeOrToken node, bool hasBaseReceiver);
    internal static void ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics, Symbol symbol, SyntaxNodeOrToken node, bool hasBaseReceiver, Symbol containingMember, NamedTypeSymbol containingType, BinderFlags location);
    private static ThreeState ReportDiagnosticsIfObsoleteInternal(DiagnosticBag diagnostics, Symbol symbol, SyntaxNodeOrToken node, Symbol containingMember, BinderFlags location);
    internal void ResolveOverloads(ImmutableArray`1<TMember> members, ImmutableArray`1<TypeSymbol> typeArguments, ImmutableArray`1<ArgumentSyntax> arguments, OverloadResolutionResult`1<TMember> result, HashSet`1& useSiteDiagnostics, bool allowRefOmittedArguments);
    internal bool IsSymbolAccessibleConditional(Symbol symbol, AssemblySymbol within, HashSet`1& useSiteDiagnostics);
    internal bool IsSymbolAccessibleConditional(Symbol symbol, NamedTypeSymbol within, HashSet`1& useSiteDiagnostics, TypeSymbol throughTypeOpt);
    internal bool IsSymbolAccessibleConditional(Symbol symbol, NamedTypeSymbol within, TypeSymbol throughTypeOpt, Boolean& failedThroughTypeCheck, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    internal static void ReportUseSiteDiagnosticForSynthesizedAttribute(CSharpCompilation compilation, WellKnownMember attributeMember, DiagnosticBag diagnostics, Location location, CSharpSyntaxNode syntax);
    private BoundExpression BindAnonymousObjectCreation(AnonymousObjectCreationExpressionSyntax node, DiagnosticBag diagnostics);
    private bool IsAnonymousTypesAllowed();
    private TypeSymbol GetAnonymousTypeFieldType(BoundExpression expression, CSharpSyntaxNode errorSyntax, DiagnosticBag diagnostics, Boolean& hasError);
    internal static void BindAttributeTypes(ImmutableArray`1<Binder> binders, ImmutableArray`1<AttributeSyntax> attributesToBind, Symbol ownerSymbol, NamedTypeSymbol[] boundAttributeTypes, DiagnosticBag diagnostics);
    internal static void GetAttributes(ImmutableArray`1<Binder> binders, ImmutableArray`1<AttributeSyntax> attributesToBind, ImmutableArray`1<NamedTypeSymbol> boundAttributeTypes, CSharpAttributeData[] attributesBuilder, DiagnosticBag diagnostics);
    internal CSharpAttributeData GetAttribute(AttributeSyntax node, NamedTypeSymbol boundAttributeType, DiagnosticBag diagnostics);
    internal BoundAttribute BindAttribute(AttributeSyntax node, NamedTypeSymbol attributeType, DiagnosticBag diagnostics);
    private CSharpAttributeData GetAttribute(BoundAttribute boundAttribute, DiagnosticBag diagnostics);
    private void ValidateTypeForAttributeParameters(ImmutableArray`1<ParameterSymbol> parameters, CSharpSyntaxNode syntax, DiagnosticBag diagnostics, Boolean& hasErrors);
    protected virtual bool IsAttributeConditionallyOmitted(NamedTypeSymbol attributeType, SyntaxTree syntaxTree, HashSet`1& useSiteDiagnostics);
    private AnalyzedAttributeArguments BindAttributeArguments(AttributeArgumentListSyntax attributeArgumentList, NamedTypeSymbol attributeType, DiagnosticBag diagnostics);
    private BoundExpression BindNamedAttributeArgument(AttributeArgumentSyntax namedArgument, NamedTypeSymbol attributeType, DiagnosticBag diagnostics);
    private Symbol BindNamedAttributeArgumentName(AttributeArgumentSyntax namedArgument, NamedTypeSymbol attributeType, DiagnosticBag diagnostics, Boolean& wasError, LookupResultKind& resultKind);
    private TypeSymbol BindNamedAttributeArgumentType(AttributeArgumentSyntax namedArgument, Symbol namedArgumentNameSymbol, NamedTypeSymbol attributeType, DiagnosticBag diagnostics);
    protected virtual MethodSymbol BindAttributeConstructor(AttributeSyntax node, NamedTypeSymbol attributeType, AnalyzedArguments boundConstructorArguments, DiagnosticBag diagnostics, LookupResultKind& resultKind, bool suppressErrors, HashSet`1& useSiteDiagnostics);
    private ImmutableArray`1<TypedConstant> GetRewrittenAttributeConstructorArguments(ImmutableArray`1& constructorArgumentsSourceIndices, MethodSymbol attributeConstructor, ImmutableArray`1<TypedConstant> constructorArgsArray, ImmutableArray`1<string> constructorArgumentNamesOpt, AttributeSyntax syntax, DiagnosticBag diagnostics, Boolean& hasErrors);
    private static Int32[] CreateSourceIndicesArray(int paramIndex, int parameterCount);
    private TypedConstant GetMatchingNamedOrOptionalConstructorArgument(Int32& matchingArgumentIndex, ImmutableArray`1<TypedConstant> constructorArgsArray, ImmutableArray`1<string> constructorArgumentNamesOpt, ParameterSymbol parameter, int startIndex, int argumentsCount, Int32& argsConsumedCount, AttributeSyntax syntax, DiagnosticBag diagnostics);
    private static int GetMatchingNamedConstructorArgumentIndex(string parameterName, ImmutableArray`1<string> argumentNamesOpt, int startIndex, int argumentsCount);
    private TypedConstant GetDefaultValueArgument(ParameterSymbol parameter, AttributeSyntax syntax, DiagnosticBag diagnostics);
    private static TypedConstant GetParamArrayArgument(ParameterSymbol parameter, ImmutableArray`1<TypedConstant> constructorArgsArray, int argumentsCount, int argsConsumedCount, Conversions conversions);
    private BoundExpression BindAwait(AwaitExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindAwait(BoundExpression expression, CSharpSyntaxNode node, DiagnosticBag diagnostics);
    private bool CouldBeAwaited(BoundExpression expression);
    private bool get_ContextForbidsAwait();
    private bool ReportBadAwaitWithoutAsync(CSharpSyntaxNode node, DiagnosticBag diagnostics);
    private bool ReportBadAwaitContext(CSharpSyntaxNode node, DiagnosticBag diagnostics);
    private bool GetAwaitableExpressionInfo(BoundExpression expression, MethodSymbol& getAwaiter, PropertySymbol& isCompleted, MethodSymbol& getResult, CSharpSyntaxNode node, DiagnosticBag diagnostics);
    private static bool ValidateAwaitedExpression(BoundExpression expression, CSharpSyntaxNode node, DiagnosticBag diagnostics);
    private bool GetGetAwaiterMethod(BoundExpression expression, CSharpSyntaxNode node, DiagnosticBag diagnostics, MethodSymbol& getAwaiterMethod);
    private bool GetIsCompletedProperty(TypeSymbol awaiterType, CSharpSyntaxNode node, TypeSymbol awaitedExpressionType, DiagnosticBag diagnostics, PropertySymbol& isCompletedProperty);
    private bool AwaiterImplementsINotifyCompletion(TypeSymbol awaiterType, CSharpSyntaxNode node, DiagnosticBag diagnostics);
    private bool GetGetResultMethod(TypeSymbol awaiterType, CSharpSyntaxNode node, TypeSymbol awaitedExpressionType, DiagnosticBag diagnostics, MethodSymbol& getResultMethod);
    private static bool HasOptionalOrVariableParameters(MethodSymbol method);
    internal ImmutableArray`1<TypeParameterConstraintClause> BindTypeParameterConstraintClauses(Symbol containingSymbol, ImmutableArray`1<TypeParameterSymbol> typeParameters, SyntaxList`1<TypeParameterConstraintClauseSyntax> clauses, DiagnosticBag diagnostics);
    private TypeParameterConstraintClause BindTypeParameterConstraints(string name, SeparatedSyntaxList`1<TypeParameterConstraintSyntax> constraintsSyntax, DiagnosticBag diagnostics);
    private static bool IsValidConstraintType(TypeConstraintSyntax syntax, TypeSymbol type, DiagnosticBag diagnostics);
    protected BoundExpression CreateConversion(BoundExpression source, TypeSymbol destination, DiagnosticBag diagnostics);
    protected BoundExpression CreateConversion(BoundExpression source, Conversion conversion, TypeSymbol destination, DiagnosticBag diagnostics);
    protected BoundExpression CreateConversion(CSharpSyntaxNode syntax, BoundExpression source, Conversion conversion, bool isCast, TypeSymbol destination, DiagnosticBag diagnostics);
    protected BoundExpression CreateConversion(CSharpSyntaxNode syntax, BoundExpression source, Conversion conversion, bool isCast, bool wasCompilerGenerated, TypeSymbol destination, DiagnosticBag diagnostics);
    private bool IsCheckedConversion(TypeSymbol source, TypeSymbol target);
    protected BoundExpression CreateUserDefinedConversion(CSharpSyntaxNode syntax, BoundExpression source, Conversion conversion, bool isCast, TypeSymbol destination, DiagnosticBag diagnostics);
    private static BoundExpression CreateAnonymousFunctionConversion(CSharpSyntaxNode syntax, BoundExpression source, Conversion conversion, bool isCast, TypeSymbol destination, DiagnosticBag diagnostics);
    private BoundExpression CreateMethodGroupConversion(CSharpSyntaxNode syntax, BoundExpression source, Conversion conversion, bool isCast, TypeSymbol destination, DiagnosticBag diagnostics);
    private static bool IsMethodGroupWithTypeOrValueReceiver(BoundNode node);
    private BoundMethodGroup FixMethodGroupWithTypeOrValue(BoundMethodGroup group, Conversion conversion, DiagnosticBag diagnostics);
    private bool MemberGroupFinalValidation(BoundExpression receiverOpt, MethodSymbol methodSymbol, CSharpSyntaxNode node, DiagnosticBag diagnostics, bool invokedAsExtensionMethod);
    private bool MemberGroupFinalValidationAccessibilityChecks(BoundExpression receiverOpt, Symbol memberSymbol, CSharpSyntaxNode node, DiagnosticBag diagnostics, bool invokedAsExtensionMethod);
    private static bool IsMemberAccessedThroughVariableOrValue(BoundExpression receiverOpt);
    private static bool IsMemberAccessedThroughType(BoundExpression receiverOpt);
    private static bool WasImplicitReceiver(BoundExpression receiverOpt);
    internal bool MethodGroupIsCompatibleWithDelegate(BoundExpression receiverOpt, bool isExtensionMethod, MethodSymbol method, NamedTypeSymbol delegateType, Location errorLocation, DiagnosticBag diagnostics);
    private bool MethodGroupConversionHasErrors(CSharpSyntaxNode syntax, Conversion conversion, BoundExpression receiverOpt, bool isExtensionMethod, NamedTypeSymbol delegateType, DiagnosticBag diagnostics);
    private bool MethodGroupConversionDoesNotExistOrHasErrors(BoundMethodGroup boundMethodGroup, NamedTypeSymbol delegateType, Location delegateMismatchLocation, DiagnosticBag diagnostics, Conversion& conversion);
    public ConstantValue FoldConstantConversion(CSharpSyntaxNode syntax, BoundExpression source, Conversion conversion, TypeSymbol destination, DiagnosticBag diagnostics);
    private ConstantValue FoldConstantNumericConversion(CSharpSyntaxNode syntax, ConstantValue sourceValue, TypeSymbol destination, DiagnosticBag diagnostics);
    private static object DoUncheckedConversion(SpecialType destinationType, ConstantValue value);
    public static bool CheckConstantBounds(SpecialType destinationType, ConstantValue value);
    private static bool CheckConstantBounds(SpecialType destinationType, double value);
    private static bool CheckConstantBounds(SpecialType destinationType, decimal value);
    private static object CanonicalizeConstant(ConstantValue value);
    internal ImmutableArray`1<Symbol> BindCref(CrefSyntax syntax, Symbol& ambiguityWinner, DiagnosticBag diagnostics);
    private ImmutableArray`1<Symbol> BindCrefInternal(CrefSyntax syntax, Symbol& ambiguityWinner, DiagnosticBag diagnostics);
    private ImmutableArray`1<Symbol> BindTypeCref(TypeCrefSyntax syntax, Symbol& ambiguityWinner, DiagnosticBag diagnostics);
    private ImmutableArray`1<Symbol> BindQualifiedCref(QualifiedCrefSyntax syntax, Symbol& ambiguityWinner, DiagnosticBag diagnostics);
    private NamespaceOrTypeSymbol BindNamespaceOrTypeSymbolInCref(TypeSyntax syntax);
    private ImmutableArray`1<Symbol> BindMemberCref(MemberCrefSyntax syntax, NamespaceOrTypeSymbol containerOpt, Symbol& ambiguityWinner, DiagnosticBag diagnostics);
    private ImmutableArray`1<Symbol> BindNameMemberCref(NameMemberCrefSyntax syntax, NamespaceOrTypeSymbol containerOpt, Symbol& ambiguityWinner, DiagnosticBag diagnostics);
    private ImmutableArray`1<Symbol> BindIndexerMemberCref(IndexerMemberCrefSyntax syntax, NamespaceOrTypeSymbol containerOpt, Symbol& ambiguityWinner, DiagnosticBag diagnostics);
    private ImmutableArray`1<Symbol> BindOperatorMemberCref(OperatorMemberCrefSyntax syntax, NamespaceOrTypeSymbol containerOpt, Symbol& ambiguityWinner, DiagnosticBag diagnostics);
    private ImmutableArray`1<Symbol> BindConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax syntax, NamespaceOrTypeSymbol containerOpt, Symbol& ambiguityWinner, DiagnosticBag diagnostics);
    private ImmutableArray`1<Symbol> ComputeSortedCrefMembers(CSharpSyntaxNode syntax, NamespaceOrTypeSymbol containerOpt, string memberName, int arity, bool hasParameterList, DiagnosticBag diagnostics);
    private ImmutableArray`1<Symbol> ComputeSortedCrefMembers(NamespaceOrTypeSymbol containerOpt, string memberName, int arity, bool hasParameterList, HashSet`1& useSiteDiagnostics);
    private ImmutableArray`1<Symbol> ProcessCrefMemberLookupResults(ImmutableArray`1<Symbol> symbols, int arity, MemberCrefSyntax memberSyntax, TypeArgumentListSyntax typeArgumentListSyntax, BaseCrefParameterListSyntax parameterListSyntax, Symbol& ambiguityWinner, DiagnosticBag diagnostics);
    private static bool ContainsNestedTypeOfUnconstructedGenericType(TypeSymbol type);
    private static bool IsNestedTypeOfUnconstructedGenericType(NamedTypeSymbol type);
    private ImmutableArray`1<Symbol> ProcessParameterlessCrefMemberLookupResults(ImmutableArray`1<Symbol> symbols, int arity, MemberCrefSyntax memberSyntax, TypeArgumentListSyntax typeArgumentListSyntax, Symbol& ambiguityWinner, DiagnosticBag diagnostics);
    private void GetCrefOverloadResolutionCandidates(ImmutableArray`1<Symbol> symbols, int arity, TypeArgumentListSyntax typeArgumentListSyntax, ArrayBuilder`1<Symbol> candidates);
    private static ImmutableArray`1<Symbol> PerformCrefOverloadResolution(ArrayBuilder`1<Symbol> candidates, ImmutableArray`1<ParameterSymbol> parameterSymbols, int arity, MemberCrefSyntax memberSyntax, Symbol& ambiguityWinner, DiagnosticBag diagnostics);
    private Symbol ConstructWithCrefTypeParameters(int arity, TypeArgumentListSyntax typeArgumentListSyntax, Symbol symbol);
    private ImmutableArray`1<ParameterSymbol> BindCrefParameters(BaseCrefParameterListSyntax parameterListSyntax, DiagnosticBag diagnostics);
    private TypeSymbol BindCrefParameterOrReturnType(TypeSyntax typeSyntax, MemberCrefSyntax memberCrefSyntax, DiagnosticBag diagnostics);
    private static bool HasNonObsoleteError(DiagnosticBag unusedDiagnostics);
    private static CrefSyntax GetRootCrefSyntax(MemberCrefSyntax syntax);
    private bool HasThis(bool isExplicit, Boolean& inStaticContext);
    internal bool get_InFieldInitializer();
    internal bool get_InParameterDefaultValue();
    protected bool get_InConstructorInitializer();
    internal bool get_InAttributeArgument();
    internal bool get_InCref();
    protected bool get_InCrefButNotParameterOrReturnType();
    protected virtual bool IsUnboundTypeAllowed(GenericNameSyntax syntax);
    private BoundBadExpression BadExpression(CSharpSyntaxNode syntax);
    private BoundBadExpression BadExpression(CSharpSyntaxNode syntax, BoundNode childNode);
    private BoundBadExpression BadExpression(CSharpSyntaxNode syntax, BoundNode[] childNodes);
    protected BoundBadExpression BadExpression(CSharpSyntaxNode syntax, LookupResultKind lookupResultKind);
    protected BoundBadExpression BadExpression(CSharpSyntaxNode syntax, LookupResultKind lookupResultKind, BoundNode childNode);
    protected BoundBadExpression BadExpression(CSharpSyntaxNode syntax, LookupResultKind lookupResultKind, BoundNode[] childNodes);
    private BoundBadExpression BadExpression(CSharpSyntaxNode syntax, LookupResultKind resultKind, ImmutableArray`1<Symbol> symbols);
    private BoundBadExpression BadExpression(CSharpSyntaxNode syntax, LookupResultKind resultKind, ImmutableArray`1<Symbol> symbols, BoundNode childNode);
    private BoundBadExpression BadExpression(CSharpSyntaxNode syntax, LookupResultKind resultKind, ImmutableArray`1<Symbol> symbols, BoundNode[] childNodes);
    private BoundBadExpression BadExpression(CSharpSyntaxNode syntax, LookupResultKind resultKind, ImmutableArray`1<Symbol> symbols, ImmutableArray`1<BoundExpression> childNodes);
    private BoundExpression ToBadExpression(BoundExpression expr, LookupResultKind resultKind);
    internal TypeSymbol CreateErrorType(string name);
    private static bool RequiresGettingValue(BindValueKind kind);
    private static bool RequiresSettingValue(BindValueKind kind);
    internal BoundExpression BindValue(ExpressionSyntax node, DiagnosticBag diagnostics, BindValueKind valueKind);
    internal BoundExpression BindValueAllowArgList(ExpressionSyntax node, DiagnosticBag diagnostics, BindValueKind valueKind);
    internal BoundExpression BindVariableOrAutoPropInitializer(EqualsValueClauseSyntax initializerOpt, TypeSymbol varType, DiagnosticBag diagnostics);
    internal Binder CreateBinderForParameterDefaultValue(ParameterSymbol parameter, EqualsValueClauseSyntax defaultValueSyntax);
    internal BoundExpression BindParameterDefaultValue(EqualsValueClauseSyntax defaultValueSyntax, TypeSymbol parameterType, DiagnosticBag diagnostics, BoundExpression& valueBeforeConversion);
    internal BoundExpression BindEnumConstantInitializer(SourceEnumConstantSymbol symbol, ExpressionSyntax valueSyntax, DiagnosticBag diagnostics);
    public BoundExpression BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics);
    protected BoundExpression BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics, bool invoked, bool indexed);
    protected BoundExpression BindExpressionAllowArgList(ExpressionSyntax node, DiagnosticBag diagnostics);
    private void VerifyUnchecked(ExpressionSyntax node, DiagnosticBag diagnostics, BoundExpression expr);
    private BoundExpression BindExpressionInternal(ExpressionSyntax node, DiagnosticBag diagnostics, bool invoked, bool indexed);
    private BoundExpression BindRefValue(RefValueExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindMakeRef(MakeRefExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindRefType(RefTypeExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindArgList(CSharpSyntaxNode node, DiagnosticBag diagnostics);
    private BoundExpression BindQualifiedName(QualifiedNameSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindParenthesizedExpression(ExpressionSyntax innerExpression, DiagnosticBag diagnostics);
    private BoundExpression BindTypeOf(TypeOfExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindSizeOf(SizeOfExpressionSyntax node, DiagnosticBag diagnostics);
    internal static ConstantValue GetConstantSizeOf(TypeSymbol type);
    private BoundExpression BindDefaultExpression(DefaultExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindIdentifier(SimpleNameSyntax node, bool invoked, DiagnosticBag diagnostics);
    private BoundExpression SynthesizeMethodGroupReceiver(CSharpSyntaxNode syntax, ArrayBuilder`1<Symbol> members);
    private bool IsBindingImplicitlyTypedLocal(LocalSymbol symbol);
    private BoundExpression BindNonMethod(SimpleNameSyntax node, Symbol symbol, DiagnosticBag diagnostics, LookupResultKind resultKind, bool isError);
    protected virtual BoundExpression BindRangeVariable(SimpleNameSyntax node, RangeVariableSymbol qv, DiagnosticBag diagnostics);
    private BoundExpression SynthesizeReceiver(SimpleNameSyntax node, Symbol member, DiagnosticBag diagnostics);
    internal Symbol ContainingMember();
    private BoundExpression TryBindInteractiveReceiver(CSharpSyntaxNode syntax, Symbol currentMember, NamedTypeSymbol currentType, NamedTypeSymbol memberDeclaringType);
    public BoundExpression BindNamespaceOrTypeOrExpression(ExpressionSyntax node, DiagnosticBag diagnostics);
    public BoundExpression BindLabel(ExpressionSyntax node, DiagnosticBag diagnostics);
    public BoundExpression BindNamespaceOrType(ExpressionSyntax node, DiagnosticBag diagnostics);
    public BoundExpression BindNamespaceAlias(IdentifierNameSyntax node, DiagnosticBag diagnostics);
    private static BoundExpression CreateBoundNamespaceOrTypeExpression(ExpressionSyntax node, Symbol symbol);
    private BoundThisReference BindThis(ThisExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundThisReference ThisReference(CSharpSyntaxNode node, NamedTypeSymbol thisTypeOpt, bool hasErrors, bool wasCompilerGenerated);
    private bool IsRefOrOutThisParameterCaptured(CSharpSyntaxNode node, DiagnosticBag diagnostics);
    private BoundBaseReference BindBase(BaseExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindCast(CastExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindCastCore(ExpressionSyntax node, BoundExpression operand, TypeSymbol targetType, bool wasCompilerGenerated, DiagnosticBag diagnostics);
    private BoundExpression BindExplicitNullableCastFromNonNullable(ExpressionSyntax node, BoundExpression operand, TypeSymbol targetType, DiagnosticBag diagnostics);
    private static NameSyntax GetNameSyntax(CSharpSyntaxNode syntax);
    private static NameSyntax GetNameSyntax(CSharpSyntaxNode syntax, String& nameString);
    private static string GetName(ExpressionSyntax syntax);
    private void BindArgumentsAndNames(ArgumentListSyntax argumentListOpt, DiagnosticBag diagnostics, AnalyzedArguments result, bool allowArglist, bool isDelegateCreation);
    private void BindArgumentsAndNames(BracketedArgumentListSyntax argumentListOpt, DiagnosticBag diagnostics, AnalyzedArguments result);
    private void BindArgumentsAndNames(SeparatedSyntaxList`1<ArgumentSyntax> arguments, DiagnosticBag diagnostics, AnalyzedArguments result, bool allowArglist, bool isDelegateCreation);
    private bool RefMustBeObeyed(bool isDelegateCreation, ArgumentSyntax argumentSyntax);
    private bool BindArgumentAndName(AnalyzedArguments result, DiagnosticBag diagnostics, bool hadError, ArgumentSyntax argumentSyntax, bool allowArglist, bool isDelegateCreation);
    private bool BindArgumentAndName(AnalyzedArguments result, DiagnosticBag diagnostics, bool hadError, CSharpSyntaxNode argumentSyntax, ExpressionSyntax argumentExpression, NameColonSyntax nameColonSyntax, RefKind refKind, bool allowArglist);
    private void CoerceArguments(MemberResolutionResult`1<TMember> methodResult, ArrayBuilder`1<BoundExpression> arguments, DiagnosticBag diagnostics);
    private static TypeSymbol GetCorrespondingParameterType(MemberAnalysisResult& result, ImmutableArray`1<ParameterSymbol> parameters, int arg);
    private BoundExpression BindArrayCreationExpression(ArrayCreationExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node, DiagnosticBag diagnostics);
    private ImmutableArray`1<BoundExpression> BindArrayInitializerExpressions(InitializerExpressionSyntax initializer, DiagnosticBag diagnostics, int dimension, int rank);
    private void BindArrayInitializerExpressions(InitializerExpressionSyntax initializer, ArrayBuilder`1<BoundExpression> exprBuilder, DiagnosticBag diagnostics, int dimension, int rank);
    private BoundArrayInitialization ConvertAndBindArrayInitialization(DiagnosticBag diagnostics, InitializerExpressionSyntax node, ArrayTypeSymbol type, Nullable`1[] knownSizes, int dimension, ImmutableArray`1<BoundExpression> boundInitExpr, Int32& boundInitExprIndex);
    private BoundArrayInitialization BindArrayInitializerList(DiagnosticBag diagnostics, InitializerExpressionSyntax node, ArrayTypeSymbol type, Nullable`1[] knownSizes, int dimension, ImmutableArray`1<BoundExpression> boundInitExprOpt);
    private BoundArrayInitialization BindUnexpectedArrayInitializer(InitializerExpressionSyntax node, DiagnosticBag diagnostics, ErrorCode errorCode, CSharpSyntaxNode errorNode);
    private BoundArrayCreation BindArrayCreationWithInitializer(DiagnosticBag diagnostics, ExpressionSyntax creationSyntax, InitializerExpressionSyntax initSyntax, ArrayTypeSymbol type, ImmutableArray`1<BoundExpression> sizes, ImmutableArray`1<BoundExpression> boundInitExprOpt);
    private BoundExpression BindStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node, DiagnosticBag diagnostics);
    private static Nullable`1<int> GetIntegerConstantForArraySize(BoundExpression expression);
    private static bool IsNegativeConstantForArraySize(BoundExpression expression);
    internal BoundExpression BindConstructorInitializer(ArgumentListSyntax initializerArgumentListOpt, MethodSymbol constructor, DiagnosticBag diagnostics);
    protected BoundExpression BindObjectCreationExpression(ObjectCreationExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindDelegateCreationExpression(ObjectCreationExpressionSyntax node, NamedTypeSymbol type, DiagnosticBag diagnostics);
    private BoundExpression BindClassCreationExpression(ObjectCreationExpressionSyntax node, NamedTypeSymbol type, string typeName, BoundExpression boundInitializerOpt, DiagnosticBag diagnostics);
    private BoundExpression BindInitializerExpressionOrValue(ExpressionSyntax syntax, TypeSymbol type, CSharpSyntaxNode typeSyntax, DiagnosticBag diagnostics);
    private BoundObjectInitializerExpression BindObjectInitializerExpression(InitializerExpressionSyntax initializerSyntax, TypeSymbol initializerType, DiagnosticBag diagnostics, BoundImplicitReceiver implicitReceiver);
    private BoundExpression BindObjectInitializerMemberAssignment(ExpressionSyntax memberInitializer, TypeSymbol initializerType, Binder objectInitializerMemberBinder, DiagnosticBag diagnostics, BoundImplicitReceiver implicitReceiver);
    private BoundExpression BindObjectInitializerMember(AssignmentExpressionSyntax namedAssignment, BoundImplicitReceiver implicitReceiver, DiagnosticBag diagnostics);
    private bool CheckNestedObjectInitializerPropertySymbol(PropertySymbol propertySymbol, ExpressionSyntax memberNameSyntax, DiagnosticBag diagnostics, bool suppressErrors, LookupResultKind& resultKind);
    private BoundExpression BadObjectInitializerMemberAccess(BoundExpression boundMember, BoundImplicitReceiver implicitReceiver, ExpressionSyntax memberNameSyntax, DiagnosticBag diagnostics, BindValueKind valueKind, bool suppressErrors);
    private static void ReportDuplicateObjectMemberInitializers(BoundExpression boundMemberInitializer, HashSet`1<string> memberNameMap, DiagnosticBag diagnostics);
    private BoundCollectionInitializerExpression BindCollectionInitializerExpression(InitializerExpressionSyntax initializerSyntax, TypeSymbol initializerType, DiagnosticBag diagnostics, BoundImplicitReceiver implicitReceiver);
    private bool CollectionInitializerTypeImplementsIEnumerable(TypeSymbol initializerType, CSharpSyntaxNode node, DiagnosticBag diagnostics);
    private BoundExpression BindCollectionInitializerElement(ExpressionSyntax elementInitializer, TypeSymbol initializerType, bool hasEnumerableInitializerType, Binder collectionInitializerAddMethodBinder, DiagnosticBag diagnostics, BoundImplicitReceiver implicitReceiver);
    private BoundExpression BindComplexElementInitializerExpression(InitializerExpressionSyntax elementInitializer, DiagnosticBag diagnostics, bool hasEnumerableInitializerType, Binder collectionInitializerAddMethodBinder, BoundImplicitReceiver implicitReceiver);
    private BoundExpression BindUnexpectedComplexElementInitializer(InitializerExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindCollectionInitializerElementAddMethod(ExpressionSyntax elementInitializer, ImmutableArray`1<BoundExpression> boundElementInitializerExpressions, bool hasEnumerableInitializerType, Binder collectionInitializerAddMethodBinder, DiagnosticBag diagnostics, BoundImplicitReceiver implicitReceiver);
    internal ImmutableArray`1<MethodSymbol> FilterInaccessibleConstructors(ImmutableArray`1<MethodSymbol> constructors, bool allowProtectedConstructorsOfBaseType, HashSet`1& useSiteDiagnostics);
    private bool IsConstructorAccessible(MethodSymbol constructor, HashSet`1& useSiteDiagnostics, bool allowProtectedConstructorsOfBaseType);
    protected BoundExpression BindClassCreationExpression(CSharpSyntaxNode node, string typeName, CSharpSyntaxNode typeNode, NamedTypeSymbol type, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics, BoundExpression boundInitializerOpt);
    private BoundExpression BindInterfaceCreationExpression(ObjectCreationExpressionSyntax node, NamedTypeSymbol type, BoundExpression boundInitializerOpt, DiagnosticBag diagnostics);
    private BoundExpression BindBadInterfaceCreationExpression(ObjectCreationExpressionSyntax node, NamedTypeSymbol type, DiagnosticBag diagnostics);
    private BoundExpression BindComImportCoClassCreationExpression(ObjectCreationExpressionSyntax node, NamedTypeSymbol interfaceType, NamedTypeSymbol coClassType, BoundExpression boundInitializerOpt, DiagnosticBag diagnostics);
    private BoundExpression BindNoPiaObjectCreationExpression(ObjectCreationExpressionSyntax node, NamedTypeSymbol interfaceType, NamedTypeSymbol coClassType, BoundExpression boundInitializerOpt, DiagnosticBag diagnostics);
    private BoundExpression BindTypeParameterCreationExpression(ObjectCreationExpressionSyntax node, TypeParameterSymbol typeParameter, BoundExpression boundInitializerOpt, DiagnosticBag diagnostics);
    private bool TryPerformConstructorOverloadResolution(NamedTypeSymbol typeContainingConstructors, AnalyzedArguments analyzedArguments, string errorName, Location errorLocation, bool suppressResultDiagnostics, DiagnosticBag diagnostics, MemberResolutionResult`1& memberResolutionResult, ImmutableArray`1& candidateConstructors, bool allowProtectedConstructorsOfBaseType);
    private ImmutableArray`1<MethodSymbol> GetAccessibleConstructorsForOverloadResolution(NamedTypeSymbol type, HashSet`1& useSiteDiagnostics);
    private ImmutableArray`1<MethodSymbol> GetAccessibleConstructorsForOverloadResolution(NamedTypeSymbol type, bool allowProtectedConstructorsOfBaseType, ImmutableArray`1& allInstanceConstructors, HashSet`1& useSiteDiagnostics);
    private static ConstantValue FoldParameterlessValueTypeConstructor(NamedTypeSymbol type);
    private BoundLiteral BindLiteralConstant(LiteralExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindCheckedExpression(CheckedExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindMemberAccess(MemberAccessExpressionSyntax node, bool invoked, bool indexed, DiagnosticBag diagnostics);
    private BoundExpression BindLeftOfPotentialColorColorMemberAccess(ExpressionSyntax left, DiagnosticBag diagnostics);
    private bool IsUsingAliasInScope(string name);
    private BoundExpression BindDynamicMemberAccess(ExpressionSyntax node, BoundExpression boundLeft, SimpleNameSyntax right, bool invoked, bool indexed, DiagnosticBag diagnostics);
    private BoundExpression BindMemberAccessWithBoundLeft(ExpressionSyntax node, BoundExpression boundLeft, SimpleNameSyntax right, SyntaxToken operatorToken, bool invoked, bool indexed, DiagnosticBag diagnostics);
    private static void WarnOnAccessOfOffDefault(CSharpSyntaxNode node, BoundExpression boundLeft, DiagnosticBag diagnostics);
    private BoundExpression MakeMemberAccessValue(BoundExpression expr, DiagnosticBag diagnostics);
    private BoundExpression BindInstanceMemberAccess(CSharpSyntaxNode node, CSharpSyntaxNode right, BoundExpression boundLeft, string rightName, int rightArity, SeparatedSyntaxList`1<TypeSyntax> typeArgumentsSyntax, ImmutableArray`1<TypeSymbol> typeArguments, bool invoked, DiagnosticBag diagnostics);
    private void BindMemberAccessReportError(BoundMethodGroup node, DiagnosticBag diagnostics);
    private void BindMemberAccessReportError(CSharpSyntaxNode node, CSharpSyntaxNode name, string plainName, BoundExpression boundLeft, DiagnosticInfo lookupError, DiagnosticBag diagnostics);
    private bool WouldUsingSystemFindExtension(TypeSymbol receiver, string methodName);
    private bool ImplementsWinRTAsyncInterface(TypeSymbol type);
    private bool IsWinRTAsyncInterface(TypeSymbol type);
    private BoundExpression BindMemberAccessBadResult(BoundMethodGroup node);
    private BoundExpression BindMemberAccessBadResult(CSharpSyntaxNode node, string nameString, BoundExpression boundLeft, DiagnosticInfo lookupError, ImmutableArray`1<Symbol> symbols, LookupResultKind lookupKind);
    private TypeSymbol GetNonMethodMemberType(Symbol symbolOpt);
    private static void CombineExtensionMethodArguments(BoundExpression receiver, AnalyzedArguments originalArguments, AnalyzedArguments extensionMethodArguments);
    private BoundExpression BindMemberOfType(CSharpSyntaxNode node, CSharpSyntaxNode right, string plainName, int arity, BoundExpression left, SeparatedSyntaxList`1<TypeSyntax> typeArgumentsSyntax, ImmutableArray`1<TypeSymbol> typeArguments, LookupResult lookupResult, BoundMethodGroupFlags methodGroupFlags, DiagnosticBag diagnostics);
    private MethodGroupResolution BindExtensionMethod(CSharpSyntaxNode expression, string methodName, AnalyzedArguments analyzedArguments, BoundExpression left, ImmutableArray`1<TypeSymbol> typeArguments, bool isMethodGroupConversion);
    private void PopulateExtensionMethodsFromSingleBinder(ExtensionMethodScope scope, MethodGroup methodGroup, CSharpSyntaxNode node, BoundExpression left, string rightName, ImmutableArray`1<TypeSymbol> typeArguments, DiagnosticBag diagnostics);
    protected BoundExpression BindFieldAccess(CSharpSyntaxNode node, BoundExpression receiver, FieldSymbol fieldSymbol, DiagnosticBag diagnostics, LookupResultKind resultKind, bool hasErrors);
    private bool InEnumMemberInitializer();
    private BoundExpression BindPropertyAccess(CSharpSyntaxNode node, BoundExpression receiver, PropertySymbol propertySymbol, DiagnosticBag diagnostics, LookupResultKind lookupResult, bool hasErrors);
    private BoundExpression BindEventAccess(CSharpSyntaxNode node, BoundExpression receiver, EventSymbol eventSymbol, DiagnosticBag diagnostics, LookupResultKind lookupResult, bool hasErrors);
    private static Nullable`1<bool> IsInstanceReceiver(BoundExpression receiver);
    private bool CheckInstanceOrStatic(CSharpSyntaxNode node, BoundExpression receiver, Symbol symbol, LookupResultKind& resultKind, DiagnosticBag diagnostics);
    private Symbol GetSymbolOrMethodOrPropertyGroup(LookupResult result, CSharpSyntaxNode node, string plainName, int arity, ArrayBuilder`1<Symbol> methodOrPropertyGroup, DiagnosticBag diagnostics, Boolean& wasError);
    private static bool IsMethodOrPropertyGroup(ArrayBuilder`1<Symbol> members);
    private BoundExpression BindElementAccess(ElementAccessExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindElementAccess(ExpressionSyntax node, BoundExpression receiver, BracketedArgumentListSyntax argumentList, DiagnosticBag diagnostics);
    private BoundExpression BindElementOrIndexerAccess(ExpressionSyntax node, BoundExpression expr, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics);
    private BoundExpression BadIndexerExpression(ExpressionSyntax node, BoundExpression expr, AnalyzedArguments analyzedArguments, DiagnosticInfo errorOpt, DiagnosticBag diagnostics);
    private BoundExpression BindElementAccessCore(ExpressionSyntax node, BoundExpression expr, AnalyzedArguments arguments, DiagnosticBag diagnostics);
    private BoundExpression BindArrayAccess(ExpressionSyntax node, BoundExpression expr, AnalyzedArguments arguments, DiagnosticBag diagnostics);
    private BoundExpression ConvertToArrayIndex(BoundExpression index, CSharpSyntaxNode node, DiagnosticBag diagnostics);
    private BoundExpression TryImplicitConversionToArrayIndex(BoundExpression expr, SpecialType specialType, CSharpSyntaxNode node, DiagnosticBag diagnostics);
    private BoundExpression BindPointerElementAccess(ExpressionSyntax node, BoundExpression expr, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics);
    private BoundExpression BindIndexerAccess(ExpressionSyntax node, BoundExpression expr, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics);
    private BoundExpression BindIndexedPropertyAccess(BoundPropertyGroup propertyGroup, bool mustHaveAllOptionalParameters, DiagnosticBag diagnostics);
    private BoundExpression BindIndexedPropertyAccess(CSharpSyntaxNode syntax, BoundExpression receiverOpt, ImmutableArray`1<PropertySymbol> propertyGroup, AnalyzedArguments arguments, DiagnosticBag diagnostics);
    private BoundExpression BindDynamicIndexer(CSharpSyntaxNode syntax, BoundExpression receiverOpt, AnalyzedArguments arguments, ImmutableArray`1<PropertySymbol> applicableProperties, DiagnosticBag diagnostics);
    private BoundExpression BindIndexerOrIndexedPropertyAccess(CSharpSyntaxNode syntax, BoundExpression receiverOpt, ArrayBuilder`1<PropertySymbol> propertyGroup, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics);
    private ErrorPropertySymbol CreateErrorPropertySymbol(ImmutableArray`1<PropertySymbol> propertyGroup);
    internal MethodGroupResolution ResolveMethodGroup(BoundMethodGroup node, AnalyzedArguments analyzedArguments, bool isMethodGroupConversion, HashSet`1& useSiteDiagnostics, bool inferWithDynamic);
    internal MethodGroupResolution ResolveMethodGroup(BoundMethodGroup node, CSharpSyntaxNode expression, string methodName, AnalyzedArguments analyzedArguments, bool isMethodGroupConversion, HashSet`1& useSiteDiagnostics, bool inferWithDynamic, bool allowUnexpandedForm);
    private MethodGroupResolution ResolveMethodGroupInternal(BoundMethodGroup methodGroup, CSharpSyntaxNode expression, string methodName, AnalyzedArguments analyzedArguments, bool isMethodGroupConversion, HashSet`1& useSiteDiagnostics, bool inferWithDynamic, bool allowUnexpandedForm);
    private MethodGroupResolution ResolveDefaultMethodGroup(BoundMethodGroup node, AnalyzedArguments analyzedArguments, bool isMethodGroupConversion, HashSet`1& useSiteDiagnostics, bool inferWithDynamic, bool allowUnexpandedForm);
    internal static bool ReportDelegateInvokeUseSiteDiagnostic(DiagnosticBag diagnostics, TypeSymbol possibleDelegateType, Location location, CSharpSyntaxNode node);
    private BoundConditionalAccess BindConditionalAccessExpression(ConditionalAccessExpressionSyntax node, DiagnosticBag diagnostics);
    private bool ContainingMethodOrLambdaRequiresValue();
    private BoundConditionalAccess GenerateBadConditionalAccessNodeError(ConditionalAccessExpressionSyntax node, BoundExpression receiver, BoundExpression access, DiagnosticBag diagnostics);
    private BoundExpression BindMemberBindingExpression(MemberBindingExpressionSyntax node, bool invoked, bool indexed, DiagnosticBag diagnostics);
    private BoundExpression BindElementBindingExpression(ElementBindingExpressionSyntax node, bool invoked, bool indexed, DiagnosticBag diagnostics);
    private CSharpSyntaxNode GetConditionalReceiverSyntax(ConditionalAccessExpressionSyntax node);
    private BoundExpression GetReceiverForConditionalBinding(ExpressionSyntax binding, DiagnosticBag diagnostics);
    private BoundExpression BindConditionalAccessReceiver(ConditionalAccessExpressionSyntax node, DiagnosticBag diagnostics);
    internal Binder WithFlags(BinderFlags flags);
    internal Binder WithAdditionalFlags(BinderFlags flags);
    internal Binder WithContainingMemberOrLambda(Symbol containing);
    internal Binder WithAdditionalFlagsAndContainingMemberOrLambda(BinderFlags flags, Symbol containing);
    internal Binder WithUnsafeRegionIfNecessary(SyntaxTokenList modifiers);
    internal Binder WithCheckedOrUncheckedRegion(bool checked);
    internal static void BindFieldInitializers(CSharpCompilation compilation, SynthesizedInteractiveInitializerMethod scriptInitializerOpt, ImmutableArray`1<ImmutableArray`1<FieldOrPropertyInitializer>> fieldInitializers, DiagnosticBag diagnostics, ProcessedFieldInitializers& processedInitializers);
    private static ImmutableArray`1<BoundInitializer> BindFieldInitializers(CSharpCompilation compilation, SynthesizedInteractiveInitializerMethod scriptInitializerOpt, ImmutableArray`1<ImmutableArray`1<FieldOrPropertyInitializer>> initializers, DiagnosticBag diagnostics, ImportChain& firstImportChain);
    internal static void BindRegularCSharpFieldInitializers(CSharpCompilation compilation, ImmutableArray`1<ImmutableArray`1<FieldOrPropertyInitializer>> initializers, ArrayBuilder`1<BoundInitializer> boundInitializers, DiagnosticBag diagnostics, ImportChain& firstDebugImports);
    private static void BindScriptFieldInitializers(CSharpCompilation compilation, SynthesizedInteractiveInitializerMethod scriptInitializer, ImmutableArray`1<ImmutableArray`1<FieldOrPropertyInitializer>> initializers, ArrayBuilder`1<BoundInitializer> boundInitializers, DiagnosticBag diagnostics, ImportChain& firstDebugImports);
    private static BoundInitializer BindGlobalStatement(Binder binder, SynthesizedInteractiveInitializerMethod scriptInitializer, StatementSyntax statementNode, DiagnosticBag diagnostics, bool isLast);
    private static BoundFieldInitializer BindFieldInitializer(Binder binder, FieldSymbol fieldSymbol, EqualsValueClauseSyntax equalsValueClauseNode, DiagnosticBag diagnostics);
    private BoundExpression BindInterpolatedString(InterpolatedStringExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindMethodGroup(ExpressionSyntax node, bool invoked, bool indexed, DiagnosticBag diagnostics);
    private static ImmutableArray`1<MethodSymbol> GetOriginalMethods(OverloadResolutionResult`1<MethodSymbol> overloadResolutionResult);
    internal BoundExpression MakeInvocationExpression(CSharpSyntaxNode node, BoundExpression receiver, string methodName, ImmutableArray`1<BoundExpression> args, DiagnosticBag diagnostics, SeparatedSyntaxList`1<TypeSyntax> typeArgsSyntax, ImmutableArray`1<TypeSymbol> typeArgs, CSharpSyntaxNode queryClause, bool allowFieldsAndProperties, bool allowUnexpandedForm);
    private BoundExpression BindInvocationExpression(InvocationExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindArgListOperator(InvocationExpressionSyntax node, DiagnosticBag diagnostics, AnalyzedArguments analyzedArguments);
    private BoundExpression BindInvocationExpression(CSharpSyntaxNode node, CSharpSyntaxNode expression, string methodName, BoundExpression boundExpression, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause, bool allowUnexpandedForm);
    private BoundExpression BindDynamicInvocation(CSharpSyntaxNode node, BoundExpression expression, AnalyzedArguments arguments, ImmutableArray`1<MethodSymbol> applicableMethods, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause);
    private ImmutableArray`1<BoundExpression> BuildArgumentsForDynamicInvocation(AnalyzedArguments arguments, DiagnosticBag diagnostics);
    private static bool ReportBadDynamicArguments(CSharpSyntaxNode node, ImmutableArray`1<BoundExpression> arguments, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause);
    private BoundExpression BindDelegateInvocation(CSharpSyntaxNode node, CSharpSyntaxNode expression, string methodName, BoundExpression boundExpression, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause, NamedTypeSymbol delegateType);
    private static bool HasApplicableConditionalMethod(OverloadResolutionResult`1<MethodSymbol> results);
    private BoundExpression BindMethodGroupInvocation(CSharpSyntaxNode syntax, CSharpSyntaxNode expression, string methodName, BoundMethodGroup methodGroup, AnalyzedArguments analyzedArguments, DiagnosticBag diagnostics, CSharpSyntaxNode queryClause, bool allowUnexpandedForm);
    private ImmutableArray`1<TMethodOrPropertySymbol> GetCandidatesPassingFinalValidation(CSharpSyntaxNode syntax, OverloadResolutionResult`1<TMethodOrPropertySymbol> overloadResolutionResult, BoundExpression receiverOpt, ImmutableArray`1<TypeSymbol> typeArgumentsOpt, DiagnosticBag diagnostics);
    private static void CheckRestrictedTypeReceiver(BoundExpression expression, Compilation compilation, DiagnosticBag diagnostics);
    private BoundCall BindInvocationExpressionContinued(CSharpSyntaxNode node, CSharpSyntaxNode expression, string methodName, OverloadResolutionResult`1<MethodSymbol> result, AnalyzedArguments analyzedArguments, MethodGroup methodGroup, NamedTypeSymbol delegateTypeOpt, DiagnosticBag diagnostics, bool extensionMethodsOfSameViabilityAreAvailable, CSharpSyntaxNode queryClause);
    private Location GetLocationForOverloadResolutionDiagnostic(CSharpSyntaxNode node, CSharpSyntaxNode expression);
    private BoundExpression ReplaceTypeOrValueReceiver(BoundExpression receiver, bool useType, DiagnosticBag diagnostics);
    private static NamedTypeSymbol GetDelegateType(BoundExpression expr);
    private BoundCall CreateBadCall(CSharpSyntaxNode node, string name, BoundExpression receiver, ImmutableArray`1<MethodSymbol> methods, LookupResultKind resultKind, ImmutableArray`1<TypeSymbol> typeArguments, AnalyzedArguments analyzedArguments, bool invokedAsExtensionMethod, bool isDelegate, bool extensionMethodsOfSameViabilityAreAvailable);
    private ImmutableArray`1<BoundExpression> BuildArgumentsForErrorRecovery(AnalyzedArguments analyzedArguments, ImmutableArray`1<ParameterSymbol> parameters);
    private ImmutableArray`1<BoundExpression> BuildArgumentsForErrorRecovery(AnalyzedArguments analyzedArguments);
    private BoundCall CreateBadCall(CSharpSyntaxNode node, BoundExpression expr, LookupResultKind resultKind, AnalyzedArguments analyzedArguments);
    private static TypeSymbol GetCommonTypeOrReturnType(ImmutableArray`1<TMember> members);
    private bool TryBindNameofOperator(InvocationExpressionSyntax node, DiagnosticBag diagnostics, BoundExpression& result);
    private BoundExpression BindNameofOperatorInternal(InvocationExpressionSyntax node, DiagnosticBag diagnostics);
    private void EnsureNameofExpressionSymbols(BoundMethodGroup methodGroup, DiagnosticBag diagnostics);
    private bool CheckSyntaxForNameofArgument(ExpressionSyntax argument, String& name, DiagnosticBag diagnostics, bool top);
    private bool InvocableNameofInScope();
    private Tuple`4<ImmutableArray`1<RefKind>, ImmutableArray`1<TypeSymbol>, ImmutableArray`1<string>, bool> AnalyzeAnonymousFunction(CSharpSyntaxNode syntax, DiagnosticBag diagnostics);
    private UnboundLambda BindAnonymousFunction(CSharpSyntaxNode syntax, DiagnosticBag diagnostics);
    internal void LookupSymbolsSimpleName(LookupResult result, NamespaceOrTypeSymbol qualifierOpt, string plainName, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, bool diagnose, HashSet`1& useSiteDiagnostics);
    internal void LookupExtensionMethods(LookupResult result, string name, int arity, LookupOptions options, HashSet`1& useSiteDiagnostics);
    private Binder LookupSymbolsWithFallback(LookupResult result, string name, int arity, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved, LookupOptions options);
    private Binder LookupSymbolsInternal(LookupResult result, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, bool diagnose, HashSet`1& useSiteDiagnostics);
    internal virtual void LookupSymbolsInSingleBinder(LookupResult result, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, HashSet`1& useSiteDiagnostics);
    private void LookupSymbolsOrMembersInternal(LookupResult result, NamespaceOrTypeSymbol qualifierOpt, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, bool diagnose, HashSet`1& useSiteDiagnostics);
    private void LookupMembersWithFallback(LookupResult result, NamespaceOrTypeSymbol nsOrType, string name, int arity, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved, LookupOptions options);
    protected void LookupMembersInternal(LookupResult result, NamespaceOrTypeSymbol nsOrType, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, HashSet`1& useSiteDiagnostics);
    protected void LookupMembersInType(LookupResult result, TypeSymbol type, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, HashSet`1& useSiteDiagnostics);
    private void LookupMembersInErrorType(LookupResult result, ErrorTypeSymbol errorType, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, HashSet`1& useSiteDiagnostics);
    private void LookupMembersInSubmissions(LookupResult result, TypeSymbol submissionClass, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, HashSet`1& useSiteDiagnostics);
    private static void LookupMembersInNamespace(LookupResult result, NamespaceSymbol ns, string name, int arity, LookupOptions options, Binder originalBinder, bool diagnose, HashSet`1& useSiteDiagnostics);
    private void LookupExtensionMethodsInSingleBinder(ExtensionMethodScope scope, LookupResult result, string name, int arity, LookupOptions options, HashSet`1& useSiteDiagnostics);
    private void LookupAttributeType(LookupResult result, NamespaceOrTypeSymbol qualifierOpt, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, bool diagnose, HashSet`1& useSiteDiagnostics);
    private bool IsAmbiguousResult(LookupResult result, Symbol& resultSymbol);
    private Symbol ResolveMultipleSymbolsInAttributeTypeLookup(ArrayBuilder`1<Symbol> symbols);
    private bool IsSingleViableAttributeType(LookupResult result, Symbol& symbol);
    private SingleLookupResult GenerateNonViableAttributeTypeResult(Symbol symbol, DiagnosticInfo diagInfo, bool diagnose);
    private bool CheckAttributeTypeViability(Symbol symbol, bool diagnose, DiagnosticInfo& diagInfo);
    internal virtual bool get_SupportsExtensionMethods();
    internal virtual void GetCandidateExtensionMethods(bool searchUsingsNotNamespace, ArrayBuilder`1<MethodSymbol> methods, string name, int arity, LookupOptions options, Binder originalBinder);
    protected static void LookupMembersWithoutInheritance(LookupResult result, TypeSymbol type, string name, int arity, LookupOptions options, Binder originalBinder, TypeSymbol accessThroughType, bool diagnose, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    private void LookupMembersInClass(LookupResult result, TypeSymbol type, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, HashSet`1& useSiteDiagnostics);
    private void AddWinRTMembers(LookupResult result, NamedTypeSymbol type, string name, int arity, LookupOptions options, Binder originalBinder, bool diagnose, HashSet`1& useSiteDiagnostics);
    private void GetWellKnownWinRTMemberInterfaces(NamedTypeSymbol& idictSymbol, NamedTypeSymbol& iroDictSymbol, NamedTypeSymbol& iListSymbol, NamedTypeSymbol& iCollectionSymbol, NamedTypeSymbol& inccSymbol, NamedTypeSymbol& inpcSymbol);
    private static bool ShouldAddWinRTMembersForInterface(NamedTypeSymbol iface, NamedTypeSymbol idictSymbol, NamedTypeSymbol iroDictSymbol, NamedTypeSymbol iListSymbol, NamedTypeSymbol iCollectionSymbol, NamedTypeSymbol inccSymbol, NamedTypeSymbol inpcSymbol);
    private static Symbol GetNearestOtherSymbol(ConsList`1<Symbol> list, TypeSymbol type);
    private static void LookupMembersInInterfaceOnly(LookupResult current, NamedTypeSymbol type, string name, int arity, LookupOptions options, Binder originalBinder, TypeSymbol accessThroughType, bool diagnose, HashSet`1& useSiteDiagnostics);
    private static void LookupMembersInInterfacesWithoutInheritance(LookupResult current, ImmutableArray`1<NamedTypeSymbol> interfaces, string name, int arity, LookupOptions options, Binder originalBinder, TypeSymbol accessThroughType, bool diagnose, HashSet`1& useSiteDiagnostics);
    private void LookupMembersInInterface(LookupResult current, NamedTypeSymbol type, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, HashSet`1& useSiteDiagnostics);
    private void LookupMembersInTypeParameter(LookupResult current, TypeParameterSymbol typeParameter, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, HashSet`1& useSiteDiagnostics);
    private static bool IsDerivedType(NamedTypeSymbol baseType, NamedTypeSymbol derivedType, HashSet`1& useSiteDiagnostics);
    private static void MergeHidingLookupResults(LookupResult resultHiding, LookupResult resultHidden, HashSet`1& useSiteDiagnostics);
    private static bool IsMethodOrIndexer(Symbol symbol);
    internal static ImmutableArray`1<Symbol> GetCandidateMembers(NamespaceOrTypeSymbol nsOrType, string name, LookupOptions options, Binder originalBinder);
    internal static ImmutableArray`1<Symbol> GetCandidateMembers(NamespaceOrTypeSymbol nsOrType, LookupOptions options, Binder originalBinder);
    internal SingleLookupResult CheckViability(Symbol symbol, int arity, LookupOptions options, TypeSymbol accessThroughType, bool diagnose, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    private CSDiagnosticInfo MakeCallMethodsDirectlyDiagnostic(Symbol symbol);
    internal void CheckViability(LookupResult result, ImmutableArray`1<TSymbol> symbols, int arity, LookupOptions options, TypeSymbol accessThroughType, bool diagnose, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    internal bool CanAddLookupSymbolInfo(Symbol symbol, LookupOptions options, TypeSymbol accessThroughType);
    private static TypeSymbol RefineAccessThroughType(LookupOptions options, TypeSymbol accessThroughType);
    private bool IsCrefAccessible(Symbol symbol);
    private static bool IsEffectivelyPrivate(Symbol symbol);
    internal bool IsAccessible(Symbol symbol, HashSet`1& useSiteDiagnostics, TypeSymbol accessThroughType, ConsList`1<Symbol> basesBeingResolved);
    internal bool IsAccessible(Symbol symbol, TypeSymbol accessThroughType, Boolean& failedThroughTypeCheck, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    internal virtual bool IsAccessibleHelper(Symbol symbol, TypeSymbol accessThroughType, Boolean& failedThroughTypeCheck, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    internal bool IsNonInvocableMember(Symbol symbol);
    private bool IsInvocableMember(Symbol symbol);
    private static bool IsInstance(Symbol symbol);
    private static bool WrongArity(Symbol symbol, int arity, bool diagnose, LookupOptions options, DiagnosticInfo& diagInfo);
    internal void AddLookupSymbolsInfo(LookupSymbolsInfo result, LookupOptions options);
    protected virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo info, LookupOptions options, Binder originalBinder);
    internal void AddMemberLookupSymbolsInfo(LookupSymbolsInfo result, NamespaceOrTypeSymbol nsOrType, LookupOptions options, Binder originalBinder);
    private void AddMemberLookupSymbolsInfoInType(LookupSymbolsInfo result, TypeSymbol type, LookupOptions options, Binder originalBinder);
    private void AddMemberLookupSymbolsInfoInSubmissions(LookupSymbolsInfo result, TypeSymbol scriptClass, LookupOptions options, Binder originalBinder);
    private static void AddMemberLookupSymbolsInfoInNamespace(LookupSymbolsInfo result, NamespaceSymbol ns, LookupOptions options, Binder originalBinder);
    private static void AddMemberLookupSymbolsInfoWithoutInheritance(LookupSymbolsInfo result, TypeSymbol type, LookupOptions options, Binder originalBinder, TypeSymbol accessThroughType);
    private void AddWinRTMembersLookupSymbolsInfo(LookupSymbolsInfo result, NamedTypeSymbol type, LookupOptions options, Binder originalBinder, TypeSymbol accessThroughType);
    private void AddMemberLookupSymbolsInfoInClass(LookupSymbolsInfo result, TypeSymbol type, LookupOptions options, Binder originalBinder, TypeSymbol accessThroughType);
    private void AddMemberLookupSymbolsInfoInInterface(LookupSymbolsInfo result, TypeSymbol type, LookupOptions options, Binder originalBinder, TypeSymbol accessThroughType);
    private void AddMemberLookupSymbolsInfoInTypeParameter(LookupSymbolsInfo result, TypeParameterSymbol type, LookupOptions options, Binder originalBinder);
    private bool ValidateLambdaParameterNameConflictsInScope(Location location, string name, DiagnosticBag diagnostics);
    internal bool ValidateDeclarationNameConflictsInScope(Symbol symbol, DiagnosticBag diagnostics);
    private static Location GetLocation(Symbol symbol);
    internal void ValidateParameterNameConflicts(ImmutableArray`1<TypeParameterSymbol> typeParameters, ImmutableArray`1<ParameterSymbol> parameters, DiagnosticBag diagnostics);
    protected bool ValidateNameConflictsInScope(Symbol symbol, Location location, string name, DiagnosticBag diagnostics);
    private BoundExpression BindCompoundAssignment(AssignmentExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindEventAssignment(AssignmentExpressionSyntax node, BoundEventAccess left, BoundExpression right, BinaryOperatorKind opKind, DiagnosticBag diagnostics);
    private static bool IsLegalDynamicOperand(BoundExpression operand);
    private BoundExpression BindDynamicBinaryOperator(BinaryExpressionSyntax node, BinaryOperatorKind kind, BoundExpression left, BoundExpression right, DiagnosticBag diagnostics);
    protected static bool IsSimpleBinaryOperator(SyntaxKind kind);
    private BoundExpression BindSimpleBinaryOperator(BinaryExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindSimpleBinaryOperator(BinaryExpressionSyntax node, DiagnosticBag diagnostics, BoundExpression left, BoundExpression right, Int32& compoundStringLength);
    private static void ReportUnaryOperatorError(CSharpSyntaxNode node, DiagnosticBag diagnostics, string operatorName, BoundExpression operand, LookupResultKind resultKind);
    private void ReportAssignmentOperatorError(AssignmentExpressionSyntax node, DiagnosticBag diagnostics, BoundExpression left, BoundExpression right, LookupResultKind resultKind);
    private void ReportBinaryOperatorError(ExpressionSyntax node, DiagnosticBag diagnostics, SyntaxToken operatorToken, BoundExpression left, BoundExpression right, LookupResultKind resultKind);
    private BoundExpression BindConditionalLogicalOperator(BinaryExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindConditionalLogicalOperator(BinaryExpressionSyntax node, BoundExpression left, BoundExpression right, DiagnosticBag diagnostics);
    private bool IsValidDynamicCondition(BoundExpression left, bool isNegative, HashSet`1& useSiteDiagnostics, MethodSymbol& userDefinedOperator);
    private bool IsValidUserDefinedConditionalLogicalOperator(CSharpSyntaxNode syntax, BinaryOperatorSignature signature, DiagnosticBag diagnostics, MethodSymbol& trueOperator, MethodSymbol& falseOperator);
    private bool HasApplicableBooleanOperator(NamedTypeSymbol containingType, string name, TypeSymbol argumentType, HashSet`1& useSiteDiagnostics, MethodSymbol& operator);
    private TypeSymbol GetBinaryOperatorErrorType(BinaryOperatorKind kind, DiagnosticBag diagnostics, CSharpSyntaxNode node);
    private BinaryOperatorAnalysisResult BinaryOperatorOverloadResolution(BinaryOperatorKind kind, BoundExpression left, BoundExpression right, CSharpSyntaxNode node, DiagnosticBag diagnostics, LookupResultKind& resultKind, ImmutableArray`1& originalUserDefinedOperators);
    private UnaryOperatorAnalysisResult UnaryOperatorOverloadResolution(UnaryOperatorKind kind, BoundExpression operand, CSharpSyntaxNode node, DiagnosticBag diagnostics, LookupResultKind& resultKind, ImmutableArray`1& originalUserDefinedOperators);
    private static object FoldDecimalBinaryOperators(BinaryOperatorKind kind, ConstantValue valueLeft, ConstantValue valueRight);
    private static object FoldUncheckedIntegralBinaryOperator(BinaryOperatorKind kind, ConstantValue valueLeft, ConstantValue valueRight);
    private static object FoldCheckedIntegralBinaryOperator(BinaryOperatorKind kind, ConstantValue valueLeft, ConstantValue valueRight);
    internal static TypeSymbol GetEnumType(BinaryOperatorKind kind, BoundExpression left, BoundExpression right);
    internal static SpecialType GetEnumPromotedType(SpecialType underlyingType);
    private ConstantValue FoldEnumBinaryOperator(CSharpSyntaxNode syntax, BinaryOperatorKind kind, BoundExpression left, BoundExpression right, DiagnosticBag diagnostics);
    private ConstantValue FoldBinaryOperator(CSharpSyntaxNode syntax, BinaryOperatorKind kind, BoundExpression left, BoundExpression right, SpecialType resultType, DiagnosticBag diagnostics);
    private ConstantValue FoldBinaryOperator(CSharpSyntaxNode syntax, BinaryOperatorKind kind, BoundExpression left, BoundExpression right, SpecialType resultType, DiagnosticBag diagnostics, Int32& compoundStringLength);
    private static ConstantValue TryFoldingNullableEquality(BinaryOperatorKind kind, BoundExpression left, BoundExpression right);
    private static object FoldNeverOverflowBinaryOperators(BinaryOperatorKind kind, ConstantValue valueLeft, ConstantValue valueRight);
    private static ConstantValue FoldStringConcatenation(BinaryOperatorKind kind, ConstantValue valueLeft, ConstantValue valueRight, Int32& compoundStringLength);
    private static BinaryOperatorKind SyntaxKindToBinaryOperatorKind(SyntaxKind kind);
    private BoundExpression BindIncrementOperator(CSharpSyntaxNode node, ExpressionSyntax operandSyntax, SyntaxToken operatorToken, DiagnosticBag diagnostics);
    private BoundExpression BindPointerIndirectionExpression(PrefixUnaryExpressionSyntax node, DiagnosticBag diagnostics);
    private static void BindPointerIndirectionExpressionInternal(CSharpSyntaxNode node, BoundExpression operand, DiagnosticBag diagnostics, TypeSymbol& pointedAtType, Boolean& hasErrors);
    private BoundExpression BindAddressOfExpression(PrefixUnaryExpressionSyntax node, DiagnosticBag diagnostics);
    internal bool IsNonMoveableVariable(BoundExpression expr, Symbol& accessedLocalOrParameterOpt);
    private BoundExpression BindUnaryOperator(PrefixUnaryExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindUnaryOperatorCore(CSharpSyntaxNode node, string operatorText, BoundExpression operand, DiagnosticBag diagnostics);
    private ConstantValue FoldEnumUnaryOperator(CSharpSyntaxNode syntax, UnaryOperatorKind kind, BoundExpression operand, DiagnosticBag diagnostics);
    private ConstantValue FoldUnaryOperator(CSharpSyntaxNode syntax, UnaryOperatorKind kind, BoundExpression operand, SpecialType resultType, DiagnosticBag diagnostics);
    private static object FoldNeverOverflowUnaryOperator(UnaryOperatorKind kind, ConstantValue value);
    private static object FoldUncheckedIntegralUnaryOperator(UnaryOperatorKind kind, ConstantValue value);
    private static object FoldCheckedIntegralUnaryOperator(UnaryOperatorKind kind, ConstantValue value);
    private static UnaryOperatorKind SyntaxKindToUnaryOperatorKind(SyntaxKind kind);
    private static BindValueKind GetBinaryAssignmentKind(SyntaxKind kind);
    private static BindValueKind GetUnaryAssignmentKind(SyntaxKind kind);
    private BoundLiteral BindIntegralMinValConstants(PrefixUnaryExpressionSyntax node, BoundExpression operand, DiagnosticBag diagnostics);
    private static bool IsDivisionByZero(BinaryOperatorKind kind, ConstantValue valueRight);
    private BoundExpression BindIsOperator(BinaryExpressionSyntax node, DiagnosticBag diagnostics);
    private static void ReportIsOperatorConstantWarnings(CSharpSyntaxNode syntax, DiagnosticBag diagnostics, TypeSymbol operandType, TypeSymbol targetType, ConversionKind conversionKind, ConstantValue operandConstantValue);
    internal static ConstantValue GetIsOperatorConstantResult(TypeSymbol operandType, TypeSymbol targetType, ConversionKind conversionKind, ConstantValue operandConstantValue);
    private BoundExpression BindAsOperator(BinaryExpressionSyntax node, DiagnosticBag diagnostics);
    private static bool ReportAsOperatorConversionDiagnostics(CSharpSyntaxNode node, DiagnosticBag diagnostics, Compilation compilation, TypeSymbol operandType, TypeSymbol targetType, ConversionKind conversionKind, ConstantValue operandConstantValue);
    private static void ReportAsOperatorConstantWarnings(CSharpSyntaxNode node, DiagnosticBag diagnostics, TypeSymbol operandType, TypeSymbol targetType, ConversionKind conversionKind, ConstantValue operandConstantValue);
    internal static ConstantValue GetAsOperatorConstantResult(TypeSymbol operandType, TypeSymbol targetType, ConversionKind conversionKind, ConstantValue operandConstantValue);
    private BoundExpression GenerateNullCoalescingBadBinaryOpsError(BinaryExpressionSyntax node, BoundExpression leftOperand, BoundExpression rightOperand, Conversion leftConversion, DiagnosticBag diagnostics);
    private BoundExpression BindNullCoalescingOperator(BinaryExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindConditionalOperator(ConditionalExpressionSyntax node, DiagnosticBag diagnostics);
    private static ConstantValue FoldConditionalOperator(BoundExpression condition, BoundExpression trueExpr, BoundExpression falseExpr);
    internal BoundExpression BindQuery(QueryExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindQueryInternal1(QueryTranslationState state, DiagnosticBag diagnostics);
    private static bool IsDegenerateQuery(QueryTranslationState state);
    private BoundExpression BindQueryInternal2(QueryTranslationState state, DiagnosticBag diagnostics);
    private BoundExpression FinalTranslation(QueryTranslationState state, DiagnosticBag diagnostics);
    private static BoundCall ReverseLastTwoParameterOrder(BoundCall result);
    private void ReduceQuery(QueryTranslationState state, DiagnosticBag diagnostics);
    private void ReduceWhere(WhereClauseSyntax where, QueryTranslationState state, DiagnosticBag diagnostics);
    private void ReduceJoin(JoinClauseSyntax join, QueryTranslationState state, DiagnosticBag diagnostics);
    private void ReduceOrderBy(OrderByClauseSyntax orderby, QueryTranslationState state, DiagnosticBag diagnostics);
    private void ReduceFrom(FromClauseSyntax from, QueryTranslationState state, DiagnosticBag diagnostics);
    private static BoundExpression ExtractCastInvocation(BoundCall invocation);
    private UnboundLambda MakePairLambda(CSharpSyntaxNode node, QueryTranslationState state, RangeVariableSymbol x1, RangeVariableSymbol x2);
    private void ReduceLet(LetClauseSyntax let, QueryTranslationState state, DiagnosticBag diagnostics);
    private BoundQueryClause MakeQueryClause(CSharpSyntaxNode syntax, BoundExpression expression, RangeVariableSymbol definedSymbol, BoundExpression queryInvocation, BoundExpression castInvocation, BoundExpression unoptimizedForm);
    private BoundExpression MakePair(CSharpSyntaxNode node, string field1Name, BoundExpression field1Value, string field2Name, BoundExpression field2Value, QueryTranslationState state, DiagnosticBag diagnostics);
    private TypeSymbol TypeOrError(BoundExpression e);
    private UnboundLambda MakeQueryUnboundLambda(RangeVariableMap qvm, RangeVariableSymbol parameter, ExpressionSyntax expression);
    private UnboundLambda MakeQueryUnboundLambda(RangeVariableMap qvm, ImmutableArray`1<RangeVariableSymbol> parameters, ExpressionSyntax expression);
    private UnboundLambda MakeQueryUnboundLambdaWithCast(RangeVariableMap qvm, RangeVariableSymbol parameter, ExpressionSyntax expression, TypeSyntax castTypeSyntax, TypeSymbol castType);
    private UnboundLambda MakeQueryUnboundLambda(RangeVariableMap qvm, ImmutableArray`1<RangeVariableSymbol> parameters, CSharpSyntaxNode node, LambdaBodyFactory bodyFactory);
    private UnboundLambda MakeQueryUnboundLambda(CSharpSyntaxNode node, QueryUnboundLambdaState state);
    protected BoundCall MakeQueryInvocation(CSharpSyntaxNode node, BoundExpression receiver, string methodName, BoundExpression arg, DiagnosticBag diagnostics);
    protected BoundCall MakeQueryInvocation(CSharpSyntaxNode node, BoundExpression receiver, string methodName, ImmutableArray`1<BoundExpression> args, DiagnosticBag diagnostics);
    protected BoundCall MakeQueryInvocation(CSharpSyntaxNode node, BoundExpression receiver, string methodName, TypeSyntax typeArgSyntax, TypeSymbol typeArg, DiagnosticBag diagnostics);
    protected BoundCall MakeQueryInvocation(CSharpSyntaxNode node, BoundExpression receiver, string methodName, SeparatedSyntaxList`1<TypeSyntax> typeArgsSyntax, ImmutableArray`1<TypeSymbol> typeArgs, ImmutableArray`1<BoundExpression> args, DiagnosticBag diagnostics);
    protected BoundExpression MakeConstruction(CSharpSyntaxNode node, NamedTypeSymbol toCreate, ImmutableArray`1<BoundExpression> args, DiagnosticBag diagnostics);
    internal void ReportQueryLookupFailed(CSharpSyntaxNode queryClause, BoundExpression instanceArgument, string name, ImmutableArray`1<Symbol> symbols, DiagnosticBag diagnostics);
    private bool ImplementsStandardQueryInterface(TypeSymbol instanceType, string name, HashSet`1& useSiteDiagnostics);
    private static bool HasUniqueInterface(TypeSymbol instanceType, NamedTypeSymbol interfaceType, HashSet`1& useSiteDiagnostics);
    private static bool HasUniqueInterface(TypeSymbol instanceType, NamedTypeSymbol interfaceType, Boolean& nonUnique, HashSet`1& useSiteDiagnostics);
    private bool HasCastToQueryProvider(TypeSymbol instanceType, HashSet`1& useSiteDiagnostics);
    private static bool IsJoinRangeVariableInLeftKey(SimpleNameSyntax node);
    private static bool IsInJoinRightKey(SimpleNameSyntax node);
    internal static void ReportQueryInferenceFailed(CSharpSyntaxNode queryClause, string methodName, BoundExpression receiver, AnalyzedArguments arguments, ImmutableArray`1<Symbol> symbols, DiagnosticBag diagnostics);
    private static bool ReportQueryInferenceFailedSelectMany(FromClauseSyntax fromClause, string methodName, BoundExpression receiver, AnalyzedArguments arguments, ImmutableArray`1<Symbol> symbols, DiagnosticBag diagnostics);
    internal virtual ImmutableHashSet`1<Symbol> get_LockedOrDisposedVariables();
    public virtual BoundStatement BindStatement(StatementSyntax node, DiagnosticBag diagnostics);
    private BoundStatement BindCheckedStatement(CheckedStatementSyntax node, DiagnosticBag diagnostics);
    private BoundStatement BindUnsafeStatement(UnsafeStatementSyntax node, DiagnosticBag diagnostics);
    private BoundStatement BindFixedStatement(FixedStatementSyntax node, DiagnosticBag diagnostics);
    private BoundStatement BindFixedStatementParts(FixedStatementSyntax node, DiagnosticBag diagnostics);
    private BoundStatement BindYieldReturnStatement(YieldStatementSyntax node, DiagnosticBag diagnostics);
    private BoundStatement BindYieldBreakStatement(YieldStatementSyntax node, DiagnosticBag diagnostics);
    private BoundStatement BindLockStatement(LockStatementSyntax node, DiagnosticBag diagnostics);
    internal virtual BoundStatement BindLockStatementParts(DiagnosticBag diagnostics, Binder originalBinder);
    private BoundStatement BindUsingStatement(UsingStatementSyntax node, DiagnosticBag diagnostics);
    internal virtual BoundStatement BindUsingStatementParts(DiagnosticBag diagnostics, Binder originalBinder);
    internal BoundStatement BindPossibleEmbeddedStatement(StatementSyntax node, DiagnosticBag diagnostics);
    private BoundThrowStatement BindThrow(ThrowStatementSyntax node, DiagnosticBag diagnostics);
    private static BoundStatement BindEmpty(EmptyStatementSyntax node);
    private BoundLabeledStatement BindLabeled(LabeledStatementSyntax node, DiagnosticBag diagnostics);
    private BoundStatement BindGoto(GotoStatementSyntax node, DiagnosticBag diagnostics);
    public BoundExpressionStatement BindExpressionStatement(ExpressionStatementSyntax node, DiagnosticBag diagnostics);
    public BoundExpressionStatement BindExpressionStatement(CSharpSyntaxNode node, ExpressionSyntax syntax, bool allowsAnyExpression, DiagnosticBag diagnostics);
    private void CheckForUnobservedAwaitable(BoundExpression expression, DiagnosticBag diagnostics);
    private BoundStatement BindDeclarationStatement(LocalDeclarationStatementSyntax node, DiagnosticBag diagnostics);
    private TypeSymbol BindVariableType(CSharpSyntaxNode declarationNode, DiagnosticBag diagnostics, TypeSyntax typeSyntax, Boolean& isConst, Boolean& isVar, AliasSymbol& alias);
    internal BoundExpression BindInferredVariableInitializer(DiagnosticBag diagnostics, EqualsValueClauseSyntax initializer, CSharpSyntaxNode errorSyntax);
    protected BoundLocalDeclaration BindVariableDeclaration(LocalDeclarationKind kind, bool isVar, VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax, TypeSymbol declTypeOpt, AliasSymbol aliasOpt, DiagnosticBag diagnostics, CSharpSyntaxNode associatedSyntaxNode);
    protected BoundLocalDeclaration BindVariableDeclaration(SourceLocalSymbol localSymbol, LocalDeclarationKind kind, bool isVar, VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax, TypeSymbol declTypeOpt, AliasSymbol aliasOpt, DiagnosticBag diagnostics, CSharpSyntaxNode associatedSyntaxNode);
    private ImmutableArray`1<BoundExpression> BindDeclaratorArguments(VariableDeclaratorSyntax declarator, DiagnosticBag diagnostics);
    private SourceLocalSymbol LocateDeclaredVariableSymbol(VariableDeclaratorSyntax declarator, TypeSyntax typeSyntax);
    private bool IsValidFixedVariableInitializer(TypeSymbol declType, SourceLocalSymbol localSymbol, BoundExpression& initializerOpt, DiagnosticBag diagnostics);
    private BoundExpression GetFixedLocalCollectionInitializer(BoundExpression initializer, TypeSymbol elementType, TypeSymbol declType, bool hasErrors, DiagnosticBag diagnostics);
    private static ErrorCode GetStandardLvalueError(BindValueKind kind);
    private static ErrorCode GetThisLvalueError(BindValueKind kind);
    private static ErrorCode GetRangeLvalueError(BindValueKind kind);
    private static bool CheckLocalVariable(CSharpSyntaxNode tree, LocalSymbol local, BindValueKind kind, bool checkingReceiver, DiagnosticBag diagnostics);
    private static void ReportReadOnlyError(FieldSymbol field, CSharpSyntaxNode node, BindValueKind kind, bool checkingReceiver, DiagnosticBag diagnostics);
    private bool CheckIsVariable(CSharpSyntaxNode node, BoundExpression expr, BindValueKind kind, bool checkingReceiver, DiagnosticBag diagnostics);
    private bool CheckIsValidReceiverForVariable(CSharpSyntaxNode node, BoundExpression receiver, BindValueKind kind, DiagnosticBag diagnostics);
    private static bool CheckNotNamespaceOrType(BoundExpression expr, DiagnosticBag diagnostics);
    private BoundAssignmentOperator BindAssignment(AssignmentExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundAssignmentOperator BindAssignment(AssignmentExpressionSyntax node, BoundExpression op1, BoundExpression op2, DiagnosticBag diagnostics);
    private static PropertySymbol GetPropertySymbol(BoundExpression expr, BoundExpression& receiver, CSharpSyntaxNode& propertySyntax);
    private static EventSymbol GetEventSymbol(BoundExpression expr, BoundExpression& receiver, CSharpSyntaxNode& eventSyntax);
    private BoundExpression CheckValue(BoundExpression expr, BindValueKind valueKind, DiagnosticBag diagnostics);
    internal bool CheckValueKind(BoundExpression expr, BindValueKind valueKind, DiagnosticBag diagnostics);
    private bool CheckEventValueKind(BoundEventAccess boundEvent, BindValueKind valueKind, DiagnosticBag diagnostics);
    private DiagnosticInfo GetBadEventUsageDiagnosticInfo(EventSymbol eventSymbol);
    private bool CheckPropertyValueKind(BoundExpression expr, BindValueKind valueKind, DiagnosticBag diagnostics);
    internal static bool AccessingAutopropertyFromConstructor(BoundPropertyAccess propertyAccess, Symbol fromMember);
    internal static bool AccessingAutopropertyFromConstructor(BoundExpression receiver, PropertySymbol propertySymbol, Symbol fromMember);
    private static bool IsConstructorOrField(Symbol member, bool isStatic);
    private static bool RequiresVariableReceiver(BoundExpression receiver, Symbol symbol);
    private TypeSymbol GetAccessThroughType(BoundExpression receiver);
    private BoundExpression BindPossibleArrayInitializer(ExpressionSyntax node, TypeSymbol destinationType, DiagnosticBag diagnostics);
    internal static void DeclareLocalVariable(SourceLocalSymbol symbol, SyntaxToken identifierToken, TypeSymbol type);
    protected virtual SourceLocalSymbol LookupLocal(SyntaxToken nameToken);
    public BoundBlock BindBlock(BlockSyntax node, DiagnosticBag diagnostics);
    internal static BoundBlock BindBlock(BlockSyntax node, DiagnosticBag diagnostics, Binder blockBinder);
    internal BoundExpression GenerateConversionForAssignment(TypeSymbol targetType, BoundExpression expression, DiagnosticBag diagnostics, bool isDefaultParameter);
    internal void GenerateAnonymousFunctionConversionError(DiagnosticBag diagnostics, CSharpSyntaxNode syntax, UnboundLambda anonymousFunction, TypeSymbol targetType);
    protected static void GenerateImplicitConversionError(DiagnosticBag diagnostics, Compilation compilation, CSharpSyntaxNode syntax, Conversion conversion, TypeSymbol sourceType, TypeSymbol targetType, ConstantValue sourceConstantValueOpt);
    protected void GenerateImplicitConversionError(DiagnosticBag diagnostics, CSharpSyntaxNode syntax, Conversion conversion, BoundExpression expression, TypeSymbol targetType);
    private BoundIfStatement BindIfStatement(IfStatementSyntax node, DiagnosticBag diagnostics);
    protected BoundExpression BindBooleanExpression(ExpressionSyntax node, DiagnosticBag diagnostics);
    public BoundSwitchStatement BindSwitchStatement(SwitchStatementSyntax node, DiagnosticBag diagnostics);
    internal virtual BoundSwitchStatement BindSwitchExpressionAndSections(SwitchStatementSyntax node, Binder originalBinder, DiagnosticBag diagnostics);
    public BoundWhileStatement BindWhile(WhileStatementSyntax node, DiagnosticBag diagnostics);
    internal virtual BoundWhileStatement BindWhileParts(DiagnosticBag diagnostics, Binder originalBinder);
    public BoundDoStatement BindDo(DoStatementSyntax node, DiagnosticBag diagnostics);
    internal virtual BoundDoStatement BindDoParts(DiagnosticBag diagnostics, Binder originalBinder);
    public BoundForStatement BindFor(ForStatementSyntax node, DiagnosticBag diagnostics);
    internal virtual BoundForStatement BindForParts(DiagnosticBag diagnostics, Binder originalBinder);
    internal BoundStatement BindForOrUsingOrFixedDeclarations(VariableDeclarationSyntax nodeOpt, LocalDeclarationKind localKind, DiagnosticBag diagnostics, ImmutableArray`1& declarations);
    internal BoundStatement BindStatementExpressionList(SeparatedSyntaxList`1<ExpressionSyntax> statements, DiagnosticBag diagnostics);
    public BoundStatement BindForEach(ForEachStatementSyntax node, DiagnosticBag diagnostics);
    internal virtual BoundStatement BindForEachParts(DiagnosticBag diagnostics, Binder originalBinder);
    public BoundStatement BindBreak(BreakStatementSyntax node, DiagnosticBag diagnostics);
    public BoundStatement BindContinue(ContinueStatementSyntax node, DiagnosticBag diagnostics);
    private static SwitchBinder GetSwitchBinder(Binder binder);
    protected static bool IsInAsyncMethod(MethodSymbol method);
    protected bool IsInAsyncMethod();
    protected bool IsTaskReturningAsyncMethod();
    protected bool IsGenericTaskReturningAsyncMethod();
    protected virtual TypeSymbol GetCurrentReturnType();
    private BoundReturnStatement BindReturn(ReturnStatementSyntax syntax, DiagnosticBag diagnostics);
    internal BoundExpression CreateReturnConversion(CSharpSyntaxNode syntax, DiagnosticBag diagnostics, BoundExpression argument, TypeSymbol returnType);
    private BoundTryStatement BindTryStatement(TryStatementSyntax node, DiagnosticBag diagnostics);
    private ImmutableArray`1<BoundCatchBlock> BindCatchBlocks(SyntaxList`1<CatchClauseSyntax> catchClauses, DiagnosticBag diagnostics);
    private BoundCatchBlock BindCatchBlock(CatchClauseSyntax node, ArrayBuilder`1<BoundCatchBlock> previousBlocks, DiagnosticBag diagnostics);
    private BoundExpression BindCatchFilter(CatchFilterClauseSyntax filter, DiagnosticBag diagnostics);
    private void ReportCantConvertLambdaReturn(CSharpSyntaxNode syntax, DiagnosticBag diagnostics);
    private static bool IsValidStatementExpression(CSharpSyntaxNode syntax, BoundExpression expression);
    internal BoundBlock CreateBlockFromExpression(CSharpSyntaxNode node, ImmutableArray`1<LocalSymbol> locals, ExpressionSyntax expressionSyntax, BoundExpression expression, DiagnosticBag diagnostics);
    public BoundBlock BindExpressionBodyAsBlock(ArrowExpressionClauseSyntax expressionBody, DiagnosticBag diagnostics);
    public BoundBlock BindLambdaExpressionAsBlock(ExpressionSyntax body, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<LocalSymbol> get_Locals();
    internal virtual ImmutableArray`1<LabelSymbol> get_Labels();
    internal TypeSymbol BindType(TypeSyntax syntax, DiagnosticBag diagnostics, Boolean& isVar);
    internal TypeSymbol BindType(TypeSyntax syntax, DiagnosticBag diagnostics, Boolean& isVar, AliasSymbol& alias);
    private Symbol BindTypeOrAlias(TypeSyntax syntax, DiagnosticBag diagnostics, Boolean& isVar);
    internal TypeSymbol BindType(ExpressionSyntax syntax, DiagnosticBag diagnostics, ConsList`1<Symbol> basesBeingResolved);
    internal TypeSymbol BindType(ExpressionSyntax syntax, DiagnosticBag diagnostics, AliasSymbol& alias, ConsList`1<Symbol> basesBeingResolved);
    internal Symbol BindTypeOrAlias(ExpressionSyntax syntax, DiagnosticBag diagnostics, ConsList`1<Symbol> basesBeingResolved);
    private NamespaceOrTypeSymbol GetContainingNamespaceOrType(Symbol symbol);
    internal Symbol BindNamespaceAliasSymbol(IdentifierNameSyntax node, DiagnosticBag diagnostics);
    internal NamespaceOrTypeSymbol BindNamespaceOrTypeSymbol(ExpressionSyntax syntax, DiagnosticBag diagnostics, ConsList`1<Symbol> basesBeingResolved);
    internal NamespaceOrTypeSymbol BindNamespaceOrTypeSymbol(ExpressionSyntax syntax, DiagnosticBag diagnostics, ConsList`1<Symbol> basesBeingResolved, bool suppressUseSiteDiagnostics);
    internal Symbol BindNamespaceOrTypeOrAliasSymbol(ExpressionSyntax syntax, DiagnosticBag diagnostics, ConsList`1<Symbol> basesBeingResolved, bool suppressUseSiteDiagnostics);
    private Symbol BindPredefinedTypeSymbol(PredefinedTypeSyntax node, DiagnosticBag diagnostics);
    private Symbol BindSimpleNamespaceOrTypeOrAliasSymbol(SimpleNameSyntax syntax, DiagnosticBag diagnostics, ConsList`1<Symbol> basesBeingResolved, bool suppressUseSiteDiagnostics, NamespaceOrTypeSymbol qualifierOpt);
    private static bool IsViableType(LookupResult result);
    protected Symbol BindNonGenericSimpleNamespaceOrTypeOrAliasSymbol(IdentifierNameSyntax node, DiagnosticBag diagnostics, ConsList`1<Symbol> basesBeingResolved, bool suppressUseSiteDiagnostics, NamespaceOrTypeSymbol qualifierOpt, bool isNameofArgument, ArrayBuilder`1<Symbol> symbols);
    private void ReportUseSiteDiagnosticForDynamic(DiagnosticBag diagnostics, IdentifierNameSyntax node);
    private static LookupOptions GetSimpleNameLookupOptions(NameSyntax node, bool isVerbatimIdentifier);
    private static Symbol UnwrapAliasNoDiagnostics(Symbol symbol, ConsList`1<Symbol> basesBeingResolved);
    private Symbol UnwrapAlias(Symbol symbol, DiagnosticBag diagnostics, CSharpSyntaxNode syntax, ConsList`1<Symbol> basesBeingResolved);
    private Symbol UnwrapAlias(Symbol symbol, AliasSymbol& alias, DiagnosticBag diagnostics, CSharpSyntaxNode syntax, ConsList`1<Symbol> basesBeingResolved);
    private NamedTypeSymbol BindGenericSimpleNamespaceOrTypeOrAliasSymbol(GenericNameSyntax node, DiagnosticBag diagnostics, ConsList`1<Symbol> basesBeingResolved, NamespaceOrTypeSymbol qualifierOpt);
    private NamedTypeSymbol LookupGenericTypeName(DiagnosticBag diagnostics, ConsList`1<Symbol> basesBeingResolved, NamespaceOrTypeSymbol qualifierOpt, GenericNameSyntax node, string plainName, int arity, LookupOptions options);
    private ExtendedErrorTypeSymbol CreateErrorIfLookupOnTypeParameter(CSharpSyntaxNode node, NamespaceOrTypeSymbol qualifierOpt, string name, int arity, DiagnosticBag diagnostics);
    private ImmutableArray`1<TypeSymbol> BindTypeArguments(SeparatedSyntaxList`1<TypeSyntax> typeArguments, DiagnosticBag diagnostics, ConsList`1<Symbol> basesBeingResolved);
    private TypeSymbol BindTypeArgument(TypeSyntax typeArgument, DiagnosticBag diagnostics, ConsList`1<Symbol> basesBeingResolved);
    private NamedTypeSymbol ConstructNamedTypeUnlessTypeArgumentOmitted(CSharpSyntaxNode typeSyntax, NamedTypeSymbol type, SeparatedSyntaxList`1<TypeSyntax> typeArgumentsSyntax, ImmutableArray`1<TypeSymbol> typeArguments, DiagnosticBag diagnostics);
    private static BoundMethodOrPropertyGroup ConstructBoundMemberGroupAndReportOmittedTypeArguments(CSharpSyntaxNode syntax, SeparatedSyntaxList`1<TypeSyntax> typeArgumentsSyntax, ImmutableArray`1<TypeSymbol> typeArguments, BoundExpression receiver, string plainName, ArrayBuilder`1<Symbol> members, LookupResult lookupResult, BoundMethodGroupFlags methodGroupFlags, bool hasErrors, DiagnosticBag diagnostics);
    private NamedTypeSymbol ConstructNamedType(NamedTypeSymbol type, CSharpSyntaxNode typeSyntax, SeparatedSyntaxList`1<TypeSyntax> typeArgumentsSyntax, ImmutableArray`1<TypeSymbol> typeArguments, ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    private bool get_ShouldCheckConstraints();
    private NamespaceOrTypeSymbol BindQualifiedName(ExpressionSyntax leftName, SimpleNameSyntax rightName, DiagnosticBag diagnostics, ConsList`1<Symbol> basesBeingResolved, bool suppressUseSiteDiagnostics);
    internal NamedTypeSymbol GetSpecialType(SpecialType typeId, DiagnosticBag diagnostics, CSharpSyntaxNode node);
    internal static NamedTypeSymbol GetSpecialType(CSharpCompilation compilation, SpecialType typeId, CSharpSyntaxNode node, DiagnosticBag diagnostics);
    internal Symbol GetSpecialTypeMember(SpecialMember member, DiagnosticBag diagnostics, CSharpSyntaxNode syntax);
    internal static bool TryGetSpecialTypeMember(CSharpCompilation compilation, SpecialMember specialMember, CSharpSyntaxNode syntax, DiagnosticBag diagnostics, TSymbol& symbol);
    internal static bool ReportUseSiteDiagnostics(Symbol symbol, DiagnosticBag diagnostics, CSharpSyntaxNode node);
    internal static bool ReportUseSiteDiagnostics(Symbol symbol, DiagnosticBag diagnostics, Location location);
    internal NamedTypeSymbol GetWellKnownType(WellKnownType type, DiagnosticBag diagnostics, CSharpSyntaxNode node);
    internal static Symbol GetWellKnownTypeMember(CSharpCompilation compilation, WellKnownMember member, DiagnosticBag diagnostics, Location location, CSharpSyntaxNode syntax, bool isOptional);
    internal static Symbol GetWellKnownTypeMember(CSharpCompilation compilation, WellKnownMember member, DiagnosticInfo& diagnosticInfo, bool isOptional);
    internal Symbol ResultSymbol(LookupResult result, string simpleName, int arity, CSharpSyntaxNode where, DiagnosticBag diagnostics, bool suppressUseSiteDiagnostics, Boolean& wasError, NamespaceOrTypeSymbol qualifierOpt, LookupOptions options);
    private static AssemblySymbol GetContainingAssembly(Symbol symbol);
    private BestSymbolInfo GetBestSymbolInfo(ArrayBuilder`1<Symbol> symbols, BestSymbolInfo& secondBest);
    private static BestSymbolLocation GetLocation(CSharpCompilation compilation, Symbol symbol);
    private CSDiagnosticInfo NotFound(CSharpSyntaxNode where, string simpleName, int arity, string whereText, DiagnosticBag diagnostics, string aliasOpt, NamespaceOrTypeSymbol qualifierOpt, LookupOptions options);
    private AssemblySymbol GetForwardedToAssembly(string fullName, int arity, Boolean& encounteredCycle);
    internal static void CheckFeatureAvailability(Location location, MessageID feature, DiagnosticBag diagnostics);
    internal bool get_InUnsafeRegion();
    private bool ReportUnsafeIfNotAllowed(CSharpSyntaxNode node, DiagnosticBag diagnostics);
    private bool ReportUnsafeIfNotAllowed(CSharpSyntaxNode node, TypeSymbol sizeOfTypeOpt, DiagnosticBag diagnostics);
    internal bool ReportUnsafeIfNotAllowed(Location location, DiagnosticBag diagnostics);
    private bool ReportUnsafeIfNotAllowed(Location location, TypeSymbol sizeOfTypeOpt, DiagnosticBag diagnostics);
    private CSDiagnosticInfo GetUnsafeDiagnosticInfo(TypeSymbol sizeOfTypeOpt);
    internal ImmutableArray`1<Symbol> BindXmlNameAttribute(XmlNameAttributeSyntax syntax, HashSet`1& useSiteDiagnostics);
    [CompilerGeneratedAttribute]
private bool <ImplementsWinRTAsyncInterface>b__307_0(NamedTypeSymbol i);
}
internal class Microsoft.CodeAnalysis.CSharp.BinderFactory : object {
    private ConcurrentCache`2<BinderCacheKey, Binder> _binderCache;
    private CSharpCompilation _compilation;
    private SyntaxTree _syntaxTree;
    private BuckStopsHereBinder _buckStopsHereBinder;
    private ObjectPool`1<BinderFactoryVisitor> _binderFactoryVisitorPool;
    internal SyntaxTree SyntaxTree { get; }
    private bool InScript { get; }
    internal BinderFactory(CSharpCompilation compilation, SyntaxTree syntaxTree);
    internal static Binder MakeCrefBinder(CrefSyntax crefSyntax, MemberDeclarationSyntax memberSyntax, BinderFactory factory, bool inParameterOrReturnType);
    private static Binder MakeCrefBinderInternal(CrefSyntax crefSyntax, Binder binder, bool inParameterOrReturnType);
    internal static MemberDeclarationSyntax GetAssociatedMemberForXmlSyntax(CSharpSyntaxNode xmlSyntax);
    private static DocumentationCommentTriviaSyntax GetEnclosingDocumentationComment(CSharpSyntaxNode xmlSyntax);
    internal SyntaxTree get_SyntaxTree();
    private bool get_InScript();
    internal Binder GetBinder(CSharpSyntaxNode node, CSharpSyntaxNode memberDeclarationOpt, Symbol memberOpt);
    internal Binder GetBinder(CSharpSyntaxNode node, int position, CSharpSyntaxNode memberDeclarationOpt, Symbol memberOpt);
    internal InContainerBinder GetImportsBinder(CSharpSyntaxNode unit, bool inUsing);
    [CompilerGeneratedAttribute]
private BinderFactoryVisitor <.ctor>b__11_0();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.BinderFlags : Enum {
    public UInt32 value__;
    public static BinderFlags None;
    public static BinderFlags SuppressConstraintChecks;
    public static BinderFlags SuppressObsoleteChecks;
    public static BinderFlags ConstructorInitializer;
    public static BinderFlags FieldInitializer;
    public static BinderFlags ObjectInitializerMember;
    public static BinderFlags CollectionInitializerAddMethod;
    public static BinderFlags AttributeArgument;
    public static BinderFlags GenericConstraintsClause;
    public static BinderFlags Cref;
    public static BinderFlags CrefParameterOrReturnType;
    public static BinderFlags UnsafeRegion;
    public static BinderFlags SuppressUnsafeDiagnostics;
    public static BinderFlags SemanticModel;
    public static BinderFlags EarlyAttributeBinding;
    public static BinderFlags CheckedRegion;
    public static BinderFlags UncheckedRegion;
    public static BinderFlags InLockBody;
    public static BinderFlags InCatchBlock;
    public static BinderFlags InFinallyBlock;
    public static BinderFlags InTryBlockOfTryCatch;
    public static BinderFlags InCatchFilter;
    public static BinderFlags InNestedFinallyBlock;
    public static BinderFlags IgnoreAccessibility;
    public static BinderFlags ParameterDefaultValue;
    public static BinderFlags AllowManagedAddressOf;
    public static BinderFlags AllowAwaitInUnsafeContext;
    public static BinderFlags IgnoreCorLibraryDuplicatedTypes;
    public static BinderFlags InScriptUsing;
    public static BinderFlags InLoadedSyntaxTree;
    public static BinderFlags AllClearedAtExecutableCodeBoundary;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.BinderFlagsExtensions : object {
    [ExtensionAttribute]
public static bool Includes(BinderFlags self, BinderFlags other);
}
internal class Microsoft.CodeAnalysis.CSharp.BlockBinder : LocalScopeBinder {
    private SyntaxList`1<StatementSyntax> _statements;
    public BlockBinder(Binder enclosing, SyntaxList`1<StatementSyntax> statements);
    public BlockBinder(Binder enclosing, SyntaxList`1<StatementSyntax> statements, BinderFlags additionalFlags);
    protected virtual ImmutableArray`1<LocalSymbol> BuildLocals();
    protected virtual ImmutableArray`1<LabelSymbol> BuildLabels();
    internal virtual ImmutableArray`1<LocalSymbol> GetDeclaredLocalsForScope(CSharpSyntaxNode node);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundAddressOfOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Operand>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFixedStatementAddressOf>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.IAddressOfExpression.Reference { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Operand { get; }
    public bool IsFixedStatementAddressOf { get; }
    public BoundAddressOfOperator(CSharpSyntaxNode syntax, BoundExpression operand, bool isFixedStatementAddressOf, TypeSymbol type, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IAddressOfExpression.get_Reference();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Operand();
    [CompilerGeneratedAttribute]
public bool get_IsFixedStatementAddressOf();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundAddressOfOperator Update(BoundExpression operand, bool isFixedStatementAddressOf, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundAnonymousObjectCreationExpression : BoundExpression {
    [CompilerGeneratedAttribute]
private MethodSymbol <Constructor>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundAnonymousPropertyDeclaration> <Declarations>k__BackingField;
    public Symbol ExpressionSymbol { get; }
    protected OperationKind ExpressionKind { get; }
    public MethodSymbol Constructor { get; }
    public ImmutableArray`1<BoundExpression> Arguments { get; }
    public ImmutableArray`1<BoundAnonymousPropertyDeclaration> Declarations { get; }
    public BoundAnonymousObjectCreationExpression(CSharpSyntaxNode syntax, MethodSymbol constructor, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<BoundAnonymousPropertyDeclaration> declarations, TypeSymbol type, bool hasErrors);
    public virtual Symbol get_ExpressionSymbol();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public MethodSymbol get_Constructor();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_Arguments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundAnonymousPropertyDeclaration> get_Declarations();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundAnonymousObjectCreationExpression Update(MethodSymbol constructor, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<BoundAnonymousPropertyDeclaration> declarations, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundAnonymousPropertyDeclaration : BoundExpression {
    [CompilerGeneratedAttribute]
private PropertySymbol <Property>k__BackingField;
    public Symbol ExpressionSymbol { get; }
    protected OperationKind ExpressionKind { get; }
    public PropertySymbol Property { get; }
    public BoundAnonymousPropertyDeclaration(CSharpSyntaxNode syntax, PropertySymbol property, TypeSymbol type, bool hasErrors);
    public BoundAnonymousPropertyDeclaration(CSharpSyntaxNode syntax, PropertySymbol property, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public PropertySymbol get_Property();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundAnonymousPropertyDeclaration Update(PropertySymbol property, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundArgList : BoundExpression {
    protected OperationKind ExpressionKind { get; }
    public BoundArgList(CSharpSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    public BoundArgList(CSharpSyntaxNode syntax, TypeSymbol type);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundArgList Update(TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundArgListOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<RefKind> <ArgumentRefKindsOpt>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public object Display { get; }
    public ImmutableArray`1<BoundExpression> Arguments { get; }
    public ImmutableArray`1<RefKind> ArgumentRefKindsOpt { get; }
    public BoundArgListOperator(CSharpSyntaxNode syntax, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<RefKind> argumentRefKindsOpt, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual object get_Display();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_Arguments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<RefKind> get_ArgumentRefKindsOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundArgListOperator Update(ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<RefKind> argumentRefKindsOpt, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundArrayAccess : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <Indices>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.IArrayElementReferenceExpression.ArrayReference { get; }
    private ImmutableArray`1<IOperation> Microsoft.CodeAnalysis.Semantics.IArrayElementReferenceExpression.Indices { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Expression { get; }
    public ImmutableArray`1<BoundExpression> Indices { get; }
    public BoundArrayAccess(CSharpSyntaxNode syntax, BoundExpression expression, ImmutableArray`1<BoundExpression> indices, TypeSymbol type, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IArrayElementReferenceExpression.get_ArrayReference();
    private sealed virtual override ImmutableArray`1<IOperation> Microsoft.CodeAnalysis.Semantics.IArrayElementReferenceExpression.get_Indices();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Expression();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_Indices();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundArrayAccess Update(BoundExpression expression, ImmutableArray`1<BoundExpression> indices, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundArrayCreation : BoundExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <Bounds>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundArrayInitialization <InitializerOpt>k__BackingField;
    private ITypeSymbol Microsoft.CodeAnalysis.Semantics.IArrayCreationExpression.ElementType { get; }
    private ImmutableArray`1<IOperation> Microsoft.CodeAnalysis.Semantics.IArrayCreationExpression.DimensionSizes { get; }
    private IArrayInitializer Microsoft.CodeAnalysis.Semantics.IArrayCreationExpression.Initializer { get; }
    protected OperationKind ExpressionKind { get; }
    public ImmutableArray`1<BoundExpression> Bounds { get; }
    public BoundArrayInitialization InitializerOpt { get; }
    public BoundArrayCreation(CSharpSyntaxNode syntax, ImmutableArray`1<BoundExpression> bounds, BoundArrayInitialization initializerOpt, TypeSymbol type, bool hasErrors);
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.Semantics.IArrayCreationExpression.get_ElementType();
    private sealed virtual override ImmutableArray`1<IOperation> Microsoft.CodeAnalysis.Semantics.IArrayCreationExpression.get_DimensionSizes();
    private sealed virtual override IArrayInitializer Microsoft.CodeAnalysis.Semantics.IArrayCreationExpression.get_Initializer();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_Bounds();
    [CompilerGeneratedAttribute]
public BoundArrayInitialization get_InitializerOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundArrayCreation Update(ImmutableArray`1<BoundExpression> bounds, BoundArrayInitialization initializerOpt, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundArrayInitialization : BoundExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <Initializers>k__BackingField;
    public ImmutableArray`1<IOperation> ElementValues { get; }
    protected OperationKind ExpressionKind { get; }
    public ImmutableArray`1<BoundExpression> Initializers { get; }
    public BoundArrayInitialization(CSharpSyntaxNode syntax, ImmutableArray`1<BoundExpression> initializers, bool hasErrors);
    public sealed virtual ImmutableArray`1<IOperation> get_ElementValues();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_Initializers();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundArrayInitialization Update(ImmutableArray`1<BoundExpression> initializers);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundArrayLength : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Expression>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Expression { get; }
    public BoundArrayLength(CSharpSyntaxNode syntax, BoundExpression expression, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Expression();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundArrayLength Update(BoundExpression expression, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundAsOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Operand>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundTypeExpression <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private Conversion <Conversion>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.IConversionExpression.Operand { get; }
    private ConversionKind Microsoft.CodeAnalysis.Semantics.IConversionExpression.ConversionKind { get; }
    private bool Microsoft.CodeAnalysis.Semantics.IConversionExpression.IsExplicit { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.OperatorMethod { get; }
    private bool Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.UsesOperatorMethod { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Operand { get; }
    public BoundTypeExpression TargetType { get; }
    public Conversion Conversion { get; }
    public BoundAsOperator(CSharpSyntaxNode syntax, BoundExpression operand, BoundTypeExpression targetType, Conversion conversion, TypeSymbol type, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IConversionExpression.get_Operand();
    private sealed virtual override ConversionKind Microsoft.CodeAnalysis.Semantics.IConversionExpression.get_ConversionKind();
    private sealed virtual override bool Microsoft.CodeAnalysis.Semantics.IConversionExpression.get_IsExplicit();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.get_OperatorMethod();
    private sealed virtual override bool Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.get_UsesOperatorMethod();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Operand();
    [CompilerGeneratedAttribute]
public BoundTypeExpression get_TargetType();
    [CompilerGeneratedAttribute]
public Conversion get_Conversion();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundAsOperator Update(BoundExpression operand, BoundTypeExpression targetType, Conversion conversion, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundAssignmentOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private RefKind <RefKind>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.IAssignmentExpression.Target { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IAssignmentExpression.Value { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Left { get; }
    public BoundExpression Right { get; }
    public RefKind RefKind { get; }
    public BoundAssignmentOperator(CSharpSyntaxNode syntax, BoundExpression left, BoundExpression right, TypeSymbol type, RefKind refKind, bool hasErrors);
    public BoundAssignmentOperator(CSharpSyntaxNode syntax, BoundExpression left, BoundExpression right, RefKind refKind, TypeSymbol type, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IAssignmentExpression.get_Target();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IAssignmentExpression.get_Value();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Left();
    [CompilerGeneratedAttribute]
public BoundExpression get_Right();
    [CompilerGeneratedAttribute]
public RefKind get_RefKind();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundAssignmentOperator Update(BoundExpression left, BoundExpression right, RefKind refKind, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundAttribute : BoundExpression {
    [CompilerGeneratedAttribute]
private MethodSymbol <Constructor>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <ConstructorArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ConstructorArgumentNamesOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <NamedArguments>k__BackingField;
    private LookupResultKind _ResultKind;
    public Symbol ExpressionSymbol { get; }
    protected OperationKind ExpressionKind { get; }
    public MethodSymbol Constructor { get; }
    public ImmutableArray`1<BoundExpression> ConstructorArguments { get; }
    public ImmutableArray`1<string> ConstructorArgumentNamesOpt { get; }
    public ImmutableArray`1<BoundExpression> NamedArguments { get; }
    public LookupResultKind ResultKind { get; }
    public BoundAttribute(CSharpSyntaxNode syntax, MethodSymbol constructor, ImmutableArray`1<BoundExpression> constructorArguments, ImmutableArray`1<string> constructorArgumentNamesOpt, ImmutableArray`1<BoundExpression> namedArguments, LookupResultKind resultKind, TypeSymbol type, bool hasErrors);
    public virtual Symbol get_ExpressionSymbol();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public MethodSymbol get_Constructor();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_ConstructorArguments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ConstructorArgumentNamesOpt();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_NamedArguments();
    public virtual LookupResultKind get_ResultKind();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundAttribute Update(MethodSymbol constructor, ImmutableArray`1<BoundExpression> constructorArguments, ImmutableArray`1<string> constructorArgumentNamesOpt, ImmutableArray`1<BoundExpression> namedArguments, LookupResultKind resultKind, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundAwaitExpression : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSymbol <GetAwaiter>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertySymbol <IsCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSymbol <GetResult>k__BackingField;
    internal bool IsDynamic { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IAwaitExpression.AwaitedValue { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Expression { get; }
    public MethodSymbol GetAwaiter { get; }
    public PropertySymbol IsCompleted { get; }
    public MethodSymbol GetResult { get; }
    public BoundAwaitExpression(CSharpSyntaxNode syntax, BoundExpression expression, MethodSymbol getAwaiter, PropertySymbol isCompleted, MethodSymbol getResult, TypeSymbol type, bool hasErrors);
    internal bool get_IsDynamic();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IAwaitExpression.get_AwaitedValue();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Expression();
    [CompilerGeneratedAttribute]
public MethodSymbol get_GetAwaiter();
    [CompilerGeneratedAttribute]
public PropertySymbol get_IsCompleted();
    [CompilerGeneratedAttribute]
public MethodSymbol get_GetResult();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundAwaitExpression Update(BoundExpression expression, MethodSymbol getAwaiter, PropertySymbol isCompleted, MethodSymbol getResult, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundBadExpression : BoundExpression {
    private LookupResultKind _ResultKind;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Symbol> <Symbols>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundNode> <ChildBoundNodes>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public LookupResultKind ResultKind { get; }
    public ImmutableArray`1<Symbol> Symbols { get; }
    public ImmutableArray`1<BoundNode> ChildBoundNodes { get; }
    public BoundBadExpression(CSharpSyntaxNode syntax, LookupResultKind resultKind, ImmutableArray`1<Symbol> symbols, ImmutableArray`1<BoundNode> childBoundNodes, TypeSymbol type);
    public BoundBadExpression(CSharpSyntaxNode syntax, LookupResultKind resultKind, ImmutableArray`1<Symbol> symbols, ImmutableArray`1<BoundNode> childBoundNodes, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual LookupResultKind get_ResultKind();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<Symbol> get_Symbols();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundNode> get_ChildBoundNodes();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundBadExpression Update(LookupResultKind resultKind, ImmutableArray`1<Symbol> symbols, ImmutableArray`1<BoundNode> childBoundNodes, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundBadStatement : BoundStatement {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundNode> <ChildBoundNodes>k__BackingField;
    protected OperationKind StatementKind { get; }
    public ImmutableArray`1<BoundNode> ChildBoundNodes { get; }
    public BoundBadStatement(CSharpSyntaxNode syntax, ImmutableArray`1<BoundNode> childBoundNodes, bool hasErrors);
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundNode> get_ChildBoundNodes();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundBadStatement Update(ImmutableArray`1<BoundNode> childBoundNodes);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundBaseReference : BoundExpression {
    public bool SuppressVirtualCalls { get; }
    private InstanceReferenceKind Microsoft.CodeAnalysis.Semantics.IInstanceReferenceExpression.InstanceReferenceKind { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundBaseReference(CSharpSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    public BoundBaseReference(CSharpSyntaxNode syntax, TypeSymbol type);
    public virtual bool get_SuppressVirtualCalls();
    private sealed virtual override InstanceReferenceKind Microsoft.CodeAnalysis.Semantics.IInstanceReferenceExpression.get_InstanceReferenceKind();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundBaseReference Update(TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundBinaryOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<MethodSymbol> <OriginalUserDefinedOperatorsOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private BinaryOperatorKind <OperatorKind>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstantValue <ConstantValueOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSymbol <MethodOpt>k__BackingField;
    private LookupResultKind _ResultKind;
    public ConstantValue ConstantValue { get; }
    public Symbol ExpressionSymbol { get; }
    public ImmutableArray`1<MethodSymbol> OriginalUserDefinedOperatorsOpt { get; }
    private BinaryOperationKind Microsoft.CodeAnalysis.Semantics.IBinaryOperatorExpression.BinaryOperationKind { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IBinaryOperatorExpression.LeftOperand { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IBinaryOperatorExpression.RightOperand { get; }
    private bool Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.UsesOperatorMethod { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.OperatorMethod { get; }
    protected OperationKind ExpressionKind { get; }
    public BinaryOperatorKind OperatorKind { get; }
    public BoundExpression Left { get; }
    public BoundExpression Right { get; }
    public ConstantValue ConstantValueOpt { get; }
    public MethodSymbol MethodOpt { get; }
    public LookupResultKind ResultKind { get; }
    public BoundBinaryOperator(CSharpSyntaxNode syntax, BinaryOperatorKind operatorKind, BoundExpression left, BoundExpression right, ConstantValue constantValueOpt, MethodSymbol methodOpt, LookupResultKind resultKind, ImmutableArray`1<MethodSymbol> originalUserDefinedOperatorsOpt, TypeSymbol type, bool hasErrors);
    public BoundBinaryOperator(CSharpSyntaxNode syntax, BinaryOperatorKind operatorKind, BoundExpression left, BoundExpression right, ConstantValue constantValueOpt, MethodSymbol methodOpt, LookupResultKind resultKind, TypeSymbol type, bool hasErrors);
    public virtual ConstantValue get_ConstantValue();
    public virtual Symbol get_ExpressionSymbol();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<MethodSymbol> get_OriginalUserDefinedOperatorsOpt();
    private sealed virtual override BinaryOperationKind Microsoft.CodeAnalysis.Semantics.IBinaryOperatorExpression.get_BinaryOperationKind();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IBinaryOperatorExpression.get_LeftOperand();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IBinaryOperatorExpression.get_RightOperand();
    private sealed virtual override bool Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.get_UsesOperatorMethod();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.get_OperatorMethod();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BinaryOperatorKind get_OperatorKind();
    [CompilerGeneratedAttribute]
public BoundExpression get_Left();
    [CompilerGeneratedAttribute]
public BoundExpression get_Right();
    [CompilerGeneratedAttribute]
public ConstantValue get_ConstantValueOpt();
    [CompilerGeneratedAttribute]
public MethodSymbol get_MethodOpt();
    public virtual LookupResultKind get_ResultKind();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundBinaryOperator Update(BinaryOperatorKind operatorKind, BoundExpression left, BoundExpression right, ConstantValue constantValueOpt, MethodSymbol methodOpt, LookupResultKind resultKind, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundBlock : BoundStatementList {
    private static ConditionalWeakTable`2<BoundBlock, object> s_blockStatementsMappings;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<LocalSymbol> <Locals>k__BackingField;
    private ImmutableArray`1<IOperation> Microsoft.CodeAnalysis.Semantics.IBlockStatement.Statements { get; }
    private ImmutableArray`1<ILocalSymbol> Microsoft.CodeAnalysis.Semantics.IBlockStatement.Locals { get; }
    protected OperationKind StatementKind { get; }
    public ImmutableArray`1<LocalSymbol> Locals { get; }
    public BoundBlock(CSharpSyntaxNode syntax, ImmutableArray`1<LocalSymbol> locals, ImmutableArray`1<BoundStatement> statements, bool hasErrors);
    private static BoundBlock();
    public static BoundBlock SynthesizedNoLocals(CSharpSyntaxNode syntax, BoundStatement statement);
    public static BoundBlock SynthesizedNoLocals(CSharpSyntaxNode syntax, ImmutableArray`1<BoundStatement> statements);
    public static BoundBlock SynthesizedNoLocals(CSharpSyntaxNode syntax, BoundStatement[] statements);
    private sealed virtual override ImmutableArray`1<IOperation> Microsoft.CodeAnalysis.Semantics.IBlockStatement.get_Statements();
    private sealed virtual override ImmutableArray`1<ILocalSymbol> Microsoft.CodeAnalysis.Semantics.IBlockStatement.get_Locals();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<LocalSymbol> get_Locals();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundBlock Update(ImmutableArray`1<LocalSymbol> locals, ImmutableArray`1<BoundStatement> statements);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundBreakStatement : BoundStatement {
    [CompilerGeneratedAttribute]
private GeneratedLabelSymbol <Label>k__BackingField;
    private ILabelSymbol Microsoft.CodeAnalysis.Semantics.IBranchStatement.Target { get; }
    private BranchKind Microsoft.CodeAnalysis.Semantics.IBranchStatement.BranchKind { get; }
    protected OperationKind StatementKind { get; }
    public GeneratedLabelSymbol Label { get; }
    public BoundBreakStatement(CSharpSyntaxNode syntax, GeneratedLabelSymbol label, bool hasErrors);
    public BoundBreakStatement(CSharpSyntaxNode syntax, GeneratedLabelSymbol label);
    private sealed virtual override ILabelSymbol Microsoft.CodeAnalysis.Semantics.IBranchStatement.get_Target();
    private sealed virtual override BranchKind Microsoft.CodeAnalysis.Semantics.IBranchStatement.get_BranchKind();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public GeneratedLabelSymbol get_Label();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundBreakStatement Update(GeneratedLabelSymbol label);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundCall : BoundExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<MethodSymbol> <OriginalMethodsOpt>k__BackingField;
    private static ConditionalWeakTable`2<BoundExpression, IArgument> s_argumentMappings;
    [CompilerGeneratedAttribute]
private BoundExpression <ReceiverOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSymbol <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ArgumentNamesOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<RefKind> <ArgumentRefKindsOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDelegateCall>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Expanded>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InvokedAsExtensionMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<int> <ArgsToParamsOpt>k__BackingField;
    private LookupResultKind _ResultKind;
    public Symbol ExpressionSymbol { get; }
    public ImmutableArray`1<MethodSymbol> OriginalMethodsOpt { get; private set; }
    private IMethodSymbol Microsoft.CodeAnalysis.Semantics.IInvocationExpression.TargetMethod { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IInvocationExpression.Instance { get; }
    private bool Microsoft.CodeAnalysis.Semantics.IInvocationExpression.IsVirtual { get; }
    private ImmutableArray`1<IArgument> Microsoft.CodeAnalysis.Semantics.IInvocationExpression.ArgumentsInSourceOrder { get; }
    private ImmutableArray`1<IArgument> Microsoft.CodeAnalysis.Semantics.IHasArgumentsExpression.ArgumentsInParameterOrder { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundExpression ReceiverOpt { get; }
    public MethodSymbol Method { get; }
    public ImmutableArray`1<BoundExpression> Arguments { get; }
    public ImmutableArray`1<string> ArgumentNamesOpt { get; }
    public ImmutableArray`1<RefKind> ArgumentRefKindsOpt { get; }
    public bool IsDelegateCall { get; }
    public bool Expanded { get; }
    public bool InvokedAsExtensionMethod { get; }
    public ImmutableArray`1<int> ArgsToParamsOpt { get; }
    public LookupResultKind ResultKind { get; }
    public BoundCall(CSharpSyntaxNode syntax, BoundExpression receiverOpt, MethodSymbol method, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNamesOpt, ImmutableArray`1<RefKind> argumentRefKindsOpt, bool isDelegateCall, bool expanded, bool invokedAsExtensionMethod, ImmutableArray`1<int> argsToParamsOpt, LookupResultKind resultKind, TypeSymbol type, bool hasErrors);
    private static BoundCall();
    public virtual Symbol get_ExpressionSymbol();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<MethodSymbol> get_OriginalMethodsOpt();
    [CompilerGeneratedAttribute]
private void set_OriginalMethodsOpt(ImmutableArray`1<MethodSymbol> value);
    public static BoundCall ErrorCall(CSharpSyntaxNode node, BoundExpression receiverOpt, MethodSymbol method, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> namedArguments, ImmutableArray`1<RefKind> refKinds, bool isDelegateCall, bool invokedAsExtensionMethod, ImmutableArray`1<MethodSymbol> originalMethods, LookupResultKind resultKind);
    public BoundCall Update(BoundExpression receiverOpt, MethodSymbol method, ImmutableArray`1<BoundExpression> arguments);
    public static BoundCall Synthesized(CSharpSyntaxNode syntax, BoundExpression receiverOpt, MethodSymbol method);
    public static BoundCall Synthesized(CSharpSyntaxNode syntax, BoundExpression receiverOpt, MethodSymbol method, BoundExpression arg0);
    public static BoundCall Synthesized(CSharpSyntaxNode syntax, BoundExpression receiverOpt, MethodSymbol method, BoundExpression arg0, BoundExpression arg1);
    public static BoundCall Synthesized(CSharpSyntaxNode syntax, BoundExpression receiverOpt, MethodSymbol method, ImmutableArray`1<BoundExpression> arguments);
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.Semantics.IInvocationExpression.get_TargetMethod();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IInvocationExpression.get_Instance();
    private sealed virtual override bool Microsoft.CodeAnalysis.Semantics.IInvocationExpression.get_IsVirtual();
    private sealed virtual override ImmutableArray`1<IArgument> Microsoft.CodeAnalysis.Semantics.IInvocationExpression.get_ArgumentsInSourceOrder();
    private sealed virtual override ImmutableArray`1<IArgument> Microsoft.CodeAnalysis.Semantics.IHasArgumentsExpression.get_ArgumentsInParameterOrder();
    private sealed virtual override IArgument Microsoft.CodeAnalysis.Semantics.IHasArgumentsExpression.GetArgumentMatchingParameter(IParameterSymbol parameter);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    internal static ImmutableArray`1<IArgument> DeriveArguments(ImmutableArray`1<BoundExpression> boundArguments, ImmutableArray`1<string> argumentNames, ImmutableArray`1<int> argumentsToParameters, ImmutableArray`1<RefKind> argumentRefKinds, ImmutableArray`1<ParameterSymbol> parameters, SyntaxNode invocationSyntax);
    private static IArgument DeriveArgument(int parameterIndex, int argumentIndex, ImmutableArray`1<BoundExpression> boundArguments, ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> argumentRefKinds, ImmutableArray`1<ParameterSymbol> parameters, SyntaxNode invocationSyntax);
    private static IOperation CreateParamArray(IParameterSymbol parameter, ImmutableArray`1<BoundExpression> boundArguments, int firstArgumentElementIndex, SyntaxNode invocationSyntax);
    internal static IArgument ArgumentMatchingParameter(ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<int> argumentsToParameters, ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> argumentRefKinds, ISymbol targetMethod, ImmutableArray`1<ParameterSymbol> parameters, IParameterSymbol parameter, SyntaxNode invocationSyntax);
    private static int ArgumentIndexMatchingParameter(ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<int> argumentsToParameters, ISymbol targetMethod, IParameterSymbol parameter);
    [CompilerGeneratedAttribute]
public BoundExpression get_ReceiverOpt();
    [CompilerGeneratedAttribute]
public MethodSymbol get_Method();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_Arguments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ArgumentNamesOpt();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<RefKind> get_ArgumentRefKindsOpt();
    [CompilerGeneratedAttribute]
public bool get_IsDelegateCall();
    [CompilerGeneratedAttribute]
public bool get_Expanded();
    [CompilerGeneratedAttribute]
public bool get_InvokedAsExtensionMethod();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<int> get_ArgsToParamsOpt();
    public virtual LookupResultKind get_ResultKind();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundCall Update(BoundExpression receiverOpt, MethodSymbol method, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNamesOpt, ImmutableArray`1<RefKind> argumentRefKindsOpt, bool isDelegateCall, bool expanded, bool invokedAsExtensionMethod, ImmutableArray`1<int> argsToParamsOpt, LookupResultKind resultKind, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundCatchBlock : BoundNode {
    [CompilerGeneratedAttribute]
private LocalSymbol <LocalOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <ExceptionSourceOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeSymbol <ExceptionTypeOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <ExceptionFilterOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundBlock <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSynthesizedAsyncCatchAll>k__BackingField;
    private IBlockStatement Microsoft.CodeAnalysis.Semantics.ICatchClause.Handler { get; }
    private ITypeSymbol Microsoft.CodeAnalysis.Semantics.ICatchClause.CaughtType { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.ICatchClause.Filter { get; }
    private ILocalSymbol Microsoft.CodeAnalysis.Semantics.ICatchClause.ExceptionLocal { get; }
    private OperationKind Microsoft.CodeAnalysis.IOperation.Kind { get; }
    private bool Microsoft.CodeAnalysis.IOperation.IsInvalid { get; }
    private SyntaxNode Microsoft.CodeAnalysis.IOperation.Syntax { get; }
    private ITypeSymbol Microsoft.CodeAnalysis.IOperation.Type { get; }
    private Optional`1<object> Microsoft.CodeAnalysis.IOperation.ConstantValue { get; }
    public LocalSymbol LocalOpt { get; }
    public BoundExpression ExceptionSourceOpt { get; }
    public TypeSymbol ExceptionTypeOpt { get; }
    public BoundExpression ExceptionFilterOpt { get; }
    public BoundBlock Body { get; }
    public bool IsSynthesizedAsyncCatchAll { get; }
    public BoundCatchBlock(CSharpSyntaxNode syntax, LocalSymbol localOpt, BoundExpression exceptionSourceOpt, TypeSymbol exceptionTypeOpt, BoundExpression exceptionFilterOpt, BoundBlock body, bool isSynthesizedAsyncCatchAll, bool hasErrors);
    private sealed virtual override IBlockStatement Microsoft.CodeAnalysis.Semantics.ICatchClause.get_Handler();
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.Semantics.ICatchClause.get_CaughtType();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.ICatchClause.get_Filter();
    private sealed virtual override ILocalSymbol Microsoft.CodeAnalysis.Semantics.ICatchClause.get_ExceptionLocal();
    private sealed virtual override OperationKind Microsoft.CodeAnalysis.IOperation.get_Kind();
    private sealed virtual override bool Microsoft.CodeAnalysis.IOperation.get_IsInvalid();
    private sealed virtual override SyntaxNode Microsoft.CodeAnalysis.IOperation.get_Syntax();
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.IOperation.get_Type();
    private sealed virtual override Optional`1<object> Microsoft.CodeAnalysis.IOperation.get_ConstantValue();
    private sealed virtual override void Microsoft.CodeAnalysis.IOperation.Accept(OperationVisitor visitor);
    private sealed virtual override TResult Microsoft.CodeAnalysis.IOperation.Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public LocalSymbol get_LocalOpt();
    [CompilerGeneratedAttribute]
public BoundExpression get_ExceptionSourceOpt();
    [CompilerGeneratedAttribute]
public TypeSymbol get_ExceptionTypeOpt();
    [CompilerGeneratedAttribute]
public BoundExpression get_ExceptionFilterOpt();
    [CompilerGeneratedAttribute]
public BoundBlock get_Body();
    [CompilerGeneratedAttribute]
public bool get_IsSynthesizedAsyncCatchAll();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundCatchBlock Update(LocalSymbol localOpt, BoundExpression exceptionSourceOpt, TypeSymbol exceptionTypeOpt, BoundExpression exceptionFilterOpt, BoundBlock body, bool isSynthesizedAsyncCatchAll);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundCollectionElementInitializer : BoundExpression {
    [CompilerGeneratedAttribute]
private MethodSymbol <AddMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Expanded>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<int> <ArgsToParamsOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InvokedAsExtensionMethod>k__BackingField;
    private LookupResultKind _ResultKind;
    public Symbol ExpressionSymbol { get; }
    protected OperationKind ExpressionKind { get; }
    public MethodSymbol AddMethod { get; }
    public ImmutableArray`1<BoundExpression> Arguments { get; }
    public bool Expanded { get; }
    public ImmutableArray`1<int> ArgsToParamsOpt { get; }
    public bool InvokedAsExtensionMethod { get; }
    public LookupResultKind ResultKind { get; }
    public BoundCollectionElementInitializer(CSharpSyntaxNode syntax, MethodSymbol addMethod, ImmutableArray`1<BoundExpression> arguments, bool expanded, ImmutableArray`1<int> argsToParamsOpt, bool invokedAsExtensionMethod, LookupResultKind resultKind, TypeSymbol type, bool hasErrors);
    public virtual Symbol get_ExpressionSymbol();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public MethodSymbol get_AddMethod();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_Arguments();
    [CompilerGeneratedAttribute]
public bool get_Expanded();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<int> get_ArgsToParamsOpt();
    [CompilerGeneratedAttribute]
public bool get_InvokedAsExtensionMethod();
    public virtual LookupResultKind get_ResultKind();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundCollectionElementInitializer Update(MethodSymbol addMethod, ImmutableArray`1<BoundExpression> arguments, bool expanded, ImmutableArray`1<int> argsToParamsOpt, bool invokedAsExtensionMethod, LookupResultKind resultKind, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundCollectionInitializerExpression : BoundExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <Initializers>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public ImmutableArray`1<BoundExpression> Initializers { get; }
    public BoundCollectionInitializerExpression(CSharpSyntaxNode syntax, ImmutableArray`1<BoundExpression> initializers, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_Initializers();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundCollectionInitializerExpression Update(ImmutableArray`1<BoundExpression> initializers, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundComplexConditionalReceiver : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <ValueTypeReceiver>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <ReferenceTypeReceiver>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public BoundExpression ValueTypeReceiver { get; }
    public BoundExpression ReferenceTypeReceiver { get; }
    public BoundComplexConditionalReceiver(CSharpSyntaxNode syntax, BoundExpression valueTypeReceiver, BoundExpression referenceTypeReceiver, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_ValueTypeReceiver();
    [CompilerGeneratedAttribute]
public BoundExpression get_ReferenceTypeReceiver();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundComplexConditionalReceiver Update(BoundExpression valueTypeReceiver, BoundExpression referenceTypeReceiver, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundCompoundAssignmentOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<MethodSymbol> <OriginalUserDefinedOperatorsOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private BinaryOperatorSignature <Operator>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private Conversion <LeftConversion>k__BackingField;
    [CompilerGeneratedAttribute]
private Conversion <FinalConversion>k__BackingField;
    private LookupResultKind _ResultKind;
    public Symbol ExpressionSymbol { get; }
    public ImmutableArray`1<MethodSymbol> OriginalUserDefinedOperatorsOpt { get; }
    private BinaryOperationKind Microsoft.CodeAnalysis.Semantics.ICompoundAssignmentExpression.BinaryOperationKind { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IAssignmentExpression.Target { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IAssignmentExpression.Value { get; }
    private bool Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.UsesOperatorMethod { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.OperatorMethod { get; }
    protected OperationKind ExpressionKind { get; }
    public BinaryOperatorSignature Operator { get; }
    public BoundExpression Left { get; }
    public BoundExpression Right { get; }
    public Conversion LeftConversion { get; }
    public Conversion FinalConversion { get; }
    public LookupResultKind ResultKind { get; }
    public BoundCompoundAssignmentOperator(CSharpSyntaxNode syntax, BinaryOperatorSignature operator, BoundExpression left, BoundExpression right, Conversion leftConversion, Conversion finalConversion, LookupResultKind resultKind, ImmutableArray`1<MethodSymbol> originalUserDefinedOperatorsOpt, TypeSymbol type, bool hasErrors);
    public BoundCompoundAssignmentOperator(CSharpSyntaxNode syntax, BinaryOperatorSignature operator, BoundExpression left, BoundExpression right, Conversion leftConversion, Conversion finalConversion, LookupResultKind resultKind, TypeSymbol type, bool hasErrors);
    public virtual Symbol get_ExpressionSymbol();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<MethodSymbol> get_OriginalUserDefinedOperatorsOpt();
    private sealed virtual override BinaryOperationKind Microsoft.CodeAnalysis.Semantics.ICompoundAssignmentExpression.get_BinaryOperationKind();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IAssignmentExpression.get_Target();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IAssignmentExpression.get_Value();
    private sealed virtual override bool Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.get_UsesOperatorMethod();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.get_OperatorMethod();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BinaryOperatorSignature get_Operator();
    [CompilerGeneratedAttribute]
public BoundExpression get_Left();
    [CompilerGeneratedAttribute]
public BoundExpression get_Right();
    [CompilerGeneratedAttribute]
public Conversion get_LeftConversion();
    [CompilerGeneratedAttribute]
public Conversion get_FinalConversion();
    public virtual LookupResultKind get_ResultKind();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundCompoundAssignmentOperator Update(BinaryOperatorSignature operator, BoundExpression left, BoundExpression right, Conversion leftConversion, Conversion finalConversion, LookupResultKind resultKind, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundConditionalAccess : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Receiver>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <AccessExpression>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.IConditionalAccessExpression.ConditionalValue { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IConditionalAccessExpression.ConditionalInstance { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Receiver { get; }
    public BoundExpression AccessExpression { get; }
    public BoundConditionalAccess(CSharpSyntaxNode syntax, BoundExpression receiver, BoundExpression accessExpression, TypeSymbol type, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IConditionalAccessExpression.get_ConditionalValue();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IConditionalAccessExpression.get_ConditionalInstance();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Receiver();
    [CompilerGeneratedAttribute]
public BoundExpression get_AccessExpression();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundConditionalAccess Update(BoundExpression receiver, BoundExpression accessExpression, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundConditionalGoto : BoundStatement {
    [CompilerGeneratedAttribute]
private BoundExpression <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <JumpIfTrue>k__BackingField;
    [CompilerGeneratedAttribute]
private LabelSymbol <Label>k__BackingField;
    protected OperationKind StatementKind { get; }
    public BoundExpression Condition { get; }
    public bool JumpIfTrue { get; }
    public LabelSymbol Label { get; }
    public BoundConditionalGoto(CSharpSyntaxNode syntax, BoundExpression condition, bool jumpIfTrue, LabelSymbol label, bool hasErrors);
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Condition();
    [CompilerGeneratedAttribute]
public bool get_JumpIfTrue();
    [CompilerGeneratedAttribute]
public LabelSymbol get_Label();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundConditionalGoto Update(BoundExpression condition, bool jumpIfTrue, LabelSymbol label);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundConditionalOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Consequence>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Alternative>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstantValue <ConstantValueOpt>k__BackingField;
    public ConstantValue ConstantValue { get; }
    public bool IsDynamic { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IConditionalChoiceExpression.Condition { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IConditionalChoiceExpression.IfTrueValue { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IConditionalChoiceExpression.IfFalseValue { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Condition { get; }
    public BoundExpression Consequence { get; }
    public BoundExpression Alternative { get; }
    public ConstantValue ConstantValueOpt { get; }
    public BoundConditionalOperator(CSharpSyntaxNode syntax, BoundExpression condition, BoundExpression consequence, BoundExpression alternative, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors);
    public virtual ConstantValue get_ConstantValue();
    public bool get_IsDynamic();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IConditionalChoiceExpression.get_Condition();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IConditionalChoiceExpression.get_IfTrueValue();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IConditionalChoiceExpression.get_IfFalseValue();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Condition();
    [CompilerGeneratedAttribute]
public BoundExpression get_Consequence();
    [CompilerGeneratedAttribute]
public BoundExpression get_Alternative();
    [CompilerGeneratedAttribute]
public ConstantValue get_ConstantValueOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundConditionalOperator Update(BoundExpression condition, BoundExpression consequence, BoundExpression alternative, ConstantValue constantValueOpt, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundConditionalReceiver : BoundExpression {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public int Id { get; }
    public BoundConditionalReceiver(CSharpSyntaxNode syntax, int id, TypeSymbol type, bool hasErrors);
    public BoundConditionalReceiver(CSharpSyntaxNode syntax, int id, TypeSymbol type);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public int get_Id();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundConditionalReceiver Update(int id, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundContinueStatement : BoundStatement {
    [CompilerGeneratedAttribute]
private GeneratedLabelSymbol <Label>k__BackingField;
    private ILabelSymbol Microsoft.CodeAnalysis.Semantics.IBranchStatement.Target { get; }
    private BranchKind Microsoft.CodeAnalysis.Semantics.IBranchStatement.BranchKind { get; }
    protected OperationKind StatementKind { get; }
    public GeneratedLabelSymbol Label { get; }
    public BoundContinueStatement(CSharpSyntaxNode syntax, GeneratedLabelSymbol label, bool hasErrors);
    public BoundContinueStatement(CSharpSyntaxNode syntax, GeneratedLabelSymbol label);
    private sealed virtual override ILabelSymbol Microsoft.CodeAnalysis.Semantics.IBranchStatement.get_Target();
    private sealed virtual override BranchKind Microsoft.CodeAnalysis.Semantics.IBranchStatement.get_BranchKind();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public GeneratedLabelSymbol get_Label();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundContinueStatement Update(GeneratedLabelSymbol label);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundConversion : BoundExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<MethodSymbol> <OriginalUserDefinedConversionsOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Operand>k__BackingField;
    [CompilerGeneratedAttribute]
private ConversionKind <ConversionKind>k__BackingField;
    private LookupResultKind _ResultKind;
    [CompilerGeneratedAttribute]
private bool <IsBaseConversion>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSymbol <SymbolOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Checked>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExplicitCastInCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExtensionMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsArrayIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstantValue <ConstantValueOpt>k__BackingField;
    public ConstantValue ConstantValue { get; }
    public Symbol ExpressionSymbol { get; }
    public ImmutableArray`1<MethodSymbol> OriginalUserDefinedConversionsOpt { get; }
    public bool SuppressVirtualCalls { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IConversionExpression.Operand { get; }
    private ConversionKind Microsoft.CodeAnalysis.Semantics.IConversionExpression.ConversionKind { get; }
    private bool Microsoft.CodeAnalysis.Semantics.IConversionExpression.IsExplicit { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.OperatorMethod { get; }
    private bool Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.UsesOperatorMethod { get; }
    protected OperationKind ExpressionKind { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.Semantics.IMethodBindingExpression.Method { get; }
    private bool Microsoft.CodeAnalysis.Semantics.IMethodBindingExpression.IsVirtual { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.Instance { get; }
    private ISymbol Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.Member { get; }
    public BoundExpression Operand { get; }
    public ConversionKind ConversionKind { get; }
    public LookupResultKind ResultKind { get; }
    public bool IsBaseConversion { get; }
    public MethodSymbol SymbolOpt { get; }
    public bool Checked { get; }
    public bool ExplicitCastInCode { get; }
    public bool IsExtensionMethod { get; }
    public bool IsArrayIndex { get; }
    public ConstantValue ConstantValueOpt { get; }
    public BoundConversion(CSharpSyntaxNode syntax, BoundExpression operand, Conversion conversion, bool checked, bool explicitCastInCode, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors);
    public BoundConversion(CSharpSyntaxNode syntax, BoundExpression operand, ConversionKind conversionKind, LookupResultKind resultKind, bool isBaseConversion, MethodSymbol symbolOpt, bool checked, bool explicitCastInCode, bool isExtensionMethod, bool isArrayIndex, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors);
    public virtual ConstantValue get_ConstantValue();
    public virtual Symbol get_ExpressionSymbol();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<MethodSymbol> get_OriginalUserDefinedConversionsOpt();
    public virtual bool get_SuppressVirtualCalls();
    internal bool ConversionHasSideEffects();
    public static BoundConversion SynthesizedNonUserDefined(CSharpSyntaxNode syntax, BoundExpression operand, ConversionKind kind, TypeSymbol type, ConstantValue constantValueOpt);
    public static BoundConversion Synthesized(CSharpSyntaxNode syntax, BoundExpression operand, Conversion conversion, bool checked, bool explicitCastInCode, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IConversionExpression.get_Operand();
    private sealed virtual override ConversionKind Microsoft.CodeAnalysis.Semantics.IConversionExpression.get_ConversionKind();
    private sealed virtual override bool Microsoft.CodeAnalysis.Semantics.IConversionExpression.get_IsExplicit();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.get_OperatorMethod();
    private sealed virtual override bool Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.get_UsesOperatorMethod();
    protected virtual OperationKind get_ExpressionKind();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.Semantics.IMethodBindingExpression.get_Method();
    private sealed virtual override bool Microsoft.CodeAnalysis.Semantics.IMethodBindingExpression.get_IsVirtual();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.get_Instance();
    private sealed virtual override ISymbol Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.get_Member();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Operand();
    [CompilerGeneratedAttribute]
public ConversionKind get_ConversionKind();
    public virtual LookupResultKind get_ResultKind();
    [CompilerGeneratedAttribute]
public bool get_IsBaseConversion();
    [CompilerGeneratedAttribute]
public MethodSymbol get_SymbolOpt();
    [CompilerGeneratedAttribute]
public bool get_Checked();
    [CompilerGeneratedAttribute]
public bool get_ExplicitCastInCode();
    [CompilerGeneratedAttribute]
public bool get_IsExtensionMethod();
    [CompilerGeneratedAttribute]
public bool get_IsArrayIndex();
    [CompilerGeneratedAttribute]
public ConstantValue get_ConstantValueOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundConversion Update(BoundExpression operand, ConversionKind conversionKind, LookupResultKind resultKind, bool isBaseConversion, MethodSymbol symbolOpt, bool checked, bool explicitCastInCode, bool isExtensionMethod, bool isArrayIndex, ConstantValue constantValueOpt, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundDefaultOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private ConstantValue <ConstantValueOpt>k__BackingField;
    public ConstantValue ConstantValue { get; }
    protected OperationKind ExpressionKind { get; }
    public ConstantValue ConstantValueOpt { get; }
    public BoundDefaultOperator(CSharpSyntaxNode syntax, TypeSymbol type);
    public BoundDefaultOperator(CSharpSyntaxNode syntax, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors);
    public BoundDefaultOperator(CSharpSyntaxNode syntax, ConstantValue constantValueOpt, TypeSymbol type);
    public virtual ConstantValue get_ConstantValue();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ConstantValue get_ConstantValueOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundDefaultOperator Update(ConstantValue constantValueOpt, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundDelegateCreationExpression : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSymbol <MethodOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExtensionMethod>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.Instance { get; }
    private bool Microsoft.CodeAnalysis.Semantics.IMethodBindingExpression.IsVirtual { get; }
    private ISymbol Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.Member { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.Semantics.IMethodBindingExpression.Method { get; }
    protected OperationKind ExpressionKind { get; }
    private SyntaxNode Microsoft.CodeAnalysis.IOperation.Syntax { get; }
    public BoundExpression Argument { get; }
    public MethodSymbol MethodOpt { get; }
    public bool IsExtensionMethod { get; }
    public BoundDelegateCreationExpression(CSharpSyntaxNode syntax, BoundExpression argument, MethodSymbol methodOpt, bool isExtensionMethod, TypeSymbol type, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.get_Instance();
    private sealed virtual override bool Microsoft.CodeAnalysis.Semantics.IMethodBindingExpression.get_IsVirtual();
    private sealed virtual override ISymbol Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.get_Member();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.Semantics.IMethodBindingExpression.get_Method();
    protected virtual OperationKind get_ExpressionKind();
    private sealed virtual override SyntaxNode Microsoft.CodeAnalysis.IOperation.get_Syntax();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Argument();
    [CompilerGeneratedAttribute]
public MethodSymbol get_MethodOpt();
    [CompilerGeneratedAttribute]
public bool get_IsExtensionMethod();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundDelegateCreationExpression Update(BoundExpression argument, MethodSymbol methodOpt, bool isExtensionMethod, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundDoStatement : BoundLoopStatement {
    [CompilerGeneratedAttribute]
private BoundExpression <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundStatement <Body>k__BackingField;
    private bool Microsoft.CodeAnalysis.Semantics.IWhileUntilLoopStatement.IsTopTest { get; }
    private bool Microsoft.CodeAnalysis.Semantics.IWhileUntilLoopStatement.IsWhile { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IForWhileUntilLoopStatement.Condition { get; }
    private LoopKind Microsoft.CodeAnalysis.Semantics.ILoopStatement.LoopKind { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.ILoopStatement.Body { get; }
    protected OperationKind StatementKind { get; }
    public BoundExpression Condition { get; }
    public BoundStatement Body { get; }
    public BoundDoStatement(CSharpSyntaxNode syntax, BoundExpression condition, BoundStatement body, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel, bool hasErrors);
    private sealed virtual override bool Microsoft.CodeAnalysis.Semantics.IWhileUntilLoopStatement.get_IsTopTest();
    private sealed virtual override bool Microsoft.CodeAnalysis.Semantics.IWhileUntilLoopStatement.get_IsWhile();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IForWhileUntilLoopStatement.get_Condition();
    private sealed virtual override LoopKind Microsoft.CodeAnalysis.Semantics.ILoopStatement.get_LoopKind();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.ILoopStatement.get_Body();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Condition();
    [CompilerGeneratedAttribute]
public BoundStatement get_Body();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundDoStatement Update(BoundExpression condition, BoundStatement body, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundDup : BoundExpression {
    [CompilerGeneratedAttribute]
private RefKind <RefKind>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public RefKind RefKind { get; }
    public BoundDup(CSharpSyntaxNode syntax, RefKind refKind, TypeSymbol type, bool hasErrors);
    public BoundDup(CSharpSyntaxNode syntax, RefKind refKind, TypeSymbol type);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public RefKind get_RefKind();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundDup Update(RefKind refKind, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundDynamicCollectionElementInitializer : BoundExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<MethodSymbol> <ApplicableMethods>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public ImmutableArray`1<BoundExpression> Arguments { get; }
    public ImmutableArray`1<MethodSymbol> ApplicableMethods { get; }
    public BoundDynamicCollectionElementInitializer(CSharpSyntaxNode syntax, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<MethodSymbol> applicableMethods, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_Arguments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<MethodSymbol> get_ApplicableMethods();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundDynamicCollectionElementInitializer Update(ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<MethodSymbol> applicableMethods, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundDynamicIndexerAccess : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <ReceiverOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ArgumentNamesOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<RefKind> <ArgumentRefKindsOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<PropertySymbol> <ApplicableIndexers>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public BoundExpression ReceiverOpt { get; }
    public ImmutableArray`1<BoundExpression> Arguments { get; }
    public ImmutableArray`1<string> ArgumentNamesOpt { get; }
    public ImmutableArray`1<RefKind> ArgumentRefKindsOpt { get; }
    public ImmutableArray`1<PropertySymbol> ApplicableIndexers { get; }
    public BoundDynamicIndexerAccess(CSharpSyntaxNode syntax, BoundExpression receiverOpt, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNamesOpt, ImmutableArray`1<RefKind> argumentRefKindsOpt, ImmutableArray`1<PropertySymbol> applicableIndexers, TypeSymbol type, bool hasErrors);
    internal string TryGetIndexedPropertyName();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_ReceiverOpt();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_Arguments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ArgumentNamesOpt();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<RefKind> get_ArgumentRefKindsOpt();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<PropertySymbol> get_ApplicableIndexers();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundDynamicIndexerAccess Update(BoundExpression receiverOpt, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNamesOpt, ImmutableArray`1<RefKind> argumentRefKindsOpt, ImmutableArray`1<PropertySymbol> applicableIndexers, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundDynamicInvocation : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ArgumentNamesOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<RefKind> <ArgumentRefKindsOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<MethodSymbol> <ApplicableMethods>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Expression { get; }
    public ImmutableArray`1<BoundExpression> Arguments { get; }
    public ImmutableArray`1<string> ArgumentNamesOpt { get; }
    public ImmutableArray`1<RefKind> ArgumentRefKindsOpt { get; }
    public ImmutableArray`1<MethodSymbol> ApplicableMethods { get; }
    public BoundDynamicInvocation(CSharpSyntaxNode syntax, BoundExpression expression, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNamesOpt, ImmutableArray`1<RefKind> argumentRefKindsOpt, ImmutableArray`1<MethodSymbol> applicableMethods, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Expression();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_Arguments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ArgumentNamesOpt();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<RefKind> get_ArgumentRefKindsOpt();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<MethodSymbol> get_ApplicableMethods();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundDynamicInvocation Update(BoundExpression expression, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNamesOpt, ImmutableArray`1<RefKind> argumentRefKindsOpt, ImmutableArray`1<MethodSymbol> applicableMethods, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundDynamicMemberAccess : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Receiver>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TypeSymbol> <TypeArgumentsOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Invoked>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Indexed>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Receiver { get; }
    public ImmutableArray`1<TypeSymbol> TypeArgumentsOpt { get; }
    public string Name { get; }
    public bool Invoked { get; }
    public bool Indexed { get; }
    public BoundDynamicMemberAccess(CSharpSyntaxNode syntax, BoundExpression receiver, ImmutableArray`1<TypeSymbol> typeArgumentsOpt, string name, bool invoked, bool indexed, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Receiver();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TypeSymbol> get_TypeArgumentsOpt();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_Invoked();
    [CompilerGeneratedAttribute]
public bool get_Indexed();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundDynamicMemberAccess Update(BoundExpression receiver, ImmutableArray`1<TypeSymbol> typeArgumentsOpt, string name, bool invoked, bool indexed, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundDynamicObjectCreationExpression : BoundExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ArgumentNamesOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<RefKind> <ArgumentRefKindsOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <InitializerExpressionOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<MethodSymbol> <ApplicableMethods>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public ImmutableArray`1<BoundExpression> Arguments { get; }
    public ImmutableArray`1<string> ArgumentNamesOpt { get; }
    public ImmutableArray`1<RefKind> ArgumentRefKindsOpt { get; }
    public BoundExpression InitializerExpressionOpt { get; }
    public ImmutableArray`1<MethodSymbol> ApplicableMethods { get; }
    public BoundDynamicObjectCreationExpression(CSharpSyntaxNode syntax, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNamesOpt, ImmutableArray`1<RefKind> argumentRefKindsOpt, BoundExpression initializerExpressionOpt, ImmutableArray`1<MethodSymbol> applicableMethods, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_Arguments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ArgumentNamesOpt();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<RefKind> get_ArgumentRefKindsOpt();
    [CompilerGeneratedAttribute]
public BoundExpression get_InitializerExpressionOpt();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<MethodSymbol> get_ApplicableMethods();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundDynamicObjectCreationExpression Update(ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNamesOpt, ImmutableArray`1<RefKind> argumentRefKindsOpt, BoundExpression initializerExpressionOpt, ImmutableArray`1<MethodSymbol> applicableMethods, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundDynamicObjectInitializerMember : BoundExpression {
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public string MemberName { get; }
    public BoundDynamicObjectInitializerMember(CSharpSyntaxNode syntax, string memberName, TypeSymbol type, bool hasErrors);
    public BoundDynamicObjectInitializerMember(CSharpSyntaxNode syntax, string memberName, TypeSymbol type);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public string get_MemberName();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundDynamicObjectInitializerMember Update(string memberName, TypeSymbol type);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.BoundEqualsValue : BoundNode {
    [CompilerGeneratedAttribute]
private BoundExpression <Value>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.ISymbolInitializer.Value { get; }
    private SyntaxNode Microsoft.CodeAnalysis.IOperation.Syntax { get; }
    private bool Microsoft.CodeAnalysis.IOperation.IsInvalid { get; }
    private OperationKind Microsoft.CodeAnalysis.IOperation.Kind { get; }
    protected OperationKind OperationKind { get; }
    private ITypeSymbol Microsoft.CodeAnalysis.IOperation.Type { get; }
    private Optional`1<object> Microsoft.CodeAnalysis.IOperation.ConstantValue { get; }
    public BoundExpression Value { get; }
    protected BoundEqualsValue(BoundKind kind, CSharpSyntaxNode syntax, BoundExpression value, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.ISymbolInitializer.get_Value();
    private sealed virtual override SyntaxNode Microsoft.CodeAnalysis.IOperation.get_Syntax();
    private sealed virtual override bool Microsoft.CodeAnalysis.IOperation.get_IsInvalid();
    private sealed virtual override OperationKind Microsoft.CodeAnalysis.IOperation.get_Kind();
    protected abstract virtual OperationKind get_OperationKind();
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.IOperation.get_Type();
    private sealed virtual override Optional`1<object> Microsoft.CodeAnalysis.IOperation.get_ConstantValue();
    public abstract virtual void Accept(OperationVisitor visitor);
    public abstract virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Value();
}
internal class Microsoft.CodeAnalysis.CSharp.BoundEventAccess : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <ReceiverOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private EventSymbol <EventSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUsableAsField>k__BackingField;
    private LookupResultKind _ResultKind;
    public Symbol ExpressionSymbol { get; }
    private IEventSymbol Microsoft.CodeAnalysis.Semantics.IEventReferenceExpression.Event { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.Instance { get; }
    private ISymbol Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.Member { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundExpression ReceiverOpt { get; }
    public EventSymbol EventSymbol { get; }
    public bool IsUsableAsField { get; }
    public LookupResultKind ResultKind { get; }
    public BoundEventAccess(CSharpSyntaxNode syntax, BoundExpression receiverOpt, EventSymbol eventSymbol, bool isUsableAsField, LookupResultKind resultKind, TypeSymbol type, bool hasErrors);
    public virtual Symbol get_ExpressionSymbol();
    private sealed virtual override IEventSymbol Microsoft.CodeAnalysis.Semantics.IEventReferenceExpression.get_Event();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.get_Instance();
    private sealed virtual override ISymbol Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.get_Member();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_ReceiverOpt();
    [CompilerGeneratedAttribute]
public EventSymbol get_EventSymbol();
    [CompilerGeneratedAttribute]
public bool get_IsUsableAsField();
    public virtual LookupResultKind get_ResultKind();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundEventAccess Update(BoundExpression receiverOpt, EventSymbol eventSymbol, bool isUsableAsField, LookupResultKind resultKind, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundEventAssignmentOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private EventSymbol <Event>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAddition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDynamic>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <ReceiverOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Argument>k__BackingField;
    private IEventSymbol Microsoft.CodeAnalysis.Semantics.IEventAssignmentExpression.Event { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IEventAssignmentExpression.EventInstance { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IEventAssignmentExpression.HandlerValue { get; }
    private bool Microsoft.CodeAnalysis.Semantics.IEventAssignmentExpression.Adds { get; }
    protected OperationKind ExpressionKind { get; }
    public EventSymbol Event { get; }
    public bool IsAddition { get; }
    public bool IsDynamic { get; }
    public BoundExpression ReceiverOpt { get; }
    public BoundExpression Argument { get; }
    public BoundEventAssignmentOperator(CSharpSyntaxNode syntax, EventSymbol event, bool isAddition, bool isDynamic, BoundExpression receiverOpt, BoundExpression argument, TypeSymbol type, bool hasErrors);
    private sealed virtual override IEventSymbol Microsoft.CodeAnalysis.Semantics.IEventAssignmentExpression.get_Event();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IEventAssignmentExpression.get_EventInstance();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IEventAssignmentExpression.get_HandlerValue();
    private sealed virtual override bool Microsoft.CodeAnalysis.Semantics.IEventAssignmentExpression.get_Adds();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public EventSymbol get_Event();
    [CompilerGeneratedAttribute]
public bool get_IsAddition();
    [CompilerGeneratedAttribute]
public bool get_IsDynamic();
    [CompilerGeneratedAttribute]
public BoundExpression get_ReceiverOpt();
    [CompilerGeneratedAttribute]
public BoundExpression get_Argument();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundEventAssignmentOperator Update(EventSymbol event, bool isAddition, bool isDynamic, BoundExpression receiverOpt, BoundExpression argument, TypeSymbol type);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.BoundExpression : BoundNode {
    [CompilerGeneratedAttribute]
private TypeSymbol <Type>k__BackingField;
    public ConstantValue ConstantValue { get; }
    public Symbol ExpressionSymbol { get; }
    public LookupResultKind ResultKind { get; }
    public bool SuppressVirtualCalls { get; }
    private ITypeSymbol Microsoft.CodeAnalysis.IOperation.Type { get; }
    private OperationKind Microsoft.CodeAnalysis.IOperation.Kind { get; }
    private bool Microsoft.CodeAnalysis.IOperation.IsInvalid { get; }
    private Optional`1<object> Microsoft.CodeAnalysis.IOperation.ConstantValue { get; }
    private SyntaxNode Microsoft.CodeAnalysis.IOperation.Syntax { get; }
    protected OperationKind ExpressionKind { get; }
    public object Display { get; }
    public TypeSymbol Type { get; }
    protected BoundExpression(BoundKind kind, CSharpSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    protected BoundExpression(BoundKind kind, CSharpSyntaxNode syntax, TypeSymbol type);
    public virtual ConstantValue get_ConstantValue();
    public virtual Symbol get_ExpressionSymbol();
    public virtual LookupResultKind get_ResultKind();
    public virtual bool get_SuppressVirtualCalls();
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.IOperation.get_Type();
    private sealed virtual override OperationKind Microsoft.CodeAnalysis.IOperation.get_Kind();
    private sealed virtual override bool Microsoft.CodeAnalysis.IOperation.get_IsInvalid();
    private sealed virtual override Optional`1<object> Microsoft.CodeAnalysis.IOperation.get_ConstantValue();
    private sealed virtual override SyntaxNode Microsoft.CodeAnalysis.IOperation.get_Syntax();
    protected abstract virtual OperationKind get_ExpressionKind();
    public abstract virtual void Accept(OperationVisitor visitor);
    public abstract virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual object get_Display();
    [CompilerGeneratedAttribute]
public TypeSymbol get_Type();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.BoundExpressionExtensions : object {
    [ExtensionAttribute]
public static bool IsLiteralNull(BoundExpression node);
    [ExtensionAttribute]
public static bool IsDefaultValue(BoundExpression node);
    [ExtensionAttribute]
public static bool HasExpressionType(BoundExpression node);
    [ExtensionAttribute]
public static bool HasDynamicType(BoundExpression node);
    [ExtensionAttribute]
public static bool MethodGroupReceiverIsDynamic(BoundMethodGroup node);
    [ExtensionAttribute]
public static bool HasExpressionSymbols(BoundExpression node);
    [ExtensionAttribute]
public static void GetExpressionSymbols(BoundExpression node, ArrayBuilder`1<Symbol> symbols, BoundNode parent, Binder binder);
    [ExtensionAttribute]
public static Conversion GetConversion(BoundExpression boundNode);
    [ExtensionAttribute]
internal static bool IsExpressionOfComImportType(BoundExpression expressionOpt);
    [ExtensionAttribute]
public static bool NullableAlwaysHasValue(BoundExpression expr);
    [ExtensionAttribute]
public static bool NullableNeverHasValue(BoundExpression expr);
    [ExtensionAttribute]
public static bool IsNullableNonBoolean(BoundExpression expr);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundExpressionStatement : BoundStatement {
    [CompilerGeneratedAttribute]
private BoundExpression <Expression>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.IExpressionStatement.Expression { get; }
    protected OperationKind StatementKind { get; }
    public BoundExpression Expression { get; }
    public BoundExpressionStatement(CSharpSyntaxNode syntax, BoundExpression expression, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IExpressionStatement.get_Expression();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Expression();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundExpressionStatement Update(BoundExpression expression);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundFieldAccess : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <ReceiverOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldSymbol <FieldSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstantValue <ConstantValueOpt>k__BackingField;
    private LookupResultKind _ResultKind;
    [CompilerGeneratedAttribute]
private bool <IsByValue>k__BackingField;
    public ConstantValue ConstantValue { get; }
    public Symbol ExpressionSymbol { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.Instance { get; }
    private ISymbol Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.Member { get; }
    private IFieldSymbol Microsoft.CodeAnalysis.Semantics.IFieldReferenceExpression.Field { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundExpression ReceiverOpt { get; }
    public FieldSymbol FieldSymbol { get; }
    public ConstantValue ConstantValueOpt { get; }
    public LookupResultKind ResultKind { get; }
    public bool IsByValue { get; }
    public BoundFieldAccess(CSharpSyntaxNode syntax, BoundExpression receiver, FieldSymbol fieldSymbol, ConstantValue constantValueOpt, bool hasErrors);
    public BoundFieldAccess(CSharpSyntaxNode syntax, BoundExpression receiver, FieldSymbol fieldSymbol, ConstantValue constantValueOpt, LookupResultKind resultKind, TypeSymbol type, bool hasErrors);
    public BoundFieldAccess(CSharpSyntaxNode syntax, BoundExpression receiverOpt, FieldSymbol fieldSymbol, ConstantValue constantValueOpt, LookupResultKind resultKind, bool isByValue, TypeSymbol type, bool hasErrors);
    public virtual ConstantValue get_ConstantValue();
    public virtual Symbol get_ExpressionSymbol();
    public BoundFieldAccess Update(BoundExpression receiver, FieldSymbol fieldSymbol, ConstantValue constantValueOpt, LookupResultKind resultKind, TypeSymbol typeSymbol);
    private static bool NeedsByValueFieldAccess(BoundExpression receiver, FieldSymbol fieldSymbol);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.get_Instance();
    private sealed virtual override ISymbol Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.get_Member();
    private sealed virtual override IFieldSymbol Microsoft.CodeAnalysis.Semantics.IFieldReferenceExpression.get_Field();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_ReceiverOpt();
    [CompilerGeneratedAttribute]
public FieldSymbol get_FieldSymbol();
    [CompilerGeneratedAttribute]
public ConstantValue get_ConstantValueOpt();
    public virtual LookupResultKind get_ResultKind();
    [CompilerGeneratedAttribute]
public bool get_IsByValue();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundFieldAccess Update(BoundExpression receiverOpt, FieldSymbol fieldSymbol, ConstantValue constantValueOpt, LookupResultKind resultKind, bool isByValue, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundFieldEqualsValue : BoundEqualsValue {
    [CompilerGeneratedAttribute]
private FieldSymbol <Field>k__BackingField;
    private ImmutableArray`1<IFieldSymbol> Microsoft.CodeAnalysis.Semantics.IFieldInitializer.InitializedFields { get; }
    protected OperationKind OperationKind { get; }
    public FieldSymbol Field { get; }
    public BoundFieldEqualsValue(CSharpSyntaxNode syntax, FieldSymbol field, BoundExpression value, bool hasErrors);
    private sealed virtual override ImmutableArray`1<IFieldSymbol> Microsoft.CodeAnalysis.Semantics.IFieldInitializer.get_InitializedFields();
    protected virtual OperationKind get_OperationKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public FieldSymbol get_Field();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundFieldEqualsValue Update(FieldSymbol field, BoundExpression value);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundFieldInfo : BoundExpression {
    [CompilerGeneratedAttribute]
private FieldSymbol <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSymbol <GetFieldFromHandle>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public FieldSymbol Field { get; }
    public MethodSymbol GetFieldFromHandle { get; }
    public BoundFieldInfo(CSharpSyntaxNode syntax, FieldSymbol field, MethodSymbol getFieldFromHandle, TypeSymbol type, bool hasErrors);
    public BoundFieldInfo(CSharpSyntaxNode syntax, FieldSymbol field, MethodSymbol getFieldFromHandle, TypeSymbol type);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public FieldSymbol get_Field();
    [CompilerGeneratedAttribute]
public MethodSymbol get_GetFieldFromHandle();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundFieldInfo Update(FieldSymbol field, MethodSymbol getFieldFromHandle, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundFieldInitializer : BoundInitializer {
    [CompilerGeneratedAttribute]
private FieldSymbol <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <InitialValue>k__BackingField;
    public FieldSymbol Field { get; }
    public BoundExpression InitialValue { get; }
    public BoundFieldInitializer(CSharpSyntaxNode syntax, FieldSymbol field, BoundExpression initialValue, bool hasErrors);
    [CompilerGeneratedAttribute]
public FieldSymbol get_Field();
    [CompilerGeneratedAttribute]
public BoundExpression get_InitialValue();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundFieldInitializer Update(FieldSymbol field, BoundExpression initialValue);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundFixedLocalCollectionInitializer : BoundExpression {
    [CompilerGeneratedAttribute]
private TypeSymbol <ElementPointerType>k__BackingField;
    [CompilerGeneratedAttribute]
private Conversion <ElementPointerTypeConversion>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Expression>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public TypeSymbol ElementPointerType { get; }
    public Conversion ElementPointerTypeConversion { get; }
    public BoundExpression Expression { get; }
    public BoundFixedLocalCollectionInitializer(CSharpSyntaxNode syntax, TypeSymbol elementPointerType, Conversion elementPointerTypeConversion, BoundExpression expression, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public TypeSymbol get_ElementPointerType();
    [CompilerGeneratedAttribute]
public Conversion get_ElementPointerTypeConversion();
    [CompilerGeneratedAttribute]
public BoundExpression get_Expression();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundFixedLocalCollectionInitializer Update(TypeSymbol elementPointerType, Conversion elementPointerTypeConversion, BoundExpression expression, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundFixedStatement : BoundStatement {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<LocalSymbol> <Locals>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundMultipleLocalDeclarations <Declarations>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundStatement <Body>k__BackingField;
    private IVariableDeclarationStatement Microsoft.CodeAnalysis.Semantics.IFixedStatement.Variables { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IFixedStatement.Body { get; }
    protected OperationKind StatementKind { get; }
    public ImmutableArray`1<LocalSymbol> Locals { get; }
    public BoundMultipleLocalDeclarations Declarations { get; }
    public BoundStatement Body { get; }
    public BoundFixedStatement(CSharpSyntaxNode syntax, ImmutableArray`1<LocalSymbol> locals, BoundMultipleLocalDeclarations declarations, BoundStatement body, bool hasErrors);
    private sealed virtual override IVariableDeclarationStatement Microsoft.CodeAnalysis.Semantics.IFixedStatement.get_Variables();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IFixedStatement.get_Body();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<LocalSymbol> get_Locals();
    [CompilerGeneratedAttribute]
public BoundMultipleLocalDeclarations get_Declarations();
    [CompilerGeneratedAttribute]
public BoundStatement get_Body();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundFixedStatement Update(ImmutableArray`1<LocalSymbol> locals, BoundMultipleLocalDeclarations declarations, BoundStatement body);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundForEachStatement : BoundLoopStatement {
    [CompilerGeneratedAttribute]
private ForEachEnumeratorInfo <EnumeratorInfoOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private Conversion <ElementConversion>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundTypeExpression <IterationVariableType>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalSymbol <IterationVariable>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundStatement <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Checked>k__BackingField;
    private ILocalSymbol Microsoft.CodeAnalysis.Semantics.IForEachLoopStatement.IterationVariable { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IForEachLoopStatement.Collection { get; }
    private LoopKind Microsoft.CodeAnalysis.Semantics.ILoopStatement.LoopKind { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.ILoopStatement.Body { get; }
    protected OperationKind StatementKind { get; }
    public ForEachEnumeratorInfo EnumeratorInfoOpt { get; }
    public Conversion ElementConversion { get; }
    public BoundTypeExpression IterationVariableType { get; }
    public LocalSymbol IterationVariable { get; }
    public BoundExpression Expression { get; }
    public BoundStatement Body { get; }
    public bool Checked { get; }
    public BoundForEachStatement(CSharpSyntaxNode syntax, ForEachEnumeratorInfo enumeratorInfoOpt, Conversion elementConversion, BoundTypeExpression iterationVariableType, LocalSymbol iterationVariable, BoundExpression expression, BoundStatement body, bool checked, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel, bool hasErrors);
    private sealed virtual override ILocalSymbol Microsoft.CodeAnalysis.Semantics.IForEachLoopStatement.get_IterationVariable();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IForEachLoopStatement.get_Collection();
    private sealed virtual override LoopKind Microsoft.CodeAnalysis.Semantics.ILoopStatement.get_LoopKind();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.ILoopStatement.get_Body();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ForEachEnumeratorInfo get_EnumeratorInfoOpt();
    [CompilerGeneratedAttribute]
public Conversion get_ElementConversion();
    [CompilerGeneratedAttribute]
public BoundTypeExpression get_IterationVariableType();
    [CompilerGeneratedAttribute]
public LocalSymbol get_IterationVariable();
    [CompilerGeneratedAttribute]
public BoundExpression get_Expression();
    [CompilerGeneratedAttribute]
public BoundStatement get_Body();
    [CompilerGeneratedAttribute]
public bool get_Checked();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundForEachStatement Update(ForEachEnumeratorInfo enumeratorInfoOpt, Conversion elementConversion, BoundTypeExpression iterationVariableType, LocalSymbol iterationVariable, BoundExpression expression, BoundStatement body, bool checked, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundForStatement : BoundLoopStatement {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<LocalSymbol> <OuterLocals>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundStatement <Initializer>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundStatement <Increment>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundStatement <Body>k__BackingField;
    private ImmutableArray`1<IOperation> Microsoft.CodeAnalysis.Semantics.IForLoopStatement.Before { get; }
    private ImmutableArray`1<IOperation> Microsoft.CodeAnalysis.Semantics.IForLoopStatement.AtLoopBottom { get; }
    private ImmutableArray`1<ILocalSymbol> Microsoft.CodeAnalysis.Semantics.IForLoopStatement.Locals { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IForWhileUntilLoopStatement.Condition { get; }
    private LoopKind Microsoft.CodeAnalysis.Semantics.ILoopStatement.LoopKind { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.ILoopStatement.Body { get; }
    protected OperationKind StatementKind { get; }
    public ImmutableArray`1<LocalSymbol> OuterLocals { get; }
    public BoundStatement Initializer { get; }
    public BoundExpression Condition { get; }
    public BoundStatement Increment { get; }
    public BoundStatement Body { get; }
    public BoundForStatement(CSharpSyntaxNode syntax, ImmutableArray`1<LocalSymbol> outerLocals, BoundStatement initializer, BoundExpression condition, BoundStatement increment, BoundStatement body, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel, bool hasErrors);
    private sealed virtual override ImmutableArray`1<IOperation> Microsoft.CodeAnalysis.Semantics.IForLoopStatement.get_Before();
    private sealed virtual override ImmutableArray`1<IOperation> Microsoft.CodeAnalysis.Semantics.IForLoopStatement.get_AtLoopBottom();
    private sealed virtual override ImmutableArray`1<ILocalSymbol> Microsoft.CodeAnalysis.Semantics.IForLoopStatement.get_Locals();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IForWhileUntilLoopStatement.get_Condition();
    private sealed virtual override LoopKind Microsoft.CodeAnalysis.Semantics.ILoopStatement.get_LoopKind();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.ILoopStatement.get_Body();
    protected virtual OperationKind get_StatementKind();
    private ImmutableArray`1<IOperation> ToStatements(BoundStatement statement);
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<LocalSymbol> get_OuterLocals();
    [CompilerGeneratedAttribute]
public BoundStatement get_Initializer();
    [CompilerGeneratedAttribute]
public BoundExpression get_Condition();
    [CompilerGeneratedAttribute]
public BoundStatement get_Increment();
    [CompilerGeneratedAttribute]
public BoundStatement get_Body();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundForStatement Update(ImmutableArray`1<LocalSymbol> outerLocals, BoundStatement initializer, BoundExpression condition, BoundStatement increment, BoundStatement body, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundGlobalStatementInitializer : BoundInitializer {
    [CompilerGeneratedAttribute]
private BoundStatement <Statement>k__BackingField;
    public BoundStatement Statement { get; }
    public BoundGlobalStatementInitializer(CSharpSyntaxNode syntax, BoundStatement statement, bool hasErrors);
    [CompilerGeneratedAttribute]
public BoundStatement get_Statement();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundGlobalStatementInitializer Update(BoundStatement statement);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundGotoStatement : BoundStatement {
    [CompilerGeneratedAttribute]
private LabelSymbol <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <CaseExpressionOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundLabel <LabelExpressionOpt>k__BackingField;
    private ILabelSymbol Microsoft.CodeAnalysis.Semantics.IBranchStatement.Target { get; }
    private BranchKind Microsoft.CodeAnalysis.Semantics.IBranchStatement.BranchKind { get; }
    protected OperationKind StatementKind { get; }
    public LabelSymbol Label { get; }
    public BoundExpression CaseExpressionOpt { get; }
    public BoundLabel LabelExpressionOpt { get; }
    public BoundGotoStatement(CSharpSyntaxNode syntax, LabelSymbol label, bool hasErrors);
    public BoundGotoStatement(CSharpSyntaxNode syntax, LabelSymbol label, BoundExpression caseExpressionOpt, BoundLabel labelExpressionOpt, bool hasErrors);
    private sealed virtual override ILabelSymbol Microsoft.CodeAnalysis.Semantics.IBranchStatement.get_Target();
    private sealed virtual override BranchKind Microsoft.CodeAnalysis.Semantics.IBranchStatement.get_BranchKind();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public LabelSymbol get_Label();
    [CompilerGeneratedAttribute]
public BoundExpression get_CaseExpressionOpt();
    [CompilerGeneratedAttribute]
public BoundLabel get_LabelExpressionOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundGotoStatement Update(LabelSymbol label, BoundExpression caseExpressionOpt, BoundLabel labelExpressionOpt);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundHoistedFieldAccess : BoundExpression {
    [CompilerGeneratedAttribute]
private FieldSymbol <FieldSymbol>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public FieldSymbol FieldSymbol { get; }
    public BoundHoistedFieldAccess(CSharpSyntaxNode syntax, FieldSymbol fieldSymbol, TypeSymbol type, bool hasErrors);
    public BoundHoistedFieldAccess(CSharpSyntaxNode syntax, FieldSymbol fieldSymbol, TypeSymbol type);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public FieldSymbol get_FieldSymbol();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundHoistedFieldAccess Update(FieldSymbol fieldSymbol, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundHostObjectMemberReference : BoundExpression {
    protected OperationKind ExpressionKind { get; }
    public BoundHostObjectMemberReference(CSharpSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    public BoundHostObjectMemberReference(CSharpSyntaxNode syntax, TypeSymbol type);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundHostObjectMemberReference Update(TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundIfStatement : BoundStatement {
    [CompilerGeneratedAttribute]
private BoundExpression <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundStatement <Consequence>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundStatement <AlternativeOpt>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.IIfStatement.Condition { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IIfStatement.IfTrueStatement { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IIfStatement.IfFalseStatement { get; }
    protected OperationKind StatementKind { get; }
    public BoundExpression Condition { get; }
    public BoundStatement Consequence { get; }
    public BoundStatement AlternativeOpt { get; }
    public BoundIfStatement(CSharpSyntaxNode syntax, BoundExpression condition, BoundStatement consequence, BoundStatement alternativeOpt, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IIfStatement.get_Condition();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IIfStatement.get_IfTrueStatement();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IIfStatement.get_IfFalseStatement();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Condition();
    [CompilerGeneratedAttribute]
public BoundStatement get_Consequence();
    [CompilerGeneratedAttribute]
public BoundStatement get_AlternativeOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundIfStatement Update(BoundExpression condition, BoundStatement consequence, BoundStatement alternativeOpt);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundImplicitReceiver : BoundExpression {
    private InstanceReferenceKind Microsoft.CodeAnalysis.Semantics.IInstanceReferenceExpression.InstanceReferenceKind { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundImplicitReceiver(CSharpSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    public BoundImplicitReceiver(CSharpSyntaxNode syntax, TypeSymbol type);
    private sealed virtual override InstanceReferenceKind Microsoft.CodeAnalysis.Semantics.IInstanceReferenceExpression.get_InstanceReferenceKind();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundImplicitReceiver Update(TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundIncrementOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<MethodSymbol> <OriginalUserDefinedOperatorsOpt>k__BackingField;
    private static ConditionalWeakTable`2<BoundIncrementOperator, IOperation> s_incrementValueMappings;
    [CompilerGeneratedAttribute]
private UnaryOperatorKind <OperatorKind>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Operand>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSymbol <MethodOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private Conversion <OperandConversion>k__BackingField;
    [CompilerGeneratedAttribute]
private Conversion <ResultConversion>k__BackingField;
    private LookupResultKind _ResultKind;
    public Symbol ExpressionSymbol { get; }
    public ImmutableArray`1<MethodSymbol> OriginalUserDefinedOperatorsOpt { get; }
    private UnaryOperationKind Microsoft.CodeAnalysis.Semantics.IIncrementExpression.IncrementOperationKind { get; }
    private BinaryOperationKind Microsoft.CodeAnalysis.Semantics.ICompoundAssignmentExpression.BinaryOperationKind { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IAssignmentExpression.Target { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IAssignmentExpression.Value { get; }
    private bool Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.UsesOperatorMethod { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.OperatorMethod { get; }
    protected OperationKind ExpressionKind { get; }
    public UnaryOperatorKind OperatorKind { get; }
    public BoundExpression Operand { get; }
    public MethodSymbol MethodOpt { get; }
    public Conversion OperandConversion { get; }
    public Conversion ResultConversion { get; }
    public LookupResultKind ResultKind { get; }
    public BoundIncrementOperator(CSharpSyntaxNode syntax, UnaryOperatorKind operatorKind, BoundExpression operand, MethodSymbol methodOpt, Conversion operandConversion, Conversion resultConversion, LookupResultKind resultKind, ImmutableArray`1<MethodSymbol> originalUserDefinedOperatorsOpt, TypeSymbol type, bool hasErrors);
    public BoundIncrementOperator(CSharpSyntaxNode syntax, UnaryOperatorKind operatorKind, BoundExpression operand, MethodSymbol methodOpt, Conversion operandConversion, Conversion resultConversion, LookupResultKind resultKind, TypeSymbol type, bool hasErrors);
    private static BoundIncrementOperator();
    public virtual Symbol get_ExpressionSymbol();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<MethodSymbol> get_OriginalUserDefinedOperatorsOpt();
    private sealed virtual override UnaryOperationKind Microsoft.CodeAnalysis.Semantics.IIncrementExpression.get_IncrementOperationKind();
    private sealed virtual override BinaryOperationKind Microsoft.CodeAnalysis.Semantics.ICompoundAssignmentExpression.get_BinaryOperationKind();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IAssignmentExpression.get_Target();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IAssignmentExpression.get_Value();
    private sealed virtual override bool Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.get_UsesOperatorMethod();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.get_OperatorMethod();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public UnaryOperatorKind get_OperatorKind();
    [CompilerGeneratedAttribute]
public BoundExpression get_Operand();
    [CompilerGeneratedAttribute]
public MethodSymbol get_MethodOpt();
    [CompilerGeneratedAttribute]
public Conversion get_OperandConversion();
    [CompilerGeneratedAttribute]
public Conversion get_ResultConversion();
    public virtual LookupResultKind get_ResultKind();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundIncrementOperator Update(UnaryOperatorKind operatorKind, BoundExpression operand, MethodSymbol methodOpt, Conversion operandConversion, Conversion resultConversion, LookupResultKind resultKind, TypeSymbol type);
    [CompilerGeneratedAttribute]
private IOperation <Microsoft.CodeAnalysis.Semantics.IAssignmentExpression.get_Value>b__14_0(BoundIncrementOperator increment);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundIndexerAccess : BoundExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<PropertySymbol> <OriginalIndexersOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <ReceiverOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertySymbol <Indexer>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ArgumentNamesOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<RefKind> <ArgumentRefKindsOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Expanded>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<int> <ArgsToParamsOpt>k__BackingField;
    public Symbol ExpressionSymbol { get; }
    public ImmutableArray`1<PropertySymbol> OriginalIndexersOpt { get; private set; }
    public LookupResultKind ResultKind { get; }
    private IPropertySymbol Microsoft.CodeAnalysis.Semantics.IPropertyReferenceExpression.Property { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.Instance { get; }
    private ISymbol Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.Member { get; }
    private ImmutableArray`1<IArgument> Microsoft.CodeAnalysis.Semantics.IHasArgumentsExpression.ArgumentsInParameterOrder { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundExpression ReceiverOpt { get; }
    public PropertySymbol Indexer { get; }
    public ImmutableArray`1<BoundExpression> Arguments { get; }
    public ImmutableArray`1<string> ArgumentNamesOpt { get; }
    public ImmutableArray`1<RefKind> ArgumentRefKindsOpt { get; }
    public bool Expanded { get; }
    public ImmutableArray`1<int> ArgsToParamsOpt { get; }
    public BoundIndexerAccess(CSharpSyntaxNode syntax, BoundExpression receiverOpt, PropertySymbol indexer, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNamesOpt, ImmutableArray`1<RefKind> argumentRefKindsOpt, bool expanded, ImmutableArray`1<int> argsToParamsOpt, TypeSymbol type, bool hasErrors);
    public virtual Symbol get_ExpressionSymbol();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<PropertySymbol> get_OriginalIndexersOpt();
    [CompilerGeneratedAttribute]
private void set_OriginalIndexersOpt(ImmutableArray`1<PropertySymbol> value);
    public virtual LookupResultKind get_ResultKind();
    public static BoundIndexerAccess ErrorAccess(CSharpSyntaxNode node, BoundExpression receiverOpt, PropertySymbol indexer, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> namedArguments, ImmutableArray`1<RefKind> refKinds, ImmutableArray`1<PropertySymbol> originalIndexers);
    private sealed virtual override IPropertySymbol Microsoft.CodeAnalysis.Semantics.IPropertyReferenceExpression.get_Property();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.get_Instance();
    private sealed virtual override ISymbol Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.get_Member();
    private sealed virtual override ImmutableArray`1<IArgument> Microsoft.CodeAnalysis.Semantics.IHasArgumentsExpression.get_ArgumentsInParameterOrder();
    private sealed virtual override IArgument Microsoft.CodeAnalysis.Semantics.IHasArgumentsExpression.GetArgumentMatchingParameter(IParameterSymbol parameter);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_ReceiverOpt();
    [CompilerGeneratedAttribute]
public PropertySymbol get_Indexer();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_Arguments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ArgumentNamesOpt();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<RefKind> get_ArgumentRefKindsOpt();
    [CompilerGeneratedAttribute]
public bool get_Expanded();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<int> get_ArgsToParamsOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundIndexerAccess Update(BoundExpression receiverOpt, PropertySymbol indexer, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNamesOpt, ImmutableArray`1<RefKind> argumentRefKindsOpt, bool expanded, ImmutableArray`1<int> argsToParamsOpt, TypeSymbol type);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.BoundInitializer : BoundNode {
    protected BoundInitializer(BoundKind kind, CSharpSyntaxNode syntax, bool hasErrors);
    protected BoundInitializer(BoundKind kind, CSharpSyntaxNode syntax);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundInterpolatedString : BoundExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <Parts>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public ImmutableArray`1<BoundExpression> Parts { get; }
    public BoundInterpolatedString(CSharpSyntaxNode syntax, ImmutableArray`1<BoundExpression> parts, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_Parts();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundInterpolatedString Update(ImmutableArray`1<BoundExpression> parts, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundIsOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Operand>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundTypeExpression <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private Conversion <Conversion>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.IIsTypeExpression.Operand { get; }
    private ITypeSymbol Microsoft.CodeAnalysis.Semantics.IIsTypeExpression.IsType { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Operand { get; }
    public BoundTypeExpression TargetType { get; }
    public Conversion Conversion { get; }
    public BoundIsOperator(CSharpSyntaxNode syntax, BoundExpression operand, BoundTypeExpression targetType, Conversion conversion, TypeSymbol type, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IIsTypeExpression.get_Operand();
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.Semantics.IIsTypeExpression.get_IsType();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Operand();
    [CompilerGeneratedAttribute]
public BoundTypeExpression get_TargetType();
    [CompilerGeneratedAttribute]
public Conversion get_Conversion();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundIsOperator Update(BoundExpression operand, BoundTypeExpression targetType, Conversion conversion, TypeSymbol type);
}
internal enum Microsoft.CodeAnalysis.CSharp.BoundKind : Enum {
    public byte value__;
    public static BoundKind FieldInitializer;
    public static BoundKind FieldEqualsValue;
    public static BoundKind PropertyEqualsValue;
    public static BoundKind ParameterEqualsValue;
    public static BoundKind GlobalStatementInitializer;
    public static BoundKind Dup;
    public static BoundKind BadExpression;
    public static BoundKind BadStatement;
    public static BoundKind TypeExpression;
    public static BoundKind TypeOrValueExpression;
    public static BoundKind NamespaceExpression;
    public static BoundKind UnaryOperator;
    public static BoundKind IncrementOperator;
    public static BoundKind AddressOfOperator;
    public static BoundKind PointerIndirectionOperator;
    public static BoundKind PointerElementAccess;
    public static BoundKind RefTypeOperator;
    public static BoundKind MakeRefOperator;
    public static BoundKind RefValueOperator;
    public static BoundKind BinaryOperator;
    public static BoundKind UserDefinedConditionalLogicalOperator;
    public static BoundKind CompoundAssignmentOperator;
    public static BoundKind AssignmentOperator;
    public static BoundKind NullCoalescingOperator;
    public static BoundKind ConditionalOperator;
    public static BoundKind ArrayAccess;
    public static BoundKind ArrayLength;
    public static BoundKind AwaitExpression;
    public static BoundKind TypeOfOperator;
    public static BoundKind MethodInfo;
    public static BoundKind FieldInfo;
    public static BoundKind DefaultOperator;
    public static BoundKind IsOperator;
    public static BoundKind AsOperator;
    public static BoundKind SizeOfOperator;
    public static BoundKind Conversion;
    public static BoundKind ArgList;
    public static BoundKind ArgListOperator;
    public static BoundKind FixedLocalCollectionInitializer;
    public static BoundKind SequencePoint;
    public static BoundKind SequencePointExpression;
    public static BoundKind SequencePointWithSpan;
    public static BoundKind Block;
    public static BoundKind StateMachineScope;
    public static BoundKind LocalDeclaration;
    public static BoundKind MultipleLocalDeclarations;
    public static BoundKind Sequence;
    public static BoundKind NoOpStatement;
    public static BoundKind ReturnStatement;
    public static BoundKind YieldReturnStatement;
    public static BoundKind YieldBreakStatement;
    public static BoundKind ThrowStatement;
    public static BoundKind ExpressionStatement;
    public static BoundKind SwitchStatement;
    public static BoundKind SwitchSection;
    public static BoundKind SwitchLabel;
    public static BoundKind BreakStatement;
    public static BoundKind ContinueStatement;
    public static BoundKind IfStatement;
    public static BoundKind DoStatement;
    public static BoundKind WhileStatement;
    public static BoundKind ForStatement;
    public static BoundKind ForEachStatement;
    public static BoundKind UsingStatement;
    public static BoundKind FixedStatement;
    public static BoundKind LockStatement;
    public static BoundKind TryStatement;
    public static BoundKind CatchBlock;
    public static BoundKind Literal;
    public static BoundKind ThisReference;
    public static BoundKind PreviousSubmissionReference;
    public static BoundKind HostObjectMemberReference;
    public static BoundKind BaseReference;
    public static BoundKind Local;
    public static BoundKind PseudoVariable;
    public static BoundKind RangeVariable;
    public static BoundKind Parameter;
    public static BoundKind LabelStatement;
    public static BoundKind GotoStatement;
    public static BoundKind LabeledStatement;
    public static BoundKind Label;
    public static BoundKind StatementList;
    public static BoundKind ConditionalGoto;
    public static BoundKind DynamicMemberAccess;
    public static BoundKind DynamicInvocation;
    public static BoundKind ConditionalAccess;
    public static BoundKind LoweredConditionalAccess;
    public static BoundKind ConditionalReceiver;
    public static BoundKind ComplexConditionalReceiver;
    public static BoundKind MethodGroup;
    public static BoundKind PropertyGroup;
    public static BoundKind Call;
    public static BoundKind EventAssignmentOperator;
    public static BoundKind Attribute;
    public static BoundKind ObjectCreationExpression;
    public static BoundKind DynamicObjectCreationExpression;
    public static BoundKind NoPiaObjectCreationExpression;
    public static BoundKind ObjectInitializerExpression;
    public static BoundKind ObjectInitializerMember;
    public static BoundKind DynamicObjectInitializerMember;
    public static BoundKind CollectionInitializerExpression;
    public static BoundKind CollectionElementInitializer;
    public static BoundKind DynamicCollectionElementInitializer;
    public static BoundKind ImplicitReceiver;
    public static BoundKind AnonymousObjectCreationExpression;
    public static BoundKind AnonymousPropertyDeclaration;
    public static BoundKind NewT;
    public static BoundKind DelegateCreationExpression;
    public static BoundKind ArrayCreation;
    public static BoundKind ArrayInitialization;
    public static BoundKind StackAllocArrayCreation;
    public static BoundKind FieldAccess;
    public static BoundKind HoistedFieldAccess;
    public static BoundKind PropertyAccess;
    public static BoundKind EventAccess;
    public static BoundKind IndexerAccess;
    public static BoundKind DynamicIndexerAccess;
    public static BoundKind Lambda;
    public static BoundKind UnboundLambda;
    public static BoundKind QueryClause;
    public static BoundKind TypeOrInstanceInitializers;
    public static BoundKind NameOfOperator;
    public static BoundKind InterpolatedString;
    public static BoundKind StringInsert;
}
internal class Microsoft.CodeAnalysis.CSharp.BoundLabel : BoundExpression {
    [CompilerGeneratedAttribute]
private LabelSymbol <Label>k__BackingField;
    public Symbol ExpressionSymbol { get; }
    protected OperationKind ExpressionKind { get; }
    public LabelSymbol Label { get; }
    public BoundLabel(CSharpSyntaxNode syntax, LabelSymbol label, TypeSymbol type, bool hasErrors);
    public BoundLabel(CSharpSyntaxNode syntax, LabelSymbol label, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public LabelSymbol get_Label();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLabel Update(LabelSymbol label, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundLabeledStatement : BoundStatement {
    [CompilerGeneratedAttribute]
private LabelSymbol <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundStatement <Body>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.ILabelStatement.LabeledStatement { get; }
    private ILabelSymbol Microsoft.CodeAnalysis.Semantics.ILabelStatement.Label { get; }
    protected OperationKind StatementKind { get; }
    public LabelSymbol Label { get; }
    public BoundStatement Body { get; }
    public BoundLabeledStatement(CSharpSyntaxNode syntax, LabelSymbol label, BoundStatement body, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.ILabelStatement.get_LabeledStatement();
    private sealed virtual override ILabelSymbol Microsoft.CodeAnalysis.Semantics.ILabelStatement.get_Label();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public LabelSymbol get_Label();
    [CompilerGeneratedAttribute]
public BoundStatement get_Body();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLabeledStatement Update(LabelSymbol label, BoundStatement body);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundLabelStatement : BoundStatement {
    [CompilerGeneratedAttribute]
private LabelSymbol <Label>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.ILabelStatement.LabeledStatement { get; }
    private ILabelSymbol Microsoft.CodeAnalysis.Semantics.ILabelStatement.Label { get; }
    protected OperationKind StatementKind { get; }
    public LabelSymbol Label { get; }
    public BoundLabelStatement(CSharpSyntaxNode syntax, LabelSymbol label, bool hasErrors);
    public BoundLabelStatement(CSharpSyntaxNode syntax, LabelSymbol label);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.ILabelStatement.get_LabeledStatement();
    private sealed virtual override ILabelSymbol Microsoft.CodeAnalysis.Semantics.ILabelStatement.get_Label();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public LabelSymbol get_Label();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLabelStatement Update(LabelSymbol label);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundLambda : BoundExpression {
    private bool _inferredFromSingleType;
    private TypeSymbol _inferredReturnType;
    private HashSet`1<DiagnosticInfo> _inferredReturnTypeUseSiteDiagnostics;
    [CompilerGeneratedAttribute]
private LambdaSymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundBlock <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Diagnostic> <Diagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private Binder <Binder>k__BackingField;
    public Symbol ExpressionSymbol { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.Semantics.ILambdaExpression.Signature { get; }
    private IBlockStatement Microsoft.CodeAnalysis.Semantics.ILambdaExpression.Body { get; }
    protected OperationKind ExpressionKind { get; }
    public object Display { get; }
    public MessageID MessageID { get; }
    public bool InferredFromSingleType { get; }
    public LambdaSymbol Symbol { get; }
    public BoundBlock Body { get; }
    public ImmutableArray`1<Diagnostic> Diagnostics { get; }
    public Binder Binder { get; }
    public BoundLambda(CSharpSyntaxNode syntax, BoundBlock body, ImmutableArray`1<Diagnostic> diagnostics, Binder binder, TypeSymbol type, bool inferReturnType);
    public BoundLambda(CSharpSyntaxNode syntax, LambdaSymbol symbol, BoundBlock body, ImmutableArray`1<Diagnostic> diagnostics, Binder binder, TypeSymbol type, bool hasErrors);
    public virtual Symbol get_ExpressionSymbol();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.Semantics.ILambdaExpression.get_Signature();
    private sealed virtual override IBlockStatement Microsoft.CodeAnalysis.Semantics.ILambdaExpression.get_Body();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual object get_Display();
    public MessageID get_MessageID();
    public bool get_InferredFromSingleType();
    public TypeSymbol InferredReturnType(HashSet`1& useSiteDiagnostics);
    private static TypeSymbol InferReturnType(BoundBlock block, Binder binder, bool isAsync, HashSet`1& useSiteDiagnostics, Boolean& inferredFromSingleType);
    [CompilerGeneratedAttribute]
public LambdaSymbol get_Symbol();
    [CompilerGeneratedAttribute]
public BoundBlock get_Body();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<Diagnostic> get_Diagnostics();
    [CompilerGeneratedAttribute]
public Binder get_Binder();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLambda Update(LambdaSymbol symbol, BoundBlock body, ImmutableArray`1<Diagnostic> diagnostics, Binder binder, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundLiteral : BoundExpression {
    [CompilerGeneratedAttribute]
private ConstantValue <ConstantValueOpt>k__BackingField;
    public ConstantValue ConstantValue { get; }
    private string Microsoft.CodeAnalysis.Semantics.ILiteralExpression.Text { get; }
    protected OperationKind ExpressionKind { get; }
    public object Display { get; }
    public ConstantValue ConstantValueOpt { get; }
    public BoundLiteral(CSharpSyntaxNode syntax, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors);
    public BoundLiteral(CSharpSyntaxNode syntax, ConstantValue constantValueOpt, TypeSymbol type);
    public virtual ConstantValue get_ConstantValue();
    private sealed virtual override string Microsoft.CodeAnalysis.Semantics.ILiteralExpression.get_Text();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual object get_Display();
    [CompilerGeneratedAttribute]
public ConstantValue get_ConstantValueOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLiteral Update(ConstantValue constantValueOpt, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundLocal : BoundExpression {
    [CompilerGeneratedAttribute]
private LocalSymbol <LocalSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstantValue <ConstantValueOpt>k__BackingField;
    public ConstantValue ConstantValue { get; }
    public Symbol ExpressionSymbol { get; }
    private ILocalSymbol Microsoft.CodeAnalysis.Semantics.ILocalReferenceExpression.Local { get; }
    protected OperationKind ExpressionKind { get; }
    public LocalSymbol LocalSymbol { get; }
    public ConstantValue ConstantValueOpt { get; }
    public BoundLocal(CSharpSyntaxNode syntax, LocalSymbol localSymbol, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors);
    public BoundLocal(CSharpSyntaxNode syntax, LocalSymbol localSymbol, ConstantValue constantValueOpt, TypeSymbol type);
    public virtual ConstantValue get_ConstantValue();
    public virtual Symbol get_ExpressionSymbol();
    private sealed virtual override ILocalSymbol Microsoft.CodeAnalysis.Semantics.ILocalReferenceExpression.get_Local();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public LocalSymbol get_LocalSymbol();
    [CompilerGeneratedAttribute]
public ConstantValue get_ConstantValueOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLocal Update(LocalSymbol localSymbol, ConstantValue constantValueOpt, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundLocalDeclaration : BoundStatement {
    private static ConditionalWeakTable`2<BoundLocalDeclaration, object> s_variablesMappings;
    [CompilerGeneratedAttribute]
private LocalSymbol <LocalSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundTypeExpression <DeclaredType>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <InitializerOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <ArgumentsOpt>k__BackingField;
    private ImmutableArray`1<IVariableDeclaration> Microsoft.CodeAnalysis.Semantics.IVariableDeclarationStatement.Variables { get; }
    protected OperationKind StatementKind { get; }
    public LocalSymbol LocalSymbol { get; }
    public BoundTypeExpression DeclaredType { get; }
    public BoundExpression InitializerOpt { get; }
    public ImmutableArray`1<BoundExpression> ArgumentsOpt { get; }
    public BoundLocalDeclaration(CSharpSyntaxNode syntax, LocalSymbol localSymbol, BoundTypeExpression declaredType, BoundExpression initializerOpt, ImmutableArray`1<BoundExpression> argumentsOpt, bool hasErrors);
    private static BoundLocalDeclaration();
    private sealed virtual override ImmutableArray`1<IVariableDeclaration> Microsoft.CodeAnalysis.Semantics.IVariableDeclarationStatement.get_Variables();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public LocalSymbol get_LocalSymbol();
    [CompilerGeneratedAttribute]
public BoundTypeExpression get_DeclaredType();
    [CompilerGeneratedAttribute]
public BoundExpression get_InitializerOpt();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_ArgumentsOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLocalDeclaration Update(LocalSymbol localSymbol, BoundTypeExpression declaredType, BoundExpression initializerOpt, ImmutableArray`1<BoundExpression> argumentsOpt);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundLockStatement : BoundStatement {
    [CompilerGeneratedAttribute]
private BoundExpression <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundStatement <Body>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.ILockStatement.LockedObject { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.ILockStatement.Body { get; }
    protected OperationKind StatementKind { get; }
    public BoundExpression Argument { get; }
    public BoundStatement Body { get; }
    public BoundLockStatement(CSharpSyntaxNode syntax, BoundExpression argument, BoundStatement body, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.ILockStatement.get_LockedObject();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.ILockStatement.get_Body();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Argument();
    [CompilerGeneratedAttribute]
public BoundStatement get_Body();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLockStatement Update(BoundExpression argument, BoundStatement body);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.BoundLoopStatement : BoundStatement {
    [CompilerGeneratedAttribute]
private GeneratedLabelSymbol <BreakLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private GeneratedLabelSymbol <ContinueLabel>k__BackingField;
    public GeneratedLabelSymbol BreakLabel { get; }
    public GeneratedLabelSymbol ContinueLabel { get; }
    protected BoundLoopStatement(BoundKind kind, CSharpSyntaxNode syntax, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel, bool hasErrors);
    protected BoundLoopStatement(BoundKind kind, CSharpSyntaxNode syntax, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel);
    [CompilerGeneratedAttribute]
public GeneratedLabelSymbol get_BreakLabel();
    [CompilerGeneratedAttribute]
public GeneratedLabelSymbol get_ContinueLabel();
}
internal class Microsoft.CodeAnalysis.CSharp.BoundLoweredConditionalAccess : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Receiver>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSymbol <HasValueMethodOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <WhenNotNull>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <WhenNullOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Receiver { get; }
    public MethodSymbol HasValueMethodOpt { get; }
    public BoundExpression WhenNotNull { get; }
    public BoundExpression WhenNullOpt { get; }
    public int Id { get; }
    public BoundLoweredConditionalAccess(CSharpSyntaxNode syntax, BoundExpression receiver, MethodSymbol hasValueMethodOpt, BoundExpression whenNotNull, BoundExpression whenNullOpt, int id, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Receiver();
    [CompilerGeneratedAttribute]
public MethodSymbol get_HasValueMethodOpt();
    [CompilerGeneratedAttribute]
public BoundExpression get_WhenNotNull();
    [CompilerGeneratedAttribute]
public BoundExpression get_WhenNullOpt();
    [CompilerGeneratedAttribute]
public int get_Id();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLoweredConditionalAccess Update(BoundExpression receiver, MethodSymbol hasValueMethodOpt, BoundExpression whenNotNull, BoundExpression whenNullOpt, int id, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundMakeRefOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Operand>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Operand { get; }
    public BoundMakeRefOperator(CSharpSyntaxNode syntax, BoundExpression operand, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Operand();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundMakeRefOperator Update(BoundExpression operand, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundMethodGroup : BoundMethodOrPropertyGroup {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TypeSymbol> <TypeArgumentsOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<MethodSymbol> <Methods>k__BackingField;
    [CompilerGeneratedAttribute]
private Symbol <LookupSymbolOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticInfo <LookupError>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundMethodGroupFlags <Flags>k__BackingField;
    public MemberAccessExpressionSyntax MemberAccessExpressionSyntax { get; }
    public CSharpSyntaxNode NameSyntax { get; }
    public BoundExpression InstanceOpt { get; }
    public bool SearchExtensionMethods { get; }
    protected OperationKind ExpressionKind { get; }
    public object Display { get; }
    public ImmutableArray`1<TypeSymbol> TypeArgumentsOpt { get; }
    public string Name { get; }
    public ImmutableArray`1<MethodSymbol> Methods { get; }
    public Symbol LookupSymbolOpt { get; }
    public DiagnosticInfo LookupError { get; }
    public BoundMethodGroupFlags Flags { get; }
    public BoundMethodGroup(CSharpSyntaxNode syntax, ImmutableArray`1<TypeSymbol> typeArgumentsOpt, BoundExpression receiverOpt, string name, ImmutableArray`1<MethodSymbol> methods, LookupResult lookupResult, BoundMethodGroupFlags flags, bool hasErrors);
    public BoundMethodGroup(CSharpSyntaxNode syntax, ImmutableArray`1<TypeSymbol> typeArgumentsOpt, string name, ImmutableArray`1<MethodSymbol> methods, Symbol lookupSymbolOpt, DiagnosticInfo lookupError, BoundMethodGroupFlags flags, BoundExpression receiverOpt, LookupResultKind resultKind, bool hasErrors);
    public MemberAccessExpressionSyntax get_MemberAccessExpressionSyntax();
    public CSharpSyntaxNode get_NameSyntax();
    public BoundExpression get_InstanceOpt();
    public bool get_SearchExtensionMethods();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual object get_Display();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TypeSymbol> get_TypeArgumentsOpt();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<MethodSymbol> get_Methods();
    [CompilerGeneratedAttribute]
public Symbol get_LookupSymbolOpt();
    [CompilerGeneratedAttribute]
public DiagnosticInfo get_LookupError();
    [CompilerGeneratedAttribute]
public BoundMethodGroupFlags get_Flags();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundMethodGroup Update(ImmutableArray`1<TypeSymbol> typeArgumentsOpt, string name, ImmutableArray`1<MethodSymbol> methods, Symbol lookupSymbolOpt, DiagnosticInfo lookupError, BoundMethodGroupFlags flags, BoundExpression receiverOpt, LookupResultKind resultKind);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.BoundMethodGroupFlags : Enum {
    public int value__;
    public static BoundMethodGroupFlags None;
    public static BoundMethodGroupFlags SearchExtensionMethods;
    public static BoundMethodGroupFlags HasImplicitReceiver;
}
internal class Microsoft.CodeAnalysis.CSharp.BoundMethodInfo : BoundExpression {
    [CompilerGeneratedAttribute]
private MethodSymbol <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSymbol <GetMethodFromHandle>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public MethodSymbol Method { get; }
    public MethodSymbol GetMethodFromHandle { get; }
    public BoundMethodInfo(CSharpSyntaxNode syntax, MethodSymbol method, MethodSymbol getMethodFromHandle, TypeSymbol type, bool hasErrors);
    public BoundMethodInfo(CSharpSyntaxNode syntax, MethodSymbol method, MethodSymbol getMethodFromHandle, TypeSymbol type);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public MethodSymbol get_Method();
    [CompilerGeneratedAttribute]
public MethodSymbol get_GetMethodFromHandle();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundMethodInfo Update(MethodSymbol method, MethodSymbol getMethodFromHandle, TypeSymbol type);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.BoundMethodOrPropertyGroup : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <ReceiverOpt>k__BackingField;
    private LookupResultKind _ResultKind;
    public BoundExpression ReceiverOpt { get; }
    public LookupResultKind ResultKind { get; }
    protected BoundMethodOrPropertyGroup(BoundKind kind, CSharpSyntaxNode syntax, BoundExpression receiverOpt, LookupResultKind resultKind, bool hasErrors);
    [CompilerGeneratedAttribute]
public BoundExpression get_ReceiverOpt();
    public virtual LookupResultKind get_ResultKind();
}
internal class Microsoft.CodeAnalysis.CSharp.BoundMultipleLocalDeclarations : BoundStatement {
    private static ConditionalWeakTable`2<BoundMultipleLocalDeclarations, object> s_variablesMappings;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundLocalDeclaration> <LocalDeclarations>k__BackingField;
    private ImmutableArray`1<IVariableDeclaration> Microsoft.CodeAnalysis.Semantics.IVariableDeclarationStatement.Variables { get; }
    protected OperationKind StatementKind { get; }
    public ImmutableArray`1<BoundLocalDeclaration> LocalDeclarations { get; }
    public BoundMultipleLocalDeclarations(CSharpSyntaxNode syntax, ImmutableArray`1<BoundLocalDeclaration> localDeclarations, bool hasErrors);
    private static BoundMultipleLocalDeclarations();
    private sealed virtual override ImmutableArray`1<IVariableDeclaration> Microsoft.CodeAnalysis.Semantics.IVariableDeclarationStatement.get_Variables();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundLocalDeclaration> get_LocalDeclarations();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundMultipleLocalDeclarations Update(ImmutableArray`1<BoundLocalDeclaration> localDeclarations);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundNameOfOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstantValue <ConstantValueOpt>k__BackingField;
    public ConstantValue ConstantValue { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Argument { get; }
    public ConstantValue ConstantValueOpt { get; }
    public BoundNameOfOperator(CSharpSyntaxNode syntax, BoundExpression argument, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors);
    public virtual ConstantValue get_ConstantValue();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Argument();
    [CompilerGeneratedAttribute]
public ConstantValue get_ConstantValueOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundNameOfOperator Update(BoundExpression argument, ConstantValue constantValueOpt, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundNamespaceExpression : BoundExpression {
    [CompilerGeneratedAttribute]
private NamespaceSymbol <NamespaceSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private AliasSymbol <AliasOpt>k__BackingField;
    public Symbol ExpressionSymbol { get; }
    protected OperationKind ExpressionKind { get; }
    public NamespaceSymbol NamespaceSymbol { get; }
    public AliasSymbol AliasOpt { get; }
    public BoundNamespaceExpression(CSharpSyntaxNode syntax, NamespaceSymbol namespaceSymbol, bool hasErrors);
    public BoundNamespaceExpression(CSharpSyntaxNode syntax, NamespaceSymbol namespaceSymbol);
    public BoundNamespaceExpression(CSharpSyntaxNode syntax, NamespaceSymbol namespaceSymbol, AliasSymbol aliasOpt, bool hasErrors);
    public BoundNamespaceExpression(CSharpSyntaxNode syntax, NamespaceSymbol namespaceSymbol, AliasSymbol aliasOpt);
    public virtual Symbol get_ExpressionSymbol();
    public BoundNamespaceExpression Update(NamespaceSymbol namespaceSymbol);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public NamespaceSymbol get_NamespaceSymbol();
    [CompilerGeneratedAttribute]
public AliasSymbol get_AliasOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundNamespaceExpression Update(NamespaceSymbol namespaceSymbol, AliasSymbol aliasOpt);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundNewT : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <InitializerExpressionOpt>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public BoundExpression InitializerExpressionOpt { get; }
    public BoundNewT(CSharpSyntaxNode syntax, BoundExpression initializerExpressionOpt, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_InitializerExpressionOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundNewT Update(BoundExpression initializerExpressionOpt, TypeSymbol type);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.BoundNode : object {
    private BoundKind _kind;
    private BoundNodeAttributes _attributes;
    public CSharpSyntaxNode Syntax;
    public bool HasAnyErrors { get; }
    public bool HasErrors { get; }
    public SyntaxTree SyntaxTree { get; }
    public bool WasCompilerGenerated { get; internal set; }
    public BoundKind Kind { get; }
    protected BoundNode(BoundKind kind, CSharpSyntaxNode syntax);
    protected BoundNode(BoundKind kind, CSharpSyntaxNode syntax, bool hasErrors);
    public bool get_HasAnyErrors();
    public bool get_HasErrors();
    public SyntaxTree get_SyntaxTree();
    public bool get_WasCompilerGenerated();
    internal void set_WasCompilerGenerated(bool value);
    public void ResetCompilerGenerated(bool newCompilerGenerated);
    public BoundKind get_Kind();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.BoundNodeExtensions : object {
    [ExtensionAttribute]
public static bool HasErrors(ImmutableArray`1<T> nodeArray);
    [ExtensionAttribute]
public static bool HasErrors(BoundNode node);
    [ExtensionAttribute]
public static bool IsConstructorInitializer(BoundStatement statement);
    [ExtensionAttribute]
public static bool IsConstructorInitializer(BoundCall call);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundNoOpStatement : BoundStatement {
    [CompilerGeneratedAttribute]
private NoOpStatementFlavor <Flavor>k__BackingField;
    protected OperationKind StatementKind { get; }
    public NoOpStatementFlavor Flavor { get; }
    public BoundNoOpStatement(CSharpSyntaxNode syntax, NoOpStatementFlavor flavor, bool hasErrors);
    public BoundNoOpStatement(CSharpSyntaxNode syntax, NoOpStatementFlavor flavor);
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public NoOpStatementFlavor get_Flavor();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundNoOpStatement Update(NoOpStatementFlavor flavor);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundNoPiaObjectCreationExpression : BoundExpression {
    [CompilerGeneratedAttribute]
private string <GuidString>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <InitializerExpressionOpt>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public string GuidString { get; }
    public BoundExpression InitializerExpressionOpt { get; }
    public BoundNoPiaObjectCreationExpression(CSharpSyntaxNode syntax, string guidString, BoundExpression initializerExpressionOpt, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public string get_GuidString();
    [CompilerGeneratedAttribute]
public BoundExpression get_InitializerExpressionOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundNoPiaObjectCreationExpression Update(string guidString, BoundExpression initializerExpressionOpt, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundNullCoalescingOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <LeftOperand>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <RightOperand>k__BackingField;
    [CompilerGeneratedAttribute]
private Conversion <LeftConversion>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.INullCoalescingExpression.PrimaryOperand { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.INullCoalescingExpression.SecondaryOperand { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundExpression LeftOperand { get; }
    public BoundExpression RightOperand { get; }
    public Conversion LeftConversion { get; }
    public BoundNullCoalescingOperator(CSharpSyntaxNode syntax, BoundExpression leftOperand, BoundExpression rightOperand, Conversion leftConversion, TypeSymbol type, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.INullCoalescingExpression.get_PrimaryOperand();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.INullCoalescingExpression.get_SecondaryOperand();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_LeftOperand();
    [CompilerGeneratedAttribute]
public BoundExpression get_RightOperand();
    [CompilerGeneratedAttribute]
public Conversion get_LeftConversion();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundNullCoalescingOperator Update(BoundExpression leftOperand, BoundExpression rightOperand, Conversion leftConversion, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundObjectCreationExpression : BoundExpression {
    private static ConditionalWeakTable`2<BoundObjectCreationExpression, object> s_memberInitializersMappings;
    [CompilerGeneratedAttribute]
private MethodSymbol <Constructor>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<MethodSymbol> <ConstructorsGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ArgumentNamesOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<RefKind> <ArgumentRefKindsOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Expanded>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<int> <ArgsToParamsOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstantValue <ConstantValueOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <InitializerExpressionOpt>k__BackingField;
    public ConstantValue ConstantValue { get; }
    public Symbol ExpressionSymbol { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.Semantics.IObjectCreationExpression.Constructor { get; }
    private ImmutableArray`1<IArgument> Microsoft.CodeAnalysis.Semantics.IHasArgumentsExpression.ArgumentsInParameterOrder { get; }
    private ImmutableArray`1<ISymbolInitializer> Microsoft.CodeAnalysis.Semantics.IObjectCreationExpression.MemberInitializers { get; }
    protected OperationKind ExpressionKind { get; }
    public MethodSymbol Constructor { get; }
    public ImmutableArray`1<MethodSymbol> ConstructorsGroup { get; }
    public ImmutableArray`1<BoundExpression> Arguments { get; }
    public ImmutableArray`1<string> ArgumentNamesOpt { get; }
    public ImmutableArray`1<RefKind> ArgumentRefKindsOpt { get; }
    public bool Expanded { get; }
    public ImmutableArray`1<int> ArgsToParamsOpt { get; }
    public ConstantValue ConstantValueOpt { get; }
    public BoundExpression InitializerExpressionOpt { get; }
    public BoundObjectCreationExpression(CSharpSyntaxNode syntax, MethodSymbol constructor, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNamesOpt, ImmutableArray`1<RefKind> argumentRefKindsOpt, bool expanded, ImmutableArray`1<int> argsToParamsOpt, ConstantValue constantValueOpt, BoundExpression initializerExpressionOpt, TypeSymbol type, bool hasErrors);
    public BoundObjectCreationExpression(CSharpSyntaxNode syntax, MethodSymbol constructor, BoundExpression[] arguments);
    public BoundObjectCreationExpression(CSharpSyntaxNode syntax, MethodSymbol constructor, ImmutableArray`1<BoundExpression> arguments);
    public BoundObjectCreationExpression(CSharpSyntaxNode syntax, MethodSymbol constructor, ImmutableArray`1<MethodSymbol> constructorsGroup, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNamesOpt, ImmutableArray`1<RefKind> argumentRefKindsOpt, bool expanded, ImmutableArray`1<int> argsToParamsOpt, ConstantValue constantValueOpt, BoundExpression initializerExpressionOpt, TypeSymbol type, bool hasErrors);
    private static BoundObjectCreationExpression();
    public virtual ConstantValue get_ConstantValue();
    public virtual Symbol get_ExpressionSymbol();
    internal BoundObjectCreationExpression UpdateArgumentsAndInitializer(ImmutableArray`1<BoundExpression> newArguments, BoundExpression newInitializerExpression, TypeSymbol changeTypeOpt);
    public BoundObjectCreationExpression Update(MethodSymbol constructor, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNamesOpt, ImmutableArray`1<RefKind> argumentRefKindsOpt, bool expanded, ImmutableArray`1<int> argsToParamsOpt, ConstantValue constantValueOpt, BoundExpression initializerExpressionOpt, TypeSymbol type);
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.Semantics.IObjectCreationExpression.get_Constructor();
    private sealed virtual override ImmutableArray`1<IArgument> Microsoft.CodeAnalysis.Semantics.IHasArgumentsExpression.get_ArgumentsInParameterOrder();
    private sealed virtual override IArgument Microsoft.CodeAnalysis.Semantics.IHasArgumentsExpression.GetArgumentMatchingParameter(IParameterSymbol parameter);
    private sealed virtual override ImmutableArray`1<ISymbolInitializer> Microsoft.CodeAnalysis.Semantics.IObjectCreationExpression.get_MemberInitializers();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public MethodSymbol get_Constructor();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<MethodSymbol> get_ConstructorsGroup();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_Arguments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ArgumentNamesOpt();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<RefKind> get_ArgumentRefKindsOpt();
    [CompilerGeneratedAttribute]
public bool get_Expanded();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<int> get_ArgsToParamsOpt();
    [CompilerGeneratedAttribute]
public ConstantValue get_ConstantValueOpt();
    [CompilerGeneratedAttribute]
public BoundExpression get_InitializerExpressionOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundObjectCreationExpression Update(MethodSymbol constructor, ImmutableArray`1<MethodSymbol> constructorsGroup, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNamesOpt, ImmutableArray`1<RefKind> argumentRefKindsOpt, bool expanded, ImmutableArray`1<int> argsToParamsOpt, ConstantValue constantValueOpt, BoundExpression initializerExpressionOpt, TypeSymbol type);
    [CompilerGeneratedAttribute]
private object <Microsoft.CodeAnalysis.Semantics.IObjectCreationExpression.get_MemberInitializers>b__16_0(BoundObjectCreationExpression objectCreationExpression);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundObjectInitializerExpression : BoundExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <Initializers>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public ImmutableArray`1<BoundExpression> Initializers { get; }
    public BoundObjectInitializerExpression(CSharpSyntaxNode syntax, ImmutableArray`1<BoundExpression> initializers, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_Initializers();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundObjectInitializerExpression Update(ImmutableArray`1<BoundExpression> initializers, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundObjectInitializerMember : BoundExpression {
    [CompilerGeneratedAttribute]
private Symbol <MemberSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ArgumentNamesOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<RefKind> <ArgumentRefKindsOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Expanded>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<int> <ArgsToParamsOpt>k__BackingField;
    private LookupResultKind _ResultKind;
    public Symbol ExpressionSymbol { get; }
    protected OperationKind ExpressionKind { get; }
    public Symbol MemberSymbol { get; }
    public ImmutableArray`1<BoundExpression> Arguments { get; }
    public ImmutableArray`1<string> ArgumentNamesOpt { get; }
    public ImmutableArray`1<RefKind> ArgumentRefKindsOpt { get; }
    public bool Expanded { get; }
    public ImmutableArray`1<int> ArgsToParamsOpt { get; }
    public LookupResultKind ResultKind { get; }
    public BoundObjectInitializerMember(CSharpSyntaxNode syntax, Symbol memberSymbol, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNamesOpt, ImmutableArray`1<RefKind> argumentRefKindsOpt, bool expanded, ImmutableArray`1<int> argsToParamsOpt, LookupResultKind resultKind, TypeSymbol type, bool hasErrors);
    public virtual Symbol get_ExpressionSymbol();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public Symbol get_MemberSymbol();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_Arguments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ArgumentNamesOpt();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<RefKind> get_ArgumentRefKindsOpt();
    [CompilerGeneratedAttribute]
public bool get_Expanded();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<int> get_ArgsToParamsOpt();
    public virtual LookupResultKind get_ResultKind();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundObjectInitializerMember Update(Symbol memberSymbol, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNamesOpt, ImmutableArray`1<RefKind> argumentRefKindsOpt, bool expanded, ImmutableArray`1<int> argsToParamsOpt, LookupResultKind resultKind, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundParameter : BoundExpression {
    [CompilerGeneratedAttribute]
private ParameterSymbol <ParameterSymbol>k__BackingField;
    public Symbol ExpressionSymbol { get; }
    private IParameterSymbol Microsoft.CodeAnalysis.Semantics.IParameterReferenceExpression.Parameter { get; }
    protected OperationKind ExpressionKind { get; }
    public ParameterSymbol ParameterSymbol { get; }
    public BoundParameter(CSharpSyntaxNode syntax, ParameterSymbol parameterSymbol, bool hasErrors);
    public BoundParameter(CSharpSyntaxNode syntax, ParameterSymbol parameterSymbol);
    public BoundParameter(CSharpSyntaxNode syntax, ParameterSymbol parameterSymbol, TypeSymbol type, bool hasErrors);
    public BoundParameter(CSharpSyntaxNode syntax, ParameterSymbol parameterSymbol, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    private sealed virtual override IParameterSymbol Microsoft.CodeAnalysis.Semantics.IParameterReferenceExpression.get_Parameter();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ParameterSymbol get_ParameterSymbol();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundParameter Update(ParameterSymbol parameterSymbol, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundParameterEqualsValue : BoundEqualsValue {
    [CompilerGeneratedAttribute]
private ParameterSymbol <Parameter>k__BackingField;
    private IParameterSymbol Microsoft.CodeAnalysis.Semantics.IParameterInitializer.Parameter { get; }
    protected OperationKind OperationKind { get; }
    public ParameterSymbol Parameter { get; }
    public BoundParameterEqualsValue(CSharpSyntaxNode syntax, ParameterSymbol parameter, BoundExpression value, bool hasErrors);
    private sealed virtual override IParameterSymbol Microsoft.CodeAnalysis.Semantics.IParameterInitializer.get_Parameter();
    protected virtual OperationKind get_OperationKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ParameterSymbol get_Parameter();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundParameterEqualsValue Update(ParameterSymbol parameter, BoundExpression value);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundPointerElementAccess : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Checked>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Expression { get; }
    public BoundExpression Index { get; }
    public bool Checked { get; }
    public BoundPointerElementAccess(CSharpSyntaxNode syntax, BoundExpression expression, BoundExpression index, bool checked, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Expression();
    [CompilerGeneratedAttribute]
public BoundExpression get_Index();
    [CompilerGeneratedAttribute]
public bool get_Checked();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundPointerElementAccess Update(BoundExpression expression, BoundExpression index, bool checked, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundPointerIndirectionOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Operand>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.IPointerIndirectionReferenceExpression.Pointer { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Operand { get; }
    public BoundPointerIndirectionOperator(CSharpSyntaxNode syntax, BoundExpression operand, TypeSymbol type, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IPointerIndirectionReferenceExpression.get_Pointer();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Operand();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundPointerIndirectionOperator Update(BoundExpression operand, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundPreviousSubmissionReference : BoundExpression {
    protected OperationKind ExpressionKind { get; }
    public BoundPreviousSubmissionReference(CSharpSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    public BoundPreviousSubmissionReference(CSharpSyntaxNode syntax, TypeSymbol type);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundPreviousSubmissionReference Update(TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundPropertyAccess : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <ReceiverOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertySymbol <PropertySymbol>k__BackingField;
    private LookupResultKind _ResultKind;
    public Symbol ExpressionSymbol { get; }
    private IPropertySymbol Microsoft.CodeAnalysis.Semantics.IPropertyReferenceExpression.Property { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.Instance { get; }
    private ISymbol Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.Member { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundExpression ReceiverOpt { get; }
    public PropertySymbol PropertySymbol { get; }
    public LookupResultKind ResultKind { get; }
    public BoundPropertyAccess(CSharpSyntaxNode syntax, BoundExpression receiverOpt, PropertySymbol propertySymbol, LookupResultKind resultKind, TypeSymbol type, bool hasErrors);
    public virtual Symbol get_ExpressionSymbol();
    private sealed virtual override IPropertySymbol Microsoft.CodeAnalysis.Semantics.IPropertyReferenceExpression.get_Property();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.get_Instance();
    private sealed virtual override ISymbol Microsoft.CodeAnalysis.Semantics.IMemberReferenceExpression.get_Member();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_ReceiverOpt();
    [CompilerGeneratedAttribute]
public PropertySymbol get_PropertySymbol();
    public virtual LookupResultKind get_ResultKind();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundPropertyAccess Update(BoundExpression receiverOpt, PropertySymbol propertySymbol, LookupResultKind resultKind, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundPropertyEqualsValue : BoundEqualsValue {
    [CompilerGeneratedAttribute]
private PropertySymbol <Property>k__BackingField;
    private IPropertySymbol Microsoft.CodeAnalysis.Semantics.IPropertyInitializer.InitializedProperty { get; }
    protected OperationKind OperationKind { get; }
    public PropertySymbol Property { get; }
    public BoundPropertyEqualsValue(CSharpSyntaxNode syntax, PropertySymbol property, BoundExpression value, bool hasErrors);
    private sealed virtual override IPropertySymbol Microsoft.CodeAnalysis.Semantics.IPropertyInitializer.get_InitializedProperty();
    protected virtual OperationKind get_OperationKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public PropertySymbol get_Property();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundPropertyEqualsValue Update(PropertySymbol property, BoundExpression value);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundPropertyGroup : BoundMethodOrPropertyGroup {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<PropertySymbol> <Properties>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public object Display { get; }
    public ImmutableArray`1<PropertySymbol> Properties { get; }
    public BoundPropertyGroup(CSharpSyntaxNode syntax, ImmutableArray`1<PropertySymbol> properties, BoundExpression receiverOpt, LookupResultKind resultKind, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual object get_Display();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<PropertySymbol> get_Properties();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundPropertyGroup Update(ImmutableArray`1<PropertySymbol> properties, BoundExpression receiverOpt, LookupResultKind resultKind);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundPseudoVariable : BoundExpression {
    [CompilerGeneratedAttribute]
private LocalSymbol <LocalSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private PseudoVariableExpressions <EmitExpressions>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public LocalSymbol LocalSymbol { get; }
    public PseudoVariableExpressions EmitExpressions { get; }
    public BoundPseudoVariable(CSharpSyntaxNode syntax, LocalSymbol localSymbol, PseudoVariableExpressions emitExpressions, TypeSymbol type, bool hasErrors);
    public BoundPseudoVariable(CSharpSyntaxNode syntax, LocalSymbol localSymbol, PseudoVariableExpressions emitExpressions, TypeSymbol type);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public LocalSymbol get_LocalSymbol();
    [CompilerGeneratedAttribute]
public PseudoVariableExpressions get_EmitExpressions();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundPseudoVariable Update(LocalSymbol localSymbol, PseudoVariableExpressions emitExpressions, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundQueryClause : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Cast>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <UnoptimizedForm>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private RangeVariableSymbol <DefinedSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private Binder <Binder>k__BackingField;
    public BoundExpression Operation { get; }
    public BoundExpression Cast { get; }
    public BoundExpression UnoptimizedForm { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Value { get; }
    public RangeVariableSymbol DefinedSymbol { get; }
    public Binder Binder { get; }
    public BoundQueryClause(CSharpSyntaxNode syntax, BoundExpression value, RangeVariableSymbol definedSymbol, BoundExpression queryInvocation, BoundExpression castInvocation, Binder binder, BoundExpression unoptimizedForm, TypeSymbol type, bool hasErrors);
    public BoundQueryClause(CSharpSyntaxNode syntax, BoundExpression value, RangeVariableSymbol definedSymbol, Binder binder, TypeSymbol type, bool hasErrors);
    [CompilerGeneratedAttribute]
public BoundExpression get_Operation();
    [CompilerGeneratedAttribute]
public BoundExpression get_Cast();
    [CompilerGeneratedAttribute]
public BoundExpression get_UnoptimizedForm();
    public BoundQueryClause Update(BoundExpression value, RangeVariableSymbol definedSymbol, BoundExpression queryInvocation, BoundExpression castInvocation, Binder binder, BoundExpression unoptimizedForm, TypeSymbol type);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Value();
    [CompilerGeneratedAttribute]
public RangeVariableSymbol get_DefinedSymbol();
    [CompilerGeneratedAttribute]
public Binder get_Binder();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundQueryClause Update(BoundExpression value, RangeVariableSymbol definedSymbol, Binder binder, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundRangeVariable : BoundExpression {
    [CompilerGeneratedAttribute]
private RangeVariableSymbol <RangeVariableSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Value>k__BackingField;
    public Symbol ExpressionSymbol { get; }
    protected OperationKind ExpressionKind { get; }
    public RangeVariableSymbol RangeVariableSymbol { get; }
    public BoundExpression Value { get; }
    public BoundRangeVariable(CSharpSyntaxNode syntax, RangeVariableSymbol rangeVariableSymbol, BoundExpression value, TypeSymbol type, bool hasErrors);
    public virtual Symbol get_ExpressionSymbol();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public RangeVariableSymbol get_RangeVariableSymbol();
    [CompilerGeneratedAttribute]
public BoundExpression get_Value();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundRangeVariable Update(RangeVariableSymbol rangeVariableSymbol, BoundExpression value, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundRefTypeOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Operand>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSymbol <GetTypeFromHandle>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Operand { get; }
    public MethodSymbol GetTypeFromHandle { get; }
    public BoundRefTypeOperator(CSharpSyntaxNode syntax, BoundExpression operand, MethodSymbol getTypeFromHandle, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Operand();
    [CompilerGeneratedAttribute]
public MethodSymbol get_GetTypeFromHandle();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundRefTypeOperator Update(BoundExpression operand, MethodSymbol getTypeFromHandle, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundRefValueOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Operand>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Operand { get; }
    public BoundRefValueOperator(CSharpSyntaxNode syntax, BoundExpression operand, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Operand();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundRefValueOperator Update(BoundExpression operand, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundReturnStatement : BoundStatement {
    [CompilerGeneratedAttribute]
private BoundExpression <ExpressionOpt>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.IReturnStatement.ReturnedValue { get; }
    protected OperationKind StatementKind { get; }
    public BoundExpression ExpressionOpt { get; }
    public BoundReturnStatement(CSharpSyntaxNode syntax, BoundExpression expressionOpt, bool hasErrors);
    public static BoundReturnStatement Synthesized(CSharpSyntaxNode syntax, BoundExpression expression, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IReturnStatement.get_ReturnedValue();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_ExpressionOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundReturnStatement Update(BoundExpression expressionOpt);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundSequence : BoundExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<LocalSymbol> <Locals>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundExpression> <SideEffects>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Value>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public ImmutableArray`1<LocalSymbol> Locals { get; }
    public ImmutableArray`1<BoundExpression> SideEffects { get; }
    public BoundExpression Value { get; }
    public BoundSequence(CSharpSyntaxNode syntax, ImmutableArray`1<LocalSymbol> locals, ImmutableArray`1<BoundExpression> sideEffects, BoundExpression value, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<LocalSymbol> get_Locals();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundExpression> get_SideEffects();
    [CompilerGeneratedAttribute]
public BoundExpression get_Value();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundSequence Update(ImmutableArray`1<LocalSymbol> locals, ImmutableArray`1<BoundExpression> sideEffects, BoundExpression value, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundSequencePoint : BoundStatement {
    [CompilerGeneratedAttribute]
private BoundStatement <StatementOpt>k__BackingField;
    protected OperationKind StatementKind { get; }
    public BoundStatement StatementOpt { get; }
    public BoundSequencePoint(CSharpSyntaxNode syntax, BoundStatement statementOpt, bool hasErrors);
    public static BoundStatement Create(CSharpSyntaxNode syntax, Nullable`1<TextSpan> part, BoundStatement statement, bool hasErrors);
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundStatement get_StatementOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundSequencePoint Update(BoundStatement statementOpt);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundSequencePointExpression : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Expression>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Expression { get; }
    public BoundSequencePointExpression(CSharpSyntaxNode syntax, BoundExpression expression, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Expression();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundSequencePointExpression Update(BoundExpression expression, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundSequencePointWithSpan : BoundStatement {
    [CompilerGeneratedAttribute]
private BoundStatement <StatementOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    protected OperationKind StatementKind { get; }
    public BoundStatement StatementOpt { get; }
    public TextSpan Span { get; }
    public BoundSequencePointWithSpan(CSharpSyntaxNode syntax, BoundStatement statementOpt, TextSpan span, bool hasErrors);
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundStatement get_StatementOpt();
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundSequencePointWithSpan Update(BoundStatement statementOpt, TextSpan span);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundSizeOfOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundTypeExpression <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstantValue <ConstantValueOpt>k__BackingField;
    public ConstantValue ConstantValue { get; }
    private ITypeSymbol Microsoft.CodeAnalysis.Semantics.ITypeOperationExpression.TypeOperand { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundTypeExpression SourceType { get; }
    public ConstantValue ConstantValueOpt { get; }
    public BoundSizeOfOperator(CSharpSyntaxNode syntax, BoundTypeExpression sourceType, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors);
    public virtual ConstantValue get_ConstantValue();
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.Semantics.ITypeOperationExpression.get_TypeOperand();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundTypeExpression get_SourceType();
    [CompilerGeneratedAttribute]
public ConstantValue get_ConstantValueOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundSizeOfOperator Update(BoundTypeExpression sourceType, ConstantValue constantValueOpt, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundStackAllocArrayCreation : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Count>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Count { get; }
    public BoundStackAllocArrayCreation(CSharpSyntaxNode syntax, BoundExpression count, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Count();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundStackAllocArrayCreation Update(BoundExpression count, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundStateMachineScope : BoundStatement {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<StateMachineFieldSymbol> <Fields>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundStatement <Statement>k__BackingField;
    protected OperationKind StatementKind { get; }
    public ImmutableArray`1<StateMachineFieldSymbol> Fields { get; }
    public BoundStatement Statement { get; }
    public BoundStateMachineScope(CSharpSyntaxNode syntax, ImmutableArray`1<StateMachineFieldSymbol> fields, BoundStatement statement, bool hasErrors);
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<StateMachineFieldSymbol> get_Fields();
    [CompilerGeneratedAttribute]
public BoundStatement get_Statement();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundStateMachineScope Update(ImmutableArray`1<StateMachineFieldSymbol> fields, BoundStatement statement);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.BoundStatement : BoundNode {
    private OperationKind Microsoft.CodeAnalysis.IOperation.Kind { get; }
    private bool Microsoft.CodeAnalysis.IOperation.IsInvalid { get; }
    private SyntaxNode Microsoft.CodeAnalysis.IOperation.Syntax { get; }
    private ITypeSymbol Microsoft.CodeAnalysis.IOperation.Type { get; }
    private Optional`1<object> Microsoft.CodeAnalysis.IOperation.ConstantValue { get; }
    protected OperationKind StatementKind { get; }
    protected BoundStatement(BoundKind kind, CSharpSyntaxNode syntax, bool hasErrors);
    protected BoundStatement(BoundKind kind, CSharpSyntaxNode syntax);
    private sealed virtual override OperationKind Microsoft.CodeAnalysis.IOperation.get_Kind();
    private sealed virtual override bool Microsoft.CodeAnalysis.IOperation.get_IsInvalid();
    private sealed virtual override SyntaxNode Microsoft.CodeAnalysis.IOperation.get_Syntax();
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.IOperation.get_Type();
    private sealed virtual override Optional`1<object> Microsoft.CodeAnalysis.IOperation.get_ConstantValue();
    protected abstract virtual OperationKind get_StatementKind();
    public abstract virtual void Accept(OperationVisitor visitor);
    public abstract virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.BoundStatementExtensions : object {
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
internal static void AssertIsLabeledStatement(BoundStatement node);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
internal static void AssertIsLabeledStatementWithLabel(BoundStatement node, LabelSymbol label);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundStatementList : BoundStatement {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundStatement> <Statements>k__BackingField;
    protected OperationKind StatementKind { get; }
    public ImmutableArray`1<BoundStatement> Statements { get; }
    protected BoundStatementList(BoundKind kind, CSharpSyntaxNode syntax, ImmutableArray`1<BoundStatement> statements, bool hasErrors);
    public BoundStatementList(CSharpSyntaxNode syntax, ImmutableArray`1<BoundStatement> statements, bool hasErrors);
    public static BoundStatementList Synthesized(CSharpSyntaxNode syntax, BoundStatement[] statements);
    public static BoundStatementList Synthesized(CSharpSyntaxNode syntax, bool hasErrors, BoundStatement[] statements);
    public static BoundStatementList Synthesized(CSharpSyntaxNode syntax, ImmutableArray`1<BoundStatement> statements);
    public static BoundStatementList Synthesized(CSharpSyntaxNode syntax, bool hasErrors, ImmutableArray`1<BoundStatement> statements);
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundStatement> get_Statements();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundStatementList Update(ImmutableArray`1<BoundStatement> statements);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundStringInsert : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundExpression <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Alignment>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Format>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public BoundExpression Value { get; }
    public BoundExpression Alignment { get; }
    public BoundExpression Format { get; }
    public BoundStringInsert(CSharpSyntaxNode syntax, BoundExpression value, BoundExpression alignment, BoundExpression format, TypeSymbol type, bool hasErrors);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Value();
    [CompilerGeneratedAttribute]
public BoundExpression get_Alignment();
    [CompilerGeneratedAttribute]
public BoundExpression get_Format();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundStringInsert Update(BoundExpression value, BoundExpression alignment, BoundExpression format, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundSwitchLabel : BoundNode {
    [CompilerGeneratedAttribute]
private LabelSymbol <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <ExpressionOpt>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.ISingleValueCaseClause.Value { get; }
    private BinaryOperationKind Microsoft.CodeAnalysis.Semantics.ISingleValueCaseClause.Equality { get; }
    private CaseKind Microsoft.CodeAnalysis.Semantics.ICaseClause.CaseKind { get; }
    private OperationKind Microsoft.CodeAnalysis.IOperation.Kind { get; }
    private bool Microsoft.CodeAnalysis.IOperation.IsInvalid { get; }
    private SyntaxNode Microsoft.CodeAnalysis.IOperation.Syntax { get; }
    private ITypeSymbol Microsoft.CodeAnalysis.IOperation.Type { get; }
    private Optional`1<object> Microsoft.CodeAnalysis.IOperation.ConstantValue { get; }
    public LabelSymbol Label { get; }
    public BoundExpression ExpressionOpt { get; }
    public BoundSwitchLabel(CSharpSyntaxNode syntax, LabelSymbol label, bool hasErrors);
    public BoundSwitchLabel(CSharpSyntaxNode syntax, LabelSymbol label, BoundExpression expressionOpt, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.ISingleValueCaseClause.get_Value();
    private sealed virtual override BinaryOperationKind Microsoft.CodeAnalysis.Semantics.ISingleValueCaseClause.get_Equality();
    private sealed virtual override CaseKind Microsoft.CodeAnalysis.Semantics.ICaseClause.get_CaseKind();
    private sealed virtual override OperationKind Microsoft.CodeAnalysis.IOperation.get_Kind();
    private sealed virtual override bool Microsoft.CodeAnalysis.IOperation.get_IsInvalid();
    private sealed virtual override SyntaxNode Microsoft.CodeAnalysis.IOperation.get_Syntax();
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.IOperation.get_Type();
    private sealed virtual override Optional`1<object> Microsoft.CodeAnalysis.IOperation.get_ConstantValue();
    private sealed virtual override void Microsoft.CodeAnalysis.IOperation.Accept(OperationVisitor visitor);
    private sealed virtual override TResult Microsoft.CodeAnalysis.IOperation.Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public LabelSymbol get_Label();
    [CompilerGeneratedAttribute]
public BoundExpression get_ExpressionOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundSwitchLabel Update(LabelSymbol label, BoundExpression expressionOpt);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundSwitchSection : BoundStatementList {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundSwitchLabel> <BoundSwitchLabels>k__BackingField;
    protected OperationKind StatementKind { get; }
    public ImmutableArray`1<BoundSwitchLabel> BoundSwitchLabels { get; }
    public BoundSwitchSection(CSharpSyntaxNode syntax, ImmutableArray`1<BoundSwitchLabel> boundSwitchLabels, ImmutableArray`1<BoundStatement> statements, bool hasErrors);
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundSwitchLabel> get_BoundSwitchLabels();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundSwitchSection Update(ImmutableArray`1<BoundSwitchLabel> boundSwitchLabels, ImmutableArray`1<BoundStatement> statements);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundSwitchStatement : BoundStatement {
    private static ConditionalWeakTable`2<BoundSwitchStatement, object> s_switchSectionsMappings;
    [CompilerGeneratedAttribute]
private BoundStatement <LoweredPreambleOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <BoundExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private LabelSymbol <ConstantTargetOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<LocalSymbol> <InnerLocals>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundSwitchSection> <SwitchSections>k__BackingField;
    [CompilerGeneratedAttribute]
private GeneratedLabelSymbol <BreakLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSymbol <StringEquality>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.ISwitchStatement.Value { get; }
    private ImmutableArray`1<ISwitchCase> Microsoft.CodeAnalysis.Semantics.ISwitchStatement.Cases { get; }
    protected OperationKind StatementKind { get; }
    public BoundStatement LoweredPreambleOpt { get; }
    public BoundExpression BoundExpression { get; }
    public LabelSymbol ConstantTargetOpt { get; }
    public ImmutableArray`1<LocalSymbol> InnerLocals { get; }
    public ImmutableArray`1<BoundSwitchSection> SwitchSections { get; }
    public GeneratedLabelSymbol BreakLabel { get; }
    public MethodSymbol StringEquality { get; }
    public BoundSwitchStatement(CSharpSyntaxNode syntax, BoundStatement loweredPreambleOpt, BoundExpression boundExpression, LabelSymbol constantTargetOpt, ImmutableArray`1<LocalSymbol> innerLocals, ImmutableArray`1<BoundSwitchSection> switchSections, GeneratedLabelSymbol breakLabel, MethodSymbol stringEquality, bool hasErrors);
    private static BoundSwitchStatement();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.ISwitchStatement.get_Value();
    private sealed virtual override ImmutableArray`1<ISwitchCase> Microsoft.CodeAnalysis.Semantics.ISwitchStatement.get_Cases();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundStatement get_LoweredPreambleOpt();
    [CompilerGeneratedAttribute]
public BoundExpression get_BoundExpression();
    [CompilerGeneratedAttribute]
public LabelSymbol get_ConstantTargetOpt();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<LocalSymbol> get_InnerLocals();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundSwitchSection> get_SwitchSections();
    [CompilerGeneratedAttribute]
public GeneratedLabelSymbol get_BreakLabel();
    [CompilerGeneratedAttribute]
public MethodSymbol get_StringEquality();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundSwitchStatement Update(BoundStatement loweredPreambleOpt, BoundExpression boundExpression, LabelSymbol constantTargetOpt, ImmutableArray`1<LocalSymbol> innerLocals, ImmutableArray`1<BoundSwitchSection> switchSections, GeneratedLabelSymbol breakLabel, MethodSymbol stringEquality);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundThisReference : BoundExpression {
    private InstanceReferenceKind Microsoft.CodeAnalysis.Semantics.IInstanceReferenceExpression.InstanceReferenceKind { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundThisReference(CSharpSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    public BoundThisReference(CSharpSyntaxNode syntax, TypeSymbol type);
    private sealed virtual override InstanceReferenceKind Microsoft.CodeAnalysis.Semantics.IInstanceReferenceExpression.get_InstanceReferenceKind();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundThisReference Update(TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundThrowStatement : BoundStatement {
    [CompilerGeneratedAttribute]
private BoundExpression <ExpressionOpt>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.IThrowStatement.ThrownObject { get; }
    protected OperationKind StatementKind { get; }
    public BoundExpression ExpressionOpt { get; }
    public BoundThrowStatement(CSharpSyntaxNode syntax, BoundExpression expressionOpt, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IThrowStatement.get_ThrownObject();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_ExpressionOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundThrowStatement Update(BoundExpression expressionOpt);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundTreeDumperNodeProducer : BoundTreeVisitor`2<object, TreeDumperNode> {
    public static TreeDumperNode MakeTree(BoundNode node);
    public virtual TreeDumperNode VisitFieldInitializer(BoundFieldInitializer node, object arg);
    public virtual TreeDumperNode VisitFieldEqualsValue(BoundFieldEqualsValue node, object arg);
    public virtual TreeDumperNode VisitPropertyEqualsValue(BoundPropertyEqualsValue node, object arg);
    public virtual TreeDumperNode VisitParameterEqualsValue(BoundParameterEqualsValue node, object arg);
    public virtual TreeDumperNode VisitGlobalStatementInitializer(BoundGlobalStatementInitializer node, object arg);
    public virtual TreeDumperNode VisitDup(BoundDup node, object arg);
    public virtual TreeDumperNode VisitBadExpression(BoundBadExpression node, object arg);
    public virtual TreeDumperNode VisitBadStatement(BoundBadStatement node, object arg);
    public virtual TreeDumperNode VisitTypeExpression(BoundTypeExpression node, object arg);
    public virtual TreeDumperNode VisitTypeOrValueExpression(BoundTypeOrValueExpression node, object arg);
    public virtual TreeDumperNode VisitNamespaceExpression(BoundNamespaceExpression node, object arg);
    public virtual TreeDumperNode VisitUnaryOperator(BoundUnaryOperator node, object arg);
    public virtual TreeDumperNode VisitIncrementOperator(BoundIncrementOperator node, object arg);
    public virtual TreeDumperNode VisitAddressOfOperator(BoundAddressOfOperator node, object arg);
    public virtual TreeDumperNode VisitPointerIndirectionOperator(BoundPointerIndirectionOperator node, object arg);
    public virtual TreeDumperNode VisitPointerElementAccess(BoundPointerElementAccess node, object arg);
    public virtual TreeDumperNode VisitRefTypeOperator(BoundRefTypeOperator node, object arg);
    public virtual TreeDumperNode VisitMakeRefOperator(BoundMakeRefOperator node, object arg);
    public virtual TreeDumperNode VisitRefValueOperator(BoundRefValueOperator node, object arg);
    public virtual TreeDumperNode VisitBinaryOperator(BoundBinaryOperator node, object arg);
    public virtual TreeDumperNode VisitUserDefinedConditionalLogicalOperator(BoundUserDefinedConditionalLogicalOperator node, object arg);
    public virtual TreeDumperNode VisitCompoundAssignmentOperator(BoundCompoundAssignmentOperator node, object arg);
    public virtual TreeDumperNode VisitAssignmentOperator(BoundAssignmentOperator node, object arg);
    public virtual TreeDumperNode VisitNullCoalescingOperator(BoundNullCoalescingOperator node, object arg);
    public virtual TreeDumperNode VisitConditionalOperator(BoundConditionalOperator node, object arg);
    public virtual TreeDumperNode VisitArrayAccess(BoundArrayAccess node, object arg);
    public virtual TreeDumperNode VisitArrayLength(BoundArrayLength node, object arg);
    public virtual TreeDumperNode VisitAwaitExpression(BoundAwaitExpression node, object arg);
    public virtual TreeDumperNode VisitTypeOfOperator(BoundTypeOfOperator node, object arg);
    public virtual TreeDumperNode VisitMethodInfo(BoundMethodInfo node, object arg);
    public virtual TreeDumperNode VisitFieldInfo(BoundFieldInfo node, object arg);
    public virtual TreeDumperNode VisitDefaultOperator(BoundDefaultOperator node, object arg);
    public virtual TreeDumperNode VisitIsOperator(BoundIsOperator node, object arg);
    public virtual TreeDumperNode VisitAsOperator(BoundAsOperator node, object arg);
    public virtual TreeDumperNode VisitSizeOfOperator(BoundSizeOfOperator node, object arg);
    public virtual TreeDumperNode VisitConversion(BoundConversion node, object arg);
    public virtual TreeDumperNode VisitArgList(BoundArgList node, object arg);
    public virtual TreeDumperNode VisitArgListOperator(BoundArgListOperator node, object arg);
    public virtual TreeDumperNode VisitFixedLocalCollectionInitializer(BoundFixedLocalCollectionInitializer node, object arg);
    public virtual TreeDumperNode VisitSequencePoint(BoundSequencePoint node, object arg);
    public virtual TreeDumperNode VisitSequencePointExpression(BoundSequencePointExpression node, object arg);
    public virtual TreeDumperNode VisitSequencePointWithSpan(BoundSequencePointWithSpan node, object arg);
    public virtual TreeDumperNode VisitBlock(BoundBlock node, object arg);
    public virtual TreeDumperNode VisitStateMachineScope(BoundStateMachineScope node, object arg);
    public virtual TreeDumperNode VisitLocalDeclaration(BoundLocalDeclaration node, object arg);
    public virtual TreeDumperNode VisitMultipleLocalDeclarations(BoundMultipleLocalDeclarations node, object arg);
    public virtual TreeDumperNode VisitSequence(BoundSequence node, object arg);
    public virtual TreeDumperNode VisitNoOpStatement(BoundNoOpStatement node, object arg);
    public virtual TreeDumperNode VisitReturnStatement(BoundReturnStatement node, object arg);
    public virtual TreeDumperNode VisitYieldReturnStatement(BoundYieldReturnStatement node, object arg);
    public virtual TreeDumperNode VisitYieldBreakStatement(BoundYieldBreakStatement node, object arg);
    public virtual TreeDumperNode VisitThrowStatement(BoundThrowStatement node, object arg);
    public virtual TreeDumperNode VisitExpressionStatement(BoundExpressionStatement node, object arg);
    public virtual TreeDumperNode VisitSwitchStatement(BoundSwitchStatement node, object arg);
    public virtual TreeDumperNode VisitSwitchSection(BoundSwitchSection node, object arg);
    public virtual TreeDumperNode VisitSwitchLabel(BoundSwitchLabel node, object arg);
    public virtual TreeDumperNode VisitBreakStatement(BoundBreakStatement node, object arg);
    public virtual TreeDumperNode VisitContinueStatement(BoundContinueStatement node, object arg);
    public virtual TreeDumperNode VisitIfStatement(BoundIfStatement node, object arg);
    public virtual TreeDumperNode VisitDoStatement(BoundDoStatement node, object arg);
    public virtual TreeDumperNode VisitWhileStatement(BoundWhileStatement node, object arg);
    public virtual TreeDumperNode VisitForStatement(BoundForStatement node, object arg);
    public virtual TreeDumperNode VisitForEachStatement(BoundForEachStatement node, object arg);
    public virtual TreeDumperNode VisitUsingStatement(BoundUsingStatement node, object arg);
    public virtual TreeDumperNode VisitFixedStatement(BoundFixedStatement node, object arg);
    public virtual TreeDumperNode VisitLockStatement(BoundLockStatement node, object arg);
    public virtual TreeDumperNode VisitTryStatement(BoundTryStatement node, object arg);
    public virtual TreeDumperNode VisitCatchBlock(BoundCatchBlock node, object arg);
    public virtual TreeDumperNode VisitLiteral(BoundLiteral node, object arg);
    public virtual TreeDumperNode VisitThisReference(BoundThisReference node, object arg);
    public virtual TreeDumperNode VisitPreviousSubmissionReference(BoundPreviousSubmissionReference node, object arg);
    public virtual TreeDumperNode VisitHostObjectMemberReference(BoundHostObjectMemberReference node, object arg);
    public virtual TreeDumperNode VisitBaseReference(BoundBaseReference node, object arg);
    public virtual TreeDumperNode VisitLocal(BoundLocal node, object arg);
    public virtual TreeDumperNode VisitPseudoVariable(BoundPseudoVariable node, object arg);
    public virtual TreeDumperNode VisitRangeVariable(BoundRangeVariable node, object arg);
    public virtual TreeDumperNode VisitParameter(BoundParameter node, object arg);
    public virtual TreeDumperNode VisitLabelStatement(BoundLabelStatement node, object arg);
    public virtual TreeDumperNode VisitGotoStatement(BoundGotoStatement node, object arg);
    public virtual TreeDumperNode VisitLabeledStatement(BoundLabeledStatement node, object arg);
    public virtual TreeDumperNode VisitLabel(BoundLabel node, object arg);
    public virtual TreeDumperNode VisitStatementList(BoundStatementList node, object arg);
    public virtual TreeDumperNode VisitConditionalGoto(BoundConditionalGoto node, object arg);
    public virtual TreeDumperNode VisitDynamicMemberAccess(BoundDynamicMemberAccess node, object arg);
    public virtual TreeDumperNode VisitDynamicInvocation(BoundDynamicInvocation node, object arg);
    public virtual TreeDumperNode VisitConditionalAccess(BoundConditionalAccess node, object arg);
    public virtual TreeDumperNode VisitLoweredConditionalAccess(BoundLoweredConditionalAccess node, object arg);
    public virtual TreeDumperNode VisitConditionalReceiver(BoundConditionalReceiver node, object arg);
    public virtual TreeDumperNode VisitComplexConditionalReceiver(BoundComplexConditionalReceiver node, object arg);
    public virtual TreeDumperNode VisitMethodGroup(BoundMethodGroup node, object arg);
    public virtual TreeDumperNode VisitPropertyGroup(BoundPropertyGroup node, object arg);
    public virtual TreeDumperNode VisitCall(BoundCall node, object arg);
    public virtual TreeDumperNode VisitEventAssignmentOperator(BoundEventAssignmentOperator node, object arg);
    public virtual TreeDumperNode VisitAttribute(BoundAttribute node, object arg);
    public virtual TreeDumperNode VisitObjectCreationExpression(BoundObjectCreationExpression node, object arg);
    public virtual TreeDumperNode VisitDynamicObjectCreationExpression(BoundDynamicObjectCreationExpression node, object arg);
    public virtual TreeDumperNode VisitNoPiaObjectCreationExpression(BoundNoPiaObjectCreationExpression node, object arg);
    public virtual TreeDumperNode VisitObjectInitializerExpression(BoundObjectInitializerExpression node, object arg);
    public virtual TreeDumperNode VisitObjectInitializerMember(BoundObjectInitializerMember node, object arg);
    public virtual TreeDumperNode VisitDynamicObjectInitializerMember(BoundDynamicObjectInitializerMember node, object arg);
    public virtual TreeDumperNode VisitCollectionInitializerExpression(BoundCollectionInitializerExpression node, object arg);
    public virtual TreeDumperNode VisitCollectionElementInitializer(BoundCollectionElementInitializer node, object arg);
    public virtual TreeDumperNode VisitDynamicCollectionElementInitializer(BoundDynamicCollectionElementInitializer node, object arg);
    public virtual TreeDumperNode VisitImplicitReceiver(BoundImplicitReceiver node, object arg);
    public virtual TreeDumperNode VisitAnonymousObjectCreationExpression(BoundAnonymousObjectCreationExpression node, object arg);
    public virtual TreeDumperNode VisitAnonymousPropertyDeclaration(BoundAnonymousPropertyDeclaration node, object arg);
    public virtual TreeDumperNode VisitNewT(BoundNewT node, object arg);
    public virtual TreeDumperNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node, object arg);
    public virtual TreeDumperNode VisitArrayCreation(BoundArrayCreation node, object arg);
    public virtual TreeDumperNode VisitArrayInitialization(BoundArrayInitialization node, object arg);
    public virtual TreeDumperNode VisitStackAllocArrayCreation(BoundStackAllocArrayCreation node, object arg);
    public virtual TreeDumperNode VisitFieldAccess(BoundFieldAccess node, object arg);
    public virtual TreeDumperNode VisitHoistedFieldAccess(BoundHoistedFieldAccess node, object arg);
    public virtual TreeDumperNode VisitPropertyAccess(BoundPropertyAccess node, object arg);
    public virtual TreeDumperNode VisitEventAccess(BoundEventAccess node, object arg);
    public virtual TreeDumperNode VisitIndexerAccess(BoundIndexerAccess node, object arg);
    public virtual TreeDumperNode VisitDynamicIndexerAccess(BoundDynamicIndexerAccess node, object arg);
    public virtual TreeDumperNode VisitLambda(BoundLambda node, object arg);
    public virtual TreeDumperNode VisitUnboundLambda(UnboundLambda node, object arg);
    public virtual TreeDumperNode VisitQueryClause(BoundQueryClause node, object arg);
    public virtual TreeDumperNode VisitTypeOrInstanceInitializers(BoundTypeOrInstanceInitializers node, object arg);
    public virtual TreeDumperNode VisitNameOfOperator(BoundNameOfOperator node, object arg);
    public virtual TreeDumperNode VisitInterpolatedString(BoundInterpolatedString node, object arg);
    public virtual TreeDumperNode VisitStringInsert(BoundStringInsert node, object arg);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitBadExpression>b__8_0(BoundNode x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitBadStatement>b__9_0(BoundNode x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitArrayAccess>b__27_0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitArgListOperator>b__39_0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitBlock>b__44_0(BoundStatement x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitLocalDeclaration>b__46_0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitMultipleLocalDeclarations>b__47_0(BoundLocalDeclaration x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitSequence>b__48_0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitSwitchStatement>b__55_0(BoundSwitchSection x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitSwitchSection>b__56_0(BoundSwitchLabel x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitSwitchSection>b__56_1(BoundStatement x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitTryStatement>b__68_0(BoundCatchBlock x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitStatementList>b__83_0(BoundStatement x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitDynamicInvocation>b__86_0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitCall>b__93_0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitAttribute>b__95_0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitAttribute>b__95_1(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitObjectCreationExpression>b__96_0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitDynamicObjectCreationExpression>b__97_0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitObjectInitializerExpression>b__99_0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitObjectInitializerMember>b__100_0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitCollectionInitializerExpression>b__102_0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitCollectionElementInitializer>b__103_0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitDynamicCollectionElementInitializer>b__104_0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitAnonymousObjectCreationExpression>b__106_0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitAnonymousObjectCreationExpression>b__106_1(BoundAnonymousPropertyDeclaration x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitArrayCreation>b__110_0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitArrayInitialization>b__111_0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitIndexerAccess>b__117_0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitDynamicIndexerAccess>b__118_0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitTypeOrInstanceInitializers>b__122_0(BoundStatement x);
    [CompilerGeneratedAttribute]
private TreeDumperNode <VisitInterpolatedString>b__124_0(BoundExpression x);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.BoundTreeRewriter : BoundTreeVisitor {
    public virtual TypeSymbol VisitType(TypeSymbol type);
    public ImmutableArray`1<T> VisitList(ImmutableArray`1<T> list);
    private ImmutableArray`1<T> DoVisitList(ImmutableArray`1<T> list);
    public virtual BoundNode VisitFieldInitializer(BoundFieldInitializer node);
    public virtual BoundNode VisitFieldEqualsValue(BoundFieldEqualsValue node);
    public virtual BoundNode VisitPropertyEqualsValue(BoundPropertyEqualsValue node);
    public virtual BoundNode VisitParameterEqualsValue(BoundParameterEqualsValue node);
    public virtual BoundNode VisitGlobalStatementInitializer(BoundGlobalStatementInitializer node);
    public virtual BoundNode VisitDup(BoundDup node);
    public virtual BoundNode VisitBadExpression(BoundBadExpression node);
    public virtual BoundNode VisitBadStatement(BoundBadStatement node);
    public virtual BoundNode VisitTypeExpression(BoundTypeExpression node);
    public virtual BoundNode VisitTypeOrValueExpression(BoundTypeOrValueExpression node);
    public virtual BoundNode VisitNamespaceExpression(BoundNamespaceExpression node);
    public virtual BoundNode VisitUnaryOperator(BoundUnaryOperator node);
    public virtual BoundNode VisitIncrementOperator(BoundIncrementOperator node);
    public virtual BoundNode VisitAddressOfOperator(BoundAddressOfOperator node);
    public virtual BoundNode VisitPointerIndirectionOperator(BoundPointerIndirectionOperator node);
    public virtual BoundNode VisitPointerElementAccess(BoundPointerElementAccess node);
    public virtual BoundNode VisitRefTypeOperator(BoundRefTypeOperator node);
    public virtual BoundNode VisitMakeRefOperator(BoundMakeRefOperator node);
    public virtual BoundNode VisitRefValueOperator(BoundRefValueOperator node);
    public virtual BoundNode VisitBinaryOperator(BoundBinaryOperator node);
    public virtual BoundNode VisitUserDefinedConditionalLogicalOperator(BoundUserDefinedConditionalLogicalOperator node);
    public virtual BoundNode VisitCompoundAssignmentOperator(BoundCompoundAssignmentOperator node);
    public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node);
    public virtual BoundNode VisitNullCoalescingOperator(BoundNullCoalescingOperator node);
    public virtual BoundNode VisitConditionalOperator(BoundConditionalOperator node);
    public virtual BoundNode VisitArrayAccess(BoundArrayAccess node);
    public virtual BoundNode VisitArrayLength(BoundArrayLength node);
    public virtual BoundNode VisitAwaitExpression(BoundAwaitExpression node);
    public virtual BoundNode VisitTypeOfOperator(BoundTypeOfOperator node);
    public virtual BoundNode VisitMethodInfo(BoundMethodInfo node);
    public virtual BoundNode VisitFieldInfo(BoundFieldInfo node);
    public virtual BoundNode VisitDefaultOperator(BoundDefaultOperator node);
    public virtual BoundNode VisitIsOperator(BoundIsOperator node);
    public virtual BoundNode VisitAsOperator(BoundAsOperator node);
    public virtual BoundNode VisitSizeOfOperator(BoundSizeOfOperator node);
    public virtual BoundNode VisitConversion(BoundConversion node);
    public virtual BoundNode VisitArgList(BoundArgList node);
    public virtual BoundNode VisitArgListOperator(BoundArgListOperator node);
    public virtual BoundNode VisitFixedLocalCollectionInitializer(BoundFixedLocalCollectionInitializer node);
    public virtual BoundNode VisitSequencePoint(BoundSequencePoint node);
    public virtual BoundNode VisitSequencePointExpression(BoundSequencePointExpression node);
    public virtual BoundNode VisitSequencePointWithSpan(BoundSequencePointWithSpan node);
    public virtual BoundNode VisitBlock(BoundBlock node);
    public virtual BoundNode VisitStateMachineScope(BoundStateMachineScope node);
    public virtual BoundNode VisitLocalDeclaration(BoundLocalDeclaration node);
    public virtual BoundNode VisitMultipleLocalDeclarations(BoundMultipleLocalDeclarations node);
    public virtual BoundNode VisitSequence(BoundSequence node);
    public virtual BoundNode VisitNoOpStatement(BoundNoOpStatement node);
    public virtual BoundNode VisitReturnStatement(BoundReturnStatement node);
    public virtual BoundNode VisitYieldReturnStatement(BoundYieldReturnStatement node);
    public virtual BoundNode VisitYieldBreakStatement(BoundYieldBreakStatement node);
    public virtual BoundNode VisitThrowStatement(BoundThrowStatement node);
    public virtual BoundNode VisitExpressionStatement(BoundExpressionStatement node);
    public virtual BoundNode VisitSwitchStatement(BoundSwitchStatement node);
    public virtual BoundNode VisitSwitchSection(BoundSwitchSection node);
    public virtual BoundNode VisitSwitchLabel(BoundSwitchLabel node);
    public virtual BoundNode VisitBreakStatement(BoundBreakStatement node);
    public virtual BoundNode VisitContinueStatement(BoundContinueStatement node);
    public virtual BoundNode VisitIfStatement(BoundIfStatement node);
    public virtual BoundNode VisitDoStatement(BoundDoStatement node);
    public virtual BoundNode VisitWhileStatement(BoundWhileStatement node);
    public virtual BoundNode VisitForStatement(BoundForStatement node);
    public virtual BoundNode VisitForEachStatement(BoundForEachStatement node);
    public virtual BoundNode VisitUsingStatement(BoundUsingStatement node);
    public virtual BoundNode VisitFixedStatement(BoundFixedStatement node);
    public virtual BoundNode VisitLockStatement(BoundLockStatement node);
    public virtual BoundNode VisitTryStatement(BoundTryStatement node);
    public virtual BoundNode VisitCatchBlock(BoundCatchBlock node);
    public virtual BoundNode VisitLiteral(BoundLiteral node);
    public virtual BoundNode VisitThisReference(BoundThisReference node);
    public virtual BoundNode VisitPreviousSubmissionReference(BoundPreviousSubmissionReference node);
    public virtual BoundNode VisitHostObjectMemberReference(BoundHostObjectMemberReference node);
    public virtual BoundNode VisitBaseReference(BoundBaseReference node);
    public virtual BoundNode VisitLocal(BoundLocal node);
    public virtual BoundNode VisitPseudoVariable(BoundPseudoVariable node);
    public virtual BoundNode VisitRangeVariable(BoundRangeVariable node);
    public virtual BoundNode VisitParameter(BoundParameter node);
    public virtual BoundNode VisitLabelStatement(BoundLabelStatement node);
    public virtual BoundNode VisitGotoStatement(BoundGotoStatement node);
    public virtual BoundNode VisitLabeledStatement(BoundLabeledStatement node);
    public virtual BoundNode VisitLabel(BoundLabel node);
    public virtual BoundNode VisitStatementList(BoundStatementList node);
    public virtual BoundNode VisitConditionalGoto(BoundConditionalGoto node);
    public virtual BoundNode VisitDynamicMemberAccess(BoundDynamicMemberAccess node);
    public virtual BoundNode VisitDynamicInvocation(BoundDynamicInvocation node);
    public virtual BoundNode VisitConditionalAccess(BoundConditionalAccess node);
    public virtual BoundNode VisitLoweredConditionalAccess(BoundLoweredConditionalAccess node);
    public virtual BoundNode VisitConditionalReceiver(BoundConditionalReceiver node);
    public virtual BoundNode VisitComplexConditionalReceiver(BoundComplexConditionalReceiver node);
    public virtual BoundNode VisitMethodGroup(BoundMethodGroup node);
    public virtual BoundNode VisitPropertyGroup(BoundPropertyGroup node);
    public virtual BoundNode VisitCall(BoundCall node);
    public virtual BoundNode VisitEventAssignmentOperator(BoundEventAssignmentOperator node);
    public virtual BoundNode VisitAttribute(BoundAttribute node);
    public virtual BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node);
    public virtual BoundNode VisitDynamicObjectCreationExpression(BoundDynamicObjectCreationExpression node);
    public virtual BoundNode VisitNoPiaObjectCreationExpression(BoundNoPiaObjectCreationExpression node);
    public virtual BoundNode VisitObjectInitializerExpression(BoundObjectInitializerExpression node);
    public virtual BoundNode VisitObjectInitializerMember(BoundObjectInitializerMember node);
    public virtual BoundNode VisitDynamicObjectInitializerMember(BoundDynamicObjectInitializerMember node);
    public virtual BoundNode VisitCollectionInitializerExpression(BoundCollectionInitializerExpression node);
    public virtual BoundNode VisitCollectionElementInitializer(BoundCollectionElementInitializer node);
    public virtual BoundNode VisitDynamicCollectionElementInitializer(BoundDynamicCollectionElementInitializer node);
    public virtual BoundNode VisitImplicitReceiver(BoundImplicitReceiver node);
    public virtual BoundNode VisitAnonymousObjectCreationExpression(BoundAnonymousObjectCreationExpression node);
    public virtual BoundNode VisitAnonymousPropertyDeclaration(BoundAnonymousPropertyDeclaration node);
    public virtual BoundNode VisitNewT(BoundNewT node);
    public virtual BoundNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node);
    public virtual BoundNode VisitArrayCreation(BoundArrayCreation node);
    public virtual BoundNode VisitArrayInitialization(BoundArrayInitialization node);
    public virtual BoundNode VisitStackAllocArrayCreation(BoundStackAllocArrayCreation node);
    public virtual BoundNode VisitFieldAccess(BoundFieldAccess node);
    public virtual BoundNode VisitHoistedFieldAccess(BoundHoistedFieldAccess node);
    public virtual BoundNode VisitPropertyAccess(BoundPropertyAccess node);
    public virtual BoundNode VisitEventAccess(BoundEventAccess node);
    public virtual BoundNode VisitIndexerAccess(BoundIndexerAccess node);
    public virtual BoundNode VisitDynamicIndexerAccess(BoundDynamicIndexerAccess node);
    public virtual BoundNode VisitLambda(BoundLambda node);
    public virtual BoundNode VisitUnboundLambda(UnboundLambda node);
    public virtual BoundNode VisitQueryClause(BoundQueryClause node);
    public virtual BoundNode VisitTypeOrInstanceInitializers(BoundTypeOrInstanceInitializers node);
    public virtual BoundNode VisitNameOfOperator(BoundNameOfOperator node);
    public virtual BoundNode VisitInterpolatedString(BoundInterpolatedString node);
    public virtual BoundNode VisitStringInsert(BoundStringInsert node);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuard : BoundTreeRewriter {
    private int _recursionDepth;
    protected int RecursionDepth { get; }
    protected BoundTreeRewriterWithStackGuard(int recursionDepth);
    protected int get_RecursionDepth();
    public virtual BoundNode Visit(BoundNode node);
    protected BoundExpression VisitExpressionWithStackGuard(BoundExpression node);
    protected sealed virtual BoundExpression VisitExpressionWithoutStackGuard(BoundExpression node);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.BoundTreeRewriterWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator : BoundTreeRewriterWithStackGuard {
    protected BoundTreeRewriterWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator(int recursionDepth);
    public sealed virtual BoundNode VisitBinaryOperator(BoundBinaryOperator node);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor : object {
    [DebuggerHiddenAttribute]
public virtual BoundNode Visit(BoundNode node);
    [DebuggerHiddenAttribute]
public virtual BoundNode DefaultVisit(BoundNode node);
    protected BoundExpression VisitExpressionWithStackGuard(Int32& recursionDepth, BoundExpression node);
    protected virtual bool ConvertInsufficientExecutionStackExceptionToCancelledByStackGuardException();
    private BoundExpression VisitExpressionWithStackGuard(BoundExpression node);
    protected abstract virtual BoundExpression VisitExpressionWithoutStackGuard(BoundExpression node);
    public virtual BoundNode VisitFieldInitializer(BoundFieldInitializer node);
    public virtual BoundNode VisitFieldEqualsValue(BoundFieldEqualsValue node);
    public virtual BoundNode VisitPropertyEqualsValue(BoundPropertyEqualsValue node);
    public virtual BoundNode VisitParameterEqualsValue(BoundParameterEqualsValue node);
    public virtual BoundNode VisitGlobalStatementInitializer(BoundGlobalStatementInitializer node);
    public virtual BoundNode VisitDup(BoundDup node);
    public virtual BoundNode VisitBadExpression(BoundBadExpression node);
    public virtual BoundNode VisitBadStatement(BoundBadStatement node);
    public virtual BoundNode VisitTypeExpression(BoundTypeExpression node);
    public virtual BoundNode VisitTypeOrValueExpression(BoundTypeOrValueExpression node);
    public virtual BoundNode VisitNamespaceExpression(BoundNamespaceExpression node);
    public virtual BoundNode VisitUnaryOperator(BoundUnaryOperator node);
    public virtual BoundNode VisitIncrementOperator(BoundIncrementOperator node);
    public virtual BoundNode VisitAddressOfOperator(BoundAddressOfOperator node);
    public virtual BoundNode VisitPointerIndirectionOperator(BoundPointerIndirectionOperator node);
    public virtual BoundNode VisitPointerElementAccess(BoundPointerElementAccess node);
    public virtual BoundNode VisitRefTypeOperator(BoundRefTypeOperator node);
    public virtual BoundNode VisitMakeRefOperator(BoundMakeRefOperator node);
    public virtual BoundNode VisitRefValueOperator(BoundRefValueOperator node);
    public virtual BoundNode VisitBinaryOperator(BoundBinaryOperator node);
    public virtual BoundNode VisitUserDefinedConditionalLogicalOperator(BoundUserDefinedConditionalLogicalOperator node);
    public virtual BoundNode VisitCompoundAssignmentOperator(BoundCompoundAssignmentOperator node);
    public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node);
    public virtual BoundNode VisitNullCoalescingOperator(BoundNullCoalescingOperator node);
    public virtual BoundNode VisitConditionalOperator(BoundConditionalOperator node);
    public virtual BoundNode VisitArrayAccess(BoundArrayAccess node);
    public virtual BoundNode VisitArrayLength(BoundArrayLength node);
    public virtual BoundNode VisitAwaitExpression(BoundAwaitExpression node);
    public virtual BoundNode VisitTypeOfOperator(BoundTypeOfOperator node);
    public virtual BoundNode VisitMethodInfo(BoundMethodInfo node);
    public virtual BoundNode VisitFieldInfo(BoundFieldInfo node);
    public virtual BoundNode VisitDefaultOperator(BoundDefaultOperator node);
    public virtual BoundNode VisitIsOperator(BoundIsOperator node);
    public virtual BoundNode VisitAsOperator(BoundAsOperator node);
    public virtual BoundNode VisitSizeOfOperator(BoundSizeOfOperator node);
    public virtual BoundNode VisitConversion(BoundConversion node);
    public virtual BoundNode VisitArgList(BoundArgList node);
    public virtual BoundNode VisitArgListOperator(BoundArgListOperator node);
    public virtual BoundNode VisitFixedLocalCollectionInitializer(BoundFixedLocalCollectionInitializer node);
    public virtual BoundNode VisitSequencePoint(BoundSequencePoint node);
    public virtual BoundNode VisitSequencePointExpression(BoundSequencePointExpression node);
    public virtual BoundNode VisitSequencePointWithSpan(BoundSequencePointWithSpan node);
    public virtual BoundNode VisitBlock(BoundBlock node);
    public virtual BoundNode VisitStateMachineScope(BoundStateMachineScope node);
    public virtual BoundNode VisitLocalDeclaration(BoundLocalDeclaration node);
    public virtual BoundNode VisitMultipleLocalDeclarations(BoundMultipleLocalDeclarations node);
    public virtual BoundNode VisitSequence(BoundSequence node);
    public virtual BoundNode VisitNoOpStatement(BoundNoOpStatement node);
    public virtual BoundNode VisitReturnStatement(BoundReturnStatement node);
    public virtual BoundNode VisitYieldReturnStatement(BoundYieldReturnStatement node);
    public virtual BoundNode VisitYieldBreakStatement(BoundYieldBreakStatement node);
    public virtual BoundNode VisitThrowStatement(BoundThrowStatement node);
    public virtual BoundNode VisitExpressionStatement(BoundExpressionStatement node);
    public virtual BoundNode VisitSwitchStatement(BoundSwitchStatement node);
    public virtual BoundNode VisitSwitchSection(BoundSwitchSection node);
    public virtual BoundNode VisitSwitchLabel(BoundSwitchLabel node);
    public virtual BoundNode VisitBreakStatement(BoundBreakStatement node);
    public virtual BoundNode VisitContinueStatement(BoundContinueStatement node);
    public virtual BoundNode VisitIfStatement(BoundIfStatement node);
    public virtual BoundNode VisitDoStatement(BoundDoStatement node);
    public virtual BoundNode VisitWhileStatement(BoundWhileStatement node);
    public virtual BoundNode VisitForStatement(BoundForStatement node);
    public virtual BoundNode VisitForEachStatement(BoundForEachStatement node);
    public virtual BoundNode VisitUsingStatement(BoundUsingStatement node);
    public virtual BoundNode VisitFixedStatement(BoundFixedStatement node);
    public virtual BoundNode VisitLockStatement(BoundLockStatement node);
    public virtual BoundNode VisitTryStatement(BoundTryStatement node);
    public virtual BoundNode VisitCatchBlock(BoundCatchBlock node);
    public virtual BoundNode VisitLiteral(BoundLiteral node);
    public virtual BoundNode VisitThisReference(BoundThisReference node);
    public virtual BoundNode VisitPreviousSubmissionReference(BoundPreviousSubmissionReference node);
    public virtual BoundNode VisitHostObjectMemberReference(BoundHostObjectMemberReference node);
    public virtual BoundNode VisitBaseReference(BoundBaseReference node);
    public virtual BoundNode VisitLocal(BoundLocal node);
    public virtual BoundNode VisitPseudoVariable(BoundPseudoVariable node);
    public virtual BoundNode VisitRangeVariable(BoundRangeVariable node);
    public virtual BoundNode VisitParameter(BoundParameter node);
    public virtual BoundNode VisitLabelStatement(BoundLabelStatement node);
    public virtual BoundNode VisitGotoStatement(BoundGotoStatement node);
    public virtual BoundNode VisitLabeledStatement(BoundLabeledStatement node);
    public virtual BoundNode VisitLabel(BoundLabel node);
    public virtual BoundNode VisitStatementList(BoundStatementList node);
    public virtual BoundNode VisitConditionalGoto(BoundConditionalGoto node);
    public virtual BoundNode VisitDynamicMemberAccess(BoundDynamicMemberAccess node);
    public virtual BoundNode VisitDynamicInvocation(BoundDynamicInvocation node);
    public virtual BoundNode VisitConditionalAccess(BoundConditionalAccess node);
    public virtual BoundNode VisitLoweredConditionalAccess(BoundLoweredConditionalAccess node);
    public virtual BoundNode VisitConditionalReceiver(BoundConditionalReceiver node);
    public virtual BoundNode VisitComplexConditionalReceiver(BoundComplexConditionalReceiver node);
    public virtual BoundNode VisitMethodGroup(BoundMethodGroup node);
    public virtual BoundNode VisitPropertyGroup(BoundPropertyGroup node);
    public virtual BoundNode VisitCall(BoundCall node);
    public virtual BoundNode VisitEventAssignmentOperator(BoundEventAssignmentOperator node);
    public virtual BoundNode VisitAttribute(BoundAttribute node);
    public virtual BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node);
    public virtual BoundNode VisitDynamicObjectCreationExpression(BoundDynamicObjectCreationExpression node);
    public virtual BoundNode VisitNoPiaObjectCreationExpression(BoundNoPiaObjectCreationExpression node);
    public virtual BoundNode VisitObjectInitializerExpression(BoundObjectInitializerExpression node);
    public virtual BoundNode VisitObjectInitializerMember(BoundObjectInitializerMember node);
    public virtual BoundNode VisitDynamicObjectInitializerMember(BoundDynamicObjectInitializerMember node);
    public virtual BoundNode VisitCollectionInitializerExpression(BoundCollectionInitializerExpression node);
    public virtual BoundNode VisitCollectionElementInitializer(BoundCollectionElementInitializer node);
    public virtual BoundNode VisitDynamicCollectionElementInitializer(BoundDynamicCollectionElementInitializer node);
    public virtual BoundNode VisitImplicitReceiver(BoundImplicitReceiver node);
    public virtual BoundNode VisitAnonymousObjectCreationExpression(BoundAnonymousObjectCreationExpression node);
    public virtual BoundNode VisitAnonymousPropertyDeclaration(BoundAnonymousPropertyDeclaration node);
    public virtual BoundNode VisitNewT(BoundNewT node);
    public virtual BoundNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node);
    public virtual BoundNode VisitArrayCreation(BoundArrayCreation node);
    public virtual BoundNode VisitArrayInitialization(BoundArrayInitialization node);
    public virtual BoundNode VisitStackAllocArrayCreation(BoundStackAllocArrayCreation node);
    public virtual BoundNode VisitFieldAccess(BoundFieldAccess node);
    public virtual BoundNode VisitHoistedFieldAccess(BoundHoistedFieldAccess node);
    public virtual BoundNode VisitPropertyAccess(BoundPropertyAccess node);
    public virtual BoundNode VisitEventAccess(BoundEventAccess node);
    public virtual BoundNode VisitIndexerAccess(BoundIndexerAccess node);
    public virtual BoundNode VisitDynamicIndexerAccess(BoundDynamicIndexerAccess node);
    public virtual BoundNode VisitLambda(BoundLambda node);
    public virtual BoundNode VisitUnboundLambda(UnboundLambda node);
    public virtual BoundNode VisitQueryClause(BoundQueryClause node);
    public virtual BoundNode VisitTypeOrInstanceInitializers(BoundTypeOrInstanceInitializers node);
    public virtual BoundNode VisitNameOfOperator(BoundNameOfOperator node);
    public virtual BoundNode VisitInterpolatedString(BoundInterpolatedString node);
    public virtual BoundNode VisitStringInsert(BoundStringInsert node);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.BoundTreeVisitor`2 : object {
    public virtual R Visit(BoundNode node, A arg);
    public virtual R DefaultVisit(BoundNode node, A arg);
    internal R VisitInternal(BoundNode node, A arg);
    public virtual R VisitFieldInitializer(BoundFieldInitializer node, A arg);
    public virtual R VisitFieldEqualsValue(BoundFieldEqualsValue node, A arg);
    public virtual R VisitPropertyEqualsValue(BoundPropertyEqualsValue node, A arg);
    public virtual R VisitParameterEqualsValue(BoundParameterEqualsValue node, A arg);
    public virtual R VisitGlobalStatementInitializer(BoundGlobalStatementInitializer node, A arg);
    public virtual R VisitDup(BoundDup node, A arg);
    public virtual R VisitBadExpression(BoundBadExpression node, A arg);
    public virtual R VisitBadStatement(BoundBadStatement node, A arg);
    public virtual R VisitTypeExpression(BoundTypeExpression node, A arg);
    public virtual R VisitTypeOrValueExpression(BoundTypeOrValueExpression node, A arg);
    public virtual R VisitNamespaceExpression(BoundNamespaceExpression node, A arg);
    public virtual R VisitUnaryOperator(BoundUnaryOperator node, A arg);
    public virtual R VisitIncrementOperator(BoundIncrementOperator node, A arg);
    public virtual R VisitAddressOfOperator(BoundAddressOfOperator node, A arg);
    public virtual R VisitPointerIndirectionOperator(BoundPointerIndirectionOperator node, A arg);
    public virtual R VisitPointerElementAccess(BoundPointerElementAccess node, A arg);
    public virtual R VisitRefTypeOperator(BoundRefTypeOperator node, A arg);
    public virtual R VisitMakeRefOperator(BoundMakeRefOperator node, A arg);
    public virtual R VisitRefValueOperator(BoundRefValueOperator node, A arg);
    public virtual R VisitBinaryOperator(BoundBinaryOperator node, A arg);
    public virtual R VisitUserDefinedConditionalLogicalOperator(BoundUserDefinedConditionalLogicalOperator node, A arg);
    public virtual R VisitCompoundAssignmentOperator(BoundCompoundAssignmentOperator node, A arg);
    public virtual R VisitAssignmentOperator(BoundAssignmentOperator node, A arg);
    public virtual R VisitNullCoalescingOperator(BoundNullCoalescingOperator node, A arg);
    public virtual R VisitConditionalOperator(BoundConditionalOperator node, A arg);
    public virtual R VisitArrayAccess(BoundArrayAccess node, A arg);
    public virtual R VisitArrayLength(BoundArrayLength node, A arg);
    public virtual R VisitAwaitExpression(BoundAwaitExpression node, A arg);
    public virtual R VisitTypeOfOperator(BoundTypeOfOperator node, A arg);
    public virtual R VisitMethodInfo(BoundMethodInfo node, A arg);
    public virtual R VisitFieldInfo(BoundFieldInfo node, A arg);
    public virtual R VisitDefaultOperator(BoundDefaultOperator node, A arg);
    public virtual R VisitIsOperator(BoundIsOperator node, A arg);
    public virtual R VisitAsOperator(BoundAsOperator node, A arg);
    public virtual R VisitSizeOfOperator(BoundSizeOfOperator node, A arg);
    public virtual R VisitConversion(BoundConversion node, A arg);
    public virtual R VisitArgList(BoundArgList node, A arg);
    public virtual R VisitArgListOperator(BoundArgListOperator node, A arg);
    public virtual R VisitFixedLocalCollectionInitializer(BoundFixedLocalCollectionInitializer node, A arg);
    public virtual R VisitSequencePoint(BoundSequencePoint node, A arg);
    public virtual R VisitSequencePointExpression(BoundSequencePointExpression node, A arg);
    public virtual R VisitSequencePointWithSpan(BoundSequencePointWithSpan node, A arg);
    public virtual R VisitBlock(BoundBlock node, A arg);
    public virtual R VisitStateMachineScope(BoundStateMachineScope node, A arg);
    public virtual R VisitLocalDeclaration(BoundLocalDeclaration node, A arg);
    public virtual R VisitMultipleLocalDeclarations(BoundMultipleLocalDeclarations node, A arg);
    public virtual R VisitSequence(BoundSequence node, A arg);
    public virtual R VisitNoOpStatement(BoundNoOpStatement node, A arg);
    public virtual R VisitReturnStatement(BoundReturnStatement node, A arg);
    public virtual R VisitYieldReturnStatement(BoundYieldReturnStatement node, A arg);
    public virtual R VisitYieldBreakStatement(BoundYieldBreakStatement node, A arg);
    public virtual R VisitThrowStatement(BoundThrowStatement node, A arg);
    public virtual R VisitExpressionStatement(BoundExpressionStatement node, A arg);
    public virtual R VisitSwitchStatement(BoundSwitchStatement node, A arg);
    public virtual R VisitSwitchSection(BoundSwitchSection node, A arg);
    public virtual R VisitSwitchLabel(BoundSwitchLabel node, A arg);
    public virtual R VisitBreakStatement(BoundBreakStatement node, A arg);
    public virtual R VisitContinueStatement(BoundContinueStatement node, A arg);
    public virtual R VisitIfStatement(BoundIfStatement node, A arg);
    public virtual R VisitDoStatement(BoundDoStatement node, A arg);
    public virtual R VisitWhileStatement(BoundWhileStatement node, A arg);
    public virtual R VisitForStatement(BoundForStatement node, A arg);
    public virtual R VisitForEachStatement(BoundForEachStatement node, A arg);
    public virtual R VisitUsingStatement(BoundUsingStatement node, A arg);
    public virtual R VisitFixedStatement(BoundFixedStatement node, A arg);
    public virtual R VisitLockStatement(BoundLockStatement node, A arg);
    public virtual R VisitTryStatement(BoundTryStatement node, A arg);
    public virtual R VisitCatchBlock(BoundCatchBlock node, A arg);
    public virtual R VisitLiteral(BoundLiteral node, A arg);
    public virtual R VisitThisReference(BoundThisReference node, A arg);
    public virtual R VisitPreviousSubmissionReference(BoundPreviousSubmissionReference node, A arg);
    public virtual R VisitHostObjectMemberReference(BoundHostObjectMemberReference node, A arg);
    public virtual R VisitBaseReference(BoundBaseReference node, A arg);
    public virtual R VisitLocal(BoundLocal node, A arg);
    public virtual R VisitPseudoVariable(BoundPseudoVariable node, A arg);
    public virtual R VisitRangeVariable(BoundRangeVariable node, A arg);
    public virtual R VisitParameter(BoundParameter node, A arg);
    public virtual R VisitLabelStatement(BoundLabelStatement node, A arg);
    public virtual R VisitGotoStatement(BoundGotoStatement node, A arg);
    public virtual R VisitLabeledStatement(BoundLabeledStatement node, A arg);
    public virtual R VisitLabel(BoundLabel node, A arg);
    public virtual R VisitStatementList(BoundStatementList node, A arg);
    public virtual R VisitConditionalGoto(BoundConditionalGoto node, A arg);
    public virtual R VisitDynamicMemberAccess(BoundDynamicMemberAccess node, A arg);
    public virtual R VisitDynamicInvocation(BoundDynamicInvocation node, A arg);
    public virtual R VisitConditionalAccess(BoundConditionalAccess node, A arg);
    public virtual R VisitLoweredConditionalAccess(BoundLoweredConditionalAccess node, A arg);
    public virtual R VisitConditionalReceiver(BoundConditionalReceiver node, A arg);
    public virtual R VisitComplexConditionalReceiver(BoundComplexConditionalReceiver node, A arg);
    public virtual R VisitMethodGroup(BoundMethodGroup node, A arg);
    public virtual R VisitPropertyGroup(BoundPropertyGroup node, A arg);
    public virtual R VisitCall(BoundCall node, A arg);
    public virtual R VisitEventAssignmentOperator(BoundEventAssignmentOperator node, A arg);
    public virtual R VisitAttribute(BoundAttribute node, A arg);
    public virtual R VisitObjectCreationExpression(BoundObjectCreationExpression node, A arg);
    public virtual R VisitDynamicObjectCreationExpression(BoundDynamicObjectCreationExpression node, A arg);
    public virtual R VisitNoPiaObjectCreationExpression(BoundNoPiaObjectCreationExpression node, A arg);
    public virtual R VisitObjectInitializerExpression(BoundObjectInitializerExpression node, A arg);
    public virtual R VisitObjectInitializerMember(BoundObjectInitializerMember node, A arg);
    public virtual R VisitDynamicObjectInitializerMember(BoundDynamicObjectInitializerMember node, A arg);
    public virtual R VisitCollectionInitializerExpression(BoundCollectionInitializerExpression node, A arg);
    public virtual R VisitCollectionElementInitializer(BoundCollectionElementInitializer node, A arg);
    public virtual R VisitDynamicCollectionElementInitializer(BoundDynamicCollectionElementInitializer node, A arg);
    public virtual R VisitImplicitReceiver(BoundImplicitReceiver node, A arg);
    public virtual R VisitAnonymousObjectCreationExpression(BoundAnonymousObjectCreationExpression node, A arg);
    public virtual R VisitAnonymousPropertyDeclaration(BoundAnonymousPropertyDeclaration node, A arg);
    public virtual R VisitNewT(BoundNewT node, A arg);
    public virtual R VisitDelegateCreationExpression(BoundDelegateCreationExpression node, A arg);
    public virtual R VisitArrayCreation(BoundArrayCreation node, A arg);
    public virtual R VisitArrayInitialization(BoundArrayInitialization node, A arg);
    public virtual R VisitStackAllocArrayCreation(BoundStackAllocArrayCreation node, A arg);
    public virtual R VisitFieldAccess(BoundFieldAccess node, A arg);
    public virtual R VisitHoistedFieldAccess(BoundHoistedFieldAccess node, A arg);
    public virtual R VisitPropertyAccess(BoundPropertyAccess node, A arg);
    public virtual R VisitEventAccess(BoundEventAccess node, A arg);
    public virtual R VisitIndexerAccess(BoundIndexerAccess node, A arg);
    public virtual R VisitDynamicIndexerAccess(BoundDynamicIndexerAccess node, A arg);
    public virtual R VisitLambda(BoundLambda node, A arg);
    public virtual R VisitUnboundLambda(UnboundLambda node, A arg);
    public virtual R VisitQueryClause(BoundQueryClause node, A arg);
    public virtual R VisitTypeOrInstanceInitializers(BoundTypeOrInstanceInitializers node, A arg);
    public virtual R VisitNameOfOperator(BoundNameOfOperator node, A arg);
    public virtual R VisitInterpolatedString(BoundInterpolatedString node, A arg);
    public virtual R VisitStringInsert(BoundStringInsert node, A arg);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.BoundTreeWalker : BoundTreeVisitor {
    public void VisitList(ImmutableArray`1<T> list);
    protected void VisitUnoptimizedForm(BoundQueryClause queryClause);
    public virtual BoundNode VisitFieldInitializer(BoundFieldInitializer node);
    public virtual BoundNode VisitFieldEqualsValue(BoundFieldEqualsValue node);
    public virtual BoundNode VisitPropertyEqualsValue(BoundPropertyEqualsValue node);
    public virtual BoundNode VisitParameterEqualsValue(BoundParameterEqualsValue node);
    public virtual BoundNode VisitGlobalStatementInitializer(BoundGlobalStatementInitializer node);
    public virtual BoundNode VisitDup(BoundDup node);
    public virtual BoundNode VisitBadExpression(BoundBadExpression node);
    public virtual BoundNode VisitBadStatement(BoundBadStatement node);
    public virtual BoundNode VisitTypeExpression(BoundTypeExpression node);
    public virtual BoundNode VisitTypeOrValueExpression(BoundTypeOrValueExpression node);
    public virtual BoundNode VisitNamespaceExpression(BoundNamespaceExpression node);
    public virtual BoundNode VisitUnaryOperator(BoundUnaryOperator node);
    public virtual BoundNode VisitIncrementOperator(BoundIncrementOperator node);
    public virtual BoundNode VisitAddressOfOperator(BoundAddressOfOperator node);
    public virtual BoundNode VisitPointerIndirectionOperator(BoundPointerIndirectionOperator node);
    public virtual BoundNode VisitPointerElementAccess(BoundPointerElementAccess node);
    public virtual BoundNode VisitRefTypeOperator(BoundRefTypeOperator node);
    public virtual BoundNode VisitMakeRefOperator(BoundMakeRefOperator node);
    public virtual BoundNode VisitRefValueOperator(BoundRefValueOperator node);
    public virtual BoundNode VisitBinaryOperator(BoundBinaryOperator node);
    public virtual BoundNode VisitUserDefinedConditionalLogicalOperator(BoundUserDefinedConditionalLogicalOperator node);
    public virtual BoundNode VisitCompoundAssignmentOperator(BoundCompoundAssignmentOperator node);
    public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node);
    public virtual BoundNode VisitNullCoalescingOperator(BoundNullCoalescingOperator node);
    public virtual BoundNode VisitConditionalOperator(BoundConditionalOperator node);
    public virtual BoundNode VisitArrayAccess(BoundArrayAccess node);
    public virtual BoundNode VisitArrayLength(BoundArrayLength node);
    public virtual BoundNode VisitAwaitExpression(BoundAwaitExpression node);
    public virtual BoundNode VisitTypeOfOperator(BoundTypeOfOperator node);
    public virtual BoundNode VisitMethodInfo(BoundMethodInfo node);
    public virtual BoundNode VisitFieldInfo(BoundFieldInfo node);
    public virtual BoundNode VisitDefaultOperator(BoundDefaultOperator node);
    public virtual BoundNode VisitIsOperator(BoundIsOperator node);
    public virtual BoundNode VisitAsOperator(BoundAsOperator node);
    public virtual BoundNode VisitSizeOfOperator(BoundSizeOfOperator node);
    public virtual BoundNode VisitConversion(BoundConversion node);
    public virtual BoundNode VisitArgList(BoundArgList node);
    public virtual BoundNode VisitArgListOperator(BoundArgListOperator node);
    public virtual BoundNode VisitFixedLocalCollectionInitializer(BoundFixedLocalCollectionInitializer node);
    public virtual BoundNode VisitSequencePoint(BoundSequencePoint node);
    public virtual BoundNode VisitSequencePointExpression(BoundSequencePointExpression node);
    public virtual BoundNode VisitSequencePointWithSpan(BoundSequencePointWithSpan node);
    public virtual BoundNode VisitBlock(BoundBlock node);
    public virtual BoundNode VisitStateMachineScope(BoundStateMachineScope node);
    public virtual BoundNode VisitLocalDeclaration(BoundLocalDeclaration node);
    public virtual BoundNode VisitMultipleLocalDeclarations(BoundMultipleLocalDeclarations node);
    public virtual BoundNode VisitSequence(BoundSequence node);
    public virtual BoundNode VisitNoOpStatement(BoundNoOpStatement node);
    public virtual BoundNode VisitReturnStatement(BoundReturnStatement node);
    public virtual BoundNode VisitYieldReturnStatement(BoundYieldReturnStatement node);
    public virtual BoundNode VisitYieldBreakStatement(BoundYieldBreakStatement node);
    public virtual BoundNode VisitThrowStatement(BoundThrowStatement node);
    public virtual BoundNode VisitExpressionStatement(BoundExpressionStatement node);
    public virtual BoundNode VisitSwitchStatement(BoundSwitchStatement node);
    public virtual BoundNode VisitSwitchSection(BoundSwitchSection node);
    public virtual BoundNode VisitSwitchLabel(BoundSwitchLabel node);
    public virtual BoundNode VisitBreakStatement(BoundBreakStatement node);
    public virtual BoundNode VisitContinueStatement(BoundContinueStatement node);
    public virtual BoundNode VisitIfStatement(BoundIfStatement node);
    public virtual BoundNode VisitDoStatement(BoundDoStatement node);
    public virtual BoundNode VisitWhileStatement(BoundWhileStatement node);
    public virtual BoundNode VisitForStatement(BoundForStatement node);
    public virtual BoundNode VisitForEachStatement(BoundForEachStatement node);
    public virtual BoundNode VisitUsingStatement(BoundUsingStatement node);
    public virtual BoundNode VisitFixedStatement(BoundFixedStatement node);
    public virtual BoundNode VisitLockStatement(BoundLockStatement node);
    public virtual BoundNode VisitTryStatement(BoundTryStatement node);
    public virtual BoundNode VisitCatchBlock(BoundCatchBlock node);
    public virtual BoundNode VisitLiteral(BoundLiteral node);
    public virtual BoundNode VisitThisReference(BoundThisReference node);
    public virtual BoundNode VisitPreviousSubmissionReference(BoundPreviousSubmissionReference node);
    public virtual BoundNode VisitHostObjectMemberReference(BoundHostObjectMemberReference node);
    public virtual BoundNode VisitBaseReference(BoundBaseReference node);
    public virtual BoundNode VisitLocal(BoundLocal node);
    public virtual BoundNode VisitPseudoVariable(BoundPseudoVariable node);
    public virtual BoundNode VisitRangeVariable(BoundRangeVariable node);
    public virtual BoundNode VisitParameter(BoundParameter node);
    public virtual BoundNode VisitLabelStatement(BoundLabelStatement node);
    public virtual BoundNode VisitGotoStatement(BoundGotoStatement node);
    public virtual BoundNode VisitLabeledStatement(BoundLabeledStatement node);
    public virtual BoundNode VisitLabel(BoundLabel node);
    public virtual BoundNode VisitStatementList(BoundStatementList node);
    public virtual BoundNode VisitConditionalGoto(BoundConditionalGoto node);
    public virtual BoundNode VisitDynamicMemberAccess(BoundDynamicMemberAccess node);
    public virtual BoundNode VisitDynamicInvocation(BoundDynamicInvocation node);
    public virtual BoundNode VisitConditionalAccess(BoundConditionalAccess node);
    public virtual BoundNode VisitLoweredConditionalAccess(BoundLoweredConditionalAccess node);
    public virtual BoundNode VisitConditionalReceiver(BoundConditionalReceiver node);
    public virtual BoundNode VisitComplexConditionalReceiver(BoundComplexConditionalReceiver node);
    public virtual BoundNode VisitMethodGroup(BoundMethodGroup node);
    public virtual BoundNode VisitPropertyGroup(BoundPropertyGroup node);
    public virtual BoundNode VisitCall(BoundCall node);
    public virtual BoundNode VisitEventAssignmentOperator(BoundEventAssignmentOperator node);
    public virtual BoundNode VisitAttribute(BoundAttribute node);
    public virtual BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node);
    public virtual BoundNode VisitDynamicObjectCreationExpression(BoundDynamicObjectCreationExpression node);
    public virtual BoundNode VisitNoPiaObjectCreationExpression(BoundNoPiaObjectCreationExpression node);
    public virtual BoundNode VisitObjectInitializerExpression(BoundObjectInitializerExpression node);
    public virtual BoundNode VisitObjectInitializerMember(BoundObjectInitializerMember node);
    public virtual BoundNode VisitDynamicObjectInitializerMember(BoundDynamicObjectInitializerMember node);
    public virtual BoundNode VisitCollectionInitializerExpression(BoundCollectionInitializerExpression node);
    public virtual BoundNode VisitCollectionElementInitializer(BoundCollectionElementInitializer node);
    public virtual BoundNode VisitDynamicCollectionElementInitializer(BoundDynamicCollectionElementInitializer node);
    public virtual BoundNode VisitImplicitReceiver(BoundImplicitReceiver node);
    public virtual BoundNode VisitAnonymousObjectCreationExpression(BoundAnonymousObjectCreationExpression node);
    public virtual BoundNode VisitAnonymousPropertyDeclaration(BoundAnonymousPropertyDeclaration node);
    public virtual BoundNode VisitNewT(BoundNewT node);
    public virtual BoundNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node);
    public virtual BoundNode VisitArrayCreation(BoundArrayCreation node);
    public virtual BoundNode VisitArrayInitialization(BoundArrayInitialization node);
    public virtual BoundNode VisitStackAllocArrayCreation(BoundStackAllocArrayCreation node);
    public virtual BoundNode VisitFieldAccess(BoundFieldAccess node);
    public virtual BoundNode VisitHoistedFieldAccess(BoundHoistedFieldAccess node);
    public virtual BoundNode VisitPropertyAccess(BoundPropertyAccess node);
    public virtual BoundNode VisitEventAccess(BoundEventAccess node);
    public virtual BoundNode VisitIndexerAccess(BoundIndexerAccess node);
    public virtual BoundNode VisitDynamicIndexerAccess(BoundDynamicIndexerAccess node);
    public virtual BoundNode VisitLambda(BoundLambda node);
    public virtual BoundNode VisitUnboundLambda(UnboundLambda node);
    public virtual BoundNode VisitQueryClause(BoundQueryClause node);
    public virtual BoundNode VisitTypeOrInstanceInitializers(BoundTypeOrInstanceInitializers node);
    public virtual BoundNode VisitNameOfOperator(BoundNameOfOperator node);
    public virtual BoundNode VisitInterpolatedString(BoundInterpolatedString node);
    public virtual BoundNode VisitStringInsert(BoundStringInsert node);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuard : BoundTreeWalker {
    private int _recursionDepth;
    protected int RecursionDepth { get; }
    protected BoundTreeWalkerWithStackGuard(int recursionDepth);
    protected int get_RecursionDepth();
    public virtual BoundNode Visit(BoundNode node);
    protected BoundExpression VisitExpressionWithStackGuard(BoundExpression node);
    protected sealed virtual BoundExpression VisitExpressionWithoutStackGuard(BoundExpression node);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator : BoundTreeWalkerWithStackGuard {
    protected BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator(int recursionDepth);
    public sealed virtual BoundNode VisitBinaryOperator(BoundBinaryOperator node);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundTryStatement : BoundStatement {
    [CompilerGeneratedAttribute]
private BoundBlock <TryBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BoundCatchBlock> <CatchBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundBlock <FinallyBlockOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreferFaultHandler>k__BackingField;
    private IBlockStatement Microsoft.CodeAnalysis.Semantics.ITryStatement.Body { get; }
    private ImmutableArray`1<ICatchClause> Microsoft.CodeAnalysis.Semantics.ITryStatement.Catches { get; }
    private IBlockStatement Microsoft.CodeAnalysis.Semantics.ITryStatement.FinallyHandler { get; }
    protected OperationKind StatementKind { get; }
    public BoundBlock TryBlock { get; }
    public ImmutableArray`1<BoundCatchBlock> CatchBlocks { get; }
    public BoundBlock FinallyBlockOpt { get; }
    public bool PreferFaultHandler { get; }
    public BoundTryStatement(CSharpSyntaxNode syntax, BoundBlock tryBlock, ImmutableArray`1<BoundCatchBlock> catchBlocks, BoundBlock finallyBlockOpt);
    public BoundTryStatement(CSharpSyntaxNode syntax, BoundBlock tryBlock, ImmutableArray`1<BoundCatchBlock> catchBlocks, BoundBlock finallyBlockOpt, bool preferFaultHandler, bool hasErrors);
    private sealed virtual override IBlockStatement Microsoft.CodeAnalysis.Semantics.ITryStatement.get_Body();
    private sealed virtual override ImmutableArray`1<ICatchClause> Microsoft.CodeAnalysis.Semantics.ITryStatement.get_Catches();
    private sealed virtual override IBlockStatement Microsoft.CodeAnalysis.Semantics.ITryStatement.get_FinallyHandler();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundBlock get_TryBlock();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BoundCatchBlock> get_CatchBlocks();
    [CompilerGeneratedAttribute]
public BoundBlock get_FinallyBlockOpt();
    [CompilerGeneratedAttribute]
public bool get_PreferFaultHandler();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundTryStatement Update(BoundBlock tryBlock, ImmutableArray`1<BoundCatchBlock> catchBlocks, BoundBlock finallyBlockOpt, bool preferFaultHandler);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundTypeExpression : BoundExpression {
    [CompilerGeneratedAttribute]
private AliasSymbol <AliasOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InferredType>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundTypeExpression <BoundContainingTypeOpt>k__BackingField;
    public Symbol ExpressionSymbol { get; }
    public LookupResultKind ResultKind { get; }
    protected OperationKind ExpressionKind { get; }
    public AliasSymbol AliasOpt { get; }
    public bool InferredType { get; }
    public BoundTypeExpression BoundContainingTypeOpt { get; }
    public BoundTypeExpression(CSharpSyntaxNode syntax, AliasSymbol aliasOpt, TypeSymbol type, bool hasErrors);
    public BoundTypeExpression(CSharpSyntaxNode syntax, AliasSymbol aliasOpt, TypeSymbol type);
    public BoundTypeExpression(CSharpSyntaxNode syntax, AliasSymbol aliasOpt, bool inferredType, TypeSymbol type, bool hasErrors);
    public BoundTypeExpression(CSharpSyntaxNode syntax, AliasSymbol aliasOpt, bool inferredType, BoundTypeExpression boundContainingTypeOpt, TypeSymbol type, bool hasErrors);
    public virtual Symbol get_ExpressionSymbol();
    public virtual LookupResultKind get_ResultKind();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public AliasSymbol get_AliasOpt();
    [CompilerGeneratedAttribute]
public bool get_InferredType();
    [CompilerGeneratedAttribute]
public BoundTypeExpression get_BoundContainingTypeOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundTypeExpression Update(AliasSymbol aliasOpt, bool inferredType, BoundTypeExpression boundContainingTypeOpt, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundTypeOfOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundTypeExpression <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSymbol <GetTypeFromHandle>k__BackingField;
    private ITypeSymbol Microsoft.CodeAnalysis.Semantics.ITypeOperationExpression.TypeOperand { get; }
    protected OperationKind ExpressionKind { get; }
    public BoundTypeExpression SourceType { get; }
    public MethodSymbol GetTypeFromHandle { get; }
    public BoundTypeOfOperator(CSharpSyntaxNode syntax, BoundTypeExpression sourceType, MethodSymbol getTypeFromHandle, TypeSymbol type, bool hasErrors);
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.Semantics.ITypeOperationExpression.get_TypeOperand();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundTypeExpression get_SourceType();
    [CompilerGeneratedAttribute]
public MethodSymbol get_GetTypeFromHandle();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundTypeOfOperator Update(BoundTypeExpression sourceType, MethodSymbol getTypeFromHandle, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundTypeOrInstanceInitializers : BoundStatementList {
    public BoundTypeOrInstanceInitializers(CSharpSyntaxNode syntax, ImmutableArray`1<BoundStatement> statements, bool hasErrors);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundTypeOrInstanceInitializers Update(ImmutableArray`1<BoundStatement> statements);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundTypeOrValueData : ValueType {
    [CompilerGeneratedAttribute]
private Symbol <ValueSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <ValueExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticBag <ValueDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <TypeExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticBag <TypeDiagnostics>k__BackingField;
    public Symbol ValueSymbol { get; }
    public BoundExpression ValueExpression { get; }
    public DiagnosticBag ValueDiagnostics { get; }
    public BoundExpression TypeExpression { get; }
    public DiagnosticBag TypeDiagnostics { get; }
    public BoundTypeOrValueData(Symbol valueSymbol, BoundExpression valueExpression, DiagnosticBag valueDiagnostics, BoundExpression typeExpression, DiagnosticBag typeDiagnostics);
    [CompilerGeneratedAttribute]
public Symbol get_ValueSymbol();
    [CompilerGeneratedAttribute]
public BoundExpression get_ValueExpression();
    [CompilerGeneratedAttribute]
public DiagnosticBag get_ValueDiagnostics();
    [CompilerGeneratedAttribute]
public BoundExpression get_TypeExpression();
    [CompilerGeneratedAttribute]
public DiagnosticBag get_TypeDiagnostics();
    public static bool op_Equality(BoundTypeOrValueData a, BoundTypeOrValueData b);
    public static bool op_Inequality(BoundTypeOrValueData a, BoundTypeOrValueData b);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override bool System.IEquatable<Microsoft.CodeAnalysis.CSharp.BoundTypeOrValueData>.Equals(BoundTypeOrValueData b);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundTypeOrValueExpression : BoundExpression {
    [CompilerGeneratedAttribute]
private BoundTypeOrValueData <Data>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public BoundTypeOrValueData Data { get; }
    public BoundTypeOrValueExpression(CSharpSyntaxNode syntax, BoundTypeOrValueData data, TypeSymbol type, bool hasErrors);
    public BoundTypeOrValueExpression(CSharpSyntaxNode syntax, BoundTypeOrValueData data, TypeSymbol type);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundTypeOrValueData get_Data();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundTypeOrValueExpression Update(BoundTypeOrValueData data, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundUnaryOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<MethodSymbol> <OriginalUserDefinedOperatorsOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private UnaryOperatorKind <OperatorKind>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Operand>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstantValue <ConstantValueOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSymbol <MethodOpt>k__BackingField;
    private LookupResultKind _ResultKind;
    public ConstantValue ConstantValue { get; }
    public Symbol ExpressionSymbol { get; }
    public ImmutableArray`1<MethodSymbol> OriginalUserDefinedOperatorsOpt { get; }
    private UnaryOperationKind Microsoft.CodeAnalysis.Semantics.IUnaryOperatorExpression.UnaryOperationKind { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IUnaryOperatorExpression.Operand { get; }
    private bool Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.UsesOperatorMethod { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.OperatorMethod { get; }
    protected OperationKind ExpressionKind { get; }
    public UnaryOperatorKind OperatorKind { get; }
    public BoundExpression Operand { get; }
    public ConstantValue ConstantValueOpt { get; }
    public MethodSymbol MethodOpt { get; }
    public LookupResultKind ResultKind { get; }
    internal BoundUnaryOperator(CSharpSyntaxNode syntax, UnaryOperatorKind operatorKind, BoundExpression operand, ConstantValue constantValueOpt, MethodSymbol methodOpt, LookupResultKind resultKind, ImmutableArray`1<MethodSymbol> originalUserDefinedOperatorsOpt, TypeSymbol type, bool hasErrors);
    public BoundUnaryOperator(CSharpSyntaxNode syntax, UnaryOperatorKind operatorKind, BoundExpression operand, ConstantValue constantValueOpt, MethodSymbol methodOpt, LookupResultKind resultKind, TypeSymbol type, bool hasErrors);
    public virtual ConstantValue get_ConstantValue();
    public virtual Symbol get_ExpressionSymbol();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<MethodSymbol> get_OriginalUserDefinedOperatorsOpt();
    private sealed virtual override UnaryOperationKind Microsoft.CodeAnalysis.Semantics.IUnaryOperatorExpression.get_UnaryOperationKind();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IUnaryOperatorExpression.get_Operand();
    private sealed virtual override bool Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.get_UsesOperatorMethod();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.Semantics.IHasOperatorMethodExpression.get_OperatorMethod();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public UnaryOperatorKind get_OperatorKind();
    [CompilerGeneratedAttribute]
public BoundExpression get_Operand();
    [CompilerGeneratedAttribute]
public ConstantValue get_ConstantValueOpt();
    [CompilerGeneratedAttribute]
public MethodSymbol get_MethodOpt();
    public virtual LookupResultKind get_ResultKind();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundUnaryOperator Update(UnaryOperatorKind operatorKind, BoundExpression operand, ConstantValue constantValueOpt, MethodSymbol methodOpt, LookupResultKind resultKind, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundUserDefinedConditionalLogicalOperator : BoundExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<MethodSymbol> <OriginalUserDefinedOperatorsOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private BinaryOperatorKind <OperatorKind>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSymbol <LogicalOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSymbol <TrueOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodSymbol <FalseOperator>k__BackingField;
    private LookupResultKind _ResultKind;
    public Symbol ExpressionSymbol { get; }
    public ImmutableArray`1<MethodSymbol> OriginalUserDefinedOperatorsOpt { get; }
    protected OperationKind ExpressionKind { get; }
    public BinaryOperatorKind OperatorKind { get; }
    public BoundExpression Left { get; }
    public BoundExpression Right { get; }
    public MethodSymbol LogicalOperator { get; }
    public MethodSymbol TrueOperator { get; }
    public MethodSymbol FalseOperator { get; }
    public LookupResultKind ResultKind { get; }
    public BoundUserDefinedConditionalLogicalOperator(CSharpSyntaxNode syntax, BinaryOperatorKind operatorKind, BoundExpression left, BoundExpression right, MethodSymbol logicalOperator, MethodSymbol trueOperator, MethodSymbol falseOperator, LookupResultKind resultKind, ImmutableArray`1<MethodSymbol> originalUserDefinedOperatorsOpt, TypeSymbol type, bool hasErrors);
    public BoundUserDefinedConditionalLogicalOperator(CSharpSyntaxNode syntax, BinaryOperatorKind operatorKind, BoundExpression left, BoundExpression right, MethodSymbol logicalOperator, MethodSymbol trueOperator, MethodSymbol falseOperator, LookupResultKind resultKind, TypeSymbol type, bool hasErrors);
    public virtual Symbol get_ExpressionSymbol();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<MethodSymbol> get_OriginalUserDefinedOperatorsOpt();
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BinaryOperatorKind get_OperatorKind();
    [CompilerGeneratedAttribute]
public BoundExpression get_Left();
    [CompilerGeneratedAttribute]
public BoundExpression get_Right();
    [CompilerGeneratedAttribute]
public MethodSymbol get_LogicalOperator();
    [CompilerGeneratedAttribute]
public MethodSymbol get_TrueOperator();
    [CompilerGeneratedAttribute]
public MethodSymbol get_FalseOperator();
    public virtual LookupResultKind get_ResultKind();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundUserDefinedConditionalLogicalOperator Update(BinaryOperatorKind operatorKind, BoundExpression left, BoundExpression right, MethodSymbol logicalOperator, MethodSymbol trueOperator, MethodSymbol falseOperator, LookupResultKind resultKind, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundUsingStatement : BoundStatement {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<LocalSymbol> <Locals>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundMultipleLocalDeclarations <DeclarationsOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundExpression <ExpressionOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private Conversion <IDisposableConversion>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundStatement <Body>k__BackingField;
    private IVariableDeclarationStatement Microsoft.CodeAnalysis.Semantics.IUsingStatement.Declaration { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IUsingStatement.Value { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IUsingStatement.Body { get; }
    protected OperationKind StatementKind { get; }
    public ImmutableArray`1<LocalSymbol> Locals { get; }
    public BoundMultipleLocalDeclarations DeclarationsOpt { get; }
    public BoundExpression ExpressionOpt { get; }
    public Conversion IDisposableConversion { get; }
    public BoundStatement Body { get; }
    public BoundUsingStatement(CSharpSyntaxNode syntax, ImmutableArray`1<LocalSymbol> locals, BoundMultipleLocalDeclarations declarationsOpt, BoundExpression expressionOpt, Conversion iDisposableConversion, BoundStatement body, bool hasErrors);
    private sealed virtual override IVariableDeclarationStatement Microsoft.CodeAnalysis.Semantics.IUsingStatement.get_Declaration();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IUsingStatement.get_Value();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IUsingStatement.get_Body();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<LocalSymbol> get_Locals();
    [CompilerGeneratedAttribute]
public BoundMultipleLocalDeclarations get_DeclarationsOpt();
    [CompilerGeneratedAttribute]
public BoundExpression get_ExpressionOpt();
    [CompilerGeneratedAttribute]
public Conversion get_IDisposableConversion();
    [CompilerGeneratedAttribute]
public BoundStatement get_Body();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundUsingStatement Update(ImmutableArray`1<LocalSymbol> locals, BoundMultipleLocalDeclarations declarationsOpt, BoundExpression expressionOpt, Conversion iDisposableConversion, BoundStatement body);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundWhileStatement : BoundLoopStatement {
    [CompilerGeneratedAttribute]
private BoundExpression <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundStatement <Body>k__BackingField;
    private bool Microsoft.CodeAnalysis.Semantics.IWhileUntilLoopStatement.IsTopTest { get; }
    private bool Microsoft.CodeAnalysis.Semantics.IWhileUntilLoopStatement.IsWhile { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.IForWhileUntilLoopStatement.Condition { get; }
    private LoopKind Microsoft.CodeAnalysis.Semantics.ILoopStatement.LoopKind { get; }
    private IOperation Microsoft.CodeAnalysis.Semantics.ILoopStatement.Body { get; }
    protected OperationKind StatementKind { get; }
    public BoundExpression Condition { get; }
    public BoundStatement Body { get; }
    public BoundWhileStatement(CSharpSyntaxNode syntax, BoundExpression condition, BoundStatement body, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel, bool hasErrors);
    private sealed virtual override bool Microsoft.CodeAnalysis.Semantics.IWhileUntilLoopStatement.get_IsTopTest();
    private sealed virtual override bool Microsoft.CodeAnalysis.Semantics.IWhileUntilLoopStatement.get_IsWhile();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IForWhileUntilLoopStatement.get_Condition();
    private sealed virtual override LoopKind Microsoft.CodeAnalysis.Semantics.ILoopStatement.get_LoopKind();
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.ILoopStatement.get_Body();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Condition();
    [CompilerGeneratedAttribute]
public BoundStatement get_Body();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundWhileStatement Update(BoundExpression condition, BoundStatement body, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundYieldBreakStatement : BoundStatement {
    private IOperation Microsoft.CodeAnalysis.Semantics.IReturnStatement.ReturnedValue { get; }
    protected OperationKind StatementKind { get; }
    public BoundYieldBreakStatement(CSharpSyntaxNode syntax, bool hasErrors);
    public BoundYieldBreakStatement(CSharpSyntaxNode syntax);
    public static BoundYieldBreakStatement Synthesized(CSharpSyntaxNode syntax, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IReturnStatement.get_ReturnedValue();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.CSharp.BoundYieldReturnStatement : BoundStatement {
    [CompilerGeneratedAttribute]
private BoundExpression <Expression>k__BackingField;
    private IOperation Microsoft.CodeAnalysis.Semantics.IReturnStatement.ReturnedValue { get; }
    protected OperationKind StatementKind { get; }
    public BoundExpression Expression { get; }
    public BoundYieldReturnStatement(CSharpSyntaxNode syntax, BoundExpression expression, bool hasErrors);
    private sealed virtual override IOperation Microsoft.CodeAnalysis.Semantics.IReturnStatement.get_ReturnedValue();
    protected virtual OperationKind get_StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public BoundExpression get_Expression();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundYieldReturnStatement Update(BoundExpression expression);
}
internal class Microsoft.CodeAnalysis.CSharp.BuckStopsHereBinder : Binder {
    public ConsList`1<LocalSymbol> ImplicitlyTypedLocalsBeingBound { get; }
    internal ImportChain ImportChain { get; }
    internal ConstantFieldsInProgress ConstantFieldsInProgress { get; }
    internal ConsList`1<FieldSymbol> FieldsBeingBound { get; }
    internal LocalSymbol LocalInProgress { get; }
    internal bool IsInMethodBody { get; }
    internal bool IsDirectlyInIterator { get; }
    internal bool IsIndirectlyInIterator { get; }
    internal GeneratedLabelSymbol BreakLabel { get; }
    internal GeneratedLabelSymbol ContinueLabel { get; }
    internal BoundExpression ConditionalReceiverExpression { get; }
    internal Symbol ContainingMemberOrLambda { get; }
    internal ImmutableArray`1<LocalSymbol> Locals { get; }
    internal ImmutableArray`1<LabelSymbol> Labels { get; }
    internal ImmutableHashSet`1<Symbol> LockedOrDisposedVariables { get; }
    internal BuckStopsHereBinder(CSharpCompilation compilation);
    public virtual ConsList`1<LocalSymbol> get_ImplicitlyTypedLocalsBeingBound();
    internal virtual ImportChain get_ImportChain();
    internal virtual Imports GetImports(ConsList`1<Symbol> basesBeingResolved);
    protected virtual SourceLocalSymbol LookupLocal(SyntaxToken nameToken);
    internal virtual bool IsAccessibleHelper(Symbol symbol, TypeSymbol accessThroughType, Boolean& failedThroughTypeCheck, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    internal virtual ConstantFieldsInProgress get_ConstantFieldsInProgress();
    internal virtual ConsList`1<FieldSymbol> get_FieldsBeingBound();
    internal virtual LocalSymbol get_LocalInProgress();
    protected virtual bool IsUnboundTypeAllowed(GenericNameSyntax syntax);
    internal virtual bool get_IsInMethodBody();
    internal virtual bool get_IsDirectlyInIterator();
    internal virtual bool get_IsIndirectlyInIterator();
    internal virtual GeneratedLabelSymbol get_BreakLabel();
    internal virtual GeneratedLabelSymbol get_ContinueLabel();
    internal virtual BoundExpression get_ConditionalReceiverExpression();
    internal virtual TypeSymbol GetIteratorElementType(YieldStatementSyntax node, DiagnosticBag diagnostics);
    internal virtual Symbol get_ContainingMemberOrLambda();
    internal virtual Binder GetBinder(CSharpSyntaxNode node);
    internal virtual ImmutableArray`1<LocalSymbol> GetDeclaredLocalsForScope(CSharpSyntaxNode node);
    internal virtual BoundSwitchStatement BindSwitchExpressionAndSections(SwitchStatementSyntax node, Binder originalBinder, DiagnosticBag diagnostics);
    internal virtual BoundForStatement BindForParts(DiagnosticBag diagnostics, Binder originalBinder);
    internal virtual BoundStatement BindForEachParts(DiagnosticBag diagnostics, Binder originalBinder);
    internal virtual BoundWhileStatement BindWhileParts(DiagnosticBag diagnostics, Binder originalBinder);
    internal virtual BoundDoStatement BindDoParts(DiagnosticBag diagnostics, Binder originalBinder);
    internal virtual BoundStatement BindUsingStatementParts(DiagnosticBag diagnostics, Binder originalBinder);
    internal virtual BoundStatement BindLockStatementParts(DiagnosticBag diagnostics, Binder originalBinder);
    internal virtual ImmutableArray`1<LocalSymbol> get_Locals();
    internal virtual ImmutableArray`1<LabelSymbol> get_Labels();
    internal virtual ImmutableHashSet`1<Symbol> get_LockedOrDisposedVariables();
}
internal class Microsoft.CodeAnalysis.CSharp.BuiltInOperators : object {
    private CSharpCompilation _compilation;
    private ImmutableArray`1[] _builtInUnaryOperators;
    private ImmutableArray`1[][] _builtInOperators;
    internal BuiltInOperators(CSharpCompilation compilation);
    private ImmutableArray`1<UnaryOperatorSignature> GetSignaturesFromUnaryOperatorKinds(Int32[] operatorKinds);
    internal void GetSimpleBuiltInOperators(UnaryOperatorKind kind, ArrayBuilder`1<UnaryOperatorSignature> operators);
    internal UnaryOperatorSignature GetSignature(UnaryOperatorKind kind);
    private ImmutableArray`1<BinaryOperatorSignature> GetSignaturesFromBinaryOperatorKinds(Int32[] operatorKinds);
    internal void GetSimpleBuiltInOperators(BinaryOperatorKind kind, ArrayBuilder`1<BinaryOperatorSignature> operators);
    internal BinaryOperatorSignature GetSignature(BinaryOperatorKind kind);
    private TypeSymbol LeftType(BinaryOperatorKind kind);
    private TypeSymbol RightType(BinaryOperatorKind kind);
    private TypeSymbol ReturnType(BinaryOperatorKind kind);
    private TypeSymbol LiftedType(BinaryOperatorKind kind);
    internal static bool IsValidObjectEquality(Conversions Conversions, TypeSymbol leftType, bool leftIsNull, TypeSymbol rightType, bool rightIsNull, HashSet`1& useSiteDiagnostics);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.CapturedSymbolReplacement : object {
    public bool IsReusable;
    public CapturedSymbolReplacement(bool isReusable);
    public abstract virtual BoundExpression Replacement(CSharpSyntaxNode node, Func`2<NamedTypeSymbol, BoundExpression> makeFrame);
}
internal class Microsoft.CodeAnalysis.CSharp.CapturedToExpressionSymbolReplacement : CapturedSymbolReplacement {
    private BoundExpression _replacement;
    public ImmutableArray`1<StateMachineFieldSymbol> HoistedFields;
    public CapturedToExpressionSymbolReplacement(BoundExpression replacement, ImmutableArray`1<StateMachineFieldSymbol> hoistedFields, bool isReusable);
    public virtual BoundExpression Replacement(CSharpSyntaxNode node, Func`2<NamedTypeSymbol, BoundExpression> makeFrame);
}
internal class Microsoft.CodeAnalysis.CSharp.CapturedToFrameSymbolReplacement : CapturedSymbolReplacement {
    public LambdaCapturedVariable HoistedField;
    public CapturedToFrameSymbolReplacement(LambdaCapturedVariable hoistedField, bool isReusable);
    public virtual BoundExpression Replacement(CSharpSyntaxNode node, Func`2<NamedTypeSymbol, BoundExpression> makeFrame);
}
internal class Microsoft.CodeAnalysis.CSharp.CapturedToStateMachineFieldReplacement : CapturedSymbolReplacement {
    public StateMachineFieldSymbol HoistedField;
    public CapturedToStateMachineFieldReplacement(StateMachineFieldSymbol hoistedField, bool isReusable);
    public virtual BoundExpression Replacement(CSharpSyntaxNode node, Func`2<NamedTypeSymbol, BoundExpression> makeFrame);
}
internal class Microsoft.CodeAnalysis.CSharp.CatchClauseBinder : LocalScopeBinder {
    private CatchClauseSyntax _syntax;
    public CatchClauseBinder(Binder enclosing, CatchClauseSyntax syntax);
    protected virtual ImmutableArray`1<LocalSymbol> BuildLocals();
    internal virtual ImmutableArray`1<LocalSymbol> GetDeclaredLocalsForScope(CSharpSyntaxNode node);
}
internal enum Microsoft.CodeAnalysis.CSharp.ClosureKind : Enum {
    public int value__;
    public static ClosureKind Static;
    public static ClosureKind ThisOnly;
    public static ClosureKind General;
}
internal class Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker : CSharpSymbolVisitor {
    private CSharpCompilation _compilation;
    private SyntaxTree _filterTree;
    private Nullable`1<TextSpan> _filterSpanWithinTree;
    private ConcurrentQueue`1<Diagnostic> _diagnostics;
    private CancellationToken _cancellationToken;
    private ConcurrentDictionary`2<Symbol, Compliance> _declaredOrInheritedCompliance;
    private ClsComplianceChecker(CSharpCompilation compilation, SyntaxTree filterTree, Nullable`1<TextSpan> filterSpanWithinTree, ConcurrentQueue`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    public static void CheckCompliance(CSharpCompilation compilation, DiagnosticBag diagnostics, CancellationToken cancellationToken, SyntaxTree filterTree, Nullable`1<TextSpan> filterSpanWithinTree);
    public virtual void VisitAssembly(AssemblySymbol symbol);
    public virtual void VisitNamespace(NamespaceSymbol symbol);
    public virtual void VisitNamedType(NamedTypeSymbol symbol);
    private bool HasAcceptableAttributeConstructor(NamedTypeSymbol attributeType);
    public virtual void VisitMethod(MethodSymbol symbol);
    private void CheckForAttributeOnAccessor(MethodSymbol symbol);
    public virtual void VisitProperty(PropertySymbol symbol);
    public virtual void VisitEvent(EventSymbol symbol);
    public virtual void VisitField(FieldSymbol symbol);
    private bool VisitTypeOrMember(Symbol symbol, Compliance compliance);
    private void CheckForNonCompliantAbstractMember(Symbol symbol);
    private void CheckBaseTypeCompliance(NamedTypeSymbol symbol);
    private void CheckForCompliantWithinNonCompliant(Symbol symbol);
    private void CheckTypeParameterCompliance(ImmutableArray`1<TypeParameterSymbol> typeParameters, NamedTypeSymbol context);
    private void CheckParameterCompliance(ImmutableArray`1<ParameterSymbol> parameters, NamedTypeSymbol context);
    private void CheckForAttributeWithArrayArgument(Symbol symbol);
    private void CheckForAttributeWithArrayArgumentInternal(ImmutableArray`1<CSharpAttributeData> attributes);
    private bool TryGetAttributeWarningLocation(CSharpAttributeData attribute, Location& location);
    private void CheckForMeaninglessOnParameter(ImmutableArray`1<ParameterSymbol> parameters);
    private void CheckForMeaninglessOnReturn(MethodSymbol method);
    private void CheckReturnTypeCompliance(Symbol symbol);
    private bool TryGetClsComplianceAttributeLocation(ImmutableArray`1<CSharpAttributeData> attributes, Symbol targetSymbol, Location& attributeLocation);
    private bool CheckForDeclarationWithoutAssemblyDeclaration(Symbol symbol, Compliance compliance);
    private void CheckMemberDistinctness(NamespaceOrTypeSymbol symbol);
    private void CheckSymbolDistinctness(Symbol symbol, string symbolName, ValueSet<string, Symbol> sameNameSymbols);
    private void CheckName(Symbol symbol);
    private bool DoNotVisit(Symbol symbol);
    private bool IsSyntacticallyFilteredOut(Symbol symbol);
    private bool IsCompliantType(TypeSymbol type, NamedTypeSymbol context);
    private bool IsCompliantType(NamedTypeSymbol type, NamedTypeSymbol context);
    private static bool IsInaccessibleBecauseOfConstruction(NamedTypeSymbol type, NamedTypeSymbol context);
    private Compliance GetDeclaredOrInheritedCompliance(Symbol symbol);
    private Compliance GetInheritedCompliance(Symbol symbol);
    private Nullable`1<bool> GetDeclaredCompliance(Symbol symbol, Location& attributeLocation);
    private static bool IsAccessibleOutsideAssembly(Symbol symbol);
    private static bool IsAccessibleIfContainerIsAccessible(Symbol symbol);
    private void AddDiagnostic(ErrorCode code, Location location);
    private void AddDiagnostic(ErrorCode code, Location location, Object[] args);
    private static bool IsImplicitClass(Symbol symbol);
    private static bool IsTrue(Compliance compliance);
    private static bool IsDeclared(Compliance compliance);
    private static bool TryGetCollisionErrorCode(Symbol x, Symbol y, ErrorCode& code);
    private static bool IsArrayOfArrays(ArrayTypeSymbol arrayType);
}
internal class Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator : object {
    private MethodSymbol _method;
    private SyntaxNode _methodBodySyntaxOpt;
    private BoundStatement _boundBody;
    private ILBuilder _builder;
    private PEModuleBuilder _module;
    private DiagnosticBag _diagnostics;
    private ILEmitStyle _ilEmitStyle;
    private bool _emitPdbSequencePoints;
    private HashSet`1<LocalSymbol> _stackLocals;
    private int _tryNestingLevel;
    private SynthesizedLocalOrdinalsDispenser _synthesizedLocalOrdinals;
    private int _uniqueNameId;
    private static object s_returnLabel;
    private int _asyncCatchHandlerOffset;
    private ArrayBuilder`1<int> _asyncYieldPoints;
    private ArrayBuilder`1<int> _asyncResumePoints;
    private IndirectReturnState _indirectReturnState;
    private LocalDefinition _returnTemp;
    private int _recursionDepth;
    private static ILOpCode[] s_compOpCodes;
    private static int IL_OP_CODE_ROW_LENGTH;
    private static ILOpCode[] s_condJumpOpCodes;
    private LocalDefinition LazyReturnTemp { get; }
    public CodeGenerator(MethodSymbol method, BoundStatement boundBody, ILBuilder builder, PEModuleBuilder moduleBuilder, DiagnosticBag diagnostics, OptimizationLevel optimizations, bool emittingPdb);
    private static CodeGenerator();
    private bool IsDebugPlus();
    private LocalDefinition get_LazyReturnTemp();
    private bool IsStackLocal(LocalSymbol local);
    public void Generate();
    public void Generate(Int32& asyncCatchHandlerOffset, ImmutableArray`1& asyncYieldPoints, ImmutableArray`1& asyncResumePoints);
    private void GenerateImpl();
    private void HandleReturn();
    private void EmitSymbolToken(TypeSymbol symbol, CSharpSyntaxNode syntaxNode);
    private void EmitSymbolToken(MethodSymbol method, CSharpSyntaxNode syntaxNode, BoundArgListOperator optArgList);
    private void EmitSymbolToken(FieldSymbol symbol, CSharpSyntaxNode syntaxNode);
    private void EmitSequencePointStatement(BoundSequencePoint node);
    private void EmitSequencePointStatement(BoundSequencePointWithSpan node);
    private void SetInitialDebugDocument();
    private void EmitHiddenSequencePoint();
    private void EmitSequencePoint(CSharpSyntaxNode syntax);
    private TextSpan EmitSequencePoint(SyntaxTree syntaxTree, TextSpan span);
    private LocalDefinition EmitAddress(BoundExpression expression, AddressKind addressKind);
    private void EmitComplexConditionalReceiverAddress(BoundComplexConditionalReceiver expression);
    private void EmitLocalAddress(BoundLocal localAccess);
    private void EmitPseudoVariableAddress(BoundPseudoVariable expression);
    private void EmitRefValueAddress(BoundRefValueOperator refValue);
    private LocalDefinition EmitAddressOfTempClone(BoundExpression expression);
    private LocalDefinition EmitSequenceAddress(BoundSequence sequence, AddressKind addressKind);
    private LocalSymbol DigForValueLocal(BoundSequence topSequence);
    private LocalSymbol DigForValueLocal(BoundSequence topSequence, BoundExpression value);
    private bool HasHome(BoundExpression expression);
    private bool HasHome(BoundFieldAccess fieldAccess);
    private void EmitArrayIndices(ImmutableArray`1<BoundExpression> indices);
    private void EmitArrayElementAddress(BoundArrayAccess arrayAccess, AddressKind addressKind);
    private LocalDefinition EmitFieldAddress(BoundFieldAccess fieldAccess);
    private void EmitStaticFieldAddress(FieldSymbol field, CSharpSyntaxNode syntaxNode);
    private void EmitParameterAddress(BoundParameter parameter);
    private LocalDefinition EmitReceiverRef(BoundExpression receiver, bool isAccessConstrained);
    private LocalDefinition EmitInstanceFieldAddress(BoundFieldAccess fieldAccess);
    private void EmitArrayInitializers(ArrayTypeSymbol arrayType, BoundArrayInitialization inits);
    private void EmitElementInitializers(ArrayTypeSymbol arrayType, ImmutableArray`1<BoundExpression> inits, bool includeConstants);
    private void EmitVectorElementInitializers(ArrayTypeSymbol arrayType, ImmutableArray`1<BoundExpression> inits, bool includeConstants);
    private static bool ShouldEmitInitExpression(bool includeConstants, BoundExpression init);
    private void EmitMultidimensionalElementInitializers(ArrayTypeSymbol arrayType, ImmutableArray`1<BoundExpression> inits, bool includeConstants);
    private void EmitAllElementInitializersRecursive(ArrayTypeSymbol arrayType, ArrayBuilder`1<IndexDesc> indices, bool includeConstants);
    private static ConstantValue AsConstOrDefault(BoundExpression init);
    private ArrayInitializerStyle ShouldEmitBlockInitializer(TypeSymbol elementType, ImmutableArray`1<BoundExpression> inits);
    private void InitializerCountRecursive(ImmutableArray`1<BoundExpression> inits, Int32& initCount, Int32& constInits);
    private ImmutableArray`1<byte> GetRawData(ImmutableArray`1<BoundExpression> initializers);
    private void SerializeArrayRecursive(BlobBuilder bw, ImmutableArray`1<BoundExpression> inits);
    private static bool IsMultidimensionalInitializer(ImmutableArray`1<BoundExpression> inits);
    private void EmitConversionExpression(BoundConversion conversion, bool used);
    private void EmitConversion(BoundConversion conversion);
    private void EmitIdentityConversion(BoundConversion conversion);
    private void EmitNumericConversion(BoundConversion conversion);
    private void EmitImplicitReferenceConversion(BoundConversion conversion);
    private void EmitExplicitReferenceConversion(BoundConversion conversion);
    private void EmitEnumConversion(BoundConversion conversion);
    private void EmitDelegateCreation(BoundExpression node, BoundExpression receiver, bool isExtensionMethod, MethodSymbol method, TypeSymbol delegateType, bool used);
    private MethodSymbol DelegateConstructor(CSharpSyntaxNode syntax, TypeSymbol delegateType);
    private void EmitMethodGroupConversion(BoundConversion conversion, bool used);
    private void EmitExpression(BoundExpression expression, bool used);
    private void EmitExpressionCoreWithStackGuard(BoundExpression expression, bool used);
    private void EmitExpressionCore(BoundExpression expression, bool used);
    private void EmitComplexConditionalReceiver(BoundComplexConditionalReceiver expression, bool used);
    private void EmitLoweredConditionalAccessExpression(BoundLoweredConditionalAccess expression, bool used);
    private void EmitConditionalReceiver(BoundConditionalReceiver expression, bool used);
    private void EmitRefValueOperator(BoundRefValueOperator expression, bool used);
    private void EmitMakeRefOperator(BoundMakeRefOperator expression, bool used);
    private void EmitRefTypeOperator(BoundRefTypeOperator expression, bool used);
    private void EmitArgList(bool used);
    private void EmitArgListOperator(BoundArgListOperator expression);
    private void EmitArgument(BoundExpression argument, RefKind refKind);
    private void EmitAddressOfExpression(BoundAddressOfOperator expression, bool used);
    private void EmitPointerIndirectionOperator(BoundPointerIndirectionOperator expression, bool used);
    private void EmitDupExpression(BoundDup expression, bool used);
    private void EmitDelegateCreationExpression(BoundDelegateCreationExpression expression, bool used);
    private void EmitThisReferenceExpression(BoundThisReference thisRef);
    private void EmitPseudoVariableValue(BoundPseudoVariable expression, bool used);
    private void EmitSequencePointExpression(BoundSequencePointExpression node, bool used);
    private void EmitSequencePoint(BoundSequencePointExpression node);
    private void EmitSequenceExpression(BoundSequence sequence, bool used);
    private void DefineLocals(BoundSequence sequence);
    private void FreeLocals(BoundSequence sequence, LocalSymbol doNotRelease);
    private void EmitSideEffects(BoundSequence sequence);
    private void EmitArguments(ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<ParameterSymbol> parameters);
    private void EmitArrayElementLoad(BoundArrayAccess arrayAccess, bool used);
    private void EmitFieldLoad(BoundFieldAccess fieldAccess, bool used);
    private LocalDefinition EmitFieldLoadReceiver(BoundExpression receiver);
    private bool EmitFieldLoadReceiverAddress(BoundExpression receiver);
    private bool FieldLoadPrefersRef(BoundExpression receiver);
    internal static bool FieldLoadMustUseRef(BoundExpression expr);
    private static int ParameterSlot(BoundParameter parameter);
    private void EmitLocalLoad(BoundLocal local, bool used);
    private void EmitParameterLoad(BoundParameter parameter);
    private void EmitLoadIndirect(TypeSymbol type, CSharpSyntaxNode syntaxNode);
    private bool CanUseCallOnRefTypeReceiver(BoundExpression receiver);
    private bool IsThisReceiver(BoundExpression receiver);
    private void EmitCallExpression(BoundCall call, bool used);
    private bool IsRef(BoundExpression receiver);
    private static int GetCallStackBehavior(BoundCall call);
    private static int GetObjCreationStackBehavior(BoundObjectCreationExpression objCreation);
    internal static bool MayUseCallForStructMethod(MethodSymbol method);
    private void TreatLongsAsNative(PrimitiveTypeCode tc);
    private void EmitArrayLength(BoundArrayLength expression, bool used);
    private void EmitArrayCreationExpression(BoundArrayCreation expression, bool used);
    private void EmitStackAllocArrayCreationExpression(BoundStackAllocArrayCreation expression, bool used);
    private void EmitObjectCreationExpression(BoundObjectCreationExpression expression, bool used);
    private void EmitAssignmentExpression(BoundAssignmentOperator assignmentOperator, bool used);
    private bool TryEmitAssignmentInPlace(BoundAssignmentOperator assignmentOperator, bool used);
    private bool SafeToGetWriteableReference(BoundExpression left);
    private void InPlaceInit(BoundExpression target, bool used);
    private void InPlaceCtorCall(BoundExpression target, BoundObjectCreationExpression objCreation, bool used);
    private bool PartialCtorResultCannotEscape(BoundExpression left);
    private static bool TargetIsNotOnHeap(BoundExpression left);
    private bool EmitAssignmentPreamble(BoundAssignmentOperator assignmentOperator);
    private void EmitAssignmentValue(BoundAssignmentOperator assignmentOperator);
    private LocalDefinition EmitAssignmentDuplication(BoundAssignmentOperator assignmentOperator, bool used, bool lhsUsesStack);
    private void EmitStore(BoundAssignmentOperator assignment);
    private void EmitAssignmentPostfix(LocalDefinition temp);
    private void EmitThisStore(BoundThisReference thisRef);
    private void EmitArrayElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode);
    private void EmitVectorElementStore(ArrayTypeSymbol arrayType, CSharpSyntaxNode syntaxNode);
    private void EmitFieldStore(BoundFieldAccess fieldAccess);
    private void EmitParameterStore(BoundParameter parameter);
    private void EmitIndirectStore(TypeSymbol type, CSharpSyntaxNode syntaxNode);
    private void EmitPopIfUnused(bool used);
    private void EmitIsExpression(BoundIsOperator isOp, bool used);
    private void EmitAsExpression(BoundAsOperator asOp, bool used);
    private void EmitDefaultValue(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode);
    private void EmitDefaultExpression(BoundDefaultOperator expression, bool used);
    private void EmitConstantExpression(TypeSymbol type, ConstantValue constantValue, bool used, CSharpSyntaxNode syntaxNode);
    private void EmitInitObj(TypeSymbol type, bool used, CSharpSyntaxNode syntaxNode);
    private void EmitTypeOfExpression(BoundTypeOfOperator boundTypeOfOperator);
    private void EmitSizeOfExpression(BoundSizeOfOperator boundSizeOfOperator);
    private void EmitMethodInfoExpression(BoundMethodInfo node);
    private void EmitFieldInfoExpression(BoundFieldInfo node);
    private void EmitConditionalOperator(BoundConditionalOperator expr, bool used);
    private void EmitNullCoalescingOperator(BoundNullCoalescingOperator expr, bool used);
    private TypeSymbol StackMergeType(BoundExpression expr);
    private static bool IsVarianceCast(TypeSymbol to, TypeSymbol from);
    private void EmitStaticCast(TypeSymbol to, CSharpSyntaxNode syntax);
    private void EmitBox(TypeSymbol type, CSharpSyntaxNode syntaxNode);
    private void EmitUnaryOperatorExpression(BoundUnaryOperator expression, bool used);
    private void EmitBinaryOperatorExpression(BoundBinaryOperator expression, bool used);
    private void EmitBinaryOperator(BoundBinaryOperator expression);
    private void EmitBinaryOperatorSimple(BoundBinaryOperator expression);
    private void EmitBinaryOperatorInstruction(BoundBinaryOperator expression);
    private void EmitShortCircuitingOperator(BoundBinaryOperator condition, bool sense, bool stopSense, bool stopValue);
    private void EmitBinaryCondOperator(BoundBinaryOperator binOp, bool sense);
    private void EmitIsNotNullOrZero(BoundExpression comparand, ConstantValue nullOrZero);
    private void EmitIsNullOrZero(BoundExpression comparand, ConstantValue nullOrZero);
    private void EmitBinaryCondOperatorHelper(ILOpCode opCode, BoundExpression left, BoundExpression right, bool sense);
    private void EmitCondExpr(BoundExpression condition, bool sense);
    private void EmitUnaryCheckedOperatorExpression(BoundUnaryOperator expression, bool used);
    private void EmitConversionToEnumUnderlyingType(BoundBinaryOperator expression, bool checked);
    private void EmitBinaryCheckedOperatorInstruction(BoundBinaryOperator expression);
    private static bool OperatorHasSideEffects(BinaryOperatorKind kind);
    private void EmitIsSense(bool sense);
    private static bool IsUnsigned(SpecialType type);
    private static bool IsUnsignedBinaryOperator(BoundBinaryOperator op);
    private static bool IsConditional(BinaryOperatorKind opKind);
    private static bool IsFloat(BinaryOperatorKind opKind);
    private void EmitStatement(BoundStatement statement);
    private int EmitStatementAndCountInstructions(BoundStatement statement);
    private void EmitStatementList(BoundStatementList list);
    private void EmitNoOpStatement(BoundNoOpStatement statement);
    private void EmitThrowStatement(BoundThrowStatement node);
    private void EmitConditionalGoto(BoundConditionalGoto boundConditionalGoto);
    private static bool CanPassToBrfalse(TypeSymbol ts);
    private static BoundExpression TryReduce(BoundBinaryOperator condition, Boolean& sense);
    private static ILOpCode CodeForJump(BoundBinaryOperator op, bool sense, ILOpCode& revOpCode);
    private void EmitCondBranch(BoundExpression condition, Object& dest, bool sense);
    private void EmitCondBranchCoreWithStackGuard(BoundExpression condition, Object& dest, bool sense);
    private void EmitCondBranchCore(BoundExpression condition, Object& dest, bool sense);
    private void EmitSequenceCondBranch(BoundSequence sequence, Object& dest, bool sense);
    private void EmitLabelStatement(BoundLabelStatement boundLabelStatement);
    private void EmitGotoStatement(BoundGotoStatement boundGotoStatement);
    private bool IsLastBlockInMethod(BoundBlock block);
    private void EmitBlock(BoundBlock block);
    private void EmitStateMachineScope(BoundStateMachineScope scope);
    private bool ShouldUseIndirectReturn();
    private bool CanHandleReturnLabel(BoundReturnStatement boundReturnStatement);
    private void EmitReturnStatement(BoundReturnStatement boundReturnStatement);
    private void EmitTryStatement(BoundTryStatement statement, bool emitCatchesOnly);
    private void EmitCatchBlock(BoundCatchBlock catchBlock);
    private void EmitSwitchStatement(BoundSwitchStatement switchStatement);
    private static KeyValuePair`2[] GetSwitchCaseLabels(ImmutableArray`1<BoundSwitchSection> sections, LabelSymbol& fallThroughLabel);
    private void EmitConstantSwitchHeader(BoundExpression expression, LabelSymbol target);
    private void EmitSwitchHeader(BoundSwitchStatement switchStatement, BoundExpression expression, KeyValuePair`2[] switchCaseLabels, LabelSymbol fallThroughLabel);
    private void EmitStringSwitchJumpTable(BoundSwitchStatement switchStatement, KeyValuePair`2[] switchCaseLabels, LabelSymbol fallThroughLabel, LocalOrParameter key, CSharpSyntaxNode syntaxNode);
    private void EmitStringCompareAndBranch(LocalOrParameter key, SyntaxNode syntaxNode, ConstantValue stringConstant, object targetLabel, IReference stringEqualityMethodRef);
    private void EmitSwitchBody(ImmutableArray`1<LocalSymbol> locals, ImmutableArray`1<BoundSwitchSection> switchSections, GeneratedLabelSymbol breakLabel, CSharpSyntaxNode syntaxNode);
    private void EmitSwitchSection(BoundSwitchSection switchSection);
    private LocalDefinition GetLocal(BoundLocal localExpression);
    private LocalDefinition GetLocal(LocalSymbol symbol);
    private LocalDefinition DefineLocal(LocalSymbol local, CSharpSyntaxNode syntaxNode);
    private string GetLocalDebugName(ILocalSymbolInternal local, LocalDebugId& localId);
    private bool IsSlotReusable(LocalSymbol local);
    private void FreeLocal(LocalSymbol local);
    private LocalDefinition AllocateTemp(TypeSymbol type, SyntaxNode syntaxNode);
    private void FreeTemp(LocalDefinition temp);
    private void FreeOptTemp(LocalDefinition temp);
}
internal class Microsoft.CodeAnalysis.CSharp.CodeGen.DummyLocal : LocalSymbol {
    internal bool IsImportedFromMetadata { get; }
    internal LocalDeclarationKind DeclarationKind { get; }
    internal SynthesizedLocalKind SynthesizedKind { get; }
    internal SyntaxToken IdentifierToken { get; }
    internal bool IsPinned { get; }
    public Symbol ContainingSymbol { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal bool IsCompilerGenerated { get; }
    internal RefKind RefKind { get; }
    internal virtual bool get_IsImportedFromMetadata();
    internal virtual LocalDeclarationKind get_DeclarationKind();
    internal virtual SynthesizedLocalKind get_SynthesizedKind();
    internal virtual LocalSymbol WithSynthesizedLocalKindAndSyntax(SynthesizedLocalKind kind, SyntaxNode syntax);
    internal virtual SyntaxToken get_IdentifierToken();
    internal virtual bool get_IsPinned();
    public virtual Symbol get_ContainingSymbol();
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual ConstantValue GetConstantValue(SyntaxNode node, LocalSymbol inProgress, DiagnosticBag diagnostics);
    internal virtual bool get_IsCompilerGenerated();
    internal virtual ImmutableArray`1<Diagnostic> GetConstantValueDiagnostics(BoundExpression boundInitValue);
    internal virtual SyntaxNode GetDeclaratorSyntax();
    internal virtual RefKind get_RefKind();
}
internal enum Microsoft.CodeAnalysis.CSharp.CodeGen.ExprContext : Enum {
    public int value__;
    public static ExprContext None;
    public static ExprContext Sideeffects;
    public static ExprContext Value;
    public static ExprContext Address;
    public static ExprContext AssignmentTarget;
    public static ExprContext Box;
}
internal class Microsoft.CodeAnalysis.CSharp.CodeGen.LocalDefUseInfo : object {
    [CompilerGeneratedAttribute]
private int <StackAtDeclaration>k__BackingField;
    private ObjectPool`1<LocalDefUseInfo> _pool;
    private static ObjectPool`1<LocalDefUseInfo> s_poolInstance;
    private ArrayBuilder`1<LocalDefUseSpan> _localDefs;
    [CompilerGeneratedAttribute]
private bool <CannotSchedule>k__BackingField;
    public int StackAtDeclaration { get; private set; }
    public ArrayBuilder`1<LocalDefUseSpan> LocalDefs { get; }
    public bool CannotSchedule { get; private set; }
    private LocalDefUseInfo(ObjectPool`1<LocalDefUseInfo> pool);
    private static LocalDefUseInfo();
    [CompilerGeneratedAttribute]
public int get_StackAtDeclaration();
    [CompilerGeneratedAttribute]
private void set_StackAtDeclaration(int value);
    public ArrayBuilder`1<LocalDefUseSpan> get_LocalDefs();
    [CompilerGeneratedAttribute]
public bool get_CannotSchedule();
    [CompilerGeneratedAttribute]
private void set_CannotSchedule(bool value);
    public void ShouldNotSchedule();
    public void Free();
    public static ObjectPool`1<LocalDefUseInfo> CreatePool();
    public static LocalDefUseInfo GetInstance(int stackAtDeclaration);
}
internal class Microsoft.CodeAnalysis.CSharp.CodeGen.LocalDefUseSpan : ValueType {
    public int Start;
    public int End;
    public LocalDefUseSpan(int start);
    private LocalDefUseSpan(int start, int end);
    internal LocalDefUseSpan WithEnd(int end);
    public virtual string ToString();
    public bool ConflictsWith(LocalDefUseSpan other);
    private bool Contains(int val);
    public bool ConflictsWithDummy(LocalDefUseSpan dummy);
    private bool Includes(int val);
}
internal class Microsoft.CodeAnalysis.CSharp.CodeGen.Optimizer : object {
    public static BoundStatement Optimize(BoundStatement src, bool debugFriendly, HashSet`1& stackLocals);
    private static void FilterValidStackLocals(Dictionary`2<LocalSymbol, LocalDefUseInfo> info);
    private static void RemoveIntersectingLocals(Dictionary`2<LocalSymbol, LocalDefUseInfo> info, ArrayBuilder`1<LocalDefUseInfo> dummies);
}
internal class Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1 : BoundTreeRewriter {
    private bool _debugFriendly;
    private ArrayBuilder`1<ValueTuple`2<BoundExpression, ExprContext>> _evalStack;
    private int _counter;
    private ExprContext _context;
    private BoundLocal _assignmentLocal;
    private Dictionary`2<LocalSymbol, LocalDefUseInfo> _locals;
    private SmallDictionary`2<object, DummyLocal> _dummyVariables;
    public static DummyLocal empty;
    private int _recursionDepth;
    private StackOptimizerPass1(Dictionary`2<LocalSymbol, LocalDefUseInfo> locals, ArrayBuilder`1<ValueTuple`2<BoundExpression, ExprContext>> evalStack, bool debugFriendly);
    private static StackOptimizerPass1();
    public static BoundNode Analyze(BoundNode node, Dictionary`2<LocalSymbol, LocalDefUseInfo> locals, bool debugFriendly);
    public virtual BoundNode Visit(BoundNode node);
    private BoundExpression VisitExpressionCore(BoundExpression node, ExprContext context);
    private BoundExpression VisitExpression(BoundExpression node, ExprContext context);
    private BoundExpression VisitExpressionCoreWithStackGuard(BoundExpression node, ExprContext context);
    protected virtual BoundExpression VisitExpressionWithoutStackGuard(BoundExpression node);
    private void PushEvalStack(BoundExpression result, ExprContext context);
    private int StackDepth();
    private bool EvalStackIsEmpty();
    private void SetStackDepth(int depth);
    private void PopEvalStack();
    private void ClearEvalStack();
    public BoundNode VisitStatement(BoundNode node);
    public virtual BoundNode VisitBlock(BoundBlock node);
    public virtual BoundNode VisitSequence(BoundSequence node);
    private bool IsNestedLocalOfCompoundOperator(LocalSymbol local, BoundSequence node);
    public virtual BoundNode VisitExpressionStatement(BoundExpressionStatement node);
    public virtual BoundNode VisitLocal(BoundLocal node);
    public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node);
    private static bool IsIndirectAssignment(BoundAssignmentOperator node);
    private static bool IsIndirectOrInstanceFieldAssignment(BoundAssignmentOperator node);
    public virtual BoundNode VisitCall(BoundCall node);
    private BoundExpression VisitCallReceiver(BoundExpression receiver);
    private ImmutableArray`1<BoundExpression> VisitArguments(ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<ParameterSymbol> parameters);
    public virtual BoundNode VisitMakeRefOperator(BoundMakeRefOperator node);
    public virtual BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node);
    public virtual BoundNode VisitArrayAccess(BoundArrayAccess node);
    public virtual BoundNode VisitFieldAccess(BoundFieldAccess node);
    public virtual BoundNode VisitLabelStatement(BoundLabelStatement node);
    public virtual BoundNode VisitLabel(BoundLabel node);
    public virtual BoundNode VisitGotoStatement(BoundGotoStatement node);
    public virtual BoundNode VisitConditionalGoto(BoundConditionalGoto node);
    public virtual BoundNode VisitConditionalOperator(BoundConditionalOperator node);
    public virtual BoundNode VisitBinaryOperator(BoundBinaryOperator node);
    private BoundNode VisitBinaryOperatorSimple(BoundBinaryOperator node);
    public virtual BoundNode VisitNullCoalescingOperator(BoundNullCoalescingOperator node);
    public virtual BoundNode VisitLoweredConditionalAccess(BoundLoweredConditionalAccess node);
    public virtual BoundNode VisitComplexConditionalReceiver(BoundComplexConditionalReceiver node);
    public virtual BoundNode VisitUnaryOperator(BoundUnaryOperator node);
    public virtual BoundNode VisitSwitchStatement(BoundSwitchStatement node);
    public virtual BoundNode VisitSwitchSection(BoundSwitchSection node);
    public virtual BoundNode VisitSwitchLabel(BoundSwitchLabel node);
    public virtual BoundNode VisitTryStatement(BoundTryStatement node);
    public virtual BoundNode VisitCatchBlock(BoundCatchBlock node);
    public virtual BoundNode VisitStackAllocArrayCreation(BoundStackAllocArrayCreation node);
    public virtual BoundNode VisitArrayInitialization(BoundArrayInitialization node);
    public virtual BoundNode VisitAddressOfOperator(BoundAddressOfOperator node);
    public virtual BoundNode VisitReturnStatement(BoundReturnStatement node);
    private void EnsureOnlyEvalStack();
    private object GetStackStateCookie();
    private void EnsureStackState(object cookie);
    private void RecordBranch(LabelSymbol label);
    private void RecordLabel(LabelSymbol label);
    private void ShouldNotSchedule(LocalSymbol localSymbol);
    private void RecordVarRef(LocalSymbol local);
    private void RecordVarRead(LocalSymbol local);
    private bool EvalStackHasLocal(LocalSymbol local);
    private void RecordDummyWrite(LocalSymbol local);
    private void RecordVarWrite(LocalSymbol local);
    private bool CanScheduleToStack(LocalSymbol local);
    private void DeclareLocals(ImmutableArray`1<LocalSymbol> locals, int stack);
    private void DeclareLocal(LocalSymbol local, int stack);
}
internal class Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass2 : BoundTreeRewriterWithStackGuard {
    private int _nodeCounter;
    private Dictionary`2<LocalSymbol, LocalDefUseInfo> _info;
    private StackOptimizerPass2(Dictionary`2<LocalSymbol, LocalDefUseInfo> info);
    public static BoundStatement Rewrite(BoundStatement src, Dictionary`2<LocalSymbol, LocalDefUseInfo> info);
    public virtual BoundNode Visit(BoundNode node);
    public virtual BoundNode VisitBinaryOperator(BoundBinaryOperator node);
    private static bool IsLastAccess(LocalDefUseInfo locInfo, int counter);
    public virtual BoundNode VisitLocal(BoundLocal node);
    public virtual BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node);
    public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node);
    public virtual BoundNode VisitCatchBlock(BoundCatchBlock node);
}
internal class Microsoft.CodeAnalysis.CSharp.CommandLineDiagnosticFormatter : CSharpDiagnosticFormatter {
    private string _baseDirectory;
    private Lazy`1<string> _lazyNormalizedBaseDirectory;
    private bool _displayFullPaths;
    private bool _displayEndLocations;
    internal CommandLineDiagnosticFormatter(string baseDirectory, bool displayFullPaths, bool displayEndLocations);
    internal virtual string FormatSourceSpan(LinePositionSpan span, IFormatProvider formatter);
    internal virtual string FormatSourcePath(string path, string basePath, IFormatProvider formatter);
    internal string RelativizeNormalizedPath(string normalizedPath);
}
internal class Microsoft.CodeAnalysis.CSharp.ConstantFieldsInProgress : object {
    private SourceFieldSymbol _fieldOpt;
    private HashSet`1<SourceFieldSymbolWithSyntaxReference> _dependencies;
    internal static ConstantFieldsInProgress Empty;
    public bool IsEmpty { get; }
    internal ConstantFieldsInProgress(SourceFieldSymbol fieldOpt, HashSet`1<SourceFieldSymbolWithSyntaxReference> dependencies);
    private static ConstantFieldsInProgress();
    public bool get_IsEmpty();
    internal void AddDependency(SourceFieldSymbolWithSyntaxReference field);
}
internal class Microsoft.CodeAnalysis.CSharp.ConstantFieldsInProgressBinder : Binder {
    private ConstantFieldsInProgress _inProgress;
    internal ConstantFieldsInProgress ConstantFieldsInProgress { get; }
    internal ConstantFieldsInProgressBinder(ConstantFieldsInProgress inProgress, Binder next);
    internal virtual ConstantFieldsInProgress get_ConstantFieldsInProgress();
}
internal class Microsoft.CodeAnalysis.CSharp.ContextualAttributeBinder : Binder {
    private Symbol _attributeTarget;
    private Symbol _attributedMember;
    internal Symbol AttributedMember { get; }
    internal Symbol AttributeTarget { get; }
    public ContextualAttributeBinder(Binder enclosing, Symbol symbol);
    internal Symbol get_AttributedMember();
    private static Symbol GetAttributedMember(Symbol symbol);
    internal Symbol get_AttributeTarget();
}
internal class Microsoft.CodeAnalysis.CSharp.ControlFlowPass : AbstractFlowPass`1<LocalState> {
    private PooledHashSet`1<LabelSymbol> _labelsDefined;
    private PooledHashSet`1<LabelSymbol> _labelsUsed;
    protected bool _convertInsufficientExecutionStackExceptionToCancelledByStackGuardException;
    internal ControlFlowPass(CSharpCompilation compilation, Symbol member, BoundNode node);
    internal ControlFlowPass(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion);
    protected virtual void Free();
    protected virtual void UnionWith(LocalState& self, LocalState& other);
    protected virtual bool IntersectWith(LocalState& self, LocalState& other);
    protected virtual string Dump(LocalState state);
    protected virtual LocalState ReachableState();
    protected virtual LocalState UnreachableState();
    protected virtual LocalState LabelState(LabelSymbol label);
    public virtual BoundNode Visit(BoundNode node);
    protected virtual ImmutableArray`1<PendingBranch<LocalState>> Scan(Boolean& badRegion);
    public static bool Analyze(CSharpCompilation compilation, Symbol member, BoundBlock block, DiagnosticBag diagnostics);
    protected virtual bool ConvertInsufficientExecutionStackExceptionToCancelledByStackGuardException();
    protected bool Analyze(Boolean& badRegion, DiagnosticBag diagnostics);
    protected virtual ImmutableArray`1<PendingBranch<LocalState>> RemoveReturns();
    protected virtual void VisitStatement(BoundStatement statement);
    private void CheckReachable(BoundStatement statement);
    protected virtual void VisitTryBlock(BoundStatement tryBlock, BoundTryStatement node, LocalState& tryState);
    protected virtual void VisitCatchBlock(BoundCatchBlock catchBlock, LocalState& finallyState);
    protected virtual void VisitFinallyBlock(BoundStatement finallyBlock, LocalState& endState);
    protected virtual void VisitLabel(BoundLabeledStatement node);
    public virtual BoundNode VisitLabeledStatement(BoundLabeledStatement node);
    public virtual BoundNode VisitGotoStatement(BoundGotoStatement node);
    protected virtual void VisitSwitchSectionLabel(LabelSymbol label, BoundSwitchSection node);
    public virtual BoundNode VisitSwitchSection(BoundSwitchSection node, bool lastSection);
}
public class Microsoft.CodeAnalysis.CSharp.Conversion : ValueType {
    internal static Conversion NoConversion;
    internal static Conversion Identity;
    internal static Conversion ImplicitNumeric;
    internal static Conversion ImplicitNullable;
    internal static Conversion ImplicitReference;
    internal static Conversion ImplicitEnumeration;
    internal static Conversion AnonymousFunction;
    internal static Conversion Boxing;
    internal static Conversion NullLiteral;
    internal static Conversion NullToPointer;
    internal static Conversion PointerToVoid;
    internal static Conversion PointerToPointer;
    internal static Conversion PointerToInteger;
    internal static Conversion IntegerToPointer;
    internal static Conversion Unboxing;
    internal static Conversion ExplicitReference;
    internal static Conversion IntPtr;
    internal static Conversion ExplicitEnumeration;
    internal static Conversion ExplicitNullable;
    internal static Conversion ExplicitNumeric;
    internal static Conversion ImplicitDynamic;
    internal static Conversion ExplicitDynamic;
    internal static Conversion InterpolatedString;
    private MethodSymbol _methodGroupConversionMethod;
    private UserDefinedConversionResult _conversionResult;
    internal ConversionKind Kind;
    private byte _flags;
    private static byte IsExtensionMethodMask;
    private static byte IsArrayIndexMask;
    internal bool IsExtensionMethod { get; }
    internal bool IsArrayIndex { get; }
    internal bool IsValid { get; }
    public bool Exists { get; }
    public bool IsImplicit { get; }
    public bool IsExplicit { get; }
    public bool IsIdentity { get; }
    public bool IsNumeric { get; }
    public bool IsEnumeration { get; }
    public bool IsInterpolatedString { get; }
    public bool IsNullable { get; }
    public bool IsReference { get; }
    public bool IsUserDefined { get; }
    public bool IsBoxing { get; }
    public bool IsUnboxing { get; }
    public bool IsNullLiteral { get; }
    public bool IsDynamic { get; }
    public bool IsConstantExpression { get; }
    public bool IsAnonymousFunction { get; }
    public bool IsMethodGroup { get; }
    public bool IsPointer { get; }
    public bool IsIntPtr { get; }
    internal MethodSymbol Method { get; }
    public IMethodSymbol MethodSymbol { get; }
    internal LookupResultKind ResultKind { get; }
    internal Conversion UserDefinedFromConversion { get; }
    internal Conversion UserDefinedToConversion { get; }
    internal ImmutableArray`1<MethodSymbol> OriginalUserDefinedConversions { get; }
    private MethodSymbol UserDefinedConversion { get; }
    internal UserDefinedConversionAnalysis BestUserDefinedConversionAnalysis { get; }
    private Conversion(ConversionKind kind, bool isExtensionMethod, bool isArrayIndex, UserDefinedConversionResult conversionResult, MethodSymbol methodGroupConversionMethod);
    internal Conversion(UserDefinedConversionResult conversionResult, bool isImplicit);
    internal Conversion(ConversionKind kind);
    internal Conversion(ConversionKind kind, MethodSymbol methodGroupConversionMethod, bool isExtensionMethod);
    private static Conversion();
    internal bool get_IsExtensionMethod();
    internal bool get_IsArrayIndex();
    internal Conversion ToArrayIndexConversion();
    internal bool get_IsValid();
    public bool get_Exists();
    public bool get_IsImplicit();
    public bool get_IsExplicit();
    public bool get_IsIdentity();
    public bool get_IsNumeric();
    public bool get_IsEnumeration();
    public bool get_IsInterpolatedString();
    public bool get_IsNullable();
    public bool get_IsReference();
    public bool get_IsUserDefined();
    public bool get_IsBoxing();
    public bool get_IsUnboxing();
    public bool get_IsNullLiteral();
    public bool get_IsDynamic();
    public bool get_IsConstantExpression();
    public bool get_IsAnonymousFunction();
    public bool get_IsMethodGroup();
    public bool get_IsPointer();
    public bool get_IsIntPtr();
    internal MethodSymbol get_Method();
    public IMethodSymbol get_MethodSymbol();
    internal LookupResultKind get_ResultKind();
    internal Conversion get_UserDefinedFromConversion();
    internal Conversion get_UserDefinedToConversion();
    internal ImmutableArray`1<MethodSymbol> get_OriginalUserDefinedConversions();
    private MethodSymbol get_UserDefinedConversion();
    internal UserDefinedConversionAnalysis get_BestUserDefinedConversionAnalysis();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Conversion other);
    public virtual int GetHashCode();
    public static bool op_Equality(Conversion left, Conversion right);
    public static bool op_Inequality(Conversion left, Conversion right);
}
internal enum Microsoft.CodeAnalysis.CSharp.ConversionKind : Enum {
    public byte value__;
    public static ConversionKind NoConversion;
    public static ConversionKind Identity;
    public static ConversionKind ImplicitNumeric;
    public static ConversionKind ImplicitEnumeration;
    public static ConversionKind ImplicitNullable;
    public static ConversionKind NullLiteral;
    public static ConversionKind ImplicitReference;
    public static ConversionKind Boxing;
    public static ConversionKind PointerToVoid;
    public static ConversionKind NullToPointer;
    public static ConversionKind ImplicitDynamic;
    public static ConversionKind ExplicitDynamic;
    public static ConversionKind ImplicitConstant;
    public static ConversionKind ImplicitUserDefined;
    public static ConversionKind AnonymousFunction;
    public static ConversionKind MethodGroup;
    public static ConversionKind ExplicitNumeric;
    public static ConversionKind ExplicitEnumeration;
    public static ConversionKind ExplicitNullable;
    public static ConversionKind ExplicitReference;
    public static ConversionKind Unboxing;
    public static ConversionKind ExplicitUserDefined;
    public static ConversionKind PointerToPointer;
    public static ConversionKind IntegerToPointer;
    public static ConversionKind PointerToInteger;
    public static ConversionKind IntPtr;
    public static ConversionKind InterpolatedString;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.ConversionKindExtensions : object {
    [ExtensionAttribute]
public static bool IsDynamic(ConversionKind conversionKind);
    [ExtensionAttribute]
public static bool IsImplicitConversion(ConversionKind conversionKind);
    [ExtensionAttribute]
public static bool IsUserDefinedConversion(ConversionKind conversionKind);
    [ExtensionAttribute]
public static bool IsPointerConversion(ConversionKind kind);
}
internal class Microsoft.CodeAnalysis.CSharp.Conversions : ConversionsBase {
    private Binder _binder;
    private CSharpCompilation Compilation { get; }
    public Conversions(Binder binder);
    private Conversions(Binder binder, int currentRecursionDepth);
    protected virtual ConversionsBase CreateInstance(int currentRecursionDepth);
    private CSharpCompilation get_Compilation();
    public virtual Conversion GetMethodGroupConversion(BoundMethodGroup source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    protected virtual Conversion GetInterpolatedStringConversion(BoundInterpolatedString source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private static MethodGroupResolution ResolveDelegateMethodGroup(Binder binder, BoundMethodGroup source, MethodSymbol delegateInvokeMethodOpt, HashSet`1& useSiteDiagnostics);
    private static MethodSymbol GetDelegateInvokeMethodIfAvailable(TypeSymbol type);
    public static bool ReportDelegateMethodGroupDiagnostics(Binder binder, BoundMethodGroup expr, TypeSymbol targetType, DiagnosticBag diagnostics);
    public Conversion MethodGroupConversion(CSharpSyntaxNode syntax, MethodGroup methodGroup, NamedTypeSymbol delegateType, HashSet`1& useSiteDiagnostics);
    public static void GetDelegateArguments(CSharpSyntaxNode syntax, AnalyzedArguments analyzedArguments, ImmutableArray`1<ParameterSymbol> delegateParameters, CSharpCompilation compilation);
    private static Conversion ToConversion(OverloadResolutionResult`1<MethodSymbol> result, MethodGroup methodGroup, NamedTypeSymbol delegateType);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.ConversionsBase : object {
    private static int MaximumRecursionDepth;
    protected AssemblySymbol corLibrary;
    private int _currentRecursionDepth;
    private static bool F;
    private static bool T;
    private static Boolean[0...,0...] s_implicitNumericConversions;
    private static Boolean[0...,0...] s_explicitNumericConversions;
    protected ConversionsBase(AssemblySymbol corLibrary, int currentRecursionDepth);
    private static ConversionsBase();
    public Conversion ClassifyConversionFromExpression(BoundExpression sourceExpression, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    public Conversion ClassifyConversionFromExpression(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    public Conversion ClassifyConversionFromExpression(BoundExpression sourceExpression, TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    public Conversion ClassifyConversionForCast(BoundExpression source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private Conversion ClassifyImplicitBuiltInConversionFromExpression(BoundExpression sourceExpression, TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    public Conversion ClassifyImplicitConversionFromExpression(BoundExpression sourceExpression, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    public Conversion ClassifyImplicitConversionFromExpression(TypeSymbol sourceExpressionType, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private Conversion ClassifyImplicitConversionFromExpression(BoundExpression sourceExpression, TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private static ConversionKind ClassifyNullLiteralConversion(BoundExpression source, TypeSymbol destination);
    private static ConversionKind ClassifyImplicitConstantExpressionConversion(BoundExpression source, TypeSymbol destination);
    internal static bool HasImplicitConstantExpressionConversion(BoundExpression source, TypeSymbol destination);
    private Conversion ClassifyExplicitOnlyConversionFromExpression(BoundExpression sourceExpression, TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private static bool HasImplicitEnumerationConversion(BoundExpression source, TypeSymbol destination);
    private static LambdaConversionResult IsAnonymousFunctionCompatibleWithDelegate(UnboundLambda anonymousFunction, TypeSymbol type);
    private static LambdaConversionResult IsAnonymousFunctionCompatibleWithExpressionTree(UnboundLambda anonymousFunction, NamedTypeSymbol type);
    public static LambdaConversionResult IsAnonymousFunctionCompatibleWithType(UnboundLambda anonymousFunction, TypeSymbol type);
    private bool HasAnonymousFunctionConversion(BoundExpression source, TypeSymbol destination);
    internal Conversion ClassifyImplicitUserDefinedConversionForSwitchGoverningType(TypeSymbol sourceType, TypeSymbol& switchGoverningType, HashSet`1& useSiteDiagnostics);
    internal Conversion GetCallerLineNumberConversion(TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    internal bool HasCallerLineNumberConversion(TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    internal bool HasCallerInfoStringConversion(TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    protected abstract virtual ConversionsBase CreateInstance(int currentRecursionDepth);
    public abstract virtual Conversion GetMethodGroupConversion(BoundMethodGroup source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    protected abstract virtual Conversion GetInterpolatedStringConversion(BoundInterpolatedString source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    public static Conversion FastClassifyConversion(TypeSymbol source, TypeSymbol target);
    public static bool IsBaseInterface(TypeSymbol baseType, TypeSymbol derivedType, HashSet`1& useSiteDiagnostics);
    public static bool IsBaseClassOfClass(TypeSymbol baseType, TypeSymbol derivedType, HashSet`1& useSiteDiagnostics);
    public static bool IsBaseClass(TypeSymbol derivedType, TypeSymbol baseType, HashSet`1& useSiteDiagnostics);
    public Conversion ClassifyConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics, bool builtinOnly);
    public Conversion ClassifyConversionForCast(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    public Conversion ClassifyStandardConversion(BoundExpression sourceExpression, TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    internal Conversion ClassifyStandardImplicitConversion(BoundExpression sourceExpression, TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    internal Conversion ClassifyStandardImplicitConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private Conversion ClassifyImplicitBuiltInConversionSlow(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private Conversion GetImplicitUserDefinedConversion(BoundExpression sourceExpression, TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    public Conversion ClassifyImplicitConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private Conversion ClassifyExplicitBuiltInOnlyConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private Conversion GetExplicitUserDefinedConversion(BoundExpression sourceExpression, TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    public static bool HasIdentityConversion(TypeSymbol type1, TypeSymbol type2);
    public static bool HasIdentityConversionToAny(T type, ArrayBuilder`1<T> targetTypes);
    public Conversion ConvertExtensionMethodThisArg(TypeSymbol parameterType, TypeSymbol thisType, HashSet`1& useSiteDiagnostics);
    public static bool IsValidExtensionMethodThisArgConversion(Conversion conversion);
    private static int GetNumericTypeIndex(SpecialType specialType);
    private static bool HasImplicitNumericConversion(TypeSymbol source, TypeSymbol destination);
    private static bool HasExplicitNumericConversion(TypeSymbol source, TypeSymbol destination);
    public static bool IsConstantNumericZero(ConstantValue value);
    public static bool IsNumericType(SpecialType specialType);
    private static bool HasSpecialIntPtrConversion(TypeSymbol source, TypeSymbol target);
    private static bool HasExplicitEnumerationConversion(TypeSymbol source, TypeSymbol destination);
    private static bool HasImplicitNullableConversion(TypeSymbol source, TypeSymbol destination);
    private static bool HasExplicitNullableConversion(TypeSymbol source, TypeSymbol destination);
    private bool HasCovariantArrayConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    public bool HasIdentityOrImplicitReferenceConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private static bool HasImplicitDynamicConversionFromExpression(TypeSymbol expressionType, TypeSymbol destination);
    private static bool HasExplicitDynamicConversion(TypeSymbol source, TypeSymbol destination);
    private bool HasArrayConversionToInterface(ArrayTypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private bool HasImplicitReferenceConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private bool HasImplicitConversionToInterface(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private bool HasImplicitConversionFromArray(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private bool HasImplicitConversionFromDelegate(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    public bool HasImplicitTypeParameterConversion(TypeParameterSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private bool HasImplicitReferenceTypeParameterConversion(TypeParameterSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private bool HasImplicitEffectiveBaseConversion(TypeParameterSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private bool HasImplicitEffectiveInterfaceSetConversion(TypeParameterSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private bool HasAnyBaseInterfaceConversion(TypeSymbol derivedType, TypeSymbol baseType, HashSet`1& useSiteDiagnostics);
    private bool HasInterfaceVarianceConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private bool HasDelegateVarianceConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private bool HasVariantConversion(NamedTypeSymbol source, NamedTypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private static ThreeState HasVariantConversionQuick(NamedTypeSymbol source, NamedTypeSymbol destination);
    private bool HasVariantConversionNoCycleCheck(NamedTypeSymbol source, NamedTypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private bool HasImplicitBoxingTypeParameterConversion(TypeParameterSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    public bool HasBoxingConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private static bool HasImplicitPointerConversion(TypeSymbol source, TypeSymbol destination);
    private bool HasIdentityOrReferenceConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private bool HasExplicitReferenceConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private bool HasExplicitReferenceTypeParameterConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private bool HasUnboxingTypeParameterConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private bool HasExplicitDelegateConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private bool HasExplicitArrayConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private bool HasUnboxingConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private static bool HasPointerToPointerConversion(TypeSymbol source, TypeSymbol destination);
    private static bool HasPointerToIntegerConversion(TypeSymbol source, TypeSymbol destination);
    private static bool HasIntegerToPointerConversion(TypeSymbol source, TypeSymbol destination);
    private static TypeSymbol GetUnderlyingEffectiveType(TypeSymbol type, HashSet`1& useSiteDiagnostics);
    public static void AddTypesParticipatingInUserDefinedConversion(ArrayBuilder`1<NamedTypeSymbol> result, TypeSymbol type, bool includeBaseTypes, HashSet`1& useSiteDiagnostics);
    private UserDefinedConversionResult AnalyzeExplicitUserDefinedConversions(BoundExpression sourceExpression, TypeSymbol source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private static void ComputeUserDefinedExplicitConversionTypeSet(TypeSymbol source, TypeSymbol target, ArrayBuilder`1<NamedTypeSymbol> d, HashSet`1& useSiteDiagnostics);
    private void ComputeApplicableUserDefinedExplicitConversionSet(BoundExpression sourceExpression, TypeSymbol source, TypeSymbol target, ArrayBuilder`1<NamedTypeSymbol> d, ArrayBuilder`1<UserDefinedConversionAnalysis> u, HashSet`1& useSiteDiagnostics);
    private void AddUserDefinedConversionsToExplicitCandidateSet(BoundExpression sourceExpression, TypeSymbol source, TypeSymbol target, ArrayBuilder`1<UserDefinedConversionAnalysis> u, NamedTypeSymbol declaringType, string operatorName, HashSet`1& useSiteDiagnostics);
    private TypeSymbol MostSpecificSourceTypeForExplicitUserDefinedConversion(ImmutableArray`1<UserDefinedConversionAnalysis> u, BoundExpression sourceExpression, TypeSymbol source, HashSet`1& useSiteDiagnostics);
    private TypeSymbol MostSpecificTargetTypeForExplicitUserDefinedConversion(ImmutableArray`1<UserDefinedConversionAnalysis> u, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private Conversion EncompassingExplicitConversion(BoundExpression expr, TypeSymbol a, TypeSymbol b, HashSet`1& useSiteDiagnostics);
    private UserDefinedConversionResult AnalyzeImplicitUserDefinedConversions(BoundExpression sourceExpression, TypeSymbol source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private static void ComputeUserDefinedImplicitConversionTypeSet(TypeSymbol s, TypeSymbol t, ArrayBuilder`1<NamedTypeSymbol> d, HashSet`1& useSiteDiagnostics);
    private void ComputeApplicableUserDefinedImplicitConversionSet(BoundExpression sourceExpression, TypeSymbol source, TypeSymbol target, ArrayBuilder`1<NamedTypeSymbol> d, ArrayBuilder`1<UserDefinedConversionAnalysis> u, HashSet`1& useSiteDiagnostics, bool allowAnyTarget);
    private TypeSymbol MostSpecificSourceTypeForImplicitUserDefinedConversion(ImmutableArray`1<UserDefinedConversionAnalysis> u, TypeSymbol source, HashSet`1& useSiteDiagnostics);
    private TypeSymbol MostSpecificTargetTypeForImplicitUserDefinedConversion(ImmutableArray`1<UserDefinedConversionAnalysis> u, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private static int LiftingCount(UserDefinedConversionAnalysis conv);
    private static Nullable`1<int> MostSpecificConversionOperator(TypeSymbol sx, TypeSymbol tx, ImmutableArray`1<UserDefinedConversionAnalysis> u);
    private static Nullable`1<int> MostSpecificConversionOperator(Func`2<UserDefinedConversionAnalysis, bool> constraint, ImmutableArray`1<UserDefinedConversionAnalysis> u);
    private static BestIndex UniqueIndex(ImmutableArray`1<T> items, Func`2<T, bool> predicate);
    private bool IsEncompassedBy(BoundExpression aExpr, TypeSymbol a, TypeSymbol b, HashSet`1& useSiteDiagnostics);
    private Conversion EncompassingImplicitConversion(BoundExpression aExpr, TypeSymbol a, TypeSymbol b, HashSet`1& useSiteDiagnostics);
    private static bool IsEncompassingImplicitConversionKind(ConversionKind kind);
    private TypeSymbol MostEncompassedType(ImmutableArray`1<T> items, Func`2<T, TypeSymbol> extract, HashSet`1& useSiteDiagnostics);
    private TypeSymbol MostEncompassedType(ImmutableArray`1<T> items, Func`2<T, bool> valid, Func`2<T, TypeSymbol> extract, HashSet`1& useSiteDiagnostics);
    private TypeSymbol MostEncompassingType(ImmutableArray`1<T> items, Func`2<T, TypeSymbol> extract, HashSet`1& useSiteDiagnostics);
    private TypeSymbol MostEncompassingType(ImmutableArray`1<T> items, Func`2<T, bool> valid, Func`2<T, TypeSymbol> extract, HashSet`1& useSiteDiagnostics);
    private static Nullable`1<int> UniqueBestValidIndex(ImmutableArray`1<T> items, Func`2<T, bool> valid, Func`3<T, T, BetterResult> better);
    private NamedTypeSymbol MakeNullableType(TypeSymbol type);
    protected UserDefinedConversionResult AnalyzeImplicitUserDefinedConversionForSwitchGoverningType(TypeSymbol source, HashSet`1& useSiteDiagnostics);
}
internal class Microsoft.CodeAnalysis.CSharp.CSDiagnostic : DiagnosticWithInfo {
    internal CSDiagnostic(DiagnosticInfo info, Location location, bool isSuppressed);
    public virtual string ToString();
    internal virtual Diagnostic WithLocation(Location location);
    internal virtual Diagnostic WithSeverity(DiagnosticSeverity severity);
    internal virtual Diagnostic WithIsSuppressed(bool isSuppressed);
}
internal class Microsoft.CodeAnalysis.CSharp.CSDiagnosticInfo : DiagnosticInfoWithSymbols {
    public static DiagnosticInfo EmptyErrorInfo;
    public static DiagnosticInfo VoidDiagnosticInfo;
    private ImmutableArray`1<Location> _additionalLocations;
    public IReadOnlyList`1<Location> AdditionalLocations { get; }
    internal ErrorCode Code { get; }
    internal CSDiagnosticInfo(ErrorCode code);
    internal CSDiagnosticInfo(ErrorCode code, Object[] args);
    internal CSDiagnosticInfo(ErrorCode code, ImmutableArray`1<Symbol> symbols, Object[] args);
    internal CSDiagnosticInfo(ErrorCode code, Object[] args, ImmutableArray`1<Symbol> symbols, ImmutableArray`1<Location> additionalLocations);
    private CSDiagnosticInfo(bool isWarningAsError, ErrorCode code, Object[] args, ImmutableArray`1<Symbol> symbols, ImmutableArray`1<Location> additionalLocations);
    private static CSDiagnosticInfo();
    public virtual IReadOnlyList`1<Location> get_AdditionalLocations();
    internal ErrorCode get_Code();
    internal static bool IsEmpty(DiagnosticInfo info);
}
public class Microsoft.CodeAnalysis.CSharp.CSharpCommandLineArguments : CommandLineArguments {
    [CompilerGeneratedAttribute]
private CSharpCompilationOptions <CompilationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpParseOptions <ParseOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldIncludeErrorEndLocation>k__BackingField;
    public CSharpCompilationOptions CompilationOptions { get; internal set; }
    public CSharpParseOptions ParseOptions { get; internal set; }
    protected ParseOptions ParseOptionsCore { get; }
    protected CompilationOptions CompilationOptionsCore { get; }
    internal bool ShouldIncludeErrorEndLocation { get; internal set; }
    [CompilerGeneratedAttribute]
public CSharpCompilationOptions get_CompilationOptions();
    [CompilerGeneratedAttribute]
internal void set_CompilationOptions(CSharpCompilationOptions value);
    [CompilerGeneratedAttribute]
public CSharpParseOptions get_ParseOptions();
    [CompilerGeneratedAttribute]
internal void set_ParseOptions(CSharpParseOptions value);
    protected virtual ParseOptions get_ParseOptionsCore();
    protected virtual CompilationOptions get_CompilationOptionsCore();
    [CompilerGeneratedAttribute]
internal bool get_ShouldIncludeErrorEndLocation();
    [CompilerGeneratedAttribute]
internal void set_ShouldIncludeErrorEndLocation(bool value);
}
public class Microsoft.CodeAnalysis.CSharp.CSharpCommandLineParser : CommandLineParser {
    [CompilerGeneratedAttribute]
private static CSharpCommandLineParser <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static CSharpCommandLineParser <ScriptRunner>k__BackingField;
    public static CSharpCommandLineParser Default { get; }
    internal static CSharpCommandLineParser ScriptRunner { get; }
    protected string RegularFileExtension { get; }
    protected string ScriptFileExtension { get; }
    internal CSharpCommandLineParser(bool isScriptRunner);
    private static CSharpCommandLineParser();
    [CompilerGeneratedAttribute]
public static CSharpCommandLineParser get_Default();
    [CompilerGeneratedAttribute]
internal static CSharpCommandLineParser get_ScriptRunner();
    protected virtual string get_RegularFileExtension();
    protected virtual string get_ScriptFileExtension();
    internal sealed virtual CommandLineArguments CommonParse(IEnumerable`1<string> args, string baseDirectory, string sdkDirectoryOpt, string additionalReferenceDirectories);
    public CSharpCommandLineArguments Parse(IEnumerable`1<string> args, string baseDirectory, string sdkDirectory, string additionalReferenceDirectories);
    private static void ParseAndResolveReferencePaths(string switchName, string switchValue, string baseDirectory, List`1<string> builder, MessageID origin, List`1<Diagnostic> diagnostics);
    private static string GetWin32Setting(string arg, string value, List`1<Diagnostic> diagnostics);
    private void GetCompilationAndModuleNames(List`1<Diagnostic> diagnostics, OutputKind outputKind, List`1<CommandLineSourceFile> sourceFiles, bool sourceFilesSpecified, string moduleAssemblyName, String& outputFileName, String& moduleName, String& compilationName);
    private static ImmutableArray`1<string> BuildSearchPaths(string sdkDirectoryOpt, List`1<string> libPaths);
    public static IEnumerable`1<string> ParseConditionalCompilationSymbols(string value, IEnumerable`1& diagnostics);
    private static Platform ParsePlatform(string value, IList`1<Diagnostic> diagnostics);
    private static OutputKind ParseTarget(string value, IList`1<Diagnostic> diagnostics);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CSharpCommandLineParser/<ParseUsings>d__20")]
private static IEnumerable`1<string> ParseUsings(string arg, string value, IList`1<Diagnostic> diagnostics);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CSharpCommandLineParser/<ParseAnalyzers>d__21")]
private IEnumerable`1<CommandLineAnalyzerReference> ParseAnalyzers(string arg, string value, List`1<Diagnostic> diagnostics);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CSharpCommandLineParser/<ParseAssemblyReferences>d__22")]
private IEnumerable`1<CommandLineReference> ParseAssemblyReferences(string arg, string value, IList`1<Diagnostic> diagnostics, bool embedInteropTypes);
    private static void ValidateWin32Settings(string win32ResourceFile, string win32IconResourceFile, string win32ManifestFile, OutputKind outputKind, IList`1<Diagnostic> diagnostics);
    internal static ResourceDescription ParseResourceDescription(string arg, string resourceDescriptor, string baseDirectory, IList`1<Diagnostic> diagnostics, bool embedded);
    private static bool TryParseLanguageVersion(string str, LanguageVersion defaultVersion, LanguageVersion& version);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CSharpCommandLineParser/<ParseWarnings>d__26")]
private static IEnumerable`1<string> ParseWarnings(string value);
    private static void AddWarnings(Dictionary`2<string, ReportDiagnostic> d, ReportDiagnostic kind, IEnumerable`1<string> items);
    private static void UnimplementedSwitch(IList`1<Diagnostic> diagnostics, string switchName);
    private static void UnimplementedSwitchValue(IList`1<Diagnostic> diagnostics, string switchName, string value);
    internal virtual void GenerateErrorForNoFilesFoundInRecurse(string path, IList`1<Diagnostic> diagnostics);
    private static void AddDiagnostic(IList`1<Diagnostic> diagnostics, ErrorCode errorCode);
    private static void AddDiagnostic(IList`1<Diagnostic> diagnostics, ErrorCode errorCode, Object[] arguments);
    private static void AddDiagnostic(IList`1<Diagnostic> diagnostics, Dictionary`2<string, ReportDiagnostic> warningOptions, ErrorCode errorCode, Object[] arguments);
}
public class Microsoft.CodeAnalysis.CSharp.CSharpCompilation : Compilation {
    internal static ParallelOptions DefaultParallelOptions;
    private CSharpCompilationOptions _options;
    private Lazy`1<Imports> _globalImports;
    private Lazy`1<Imports> _previousSubmissionImports;
    private Lazy`1<AliasSymbol> _globalNamespaceAlias;
    private Lazy`1<ImplicitNamedTypeSymbol> _scriptClass;
    private ConcurrentSet`1<ImportInfo> _lazyImportInfos;
    private ImmutableArray`1<Diagnostic> _lazyClsComplianceDiagnostics;
    private Conversions _conversions;
    private AnonymousTypeManager _anonymousTypeManager;
    private NamespaceSymbol _lazyGlobalNamespace;
    internal BuiltInOperators builtInOperators;
    private SourceAssemblySymbol _lazyAssemblySymbol;
    private ReferenceManager _referenceManager;
    private SyntaxAndDeclarationManager _syntaxAndDeclarations;
    private EntryPoint _lazyEntryPoint;
    private HashSet`1<SyntaxTree> _lazyCompilationUnitCompletedTrees;
    [CompilerGeneratedAttribute]
private LanguageVersion <LanguageVersion>k__BackingField;
    private static CSharpCompilationOptions s_defaultOptions;
    private static CSharpCompilationOptions s_defaultSubmissionOptions;
    [CompilerGeneratedAttribute]
private CSharpScriptCompilationInfo <ScriptCompilationInfo>k__BackingField;
    private ConcurrentDictionary`2<string, NamespaceSymbol> _externAliasTargets;
    private TypeSymbol _lazyHostObjectTypeSymbol;
    private WeakReference`1[] _binderFactories;
    private DiagnosticBag _lazyDeclarationDiagnostics;
    private bool _declarationDiagnosticsFrozen;
    private DiagnosticBag _additionalCodegenWarnings;
    private WellKnownMembersSignatureComparer _wellKnownMemberSignatureComparer;
    private NamedTypeSymbol[] _lazyWellKnownTypes;
    private Symbol[] _lazyWellKnownTypeMembers;
    internal Conversions Conversions { get; }
    public string Language { get; }
    public bool IsCaseSensitive { get; }
    public CSharpCompilationOptions Options { get; }
    internal AnonymousTypeManager AnonymousTypeManager { get; }
    internal CommonAnonymousTypeManager CommonAnonymousTypeManager { get; }
    internal bool FeatureStrictEnabled { get; }
    public LanguageVersion LanguageVersion { get; }
    public CSharpScriptCompilationInfo ScriptCompilationInfo { get; }
    internal ScriptCompilationInfo CommonScriptCompilationInfo { get; }
    internal CSharpCompilation PreviousSubmission { get; }
    public ImmutableArray`1<SyntaxTree> SyntaxTrees { get; }
    public ImmutableArray`1<MetadataReference> DirectiveReferences { get; }
    internal IDictionary`2<ValueTuple`2<string, string>, MetadataReference> ReferenceDirectiveMap { get; }
    internal IEnumerable`1<string> ExternAliases { get; }
    public IEnumerable`1<AssemblyIdentity> ReferencedAssemblyNames { get; }
    internal IEnumerable`1<ReferenceDirective> ReferenceDirectives { get; }
    internal SourceAssemblySymbol SourceAssembly { get; }
    internal AssemblySymbol Assembly { get; }
    internal ModuleSymbol SourceModule { get; }
    internal NamespaceSymbol GlobalNamespace { get; }
    internal NamedTypeSymbol ScriptClass { get; }
    internal Imports GlobalImports { get; }
    internal AliasSymbol GlobalNamespaceAlias { get; }
    internal TypeSymbol DynamicType { get; }
    internal NamedTypeSymbol ObjectType { get; }
    internal bool DeclaresTheObjectClass { get; }
    internal CommonMessageProvider MessageProvider { get; }
    internal DiagnosticBag DeclarationDiagnostics { get; }
    internal DiagnosticBag AdditionalCodegenWarnings { get; }
    internal DeclarationTable Declarations { get; }
    internal MergedNamespaceDeclaration MergedRootDeclaration { get; }
    internal byte LinkerMajorVersion { get; }
    internal bool IsDelaySigned { get; }
    internal StrongNameKeys StrongNameKeys { get; }
    protected IAssemblySymbol CommonAssembly { get; }
    protected INamespaceSymbol CommonGlobalNamespace { get; }
    protected CompilationOptions CommonOptions { get; }
    protected IEnumerable`1<SyntaxTree> CommonSyntaxTrees { get; }
    protected IModuleSymbol CommonSourceModule { get; }
    protected INamedTypeSymbol CommonScriptClass { get; }
    protected ITypeSymbol CommonDynamicType { get; }
    protected INamedTypeSymbol CommonObjectType { get; }
    internal bool EnableEnumArrayBlockInitialization { get; }
    private CSharpCompilation(string assemblyName, CSharpCompilationOptions options, ImmutableArray`1<MetadataReference> references, CSharpCompilation previousSubmission, Type submissionReturnType, Type hostObjectType, bool isSubmission, ReferenceManager referenceManager, bool reuseReferenceManager, SyntaxAndDeclarationManager syntaxAndDeclarations, AsyncQueue`1<CompilationEvent> eventQueue);
    private static CSharpCompilation();
    internal Conversions get_Conversions();
    public virtual string get_Language();
    public virtual bool get_IsCaseSensitive();
    public CSharpCompilationOptions get_Options();
    internal AnonymousTypeManager get_AnonymousTypeManager();
    internal virtual CommonAnonymousTypeManager get_CommonAnonymousTypeManager();
    internal bool get_FeatureStrictEnabled();
    [CompilerGeneratedAttribute]
public LanguageVersion get_LanguageVersion();
    public virtual INamedTypeSymbol CreateErrorTypeSymbol(INamespaceOrTypeSymbol container, string name, int arity);
    public static CSharpCompilation Create(string assemblyName, IEnumerable`1<SyntaxTree> syntaxTrees, IEnumerable`1<MetadataReference> references, CSharpCompilationOptions options);
    public static CSharpCompilation CreateScriptCompilation(string assemblyName, SyntaxTree syntaxTree, IEnumerable`1<MetadataReference> references, CSharpCompilationOptions options, CSharpCompilation previousScriptCompilation, Type returnType, Type globalsType);
    private static CSharpCompilation Create(string assemblyName, CSharpCompilationOptions options, IEnumerable`1<SyntaxTree> syntaxTrees, IEnumerable`1<MetadataReference> references, CSharpCompilation previousSubmission, Type returnType, Type hostObjectType, bool isSubmission);
    internal virtual void ValidateDebugEntryPoint(IMethodSymbol debugEntryPoint, DiagnosticBag diagnostics);
    private static LanguageVersion CommonLanguageVersion(ImmutableArray`1<SyntaxTree> syntaxTrees);
    public CSharpCompilation Clone();
    private CSharpCompilation Update(ReferenceManager referenceManager, bool reuseReferenceManager, SyntaxAndDeclarationManager syntaxAndDeclarations);
    public CSharpCompilation WithAssemblyName(string assemblyName);
    public CSharpCompilation WithReferences(IEnumerable`1<MetadataReference> references);
    public CSharpCompilation WithReferences(MetadataReference[] references);
    public CSharpCompilation WithOptions(CSharpCompilationOptions options);
    public CSharpCompilation WithScriptCompilationInfo(CSharpScriptCompilationInfo info);
    internal virtual Compilation WithEventQueue(AsyncQueue`1<CompilationEvent> eventQueue);
    [CompilerGeneratedAttribute]
public CSharpScriptCompilationInfo get_ScriptCompilationInfo();
    internal virtual ScriptCompilationInfo get_CommonScriptCompilationInfo();
    internal CSharpCompilation get_PreviousSubmission();
    internal virtual bool HasSubmissionResult();
    public ImmutableArray`1<SyntaxTree> get_SyntaxTrees();
    public bool ContainsSyntaxTree(SyntaxTree syntaxTree);
    public CSharpCompilation AddSyntaxTrees(SyntaxTree[] trees);
    public CSharpCompilation AddSyntaxTrees(IEnumerable`1<SyntaxTree> trees);
    public CSharpCompilation RemoveSyntaxTrees(SyntaxTree[] trees);
    public CSharpCompilation RemoveSyntaxTrees(IEnumerable`1<SyntaxTree> trees);
    public CSharpCompilation RemoveAllSyntaxTrees();
    public CSharpCompilation ReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree);
    internal virtual int GetSyntaxTreeOrdinal(SyntaxTree tree);
    internal virtual CommonReferenceManager CommonGetBoundReferenceManager();
    internal ReferenceManager GetBoundReferenceManager();
    internal bool ReferenceManagerEquals(CSharpCompilation other);
    public virtual ImmutableArray`1<MetadataReference> get_DirectiveReferences();
    internal virtual IDictionary`2<ValueTuple`2<string, string>, MetadataReference> get_ReferenceDirectiveMap();
    internal IEnumerable`1<string> get_ExternAliases();
    internal Symbol GetAssemblyOrModuleSymbol(MetadataReference reference);
    public virtual IEnumerable`1<AssemblyIdentity> get_ReferencedAssemblyNames();
    internal virtual IEnumerable`1<ReferenceDirective> get_ReferenceDirectives();
    public MetadataReference GetDirectiveReference(ReferenceDirectiveTriviaSyntax directive);
    public CSharpCompilation AddReferences(MetadataReference[] references);
    public CSharpCompilation AddReferences(IEnumerable`1<MetadataReference> references);
    public CSharpCompilation RemoveReferences(MetadataReference[] references);
    public CSharpCompilation RemoveReferences(IEnumerable`1<MetadataReference> references);
    public CSharpCompilation RemoveAllReferences();
    public CSharpCompilation ReplaceReference(MetadataReference oldReference, MetadataReference newReference);
    public virtual CompilationReference ToMetadataReference(ImmutableArray`1<string> aliases, bool embedInteropTypes);
    private void GetAllUnaliasedModules(ArrayBuilder`1<ModuleSymbol> modules);
    internal void GetUnaliasedReferencedAssemblies(ArrayBuilder`1<AssemblySymbol> assemblies);
    public MetadataReference GetMetadataReference(IAssemblySymbol assemblySymbol);
    internal SourceAssemblySymbol get_SourceAssembly();
    internal AssemblySymbol get_Assembly();
    internal ModuleSymbol get_SourceModule();
    internal NamespaceSymbol get_GlobalNamespace();
    internal NamespaceSymbol GetCompilationNamespace(INamespaceSymbol namespaceSymbol);
    internal bool GetExternAliasTarget(string aliasName, NamespaceSymbol& namespace);
    internal NamedTypeSymbol get_ScriptClass();
    private ImplicitNamedTypeSymbol BindScriptClass();
    internal bool IsSubmissionSyntaxTree(SyntaxTree tree);
    internal Imports get_GlobalImports();
    private Imports BindGlobalImports();
    internal Imports GetSubmissionImports();
    internal Imports GetPreviousSubmissionImports();
    private Imports ExpandPreviousSubmissionImports();
    internal AliasSymbol get_GlobalNamespaceAlias();
    internal NamedTypeSymbol GetSpecialType(SpecialType specialType);
    internal Symbol GetSpecialTypeMember(SpecialMember specialMember);
    internal TypeSymbol GetTypeByReflectionType(Type type, DiagnosticBag diagnostics);
    private static CSDiagnosticInfo CreateReflectionTypeNotFoundError(Type type);
    internal TypeSymbol GetHostObjectTypeSymbol();
    internal SynthesizedInteractiveInitializerMethod GetSubmissionInitializer();
    internal NamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName);
    internal TypeSymbol get_DynamicType();
    internal NamedTypeSymbol get_ObjectType();
    internal bool get_DeclaresTheObjectClass();
    internal MethodSymbol GetEntryPoint(CancellationToken cancellationToken);
    internal EntryPoint GetEntryPointAndDiagnostics(CancellationToken cancellationToken);
    private MethodSymbol FindEntryPoint(CancellationToken cancellationToken, ImmutableArray`1& sealedDiagnostics);
    internal bool MightContainNoPiaLocalTypes();
    public Conversion ClassifyConversion(ITypeSymbol source, ITypeSymbol destination);
    internal ArrayTypeSymbol CreateArrayTypeSymbol(TypeSymbol elementType, int rank);
    internal PointerTypeSymbol CreatePointerTypeSymbol(TypeSymbol elementType);
    public SemanticModel GetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility);
    internal BinderFactory GetBinderFactory(SyntaxTree syntaxTree);
    private BinderFactory AddNewFactory(SyntaxTree syntaxTree, WeakReference`1& slot);
    internal Binder GetBinder(SyntaxReference reference);
    internal Binder GetBinder(CSharpSyntaxNode syntax);
    internal Imports GetImports(SingleNamespaceDeclaration declaration);
    private AliasSymbol CreateGlobalNamespaceAlias();
    private void CompleteTree(SyntaxTree tree);
    internal void ReportUnusedImports(DiagnosticBag diagnostics, CancellationToken cancellationToken, SyntaxTree filterTree);
    internal void RecordImport(UsingDirectiveSyntax syntax);
    internal void RecordImport(ExternAliasDirectiveSyntax syntax);
    private void RecordImportInternal(CSharpSyntaxNode syntax);
    internal virtual CommonMessageProvider get_MessageProvider();
    internal DiagnosticBag get_DeclarationDiagnostics();
    private IEnumerable`1<Diagnostic> FreezeDeclarationDiagnostics();
    internal DiagnosticBag get_AdditionalCodegenWarnings();
    internal DeclarationTable get_Declarations();
    internal MergedNamespaceDeclaration get_MergedRootDeclaration();
    public virtual ImmutableArray`1<Diagnostic> GetParseDiagnostics(CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetDeclarationDiagnostics(CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetMethodBodyDiagnostics(CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetDiagnostics(CancellationToken cancellationToken);
    internal ImmutableArray`1<Diagnostic> GetDiagnostics(CompilationStage stage, bool includeEarlierStages, CancellationToken cancellationToken);
    private static void AppendLoadDirectiveDiagnostics(DiagnosticBag builder, SyntaxAndDeclarationManager syntaxAndDeclarations, SyntaxTree syntaxTree, Func`2<IEnumerable`1<Diagnostic>, IEnumerable`1<Diagnostic>> locationFilterOpt);
    private void GetDiagnosticsForAllMethodBodies(DiagnosticBag diagnostics, CancellationToken cancellationToken);
    private static bool IsDefinedOrImplementedInSourceTree(Symbol symbol, SyntaxTree tree, Nullable`1<TextSpan> span);
    private ImmutableArray`1<Diagnostic> GetDiagnosticsForMethodBodiesInTree(SyntaxTree tree, Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    internal virtual bool FilterAndAppendAndFreeDiagnostics(DiagnosticBag accumulator, DiagnosticBag& incoming);
    private bool FilterAndAppendDiagnostics(DiagnosticBag accumulator, IEnumerable`1<Diagnostic> incoming);
    private ImmutableArray`1<Diagnostic> GetSourceDeclarationDiagnostics(SyntaxTree syntaxTree, Nullable`1<TextSpan> filterSpanWithinTree, Func`4<IEnumerable`1<Diagnostic>, SyntaxTree, Nullable`1<TextSpan>, IEnumerable`1<Diagnostic>> locationFilterOpt, CancellationToken cancellationToken);
    private ImmutableArray`1<Diagnostic> GetClsComplianceDiagnostics(SyntaxTree syntaxTree, Nullable`1<TextSpan> filterSpanWithinTree, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CSharpCompilation/<FilterDiagnosticsByLocation>d__180")]
private static IEnumerable`1<Diagnostic> FilterDiagnosticsByLocation(IEnumerable`1<Diagnostic> diagnostics, SyntaxTree tree, Nullable`1<TextSpan> filterSpanWithinTree);
    internal ImmutableArray`1<Diagnostic> GetDiagnosticsForSyntaxTree(CompilationStage stage, SyntaxTree syntaxTree, Nullable`1<TextSpan> filterSpanWithinTree, bool includeEarlierStages, CancellationToken cancellationToken);
    protected virtual void AppendDefaultVersionResource(Stream resourceStream);
    internal virtual byte get_LinkerMajorVersion();
    internal virtual bool get_IsDelaySigned();
    internal virtual StrongNameKeys get_StrongNameKeys();
    internal virtual CommonPEModuleBuilder CreateModuleBuilder(EmitOptions emitOptions, IMethodSymbol debugEntryPoint, IEnumerable`1<ResourceDescription> manifestResources, CompilationTestData testData, DiagnosticBag diagnostics, CancellationToken cancellationToken);
    internal virtual bool CompileImpl(CommonPEModuleBuilder moduleBuilder, Stream win32Resources, Stream xmlDocStream, bool emittingPdb, DiagnosticBag diagnostics, Predicate`1<ISymbol> filterOpt, CancellationToken cancellationToken);
    private bool StartSourceChecksumCalculation(PEModuleBuilder moduleBeingBuilt, DiagnosticBag diagnostics);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CSharpCompilation/<AddedModulesResourceNames>d__192")]
private IEnumerable`1<string> AddedModulesResourceNames(DiagnosticBag diagnostics);
    internal virtual EmitDifferenceResult EmitDifference(EmitBaseline baseline, IEnumerable`1<SemanticEdit> edits, Func`2<ISymbol, bool> isAddedSymbol, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection`1<MethodDefinitionHandle> updatedMethods, CompilationTestData testData, CancellationToken cancellationToken);
    internal string GetRuntimeMetadataVersion(EmitOptions emitOptions, DiagnosticBag diagnostics);
    private string GetRuntimeMetadataVersion(EmitOptions emitOptions);
    private static void AddDebugSourceDocumentsForChecksumDirectives(PEModuleBuilder moduleBeingBuilt, SyntaxTree tree, DiagnosticBag diagnostics);
    private static bool ChecksumMatches(string bytesText, ImmutableArray`1<byte> bytes);
    private static ImmutableArray`1<byte> MakeChecksumBytes(string bytesText);
    private static DebugSourceDocument MakeDebugSourceDocumentForTree(string normalizedPath, SyntaxTree tree);
    private void SetupWin32Resources(PEModuleBuilder moduleBeingBuilt, Stream win32Resources, DiagnosticBag diagnostics);
    internal virtual bool HasCodeToEmit();
    protected virtual Compilation CommonWithReferences(IEnumerable`1<MetadataReference> newReferences);
    protected virtual Compilation CommonWithAssemblyName(string assemblyName);
    protected virtual IAssemblySymbol get_CommonAssembly();
    protected virtual INamespaceSymbol get_CommonGlobalNamespace();
    protected virtual CompilationOptions get_CommonOptions();
    protected virtual SemanticModel CommonGetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility);
    protected virtual IEnumerable`1<SyntaxTree> get_CommonSyntaxTrees();
    protected virtual Compilation CommonAddSyntaxTrees(IEnumerable`1<SyntaxTree> trees);
    protected virtual Compilation CommonRemoveSyntaxTrees(IEnumerable`1<SyntaxTree> trees);
    protected virtual Compilation CommonRemoveAllSyntaxTrees();
    protected virtual Compilation CommonReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree);
    protected virtual Compilation CommonWithOptions(CompilationOptions options);
    protected virtual Compilation CommonWithScriptCompilationInfo(ScriptCompilationInfo info);
    protected virtual bool CommonContainsSyntaxTree(SyntaxTree syntaxTree);
    protected virtual ISymbol CommonGetAssemblyOrModuleSymbol(MetadataReference reference);
    protected virtual Compilation CommonClone();
    protected virtual IModuleSymbol get_CommonSourceModule();
    protected virtual INamedTypeSymbol CommonGetSpecialType(SpecialType specialType);
    protected virtual INamespaceSymbol CommonGetCompilationNamespace(INamespaceSymbol namespaceSymbol);
    protected virtual INamedTypeSymbol CommonGetTypeByMetadataName(string metadataName);
    protected virtual INamedTypeSymbol get_CommonScriptClass();
    protected virtual IArrayTypeSymbol CommonCreateArrayTypeSymbol(ITypeSymbol elementType, int rank);
    protected virtual IPointerTypeSymbol CommonCreatePointerTypeSymbol(ITypeSymbol elementType);
    protected virtual ITypeSymbol get_CommonDynamicType();
    protected virtual INamedTypeSymbol get_CommonObjectType();
    protected virtual IMethodSymbol CommonGetEntryPoint(CancellationToken cancellationToken);
    internal virtual int CompareSourceLocations(Location loc1, Location loc2);
    public virtual bool ContainsSymbolsWithName(Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    public virtual IEnumerable`1<ISymbol> GetSymbolsWithName(Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    internal bool HasDynamicEmitAttributes();
    internal bool CanEmitBoolean();
    internal virtual AnalyzerDriver AnalyzerForLanguage(ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerManager analyzerManager);
    internal void SymbolDeclaredEvent(Symbol symbol);
    internal bool get_EnableEnumArrayBlockInitialization();
    internal virtual bool IsIOperationFeatureEnabled();
    internal Symbol GetWellKnownTypeMember(WellKnownMember member);
    internal NamedTypeSymbol GetWellKnownType(WellKnownType type);
    internal bool IsAttributeType(TypeSymbol type);
    internal virtual bool IsAttributeType(ITypeSymbol type);
    internal bool IsExceptionType(TypeSymbol type, HashSet`1& useSiteDiagnostics);
    internal bool IsEqualOrDerivedFromWellKnownClass(TypeSymbol type, WellKnownType wellKnownType, HashSet`1& useSiteDiagnostics);
    internal virtual bool IsSystemTypeReference(ITypeSymbol type);
    internal virtual ISymbol CommonGetWellKnownTypeMember(WellKnownMember member);
    internal static Symbol GetRuntimeMember(NamedTypeSymbol declaringType, MemberDescriptor& descriptor, SignatureComparer`5<MethodSymbol, FieldSymbol, PropertySymbol, TypeSymbol, ParameterSymbol> comparer, AssemblySymbol accessWithinOpt);
    internal SynthesizedAttributeData TrySynthesizeAttribute(WellKnownMember constructor, ImmutableArray`1<TypedConstant> arguments, ImmutableArray`1<KeyValuePair`2<WellKnownMember, TypedConstant>> namedArguments);
    internal SynthesizedAttributeData SynthesizeDecimalConstantAttribute(decimal value);
    internal SynthesizedAttributeData SynthesizeDebuggerBrowsableNeverAttribute();
    internal SynthesizedAttributeData SynthesizeDebuggerStepThroughAttribute();
    internal SynthesizedAttributeData SynthesizeDebuggableAttribute();
    internal SynthesizedAttributeData SynthesizeDynamicAttribute(TypeSymbol type, int customModifiersCount, RefKind refKindOpt);
}
public class Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions : CompilationOptions {
    [CompilerGeneratedAttribute]
private bool <AllowUnsafe>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Usings>k__BackingField;
    [CompilerGeneratedAttribute]
private BinderFlags <TopLevelBinderFlags>k__BackingField;
    public bool AllowUnsafe { get; private set; }
    public ImmutableArray`1<string> Usings { get; private set; }
    internal BinderFlags TopLevelBinderFlags { get; private set; }
    public CSharpCompilationOptions(OutputKind outputKind, bool reportSuppressedDiagnostics, string moduleName, string mainTypeName, string scriptClassName, IEnumerable`1<string> usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray`1<byte> cryptoPublicKey, Nullable`1<bool> delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, bool deterministic, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider, bool publicSign);
    internal CSharpCompilationOptions(OutputKind outputKind, bool reportSuppressedDiagnostics, string moduleName, string mainTypeName, string scriptClassName, IEnumerable`1<string> usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray`1<byte> cryptoPublicKey, Nullable`1<bool> delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, bool deterministic, DateTime currentLocalTime, bool extendedCustomDebugInformation, bool debugPlusMode, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider, MetadataImportOptions metadataImportOptions, bool referencesSupersedeLowerVersions, bool publicSign, BinderFlags topLevelBinderFlags);
    private CSharpCompilationOptions(CSharpCompilationOptions other);
    [EditorBrowsableAttribute("1")]
public CSharpCompilationOptions(OutputKind outputKind, string moduleName, string mainTypeName, string scriptClassName, IEnumerable`1<string> usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray`1<byte> cryptoPublicKey, Nullable`1<bool> delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, bool deterministic, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider);
    [EditorBrowsableAttribute("1")]
public CSharpCompilationOptions(OutputKind outputKind, string moduleName, string mainTypeName, string scriptClassName, IEnumerable`1<string> usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray`1<byte> cryptoPublicKey, Nullable`1<bool> delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider);
    [EditorBrowsableAttribute("1")]
public CSharpCompilationOptions(OutputKind outputKind, bool reportSuppressedDiagnostics, string moduleName, string mainTypeName, string scriptClassName, IEnumerable`1<string> usings, OptimizationLevel optimizationLevel, bool checkOverflow, bool allowUnsafe, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray`1<byte> cryptoPublicKey, Nullable`1<bool> delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, bool deterministic, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider);
    [CompilerGeneratedAttribute]
public bool get_AllowUnsafe();
    [CompilerGeneratedAttribute]
private void set_AllowUnsafe(bool value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Usings();
    [CompilerGeneratedAttribute]
private void set_Usings(ImmutableArray`1<string> value);
    [CompilerGeneratedAttribute]
internal BinderFlags get_TopLevelBinderFlags();
    [CompilerGeneratedAttribute]
private void set_TopLevelBinderFlags(BinderFlags value);
    internal CSharpCompilationOptions WithTopLevelBinderFlags(BinderFlags flags);
    internal virtual ImmutableArray`1<string> GetImports();
    public CSharpCompilationOptions WithOutputKind(OutputKind kind);
    public CSharpCompilationOptions WithModuleName(string moduleName);
    public CSharpCompilationOptions WithScriptClassName(string name);
    public CSharpCompilationOptions WithMainTypeName(string name);
    public CSharpCompilationOptions WithCryptoKeyContainer(string name);
    public CSharpCompilationOptions WithCryptoKeyFile(string path);
    public CSharpCompilationOptions WithCryptoPublicKey(ImmutableArray`1<byte> value);
    public CSharpCompilationOptions WithDelaySign(Nullable`1<bool> value);
    public CSharpCompilationOptions WithUsings(ImmutableArray`1<string> usings);
    public CSharpCompilationOptions WithUsings(IEnumerable`1<string> usings);
    public CSharpCompilationOptions WithUsings(String[] usings);
    public CSharpCompilationOptions WithOptimizationLevel(OptimizationLevel value);
    public CSharpCompilationOptions WithOverflowChecks(bool enabled);
    public CSharpCompilationOptions WithAllowUnsafe(bool enabled);
    public CSharpCompilationOptions WithPlatform(Platform platform);
    public CSharpCompilationOptions WithPublicSign(bool publicSign);
    protected virtual CompilationOptions CommonWithGeneralDiagnosticOption(ReportDiagnostic value);
    protected virtual CompilationOptions CommonWithSpecificDiagnosticOptions(ImmutableDictionary`2<string, ReportDiagnostic> specificDiagnosticOptions);
    protected virtual CompilationOptions CommonWithSpecificDiagnosticOptions(IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> specificDiagnosticOptions);
    protected virtual CompilationOptions CommonWithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics);
    public CSharpCompilationOptions WithGeneralDiagnosticOption(ReportDiagnostic value);
    public CSharpCompilationOptions WithSpecificDiagnosticOptions(ImmutableDictionary`2<string, ReportDiagnostic> values);
    public CSharpCompilationOptions WithSpecificDiagnosticOptions(IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> values);
    public CSharpCompilationOptions WithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics);
    public CSharpCompilationOptions WithWarningLevel(int warningLevel);
    public CSharpCompilationOptions WithConcurrentBuild(bool concurrentBuild);
    public CSharpCompilationOptions WithDeterministic(bool deterministic);
    internal CSharpCompilationOptions WithCurrentLocalTime(DateTime value);
    internal CSharpCompilationOptions WithExtendedCustomDebugInformation(bool extendedCustomDebugInformation);
    internal CSharpCompilationOptions WithDebugPlusMode(bool debugPlusMode);
    internal CSharpCompilationOptions WithMetadataImportOptions(MetadataImportOptions value);
    internal CSharpCompilationOptions WithReferencesSupersedeLowerVersions(bool value);
    public CSharpCompilationOptions WithXmlReferenceResolver(XmlReferenceResolver resolver);
    public CSharpCompilationOptions WithSourceReferenceResolver(SourceReferenceResolver resolver);
    public CSharpCompilationOptions WithMetadataReferenceResolver(MetadataReferenceResolver resolver);
    public CSharpCompilationOptions WithAssemblyIdentityComparer(AssemblyIdentityComparer comparer);
    public CSharpCompilationOptions WithStrongNameProvider(StrongNameProvider provider);
    protected virtual CompilationOptions CommonWithDeterministic(bool deterministic);
    protected virtual CompilationOptions CommonWithOutputKind(OutputKind kind);
    protected virtual CompilationOptions CommonWithPlatform(Platform platform);
    protected virtual CompilationOptions CommonWithPublicSign(bool publicSign);
    protected virtual CompilationOptions CommonWithOptimizationLevel(OptimizationLevel value);
    protected virtual CompilationOptions CommonWithAssemblyIdentityComparer(AssemblyIdentityComparer comparer);
    protected virtual CompilationOptions CommonWithXmlReferenceResolver(XmlReferenceResolver resolver);
    protected virtual CompilationOptions CommonWithSourceReferenceResolver(SourceReferenceResolver resolver);
    protected virtual CompilationOptions CommonWithMetadataReferenceResolver(MetadataReferenceResolver resolver);
    protected virtual CompilationOptions CommonWithStrongNameProvider(StrongNameProvider provider);
    [ObsoleteAttribute]
protected virtual CompilationOptions CommonWithFeatures(ImmutableArray`1<string> features);
    internal virtual void ValidateOptions(ArrayBuilder`1<Diagnostic> builder);
    public sealed virtual bool Equals(CSharpCompilationOptions other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual Diagnostic FilterDiagnostic(Diagnostic diagnostic);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.CSharp.CSharpCompilationReference : CompilationReference {
    [CompilerGeneratedAttribute]
private CSharpCompilation <Compilation>k__BackingField;
    public CSharpCompilation Compilation { get; }
    internal Compilation CompilationCore { get; }
    public CSharpCompilationReference(CSharpCompilation compilation, ImmutableArray`1<string> aliases, bool embedInteropTypes);
    private CSharpCompilationReference(CSharpCompilation compilation, MetadataReferenceProperties properties);
    [CompilerGeneratedAttribute]
public CSharpCompilation get_Compilation();
    internal virtual Compilation get_CompilationCore();
    internal virtual CompilationReference WithPropertiesImpl(MetadataReferenceProperties properties);
    private string GetDebuggerDisplay();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.CSharpCompiler : CommonCompiler {
    internal static string ResponseFileName;
    private CommandLineDiagnosticFormatter _diagnosticFormatter;
    public DiagnosticFormatter DiagnosticFormatter { get; }
    protected internal CSharpCommandLineArguments Arguments { get; }
    protected CSharpCompiler(CSharpCommandLineParser parser, string responseFile, String[] args, string clientDirectory, string baseDirectory, string sdkDirectoryOpt, string additionalReferenceDirectories, IAnalyzerAssemblyLoader analyzerLoader);
    public virtual DiagnosticFormatter get_DiagnosticFormatter();
    protected internal CSharpCommandLineArguments get_Arguments();
    public virtual Compilation CreateCompilation(TextWriter consoleOutput, TouchedFileLogger touchedFilesLogger, ErrorLogger errorLogger);
    private SyntaxTree ParseFile(TextWriter consoleOutput, CSharpParseOptions parseOptions, CSharpParseOptions scriptParseOptions, Boolean& hadErrors, CommandLineSourceFile file, ErrorLogger errorLogger, String& normalizedFilePath);
    private static SyntaxTree ParseFile(CSharpParseOptions parseOptions, CSharpParseOptions scriptParseOptions, SourceText content, CommandLineSourceFile file);
    protected virtual string GetOutputFileName(Compilation compilation, CancellationToken cancellationToken);
    internal virtual bool SuppressDefaultResponseFile(IEnumerable`1<string> args);
    public virtual void PrintLogo(TextWriter consoleOutput);
    internal virtual string GetToolName();
    public virtual void PrintHelp(TextWriter consoleOutput);
    protected virtual bool TryGetCompilerDiagnosticCode(string diagnosticId, UInt32& code);
    protected virtual ImmutableArray`1<DiagnosticAnalyzer> ResolveAnalyzersFromArguments(List`1<DiagnosticInfo> diagnostics, CommonMessageProvider messageProvider, TouchedFileLogger touchedFiles);
}
internal class Microsoft.CodeAnalysis.CSharp.CSharpControlFlowAnalysis : ControlFlowAnalysis {
    private RegionAnalysisContext _context;
    private ImmutableArray`1<SyntaxNode> _entryPoints;
    private ImmutableArray`1<SyntaxNode> _exitPoints;
    private object _regionStartPointIsReachable;
    private object _regionEndPointIsReachable;
    private Nullable`1<bool> _succeeded;
    public ImmutableArray`1<SyntaxNode> EntryPoints { get; }
    public ImmutableArray`1<SyntaxNode> ExitPoints { get; }
    public bool EndPointIsReachable { get; }
    public bool StartPointIsReachable { get; }
    public ImmutableArray`1<SyntaxNode> ReturnStatements { get; }
    public bool Succeeded { get; }
    internal CSharpControlFlowAnalysis(RegionAnalysisContext context);
    public virtual ImmutableArray`1<SyntaxNode> get_EntryPoints();
    public virtual ImmutableArray`1<SyntaxNode> get_ExitPoints();
    public sealed virtual bool get_EndPointIsReachable();
    public sealed virtual bool get_StartPointIsReachable();
    private void ComputeReachability();
    public virtual ImmutableArray`1<SyntaxNode> get_ReturnStatements();
    public sealed virtual bool get_Succeeded();
}
internal class Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis : DataFlowAnalysis {
    private RegionAnalysisContext _context;
    private ImmutableArray`1<ISymbol> _variablesDeclared;
    private HashSet`1<Symbol> _unassignedVariables;
    private ImmutableArray`1<ISymbol> _dataFlowsIn;
    private ImmutableArray`1<ISymbol> _dataFlowsOut;
    private ImmutableArray`1<ISymbol> _alwaysAssigned;
    private ImmutableArray`1<ISymbol> _readInside;
    private ImmutableArray`1<ISymbol> _writtenInside;
    private ImmutableArray`1<ISymbol> _readOutside;
    private ImmutableArray`1<ISymbol> _writtenOutside;
    private ImmutableArray`1<ISymbol> _captured;
    private ImmutableArray`1<ISymbol> _unsafeAddressTaken;
    private HashSet`1<PrefixUnaryExpressionSyntax> _unassignedVariableAddressOfSyntaxes;
    private Nullable`1<bool> _succeeded;
    public ImmutableArray`1<ISymbol> VariablesDeclared { get; }
    private HashSet`1<Symbol> UnassignedVariables { get; }
    public ImmutableArray`1<ISymbol> DataFlowsIn { get; }
    public ImmutableArray`1<ISymbol> DataFlowsOut { get; }
    public ImmutableArray`1<ISymbol> AlwaysAssigned { get; }
    public ImmutableArray`1<ISymbol> ReadInside { get; }
    public ImmutableArray`1<ISymbol> WrittenInside { get; }
    public ImmutableArray`1<ISymbol> ReadOutside { get; }
    public ImmutableArray`1<ISymbol> WrittenOutside { get; }
    public ImmutableArray`1<ISymbol> Captured { get; }
    public ImmutableArray`1<ISymbol> UnsafeAddressTaken { get; }
    private HashSet`1<PrefixUnaryExpressionSyntax> UnassignedVariableAddressOfSyntaxes { get; }
    public bool Succeeded { get; }
    internal CSharpDataFlowAnalysis(RegionAnalysisContext context);
    public virtual ImmutableArray`1<ISymbol> get_VariablesDeclared();
    private HashSet`1<Symbol> get_UnassignedVariables();
    public virtual ImmutableArray`1<ISymbol> get_DataFlowsIn();
    public virtual ImmutableArray`1<ISymbol> get_DataFlowsOut();
    public virtual ImmutableArray`1<ISymbol> get_AlwaysAssigned();
    public virtual ImmutableArray`1<ISymbol> get_ReadInside();
    public virtual ImmutableArray`1<ISymbol> get_WrittenInside();
    public virtual ImmutableArray`1<ISymbol> get_ReadOutside();
    public virtual ImmutableArray`1<ISymbol> get_WrittenOutside();
    private void AnalyzeReadWrite();
    public virtual ImmutableArray`1<ISymbol> get_Captured();
    public virtual ImmutableArray`1<ISymbol> get_UnsafeAddressTaken();
    private HashSet`1<PrefixUnaryExpressionSyntax> get_UnassignedVariableAddressOfSyntaxes();
    public sealed virtual bool get_Succeeded();
    internal static ImmutableArray`1<ISymbol> Sort(IEnumerable`1<Symbol> data);
}
internal class Microsoft.CodeAnalysis.CSharp.CSharpDeclarationComputer : DeclarationComputer {
    public static void ComputeDeclarationsInSpan(SemanticModel model, TextSpan span, bool getSymbol, List`1<DeclarationInfo> builder, CancellationToken cancellationToken);
    public static void ComputeDeclarationsInNode(SemanticModel model, SyntaxNode node, bool getSymbol, List`1<DeclarationInfo> builder, CancellationToken cancellationToken, Nullable`1<int> levelsToCompute);
    private static bool InvalidLevel(Nullable`1<int> level);
    private static Nullable`1<int> DecrementLevel(Nullable`1<int> level);
    private static void ComputeDeclarations(SemanticModel model, SyntaxNode node, Func`3<SyntaxNode, Nullable`1<int>, bool> shouldSkip, bool getSymbol, List`1<DeclarationInfo> builder, Nullable`1<int> levelsToCompute, CancellationToken cancellationToken);
    private static DeclarationInfo GetExpressionBodyDeclarationInfo(BasePropertyDeclarationSyntax declarationWithExpressionBody, ArrowExpressionClauseSyntax expressionBody, SemanticModel model, bool getSymbol, CancellationToken cancellationToken);
    internal static ArrowExpressionClauseSyntax GetExpressionBodySyntax(CSharpSyntaxNode node);
}
internal static class Microsoft.CodeAnalysis.CSharp.CSharpDiagnosticFilter : object {
    private static ErrorCode[] s_alinkWarnings;
    private static CSharpDiagnosticFilter();
    public static Diagnostic Filter(Diagnostic d, int warningLevelOption, ReportDiagnostic generalDiagnosticOption, IDictionary`2<string, ReportDiagnostic> specificDiagnosticOptions);
    internal static ReportDiagnostic GetDiagnosticReport(DiagnosticSeverity severity, bool isEnabledByDefault, string id, int diagnosticWarningLevel, Location location, string category, int warningLevelOption, ReportDiagnostic generalDiagnosticOption, IDictionary`2<string, ReportDiagnostic> specificDiagnosticOptions, Boolean& hasPragmaSuppression);
}
public class Microsoft.CodeAnalysis.CSharp.CSharpDiagnosticFormatter : DiagnosticFormatter {
    [CompilerGeneratedAttribute]
private static CSharpDiagnosticFormatter <Instance>k__BackingField;
    public static CSharpDiagnosticFormatter Instance { get; }
    private static CSharpDiagnosticFormatter();
    [CompilerGeneratedAttribute]
public static CSharpDiagnosticFormatter get_Instance();
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.CSharp.CSharpExtensions : object {
    internal static bool IsCSharpKind(int rawKind);
    [ExtensionAttribute]
public static SyntaxKind Kind(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxKind Kind(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static SyntaxKind Kind(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxKind Kind(SyntaxNodeOrToken nodeOrToken);
    [ExtensionAttribute]
public static bool IsKeyword(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsContextualKeyword(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsReservedKeyword(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsVerbatimStringLiteral(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsVerbatimIdentifier(SyntaxToken token);
    [ExtensionAttribute]
public static VarianceKind VarianceKindFromToken(SyntaxToken node);
    [ExtensionAttribute]
public static SyntaxTokenList Insert(SyntaxTokenList list, int index, SyntaxToken[] items);
    [ExtensionAttribute]
public static SyntaxToken ReplaceTrivia(SyntaxToken token, IEnumerable`1<SyntaxTrivia> trivia, Func`3<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia);
    [ExtensionAttribute]
public static SyntaxToken ReplaceTrivia(SyntaxToken token, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia);
    [ExtensionAttribute]
internal static DirectiveStack ApplyDirectives(SyntaxNode node, DirectiveStack stack);
    [ExtensionAttribute]
internal static DirectiveStack ApplyDirectives(SyntaxToken token, DirectiveStack stack);
    [ExtensionAttribute]
internal static DirectiveStack ApplyDirectives(SyntaxNodeOrToken nodeOrToken, DirectiveStack stack);
    [ExtensionAttribute]
internal static SeparatedSyntaxList`1<TOther> AsSeparatedList(SyntaxNodeOrTokenList list);
    [ExtensionAttribute]
internal static IList`1<DirectiveTriviaSyntax> GetDirectives(SyntaxNode node, Func`2<DirectiveTriviaSyntax, bool> filter);
    [ExtensionAttribute]
public static DirectiveTriviaSyntax GetFirstDirective(SyntaxNode node, Func`2<DirectiveTriviaSyntax, bool> predicate);
    [ExtensionAttribute]
public static DirectiveTriviaSyntax GetLastDirective(SyntaxNode node, Func`2<DirectiveTriviaSyntax, bool> predicate);
    [ExtensionAttribute]
public static CompilationUnitSyntax GetCompilationUnitRoot(SyntaxTree tree, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool HasReferenceDirectives(SyntaxTree tree);
    [ExtensionAttribute]
internal static bool HasReferenceOrLoadDirectives(SyntaxTree tree);
    [ExtensionAttribute]
internal static bool IsAnyPreprocessorSymbolDefined(SyntaxTree tree, ImmutableArray`1<string> conditionalSymbols);
    [ExtensionAttribute]
internal static bool IsPreprocessorSymbolDefined(SyntaxTree tree, string symbolName, int position);
    [ExtensionAttribute]
internal static ReportDiagnostic GetPragmaDirectiveWarningState(SyntaxTree tree, string id, int position);
    [ExtensionAttribute]
public static Conversion ClassifyConversion(Compilation compilation, ITypeSymbol source, ITypeSymbol destination);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, OrderingSyntax node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetCollectionInitializerSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, CrefSyntax crefSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSpeculativeSymbolInfo(SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption);
    [ExtensionAttribute]
public static SymbolInfo GetSpeculativeSymbolInfo(SemanticModel semanticModel, int position, CrefSyntax expression, SpeculativeBindingOption bindingOption);
    [ExtensionAttribute]
public static SymbolInfo GetSpeculativeSymbolInfo(SemanticModel semanticModel, int position, AttributeSyntax attribute);
    [ExtensionAttribute]
public static SymbolInfo GetSpeculativeSymbolInfo(SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer);
    [ExtensionAttribute]
public static TypeInfo GetTypeInfo(SemanticModel semanticModel, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TypeInfo GetTypeInfo(SemanticModel semanticModel, SelectOrGroupClauseSyntax node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TypeInfo GetTypeInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TypeInfo GetTypeInfo(SemanticModel semanticModel, AttributeSyntax attributeSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TypeInfo GetSpeculativeTypeInfo(SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption);
    [ExtensionAttribute]
public static Conversion GetConversion(SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Conversion GetSpeculativeConversion(SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption);
    [ExtensionAttribute]
public static ForEachStatementInfo GetForEachStatementInfo(SemanticModel semanticModel, ForEachStatementSyntax forEachStatement);
    [ExtensionAttribute]
public static AwaitExpressionInfo GetAwaitExpressionInfo(SemanticModel semanticModel, AwaitExpressionSyntax awaitExpression);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> GetMemberGroup(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> GetMemberGroup(SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> GetMemberGroup(SemanticModel semanticModel, ConstructorInitializerSyntax initializer, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<IPropertySymbol> GetIndexerGroup(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Optional`1<object> GetConstantValue(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static QueryClauseInfo GetQueryClauseInfo(SemanticModel semanticModel, QueryClauseSyntax node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IAliasSymbol GetAliasInfo(SemanticModel semanticModel, IdentifierNameSyntax nameSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IAliasSymbol GetSpeculativeAliasInfo(SemanticModel semanticModel, int position, IdentifierNameSyntax nameSyntax, SpeculativeBindingOption bindingOption);
    [ExtensionAttribute]
public static ControlFlowAnalysis AnalyzeControlFlow(SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement);
    [ExtensionAttribute]
public static ControlFlowAnalysis AnalyzeControlFlow(SemanticModel semanticModel, StatementSyntax statement);
    [ExtensionAttribute]
public static DataFlowAnalysis AnalyzeDataFlow(SemanticModel semanticModel, ExpressionSyntax expression);
    [ExtensionAttribute]
public static DataFlowAnalysis AnalyzeDataFlow(SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement);
    [ExtensionAttribute]
public static DataFlowAnalysis AnalyzeDataFlow(SemanticModel semanticModel, StatementSyntax statement);
    [ExtensionAttribute]
public static bool TryGetSpeculativeSemanticModelForMethodBody(SemanticModel semanticModel, int position, BaseMethodDeclarationSyntax method, SemanticModel& speculativeModel);
    [ExtensionAttribute]
public static bool TryGetSpeculativeSemanticModelForMethodBody(SemanticModel semanticModel, int position, AccessorDeclarationSyntax accessor, SemanticModel& speculativeModel);
    [ExtensionAttribute]
public static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, TypeSyntax type, SemanticModel& speculativeModel, SpeculativeBindingOption bindingOption);
    [ExtensionAttribute]
public static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, CrefSyntax crefSyntax, SemanticModel& speculativeModel);
    [ExtensionAttribute]
public static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, StatementSyntax statement, SemanticModel& speculativeModel);
    [ExtensionAttribute]
public static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, EqualsValueClauseSyntax initializer, SemanticModel& speculativeModel);
    [ExtensionAttribute]
public static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, ArrowExpressionClauseSyntax expressionBody, SemanticModel& speculativeModel);
    [ExtensionAttribute]
public static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer, SemanticModel& speculativeModel);
    [ExtensionAttribute]
public static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, AttributeSyntax attribute, SemanticModel& speculativeModel);
    [ExtensionAttribute]
public static Conversion ClassifyConversion(SemanticModel semanticModel, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource);
    [ExtensionAttribute]
public static Conversion ClassifyConversion(SemanticModel semanticModel, int position, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource);
    [ExtensionAttribute]
public static ISymbol GetDeclaredSymbol(SemanticModel semanticModel, MemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamespaceSymbol GetDeclaredSymbol(SemanticModel semanticModel, NamespaceDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol GetDeclaredSymbol(SemanticModel semanticModel, BaseTypeDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol GetDeclaredSymbol(SemanticModel semanticModel, DelegateDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IFieldSymbol GetDeclaredSymbol(SemanticModel semanticModel, EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMethodSymbol GetDeclaredSymbol(SemanticModel semanticModel, BaseMethodDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISymbol GetDeclaredSymbol(SemanticModel semanticModel, BasePropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IPropertySymbol GetDeclaredSymbol(SemanticModel semanticModel, PropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IPropertySymbol GetDeclaredSymbol(SemanticModel semanticModel, IndexerDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEventSymbol GetDeclaredSymbol(SemanticModel semanticModel, EventDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IPropertySymbol GetDeclaredSymbol(SemanticModel semanticModel, AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol GetDeclaredSymbol(SemanticModel semanticModel, AnonymousObjectCreationExpressionSyntax declaratorSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMethodSymbol GetDeclaredSymbol(SemanticModel semanticModel, AccessorDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISymbol GetDeclaredSymbol(SemanticModel semanticModel, VariableDeclaratorSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ILabelSymbol GetDeclaredSymbol(SemanticModel semanticModel, LabeledStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ILabelSymbol GetDeclaredSymbol(SemanticModel semanticModel, SwitchLabelSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IAliasSymbol GetDeclaredSymbol(SemanticModel semanticModel, UsingDirectiveSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IAliasSymbol GetDeclaredSymbol(SemanticModel semanticModel, ExternAliasDirectiveSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IParameterSymbol GetDeclaredSymbol(SemanticModel semanticModel, ParameterSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeParameterSymbol GetDeclaredSymbol(SemanticModel semanticModel, TypeParameterSyntax typeParameter, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ILocalSymbol GetDeclaredSymbol(SemanticModel semanticModel, ForEachStatementSyntax forEachStatement, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ILocalSymbol GetDeclaredSymbol(SemanticModel semanticModel, CatchDeclarationSyntax catchDeclaration, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IRangeVariableSymbol GetDeclaredSymbol(SemanticModel semanticModel, QueryClauseSyntax queryClause, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IRangeVariableSymbol GetDeclaredSymbol(SemanticModel semanticModel, JoinIntoClauseSyntax node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IRangeVariableSymbol GetDeclaredSymbol(SemanticModel semanticModel, QueryContinuationSyntax node, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.CSharp.CSharpFileSystemExtensions : object {
    [ExtensionAttribute]
public static EmitResult Emit(CSharpCompilation compilation, string outputPath, string pdbPath, string xmlDocumentationPath, string win32ResourcesPath, IEnumerable`1<ResourceDescription> manifestResources, CancellationToken cancellationToken);
}
public class Microsoft.CodeAnalysis.CSharp.CSharpParseOptions : ParseOptions {
    [CompilerGeneratedAttribute]
private static CSharpParseOptions <Default>k__BackingField;
    private ImmutableDictionary`2<string, string> _features;
    [CompilerGeneratedAttribute]
private LanguageVersion <LanguageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <PreprocessorSymbols>k__BackingField;
    public static CSharpParseOptions Default { get; }
    public LanguageVersion LanguageVersion { get; private set; }
    internal ImmutableArray`1<string> PreprocessorSymbols { get; private set; }
    public IEnumerable`1<string> PreprocessorSymbolNames { get; }
    public IReadOnlyDictionary`2<string, string> Features { get; }
    public CSharpParseOptions(LanguageVersion languageVersion, DocumentationMode documentationMode, SourceCodeKind kind, IEnumerable`1<string> preprocessorSymbols);
    internal CSharpParseOptions(LanguageVersion languageVersion, DocumentationMode documentationMode, SourceCodeKind kind, IEnumerable`1<string> preprocessorSymbols, ImmutableDictionary`2<string, string> features);
    private CSharpParseOptions(CSharpParseOptions other);
    internal CSharpParseOptions(LanguageVersion languageVersion, DocumentationMode documentationMode, SourceCodeKind kind, ImmutableArray`1<string> preprocessorSymbols);
    private static CSharpParseOptions();
    [CompilerGeneratedAttribute]
public static CSharpParseOptions get_Default();
    [CompilerGeneratedAttribute]
public LanguageVersion get_LanguageVersion();
    [CompilerGeneratedAttribute]
private void set_LanguageVersion(LanguageVersion value);
    [CompilerGeneratedAttribute]
internal ImmutableArray`1<string> get_PreprocessorSymbols();
    [CompilerGeneratedAttribute]
private void set_PreprocessorSymbols(ImmutableArray`1<string> value);
    public virtual IEnumerable`1<string> get_PreprocessorSymbolNames();
    public CSharpParseOptions WithKind(SourceCodeKind kind);
    public CSharpParseOptions WithLanguageVersion(LanguageVersion version);
    public CSharpParseOptions WithPreprocessorSymbols(IEnumerable`1<string> preprocessorSymbols);
    public CSharpParseOptions WithPreprocessorSymbols(String[] preprocessorSymbols);
    public CSharpParseOptions WithPreprocessorSymbols(ImmutableArray`1<string> symbols);
    public CSharpParseOptions WithDocumentationMode(DocumentationMode documentationMode);
    public virtual ParseOptions CommonWithKind(SourceCodeKind kind);
    protected virtual ParseOptions CommonWithDocumentationMode(DocumentationMode documentationMode);
    protected virtual ParseOptions CommonWithFeatures(IEnumerable`1<KeyValuePair`2<string, string>> features);
    public CSharpParseOptions WithFeatures(IEnumerable`1<KeyValuePair`2<string, string>> features);
    public virtual IReadOnlyDictionary`2<string, string> get_Features();
    internal bool IsFeatureEnabled(MessageID feature);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CSharpParseOptions other);
    public virtual int GetHashCode();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CantReferenceCompilationOf { get; }
    internal static string ChainingSpeculativeModelIsNotSupported { get; }
    internal static string CompilationC { get; }
    internal static string CouldNotFindFile { get; }
    internal static string ElementIsExpected { get; }
    internal static string ElementsCannotBeNull { get; }
    internal static string ERR_AbstractAndExtern { get; }
    internal static string ERR_AbstractAndSealed { get; }
    internal static string ERR_AbstractAttributeClass { get; }
    internal static string ERR_AbstractBaseCall { get; }
    internal static string ERR_AbstractEventInitializer { get; }
    internal static string ERR_AbstractField { get; }
    internal static string ERR_AbstractHasBody { get; }
    internal static string ERR_AbstractInConcreteClass { get; }
    internal static string ERR_AbstractNotVirtual { get; }
    internal static string ERR_AbstractSealedStatic { get; }
    internal static string ERR_AccessModMissingAccessor { get; }
    internal static string ERR_AccessorImplementingMethod { get; }
    internal static string ERR_AccessorListAndExpressionBody { get; }
    internal static string ERR_AddModuleAssembly { get; }
    internal static string ERR_AddOrRemoveExpected { get; }
    internal static string ERR_AddRemoveMustHaveBody { get; }
    internal static string ERR_AddrOnReadOnlyLocal { get; }
    internal static string ERR_AgnosticToMachineModule { get; }
    internal static string ERR_AliasMissingFile { get; }
    internal static string ERR_AliasNotFound { get; }
    internal static string ERR_AliasQualAsExpression { get; }
    internal static string ERR_AliasQualifiedNameNotAnExpression { get; }
    internal static string ERR_AmbigBinaryOps { get; }
    internal static string ERR_AmbigCall { get; }
    internal static string ERR_AmbigContext { get; }
    internal static string ERR_AmbigMember { get; }
    internal static string ERR_AmbigOverride { get; }
    internal static string ERR_AmbigQM { get; }
    internal static string ERR_AmbigUDConv { get; }
    internal static string ERR_AmbigUnaryOp { get; }
    internal static string ERR_AmbiguousAttribute { get; }
    internal static string ERR_AnonDelegateCantUse { get; }
    internal static string ERR_AnonMethGrpInForEach { get; }
    internal static string ERR_AnonMethToNonDel { get; }
    internal static string ERR_AnonymousMethodToExpressionTree { get; }
    internal static string ERR_AnonymousReturnExpected { get; }
    internal static string ERR_AnonymousTypeDuplicatePropertyName { get; }
    internal static string ERR_AnonymousTypeNotAvailable { get; }
    internal static string ERR_AnonymousTypePropertyAssignedBadValue { get; }
    internal static string ERR_ArgsInvalid { get; }
    internal static string ERR_ArrayElementCantBeRefAny { get; }
    internal static string ERR_ArrayInitializerExpected { get; }
    internal static string ERR_ArrayInitializerIncorrectLength { get; }
    internal static string ERR_ArrayInitInBadPlace { get; }
    internal static string ERR_ArrayInitToNonArrayType { get; }
    internal static string ERR_ArrayOfStaticClass { get; }
    internal static string ERR_ArraySizeInDeclaration { get; }
    internal static string ERR_AsMustHaveReferenceType { get; }
    internal static string ERR_AssemblyMatchBadVersion { get; }
    internal static string ERR_AssemblyNameOnNonModule { get; }
    internal static string ERR_AssemblySpecifiedForLinkAndRef { get; }
    internal static string ERR_AssgLvalueExpected { get; }
    internal static string ERR_AssgReadonly { get; }
    internal static string ERR_AssgReadonly2 { get; }
    internal static string ERR_AssgReadonlyLocal { get; }
    internal static string ERR_AssgReadonlyLocal2Cause { get; }
    internal static string ERR_AssgReadonlyLocalCause { get; }
    internal static string ERR_AssgReadonlyProp { get; }
    internal static string ERR_AssgReadonlyStatic { get; }
    internal static string ERR_AssgReadonlyStatic2 { get; }
    internal static string ERR_AsWithTypeVar { get; }
    internal static string ERR_AttrArgWithTypeVars { get; }
    internal static string ERR_AttributeCantBeGeneric { get; }
    internal static string ERR_AttributeNotOnAccessor { get; }
    internal static string ERR_AttributeOnBadSymbolType { get; }
    internal static string ERR_AttributeParameterRequired1 { get; }
    internal static string ERR_AttributeParameterRequired2 { get; }
    internal static string ERR_AttributesNotAllowed { get; }
    internal static string ERR_AttributeUsageOnNonAttributeClass { get; }
    internal static string ERR_AutoPropertyInitializerInInterface { get; }
    internal static string ERR_AutoPropertyMustHaveGetAccessor { get; }
    internal static string ERR_AutoPropertyMustOverrideSet { get; }
    internal static string ERR_AwaitInUnsafeContext { get; }
    internal static string ERR_BadAccess { get; }
    internal static string ERR_BadAppConfigPath { get; }
    internal static string ERR_BadArgCount { get; }
    internal static string ERR_BadArgExtraRef { get; }
    internal static string ERR_BadArgRef { get; }
    internal static string ERR_BadArgType { get; }
    internal static string ERR_BadArgTypeDynamicExtension { get; }
    internal static string ERR_BadArgTypesForCollectionAdd { get; }
    internal static string ERR_BadArgumentToAttribute { get; }
    internal static string ERR_BadArity { get; }
    internal static string ERR_BadArraySyntax { get; }
    internal static string ERR_BadAsyncArgType { get; }
    internal static string ERR_BadAsyncExpressionTree { get; }
    internal static string ERR_BadAsyncLacksBody { get; }
    internal static string ERR_BadAsyncReturn { get; }
    internal static string ERR_BadAsyncReturnExpression { get; }
    internal static string ERR_BadAttributeArgument { get; }
    internal static string ERR_BadAttributeParamDefaultArgument { get; }
    internal static string ERR_BadAttributeParamType { get; }
    internal static string ERR_BadAwaitArg { get; }
    internal static string ERR_BadAwaitArg_NeedSystem { get; }
    internal static string ERR_BadAwaitArgIntrinsic { get; }
    internal static string ERR_BadAwaitArgVoidCall { get; }
    internal static string ERR_BadAwaitAsIdentifier { get; }
    internal static string ERR_BadAwaiterPattern { get; }
    internal static string ERR_BadAwaitInCatch { get; }
    internal static string ERR_BadAwaitInCatchFilter { get; }
    internal static string ERR_BadAwaitInFinally { get; }
    internal static string ERR_BadAwaitInLock { get; }
    internal static string ERR_BadAwaitInQuery { get; }
    internal static string ERR_BadAwaitInStaticVariableInitializer { get; }
    internal static string ERR_BadAwaitWithoutAsync { get; }
    internal static string ERR_BadAwaitWithoutAsyncLambda { get; }
    internal static string ERR_BadAwaitWithoutAsyncMethod { get; }
    internal static string ERR_BadAwaitWithoutVoidAsyncMethod { get; }
    internal static string ERR_BadBaseNumber { get; }
    internal static string ERR_BadBaseType { get; }
    internal static string ERR_BadBinaryOperatorSignature { get; }
    internal static string ERR_BadBinaryOps { get; }
    internal static string ERR_BadBinOpArgs { get; }
    internal static string ERR_BadBoolOp { get; }
    internal static string ERR_BadBoundType { get; }
    internal static string ERR_BadCallerFilePathParamWithoutDefaultValue { get; }
    internal static string ERR_BadCallerLineNumberParamWithoutDefaultValue { get; }
    internal static string ERR_BadCallerMemberNameParamWithoutDefaultValue { get; }
    internal static string ERR_BadCastInFixed { get; }
    internal static string ERR_BadCoClassSig { get; }
    internal static string ERR_BadCompatMode { get; }
    internal static string ERR_BadCompilationOption { get; }
    internal static string ERR_BadCompilationOptionValue { get; }
    internal static string ERR_BadConstraintType { get; }
    internal static string ERR_BadConstType { get; }
    internal static string ERR_BadCtorArgCount { get; }
    internal static string ERR_BadDebugType { get; }
    internal static string ERR_BadDelArgCount { get; }
    internal static string ERR_BadDelegateConstructor { get; }
    internal static string ERR_BadDelegateLeave { get; }
    internal static string ERR_BadDestructorName { get; }
    internal static string ERR_BadDirectivePlacement { get; }
    internal static string ERR_BadDynamicConversion { get; }
    internal static string ERR_BadDynamicMethodArg { get; }
    internal static string ERR_BadDynamicMethodArgLambda { get; }
    internal static string ERR_BadDynamicMethodArgMemgrp { get; }
    internal static string ERR_BadDynamicQuery { get; }
    internal static string ERR_BadDynamicTypeof { get; }
    internal static string ERR_BadEmbeddedStmt { get; }
    internal static string ERR_BadEmptyThrow { get; }
    internal static string ERR_BadEmptyThrowInFinally { get; }
    internal static string ERR_BadEventUsage { get; }
    internal static string ERR_BadEventUsageNoField { get; }
    internal static string ERR_BadExceptionType { get; }
    internal static string ERR_BadExtensionAgg { get; }
    internal static string ERR_BadExtensionArgTypes { get; }
    internal static string ERR_BadExtensionMeth { get; }
    internal static string ERR_BadExternAlias { get; }
    internal static string ERR_BadExternIdentifier { get; }
    internal static string ERR_BadFinallyLeave { get; }
    internal static string ERR_BadFixedInitType { get; }
    internal static string ERR_BadForeachDecl { get; }
    internal static string ERR_BadGetEnumerator { get; }
    internal static string ERR_BadIncDecRetType { get; }
    internal static string ERR_BadIncDecSignature { get; }
    internal static string ERR_BadIndexCount { get; }
    internal static string ERR_BadIndexerNameAttr { get; }
    internal static string ERR_BadIndexLHS { get; }
    internal static string ERR_BadInstanceArgType { get; }
    internal static string ERR_BadIteratorArgType { get; }
    internal static string ERR_BadIteratorReturn { get; }
    internal static string ERR_BadMemberFlag { get; }
    internal static string ERR_BadMemberProtection { get; }
    internal static string ERR_BadModifierLocation { get; }
    internal static string ERR_BadModifiersOnNamespace { get; }
    internal static string ERR_BadNamedArgument { get; }
    internal static string ERR_BadNamedArgumentForDelegateInvoke { get; }
    internal static string ERR_BadNamedAttributeArgument { get; }
    internal static string ERR_BadNamedAttributeArgumentType { get; }
    internal static string ERR_BadNewExpr { get; }
    internal static string ERR_BadOperatorSyntax { get; }
    internal static string ERR_BadOutWithThis { get; }
    internal static string ERR_BadParamExtraRef { get; }
    internal static string ERR_BadParamModThis { get; }
    internal static string ERR_BadParamRef { get; }
    internal static string ERR_BadParamType { get; }
    internal static string ERR_BadPdbData { get; }
    internal static string ERR_BadPlatformType { get; }
    internal static string ERR_BadPrefer32OnLib { get; }
    internal static string ERR_BadProtectedAccess { get; }
    internal static string ERR_BadRefWithThis { get; }
    internal static string ERR_BadResourceVis { get; }
    internal static string ERR_BadRetType { get; }
    internal static string ERR_BadShiftOperatorSignature { get; }
    internal static string ERR_BadSKknown { get; }
    internal static string ERR_BadSKunknown { get; }
    internal static string ERR_BadSpecialByRefLocal { get; }
    internal static string ERR_BadStackAllocExpr { get; }
    internal static string ERR_BadSwitch { get; }
    internal static string ERR_BadThisParam { get; }
    internal static string ERR_BadTypeArgument { get; }
    internal static string ERR_BadTypeforThis { get; }
    internal static string ERR_BadTypeReference { get; }
    internal static string ERR_BadUnaryOp { get; }
    internal static string ERR_BadUnaryOperatorSignature { get; }
    internal static string ERR_BadUnOpArgs { get; }
    internal static string ERR_BadUsingNamespace { get; }
    internal static string ERR_BadUsingType { get; }
    internal static string ERR_BadVarargs { get; }
    internal static string ERR_BadVarDecl { get; }
    internal static string ERR_BadVisBaseClass { get; }
    internal static string ERR_BadVisBaseInterface { get; }
    internal static string ERR_BadVisBound { get; }
    internal static string ERR_BadVisDelegateParam { get; }
    internal static string ERR_BadVisDelegateReturn { get; }
    internal static string ERR_BadVisEventType { get; }
    internal static string ERR_BadVisFieldType { get; }
    internal static string ERR_BadVisIndexerParam { get; }
    internal static string ERR_BadVisIndexerReturn { get; }
    internal static string ERR_BadVisOpParam { get; }
    internal static string ERR_BadVisOpReturn { get; }
    internal static string ERR_BadVisParamType { get; }
    internal static string ERR_BadVisPropertyType { get; }
    internal static string ERR_BadVisReturnType { get; }
    internal static string ERR_BadWarningLevel { get; }
    internal static string ERR_BadWin32Res { get; }
    internal static string ERR_BadYieldInCatch { get; }
    internal static string ERR_BadYieldInFinally { get; }
    internal static string ERR_BadYieldInTryOfCatch { get; }
    internal static string ERR_BaseClassMustBeFirst { get; }
    internal static string ERR_BaseConstraintConflict { get; }
    internal static string ERR_BaseIllegal { get; }
    internal static string ERR_BaseInBadContext { get; }
    internal static string ERR_BaseInStaticMeth { get; }
    internal static string ERR_BinaryFile { get; }
    internal static string ERR_BindToBogus { get; }
    internal static string ERR_BindToBogusProp1 { get; }
    internal static string ERR_BindToBogusProp2 { get; }
    internal static string ERR_BlockBodyAndExpressionBody { get; }
    internal static string ERR_BogusExplicitImpl { get; }
    internal static string ERR_BogusType { get; }
    internal static string ERR_ByRefParameterInExpressionTree { get; }
    internal static string ERR_ByRefReturnUnsupported { get; }
    internal static string ERR_ByRefTypeAndAwait { get; }
    internal static string ERR_CallingBaseFinalizeDeprecated { get; }
    internal static string ERR_CallingFinalizeDeprecated { get; }
    internal static string ERR_CannotPassNullForFriendAssembly { get; }
    internal static string ERR_CantCallSpecialMethod { get; }
    internal static string ERR_CantChangeAccessOnOverride { get; }
    internal static string ERR_CantChangeReturnTypeOnOverride { get; }
    internal static string ERR_CantChangeTypeOnOverride { get; }
    internal static string ERR_CantConvAnonMethNoParams { get; }
    internal static string ERR_CantConvAnonMethParams { get; }
    internal static string ERR_CantConvAnonMethReturns { get; }
    internal static string ERR_CantConvAsyncAnonFuncReturns { get; }
    internal static string ERR_CantDeriveFromSealedType { get; }
    internal static string ERR_CantHaveWin32ResAndIcon { get; }
    internal static string ERR_CantHaveWin32ResAndManifest { get; }
    internal static string ERR_CantInferMethTypeArgs { get; }
    internal static string ERR_CantMakeTempFile { get; }
    internal static string ERR_CantOpenFileWrite { get; }
    internal static string ERR_CantOpenIcon { get; }
    internal static string ERR_CantOpenWin32Manifest { get; }
    internal static string ERR_CantOpenWin32Res { get; }
    internal static string ERR_CantOverrideBogusMethod { get; }
    internal static string ERR_CantOverrideNonEvent { get; }
    internal static string ERR_CantOverrideNonFunction { get; }
    internal static string ERR_CantOverrideNonProperty { get; }
    internal static string ERR_CantOverrideNonVirtual { get; }
    internal static string ERR_CantOverrideSealed { get; }
    internal static string ERR_CantReadConfigFile { get; }
    internal static string ERR_CantReadResource { get; }
    internal static string ERR_CantReadRulesetFile { get; }
    internal static string ERR_CantRefResource { get; }
    internal static string ERR_CantReturnVoid { get; }
    internal static string ERR_CantSetWin32Manifest { get; }
    internal static string ERR_CantUseRequiredAttribute { get; }
    internal static string ERR_CheckedOverflow { get; }
    internal static string ERR_CircConstValue { get; }
    internal static string ERR_CircularBase { get; }
    internal static string ERR_CircularConstraint { get; }
    internal static string ERR_ClassBoundNotFirst { get; }
    internal static string ERR_ClassDoesntImplementInterface { get; }
    internal static string ERR_ClassTypeExpected { get; }
    internal static string ERR_CloseParenExpected { get; }
    internal static string ERR_CloseUnimplementedInterfaceMemberNotPublic { get; }
    internal static string ERR_CloseUnimplementedInterfaceMemberStatic { get; }
    internal static string ERR_CloseUnimplementedInterfaceMemberWrongReturnType { get; }
    internal static string ERR_CmdOptionConflictsSource { get; }
    internal static string ERR_ColColWithTypeAlias { get; }
    internal static string ERR_CollectionInitRequiresIEnumerable { get; }
    internal static string ERR_ComImportWithBase { get; }
    internal static string ERR_ComImportWithImpl { get; }
    internal static string ERR_ComImportWithInitializers { get; }
    internal static string ERR_ComImportWithoutUuidAttribute { get; }
    internal static string ERR_ComImportWithUserCtor { get; }
    internal static string ERR_CompileCancelled { get; }
    internal static string ERR_ComRefCallInExpressionTree { get; }
    internal static string ERR_ConcreteMissingBody { get; }
    internal static string ERR_ConditionalMustReturnVoid { get; }
    internal static string ERR_ConditionalOnInterfaceMethod { get; }
    internal static string ERR_ConditionalOnNonAttributeClass { get; }
    internal static string ERR_ConditionalOnOverride { get; }
    internal static string ERR_ConditionalOnSpecialMethod { get; }
    internal static string ERR_ConditionalWithOutParam { get; }
    internal static string ERR_ConflictAliasAndMember { get; }
    internal static string ERR_ConflictingAliasAndDefinition { get; }
    internal static string ERR_ConflictingMachineModule { get; }
    internal static string ERR_ConstantExpected { get; }
    internal static string ERR_ConstantStringTooLong { get; }
    internal static string ERR_ConstOutOfRange { get; }
    internal static string ERR_ConstOutOfRangeChecked { get; }
    internal static string ERR_ConstraintIsStaticClass { get; }
    internal static string ERR_ConstraintOnlyAllowedOnGenericDecl { get; }
    internal static string ERR_ConstructedDynamicTypeAsBound { get; }
    internal static string ERR_ConstructorInStaticClass { get; }
    internal static string ERR_ConstValueRequired { get; }
    internal static string ERR_ConversionNotInvolvingContainedType { get; }
    internal static string ERR_ConversionWithBase { get; }
    internal static string ERR_ConversionWithDerived { get; }
    internal static string ERR_ConversionWithInterface { get; }
    internal static string ERR_ConvertToStaticClass { get; }
    internal static string ERR_ConWithValCon { get; }
    internal static string ERR_CryptoHashFailed { get; }
    internal static string ERR_CStyleArray { get; }
    internal static string ERR_CycleInInterfaceInheritance { get; }
    internal static string ERR_CycleInTypeForwarder { get; }
    internal static string ERR_DebugEntryPointNotSourceMethodDefinition { get; }
    internal static string ERR_DecConstError { get; }
    internal static string ERR_DefaultMemberOnIndexedType { get; }
    internal static string ERR_DefaultValueBadValueType { get; }
    internal static string ERR_DefaultValueBeforeRequiredValue { get; }
    internal static string ERR_DefaultValueForExtensionParameter { get; }
    internal static string ERR_DefaultValueForParamsParameter { get; }
    internal static string ERR_DefaultValueMustBeConstant { get; }
    internal static string ERR_DefaultValueNotAllowed { get; }
    internal static string ERR_DefaultValueTypeMustMatch { get; }
    internal static string ERR_DefaultValueUsedWithAttributes { get; }
    internal static string ERR_DelegateOnConditional { get; }
    internal static string ERR_DelegateOnNullable { get; }
    internal static string ERR_DeprecatedCollectionInitAddStr { get; }
    internal static string ERR_DeprecatedSymbolStr { get; }
    internal static string ERR_DeriveFromConstructedDynamic { get; }
    internal static string ERR_DeriveFromDynamic { get; }
    internal static string ERR_DeriveFromEnumOrValueType { get; }
    internal static string ERR_DerivingFromATyVar { get; }
    internal static string ERR_DestructorInStaticClass { get; }
    internal static string ERR_DictionaryInitializerInExpressionTree { get; }
    internal static string ERR_DllImportOnGenericMethod { get; }
    internal static string ERR_DllImportOnInvalidMethod { get; }
    internal static string ERR_DoesntImplementAwaitInterface { get; }
    internal static string ERR_DoNotUseFixedBufferAttr { get; }
    internal static string ERR_DottedTypeNameNotFoundInAgg { get; }
    internal static string ERR_DottedTypeNameNotFoundInNS { get; }
    internal static string ERR_DottedTypeNameNotFoundInNSFwd { get; }
    internal static string ERR_DuplicateAccessor { get; }
    internal static string ERR_DuplicateAlias { get; }
    internal static string ERR_DuplicateAttribute { get; }
    internal static string ERR_DuplicateAttributeInNetModule { get; }
    internal static string ERR_DuplicateBound { get; }
    internal static string ERR_DuplicateCaseLabel { get; }
    internal static string ERR_DuplicateConstraintClause { get; }
    internal static string ERR_DuplicateConversionInClass { get; }
    internal static string ERR_DuplicateGeneratedName { get; }
    internal static string ERR_DuplicateImport { get; }
    internal static string ERR_DuplicateImportSimple { get; }
    internal static string ERR_DuplicateInterfaceInBaseList { get; }
    internal static string ERR_DuplicateLabel { get; }
    internal static string ERR_DuplicateModifier { get; }
    internal static string ERR_DuplicateNamedArgument { get; }
    internal static string ERR_DuplicateNamedAttributeArgument { get; }
    internal static string ERR_DuplicateNameInClass { get; }
    internal static string ERR_DuplicateNameInNS { get; }
    internal static string ERR_DuplicateParamName { get; }
    internal static string ERR_DuplicatePropertyAccessMods { get; }
    internal static string ERR_DuplicateTypeForwarder { get; }
    internal static string ERR_DuplicateTypeParameter { get; }
    internal static string ERR_DupParamMod { get; }
    internal static string ERR_DynamicAttributeMissing { get; }
    internal static string ERR_DynamicRequiredTypesMissing { get; }
    internal static string ERR_DynamicTypeAsBound { get; }
    internal static string ERR_EmptyCharConst { get; }
    internal static string ERR_EmptyElementInitializer { get; }
    internal static string ERR_EmptyFormatSpecifier { get; }
    internal static string ERR_EmptyYield { get; }
    internal static string ERR_EncNoPIAReference { get; }
    internal static string ERR_EncodinglessSyntaxTree { get; }
    internal static string ERR_EncReferenceToAddedMember { get; }
    internal static string ERR_EncUpdateFailedMissingAttribute { get; }
    internal static string ERR_EndifDirectiveExpected { get; }
    internal static string ERR_EndOfPPLineExpected { get; }
    internal static string ERR_EndRegionDirectiveExpected { get; }
    internal static string ERR_EnumeratorOverflow { get; }
    internal static string ERR_EnumsCantContainDefaultConstructor { get; }
    internal static string ERR_EOFExpected { get; }
    internal static string ERR_ErrorBuildingWin32Resources { get; }
    internal static string ERR_ErrorDirective { get; }
    internal static string ERR_ErrorInReferencedAssembly { get; }
    internal static string ERR_EscapedCurly { get; }
    internal static string ERR_EventNeedsBothAccessors { get; }
    internal static string ERR_EventNotDelegate { get; }
    internal static string ERR_EventPropertyInInterface { get; }
    internal static string ERR_ExpectedContextualKeywordBy { get; }
    internal static string ERR_ExpectedContextualKeywordEquals { get; }
    internal static string ERR_ExpectedContextualKeywordOn { get; }
    internal static string ERR_ExpectedEndTry { get; }
    internal static string ERR_ExpectedPPFile { get; }
    internal static string ERR_ExpectedSelectOrGroup { get; }
    internal static string ERR_ExpectedSingleScript { get; }
    internal static string ERR_ExpectedVerbatimLiteral { get; }
    internal static string ERR_ExplicitDynamicAttr { get; }
    internal static string ERR_ExplicitEventFieldImpl { get; }
    internal static string ERR_ExplicitExtension { get; }
    internal static string ERR_ExplicitImplCollisionOnRefOut { get; }
    internal static string ERR_ExplicitImplParams { get; }
    internal static string ERR_ExplicitInterfaceImplementationInNonClassOrStruct { get; }
    internal static string ERR_ExplicitInterfaceImplementationNotInterface { get; }
    internal static string ERR_ExplicitLayoutAndAutoImplementedProperty { get; }
    internal static string ERR_ExplicitMethodImplAccessor { get; }
    internal static string ERR_ExplicitParamArray { get; }
    internal static string ERR_ExplicitPropertyAddingAccessor { get; }
    internal static string ERR_ExplicitPropertyMissingAccessor { get; }
    internal static string ERR_ExportedTypeConflictsWithDeclaration { get; }
    internal static string ERR_ExportedTypesConflict { get; }
    internal static string ERR_ExpressionExpected { get; }
    internal static string ERR_ExpressionHasNoName { get; }
    internal static string ERR_ExpressionOrDeclarationExpected { get; }
    internal static string ERR_ExpressionTreeContainsAnonymousMethod { get; }
    internal static string ERR_ExpressionTreeContainsAssignment { get; }
    internal static string ERR_ExpressionTreeContainsBadCoalesce { get; }
    internal static string ERR_ExpressionTreeContainsBaseAccess { get; }
    internal static string ERR_ExpressionTreeContainsDynamicOperation { get; }
    internal static string ERR_ExpressionTreeContainsIndexedProperty { get; }
    internal static string ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer { get; }
    internal static string ERR_ExpressionTreeContainsNamedArgument { get; }
    internal static string ERR_ExpressionTreeContainsOptionalArgument { get; }
    internal static string ERR_ExpressionTreeContainsPointerOp { get; }
    internal static string ERR_ExpressionTreeMustHaveDelegate { get; }
    internal static string ERR_ExtensionAttrNotFound { get; }
    internal static string ERR_ExtensionCollectionElementInitializerInExpressionTree { get; }
    internal static string ERR_ExtensionMethodsDecl { get; }
    internal static string ERR_ExternAfterElements { get; }
    internal static string ERR_ExternAliasNotAllowed { get; }
    internal static string ERR_ExternHasBody { get; }
    internal static string ERR_ExternHasConstructorInitializer { get; }
    internal static string ERR_FeatureIsExperimental { get; }
    internal static string ERR_FeatureNotAvailableInVersion1 { get; }
    internal static string ERR_FeatureNotAvailableInVersion2 { get; }
    internal static string ERR_FeatureNotAvailableInVersion3 { get; }
    internal static string ERR_FeatureNotAvailableInVersion4 { get; }
    internal static string ERR_FeatureNotAvailableInVersion5 { get; }
    internal static string ERR_FeatureNotAvailableInVersion6 { get; }
    internal static string ERR_FeatureNotValidInExpressionTree { get; }
    internal static string ERR_FieldCantBeRefAny { get; }
    internal static string ERR_FieldCantHaveVoidType { get; }
    internal static string ERR_FieldHasMultipleDistinctConstantValues { get; }
    internal static string ERR_FieldInitializerInStruct { get; }
    internal static string ERR_FieldInitRefNonstatic { get; }
    internal static string ERR_FileNotFound { get; }
    internal static string ERR_FixedBufferNotFixed { get; }
    internal static string ERR_FixedBufferTooManyDimensions { get; }
    internal static string ERR_FixedDimsRequired { get; }
    internal static string ERR_FixedLocalInLambda { get; }
    internal static string ERR_FixedMustInit { get; }
    internal static string ERR_FixedNeeded { get; }
    internal static string ERR_FixedNeedsLvalue { get; }
    internal static string ERR_FixedNotInStruct { get; }
    internal static string ERR_FixedNotNeeded { get; }
    internal static string ERR_FixedOverflow { get; }
    internal static string ERR_FloatOverflow { get; }
    internal static string ERR_ForEachMissingMember { get; }
    internal static string ERR_ForwardedTypeConflictsWithDeclaration { get; }
    internal static string ERR_ForwardedTypeConflictsWithExportedType { get; }
    internal static string ERR_ForwardedTypeInThisAssembly { get; }
    internal static string ERR_ForwardedTypeIsNested { get; }
    internal static string ERR_ForwardedTypesConflict { get; }
    internal static string ERR_FriendAssemblyBadArgs { get; }
    internal static string ERR_FriendAssemblySNReq { get; }
    internal static string ERR_FriendRefNotEqualToThis { get; }
    internal static string ERR_FriendRefSigningMismatch { get; }
    internal static string ERR_GenericArgIsStaticClass { get; }
    internal static string ERR_GenericConstraintNotSatisfiedNullableEnum { get; }
    internal static string ERR_GenericConstraintNotSatisfiedNullableInterface { get; }
    internal static string ERR_GenericConstraintNotSatisfiedRefType { get; }
    internal static string ERR_GenericConstraintNotSatisfiedTyVar { get; }
    internal static string ERR_GenericConstraintNotSatisfiedValType { get; }
    internal static string ERR_GenericDerivingFromAttribute { get; }
    internal static string ERR_GenericsUsedAcrossAssemblies { get; }
    internal static string ERR_GenericsUsedInNoPIAType { get; }
    internal static string ERR_GetOrSetExpected { get; }
    internal static string ERR_GlobalAttributesNotAllowed { get; }
    internal static string ERR_GlobalAttributesNotFirst { get; }
    internal static string ERR_GlobalDefinitionOrStatementExpected { get; }
    internal static string ERR_GlobalExternAlias { get; }
    internal static string ERR_GlobalSingleTypeNameNotFound { get; }
    internal static string ERR_GlobalSingleTypeNameNotFoundFwd { get; }
    internal static string ERR_GlobalStatement { get; }
    internal static string ERR_HasNoTypeVars { get; }
    internal static string ERR_HidingAbstractMethod { get; }
    internal static string ERR_IdentifierExpected { get; }
    internal static string ERR_IdentifierExpectedKW { get; }
    internal static string ERR_IdentityConversion { get; }
    internal static string ERR_IllegalArglist { get; }
    internal static string ERR_IllegalEscape { get; }
    internal static string ERR_IllegalFixedType { get; }
    internal static string ERR_IllegalInnerUnsafe { get; }
    internal static string ERR_IllegalParams { get; }
    internal static string ERR_IllegalRefParam { get; }
    internal static string ERR_IllegalStatement { get; }
    internal static string ERR_IllegalUnsafe { get; }
    internal static string ERR_IllegalVarArgs { get; }
    internal static string ERR_IllegalVarianceSyntax { get; }
    internal static string ERR_ImplBadConstraints { get; }
    internal static string ERR_ImplicitlyTypedArrayNoBestType { get; }
    internal static string ERR_ImplicitlyTypedLocalCannotBeFixed { get; }
    internal static string ERR_ImplicitlyTypedVariableAssignedArrayInitializer { get; }
    internal static string ERR_ImplicitlyTypedVariableAssignedBadValue { get; }
    internal static string ERR_ImplicitlyTypedVariableCannotBeConst { get; }
    internal static string ERR_ImplicitlyTypedVariableMultipleDeclarator { get; }
    internal static string ERR_ImplicitlyTypedVariableWithNoInitializer { get; }
    internal static string ERR_ImportedCircularBase { get; }
    internal static string ERR_ImportNonAssembly { get; }
    internal static string ERR_InaccessibleGetter { get; }
    internal static string ERR_InaccessibleSetter { get; }
    internal static string ERR_InAttrOnOutParam { get; }
    internal static string ERR_InconsistentIndexerNames { get; }
    internal static string ERR_InconsistentLambdaParameterUsage { get; }
    internal static string ERR_IncrementLvalueExpected { get; }
    internal static string ERR_IndexedPropertyMustHaveAllOptionalParams { get; }
    internal static string ERR_IndexedPropertyRequiresParams { get; }
    internal static string ERR_IndexerCantHaveVoidType { get; }
    internal static string ERR_IndexerInStaticClass { get; }
    internal static string ERR_IndexerNeedsParam { get; }
    internal static string ERR_IndirectRecursiveConstructorCall { get; }
    internal static string ERR_InExpected { get; }
    internal static string ERR_InitializerAddHasParamModifiers { get; }
    internal static string ERR_InitializerAddHasWrongSignature { get; }
    internal static string ERR_InitializerInStructWithoutExplicitConstructor { get; }
    internal static string ERR_InitializerOnNonAutoProperty { get; }
    internal static string ERR_InstanceMemberInStaticClass { get; }
    internal static string ERR_InstantiatingStaticClass { get; }
    internal static string ERR_InsufficientStack { get; }
    internal static string ERR_IntDivByZero { get; }
    internal static string ERR_IntegralTypeExpected { get; }
    internal static string ERR_IntegralTypeValueExpected { get; }
    internal static string ERR_InterfaceEventInitializer { get; }
    internal static string ERR_InterfaceImplementedByConditional { get; }
    internal static string ERR_InterfaceMemberHasBody { get; }
    internal static string ERR_InterfaceMemberNotFound { get; }
    internal static string ERR_InterfacesCannotContainTypes { get; }
    internal static string ERR_InterfacesCantContainConstructors { get; }
    internal static string ERR_InterfacesCantContainFields { get; }
    internal static string ERR_InterfacesCantContainOperators { get; }
    internal static string ERR_InteropMethodWithBody { get; }
    internal static string ERR_InteropStructContainsMethods { get; }
    internal static string ERR_InteropTypeMissingAttribute { get; }
    internal static string ERR_InteropTypesWithSameNameAndGuid { get; }
    internal static string ERR_IntOverflow { get; }
    internal static string ERR_InvalidAddrOp { get; }
    internal static string ERR_InvalidAnonymousTypeMemberDeclarator { get; }
    internal static string ERR_InvalidArray { get; }
    internal static string ERR_InvalidAssemblyCulture { get; }
    internal static string ERR_InvalidAssemblyCultureForExe { get; }
    internal static string ERR_InvalidAssemblyName { get; }
    internal static string ERR_InvalidAttributeArgument { get; }
    internal static string ERR_InvalidConstantDeclarationType { get; }
    internal static string ERR_InvalidDebugInformationFormat { get; }
    internal static string ERR_InvalidDelegateType { get; }
    internal static string ERR_InvalidDynamicCondition { get; }
    internal static string ERR_InvalidExprTerm { get; }
    internal static string ERR_InvalidFileAlignment { get; }
    internal static string ERR_InvalidFixedArraySize { get; }
    internal static string ERR_InvalidFormatForGuidForOption { get; }
    internal static string ERR_InvalidFwdType { get; }
    internal static string ERR_InvalidGotoCase { get; }
    internal static string ERR_InvalidInitializerElementInitializer { get; }
    internal static string ERR_InvalidLineNumber { get; }
    internal static string ERR_InvalidMemberDecl { get; }
    internal static string ERR_InvalidNamedArgument { get; }
    internal static string ERR_InvalidNumber { get; }
    internal static string ERR_InvalidOutputName { get; }
    internal static string ERR_InvalidPathMap { get; }
    internal static string ERR_InvalidPreprocExpr { get; }
    internal static string ERR_InvalidPropertyAccessMod { get; }
    internal static string ERR_InvalidQM { get; }
    internal static string ERR_InvalidReal { get; }
    internal static string ERR_InvalidSignaturePublicKey { get; }
    internal static string ERR_InvalidSpecifier { get; }
    internal static string ERR_InvalidSubsystemVersion { get; }
    internal static string ERR_InvalidVersionFormat { get; }
    internal static string ERR_InvalidVersionFormat2 { get; }
    internal static string ERR_IteratorInInteractive { get; }
    internal static string ERR_LabelNotFound { get; }
    internal static string ERR_LabelShadow { get; }
    internal static string ERR_LambdaInIsAs { get; }
    internal static string ERR_LbraceExpected { get; }
    internal static string ERR_LegacyObjectIdSyntax { get; }
    internal static string ERR_LinkedNetmoduleMetadataMustProvideFullPEImage { get; }
    internal static string ERR_LiteralDoubleCast { get; }
    internal static string ERR_LoadDirectiveOnlyAllowedInScripts { get; }
    internal static string ERR_LocalCantBeFixedAndHoisted { get; }
    internal static string ERR_LocalDuplicate { get; }
    internal static string ERR_LocalIllegallyOverrides { get; }
    internal static string ERR_LocalSameNameAsTypeParam { get; }
    internal static string ERR_LocalTypeNameClash { get; }
    internal static string ERR_LockNeedsReference { get; }
    internal static string ERR_LookupInTypeVariable { get; }
    internal static string ERR_MainCantBeAsync { get; }
    internal static string ERR_MainClassIsImport { get; }
    internal static string ERR_MainClassNotClass { get; }
    internal static string ERR_MainClassNotFound { get; }
    internal static string ERR_ManagedAddr { get; }
    internal static string ERR_MarshalUnmanagedTypeNotValidForFields { get; }
    internal static string ERR_MarshalUnmanagedTypeOnlyValidForFields { get; }
    internal static string ERR_MemberAlreadyExists { get; }
    internal static string ERR_MemberAlreadyInitialized { get; }
    internal static string ERR_MemberCannotBeInitialized { get; }
    internal static string ERR_MemberNameSameAsType { get; }
    internal static string ERR_MemberNeedsType { get; }
    internal static string ERR_MemberReserved { get; }
    internal static string ERR_MemGroupInExpressionTree { get; }
    internal static string ERR_MetadataNameTooLong { get; }
    internal static string ERR_MetadataReferencesNotSupported { get; }
    internal static string ERR_MethDelegateMismatch { get; }
    internal static string ERR_MethGrpToNonDel { get; }
    internal static string ERR_MethodArgCantBeRefAny { get; }
    internal static string ERR_MethodImplementingAccessor { get; }
    internal static string ERR_MethodNameExpected { get; }
    internal static string ERR_MethodReturnCantBeRefAny { get; }
    internal static string ERR_MissingArgument { get; }
    internal static string ERR_MissingArraySize { get; }
    internal static string ERR_MissingCoClass { get; }
    internal static string ERR_MissingDebugSwitch { get; }
    internal static string ERR_MissingGuidForOption { get; }
    internal static string ERR_MissingMethodOnSourceInterface { get; }
    internal static string ERR_MissingNetModuleReference { get; }
    internal static string ERR_MissingPartial { get; }
    internal static string ERR_MissingPPFile { get; }
    internal static string ERR_MissingPredefinedMember { get; }
    internal static string ERR_MissingSourceInterface { get; }
    internal static string ERR_MissingStructOffset { get; }
    internal static string ERR_MissingTypeInAssembly { get; }
    internal static string ERR_MissingTypeInSource { get; }
    internal static string ERR_MixingWinRTEventWithRegular { get; }
    internal static string ERR_ModuleEmitFailure { get; }
    internal static string ERR_MultiParamMod { get; }
    internal static string ERR_MultipleEntryPoints { get; }
    internal static string ERR_MultipleIEnumOfT { get; }
    internal static string ERR_MultiTypeInDeclaration { get; }
    internal static string ERR_MustHaveOpTF { get; }
    internal static string ERR_MutuallyExclusiveOptions { get; }
    internal static string ERR_NamedArgumentExpected { get; }
    internal static string ERR_NamedArgumentForArray { get; }
    internal static string ERR_NamedArgumentSpecificationBeforeFixedArgument { get; }
    internal static string ERR_NamedArgumentUsedInPositional { get; }
    internal static string ERR_NameNotInContext { get; }
    internal static string ERR_NameNotInContextPossibleMissingReference { get; }
    internal static string ERR_NameofExtensionMethod { get; }
    internal static string ERR_NameofMethodGroupWithTypeParameters { get; }
    internal static string ERR_NamespaceNotAllowedInScript { get; }
    internal static string ERR_NamespaceUnexpected { get; }
    internal static string ERR_NegativeArraySize { get; }
    internal static string ERR_NegativeStackAllocSize { get; }
    internal static string ERR_NetModuleNameMismatch { get; }
    internal static string ERR_NetModuleNameMustBeUnique { get; }
    internal static string ERR_NewBoundMustBeLast { get; }
    internal static string ERR_NewBoundWithVal { get; }
    internal static string ERR_NewCoClassOnLink { get; }
    internal static string ERR_NewConstraintNotSatisfied { get; }
    internal static string ERR_NewlineInConst { get; }
    internal static string ERR_NewTyvarWithArgs { get; }
    internal static string ERR_NewVirtualInSealed { get; }
    internal static string ERR_NoAliasHere { get; }
    internal static string ERR_NoBaseClass { get; }
    internal static string ERR_NoBreakOrCont { get; }
    internal static string ERR_NoCanonicalView { get; }
    internal static string ERR_NoConstructors { get; }
    internal static string ERR_NoConversionForCallerFilePathParam { get; }
    internal static string ERR_NoConversionForCallerLineNumberParam { get; }
    internal static string ERR_NoConversionForCallerMemberNameParam { get; }
    internal static string ERR_NoConversionForDefaultParam { get; }
    internal static string ERR_NoConversionForNubDefaultParam { get; }
    internal static string ERR_NoConvToIDisp { get; }
    internal static string ERR_NoCorrespondingArgument { get; }
    internal static string ERR_NoDynamicPhantomOnBase { get; }
    internal static string ERR_NoDynamicPhantomOnBaseCtor { get; }
    internal static string ERR_NoDynamicPhantomOnBaseIndexer { get; }
    internal static string ERR_NoEntryPoint { get; }
    internal static string ERR_NoExplicitBuiltinConv { get; }
    internal static string ERR_NoExplicitConv { get; }
    internal static string ERR_NoFileSpec { get; }
    internal static string ERR_NoGetToOverride { get; }
    internal static string ERR_NoImplicitConv { get; }
    internal static string ERR_NoImplicitConvCast { get; }
    internal static string ERR_NoMainInClass { get; }
    internal static string ERR_NoMainOnDLL { get; }
    internal static string ERR_NoMetadataFile { get; }
    internal static string ERR_NoModifiersOnAccessor { get; }
    internal static string ERR_NoMultipleInheritance { get; }
    internal static string ERR_NoNamespacePrivate { get; }
    internal static string ERR_NoNewAbstract { get; }
    internal static string ERR_NoNewTyvar { get; }
    internal static string ERR_NonInterfaceInInterfaceList { get; }
    internal static string ERR_NonInvocableMemberCalled { get; }
    internal static string ERR_NoPIAAssemblyMissingAttribute { get; }
    internal static string ERR_NoPIAAssemblyMissingAttributes { get; }
    internal static string ERR_NoPIANestedType { get; }
    internal static string ERR_NoSetToOverride { get; }
    internal static string ERR_NoSourceFile { get; }
    internal static string ERR_NoSuchMember { get; }
    internal static string ERR_NoSuchMemberOrExtension { get; }
    internal static string ERR_NoSuchMemberOrExtensionNeedUsing { get; }
    internal static string ERR_NotAnAttributeClass { get; }
    internal static string ERR_NotConstantExpression { get; }
    internal static string ERR_NotNullConstRefField { get; }
    internal static string ERR_NotNullRefDefaultParameter { get; }
    internal static string ERR_NotYetImplementedInRoslyn { get; }
    internal static string ERR_NoTypeDef { get; }
    internal static string ERR_NoTypeDefFromModule { get; }
    internal static string ERR_NoVoidHere { get; }
    internal static string ERR_NoVoidParameter { get; }
    internal static string ERR_NullNotValid { get; }
    internal static string ERR_NullPropagatingOpInExpressionTree { get; }
    internal static string ERR_ObjectCallingBaseConstructor { get; }
    internal static string ERR_ObjectCantHaveBases { get; }
    internal static string ERR_ObjectOrCollectionInitializerWithDelegateCreation { get; }
    internal static string ERR_ObjectProhibited { get; }
    internal static string ERR_ObjectRequired { get; }
    internal static string ERR_OneAliasPerReference { get; }
    internal static string ERR_OnlyClassesCanContainDestructors { get; }
    internal static string ERR_OpenEndedComment { get; }
    internal static string ERR_OpenResponseFile { get; }
    internal static string ERR_OperatorCantReturnVoid { get; }
    internal static string ERR_OperatorInStaticClass { get; }
    internal static string ERR_OperatorNeedsMatch { get; }
    internal static string ERR_OperatorsMustBeStatic { get; }
    internal static string ERR_OpTFRetType { get; }
    internal static string ERR_OptionMustBeAbsolutePath { get; }
    internal static string ERR_OutAttrOnRefParam { get; }
    internal static string ERR_OutputNeedsName { get; }
    internal static string ERR_OutputWriteFailed { get; }
    internal static string ERR_OverloadRefOut { get; }
    internal static string ERR_OverloadRefOutCtor { get; }
    internal static string ERR_OverrideFinalizeDeprecated { get; }
    internal static string ERR_OverrideNotExpected { get; }
    internal static string ERR_OverrideNotNew { get; }
    internal static string ERR_OverrideWithConstraints { get; }
    internal static string ERR_OvlBinaryOperatorExpected { get; }
    internal static string ERR_OvlOperatorExpected { get; }
    internal static string ERR_OvlUnaryOperatorExpected { get; }
    internal static string ERR_ParamDefaultValueDiffersFromAttribute { get; }
    internal static string ERR_ParameterIsStaticClass { get; }
    internal static string ERR_ParameterNotValidForType { get; }
    internal static string ERR_ParamsCantBeRefOut { get; }
    internal static string ERR_ParamsLast { get; }
    internal static string ERR_ParamsMustBeArray { get; }
    internal static string ERR_ParamUnassigned { get; }
    internal static string ERR_PartialMethodCannotHaveOutParameters { get; }
    internal static string ERR_PartialMethodExtensionDifference { get; }
    internal static string ERR_PartialMethodInconsistentConstraints { get; }
    internal static string ERR_PartialMethodInExpressionTree { get; }
    internal static string ERR_PartialMethodInvalidModifier { get; }
    internal static string ERR_PartialMethodMustHaveLatent { get; }
    internal static string ERR_PartialMethodMustReturnVoid { get; }
    internal static string ERR_PartialMethodNotExplicit { get; }
    internal static string ERR_PartialMethodOnlyInPartialClass { get; }
    internal static string ERR_PartialMethodOnlyMethods { get; }
    internal static string ERR_PartialMethodOnlyOneActual { get; }
    internal static string ERR_PartialMethodOnlyOneLatent { get; }
    internal static string ERR_PartialMethodParamsDifference { get; }
    internal static string ERR_PartialMethodStaticDifference { get; }
    internal static string ERR_PartialMethodToDelegate { get; }
    internal static string ERR_PartialMethodUnsafeDifference { get; }
    internal static string ERR_PartialMisplaced { get; }
    internal static string ERR_PartialModifierConflict { get; }
    internal static string ERR_PartialMultipleBases { get; }
    internal static string ERR_PartialTypeKindConflict { get; }
    internal static string ERR_PartialWrongConstraints { get; }
    internal static string ERR_PartialWrongTypeParams { get; }
    internal static string ERR_PartialWrongTypeParamsVariance { get; }
    internal static string ERR_PermissionSetAttributeFileReadError { get; }
    internal static string ERR_PermissionSetAttributeInvalidFile { get; }
    internal static string ERR_PeWritingFailure { get; }
    internal static string ERR_PointerInAsOrIs { get; }
    internal static string ERR_PPDefFollowsToken { get; }
    internal static string ERR_PPDirectiveExpected { get; }
    internal static string ERR_PPLoadFollowsToken { get; }
    internal static string ERR_PPReferenceFollowsToken { get; }
    internal static string ERR_PredefinedTypeNotFound { get; }
    internal static string ERR_PrincipalPermissionInvalidAction { get; }
    internal static string ERR_PrivateAbstractAccessor { get; }
    internal static string ERR_PropertyAccessModInInterface { get; }
    internal static string ERR_PropertyCantHaveVoidType { get; }
    internal static string ERR_PropertyLacksGet { get; }
    internal static string ERR_PropertyWithNoAccessors { get; }
    internal static string ERR_ProtectedInStatic { get; }
    internal static string ERR_ProtectedInStruct { get; }
    internal static string ERR_PtrExpected { get; }
    internal static string ERR_PtrIndexSingle { get; }
    internal static string ERR_PublicKeyContainerFailure { get; }
    internal static string ERR_PublicKeyFileFailure { get; }
    internal static string ERR_PublicSignButNoKey { get; }
    internal static string ERR_QueryDuplicateRangeVariable { get; }
    internal static string ERR_QueryInnerKey { get; }
    internal static string ERR_QueryMultipleProviders { get; }
    internal static string ERR_QueryNoProvider { get; }
    internal static string ERR_QueryNoProviderCastable { get; }
    internal static string ERR_QueryNoProviderStandard { get; }
    internal static string ERR_QueryOuterKey { get; }
    internal static string ERR_QueryOutRefRangeVariable { get; }
    internal static string ERR_QueryRangeVariableAssignedBadValue { get; }
    internal static string ERR_QueryRangeVariableOverrides { get; }
    internal static string ERR_QueryRangeVariableReadOnly { get; }
    internal static string ERR_QueryRangeVariableSameAsTypeParam { get; }
    internal static string ERR_QueryTypeInferenceFailed { get; }
    internal static string ERR_QueryTypeInferenceFailedMulti { get; }
    internal static string ERR_QueryTypeInferenceFailedSelectMany { get; }
    internal static string ERR_RbraceExpected { get; }
    internal static string ERR_ReadonlyValueTypeInObjectInitializer { get; }
    internal static string ERR_RecursiveConstructorCall { get; }
    internal static string ERR_RecursivelyTypedVariable { get; }
    internal static string ERR_RefConstraintNotSatisfied { get; }
    internal static string ERR_ReferenceDirectiveOnlyAllowedInScripts { get; }
    internal static string ERR_RefLvalueExpected { get; }
    internal static string ERR_RefOutDefaultValue { get; }
    internal static string ERR_RefProperty { get; }
    internal static string ERR_RefReadonly { get; }
    internal static string ERR_RefReadonly2 { get; }
    internal static string ERR_RefReadonlyLocal { get; }
    internal static string ERR_RefReadonlyLocal2Cause { get; }
    internal static string ERR_RefReadonlyLocalCause { get; }
    internal static string ERR_RefReadonlyStatic { get; }
    internal static string ERR_RefReadonlyStatic2 { get; }
    internal static string ERR_RefValBoundMustBeFirst { get; }
    internal static string ERR_RefValBoundWithClass { get; }
    internal static string ERR_ReservedAssemblyName { get; }
    internal static string ERR_ReservedEnumerator { get; }
    internal static string ERR_ResourceFileNameNotUnique { get; }
    internal static string ERR_ResourceNotUnique { get; }
    internal static string ERR_RetNoObjectRequired { get; }
    internal static string ERR_RetNoObjectRequiredLambda { get; }
    internal static string ERR_RetObjectRequired { get; }
    internal static string ERR_ReturnExpected { get; }
    internal static string ERR_ReturnInIterator { get; }
    internal static string ERR_ReturnNotLValue { get; }
    internal static string ERR_ReturnTypeIsStaticClass { get; }
    internal static string ERR_SameFullNameAggAgg { get; }
    internal static string ERR_SameFullNameNsAgg { get; }
    internal static string ERR_SameFullNameThisAggThisNs { get; }
    internal static string ERR_SealedNonOverride { get; }
    internal static string ERR_SealedStaticClass { get; }
    internal static string ERR_SecurityAttributeInvalidAction { get; }
    internal static string ERR_SecurityAttributeInvalidActionAssembly { get; }
    internal static string ERR_SecurityAttributeInvalidActionTypeOrMethod { get; }
    internal static string ERR_SecurityAttributeInvalidTarget { get; }
    internal static string ERR_SecurityAttributeMissingAction { get; }
    internal static string ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync { get; }
    internal static string ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct { get; }
    internal static string ERR_SemicolonExpected { get; }
    internal static string ERR_SemiOrLBraceExpected { get; }
    internal static string ERR_SignButNoPrivateKey { get; }
    internal static string ERR_SingleLineCommentInExpressionHole { get; }
    internal static string ERR_SingleTypeNameNotFound { get; }
    internal static string ERR_SingleTypeNameNotFoundFwd { get; }
    internal static string ERR_SizeofUnsafe { get; }
    internal static string ERR_SourceFileReferencesNotSupported { get; }
    internal static string ERR_SpecialByRefInLambda { get; }
    internal static string ERR_SpecialTypeAsBound { get; }
    internal static string ERR_StackallocInCatchFinally { get; }
    internal static string ERR_StatementLambdaToExpressionTree { get; }
    internal static string ERR_StaticBaseClass { get; }
    internal static string ERR_StaticClassInterfaceImpl { get; }
    internal static string ERR_StaticConstant { get; }
    internal static string ERR_StaticConstParam { get; }
    internal static string ERR_StaticConstructorWithAccessModifiers { get; }
    internal static string ERR_StaticConstructorWithExplicitConstructorCall { get; }
    internal static string ERR_StaticDerivedFromNonObject { get; }
    internal static string ERR_StaticInAsOrIs { get; }
    internal static string ERR_StaticMemberInObjectInitializer { get; }
    internal static string ERR_StaticNotVirtual { get; }
    internal static string ERR_StructLayoutCycle { get; }
    internal static string ERR_StructOffsetOnBadField { get; }
    internal static string ERR_StructOffsetOnBadStruct { get; }
    internal static string ERR_StructsCantContainDefaultConstructor { get; }
    internal static string ERR_StructWithBaseConstructorCall { get; }
    internal static string ERR_SubexpressionNotInNameof { get; }
    internal static string ERR_SwitchFallOut { get; }
    internal static string ERR_SwitchFallThrough { get; }
    internal static string ERR_SwitchGoverningTypeValueExpected { get; }
    internal static string ERR_SwitchNeedsNumber { get; }
    internal static string ERR_SwitchNeedsString { get; }
    internal static string ERR_SynchronizedAsyncMethod { get; }
    internal static string ERR_SyntaxError { get; }
    internal static string ERR_SystemVoid { get; }
    internal static string ERR_TaskRetNoObjectRequired { get; }
    internal static string ERR_TaskRetNoObjectRequiredLambda { get; }
    internal static string ERR_ThisInBadContext { get; }
    internal static string ERR_ThisInStaticMeth { get; }
    internal static string ERR_ThisOrBaseExpected { get; }
    internal static string ERR_ThisStructNotInAnonMeth { get; }
    internal static string ERR_TooManyCatches { get; }
    internal static string ERR_TooManyCharsInConst { get; }
    internal static string ERR_TooManyLocals { get; }
    internal static string ERR_TooManyUserStrings { get; }
    internal static string ERR_TrailingWhitespaceInFormatSpecifier { get; }
    internal static string ERR_TypeArgsNotAllowed { get; }
    internal static string ERR_TypeExpected { get; }
    internal static string ERR_TypeParamMustBeIdentifier { get; }
    internal static string ERR_TypeVarCantBeNull { get; }
    internal static string ERR_TypeVariableSameAsParent { get; }
    internal static string ERR_TypeVarNotFound { get; }
    internal static string ERR_TypeVarNotFoundRangeVariable { get; }
    internal static string ERR_TyVarNotFoundInConstraint { get; }
    internal static string ERR_UnassignedThis { get; }
    internal static string ERR_UnassignedThisAutoProperty { get; }
    internal static string ERR_UnboxNotLValue { get; }
    internal static string ERR_UnclosedExpressionHole { get; }
    internal static string ERR_UnescapedCurly { get; }
    internal static string ERR_UnexpectedAliasedName { get; }
    internal static string ERR_UnexpectedBoundGenericName { get; }
    internal static string ERR_UnexpectedCharacter { get; }
    internal static string ERR_UnexpectedDirective { get; }
    internal static string ERR_UnexpectedGenericName { get; }
    internal static string ERR_UnexpectedSemicolon { get; }
    internal static string ERR_UnexpectedToken { get; }
    internal static string ERR_UnexpectedUnboundGenericName { get; }
    internal static string ERR_UnexpectedVariance { get; }
    internal static string ERR_UnifyingInterfaceInstantiations { get; }
    internal static string ERR_UnimplementedAbstractMethod { get; }
    internal static string ERR_UnimplementedInterfaceAccessor { get; }
    internal static string ERR_UnimplementedInterfaceMember { get; }
    internal static string ERR_UnreachableCatch { get; }
    internal static string ERR_UnsafeAsyncArgType { get; }
    internal static string ERR_UnsafeIteratorArgType { get; }
    internal static string ERR_UnsafeNeeded { get; }
    internal static string ERR_UnsafeTypeInObjectCreation { get; }
    internal static string ERR_UnsupportedTransparentIdentifierAccess { get; }
    internal static string ERR_UnterminatedStringLit { get; }
    internal static string ERR_UseDefViolation { get; }
    internal static string ERR_UseDefViolationField { get; }
    internal static string ERR_UseDefViolationOut { get; }
    internal static string ERR_UseDefViolationProperty { get; }
    internal static string ERR_UseDefViolationThis { get; }
    internal static string ERR_UsingAfterElements { get; }
    internal static string ERR_ValConstraintNotSatisfied { get; }
    internal static string ERR_ValueCantBeNull { get; }
    internal static string ERR_ValueExpected { get; }
    internal static string ERR_ValueTypeExtDelegate { get; }
    internal static string ERR_ValueTypePropertyInObjectInitializer { get; }
    internal static string ERR_VarargsAsync { get; }
    internal static string ERR_VarArgsInExpressionTree { get; }
    internal static string ERR_VarargsIterator { get; }
    internal static string ERR_VarargsLast { get; }
    internal static string ERR_VarDeclIsStaticClass { get; }
    internal static string ERR_VariableUsedBeforeDeclaration { get; }
    internal static string ERR_VariableUsedBeforeDeclarationAndHidesField { get; }
    internal static string ERR_VirtualPrivate { get; }
    internal static string ERR_VoidError { get; }
    internal static string ERR_VolatileAndReadonly { get; }
    internal static string ERR_VolatileStruct { get; }
    internal static string ERR_WinRtEventPassedByRef { get; }
    internal static string ERR_YieldInAnonMeth { get; }
    internal static string ERR_YieldNotAllowedInScript { get; }
    internal static string FTL_BadChecksumAlgorithm { get; }
    internal static string FTL_BadCodepage { get; }
    internal static string FTL_DebugEmitFailure { get; }
    internal static string FTL_InputFileNameTooLong { get; }
    internal static string FTL_InvalidTarget { get; }
    internal static string FTL_MetadataCantOpenFile { get; }
    internal static string FTL_OutputFileExists { get; }
    internal static string GenericParameterDefinition { get; }
    internal static string HDN_UnusedExternAlias { get; }
    internal static string HDN_UnusedExternAlias_Title { get; }
    internal static string HDN_UnusedUsingDirective { get; }
    internal static string HDN_UnusedUsingDirective_Title { get; }
    internal static string IDS_AnonMethod { get; }
    internal static string IDS_AwaitInCatchAndFinally { get; }
    internal static string IDS_Collection { get; }
    internal static string IDS_Contravariant { get; }
    internal static string IDS_Contravariantly { get; }
    internal static string IDS_Covariant { get; }
    internal static string IDS_Covariantly { get; }
    internal static string IDS_CSCHelp { get; }
    internal static string IDS_DirectoryDoesNotExist { get; }
    internal static string IDS_DirectoryHasInvalidPath { get; }
    internal static string IDS_FeatureAnonDelegates { get; }
    internal static string IDS_FeatureAnonymousTypes { get; }
    internal static string IDS_FeatureAsync { get; }
    internal static string IDS_FeatureAutoImplementedProperties { get; }
    internal static string IDS_FeatureAutoPropertyInitializer { get; }
    internal static string IDS_FeatureCollectionInitializer { get; }
    internal static string IDS_FeatureDeclarationExpression { get; }
    internal static string IDS_FeatureDefault { get; }
    internal static string IDS_FeatureDictionaryInitializer { get; }
    internal static string IDS_FeatureDynamic { get; }
    internal static string IDS_FeatureExceptionFilter { get; }
    internal static string IDS_FeatureExpressionBodiedIndexer { get; }
    internal static string IDS_FeatureExpressionBodiedMethod { get; }
    internal static string IDS_FeatureExpressionBodiedProperty { get; }
    internal static string IDS_FeatureExtensionMethod { get; }
    internal static string IDS_FeatureExternAlias { get; }
    internal static string IDS_FeatureFixedBuffer { get; }
    internal static string IDS_FeatureGenerics { get; }
    internal static string IDS_FeatureGlobalNamespace { get; }
    internal static string IDS_FeatureImplicitArray { get; }
    internal static string IDS_FeatureImplicitLocal { get; }
    internal static string IDS_FeatureInterpolatedStrings { get; }
    internal static string IDS_FeatureIterators { get; }
    internal static string IDS_FeatureLambda { get; }
    internal static string IDS_FeatureModuleAttrLoc { get; }
    internal static string IDS_FeatureNamedArgument { get; }
    internal static string IDS_FeatureNameof { get; }
    internal static string IDS_FeatureNullable { get; }
    internal static string IDS_FeatureNullPropagatingOperator { get; }
    internal static string IDS_FeatureObjectInitializer { get; }
    internal static string IDS_FeatureOptionalParameter { get; }
    internal static string IDS_FeaturePartialMethod { get; }
    internal static string IDS_FeaturePartialTypes { get; }
    internal static string IDS_FeaturePragma { get; }
    internal static string IDS_FeaturePropertyAccessorMods { get; }
    internal static string IDS_FeatureQueryExpression { get; }
    internal static string IDS_FeatureReadonlyAutoImplementedProperties { get; }
    internal static string IDS_FeatureStaticClasses { get; }
    internal static string IDS_FeatureSwitchOnBool { get; }
    internal static string IDS_FeatureTypeVariance { get; }
    internal static string IDS_FeatureUsingStatic { get; }
    internal static string IDS_FIXEDLOCAL { get; }
    internal static string IDS_FOREACHLOCAL { get; }
    internal static string IDS_GlobalNamespace { get; }
    internal static string IDS_Invariantly { get; }
    internal static string IDS_Lambda { get; }
    internal static string IDS_LIB_ENV { get; }
    internal static string IDS_LIB_OPTION { get; }
    internal static string IDS_LogoLine1 { get; }
    internal static string IDS_LogoLine2 { get; }
    internal static string IDS_MethodGroup { get; }
    internal static string IDS_Namespace1 { get; }
    internal static string IDS_NULL { get; }
    internal static string IDS_OperationCausedStackOverflow { get; }
    internal static string IDS_PathList { get; }
    internal static string IDS_REFERENCEPATH_OPTION { get; }
    internal static string IDS_RELATEDERROR { get; }
    internal static string IDS_RELATEDWARNING { get; }
    internal static string IDS_SK_ALIAS { get; }
    internal static string IDS_SK_EVENT { get; }
    internal static string IDS_SK_EXTERNALIAS { get; }
    internal static string IDS_SK_FIELD { get; }
    internal static string IDS_SK_LABEL { get; }
    internal static string IDS_SK_METHOD { get; }
    internal static string IDS_SK_NAMESPACE { get; }
    internal static string IDS_SK_PROPERTY { get; }
    internal static string IDS_SK_TYPE { get; }
    internal static string IDS_SK_TYVAR { get; }
    internal static string IDS_SK_UNKNOWN { get; }
    internal static string IDS_SK_VARIABLE { get; }
    internal static string IDS_Text { get; }
    internal static string IDS_ToolName { get; }
    internal static string IDS_USINGLOCAL { get; }
    internal static string IDS_VersionExperimental { get; }
    internal static string IDS_XMLBADINCLUDE { get; }
    internal static string IDS_XMLFAILEDINCLUDE { get; }
    internal static string IDS_XMLIGNORED { get; }
    internal static string IDS_XMLIGNORED2 { get; }
    internal static string IDS_XMLMISSINGINCLUDEFILE { get; }
    internal static string IDS_XMLMISSINGINCLUDEPATH { get; }
    internal static string IDS_XMLNOINCLUDE { get; }
    internal static string INF_UnableToLoadSomeTypesInAnalyzer { get; }
    internal static string INF_UnableToLoadSomeTypesInAnalyzer_Title { get; }
    internal static string InvalidGetDeclarationNameMultipleDeclarators { get; }
    internal static string ItemsMustBeNonEmpty { get; }
    internal static string LocationMustBeProvided { get; }
    internal static string LookupOptionsHasInvalidCombo { get; }
    internal static string MustCallSetMethodTestData { get; }
    internal static string NameConflictForName { get; }
    internal static string NoNoneSearchCriteria { get; }
    internal static string NotACSharpSymbol { get; }
    internal static string PositionIsNotWithinSyntax { get; }
    internal static string PositionNotWithinTree { get; }
    internal static string SeparatorIsExpected { get; }
    internal static string SpeculatedSyntaxNodeCannotBelongToCurrentCompilation { get; }
    internal static string SubmissionCanHaveAtMostOne { get; }
    internal static string SubmissionCanOnlyInclude { get; }
    internal static string SyntaxNodeIsNotWithinSynt { get; }
    internal static string SyntaxTreeAlreadyPresent { get; }
    internal static string SyntaxTreeFromLoadNoRemoveReplace { get; }
    internal static string SyntaxTreeIsNotASubmission { get; }
    internal static string SyntaxTreeNotFoundTo { get; }
    internal static string SyntaxTreeSemanticModelMust { get; }
    internal static string TheStreamCannotBeReadFrom { get; }
    internal static string TheStreamCannotBeWritten { get; }
    internal static string ThisMethodCanOnlyBeUsedToCreateTokens { get; }
    internal static string TreeMustHaveARootNodeWith { get; }
    internal static string TreeNotPartOfCompilation { get; }
    internal static string TypeArgumentCannotBeNull { get; }
    internal static string UseLiteralForNumeric { get; }
    internal static string UseLiteralForTokens { get; }
    internal static string UseVerbatimIdentifier { get; }
    internal static string WRN_AlignmentMagnitude { get; }
    internal static string WRN_AlignmentMagnitude_Title { get; }
    internal static string WRN_AlwaysNull { get; }
    internal static string WRN_AlwaysNull_Title { get; }
    internal static string WRN_AmbiguousXMLReference { get; }
    internal static string WRN_AmbiguousXMLReference_Title { get; }
    internal static string WRN_AnalyzerCannotBeCreated { get; }
    internal static string WRN_AnalyzerCannotBeCreated_Title { get; }
    internal static string WRN_AssemblyAttributeFromModuleIsOverridden { get; }
    internal static string WRN_AssemblyAttributeFromModuleIsOverridden_Title { get; }
    internal static string WRN_AssignmentToLockOrDispose { get; }
    internal static string WRN_AssignmentToLockOrDispose_Title { get; }
    internal static string WRN_AssignmentToSelf { get; }
    internal static string WRN_AssignmentToSelf_Title { get; }
    internal static string WRN_AsyncLacksAwaits { get; }
    internal static string WRN_AsyncLacksAwaits_Title { get; }
    internal static string WRN_AttributeIgnoredWhenPublicSigning { get; }
    internal static string WRN_AttributeIgnoredWhenPublicSigning_Title { get; }
    internal static string WRN_AttributeLocationOnBadDeclaration { get; }
    internal static string WRN_AttributeLocationOnBadDeclaration_Title { get; }
    internal static string WRN_BadRefCompareLeft { get; }
    internal static string WRN_BadRefCompareLeft_Title { get; }
    internal static string WRN_BadRefCompareRight { get; }
    internal static string WRN_BadRefCompareRight_Title { get; }
    internal static string WRN_BadRestoreNumber { get; }
    internal static string WRN_BadRestoreNumber_Title { get; }
    internal static string WRN_BadUILang { get; }
    internal static string WRN_BadUILang_Title { get; }
    internal static string WRN_BadWarningNumber { get; }
    internal static string WRN_BadWarningNumber_Description { get; }
    internal static string WRN_BadWarningNumber_Title { get; }
    internal static string WRN_BadXMLRef { get; }
    internal static string WRN_BadXMLRef_Title { get; }
    internal static string WRN_BadXMLRefParamType { get; }
    internal static string WRN_BadXMLRefParamType_Title { get; }
    internal static string WRN_BadXMLRefReturnType { get; }
    internal static string WRN_BadXMLRefReturnType_Title { get; }
    internal static string WRN_BadXMLRefSyntax { get; }
    internal static string WRN_BadXMLRefSyntax_Title { get; }
    internal static string WRN_BadXMLRefTypeVar { get; }
    internal static string WRN_BadXMLRefTypeVar_Title { get; }
    internal static string WRN_BitwiseOrSignExtend { get; }
    internal static string WRN_BitwiseOrSignExtend_Description { get; }
    internal static string WRN_BitwiseOrSignExtend_Title { get; }
    internal static string WRN_ByRefNonAgileField { get; }
    internal static string WRN_ByRefNonAgileField_Title { get; }
    internal static string WRN_CA2000_DisposeObjectsBeforeLosingScope1 { get; }
    internal static string WRN_CA2000_DisposeObjectsBeforeLosingScope1_Title { get; }
    internal static string WRN_CA2000_DisposeObjectsBeforeLosingScope2 { get; }
    internal static string WRN_CA2000_DisposeObjectsBeforeLosingScope2_Title { get; }
    internal static string WRN_CA2202_DoNotDisposeObjectsMultipleTimes { get; }
    internal static string WRN_CA2202_DoNotDisposeObjectsMultipleTimes_Title { get; }
    internal static string WRN_CallerFilePathParamForUnconsumedLocation { get; }
    internal static string WRN_CallerFilePathParamForUnconsumedLocation_Title { get; }
    internal static string WRN_CallerFilePathPreferredOverCallerMemberName { get; }
    internal static string WRN_CallerFilePathPreferredOverCallerMemberName_Title { get; }
    internal static string WRN_CallerLineNumberParamForUnconsumedLocation { get; }
    internal static string WRN_CallerLineNumberParamForUnconsumedLocation_Title { get; }
    internal static string WRN_CallerLineNumberPreferredOverCallerFilePath { get; }
    internal static string WRN_CallerLineNumberPreferredOverCallerFilePath_Title { get; }
    internal static string WRN_CallerLineNumberPreferredOverCallerMemberName { get; }
    internal static string WRN_CallerLineNumberPreferredOverCallerMemberName_Title { get; }
    internal static string WRN_CallerMemberNameParamForUnconsumedLocation { get; }
    internal static string WRN_CallerMemberNameParamForUnconsumedLocation_Title { get; }
    internal static string WRN_CallOnNonAgileField { get; }
    internal static string WRN_CallOnNonAgileField_Description { get; }
    internal static string WRN_CallOnNonAgileField_Title { get; }
    internal static string WRN_CantHaveManifestForModule { get; }
    internal static string WRN_CantHaveManifestForModule_Title { get; }
    internal static string WRN_CLS_ArrayArgumentToAttribute { get; }
    internal static string WRN_CLS_ArrayArgumentToAttribute_Title { get; }
    internal static string WRN_CLS_AssemblyNotCLS { get; }
    internal static string WRN_CLS_AssemblyNotCLS_Title { get; }
    internal static string WRN_CLS_AssemblyNotCLS2 { get; }
    internal static string WRN_CLS_AssemblyNotCLS2_Title { get; }
    internal static string WRN_CLS_BadArgType { get; }
    internal static string WRN_CLS_BadArgType_Title { get; }
    internal static string WRN_CLS_BadAttributeType { get; }
    internal static string WRN_CLS_BadAttributeType_Title { get; }
    internal static string WRN_CLS_BadBase { get; }
    internal static string WRN_CLS_BadBase_Description { get; }
    internal static string WRN_CLS_BadBase_Title { get; }
    internal static string WRN_CLS_BadFieldPropType { get; }
    internal static string WRN_CLS_BadFieldPropType_Description { get; }
    internal static string WRN_CLS_BadFieldPropType_Title { get; }
    internal static string WRN_CLS_BadIdentifier { get; }
    internal static string WRN_CLS_BadIdentifier_Title { get; }
    internal static string WRN_CLS_BadIdentifierCase { get; }
    internal static string WRN_CLS_BadIdentifierCase_Title { get; }
    internal static string WRN_CLS_BadInterface { get; }
    internal static string WRN_CLS_BadInterface_Title { get; }
    internal static string WRN_CLS_BadInterfaceMember { get; }
    internal static string WRN_CLS_BadInterfaceMember_Title { get; }
    internal static string WRN_CLS_BadReturnType { get; }
    internal static string WRN_CLS_BadReturnType_Title { get; }
    internal static string WRN_CLS_BadTypeVar { get; }
    internal static string WRN_CLS_BadTypeVar_Title { get; }
    internal static string WRN_CLS_IllegalTrueInFalse { get; }
    internal static string WRN_CLS_IllegalTrueInFalse_Title { get; }
    internal static string WRN_CLS_MeaninglessOnParam { get; }
    internal static string WRN_CLS_MeaninglessOnParam_Title { get; }
    internal static string WRN_CLS_MeaninglessOnPrivateType { get; }
    internal static string WRN_CLS_MeaninglessOnPrivateType_Title { get; }
    internal static string WRN_CLS_MeaninglessOnReturn { get; }
    internal static string WRN_CLS_MeaninglessOnReturn_Title { get; }
    internal static string WRN_CLS_ModuleMissingCLS { get; }
    internal static string WRN_CLS_ModuleMissingCLS_Title { get; }
    internal static string WRN_CLS_NoAbstractMembers { get; }
    internal static string WRN_CLS_NoAbstractMembers_Title { get; }
    internal static string WRN_CLS_NotOnModules { get; }
    internal static string WRN_CLS_NotOnModules_Title { get; }
    internal static string WRN_CLS_NotOnModules2 { get; }
    internal static string WRN_CLS_NotOnModules2_Title { get; }
    internal static string WRN_CLS_NoVarArgs { get; }
    internal static string WRN_CLS_NoVarArgs_Title { get; }
    internal static string WRN_CLS_OverloadRefOut { get; }
    internal static string WRN_CLS_OverloadRefOut_Title { get; }
    internal static string WRN_CLS_OverloadUnnamed { get; }
    internal static string WRN_CLS_OverloadUnnamed_Description { get; }
    internal static string WRN_CLS_OverloadUnnamed_Title { get; }
    internal static string WRN_CLS_VolatileField { get; }
    internal static string WRN_CLS_VolatileField_Title { get; }
    internal static string WRN_CmdOptionConflictsSource { get; }
    internal static string WRN_CmdOptionConflictsSource_Description { get; }
    internal static string WRN_CmdOptionConflictsSource_Title { get; }
    internal static string WRN_CmpAlwaysFalse { get; }
    internal static string WRN_CmpAlwaysFalse_Title { get; }
    internal static string WRN_CoClassWithoutComImport { get; }
    internal static string WRN_CoClassWithoutComImport_Title { get; }
    internal static string WRN_ComparisonToSelf { get; }
    internal static string WRN_ComparisonToSelf_Title { get; }
    internal static string WRN_ConflictingChecksum { get; }
    internal static string WRN_ConflictingChecksum_Title { get; }
    internal static string WRN_ConflictingMachineAssembly { get; }
    internal static string WRN_ConflictingMachineAssembly_Title { get; }
    internal static string WRN_DebugFullNameTooLong { get; }
    internal static string WRN_DebugFullNameTooLong_Title { get; }
    internal static string WRN_DefaultValueForUnconsumedLocation { get; }
    internal static string WRN_DefaultValueForUnconsumedLocation_Title { get; }
    internal static string WRN_DefineIdentifierRequired { get; }
    internal static string WRN_DefineIdentifierRequired_Title { get; }
    internal static string WRN_DelaySignButNoKey { get; }
    internal static string WRN_DelaySignButNoKey_Title { get; }
    internal static string WRN_DeprecatedCollectionInitAdd { get; }
    internal static string WRN_DeprecatedCollectionInitAdd_Title { get; }
    internal static string WRN_DeprecatedCollectionInitAddStr { get; }
    internal static string WRN_DeprecatedCollectionInitAddStr_Title { get; }
    internal static string WRN_DeprecatedSymbol { get; }
    internal static string WRN_DeprecatedSymbol_Title { get; }
    internal static string WRN_DeprecatedSymbolStr { get; }
    internal static string WRN_DeprecatedSymbolStr_Title { get; }
    internal static string WRN_DotOnDefault { get; }
    internal static string WRN_DotOnDefault_Title { get; }
    internal static string WRN_DuplicateParamTag { get; }
    internal static string WRN_DuplicateParamTag_Title { get; }
    internal static string WRN_DuplicateTypeParamTag { get; }
    internal static string WRN_DuplicateTypeParamTag_Title { get; }
    internal static string WRN_DuplicateUsing { get; }
    internal static string WRN_DuplicateUsing_Title { get; }
    internal static string WRN_DynamicDispatchToConditionalMethod { get; }
    internal static string WRN_DynamicDispatchToConditionalMethod_Title { get; }
    internal static string WRN_EmptySwitch { get; }
    internal static string WRN_EmptySwitch_Title { get; }
    internal static string WRN_EndOfPPLineExpected { get; }
    internal static string WRN_EndOfPPLineExpected_Title { get; }
    internal static string WRN_EqualityOpWithoutEquals { get; }
    internal static string WRN_EqualityOpWithoutEquals_Title { get; }
    internal static string WRN_EqualityOpWithoutGetHashCode { get; }
    internal static string WRN_EqualityOpWithoutGetHashCode_Title { get; }
    internal static string WRN_EqualsWithoutGetHashCode { get; }
    internal static string WRN_EqualsWithoutGetHashCode_Title { get; }
    internal static string WRN_ErrorOverride { get; }
    internal static string WRN_ErrorOverride_Description { get; }
    internal static string WRN_ErrorOverride_Title { get; }
    internal static string WRN_ExplicitImplCollision { get; }
    internal static string WRN_ExplicitImplCollision_Title { get; }
    internal static string WRN_ExternCtorNoImplementation { get; }
    internal static string WRN_ExternCtorNoImplementation_Title { get; }
    internal static string WRN_ExternMethodNoImplementation { get; }
    internal static string WRN_ExternMethodNoImplementation_Title { get; }
    internal static string WRN_FailedInclude { get; }
    internal static string WRN_FailedInclude_Title { get; }
    internal static string WRN_FileAlreadyIncluded { get; }
    internal static string WRN_FileAlreadyIncluded_Title { get; }
    internal static string WRN_FileNameTooLong { get; }
    internal static string WRN_FileNameTooLong_Title { get; }
    internal static string WRN_FilterIsConstant { get; }
    internal static string WRN_FilterIsConstant_Title { get; }
    internal static string WRN_FinalizeMethod { get; }
    internal static string WRN_FinalizeMethod_Description { get; }
    internal static string WRN_FinalizeMethod_Title { get; }
    internal static string WRN_GlobalAliasDefn { get; }
    internal static string WRN_GlobalAliasDefn_Title { get; }
    internal static string WRN_GotoCaseShouldConvert { get; }
    internal static string WRN_GotoCaseShouldConvert_Title { get; }
    internal static string WRN_IdentifierOrNumericLiteralExpected { get; }
    internal static string WRN_IdentifierOrNumericLiteralExpected_Title { get; }
    internal static string WRN_IllegalPPChecksum { get; }
    internal static string WRN_IllegalPPChecksum_Title { get; }
    internal static string WRN_IllegalPPWarning { get; }
    internal static string WRN_IllegalPPWarning_Title { get; }
    internal static string WRN_IllegalPragma { get; }
    internal static string WRN_IllegalPragma_Title { get; }
    internal static string WRN_IncorrectBooleanAssg { get; }
    internal static string WRN_IncorrectBooleanAssg_Title { get; }
    internal static string WRN_InvalidAssemblyName { get; }
    internal static string WRN_InvalidAssemblyName_Description { get; }
    internal static string WRN_InvalidAssemblyName_Title { get; }
    internal static string WRN_InvalidAttributeLocation { get; }
    internal static string WRN_InvalidAttributeLocation_Title { get; }
    internal static string WRN_InvalidInclude { get; }
    internal static string WRN_InvalidInclude_Title { get; }
    internal static string WRN_InvalidMainSig { get; }
    internal static string WRN_InvalidMainSig_Title { get; }
    internal static string WRN_InvalidNumber { get; }
    internal static string WRN_InvalidNumber_Title { get; }
    internal static string WRN_InvalidSearchPathDir { get; }
    internal static string WRN_InvalidSearchPathDir_Title { get; }
    internal static string WRN_InvalidVersionFormat { get; }
    internal static string WRN_InvalidVersionFormat_Title { get; }
    internal static string WRN_IsAlwaysFalse { get; }
    internal static string WRN_IsAlwaysFalse_Title { get; }
    internal static string WRN_IsAlwaysTrue { get; }
    internal static string WRN_IsAlwaysTrue_Title { get; }
    internal static string WRN_IsDynamicIsConfusing { get; }
    internal static string WRN_IsDynamicIsConfusing_Title { get; }
    internal static string WRN_LowercaseEllSuffix { get; }
    internal static string WRN_LowercaseEllSuffix_Title { get; }
    internal static string WRN_MainCantBeGeneric { get; }
    internal static string WRN_MainCantBeGeneric_Title { get; }
    internal static string WRN_MainIgnored { get; }
    internal static string WRN_MainIgnored_Title { get; }
    internal static string WRN_MissingParamTag { get; }
    internal static string WRN_MissingParamTag_Title { get; }
    internal static string WRN_MissingTypeParamTag { get; }
    internal static string WRN_MissingTypeParamTag_Title { get; }
    internal static string WRN_MissingXMLComment { get; }
    internal static string WRN_MissingXMLComment_Description { get; }
    internal static string WRN_MissingXMLComment_Title { get; }
    internal static string WRN_MultiplePredefTypes { get; }
    internal static string WRN_MultiplePredefTypes_Description { get; }
    internal static string WRN_MultiplePredefTypes_Title { get; }
    internal static string WRN_MultipleRuntimeImplementationMatches { get; }
    internal static string WRN_MultipleRuntimeImplementationMatches_Description { get; }
    internal static string WRN_MultipleRuntimeImplementationMatches_Title { get; }
    internal static string WRN_MultipleRuntimeOverrideMatches { get; }
    internal static string WRN_MultipleRuntimeOverrideMatches_Title { get; }
    internal static string WRN_NegativeArrayIndex { get; }
    internal static string WRN_NegativeArrayIndex_Title { get; }
    internal static string WRN_NewNotRequired { get; }
    internal static string WRN_NewNotRequired_Title { get; }
    internal static string WRN_NewOrOverrideExpected { get; }
    internal static string WRN_NewOrOverrideExpected_Title { get; }
    internal static string WRN_NewRequired { get; }
    internal static string WRN_NewRequired_Description { get; }
    internal static string WRN_NewRequired_Title { get; }
    internal static string WRN_NoAnalyzerInAssembly { get; }
    internal static string WRN_NoAnalyzerInAssembly_Title { get; }
    internal static string WRN_NoConfigNotOnCommandLine { get; }
    internal static string WRN_NoConfigNotOnCommandLine_Title { get; }
    internal static string WRN_NonECMAFeature { get; }
    internal static string WRN_NonECMAFeature_Title { get; }
    internal static string WRN_NonObsoleteOverridingObsolete { get; }
    internal static string WRN_NonObsoleteOverridingObsolete_Title { get; }
    internal static string WRN_NoRuntimeMetadataVersion { get; }
    internal static string WRN_NoRuntimeMetadataVersion_Title { get; }
    internal static string WRN_NoSources { get; }
    internal static string WRN_NoSources_Title { get; }
    internal static string WRN_NubExprIsConstBool { get; }
    internal static string WRN_NubExprIsConstBool_Title { get; }
    internal static string WRN_NubExprIsConstBool2 { get; }
    internal static string WRN_NubExprIsConstBool2_Title { get; }
    internal static string WRN_ObsoleteOverridingNonObsolete { get; }
    internal static string WRN_ObsoleteOverridingNonObsolete_Title { get; }
    internal static string WRN_PatternBadSignature { get; }
    internal static string WRN_PatternBadSignature_Title { get; }
    internal static string WRN_PatternIsAmbiguous { get; }
    internal static string WRN_PatternIsAmbiguous_Title { get; }
    internal static string WRN_PatternStaticOrInaccessible { get; }
    internal static string WRN_PatternStaticOrInaccessible_Title { get; }
    internal static string WRN_PdbLocalNameTooLong { get; }
    internal static string WRN_PdbLocalNameTooLong_Title { get; }
    internal static string WRN_PossibleMistakenNullStatement { get; }
    internal static string WRN_PossibleMistakenNullStatement_Title { get; }
    internal static string WRN_ProtectedInSealed { get; }
    internal static string WRN_ProtectedInSealed_Title { get; }
    internal static string WRN_RefCultureMismatch { get; }
    internal static string WRN_RefCultureMismatch_Title { get; }
    internal static string WRN_ReferencedAssemblyDoesNotHaveStrongName { get; }
    internal static string WRN_ReferencedAssemblyDoesNotHaveStrongName_Title { get; }
    internal static string WRN_ReferencedAssemblyReferencesLinkedPIA { get; }
    internal static string WRN_ReferencedAssemblyReferencesLinkedPIA_Description { get; }
    internal static string WRN_ReferencedAssemblyReferencesLinkedPIA_Title { get; }
    internal static string WRN_SameFullNameThisAggAgg { get; }
    internal static string WRN_SameFullNameThisAggAgg_Title { get; }
    internal static string WRN_SameFullNameThisAggNs { get; }
    internal static string WRN_SameFullNameThisAggNs_Title { get; }
    internal static string WRN_SameFullNameThisNsAgg { get; }
    internal static string WRN_SameFullNameThisNsAgg_Title { get; }
    internal static string WRN_SequentialOnPartialClass { get; }
    internal static string WRN_SequentialOnPartialClass_Title { get; }
    internal static string WRN_TooManyLinesForDebugger { get; }
    internal static string WRN_TooManyLinesForDebugger_Title { get; }
    internal static string WRN_TypeParameterSameAsOuterTypeParameter { get; }
    internal static string WRN_TypeParameterSameAsOuterTypeParameter_Title { get; }
    internal static string WRN_UnableToLoadAnalyzer { get; }
    internal static string WRN_UnableToLoadAnalyzer_Title { get; }
    internal static string WRN_UnassignedInternalField { get; }
    internal static string WRN_UnassignedInternalField_Title { get; }
    internal static string WRN_UnifyReferenceBldRev { get; }
    internal static string WRN_UnifyReferenceBldRev_Description { get; }
    internal static string WRN_UnifyReferenceBldRev_Title { get; }
    internal static string WRN_UnifyReferenceMajMin { get; }
    internal static string WRN_UnifyReferenceMajMin_Description { get; }
    internal static string WRN_UnifyReferenceMajMin_Title { get; }
    internal static string WRN_UnimplementedCommandLineSwitch { get; }
    internal static string WRN_UnimplementedCommandLineSwitch_Title { get; }
    internal static string WRN_UnmatchedParamRefTag { get; }
    internal static string WRN_UnmatchedParamRefTag_Title { get; }
    internal static string WRN_UnmatchedParamTag { get; }
    internal static string WRN_UnmatchedParamTag_Title { get; }
    internal static string WRN_UnmatchedTypeParamRefTag { get; }
    internal static string WRN_UnmatchedTypeParamRefTag_Title { get; }
    internal static string WRN_UnmatchedTypeParamTag { get; }
    internal static string WRN_UnmatchedTypeParamTag_Title { get; }
    internal static string WRN_UnobservedAwaitableExpression { get; }
    internal static string WRN_UnobservedAwaitableExpression_Description { get; }
    internal static string WRN_UnobservedAwaitableExpression_Title { get; }
    internal static string WRN_UnprocessedXMLComment { get; }
    internal static string WRN_UnprocessedXMLComment_Title { get; }
    internal static string WRN_UnqualifiedNestedTypeInCref { get; }
    internal static string WRN_UnqualifiedNestedTypeInCref_Title { get; }
    internal static string WRN_UnreachableCode { get; }
    internal static string WRN_UnreachableCode_Title { get; }
    internal static string WRN_UnreachableGeneralCatch { get; }
    internal static string WRN_UnreachableGeneralCatch_Description { get; }
    internal static string WRN_UnreachableGeneralCatch_Title { get; }
    internal static string WRN_UnreferencedEvent { get; }
    internal static string WRN_UnreferencedEvent_Title { get; }
    internal static string WRN_UnreferencedField { get; }
    internal static string WRN_UnreferencedField_Title { get; }
    internal static string WRN_UnreferencedFieldAssg { get; }
    internal static string WRN_UnreferencedFieldAssg_Title { get; }
    internal static string WRN_UnreferencedLabel { get; }
    internal static string WRN_UnreferencedLabel_Title { get; }
    internal static string WRN_UnreferencedVar { get; }
    internal static string WRN_UnreferencedVar_Title { get; }
    internal static string WRN_UnreferencedVarAssg { get; }
    internal static string WRN_UnreferencedVarAssg_Title { get; }
    internal static string WRN_VacuousIntegralComp { get; }
    internal static string WRN_VacuousIntegralComp_Title { get; }
    internal static string WRN_VolatileByRef { get; }
    internal static string WRN_VolatileByRef_Description { get; }
    internal static string WRN_VolatileByRef_Title { get; }
    internal static string WRN_WarningDirective { get; }
    internal static string WRN_WarningDirective_Title { get; }
    internal static string WRN_XMLParseError { get; }
    internal static string WRN_XMLParseError_Title { get; }
    internal static string WRN_XMLParseIncludeError { get; }
    internal static string WRN_XMLParseIncludeError_Title { get; }
    internal static string WrongNumberOfTypeArguments { get; }
    internal static string WrongSemanticModelType { get; }
    internal static string XML_CDataEndTagNotAllowed { get; }
    internal static string XML_DuplicateAttribute { get; }
    internal static string XML_ElementTypeMatch { get; }
    internal static string XML_EndTagExpected { get; }
    internal static string XML_EndTagNotExpected { get; }
    internal static string XML_ExpectedEndOfTag { get; }
    internal static string XML_ExpectedEndOfXml { get; }
    internal static string XML_ExpectedIdentifier { get; }
    internal static string XML_IncorrectComment { get; }
    internal static string XML_InvalidCharEntity { get; }
    internal static string XML_InvalidToken { get; }
    internal static string XML_InvalidUnicodeChar { get; }
    internal static string XML_InvalidWhitespace { get; }
    internal static string XML_LessThanInAttributeValue { get; }
    internal static string XML_MissingEqualsAttribute { get; }
    internal static string XML_RefUndefinedEntity_1 { get; }
    internal static string XML_StringLiteralNoEndQuote { get; }
    internal static string XML_StringLiteralNonAsciiQuote { get; }
    internal static string XML_StringLiteralNoStartQuote { get; }
    internal static string XML_WhitespaceMissing { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CantReferenceCompilationOf();
    internal static string get_ChainingSpeculativeModelIsNotSupported();
    internal static string get_CompilationC();
    internal static string get_CouldNotFindFile();
    internal static string get_ElementIsExpected();
    internal static string get_ElementsCannotBeNull();
    internal static string get_ERR_AbstractAndExtern();
    internal static string get_ERR_AbstractAndSealed();
    internal static string get_ERR_AbstractAttributeClass();
    internal static string get_ERR_AbstractBaseCall();
    internal static string get_ERR_AbstractEventInitializer();
    internal static string get_ERR_AbstractField();
    internal static string get_ERR_AbstractHasBody();
    internal static string get_ERR_AbstractInConcreteClass();
    internal static string get_ERR_AbstractNotVirtual();
    internal static string get_ERR_AbstractSealedStatic();
    internal static string get_ERR_AccessModMissingAccessor();
    internal static string get_ERR_AccessorImplementingMethod();
    internal static string get_ERR_AccessorListAndExpressionBody();
    internal static string get_ERR_AddModuleAssembly();
    internal static string get_ERR_AddOrRemoveExpected();
    internal static string get_ERR_AddRemoveMustHaveBody();
    internal static string get_ERR_AddrOnReadOnlyLocal();
    internal static string get_ERR_AgnosticToMachineModule();
    internal static string get_ERR_AliasMissingFile();
    internal static string get_ERR_AliasNotFound();
    internal static string get_ERR_AliasQualAsExpression();
    internal static string get_ERR_AliasQualifiedNameNotAnExpression();
    internal static string get_ERR_AmbigBinaryOps();
    internal static string get_ERR_AmbigCall();
    internal static string get_ERR_AmbigContext();
    internal static string get_ERR_AmbigMember();
    internal static string get_ERR_AmbigOverride();
    internal static string get_ERR_AmbigQM();
    internal static string get_ERR_AmbigUDConv();
    internal static string get_ERR_AmbigUnaryOp();
    internal static string get_ERR_AmbiguousAttribute();
    internal static string get_ERR_AnonDelegateCantUse();
    internal static string get_ERR_AnonMethGrpInForEach();
    internal static string get_ERR_AnonMethToNonDel();
    internal static string get_ERR_AnonymousMethodToExpressionTree();
    internal static string get_ERR_AnonymousReturnExpected();
    internal static string get_ERR_AnonymousTypeDuplicatePropertyName();
    internal static string get_ERR_AnonymousTypeNotAvailable();
    internal static string get_ERR_AnonymousTypePropertyAssignedBadValue();
    internal static string get_ERR_ArgsInvalid();
    internal static string get_ERR_ArrayElementCantBeRefAny();
    internal static string get_ERR_ArrayInitializerExpected();
    internal static string get_ERR_ArrayInitializerIncorrectLength();
    internal static string get_ERR_ArrayInitInBadPlace();
    internal static string get_ERR_ArrayInitToNonArrayType();
    internal static string get_ERR_ArrayOfStaticClass();
    internal static string get_ERR_ArraySizeInDeclaration();
    internal static string get_ERR_AsMustHaveReferenceType();
    internal static string get_ERR_AssemblyMatchBadVersion();
    internal static string get_ERR_AssemblyNameOnNonModule();
    internal static string get_ERR_AssemblySpecifiedForLinkAndRef();
    internal static string get_ERR_AssgLvalueExpected();
    internal static string get_ERR_AssgReadonly();
    internal static string get_ERR_AssgReadonly2();
    internal static string get_ERR_AssgReadonlyLocal();
    internal static string get_ERR_AssgReadonlyLocal2Cause();
    internal static string get_ERR_AssgReadonlyLocalCause();
    internal static string get_ERR_AssgReadonlyProp();
    internal static string get_ERR_AssgReadonlyStatic();
    internal static string get_ERR_AssgReadonlyStatic2();
    internal static string get_ERR_AsWithTypeVar();
    internal static string get_ERR_AttrArgWithTypeVars();
    internal static string get_ERR_AttributeCantBeGeneric();
    internal static string get_ERR_AttributeNotOnAccessor();
    internal static string get_ERR_AttributeOnBadSymbolType();
    internal static string get_ERR_AttributeParameterRequired1();
    internal static string get_ERR_AttributeParameterRequired2();
    internal static string get_ERR_AttributesNotAllowed();
    internal static string get_ERR_AttributeUsageOnNonAttributeClass();
    internal static string get_ERR_AutoPropertyInitializerInInterface();
    internal static string get_ERR_AutoPropertyMustHaveGetAccessor();
    internal static string get_ERR_AutoPropertyMustOverrideSet();
    internal static string get_ERR_AwaitInUnsafeContext();
    internal static string get_ERR_BadAccess();
    internal static string get_ERR_BadAppConfigPath();
    internal static string get_ERR_BadArgCount();
    internal static string get_ERR_BadArgExtraRef();
    internal static string get_ERR_BadArgRef();
    internal static string get_ERR_BadArgType();
    internal static string get_ERR_BadArgTypeDynamicExtension();
    internal static string get_ERR_BadArgTypesForCollectionAdd();
    internal static string get_ERR_BadArgumentToAttribute();
    internal static string get_ERR_BadArity();
    internal static string get_ERR_BadArraySyntax();
    internal static string get_ERR_BadAsyncArgType();
    internal static string get_ERR_BadAsyncExpressionTree();
    internal static string get_ERR_BadAsyncLacksBody();
    internal static string get_ERR_BadAsyncReturn();
    internal static string get_ERR_BadAsyncReturnExpression();
    internal static string get_ERR_BadAttributeArgument();
    internal static string get_ERR_BadAttributeParamDefaultArgument();
    internal static string get_ERR_BadAttributeParamType();
    internal static string get_ERR_BadAwaitArg();
    internal static string get_ERR_BadAwaitArg_NeedSystem();
    internal static string get_ERR_BadAwaitArgIntrinsic();
    internal static string get_ERR_BadAwaitArgVoidCall();
    internal static string get_ERR_BadAwaitAsIdentifier();
    internal static string get_ERR_BadAwaiterPattern();
    internal static string get_ERR_BadAwaitInCatch();
    internal static string get_ERR_BadAwaitInCatchFilter();
    internal static string get_ERR_BadAwaitInFinally();
    internal static string get_ERR_BadAwaitInLock();
    internal static string get_ERR_BadAwaitInQuery();
    internal static string get_ERR_BadAwaitInStaticVariableInitializer();
    internal static string get_ERR_BadAwaitWithoutAsync();
    internal static string get_ERR_BadAwaitWithoutAsyncLambda();
    internal static string get_ERR_BadAwaitWithoutAsyncMethod();
    internal static string get_ERR_BadAwaitWithoutVoidAsyncMethod();
    internal static string get_ERR_BadBaseNumber();
    internal static string get_ERR_BadBaseType();
    internal static string get_ERR_BadBinaryOperatorSignature();
    internal static string get_ERR_BadBinaryOps();
    internal static string get_ERR_BadBinOpArgs();
    internal static string get_ERR_BadBoolOp();
    internal static string get_ERR_BadBoundType();
    internal static string get_ERR_BadCallerFilePathParamWithoutDefaultValue();
    internal static string get_ERR_BadCallerLineNumberParamWithoutDefaultValue();
    internal static string get_ERR_BadCallerMemberNameParamWithoutDefaultValue();
    internal static string get_ERR_BadCastInFixed();
    internal static string get_ERR_BadCoClassSig();
    internal static string get_ERR_BadCompatMode();
    internal static string get_ERR_BadCompilationOption();
    internal static string get_ERR_BadCompilationOptionValue();
    internal static string get_ERR_BadConstraintType();
    internal static string get_ERR_BadConstType();
    internal static string get_ERR_BadCtorArgCount();
    internal static string get_ERR_BadDebugType();
    internal static string get_ERR_BadDelArgCount();
    internal static string get_ERR_BadDelegateConstructor();
    internal static string get_ERR_BadDelegateLeave();
    internal static string get_ERR_BadDestructorName();
    internal static string get_ERR_BadDirectivePlacement();
    internal static string get_ERR_BadDynamicConversion();
    internal static string get_ERR_BadDynamicMethodArg();
    internal static string get_ERR_BadDynamicMethodArgLambda();
    internal static string get_ERR_BadDynamicMethodArgMemgrp();
    internal static string get_ERR_BadDynamicQuery();
    internal static string get_ERR_BadDynamicTypeof();
    internal static string get_ERR_BadEmbeddedStmt();
    internal static string get_ERR_BadEmptyThrow();
    internal static string get_ERR_BadEmptyThrowInFinally();
    internal static string get_ERR_BadEventUsage();
    internal static string get_ERR_BadEventUsageNoField();
    internal static string get_ERR_BadExceptionType();
    internal static string get_ERR_BadExtensionAgg();
    internal static string get_ERR_BadExtensionArgTypes();
    internal static string get_ERR_BadExtensionMeth();
    internal static string get_ERR_BadExternAlias();
    internal static string get_ERR_BadExternIdentifier();
    internal static string get_ERR_BadFinallyLeave();
    internal static string get_ERR_BadFixedInitType();
    internal static string get_ERR_BadForeachDecl();
    internal static string get_ERR_BadGetEnumerator();
    internal static string get_ERR_BadIncDecRetType();
    internal static string get_ERR_BadIncDecSignature();
    internal static string get_ERR_BadIndexCount();
    internal static string get_ERR_BadIndexerNameAttr();
    internal static string get_ERR_BadIndexLHS();
    internal static string get_ERR_BadInstanceArgType();
    internal static string get_ERR_BadIteratorArgType();
    internal static string get_ERR_BadIteratorReturn();
    internal static string get_ERR_BadMemberFlag();
    internal static string get_ERR_BadMemberProtection();
    internal static string get_ERR_BadModifierLocation();
    internal static string get_ERR_BadModifiersOnNamespace();
    internal static string get_ERR_BadNamedArgument();
    internal static string get_ERR_BadNamedArgumentForDelegateInvoke();
    internal static string get_ERR_BadNamedAttributeArgument();
    internal static string get_ERR_BadNamedAttributeArgumentType();
    internal static string get_ERR_BadNewExpr();
    internal static string get_ERR_BadOperatorSyntax();
    internal static string get_ERR_BadOutWithThis();
    internal static string get_ERR_BadParamExtraRef();
    internal static string get_ERR_BadParamModThis();
    internal static string get_ERR_BadParamRef();
    internal static string get_ERR_BadParamType();
    internal static string get_ERR_BadPdbData();
    internal static string get_ERR_BadPlatformType();
    internal static string get_ERR_BadPrefer32OnLib();
    internal static string get_ERR_BadProtectedAccess();
    internal static string get_ERR_BadRefWithThis();
    internal static string get_ERR_BadResourceVis();
    internal static string get_ERR_BadRetType();
    internal static string get_ERR_BadShiftOperatorSignature();
    internal static string get_ERR_BadSKknown();
    internal static string get_ERR_BadSKunknown();
    internal static string get_ERR_BadSpecialByRefLocal();
    internal static string get_ERR_BadStackAllocExpr();
    internal static string get_ERR_BadSwitch();
    internal static string get_ERR_BadThisParam();
    internal static string get_ERR_BadTypeArgument();
    internal static string get_ERR_BadTypeforThis();
    internal static string get_ERR_BadTypeReference();
    internal static string get_ERR_BadUnaryOp();
    internal static string get_ERR_BadUnaryOperatorSignature();
    internal static string get_ERR_BadUnOpArgs();
    internal static string get_ERR_BadUsingNamespace();
    internal static string get_ERR_BadUsingType();
    internal static string get_ERR_BadVarargs();
    internal static string get_ERR_BadVarDecl();
    internal static string get_ERR_BadVisBaseClass();
    internal static string get_ERR_BadVisBaseInterface();
    internal static string get_ERR_BadVisBound();
    internal static string get_ERR_BadVisDelegateParam();
    internal static string get_ERR_BadVisDelegateReturn();
    internal static string get_ERR_BadVisEventType();
    internal static string get_ERR_BadVisFieldType();
    internal static string get_ERR_BadVisIndexerParam();
    internal static string get_ERR_BadVisIndexerReturn();
    internal static string get_ERR_BadVisOpParam();
    internal static string get_ERR_BadVisOpReturn();
    internal static string get_ERR_BadVisParamType();
    internal static string get_ERR_BadVisPropertyType();
    internal static string get_ERR_BadVisReturnType();
    internal static string get_ERR_BadWarningLevel();
    internal static string get_ERR_BadWin32Res();
    internal static string get_ERR_BadYieldInCatch();
    internal static string get_ERR_BadYieldInFinally();
    internal static string get_ERR_BadYieldInTryOfCatch();
    internal static string get_ERR_BaseClassMustBeFirst();
    internal static string get_ERR_BaseConstraintConflict();
    internal static string get_ERR_BaseIllegal();
    internal static string get_ERR_BaseInBadContext();
    internal static string get_ERR_BaseInStaticMeth();
    internal static string get_ERR_BinaryFile();
    internal static string get_ERR_BindToBogus();
    internal static string get_ERR_BindToBogusProp1();
    internal static string get_ERR_BindToBogusProp2();
    internal static string get_ERR_BlockBodyAndExpressionBody();
    internal static string get_ERR_BogusExplicitImpl();
    internal static string get_ERR_BogusType();
    internal static string get_ERR_ByRefParameterInExpressionTree();
    internal static string get_ERR_ByRefReturnUnsupported();
    internal static string get_ERR_ByRefTypeAndAwait();
    internal static string get_ERR_CallingBaseFinalizeDeprecated();
    internal static string get_ERR_CallingFinalizeDeprecated();
    internal static string get_ERR_CannotPassNullForFriendAssembly();
    internal static string get_ERR_CantCallSpecialMethod();
    internal static string get_ERR_CantChangeAccessOnOverride();
    internal static string get_ERR_CantChangeReturnTypeOnOverride();
    internal static string get_ERR_CantChangeTypeOnOverride();
    internal static string get_ERR_CantConvAnonMethNoParams();
    internal static string get_ERR_CantConvAnonMethParams();
    internal static string get_ERR_CantConvAnonMethReturns();
    internal static string get_ERR_CantConvAsyncAnonFuncReturns();
    internal static string get_ERR_CantDeriveFromSealedType();
    internal static string get_ERR_CantHaveWin32ResAndIcon();
    internal static string get_ERR_CantHaveWin32ResAndManifest();
    internal static string get_ERR_CantInferMethTypeArgs();
    internal static string get_ERR_CantMakeTempFile();
    internal static string get_ERR_CantOpenFileWrite();
    internal static string get_ERR_CantOpenIcon();
    internal static string get_ERR_CantOpenWin32Manifest();
    internal static string get_ERR_CantOpenWin32Res();
    internal static string get_ERR_CantOverrideBogusMethod();
    internal static string get_ERR_CantOverrideNonEvent();
    internal static string get_ERR_CantOverrideNonFunction();
    internal static string get_ERR_CantOverrideNonProperty();
    internal static string get_ERR_CantOverrideNonVirtual();
    internal static string get_ERR_CantOverrideSealed();
    internal static string get_ERR_CantReadConfigFile();
    internal static string get_ERR_CantReadResource();
    internal static string get_ERR_CantReadRulesetFile();
    internal static string get_ERR_CantRefResource();
    internal static string get_ERR_CantReturnVoid();
    internal static string get_ERR_CantSetWin32Manifest();
    internal static string get_ERR_CantUseRequiredAttribute();
    internal static string get_ERR_CheckedOverflow();
    internal static string get_ERR_CircConstValue();
    internal static string get_ERR_CircularBase();
    internal static string get_ERR_CircularConstraint();
    internal static string get_ERR_ClassBoundNotFirst();
    internal static string get_ERR_ClassDoesntImplementInterface();
    internal static string get_ERR_ClassTypeExpected();
    internal static string get_ERR_CloseParenExpected();
    internal static string get_ERR_CloseUnimplementedInterfaceMemberNotPublic();
    internal static string get_ERR_CloseUnimplementedInterfaceMemberStatic();
    internal static string get_ERR_CloseUnimplementedInterfaceMemberWrongReturnType();
    internal static string get_ERR_CmdOptionConflictsSource();
    internal static string get_ERR_ColColWithTypeAlias();
    internal static string get_ERR_CollectionInitRequiresIEnumerable();
    internal static string get_ERR_ComImportWithBase();
    internal static string get_ERR_ComImportWithImpl();
    internal static string get_ERR_ComImportWithInitializers();
    internal static string get_ERR_ComImportWithoutUuidAttribute();
    internal static string get_ERR_ComImportWithUserCtor();
    internal static string get_ERR_CompileCancelled();
    internal static string get_ERR_ComRefCallInExpressionTree();
    internal static string get_ERR_ConcreteMissingBody();
    internal static string get_ERR_ConditionalMustReturnVoid();
    internal static string get_ERR_ConditionalOnInterfaceMethod();
    internal static string get_ERR_ConditionalOnNonAttributeClass();
    internal static string get_ERR_ConditionalOnOverride();
    internal static string get_ERR_ConditionalOnSpecialMethod();
    internal static string get_ERR_ConditionalWithOutParam();
    internal static string get_ERR_ConflictAliasAndMember();
    internal static string get_ERR_ConflictingAliasAndDefinition();
    internal static string get_ERR_ConflictingMachineModule();
    internal static string get_ERR_ConstantExpected();
    internal static string get_ERR_ConstantStringTooLong();
    internal static string get_ERR_ConstOutOfRange();
    internal static string get_ERR_ConstOutOfRangeChecked();
    internal static string get_ERR_ConstraintIsStaticClass();
    internal static string get_ERR_ConstraintOnlyAllowedOnGenericDecl();
    internal static string get_ERR_ConstructedDynamicTypeAsBound();
    internal static string get_ERR_ConstructorInStaticClass();
    internal static string get_ERR_ConstValueRequired();
    internal static string get_ERR_ConversionNotInvolvingContainedType();
    internal static string get_ERR_ConversionWithBase();
    internal static string get_ERR_ConversionWithDerived();
    internal static string get_ERR_ConversionWithInterface();
    internal static string get_ERR_ConvertToStaticClass();
    internal static string get_ERR_ConWithValCon();
    internal static string get_ERR_CryptoHashFailed();
    internal static string get_ERR_CStyleArray();
    internal static string get_ERR_CycleInInterfaceInheritance();
    internal static string get_ERR_CycleInTypeForwarder();
    internal static string get_ERR_DebugEntryPointNotSourceMethodDefinition();
    internal static string get_ERR_DecConstError();
    internal static string get_ERR_DefaultMemberOnIndexedType();
    internal static string get_ERR_DefaultValueBadValueType();
    internal static string get_ERR_DefaultValueBeforeRequiredValue();
    internal static string get_ERR_DefaultValueForExtensionParameter();
    internal static string get_ERR_DefaultValueForParamsParameter();
    internal static string get_ERR_DefaultValueMustBeConstant();
    internal static string get_ERR_DefaultValueNotAllowed();
    internal static string get_ERR_DefaultValueTypeMustMatch();
    internal static string get_ERR_DefaultValueUsedWithAttributes();
    internal static string get_ERR_DelegateOnConditional();
    internal static string get_ERR_DelegateOnNullable();
    internal static string get_ERR_DeprecatedCollectionInitAddStr();
    internal static string get_ERR_DeprecatedSymbolStr();
    internal static string get_ERR_DeriveFromConstructedDynamic();
    internal static string get_ERR_DeriveFromDynamic();
    internal static string get_ERR_DeriveFromEnumOrValueType();
    internal static string get_ERR_DerivingFromATyVar();
    internal static string get_ERR_DestructorInStaticClass();
    internal static string get_ERR_DictionaryInitializerInExpressionTree();
    internal static string get_ERR_DllImportOnGenericMethod();
    internal static string get_ERR_DllImportOnInvalidMethod();
    internal static string get_ERR_DoesntImplementAwaitInterface();
    internal static string get_ERR_DoNotUseFixedBufferAttr();
    internal static string get_ERR_DottedTypeNameNotFoundInAgg();
    internal static string get_ERR_DottedTypeNameNotFoundInNS();
    internal static string get_ERR_DottedTypeNameNotFoundInNSFwd();
    internal static string get_ERR_DuplicateAccessor();
    internal static string get_ERR_DuplicateAlias();
    internal static string get_ERR_DuplicateAttribute();
    internal static string get_ERR_DuplicateAttributeInNetModule();
    internal static string get_ERR_DuplicateBound();
    internal static string get_ERR_DuplicateCaseLabel();
    internal static string get_ERR_DuplicateConstraintClause();
    internal static string get_ERR_DuplicateConversionInClass();
    internal static string get_ERR_DuplicateGeneratedName();
    internal static string get_ERR_DuplicateImport();
    internal static string get_ERR_DuplicateImportSimple();
    internal static string get_ERR_DuplicateInterfaceInBaseList();
    internal static string get_ERR_DuplicateLabel();
    internal static string get_ERR_DuplicateModifier();
    internal static string get_ERR_DuplicateNamedArgument();
    internal static string get_ERR_DuplicateNamedAttributeArgument();
    internal static string get_ERR_DuplicateNameInClass();
    internal static string get_ERR_DuplicateNameInNS();
    internal static string get_ERR_DuplicateParamName();
    internal static string get_ERR_DuplicatePropertyAccessMods();
    internal static string get_ERR_DuplicateTypeForwarder();
    internal static string get_ERR_DuplicateTypeParameter();
    internal static string get_ERR_DupParamMod();
    internal static string get_ERR_DynamicAttributeMissing();
    internal static string get_ERR_DynamicRequiredTypesMissing();
    internal static string get_ERR_DynamicTypeAsBound();
    internal static string get_ERR_EmptyCharConst();
    internal static string get_ERR_EmptyElementInitializer();
    internal static string get_ERR_EmptyFormatSpecifier();
    internal static string get_ERR_EmptyYield();
    internal static string get_ERR_EncNoPIAReference();
    internal static string get_ERR_EncodinglessSyntaxTree();
    internal static string get_ERR_EncReferenceToAddedMember();
    internal static string get_ERR_EncUpdateFailedMissingAttribute();
    internal static string get_ERR_EndifDirectiveExpected();
    internal static string get_ERR_EndOfPPLineExpected();
    internal static string get_ERR_EndRegionDirectiveExpected();
    internal static string get_ERR_EnumeratorOverflow();
    internal static string get_ERR_EnumsCantContainDefaultConstructor();
    internal static string get_ERR_EOFExpected();
    internal static string get_ERR_ErrorBuildingWin32Resources();
    internal static string get_ERR_ErrorDirective();
    internal static string get_ERR_ErrorInReferencedAssembly();
    internal static string get_ERR_EscapedCurly();
    internal static string get_ERR_EventNeedsBothAccessors();
    internal static string get_ERR_EventNotDelegate();
    internal static string get_ERR_EventPropertyInInterface();
    internal static string get_ERR_ExpectedContextualKeywordBy();
    internal static string get_ERR_ExpectedContextualKeywordEquals();
    internal static string get_ERR_ExpectedContextualKeywordOn();
    internal static string get_ERR_ExpectedEndTry();
    internal static string get_ERR_ExpectedPPFile();
    internal static string get_ERR_ExpectedSelectOrGroup();
    internal static string get_ERR_ExpectedSingleScript();
    internal static string get_ERR_ExpectedVerbatimLiteral();
    internal static string get_ERR_ExplicitDynamicAttr();
    internal static string get_ERR_ExplicitEventFieldImpl();
    internal static string get_ERR_ExplicitExtension();
    internal static string get_ERR_ExplicitImplCollisionOnRefOut();
    internal static string get_ERR_ExplicitImplParams();
    internal static string get_ERR_ExplicitInterfaceImplementationInNonClassOrStruct();
    internal static string get_ERR_ExplicitInterfaceImplementationNotInterface();
    internal static string get_ERR_ExplicitLayoutAndAutoImplementedProperty();
    internal static string get_ERR_ExplicitMethodImplAccessor();
    internal static string get_ERR_ExplicitParamArray();
    internal static string get_ERR_ExplicitPropertyAddingAccessor();
    internal static string get_ERR_ExplicitPropertyMissingAccessor();
    internal static string get_ERR_ExportedTypeConflictsWithDeclaration();
    internal static string get_ERR_ExportedTypesConflict();
    internal static string get_ERR_ExpressionExpected();
    internal static string get_ERR_ExpressionHasNoName();
    internal static string get_ERR_ExpressionOrDeclarationExpected();
    internal static string get_ERR_ExpressionTreeContainsAnonymousMethod();
    internal static string get_ERR_ExpressionTreeContainsAssignment();
    internal static string get_ERR_ExpressionTreeContainsBadCoalesce();
    internal static string get_ERR_ExpressionTreeContainsBaseAccess();
    internal static string get_ERR_ExpressionTreeContainsDynamicOperation();
    internal static string get_ERR_ExpressionTreeContainsIndexedProperty();
    internal static string get_ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer();
    internal static string get_ERR_ExpressionTreeContainsNamedArgument();
    internal static string get_ERR_ExpressionTreeContainsOptionalArgument();
    internal static string get_ERR_ExpressionTreeContainsPointerOp();
    internal static string get_ERR_ExpressionTreeMustHaveDelegate();
    internal static string get_ERR_ExtensionAttrNotFound();
    internal static string get_ERR_ExtensionCollectionElementInitializerInExpressionTree();
    internal static string get_ERR_ExtensionMethodsDecl();
    internal static string get_ERR_ExternAfterElements();
    internal static string get_ERR_ExternAliasNotAllowed();
    internal static string get_ERR_ExternHasBody();
    internal static string get_ERR_ExternHasConstructorInitializer();
    internal static string get_ERR_FeatureIsExperimental();
    internal static string get_ERR_FeatureNotAvailableInVersion1();
    internal static string get_ERR_FeatureNotAvailableInVersion2();
    internal static string get_ERR_FeatureNotAvailableInVersion3();
    internal static string get_ERR_FeatureNotAvailableInVersion4();
    internal static string get_ERR_FeatureNotAvailableInVersion5();
    internal static string get_ERR_FeatureNotAvailableInVersion6();
    internal static string get_ERR_FeatureNotValidInExpressionTree();
    internal static string get_ERR_FieldCantBeRefAny();
    internal static string get_ERR_FieldCantHaveVoidType();
    internal static string get_ERR_FieldHasMultipleDistinctConstantValues();
    internal static string get_ERR_FieldInitializerInStruct();
    internal static string get_ERR_FieldInitRefNonstatic();
    internal static string get_ERR_FileNotFound();
    internal static string get_ERR_FixedBufferNotFixed();
    internal static string get_ERR_FixedBufferTooManyDimensions();
    internal static string get_ERR_FixedDimsRequired();
    internal static string get_ERR_FixedLocalInLambda();
    internal static string get_ERR_FixedMustInit();
    internal static string get_ERR_FixedNeeded();
    internal static string get_ERR_FixedNeedsLvalue();
    internal static string get_ERR_FixedNotInStruct();
    internal static string get_ERR_FixedNotNeeded();
    internal static string get_ERR_FixedOverflow();
    internal static string get_ERR_FloatOverflow();
    internal static string get_ERR_ForEachMissingMember();
    internal static string get_ERR_ForwardedTypeConflictsWithDeclaration();
    internal static string get_ERR_ForwardedTypeConflictsWithExportedType();
    internal static string get_ERR_ForwardedTypeInThisAssembly();
    internal static string get_ERR_ForwardedTypeIsNested();
    internal static string get_ERR_ForwardedTypesConflict();
    internal static string get_ERR_FriendAssemblyBadArgs();
    internal static string get_ERR_FriendAssemblySNReq();
    internal static string get_ERR_FriendRefNotEqualToThis();
    internal static string get_ERR_FriendRefSigningMismatch();
    internal static string get_ERR_GenericArgIsStaticClass();
    internal static string get_ERR_GenericConstraintNotSatisfiedNullableEnum();
    internal static string get_ERR_GenericConstraintNotSatisfiedNullableInterface();
    internal static string get_ERR_GenericConstraintNotSatisfiedRefType();
    internal static string get_ERR_GenericConstraintNotSatisfiedTyVar();
    internal static string get_ERR_GenericConstraintNotSatisfiedValType();
    internal static string get_ERR_GenericDerivingFromAttribute();
    internal static string get_ERR_GenericsUsedAcrossAssemblies();
    internal static string get_ERR_GenericsUsedInNoPIAType();
    internal static string get_ERR_GetOrSetExpected();
    internal static string get_ERR_GlobalAttributesNotAllowed();
    internal static string get_ERR_GlobalAttributesNotFirst();
    internal static string get_ERR_GlobalDefinitionOrStatementExpected();
    internal static string get_ERR_GlobalExternAlias();
    internal static string get_ERR_GlobalSingleTypeNameNotFound();
    internal static string get_ERR_GlobalSingleTypeNameNotFoundFwd();
    internal static string get_ERR_GlobalStatement();
    internal static string get_ERR_HasNoTypeVars();
    internal static string get_ERR_HidingAbstractMethod();
    internal static string get_ERR_IdentifierExpected();
    internal static string get_ERR_IdentifierExpectedKW();
    internal static string get_ERR_IdentityConversion();
    internal static string get_ERR_IllegalArglist();
    internal static string get_ERR_IllegalEscape();
    internal static string get_ERR_IllegalFixedType();
    internal static string get_ERR_IllegalInnerUnsafe();
    internal static string get_ERR_IllegalParams();
    internal static string get_ERR_IllegalRefParam();
    internal static string get_ERR_IllegalStatement();
    internal static string get_ERR_IllegalUnsafe();
    internal static string get_ERR_IllegalVarArgs();
    internal static string get_ERR_IllegalVarianceSyntax();
    internal static string get_ERR_ImplBadConstraints();
    internal static string get_ERR_ImplicitlyTypedArrayNoBestType();
    internal static string get_ERR_ImplicitlyTypedLocalCannotBeFixed();
    internal static string get_ERR_ImplicitlyTypedVariableAssignedArrayInitializer();
    internal static string get_ERR_ImplicitlyTypedVariableAssignedBadValue();
    internal static string get_ERR_ImplicitlyTypedVariableCannotBeConst();
    internal static string get_ERR_ImplicitlyTypedVariableMultipleDeclarator();
    internal static string get_ERR_ImplicitlyTypedVariableWithNoInitializer();
    internal static string get_ERR_ImportedCircularBase();
    internal static string get_ERR_ImportNonAssembly();
    internal static string get_ERR_InaccessibleGetter();
    internal static string get_ERR_InaccessibleSetter();
    internal static string get_ERR_InAttrOnOutParam();
    internal static string get_ERR_InconsistentIndexerNames();
    internal static string get_ERR_InconsistentLambdaParameterUsage();
    internal static string get_ERR_IncrementLvalueExpected();
    internal static string get_ERR_IndexedPropertyMustHaveAllOptionalParams();
    internal static string get_ERR_IndexedPropertyRequiresParams();
    internal static string get_ERR_IndexerCantHaveVoidType();
    internal static string get_ERR_IndexerInStaticClass();
    internal static string get_ERR_IndexerNeedsParam();
    internal static string get_ERR_IndirectRecursiveConstructorCall();
    internal static string get_ERR_InExpected();
    internal static string get_ERR_InitializerAddHasParamModifiers();
    internal static string get_ERR_InitializerAddHasWrongSignature();
    internal static string get_ERR_InitializerInStructWithoutExplicitConstructor();
    internal static string get_ERR_InitializerOnNonAutoProperty();
    internal static string get_ERR_InstanceMemberInStaticClass();
    internal static string get_ERR_InstantiatingStaticClass();
    internal static string get_ERR_InsufficientStack();
    internal static string get_ERR_IntDivByZero();
    internal static string get_ERR_IntegralTypeExpected();
    internal static string get_ERR_IntegralTypeValueExpected();
    internal static string get_ERR_InterfaceEventInitializer();
    internal static string get_ERR_InterfaceImplementedByConditional();
    internal static string get_ERR_InterfaceMemberHasBody();
    internal static string get_ERR_InterfaceMemberNotFound();
    internal static string get_ERR_InterfacesCannotContainTypes();
    internal static string get_ERR_InterfacesCantContainConstructors();
    internal static string get_ERR_InterfacesCantContainFields();
    internal static string get_ERR_InterfacesCantContainOperators();
    internal static string get_ERR_InteropMethodWithBody();
    internal static string get_ERR_InteropStructContainsMethods();
    internal static string get_ERR_InteropTypeMissingAttribute();
    internal static string get_ERR_InteropTypesWithSameNameAndGuid();
    internal static string get_ERR_IntOverflow();
    internal static string get_ERR_InvalidAddrOp();
    internal static string get_ERR_InvalidAnonymousTypeMemberDeclarator();
    internal static string get_ERR_InvalidArray();
    internal static string get_ERR_InvalidAssemblyCulture();
    internal static string get_ERR_InvalidAssemblyCultureForExe();
    internal static string get_ERR_InvalidAssemblyName();
    internal static string get_ERR_InvalidAttributeArgument();
    internal static string get_ERR_InvalidConstantDeclarationType();
    internal static string get_ERR_InvalidDebugInformationFormat();
    internal static string get_ERR_InvalidDelegateType();
    internal static string get_ERR_InvalidDynamicCondition();
    internal static string get_ERR_InvalidExprTerm();
    internal static string get_ERR_InvalidFileAlignment();
    internal static string get_ERR_InvalidFixedArraySize();
    internal static string get_ERR_InvalidFormatForGuidForOption();
    internal static string get_ERR_InvalidFwdType();
    internal static string get_ERR_InvalidGotoCase();
    internal static string get_ERR_InvalidInitializerElementInitializer();
    internal static string get_ERR_InvalidLineNumber();
    internal static string get_ERR_InvalidMemberDecl();
    internal static string get_ERR_InvalidNamedArgument();
    internal static string get_ERR_InvalidNumber();
    internal static string get_ERR_InvalidOutputName();
    internal static string get_ERR_InvalidPathMap();
    internal static string get_ERR_InvalidPreprocExpr();
    internal static string get_ERR_InvalidPropertyAccessMod();
    internal static string get_ERR_InvalidQM();
    internal static string get_ERR_InvalidReal();
    internal static string get_ERR_InvalidSignaturePublicKey();
    internal static string get_ERR_InvalidSpecifier();
    internal static string get_ERR_InvalidSubsystemVersion();
    internal static string get_ERR_InvalidVersionFormat();
    internal static string get_ERR_InvalidVersionFormat2();
    internal static string get_ERR_IteratorInInteractive();
    internal static string get_ERR_LabelNotFound();
    internal static string get_ERR_LabelShadow();
    internal static string get_ERR_LambdaInIsAs();
    internal static string get_ERR_LbraceExpected();
    internal static string get_ERR_LegacyObjectIdSyntax();
    internal static string get_ERR_LinkedNetmoduleMetadataMustProvideFullPEImage();
    internal static string get_ERR_LiteralDoubleCast();
    internal static string get_ERR_LoadDirectiveOnlyAllowedInScripts();
    internal static string get_ERR_LocalCantBeFixedAndHoisted();
    internal static string get_ERR_LocalDuplicate();
    internal static string get_ERR_LocalIllegallyOverrides();
    internal static string get_ERR_LocalSameNameAsTypeParam();
    internal static string get_ERR_LocalTypeNameClash();
    internal static string get_ERR_LockNeedsReference();
    internal static string get_ERR_LookupInTypeVariable();
    internal static string get_ERR_MainCantBeAsync();
    internal static string get_ERR_MainClassIsImport();
    internal static string get_ERR_MainClassNotClass();
    internal static string get_ERR_MainClassNotFound();
    internal static string get_ERR_ManagedAddr();
    internal static string get_ERR_MarshalUnmanagedTypeNotValidForFields();
    internal static string get_ERR_MarshalUnmanagedTypeOnlyValidForFields();
    internal static string get_ERR_MemberAlreadyExists();
    internal static string get_ERR_MemberAlreadyInitialized();
    internal static string get_ERR_MemberCannotBeInitialized();
    internal static string get_ERR_MemberNameSameAsType();
    internal static string get_ERR_MemberNeedsType();
    internal static string get_ERR_MemberReserved();
    internal static string get_ERR_MemGroupInExpressionTree();
    internal static string get_ERR_MetadataNameTooLong();
    internal static string get_ERR_MetadataReferencesNotSupported();
    internal static string get_ERR_MethDelegateMismatch();
    internal static string get_ERR_MethGrpToNonDel();
    internal static string get_ERR_MethodArgCantBeRefAny();
    internal static string get_ERR_MethodImplementingAccessor();
    internal static string get_ERR_MethodNameExpected();
    internal static string get_ERR_MethodReturnCantBeRefAny();
    internal static string get_ERR_MissingArgument();
    internal static string get_ERR_MissingArraySize();
    internal static string get_ERR_MissingCoClass();
    internal static string get_ERR_MissingDebugSwitch();
    internal static string get_ERR_MissingGuidForOption();
    internal static string get_ERR_MissingMethodOnSourceInterface();
    internal static string get_ERR_MissingNetModuleReference();
    internal static string get_ERR_MissingPartial();
    internal static string get_ERR_MissingPPFile();
    internal static string get_ERR_MissingPredefinedMember();
    internal static string get_ERR_MissingSourceInterface();
    internal static string get_ERR_MissingStructOffset();
    internal static string get_ERR_MissingTypeInAssembly();
    internal static string get_ERR_MissingTypeInSource();
    internal static string get_ERR_MixingWinRTEventWithRegular();
    internal static string get_ERR_ModuleEmitFailure();
    internal static string get_ERR_MultiParamMod();
    internal static string get_ERR_MultipleEntryPoints();
    internal static string get_ERR_MultipleIEnumOfT();
    internal static string get_ERR_MultiTypeInDeclaration();
    internal static string get_ERR_MustHaveOpTF();
    internal static string get_ERR_MutuallyExclusiveOptions();
    internal static string get_ERR_NamedArgumentExpected();
    internal static string get_ERR_NamedArgumentForArray();
    internal static string get_ERR_NamedArgumentSpecificationBeforeFixedArgument();
    internal static string get_ERR_NamedArgumentUsedInPositional();
    internal static string get_ERR_NameNotInContext();
    internal static string get_ERR_NameNotInContextPossibleMissingReference();
    internal static string get_ERR_NameofExtensionMethod();
    internal static string get_ERR_NameofMethodGroupWithTypeParameters();
    internal static string get_ERR_NamespaceNotAllowedInScript();
    internal static string get_ERR_NamespaceUnexpected();
    internal static string get_ERR_NegativeArraySize();
    internal static string get_ERR_NegativeStackAllocSize();
    internal static string get_ERR_NetModuleNameMismatch();
    internal static string get_ERR_NetModuleNameMustBeUnique();
    internal static string get_ERR_NewBoundMustBeLast();
    internal static string get_ERR_NewBoundWithVal();
    internal static string get_ERR_NewCoClassOnLink();
    internal static string get_ERR_NewConstraintNotSatisfied();
    internal static string get_ERR_NewlineInConst();
    internal static string get_ERR_NewTyvarWithArgs();
    internal static string get_ERR_NewVirtualInSealed();
    internal static string get_ERR_NoAliasHere();
    internal static string get_ERR_NoBaseClass();
    internal static string get_ERR_NoBreakOrCont();
    internal static string get_ERR_NoCanonicalView();
    internal static string get_ERR_NoConstructors();
    internal static string get_ERR_NoConversionForCallerFilePathParam();
    internal static string get_ERR_NoConversionForCallerLineNumberParam();
    internal static string get_ERR_NoConversionForCallerMemberNameParam();
    internal static string get_ERR_NoConversionForDefaultParam();
    internal static string get_ERR_NoConversionForNubDefaultParam();
    internal static string get_ERR_NoConvToIDisp();
    internal static string get_ERR_NoCorrespondingArgument();
    internal static string get_ERR_NoDynamicPhantomOnBase();
    internal static string get_ERR_NoDynamicPhantomOnBaseCtor();
    internal static string get_ERR_NoDynamicPhantomOnBaseIndexer();
    internal static string get_ERR_NoEntryPoint();
    internal static string get_ERR_NoExplicitBuiltinConv();
    internal static string get_ERR_NoExplicitConv();
    internal static string get_ERR_NoFileSpec();
    internal static string get_ERR_NoGetToOverride();
    internal static string get_ERR_NoImplicitConv();
    internal static string get_ERR_NoImplicitConvCast();
    internal static string get_ERR_NoMainInClass();
    internal static string get_ERR_NoMainOnDLL();
    internal static string get_ERR_NoMetadataFile();
    internal static string get_ERR_NoModifiersOnAccessor();
    internal static string get_ERR_NoMultipleInheritance();
    internal static string get_ERR_NoNamespacePrivate();
    internal static string get_ERR_NoNewAbstract();
    internal static string get_ERR_NoNewTyvar();
    internal static string get_ERR_NonInterfaceInInterfaceList();
    internal static string get_ERR_NonInvocableMemberCalled();
    internal static string get_ERR_NoPIAAssemblyMissingAttribute();
    internal static string get_ERR_NoPIAAssemblyMissingAttributes();
    internal static string get_ERR_NoPIANestedType();
    internal static string get_ERR_NoSetToOverride();
    internal static string get_ERR_NoSourceFile();
    internal static string get_ERR_NoSuchMember();
    internal static string get_ERR_NoSuchMemberOrExtension();
    internal static string get_ERR_NoSuchMemberOrExtensionNeedUsing();
    internal static string get_ERR_NotAnAttributeClass();
    internal static string get_ERR_NotConstantExpression();
    internal static string get_ERR_NotNullConstRefField();
    internal static string get_ERR_NotNullRefDefaultParameter();
    internal static string get_ERR_NotYetImplementedInRoslyn();
    internal static string get_ERR_NoTypeDef();
    internal static string get_ERR_NoTypeDefFromModule();
    internal static string get_ERR_NoVoidHere();
    internal static string get_ERR_NoVoidParameter();
    internal static string get_ERR_NullNotValid();
    internal static string get_ERR_NullPropagatingOpInExpressionTree();
    internal static string get_ERR_ObjectCallingBaseConstructor();
    internal static string get_ERR_ObjectCantHaveBases();
    internal static string get_ERR_ObjectOrCollectionInitializerWithDelegateCreation();
    internal static string get_ERR_ObjectProhibited();
    internal static string get_ERR_ObjectRequired();
    internal static string get_ERR_OneAliasPerReference();
    internal static string get_ERR_OnlyClassesCanContainDestructors();
    internal static string get_ERR_OpenEndedComment();
    internal static string get_ERR_OpenResponseFile();
    internal static string get_ERR_OperatorCantReturnVoid();
    internal static string get_ERR_OperatorInStaticClass();
    internal static string get_ERR_OperatorNeedsMatch();
    internal static string get_ERR_OperatorsMustBeStatic();
    internal static string get_ERR_OpTFRetType();
    internal static string get_ERR_OptionMustBeAbsolutePath();
    internal static string get_ERR_OutAttrOnRefParam();
    internal static string get_ERR_OutputNeedsName();
    internal static string get_ERR_OutputWriteFailed();
    internal static string get_ERR_OverloadRefOut();
    internal static string get_ERR_OverloadRefOutCtor();
    internal static string get_ERR_OverrideFinalizeDeprecated();
    internal static string get_ERR_OverrideNotExpected();
    internal static string get_ERR_OverrideNotNew();
    internal static string get_ERR_OverrideWithConstraints();
    internal static string get_ERR_OvlBinaryOperatorExpected();
    internal static string get_ERR_OvlOperatorExpected();
    internal static string get_ERR_OvlUnaryOperatorExpected();
    internal static string get_ERR_ParamDefaultValueDiffersFromAttribute();
    internal static string get_ERR_ParameterIsStaticClass();
    internal static string get_ERR_ParameterNotValidForType();
    internal static string get_ERR_ParamsCantBeRefOut();
    internal static string get_ERR_ParamsLast();
    internal static string get_ERR_ParamsMustBeArray();
    internal static string get_ERR_ParamUnassigned();
    internal static string get_ERR_PartialMethodCannotHaveOutParameters();
    internal static string get_ERR_PartialMethodExtensionDifference();
    internal static string get_ERR_PartialMethodInconsistentConstraints();
    internal static string get_ERR_PartialMethodInExpressionTree();
    internal static string get_ERR_PartialMethodInvalidModifier();
    internal static string get_ERR_PartialMethodMustHaveLatent();
    internal static string get_ERR_PartialMethodMustReturnVoid();
    internal static string get_ERR_PartialMethodNotExplicit();
    internal static string get_ERR_PartialMethodOnlyInPartialClass();
    internal static string get_ERR_PartialMethodOnlyMethods();
    internal static string get_ERR_PartialMethodOnlyOneActual();
    internal static string get_ERR_PartialMethodOnlyOneLatent();
    internal static string get_ERR_PartialMethodParamsDifference();
    internal static string get_ERR_PartialMethodStaticDifference();
    internal static string get_ERR_PartialMethodToDelegate();
    internal static string get_ERR_PartialMethodUnsafeDifference();
    internal static string get_ERR_PartialMisplaced();
    internal static string get_ERR_PartialModifierConflict();
    internal static string get_ERR_PartialMultipleBases();
    internal static string get_ERR_PartialTypeKindConflict();
    internal static string get_ERR_PartialWrongConstraints();
    internal static string get_ERR_PartialWrongTypeParams();
    internal static string get_ERR_PartialWrongTypeParamsVariance();
    internal static string get_ERR_PermissionSetAttributeFileReadError();
    internal static string get_ERR_PermissionSetAttributeInvalidFile();
    internal static string get_ERR_PeWritingFailure();
    internal static string get_ERR_PointerInAsOrIs();
    internal static string get_ERR_PPDefFollowsToken();
    internal static string get_ERR_PPDirectiveExpected();
    internal static string get_ERR_PPLoadFollowsToken();
    internal static string get_ERR_PPReferenceFollowsToken();
    internal static string get_ERR_PredefinedTypeNotFound();
    internal static string get_ERR_PrincipalPermissionInvalidAction();
    internal static string get_ERR_PrivateAbstractAccessor();
    internal static string get_ERR_PropertyAccessModInInterface();
    internal static string get_ERR_PropertyCantHaveVoidType();
    internal static string get_ERR_PropertyLacksGet();
    internal static string get_ERR_PropertyWithNoAccessors();
    internal static string get_ERR_ProtectedInStatic();
    internal static string get_ERR_ProtectedInStruct();
    internal static string get_ERR_PtrExpected();
    internal static string get_ERR_PtrIndexSingle();
    internal static string get_ERR_PublicKeyContainerFailure();
    internal static string get_ERR_PublicKeyFileFailure();
    internal static string get_ERR_PublicSignButNoKey();
    internal static string get_ERR_QueryDuplicateRangeVariable();
    internal static string get_ERR_QueryInnerKey();
    internal static string get_ERR_QueryMultipleProviders();
    internal static string get_ERR_QueryNoProvider();
    internal static string get_ERR_QueryNoProviderCastable();
    internal static string get_ERR_QueryNoProviderStandard();
    internal static string get_ERR_QueryOuterKey();
    internal static string get_ERR_QueryOutRefRangeVariable();
    internal static string get_ERR_QueryRangeVariableAssignedBadValue();
    internal static string get_ERR_QueryRangeVariableOverrides();
    internal static string get_ERR_QueryRangeVariableReadOnly();
    internal static string get_ERR_QueryRangeVariableSameAsTypeParam();
    internal static string get_ERR_QueryTypeInferenceFailed();
    internal static string get_ERR_QueryTypeInferenceFailedMulti();
    internal static string get_ERR_QueryTypeInferenceFailedSelectMany();
    internal static string get_ERR_RbraceExpected();
    internal static string get_ERR_ReadonlyValueTypeInObjectInitializer();
    internal static string get_ERR_RecursiveConstructorCall();
    internal static string get_ERR_RecursivelyTypedVariable();
    internal static string get_ERR_RefConstraintNotSatisfied();
    internal static string get_ERR_ReferenceDirectiveOnlyAllowedInScripts();
    internal static string get_ERR_RefLvalueExpected();
    internal static string get_ERR_RefOutDefaultValue();
    internal static string get_ERR_RefProperty();
    internal static string get_ERR_RefReadonly();
    internal static string get_ERR_RefReadonly2();
    internal static string get_ERR_RefReadonlyLocal();
    internal static string get_ERR_RefReadonlyLocal2Cause();
    internal static string get_ERR_RefReadonlyLocalCause();
    internal static string get_ERR_RefReadonlyStatic();
    internal static string get_ERR_RefReadonlyStatic2();
    internal static string get_ERR_RefValBoundMustBeFirst();
    internal static string get_ERR_RefValBoundWithClass();
    internal static string get_ERR_ReservedAssemblyName();
    internal static string get_ERR_ReservedEnumerator();
    internal static string get_ERR_ResourceFileNameNotUnique();
    internal static string get_ERR_ResourceNotUnique();
    internal static string get_ERR_RetNoObjectRequired();
    internal static string get_ERR_RetNoObjectRequiredLambda();
    internal static string get_ERR_RetObjectRequired();
    internal static string get_ERR_ReturnExpected();
    internal static string get_ERR_ReturnInIterator();
    internal static string get_ERR_ReturnNotLValue();
    internal static string get_ERR_ReturnTypeIsStaticClass();
    internal static string get_ERR_SameFullNameAggAgg();
    internal static string get_ERR_SameFullNameNsAgg();
    internal static string get_ERR_SameFullNameThisAggThisNs();
    internal static string get_ERR_SealedNonOverride();
    internal static string get_ERR_SealedStaticClass();
    internal static string get_ERR_SecurityAttributeInvalidAction();
    internal static string get_ERR_SecurityAttributeInvalidActionAssembly();
    internal static string get_ERR_SecurityAttributeInvalidActionTypeOrMethod();
    internal static string get_ERR_SecurityAttributeInvalidTarget();
    internal static string get_ERR_SecurityAttributeMissingAction();
    internal static string get_ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync();
    internal static string get_ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct();
    internal static string get_ERR_SemicolonExpected();
    internal static string get_ERR_SemiOrLBraceExpected();
    internal static string get_ERR_SignButNoPrivateKey();
    internal static string get_ERR_SingleLineCommentInExpressionHole();
    internal static string get_ERR_SingleTypeNameNotFound();
    internal static string get_ERR_SingleTypeNameNotFoundFwd();
    internal static string get_ERR_SizeofUnsafe();
    internal static string get_ERR_SourceFileReferencesNotSupported();
    internal static string get_ERR_SpecialByRefInLambda();
    internal static string get_ERR_SpecialTypeAsBound();
    internal static string get_ERR_StackallocInCatchFinally();
    internal static string get_ERR_StatementLambdaToExpressionTree();
    internal static string get_ERR_StaticBaseClass();
    internal static string get_ERR_StaticClassInterfaceImpl();
    internal static string get_ERR_StaticConstant();
    internal static string get_ERR_StaticConstParam();
    internal static string get_ERR_StaticConstructorWithAccessModifiers();
    internal static string get_ERR_StaticConstructorWithExplicitConstructorCall();
    internal static string get_ERR_StaticDerivedFromNonObject();
    internal static string get_ERR_StaticInAsOrIs();
    internal static string get_ERR_StaticMemberInObjectInitializer();
    internal static string get_ERR_StaticNotVirtual();
    internal static string get_ERR_StructLayoutCycle();
    internal static string get_ERR_StructOffsetOnBadField();
    internal static string get_ERR_StructOffsetOnBadStruct();
    internal static string get_ERR_StructsCantContainDefaultConstructor();
    internal static string get_ERR_StructWithBaseConstructorCall();
    internal static string get_ERR_SubexpressionNotInNameof();
    internal static string get_ERR_SwitchFallOut();
    internal static string get_ERR_SwitchFallThrough();
    internal static string get_ERR_SwitchGoverningTypeValueExpected();
    internal static string get_ERR_SwitchNeedsNumber();
    internal static string get_ERR_SwitchNeedsString();
    internal static string get_ERR_SynchronizedAsyncMethod();
    internal static string get_ERR_SyntaxError();
    internal static string get_ERR_SystemVoid();
    internal static string get_ERR_TaskRetNoObjectRequired();
    internal static string get_ERR_TaskRetNoObjectRequiredLambda();
    internal static string get_ERR_ThisInBadContext();
    internal static string get_ERR_ThisInStaticMeth();
    internal static string get_ERR_ThisOrBaseExpected();
    internal static string get_ERR_ThisStructNotInAnonMeth();
    internal static string get_ERR_TooManyCatches();
    internal static string get_ERR_TooManyCharsInConst();
    internal static string get_ERR_TooManyLocals();
    internal static string get_ERR_TooManyUserStrings();
    internal static string get_ERR_TrailingWhitespaceInFormatSpecifier();
    internal static string get_ERR_TypeArgsNotAllowed();
    internal static string get_ERR_TypeExpected();
    internal static string get_ERR_TypeParamMustBeIdentifier();
    internal static string get_ERR_TypeVarCantBeNull();
    internal static string get_ERR_TypeVariableSameAsParent();
    internal static string get_ERR_TypeVarNotFound();
    internal static string get_ERR_TypeVarNotFoundRangeVariable();
    internal static string get_ERR_TyVarNotFoundInConstraint();
    internal static string get_ERR_UnassignedThis();
    internal static string get_ERR_UnassignedThisAutoProperty();
    internal static string get_ERR_UnboxNotLValue();
    internal static string get_ERR_UnclosedExpressionHole();
    internal static string get_ERR_UnescapedCurly();
    internal static string get_ERR_UnexpectedAliasedName();
    internal static string get_ERR_UnexpectedBoundGenericName();
    internal static string get_ERR_UnexpectedCharacter();
    internal static string get_ERR_UnexpectedDirective();
    internal static string get_ERR_UnexpectedGenericName();
    internal static string get_ERR_UnexpectedSemicolon();
    internal static string get_ERR_UnexpectedToken();
    internal static string get_ERR_UnexpectedUnboundGenericName();
    internal static string get_ERR_UnexpectedVariance();
    internal static string get_ERR_UnifyingInterfaceInstantiations();
    internal static string get_ERR_UnimplementedAbstractMethod();
    internal static string get_ERR_UnimplementedInterfaceAccessor();
    internal static string get_ERR_UnimplementedInterfaceMember();
    internal static string get_ERR_UnreachableCatch();
    internal static string get_ERR_UnsafeAsyncArgType();
    internal static string get_ERR_UnsafeIteratorArgType();
    internal static string get_ERR_UnsafeNeeded();
    internal static string get_ERR_UnsafeTypeInObjectCreation();
    internal static string get_ERR_UnsupportedTransparentIdentifierAccess();
    internal static string get_ERR_UnterminatedStringLit();
    internal static string get_ERR_UseDefViolation();
    internal static string get_ERR_UseDefViolationField();
    internal static string get_ERR_UseDefViolationOut();
    internal static string get_ERR_UseDefViolationProperty();
    internal static string get_ERR_UseDefViolationThis();
    internal static string get_ERR_UsingAfterElements();
    internal static string get_ERR_ValConstraintNotSatisfied();
    internal static string get_ERR_ValueCantBeNull();
    internal static string get_ERR_ValueExpected();
    internal static string get_ERR_ValueTypeExtDelegate();
    internal static string get_ERR_ValueTypePropertyInObjectInitializer();
    internal static string get_ERR_VarargsAsync();
    internal static string get_ERR_VarArgsInExpressionTree();
    internal static string get_ERR_VarargsIterator();
    internal static string get_ERR_VarargsLast();
    internal static string get_ERR_VarDeclIsStaticClass();
    internal static string get_ERR_VariableUsedBeforeDeclaration();
    internal static string get_ERR_VariableUsedBeforeDeclarationAndHidesField();
    internal static string get_ERR_VirtualPrivate();
    internal static string get_ERR_VoidError();
    internal static string get_ERR_VolatileAndReadonly();
    internal static string get_ERR_VolatileStruct();
    internal static string get_ERR_WinRtEventPassedByRef();
    internal static string get_ERR_YieldInAnonMeth();
    internal static string get_ERR_YieldNotAllowedInScript();
    internal static string get_FTL_BadChecksumAlgorithm();
    internal static string get_FTL_BadCodepage();
    internal static string get_FTL_DebugEmitFailure();
    internal static string get_FTL_InputFileNameTooLong();
    internal static string get_FTL_InvalidTarget();
    internal static string get_FTL_MetadataCantOpenFile();
    internal static string get_FTL_OutputFileExists();
    internal static string get_GenericParameterDefinition();
    internal static string get_HDN_UnusedExternAlias();
    internal static string get_HDN_UnusedExternAlias_Title();
    internal static string get_HDN_UnusedUsingDirective();
    internal static string get_HDN_UnusedUsingDirective_Title();
    internal static string get_IDS_AnonMethod();
    internal static string get_IDS_AwaitInCatchAndFinally();
    internal static string get_IDS_Collection();
    internal static string get_IDS_Contravariant();
    internal static string get_IDS_Contravariantly();
    internal static string get_IDS_Covariant();
    internal static string get_IDS_Covariantly();
    internal static string get_IDS_CSCHelp();
    internal static string get_IDS_DirectoryDoesNotExist();
    internal static string get_IDS_DirectoryHasInvalidPath();
    internal static string get_IDS_FeatureAnonDelegates();
    internal static string get_IDS_FeatureAnonymousTypes();
    internal static string get_IDS_FeatureAsync();
    internal static string get_IDS_FeatureAutoImplementedProperties();
    internal static string get_IDS_FeatureAutoPropertyInitializer();
    internal static string get_IDS_FeatureCollectionInitializer();
    internal static string get_IDS_FeatureDeclarationExpression();
    internal static string get_IDS_FeatureDefault();
    internal static string get_IDS_FeatureDictionaryInitializer();
    internal static string get_IDS_FeatureDynamic();
    internal static string get_IDS_FeatureExceptionFilter();
    internal static string get_IDS_FeatureExpressionBodiedIndexer();
    internal static string get_IDS_FeatureExpressionBodiedMethod();
    internal static string get_IDS_FeatureExpressionBodiedProperty();
    internal static string get_IDS_FeatureExtensionMethod();
    internal static string get_IDS_FeatureExternAlias();
    internal static string get_IDS_FeatureFixedBuffer();
    internal static string get_IDS_FeatureGenerics();
    internal static string get_IDS_FeatureGlobalNamespace();
    internal static string get_IDS_FeatureImplicitArray();
    internal static string get_IDS_FeatureImplicitLocal();
    internal static string get_IDS_FeatureInterpolatedStrings();
    internal static string get_IDS_FeatureIterators();
    internal static string get_IDS_FeatureLambda();
    internal static string get_IDS_FeatureModuleAttrLoc();
    internal static string get_IDS_FeatureNamedArgument();
    internal static string get_IDS_FeatureNameof();
    internal static string get_IDS_FeatureNullable();
    internal static string get_IDS_FeatureNullPropagatingOperator();
    internal static string get_IDS_FeatureObjectInitializer();
    internal static string get_IDS_FeatureOptionalParameter();
    internal static string get_IDS_FeaturePartialMethod();
    internal static string get_IDS_FeaturePartialTypes();
    internal static string get_IDS_FeaturePragma();
    internal static string get_IDS_FeaturePropertyAccessorMods();
    internal static string get_IDS_FeatureQueryExpression();
    internal static string get_IDS_FeatureReadonlyAutoImplementedProperties();
    internal static string get_IDS_FeatureStaticClasses();
    internal static string get_IDS_FeatureSwitchOnBool();
    internal static string get_IDS_FeatureTypeVariance();
    internal static string get_IDS_FeatureUsingStatic();
    internal static string get_IDS_FIXEDLOCAL();
    internal static string get_IDS_FOREACHLOCAL();
    internal static string get_IDS_GlobalNamespace();
    internal static string get_IDS_Invariantly();
    internal static string get_IDS_Lambda();
    internal static string get_IDS_LIB_ENV();
    internal static string get_IDS_LIB_OPTION();
    internal static string get_IDS_LogoLine1();
    internal static string get_IDS_LogoLine2();
    internal static string get_IDS_MethodGroup();
    internal static string get_IDS_Namespace1();
    internal static string get_IDS_NULL();
    internal static string get_IDS_OperationCausedStackOverflow();
    internal static string get_IDS_PathList();
    internal static string get_IDS_REFERENCEPATH_OPTION();
    internal static string get_IDS_RELATEDERROR();
    internal static string get_IDS_RELATEDWARNING();
    internal static string get_IDS_SK_ALIAS();
    internal static string get_IDS_SK_EVENT();
    internal static string get_IDS_SK_EXTERNALIAS();
    internal static string get_IDS_SK_FIELD();
    internal static string get_IDS_SK_LABEL();
    internal static string get_IDS_SK_METHOD();
    internal static string get_IDS_SK_NAMESPACE();
    internal static string get_IDS_SK_PROPERTY();
    internal static string get_IDS_SK_TYPE();
    internal static string get_IDS_SK_TYVAR();
    internal static string get_IDS_SK_UNKNOWN();
    internal static string get_IDS_SK_VARIABLE();
    internal static string get_IDS_Text();
    internal static string get_IDS_ToolName();
    internal static string get_IDS_USINGLOCAL();
    internal static string get_IDS_VersionExperimental();
    internal static string get_IDS_XMLBADINCLUDE();
    internal static string get_IDS_XMLFAILEDINCLUDE();
    internal static string get_IDS_XMLIGNORED();
    internal static string get_IDS_XMLIGNORED2();
    internal static string get_IDS_XMLMISSINGINCLUDEFILE();
    internal static string get_IDS_XMLMISSINGINCLUDEPATH();
    internal static string get_IDS_XMLNOINCLUDE();
    internal static string get_INF_UnableToLoadSomeTypesInAnalyzer();
    internal static string get_INF_UnableToLoadSomeTypesInAnalyzer_Title();
    internal static string get_InvalidGetDeclarationNameMultipleDeclarators();
    internal static string get_ItemsMustBeNonEmpty();
    internal static string get_LocationMustBeProvided();
    internal static string get_LookupOptionsHasInvalidCombo();
    internal static string get_MustCallSetMethodTestData();
    internal static string get_NameConflictForName();
    internal static string get_NoNoneSearchCriteria();
    internal static string get_NotACSharpSymbol();
    internal static string get_PositionIsNotWithinSyntax();
    internal static string get_PositionNotWithinTree();
    internal static string get_SeparatorIsExpected();
    internal static string get_SpeculatedSyntaxNodeCannotBelongToCurrentCompilation();
    internal static string get_SubmissionCanHaveAtMostOne();
    internal static string get_SubmissionCanOnlyInclude();
    internal static string get_SyntaxNodeIsNotWithinSynt();
    internal static string get_SyntaxTreeAlreadyPresent();
    internal static string get_SyntaxTreeFromLoadNoRemoveReplace();
    internal static string get_SyntaxTreeIsNotASubmission();
    internal static string get_SyntaxTreeNotFoundTo();
    internal static string get_SyntaxTreeSemanticModelMust();
    internal static string get_TheStreamCannotBeReadFrom();
    internal static string get_TheStreamCannotBeWritten();
    internal static string get_ThisMethodCanOnlyBeUsedToCreateTokens();
    internal static string get_TreeMustHaveARootNodeWith();
    internal static string get_TreeNotPartOfCompilation();
    internal static string get_TypeArgumentCannotBeNull();
    internal static string get_UseLiteralForNumeric();
    internal static string get_UseLiteralForTokens();
    internal static string get_UseVerbatimIdentifier();
    internal static string get_WRN_AlignmentMagnitude();
    internal static string get_WRN_AlignmentMagnitude_Title();
    internal static string get_WRN_AlwaysNull();
    internal static string get_WRN_AlwaysNull_Title();
    internal static string get_WRN_AmbiguousXMLReference();
    internal static string get_WRN_AmbiguousXMLReference_Title();
    internal static string get_WRN_AnalyzerCannotBeCreated();
    internal static string get_WRN_AnalyzerCannotBeCreated_Title();
    internal static string get_WRN_AssemblyAttributeFromModuleIsOverridden();
    internal static string get_WRN_AssemblyAttributeFromModuleIsOverridden_Title();
    internal static string get_WRN_AssignmentToLockOrDispose();
    internal static string get_WRN_AssignmentToLockOrDispose_Title();
    internal static string get_WRN_AssignmentToSelf();
    internal static string get_WRN_AssignmentToSelf_Title();
    internal static string get_WRN_AsyncLacksAwaits();
    internal static string get_WRN_AsyncLacksAwaits_Title();
    internal static string get_WRN_AttributeIgnoredWhenPublicSigning();
    internal static string get_WRN_AttributeIgnoredWhenPublicSigning_Title();
    internal static string get_WRN_AttributeLocationOnBadDeclaration();
    internal static string get_WRN_AttributeLocationOnBadDeclaration_Title();
    internal static string get_WRN_BadRefCompareLeft();
    internal static string get_WRN_BadRefCompareLeft_Title();
    internal static string get_WRN_BadRefCompareRight();
    internal static string get_WRN_BadRefCompareRight_Title();
    internal static string get_WRN_BadRestoreNumber();
    internal static string get_WRN_BadRestoreNumber_Title();
    internal static string get_WRN_BadUILang();
    internal static string get_WRN_BadUILang_Title();
    internal static string get_WRN_BadWarningNumber();
    internal static string get_WRN_BadWarningNumber_Description();
    internal static string get_WRN_BadWarningNumber_Title();
    internal static string get_WRN_BadXMLRef();
    internal static string get_WRN_BadXMLRef_Title();
    internal static string get_WRN_BadXMLRefParamType();
    internal static string get_WRN_BadXMLRefParamType_Title();
    internal static string get_WRN_BadXMLRefReturnType();
    internal static string get_WRN_BadXMLRefReturnType_Title();
    internal static string get_WRN_BadXMLRefSyntax();
    internal static string get_WRN_BadXMLRefSyntax_Title();
    internal static string get_WRN_BadXMLRefTypeVar();
    internal static string get_WRN_BadXMLRefTypeVar_Title();
    internal static string get_WRN_BitwiseOrSignExtend();
    internal static string get_WRN_BitwiseOrSignExtend_Description();
    internal static string get_WRN_BitwiseOrSignExtend_Title();
    internal static string get_WRN_ByRefNonAgileField();
    internal static string get_WRN_ByRefNonAgileField_Title();
    internal static string get_WRN_CA2000_DisposeObjectsBeforeLosingScope1();
    internal static string get_WRN_CA2000_DisposeObjectsBeforeLosingScope1_Title();
    internal static string get_WRN_CA2000_DisposeObjectsBeforeLosingScope2();
    internal static string get_WRN_CA2000_DisposeObjectsBeforeLosingScope2_Title();
    internal static string get_WRN_CA2202_DoNotDisposeObjectsMultipleTimes();
    internal static string get_WRN_CA2202_DoNotDisposeObjectsMultipleTimes_Title();
    internal static string get_WRN_CallerFilePathParamForUnconsumedLocation();
    internal static string get_WRN_CallerFilePathParamForUnconsumedLocation_Title();
    internal static string get_WRN_CallerFilePathPreferredOverCallerMemberName();
    internal static string get_WRN_CallerFilePathPreferredOverCallerMemberName_Title();
    internal static string get_WRN_CallerLineNumberParamForUnconsumedLocation();
    internal static string get_WRN_CallerLineNumberParamForUnconsumedLocation_Title();
    internal static string get_WRN_CallerLineNumberPreferredOverCallerFilePath();
    internal static string get_WRN_CallerLineNumberPreferredOverCallerFilePath_Title();
    internal static string get_WRN_CallerLineNumberPreferredOverCallerMemberName();
    internal static string get_WRN_CallerLineNumberPreferredOverCallerMemberName_Title();
    internal static string get_WRN_CallerMemberNameParamForUnconsumedLocation();
    internal static string get_WRN_CallerMemberNameParamForUnconsumedLocation_Title();
    internal static string get_WRN_CallOnNonAgileField();
    internal static string get_WRN_CallOnNonAgileField_Description();
    internal static string get_WRN_CallOnNonAgileField_Title();
    internal static string get_WRN_CantHaveManifestForModule();
    internal static string get_WRN_CantHaveManifestForModule_Title();
    internal static string get_WRN_CLS_ArrayArgumentToAttribute();
    internal static string get_WRN_CLS_ArrayArgumentToAttribute_Title();
    internal static string get_WRN_CLS_AssemblyNotCLS();
    internal static string get_WRN_CLS_AssemblyNotCLS_Title();
    internal static string get_WRN_CLS_AssemblyNotCLS2();
    internal static string get_WRN_CLS_AssemblyNotCLS2_Title();
    internal static string get_WRN_CLS_BadArgType();
    internal static string get_WRN_CLS_BadArgType_Title();
    internal static string get_WRN_CLS_BadAttributeType();
    internal static string get_WRN_CLS_BadAttributeType_Title();
    internal static string get_WRN_CLS_BadBase();
    internal static string get_WRN_CLS_BadBase_Description();
    internal static string get_WRN_CLS_BadBase_Title();
    internal static string get_WRN_CLS_BadFieldPropType();
    internal static string get_WRN_CLS_BadFieldPropType_Description();
    internal static string get_WRN_CLS_BadFieldPropType_Title();
    internal static string get_WRN_CLS_BadIdentifier();
    internal static string get_WRN_CLS_BadIdentifier_Title();
    internal static string get_WRN_CLS_BadIdentifierCase();
    internal static string get_WRN_CLS_BadIdentifierCase_Title();
    internal static string get_WRN_CLS_BadInterface();
    internal static string get_WRN_CLS_BadInterface_Title();
    internal static string get_WRN_CLS_BadInterfaceMember();
    internal static string get_WRN_CLS_BadInterfaceMember_Title();
    internal static string get_WRN_CLS_BadReturnType();
    internal static string get_WRN_CLS_BadReturnType_Title();
    internal static string get_WRN_CLS_BadTypeVar();
    internal static string get_WRN_CLS_BadTypeVar_Title();
    internal static string get_WRN_CLS_IllegalTrueInFalse();
    internal static string get_WRN_CLS_IllegalTrueInFalse_Title();
    internal static string get_WRN_CLS_MeaninglessOnParam();
    internal static string get_WRN_CLS_MeaninglessOnParam_Title();
    internal static string get_WRN_CLS_MeaninglessOnPrivateType();
    internal static string get_WRN_CLS_MeaninglessOnPrivateType_Title();
    internal static string get_WRN_CLS_MeaninglessOnReturn();
    internal static string get_WRN_CLS_MeaninglessOnReturn_Title();
    internal static string get_WRN_CLS_ModuleMissingCLS();
    internal static string get_WRN_CLS_ModuleMissingCLS_Title();
    internal static string get_WRN_CLS_NoAbstractMembers();
    internal static string get_WRN_CLS_NoAbstractMembers_Title();
    internal static string get_WRN_CLS_NotOnModules();
    internal static string get_WRN_CLS_NotOnModules_Title();
    internal static string get_WRN_CLS_NotOnModules2();
    internal static string get_WRN_CLS_NotOnModules2_Title();
    internal static string get_WRN_CLS_NoVarArgs();
    internal static string get_WRN_CLS_NoVarArgs_Title();
    internal static string get_WRN_CLS_OverloadRefOut();
    internal static string get_WRN_CLS_OverloadRefOut_Title();
    internal static string get_WRN_CLS_OverloadUnnamed();
    internal static string get_WRN_CLS_OverloadUnnamed_Description();
    internal static string get_WRN_CLS_OverloadUnnamed_Title();
    internal static string get_WRN_CLS_VolatileField();
    internal static string get_WRN_CLS_VolatileField_Title();
    internal static string get_WRN_CmdOptionConflictsSource();
    internal static string get_WRN_CmdOptionConflictsSource_Description();
    internal static string get_WRN_CmdOptionConflictsSource_Title();
    internal static string get_WRN_CmpAlwaysFalse();
    internal static string get_WRN_CmpAlwaysFalse_Title();
    internal static string get_WRN_CoClassWithoutComImport();
    internal static string get_WRN_CoClassWithoutComImport_Title();
    internal static string get_WRN_ComparisonToSelf();
    internal static string get_WRN_ComparisonToSelf_Title();
    internal static string get_WRN_ConflictingChecksum();
    internal static string get_WRN_ConflictingChecksum_Title();
    internal static string get_WRN_ConflictingMachineAssembly();
    internal static string get_WRN_ConflictingMachineAssembly_Title();
    internal static string get_WRN_DebugFullNameTooLong();
    internal static string get_WRN_DebugFullNameTooLong_Title();
    internal static string get_WRN_DefaultValueForUnconsumedLocation();
    internal static string get_WRN_DefaultValueForUnconsumedLocation_Title();
    internal static string get_WRN_DefineIdentifierRequired();
    internal static string get_WRN_DefineIdentifierRequired_Title();
    internal static string get_WRN_DelaySignButNoKey();
    internal static string get_WRN_DelaySignButNoKey_Title();
    internal static string get_WRN_DeprecatedCollectionInitAdd();
    internal static string get_WRN_DeprecatedCollectionInitAdd_Title();
    internal static string get_WRN_DeprecatedCollectionInitAddStr();
    internal static string get_WRN_DeprecatedCollectionInitAddStr_Title();
    internal static string get_WRN_DeprecatedSymbol();
    internal static string get_WRN_DeprecatedSymbol_Title();
    internal static string get_WRN_DeprecatedSymbolStr();
    internal static string get_WRN_DeprecatedSymbolStr_Title();
    internal static string get_WRN_DotOnDefault();
    internal static string get_WRN_DotOnDefault_Title();
    internal static string get_WRN_DuplicateParamTag();
    internal static string get_WRN_DuplicateParamTag_Title();
    internal static string get_WRN_DuplicateTypeParamTag();
    internal static string get_WRN_DuplicateTypeParamTag_Title();
    internal static string get_WRN_DuplicateUsing();
    internal static string get_WRN_DuplicateUsing_Title();
    internal static string get_WRN_DynamicDispatchToConditionalMethod();
    internal static string get_WRN_DynamicDispatchToConditionalMethod_Title();
    internal static string get_WRN_EmptySwitch();
    internal static string get_WRN_EmptySwitch_Title();
    internal static string get_WRN_EndOfPPLineExpected();
    internal static string get_WRN_EndOfPPLineExpected_Title();
    internal static string get_WRN_EqualityOpWithoutEquals();
    internal static string get_WRN_EqualityOpWithoutEquals_Title();
    internal static string get_WRN_EqualityOpWithoutGetHashCode();
    internal static string get_WRN_EqualityOpWithoutGetHashCode_Title();
    internal static string get_WRN_EqualsWithoutGetHashCode();
    internal static string get_WRN_EqualsWithoutGetHashCode_Title();
    internal static string get_WRN_ErrorOverride();
    internal static string get_WRN_ErrorOverride_Description();
    internal static string get_WRN_ErrorOverride_Title();
    internal static string get_WRN_ExplicitImplCollision();
    internal static string get_WRN_ExplicitImplCollision_Title();
    internal static string get_WRN_ExternCtorNoImplementation();
    internal static string get_WRN_ExternCtorNoImplementation_Title();
    internal static string get_WRN_ExternMethodNoImplementation();
    internal static string get_WRN_ExternMethodNoImplementation_Title();
    internal static string get_WRN_FailedInclude();
    internal static string get_WRN_FailedInclude_Title();
    internal static string get_WRN_FileAlreadyIncluded();
    internal static string get_WRN_FileAlreadyIncluded_Title();
    internal static string get_WRN_FileNameTooLong();
    internal static string get_WRN_FileNameTooLong_Title();
    internal static string get_WRN_FilterIsConstant();
    internal static string get_WRN_FilterIsConstant_Title();
    internal static string get_WRN_FinalizeMethod();
    internal static string get_WRN_FinalizeMethod_Description();
    internal static string get_WRN_FinalizeMethod_Title();
    internal static string get_WRN_GlobalAliasDefn();
    internal static string get_WRN_GlobalAliasDefn_Title();
    internal static string get_WRN_GotoCaseShouldConvert();
    internal static string get_WRN_GotoCaseShouldConvert_Title();
    internal static string get_WRN_IdentifierOrNumericLiteralExpected();
    internal static string get_WRN_IdentifierOrNumericLiteralExpected_Title();
    internal static string get_WRN_IllegalPPChecksum();
    internal static string get_WRN_IllegalPPChecksum_Title();
    internal static string get_WRN_IllegalPPWarning();
    internal static string get_WRN_IllegalPPWarning_Title();
    internal static string get_WRN_IllegalPragma();
    internal static string get_WRN_IllegalPragma_Title();
    internal static string get_WRN_IncorrectBooleanAssg();
    internal static string get_WRN_IncorrectBooleanAssg_Title();
    internal static string get_WRN_InvalidAssemblyName();
    internal static string get_WRN_InvalidAssemblyName_Description();
    internal static string get_WRN_InvalidAssemblyName_Title();
    internal static string get_WRN_InvalidAttributeLocation();
    internal static string get_WRN_InvalidAttributeLocation_Title();
    internal static string get_WRN_InvalidInclude();
    internal static string get_WRN_InvalidInclude_Title();
    internal static string get_WRN_InvalidMainSig();
    internal static string get_WRN_InvalidMainSig_Title();
    internal static string get_WRN_InvalidNumber();
    internal static string get_WRN_InvalidNumber_Title();
    internal static string get_WRN_InvalidSearchPathDir();
    internal static string get_WRN_InvalidSearchPathDir_Title();
    internal static string get_WRN_InvalidVersionFormat();
    internal static string get_WRN_InvalidVersionFormat_Title();
    internal static string get_WRN_IsAlwaysFalse();
    internal static string get_WRN_IsAlwaysFalse_Title();
    internal static string get_WRN_IsAlwaysTrue();
    internal static string get_WRN_IsAlwaysTrue_Title();
    internal static string get_WRN_IsDynamicIsConfusing();
    internal static string get_WRN_IsDynamicIsConfusing_Title();
    internal static string get_WRN_LowercaseEllSuffix();
    internal static string get_WRN_LowercaseEllSuffix_Title();
    internal static string get_WRN_MainCantBeGeneric();
    internal static string get_WRN_MainCantBeGeneric_Title();
    internal static string get_WRN_MainIgnored();
    internal static string get_WRN_MainIgnored_Title();
    internal static string get_WRN_MissingParamTag();
    internal static string get_WRN_MissingParamTag_Title();
    internal static string get_WRN_MissingTypeParamTag();
    internal static string get_WRN_MissingTypeParamTag_Title();
    internal static string get_WRN_MissingXMLComment();
    internal static string get_WRN_MissingXMLComment_Description();
    internal static string get_WRN_MissingXMLComment_Title();
    internal static string get_WRN_MultiplePredefTypes();
    internal static string get_WRN_MultiplePredefTypes_Description();
    internal static string get_WRN_MultiplePredefTypes_Title();
    internal static string get_WRN_MultipleRuntimeImplementationMatches();
    internal static string get_WRN_MultipleRuntimeImplementationMatches_Description();
    internal static string get_WRN_MultipleRuntimeImplementationMatches_Title();
    internal static string get_WRN_MultipleRuntimeOverrideMatches();
    internal static string get_WRN_MultipleRuntimeOverrideMatches_Title();
    internal static string get_WRN_NegativeArrayIndex();
    internal static string get_WRN_NegativeArrayIndex_Title();
    internal static string get_WRN_NewNotRequired();
    internal static string get_WRN_NewNotRequired_Title();
    internal static string get_WRN_NewOrOverrideExpected();
    internal static string get_WRN_NewOrOverrideExpected_Title();
    internal static string get_WRN_NewRequired();
    internal static string get_WRN_NewRequired_Description();
    internal static string get_WRN_NewRequired_Title();
    internal static string get_WRN_NoAnalyzerInAssembly();
    internal static string get_WRN_NoAnalyzerInAssembly_Title();
    internal static string get_WRN_NoConfigNotOnCommandLine();
    internal static string get_WRN_NoConfigNotOnCommandLine_Title();
    internal static string get_WRN_NonECMAFeature();
    internal static string get_WRN_NonECMAFeature_Title();
    internal static string get_WRN_NonObsoleteOverridingObsolete();
    internal static string get_WRN_NonObsoleteOverridingObsolete_Title();
    internal static string get_WRN_NoRuntimeMetadataVersion();
    internal static string get_WRN_NoRuntimeMetadataVersion_Title();
    internal static string get_WRN_NoSources();
    internal static string get_WRN_NoSources_Title();
    internal static string get_WRN_NubExprIsConstBool();
    internal static string get_WRN_NubExprIsConstBool_Title();
    internal static string get_WRN_NubExprIsConstBool2();
    internal static string get_WRN_NubExprIsConstBool2_Title();
    internal static string get_WRN_ObsoleteOverridingNonObsolete();
    internal static string get_WRN_ObsoleteOverridingNonObsolete_Title();
    internal static string get_WRN_PatternBadSignature();
    internal static string get_WRN_PatternBadSignature_Title();
    internal static string get_WRN_PatternIsAmbiguous();
    internal static string get_WRN_PatternIsAmbiguous_Title();
    internal static string get_WRN_PatternStaticOrInaccessible();
    internal static string get_WRN_PatternStaticOrInaccessible_Title();
    internal static string get_WRN_PdbLocalNameTooLong();
    internal static string get_WRN_PdbLocalNameTooLong_Title();
    internal static string get_WRN_PossibleMistakenNullStatement();
    internal static string get_WRN_PossibleMistakenNullStatement_Title();
    internal static string get_WRN_ProtectedInSealed();
    internal static string get_WRN_ProtectedInSealed_Title();
    internal static string get_WRN_RefCultureMismatch();
    internal static string get_WRN_RefCultureMismatch_Title();
    internal static string get_WRN_ReferencedAssemblyDoesNotHaveStrongName();
    internal static string get_WRN_ReferencedAssemblyDoesNotHaveStrongName_Title();
    internal static string get_WRN_ReferencedAssemblyReferencesLinkedPIA();
    internal static string get_WRN_ReferencedAssemblyReferencesLinkedPIA_Description();
    internal static string get_WRN_ReferencedAssemblyReferencesLinkedPIA_Title();
    internal static string get_WRN_SameFullNameThisAggAgg();
    internal static string get_WRN_SameFullNameThisAggAgg_Title();
    internal static string get_WRN_SameFullNameThisAggNs();
    internal static string get_WRN_SameFullNameThisAggNs_Title();
    internal static string get_WRN_SameFullNameThisNsAgg();
    internal static string get_WRN_SameFullNameThisNsAgg_Title();
    internal static string get_WRN_SequentialOnPartialClass();
    internal static string get_WRN_SequentialOnPartialClass_Title();
    internal static string get_WRN_TooManyLinesForDebugger();
    internal static string get_WRN_TooManyLinesForDebugger_Title();
    internal static string get_WRN_TypeParameterSameAsOuterTypeParameter();
    internal static string get_WRN_TypeParameterSameAsOuterTypeParameter_Title();
    internal static string get_WRN_UnableToLoadAnalyzer();
    internal static string get_WRN_UnableToLoadAnalyzer_Title();
    internal static string get_WRN_UnassignedInternalField();
    internal static string get_WRN_UnassignedInternalField_Title();
    internal static string get_WRN_UnifyReferenceBldRev();
    internal static string get_WRN_UnifyReferenceBldRev_Description();
    internal static string get_WRN_UnifyReferenceBldRev_Title();
    internal static string get_WRN_UnifyReferenceMajMin();
    internal static string get_WRN_UnifyReferenceMajMin_Description();
    internal static string get_WRN_UnifyReferenceMajMin_Title();
    internal static string get_WRN_UnimplementedCommandLineSwitch();
    internal static string get_WRN_UnimplementedCommandLineSwitch_Title();
    internal static string get_WRN_UnmatchedParamRefTag();
    internal static string get_WRN_UnmatchedParamRefTag_Title();
    internal static string get_WRN_UnmatchedParamTag();
    internal static string get_WRN_UnmatchedParamTag_Title();
    internal static string get_WRN_UnmatchedTypeParamRefTag();
    internal static string get_WRN_UnmatchedTypeParamRefTag_Title();
    internal static string get_WRN_UnmatchedTypeParamTag();
    internal static string get_WRN_UnmatchedTypeParamTag_Title();
    internal static string get_WRN_UnobservedAwaitableExpression();
    internal static string get_WRN_UnobservedAwaitableExpression_Description();
    internal static string get_WRN_UnobservedAwaitableExpression_Title();
    internal static string get_WRN_UnprocessedXMLComment();
    internal static string get_WRN_UnprocessedXMLComment_Title();
    internal static string get_WRN_UnqualifiedNestedTypeInCref();
    internal static string get_WRN_UnqualifiedNestedTypeInCref_Title();
    internal static string get_WRN_UnreachableCode();
    internal static string get_WRN_UnreachableCode_Title();
    internal static string get_WRN_UnreachableGeneralCatch();
    internal static string get_WRN_UnreachableGeneralCatch_Description();
    internal static string get_WRN_UnreachableGeneralCatch_Title();
    internal static string get_WRN_UnreferencedEvent();
    internal static string get_WRN_UnreferencedEvent_Title();
    internal static string get_WRN_UnreferencedField();
    internal static string get_WRN_UnreferencedField_Title();
    internal static string get_WRN_UnreferencedFieldAssg();
    internal static string get_WRN_UnreferencedFieldAssg_Title();
    internal static string get_WRN_UnreferencedLabel();
    internal static string get_WRN_UnreferencedLabel_Title();
    internal static string get_WRN_UnreferencedVar();
    internal static string get_WRN_UnreferencedVar_Title();
    internal static string get_WRN_UnreferencedVarAssg();
    internal static string get_WRN_UnreferencedVarAssg_Title();
    internal static string get_WRN_VacuousIntegralComp();
    internal static string get_WRN_VacuousIntegralComp_Title();
    internal static string get_WRN_VolatileByRef();
    internal static string get_WRN_VolatileByRef_Description();
    internal static string get_WRN_VolatileByRef_Title();
    internal static string get_WRN_WarningDirective();
    internal static string get_WRN_WarningDirective_Title();
    internal static string get_WRN_XMLParseError();
    internal static string get_WRN_XMLParseError_Title();
    internal static string get_WRN_XMLParseIncludeError();
    internal static string get_WRN_XMLParseIncludeError_Title();
    internal static string get_WrongNumberOfTypeArguments();
    internal static string get_WrongSemanticModelType();
    internal static string get_XML_CDataEndTagNotAllowed();
    internal static string get_XML_DuplicateAttribute();
    internal static string get_XML_ElementTypeMatch();
    internal static string get_XML_EndTagExpected();
    internal static string get_XML_EndTagNotExpected();
    internal static string get_XML_ExpectedEndOfTag();
    internal static string get_XML_ExpectedEndOfXml();
    internal static string get_XML_ExpectedIdentifier();
    internal static string get_XML_IncorrectComment();
    internal static string get_XML_InvalidCharEntity();
    internal static string get_XML_InvalidToken();
    internal static string get_XML_InvalidUnicodeChar();
    internal static string get_XML_InvalidWhitespace();
    internal static string get_XML_LessThanInAttributeValue();
    internal static string get_XML_MissingEqualsAttribute();
    internal static string get_XML_RefUndefinedEntity_1();
    internal static string get_XML_StringLiteralNoEndQuote();
    internal static string get_XML_StringLiteralNonAsciiQuote();
    internal static string get_XML_StringLiteralNoStartQuote();
    internal static string get_XML_WhitespaceMissing();
}
public class Microsoft.CodeAnalysis.CSharp.CSharpScriptCompilationInfo : ScriptCompilationInfo {
    [CompilerGeneratedAttribute]
private CSharpCompilation <PreviousScriptCompilation>k__BackingField;
    public CSharpCompilation PreviousScriptCompilation { get; }
    internal Compilation CommonPreviousScriptCompilation { get; }
    internal CSharpScriptCompilationInfo(CSharpCompilation previousCompilationOpt, Type returnType, Type globalsType);
    [CompilerGeneratedAttribute]
public CSharpCompilation get_PreviousScriptCompilation();
    internal virtual Compilation get_CommonPreviousScriptCompilation();
    public CSharpScriptCompilationInfo WithPreviousScriptCompilation(CSharpCompilation compilation);
    internal virtual ScriptCompilationInfo CommonWithPreviousScriptCompilation(Compilation compilation);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel : SemanticModel {
    public CSharpCompilation Compilation { get; }
    internal CSharpSyntaxNode Root { get; }
    public CSharpSemanticModel ParentModel { get; }
    public SyntaxTree SyntaxTree { get; }
    public string Language { get; }
    protected Compilation CompilationCore { get; }
    protected SemanticModel ParentModelCore { get; }
    protected SyntaxTree SyntaxTreeCore { get; }
    public abstract virtual CSharpCompilation get_Compilation();
    internal abstract virtual CSharpSyntaxNode get_Root();
    internal static bool CanGetSemanticInfo(CSharpSyntaxNode node, bool allowNamedArgumentName, bool isSpeculative);
    internal abstract virtual SymbolInfo GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken);
    internal abstract virtual SymbolInfo GetCollectionInitializerSymbolInfoWorker(InitializerExpressionSyntax collectionInitializer, ExpressionSyntax node, CancellationToken cancellationToken);
    internal abstract virtual CSharpTypeInfo GetTypeInfoWorker(CSharpSyntaxNode node, CancellationToken cancellationToken);
    internal abstract virtual ImmutableArray`1<Symbol> GetMemberGroupWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken);
    internal abstract virtual ImmutableArray`1<PropertySymbol> GetIndexerGroupWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken);
    internal abstract virtual Optional`1<object> GetConstantValueWorker(CSharpSyntaxNode node, CancellationToken cancellationToken);
    internal Binder GetSpeculativeBinder(int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption);
    private Binder GetSpeculativeBinderForAttribute(int position);
    private static BoundExpression GetSpeculativelyBoundExpressionHelper(Binder binder, ExpressionSyntax expression, SpeculativeBindingOption bindingOption, DiagnosticBag diagnostics);
    private BoundExpression GetSpeculativelyBoundExpression(int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption, Binder& binder, ImmutableArray`1& crefSymbols);
    internal static ImmutableArray`1<Symbol> BindCref(CrefSyntax crefSyntax, Binder binder);
    internal SymbolInfo GetCrefSymbolInfo(int position, CrefSyntax crefSyntax, SymbolInfoOptions options, bool hasParameterList);
    internal static bool HasParameterList(CrefSyntax crefSyntax);
    private static SymbolInfo GetCrefSymbolInfo(ImmutableArray`1<Symbol> symbols, SymbolInfoOptions options, bool hasParameterList);
    private BoundAttribute GetSpeculativelyBoundAttribute(int position, AttributeSyntax attribute, Binder& binder);
    private int CheckAndAdjustPositionForSpeculativeAttribute(int position);
    protected virtual IOperation GetOperationCore(SyntaxNode node, CancellationToken cancellationToken);
    internal virtual IOperation GetOperationWorker(CSharpSyntaxNode node, GetOperationOptions options, CancellationToken cancellationToken);
    public abstract virtual SymbolInfo GetSymbolInfo(OrderingSyntax node, CancellationToken cancellationToken);
    public abstract virtual SymbolInfo GetSymbolInfo(SelectOrGroupClauseSyntax node, CancellationToken cancellationToken);
    public SymbolInfo GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken);
    public SymbolInfo GetCollectionInitializerSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken);
    public SymbolInfo GetSymbolInfo(ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken);
    public SymbolInfo GetSymbolInfo(AttributeSyntax attributeSyntax, CancellationToken cancellationToken);
    public SymbolInfo GetSymbolInfo(CrefSyntax crefSyntax, CancellationToken cancellationToken);
    public SymbolInfo GetSpeculativeSymbolInfo(int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption);
    public SymbolInfo GetSpeculativeSymbolInfo(int position, AttributeSyntax attribute);
    public SymbolInfo GetSpeculativeSymbolInfo(int position, ConstructorInitializerSyntax constructorInitializer);
    public SymbolInfo GetSpeculativeSymbolInfo(int position, CrefSyntax cref, SymbolInfoOptions options);
    public TypeInfo GetTypeInfo(ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken);
    public abstract virtual TypeInfo GetTypeInfo(SelectOrGroupClauseSyntax node, CancellationToken cancellationToken);
    public TypeInfo GetTypeInfo(ExpressionSyntax expression, CancellationToken cancellationToken);
    public TypeInfo GetTypeInfo(AttributeSyntax attributeSyntax, CancellationToken cancellationToken);
    public Conversion GetConversion(SyntaxNode expression, CancellationToken cancellationToken);
    public TypeInfo GetSpeculativeTypeInfo(int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption);
    internal CSharpTypeInfo GetSpeculativeTypeInfoWorker(int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption);
    public Conversion GetSpeculativeConversion(int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption);
    public ImmutableArray`1<ISymbol> GetMemberGroup(ExpressionSyntax expression, CancellationToken cancellationToken);
    public ImmutableArray`1<ISymbol> GetMemberGroup(AttributeSyntax attribute, CancellationToken cancellationToken);
    public ImmutableArray`1<ISymbol> GetMemberGroup(ConstructorInitializerSyntax initializer, CancellationToken cancellationToken);
    public ImmutableArray`1<IPropertySymbol> GetIndexerGroup(ExpressionSyntax expression, CancellationToken cancellationToken);
    public Optional`1<object> GetConstantValue(ExpressionSyntax expression, CancellationToken cancellationToken);
    public abstract virtual QueryClauseInfo GetQueryClauseInfo(QueryClauseSyntax node, CancellationToken cancellationToken);
    public IAliasSymbol GetAliasInfo(IdentifierNameSyntax nameSyntax, CancellationToken cancellationToken);
    public IAliasSymbol GetSpeculativeAliasInfo(int position, IdentifierNameSyntax nameSyntax, SpeculativeBindingOption bindingOption);
    internal Binder GetEnclosingBinder(int position);
    internal abstract virtual Binder GetEnclosingBinderInternal(int position);
    internal abstract virtual MemberSemanticModel GetMemberModel(CSharpSyntaxNode node);
    internal bool IsInTree(CSharpSyntaxNode node);
    private static bool IsInStructuredTriviaOtherThanCrefOrNameAttribute(CSharpSyntaxNode node);
    protected int CheckAndAdjustPosition(int position);
    protected int CheckAndAdjustPosition(int position, SyntaxToken& token);
    protected int GetAdjustedNodePosition(CSharpSyntaxNode node);
    [ConditionalAttribute("DEBUG")]
protected void AssertPositionAdjusted(int position);
    protected void CheckSyntaxNode(CSharpSyntaxNode syntax);
    private void CheckModelAndSyntaxNodeToSpeculate(CSharpSyntaxNode syntax);
    public ImmutableArray`1<ISymbol> LookupSymbols(int position, INamespaceOrTypeSymbol container, string name, bool includeReducedExtensionMethods);
    public ImmutableArray`1<ISymbol> LookupBaseMembers(int position, string name);
    public ImmutableArray`1<ISymbol> LookupStaticMembers(int position, INamespaceOrTypeSymbol container, string name);
    public ImmutableArray`1<ISymbol> LookupNamespacesAndTypes(int position, INamespaceOrTypeSymbol container, string name);
    public ImmutableArray`1<ISymbol> LookupLabels(int position, string name);
    private ImmutableArray`1<Symbol> LookupSymbolsInternal(int position, NamespaceOrTypeSymbol container, string name, LookupOptions options, bool useBaseReferenceAccessibility);
    private void AppendSymbolsWithName(ArrayBuilder`1<Symbol> results, string name, Binder binder, NamespaceOrTypeSymbol container, LookupOptions options, LookupSymbolsInfo info);
    private void AppendSymbolsWithNameAndArity(ArrayBuilder`1<Symbol> results, string name, int arity, Binder binder, NamespaceOrTypeSymbol container, LookupOptions options);
    private static ImmutableArray`1<Symbol> FilterNotReferencable(ImmutableArray`1<Symbol> sealedResults);
    public bool IsAccessible(int position, ISymbol symbol);
    public bool IsEventUsableAsField(int position, IEventSymbol eventSymbol);
    private bool IsInTypeofExpression(int position);
    internal SymbolInfo GetSymbolInfoForNode(SymbolInfoOptions options, BoundNode lowestBoundNode, BoundNode highestBoundNode, BoundNode boundNodeForSyntacticParent, Binder binderOpt);
    private static void AddUnwrappingErrorTypes(ArrayBuilder`1<Symbol> builder, Symbol s);
    private static bool IsUserDefinedTrueOrFalse(BoundUnaryOperator operator);
    internal CSharpTypeInfo GetTypeInfoForNode(BoundNode lowestBoundNode, BoundNode highestBoundNode, BoundNode boundNodeForSyntacticParent);
    internal ImmutableArray`1<Symbol> GetMemberGroupForNode(SymbolInfoOptions options, BoundNode lowestBoundNode, BoundNode boundNodeForSyntacticParent, Binder binderOpt);
    internal ImmutableArray`1<PropertySymbol> GetIndexerGroupForNode(BoundNode lowestBoundNode, Binder binderOpt);
    internal static SymbolInfo GetSymbolInfoForSymbol(Symbol symbol, SymbolInfoOptions options);
    internal static CSharpTypeInfo GetTypeInfoForSymbol(Symbol symbol);
    protected static Symbol UnwrapAlias(Symbol symbol);
    protected static ImmutableArray`1<Symbol> UnwrapAliases(ImmutableArray`1<Symbol> symbols);
    internal virtual BoundNode Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics);
    public virtual ControlFlowAnalysis AnalyzeControlFlow(StatementSyntax firstStatement, StatementSyntax lastStatement);
    public virtual ControlFlowAnalysis AnalyzeControlFlow(StatementSyntax statement);
    public virtual DataFlowAnalysis AnalyzeDataFlow(ExpressionSyntax expression);
    public virtual DataFlowAnalysis AnalyzeDataFlow(StatementSyntax firstStatement, StatementSyntax lastStatement);
    public virtual DataFlowAnalysis AnalyzeDataFlow(StatementSyntax statement);
    public bool TryGetSpeculativeSemanticModelForMethodBody(int position, BaseMethodDeclarationSyntax method, SemanticModel& speculativeModel);
    internal abstract virtual bool TryGetSpeculativeSemanticModelForMethodBodyCore(SyntaxTreeSemanticModel parentModel, int position, BaseMethodDeclarationSyntax method, SemanticModel& speculativeModel);
    public bool TryGetSpeculativeSemanticModelForMethodBody(int position, AccessorDeclarationSyntax accessor, SemanticModel& speculativeModel);
    internal abstract virtual bool TryGetSpeculativeSemanticModelForMethodBodyCore(SyntaxTreeSemanticModel parentModel, int position, AccessorDeclarationSyntax accessor, SemanticModel& speculativeModel);
    public bool TryGetSpeculativeSemanticModel(int position, TypeSyntax type, SemanticModel& speculativeModel, SpeculativeBindingOption bindingOption);
    internal abstract virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, TypeSyntax type, SpeculativeBindingOption bindingOption, SemanticModel& speculativeModel);
    public bool TryGetSpeculativeSemanticModel(int position, StatementSyntax statement, SemanticModel& speculativeModel);
    internal abstract virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, StatementSyntax statement, SemanticModel& speculativeModel);
    public bool TryGetSpeculativeSemanticModel(int position, EqualsValueClauseSyntax initializer, SemanticModel& speculativeModel);
    internal abstract virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, EqualsValueClauseSyntax initializer, SemanticModel& speculativeModel);
    public bool TryGetSpeculativeSemanticModel(int position, ArrowExpressionClauseSyntax expressionBody, SemanticModel& speculativeModel);
    internal abstract virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, ArrowExpressionClauseSyntax expressionBody, SemanticModel& speculativeModel);
    public bool TryGetSpeculativeSemanticModel(int position, ConstructorInitializerSyntax constructorInitializer, SemanticModel& speculativeModel);
    internal abstract virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, ConstructorInitializerSyntax constructorInitializer, SemanticModel& speculativeModel);
    public bool TryGetSpeculativeSemanticModel(int position, CrefSyntax crefSyntax, SemanticModel& speculativeModel);
    internal abstract virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, CrefSyntax crefSyntax, SemanticModel& speculativeModel);
    public bool TryGetSpeculativeSemanticModel(int position, AttributeSyntax attribute, SemanticModel& speculativeModel);
    public abstract virtual CSharpSemanticModel get_ParentModel();
    public abstract virtual SyntaxTree get_SyntaxTree();
    public abstract virtual Conversion ClassifyConversion(ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource);
    public Conversion ClassifyConversion(int position, ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource);
    internal abstract virtual Conversion ClassifyConversionForCast(ExpressionSyntax expression, TypeSymbol destination);
    internal Conversion ClassifyConversionForCast(int position, ExpressionSyntax expression, TypeSymbol destination);
    public abstract virtual ISymbol GetDeclaredSymbol(MemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual INamespaceSymbol GetDeclaredSymbol(NamespaceDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual INamedTypeSymbol GetDeclaredSymbol(BaseTypeDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual INamedTypeSymbol GetDeclaredSymbol(DelegateDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual IFieldSymbol GetDeclaredSymbol(EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual IMethodSymbol GetDeclaredSymbol(BaseMethodDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual ISymbol GetDeclaredSymbol(BasePropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual IPropertySymbol GetDeclaredSymbol(PropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual IPropertySymbol GetDeclaredSymbol(IndexerDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual IEventSymbol GetDeclaredSymbol(EventDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual IPropertySymbol GetDeclaredSymbol(AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, CancellationToken cancellationToken);
    public abstract virtual INamedTypeSymbol GetDeclaredSymbol(AnonymousObjectCreationExpressionSyntax declaratorSyntax, CancellationToken cancellationToken);
    public abstract virtual IMethodSymbol GetDeclaredSymbol(AccessorDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual IMethodSymbol GetDeclaredSymbol(ArrowExpressionClauseSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual ISymbol GetDeclaredSymbol(VariableDeclaratorSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual ILabelSymbol GetDeclaredSymbol(LabeledStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual ILabelSymbol GetDeclaredSymbol(SwitchLabelSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual IAliasSymbol GetDeclaredSymbol(UsingDirectiveSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual IAliasSymbol GetDeclaredSymbol(ExternAliasDirectiveSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual IParameterSymbol GetDeclaredSymbol(ParameterSyntax declarationSyntax, CancellationToken cancellationToken);
    internal abstract virtual ImmutableArray`1<ISymbol> GetDeclaredSymbols(BaseFieldDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    protected ParameterSymbol GetParameterSymbol(ImmutableArray`1<ParameterSymbol> parameters, ParameterSyntax parameter, CancellationToken cancellationToken);
    public abstract virtual ITypeParameterSymbol GetDeclaredSymbol(TypeParameterSyntax typeParameter, CancellationToken cancellationToken);
    internal BinderFlags GetSemanticModelBinderFlags();
    public ILocalSymbol GetDeclaredSymbol(ForEachStatementSyntax forEachStatement, CancellationToken cancellationToken);
    public ILocalSymbol GetDeclaredSymbol(CatchDeclarationSyntax catchDeclaration, CancellationToken cancellationToken);
    public abstract virtual IRangeVariableSymbol GetDeclaredSymbol(QueryClauseSyntax queryClause, CancellationToken cancellationToken);
    public abstract virtual IRangeVariableSymbol GetDeclaredSymbol(JoinIntoClauseSyntax node, CancellationToken cancellationToken);
    public abstract virtual IRangeVariableSymbol GetDeclaredSymbol(QueryContinuationSyntax node, CancellationToken cancellationToken);
    private ImmutableArray`1<Symbol> GetSemanticSymbols(BoundExpression boundNode, BoundNode boundNodeForSyntacticParent, Binder binderOpt, SymbolInfoOptions options, Boolean& isDynamic, LookupResultKind& resultKind, ImmutableArray`1& memberGroup);
    private static ParameterSymbol GetThisParameter(TypeSymbol typeOfThis, NamedTypeSymbol containingType, Symbol containingMember, LookupResultKind& resultKind);
    private static void GetSymbolsAndResultKind(BoundUnaryOperator unaryOperator, Boolean& isDynamic, LookupResultKind& resultKind, ImmutableArray`1& symbols);
    private static void GetSymbolsAndResultKind(BoundIncrementOperator increment, Boolean& isDynamic, LookupResultKind& resultKind, ImmutableArray`1& symbols);
    private static void GetSymbolsAndResultKind(BoundBinaryOperator binaryOperator, Boolean& isDynamic, LookupResultKind& resultKind, ImmutableArray`1& symbols);
    private static Symbol GetIntrinsicOperatorSymbol(BinaryOperatorKind op, bool isDynamic, TypeSymbol leftType, TypeSymbol rightType, TypeSymbol returnType, bool isChecked);
    private static void GetSymbolsAndResultKind(BoundCompoundAssignmentOperator compoundAssignment, Boolean& isDynamic, LookupResultKind& resultKind, ImmutableArray`1& symbols);
    private static void GetSymbolsAndResultKind(BoundExpression node, Symbol symbolOpt, ImmutableArray`1<MethodSymbol> originalCandidates, ImmutableArray`1& symbols, LookupResultKind& resultKind);
    private void AdjustSymbolsForObjectCreation(BoundExpression boundNode, BoundNode boundNodeForSyntacticParent, Binder binderOpt, LookupResultKind& resultKind, ImmutableArray`1& symbols, ImmutableArray`1& memberGroup);
    private void AdjustSymbolsForObjectCreation(BoundNode lowestBoundNode, NamedTypeSymbol typeSymbolOpt, MethodSymbol constructorOpt, Binder binderOpt, LookupResultKind& resultKind, ImmutableArray`1& symbols, ImmutableArray`1& memberGroup);
    private ImmutableArray`1<PropertySymbol> GetIndexerGroupSemanticSymbols(BoundExpression boundNode, Binder binderOpt);
    private static ImmutableArray`1<PropertySymbol> FilterOverriddenOrHiddenIndexers(ImmutableArray`1<Symbol> symbols);
    private static ImmutableArray`1<MethodSymbol> FilterOverriddenOrHiddenMethods(ImmutableArray`1<MethodSymbol> methods);
    private ImmutableArray`1<Symbol> GetMethodGroupSemanticSymbols(BoundMethodGroup boundNode, BoundNode boundNodeForSyntacticParent, Binder binderOpt, LookupResultKind& resultKind, Boolean& isDynamic, ImmutableArray`1& methodGroup);
    private ImmutableArray`1<Symbol> GetPropertyGroupSemanticSymbols(BoundPropertyGroup boundNode, BoundNode boundNodeForSyntacticParent, Binder binderOpt, LookupResultKind& resultKind, ImmutableArray`1& propertyGroup);
    private SymbolInfo GetNamedArgumentSymbolInfo(IdentifierNameSyntax identifierNameSyntax, CancellationToken cancellationToken);
    private static ParameterSymbol FindNamedParameter(ImmutableArray`1<ParameterSymbol> parameters, string argumentName);
    internal static ImmutableArray`1<MethodSymbol> GetReducedAndFilteredMethodGroupSymbols(Binder binder, BoundMethodGroup node);
    private static bool AddReducedAndFilteredMethodGroupSymbol(ArrayBuilder`1<MethodSymbol> methods, ArrayBuilder`1<MethodSymbol> filteredMethods, MethodSymbol method, ImmutableArray`1<TypeSymbol> typeArguments, TypeSymbol receiverType);
    private static void MergeReducedAndFilteredMethodGroupSymbol(ArrayBuilder`1<MethodSymbol> methods, ArrayBuilder`1<MethodSymbol> filteredMethods, SingleLookupResult singleResult, ImmutableArray`1<TypeSymbol> typeArguments, TypeSymbol receiverType, LookupResultKind& resultKind);
    private static ImmutableArray`1<MethodSymbol> CreateReducedExtensionMethodsFromOriginalsIfNecessary(BoundCall call);
    private static ImmutableArray`1<Symbol> CreateReducedExtensionMethodIfPossible(BoundCall call);
    private static ImmutableArray`1<Symbol> CreateReducedExtensionMethodIfPossible(BoundDelegateCreationExpression delegateCreation, BoundExpression receiverOpt);
    public abstract virtual ForEachStatementInfo GetForEachStatementInfo(ForEachStatementSyntax node);
    public abstract virtual AwaitExpressionInfo GetAwaitExpressionInfo(AwaitExpressionSyntax node);
    public PreprocessingSymbolInfo GetPreprocessingSymbolInfo(IdentifierNameSyntax node);
    internal static void ValidateSymbolInfoOptions(SymbolInfoOptions options);
    public ISymbol GetEnclosingSymbol(int position, CancellationToken cancellationToken);
    public sealed virtual string get_Language();
    protected sealed virtual Compilation get_CompilationCore();
    protected sealed virtual SemanticModel get_ParentModelCore();
    protected sealed virtual SyntaxTree get_SyntaxTreeCore();
    private SymbolInfo GetSymbolInfoFromNode(SyntaxNode node, CancellationToken cancellationToken);
    private TypeInfo GetTypeInfoFromNode(SyntaxNode node, CancellationToken cancellationToken);
    private ImmutableArray`1<ISymbol> GetMemberGroupFromNode(SyntaxNode node, CancellationToken cancellationToken);
    protected sealed virtual ImmutableArray`1<ISymbol> GetMemberGroupCore(SyntaxNode node, CancellationToken cancellationToken);
    protected sealed virtual SymbolInfo GetSpeculativeSymbolInfoCore(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    protected sealed virtual TypeInfo GetSpeculativeTypeInfoCore(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    protected sealed virtual IAliasSymbol GetSpeculativeAliasInfoCore(int position, SyntaxNode nameSyntax, SpeculativeBindingOption bindingOption);
    protected sealed virtual SymbolInfo GetSymbolInfoCore(SyntaxNode node, CancellationToken cancellationToken);
    protected sealed virtual TypeInfo GetTypeInfoCore(SyntaxNode node, CancellationToken cancellationToken);
    protected sealed virtual IAliasSymbol GetAliasInfoCore(SyntaxNode node, CancellationToken cancellationToken);
    protected sealed virtual PreprocessingSymbolInfo GetPreprocessingSymbolInfoCore(SyntaxNode node);
    protected sealed virtual ISymbol GetDeclaredSymbolCore(SyntaxNode declaration, CancellationToken cancellationToken);
    protected sealed virtual ImmutableArray`1<ISymbol> GetDeclaredSymbolsCore(SyntaxNode declaration, CancellationToken cancellationToken);
    internal virtual void ComputeDeclarationsInSpan(TextSpan span, bool getSymbol, List`1<DeclarationInfo> builder, CancellationToken cancellationToken);
    internal virtual void ComputeDeclarationsInNode(SyntaxNode node, bool getSymbol, List`1<DeclarationInfo> builder, CancellationToken cancellationToken, Nullable`1<int> levelsToCompute);
    protected internal virtual SyntaxNode GetTopmostNodeForDiagnosticAnalysis(ISymbol symbol, SyntaxNode declaringSyntax);
    protected sealed virtual ImmutableArray`1<ISymbol> LookupSymbolsCore(int position, INamespaceOrTypeSymbol container, string name, bool includeReducedExtensionMethods);
    protected sealed virtual ImmutableArray`1<ISymbol> LookupBaseMembersCore(int position, string name);
    protected sealed virtual ImmutableArray`1<ISymbol> LookupStaticMembersCore(int position, INamespaceOrTypeSymbol container, string name);
    protected sealed virtual ImmutableArray`1<ISymbol> LookupNamespacesAndTypesCore(int position, INamespaceOrTypeSymbol container, string name);
    protected sealed virtual ImmutableArray`1<ISymbol> LookupLabelsCore(int position, string name);
    private static NamespaceOrTypeSymbol ToLanguageSpecific(INamespaceOrTypeSymbol container);
    protected sealed virtual ControlFlowAnalysis AnalyzeControlFlowCore(SyntaxNode firstStatement, SyntaxNode lastStatement);
    protected sealed virtual ControlFlowAnalysis AnalyzeControlFlowCore(SyntaxNode statement);
    protected sealed virtual DataFlowAnalysis AnalyzeDataFlowCore(SyntaxNode firstStatement, SyntaxNode lastStatement);
    protected sealed virtual DataFlowAnalysis AnalyzeDataFlowCore(SyntaxNode statementOrExpression);
    protected sealed virtual Optional`1<object> GetConstantValueCore(SyntaxNode node, CancellationToken cancellationToken);
    protected sealed virtual ISymbol GetEnclosingSymbolCore(int position, CancellationToken cancellationToken);
    protected sealed virtual bool IsAccessibleCore(int position, ISymbol symbol);
    protected sealed virtual bool IsEventUsableAsFieldCore(int position, IEventSymbol symbol);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor : object {
    public virtual void Visit(Symbol symbol);
    public virtual void DefaultVisit(Symbol symbol);
    public virtual void VisitAlias(AliasSymbol symbol);
    public virtual void VisitArrayType(ArrayTypeSymbol symbol);
    public virtual void VisitAssembly(AssemblySymbol symbol);
    public virtual void VisitDynamicType(DynamicTypeSymbol symbol);
    public virtual void VisitEvent(EventSymbol symbol);
    public virtual void VisitField(FieldSymbol symbol);
    public virtual void VisitLabel(LabelSymbol symbol);
    public virtual void VisitLocal(LocalSymbol symbol);
    public virtual void VisitMethod(MethodSymbol symbol);
    public virtual void VisitModule(ModuleSymbol symbol);
    public virtual void VisitNamedType(NamedTypeSymbol symbol);
    public virtual void VisitNamespace(NamespaceSymbol symbol);
    public virtual void VisitParameter(ParameterSymbol symbol);
    public virtual void VisitPointerType(PointerTypeSymbol symbol);
    public virtual void VisitProperty(PropertySymbol symbol);
    public virtual void VisitRangeVariable(RangeVariableSymbol symbol);
    public virtual void VisitTypeParameter(TypeParameterSymbol symbol);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`1 : object {
    public virtual TResult Visit(Symbol symbol);
    public virtual TResult DefaultVisit(Symbol symbol);
    public virtual TResult VisitAlias(AliasSymbol symbol);
    public virtual TResult VisitArrayType(ArrayTypeSymbol symbol);
    public virtual TResult VisitAssembly(AssemblySymbol symbol);
    public virtual TResult VisitDynamicType(DynamicTypeSymbol symbol);
    public virtual TResult VisitEvent(EventSymbol symbol);
    public virtual TResult VisitField(FieldSymbol symbol);
    public virtual TResult VisitLabel(LabelSymbol symbol);
    public virtual TResult VisitLocal(LocalSymbol symbol);
    public virtual TResult VisitMethod(MethodSymbol symbol);
    public virtual TResult VisitModule(ModuleSymbol symbol);
    public virtual TResult VisitNamedType(NamedTypeSymbol symbol);
    public virtual TResult VisitNamespace(NamespaceSymbol symbol);
    public virtual TResult VisitParameter(ParameterSymbol symbol);
    public virtual TResult VisitPointerType(PointerTypeSymbol symbol);
    public virtual TResult VisitProperty(PropertySymbol symbol);
    public virtual TResult VisitRangeVariable(RangeVariableSymbol symbol);
    public virtual TResult VisitTypeParameter(TypeParameterSymbol symbol);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2 : object {
    public virtual TResult Visit(Symbol symbol, TArgument argument);
    public virtual TResult DefaultVisit(Symbol symbol, TArgument argument);
    public virtual TResult VisitAssembly(AssemblySymbol symbol, TArgument argument);
    public virtual TResult VisitModule(ModuleSymbol symbol, TArgument argument);
    public virtual TResult VisitNamespace(NamespaceSymbol symbol, TArgument argument);
    public virtual TResult VisitNamedType(NamedTypeSymbol symbol, TArgument argument);
    public virtual TResult VisitArrayType(ArrayTypeSymbol symbol, TArgument argument);
    public virtual TResult VisitPointerType(PointerTypeSymbol symbol, TArgument argument);
    public virtual TResult VisitErrorType(ErrorTypeSymbol symbol, TArgument argument);
    public virtual TResult VisitTypeParameter(TypeParameterSymbol symbol, TArgument argument);
    public virtual TResult VisitDynamicType(DynamicTypeSymbol symbol, TArgument argument);
    public virtual TResult VisitMethod(MethodSymbol symbol, TArgument argument);
    public virtual TResult VisitField(FieldSymbol symbol, TArgument argument);
    public virtual TResult VisitProperty(PropertySymbol symbol, TArgument argument);
    public virtual TResult VisitEvent(EventSymbol symbol, TArgument argument);
    public virtual TResult VisitParameter(ParameterSymbol symbol, TArgument argument);
    public virtual TResult VisitLocal(LocalSymbol symbol, TArgument argument);
    public virtual TResult VisitLabel(LabelSymbol symbol, TArgument argument);
    public virtual TResult VisitAlias(AliasSymbol symbol, TArgument argument);
    public virtual TResult VisitRangeVariable(RangeVariableSymbol symbol, TArgument argument);
}
public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode : SyntaxNode {
    private static RecordingObjectBinder s_defaultBinder;
    private static ObjectWriterData s_defaultObjectWriterData;
    private static ObjectReaderData s_defaultObjectReaderData;
    private static IEnumerable`1<object> s_serializationData;
    internal AbstractSyntaxNavigator Navigator { get; }
    internal SyntaxTree SyntaxTree { get; }
    internal CSharpSyntaxNode Parent { get; }
    internal CSharpSyntaxNode ParentOrStructuredTriviaParent { get; }
    internal CSharpSyntaxNode CsGreen { get; }
    protected string KindText { get; }
    public string Language { get; }
    internal bool HasErrors { get; }
    internal Location Location { get; }
    protected SyntaxTree SyntaxTreeCore { get; }
    internal CSharpSyntaxNode(GreenNode green, SyntaxNode parent, int position);
    internal CSharpSyntaxNode(GreenNode green, int position, SyntaxTree syntaxTree);
    private static CSharpSyntaxNode();
    internal virtual AbstractSyntaxNavigator get_Navigator();
    internal static T CloneNodeAsRoot(T node, SyntaxTree syntaxTree);
    internal SyntaxTree get_SyntaxTree();
    private static SyntaxTree ComputeSyntaxTree(CSharpSyntaxNode node);
    public abstract virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public abstract virtual void Accept(CSharpSyntaxVisitor visitor);
    internal CSharpSyntaxNode get_Parent();
    internal CSharpSyntaxNode get_ParentOrStructuredTriviaParent();
    internal CSharpSyntaxNode get_CsGreen();
    public SyntaxKind Kind();
    protected virtual string get_KindText();
    public virtual string get_Language();
    internal bool get_HasErrors();
    private bool HasErrorsSlow();
    public SyntaxTriviaList GetLeadingTrivia();
    public SyntaxTriviaList GetTrailingTrivia();
    internal Location get_Location();
    public sealed virtual string ToString();
    public sealed virtual string ToFullString();
    public virtual void WriteTo(TextWriter writer);
    public virtual void SerializeTo(Stream stream, CancellationToken cancellationToken);
    public static SyntaxNode DeserializeFrom(Stream stream, CancellationToken cancellationToken);
    private static ObjectWriterData GetDefaultObjectWriterData();
    private static ObjectReaderData GetDefaultObjectReaderData();
    private static IEnumerable`1<object> GetSerializationData();
    internal bool IsEquivalentTo(CSharpSyntaxNode other);
    public Location GetLocation();
    internal SyntaxReference GetReference();
    public IEnumerable`1<Diagnostic> GetDiagnostics();
    internal sealed virtual SyntaxNode TryGetCorrespondingLambdaBody(SyntaxNode body);
    internal virtual SyntaxNode GetLambda();
    internal IList`1<DirectiveTriviaSyntax> GetDirectives(Func`2<DirectiveTriviaSyntax, bool> filter);
    public DirectiveTriviaSyntax GetFirstDirective(Func`2<DirectiveTriviaSyntax, bool> predicate);
    public DirectiveTriviaSyntax GetLastDirective(Func`2<DirectiveTriviaSyntax, bool> predicate);
    public virtual SyntaxNodeOrToken ChildThatContainsPosition(int position);
    public SyntaxToken GetFirstToken(bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    internal SyntaxToken GetFirstToken(Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    public SyntaxToken GetLastToken(bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    public SyntaxToken FindToken(int position, bool findInsideTrivia);
    internal SyntaxToken FindTokenIncludingCrefAndNameAttributes(int position);
    public SyntaxTrivia FindTrivia(int position, Func`2<SyntaxTrivia, bool> stepInto);
    public SyntaxTrivia FindTrivia(int position, bool findInsideTrivia);
    protected virtual bool EquivalentToCore(SyntaxNode other);
    protected virtual SyntaxTree get_SyntaxTreeCore();
    protected internal virtual SyntaxNode ReplaceCore(IEnumerable`1<TNode> nodes, Func`3<TNode, TNode, SyntaxNode> computeReplacementNode, IEnumerable`1<SyntaxToken> tokens, Func`3<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken, IEnumerable`1<SyntaxTrivia> trivia, Func`3<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia);
    protected internal virtual SyntaxNode ReplaceNodeInListCore(SyntaxNode originalNode, IEnumerable`1<SyntaxNode> replacementNodes);
    protected internal virtual SyntaxNode InsertNodesInListCore(SyntaxNode nodeInList, IEnumerable`1<SyntaxNode> nodesToInsert, bool insertBefore);
    protected internal virtual SyntaxNode ReplaceTokenInListCore(SyntaxToken originalToken, IEnumerable`1<SyntaxToken> newTokens);
    protected internal virtual SyntaxNode InsertTokensInListCore(SyntaxToken originalToken, IEnumerable`1<SyntaxToken> newTokens, bool insertBefore);
    protected internal virtual SyntaxNode ReplaceTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable`1<SyntaxTrivia> newTrivia);
    protected internal virtual SyntaxNode InsertTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable`1<SyntaxTrivia> newTrivia, bool insertBefore);
    protected internal virtual SyntaxNode RemoveNodesCore(IEnumerable`1<SyntaxNode> nodes, SyntaxRemoveOptions options);
    protected internal virtual SyntaxNode NormalizeWhitespaceCore(string indentation, string eol, bool elasticTrivia);
    protected virtual bool IsEquivalentToCore(SyntaxNode node, bool topLevel);
}
public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter : CSharpSyntaxVisitor`1<SyntaxNode> {
    private bool _visitIntoStructuredTrivia;
    private int _recursionDepth;
    public bool VisitIntoStructuredTrivia { get; }
    public CSharpSyntaxRewriter(bool visitIntoStructuredTrivia);
    public virtual bool get_VisitIntoStructuredTrivia();
    public virtual SyntaxNode Visit(SyntaxNode node);
    public virtual SyntaxToken VisitToken(SyntaxToken token);
    public virtual SyntaxTrivia VisitTrivia(SyntaxTrivia trivia);
    public virtual SyntaxList`1<TNode> VisitList(SyntaxList`1<TNode> list);
    public virtual TNode VisitListElement(TNode node);
    public virtual SeparatedSyntaxList`1<TNode> VisitList(SeparatedSyntaxList`1<TNode> list);
    public virtual SyntaxToken VisitListSeparator(SyntaxToken separator);
    public virtual SyntaxTokenList VisitList(SyntaxTokenList list);
    public virtual SyntaxTriviaList VisitList(SyntaxTriviaList list);
    public virtual SyntaxTrivia VisitListElement(SyntaxTrivia element);
    public virtual SyntaxNode VisitIdentifierName(IdentifierNameSyntax node);
    public virtual SyntaxNode VisitQualifiedName(QualifiedNameSyntax node);
    public virtual SyntaxNode VisitGenericName(GenericNameSyntax node);
    public virtual SyntaxNode VisitTypeArgumentList(TypeArgumentListSyntax node);
    public virtual SyntaxNode VisitAliasQualifiedName(AliasQualifiedNameSyntax node);
    public virtual SyntaxNode VisitPredefinedType(PredefinedTypeSyntax node);
    public virtual SyntaxNode VisitArrayType(ArrayTypeSyntax node);
    public virtual SyntaxNode VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node);
    public virtual SyntaxNode VisitPointerType(PointerTypeSyntax node);
    public virtual SyntaxNode VisitNullableType(NullableTypeSyntax node);
    public virtual SyntaxNode VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node);
    public virtual SyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node);
    public virtual SyntaxNode VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node);
    public virtual SyntaxNode VisitAwaitExpression(AwaitExpressionSyntax node);
    public virtual SyntaxNode VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node);
    public virtual SyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node);
    public virtual SyntaxNode VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node);
    public virtual SyntaxNode VisitMemberBindingExpression(MemberBindingExpressionSyntax node);
    public virtual SyntaxNode VisitElementBindingExpression(ElementBindingExpressionSyntax node);
    public virtual SyntaxNode VisitImplicitElementAccess(ImplicitElementAccessSyntax node);
    public virtual SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node);
    public virtual SyntaxNode VisitAssignmentExpression(AssignmentExpressionSyntax node);
    public virtual SyntaxNode VisitConditionalExpression(ConditionalExpressionSyntax node);
    public virtual SyntaxNode VisitThisExpression(ThisExpressionSyntax node);
    public virtual SyntaxNode VisitBaseExpression(BaseExpressionSyntax node);
    public virtual SyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node);
    public virtual SyntaxNode VisitMakeRefExpression(MakeRefExpressionSyntax node);
    public virtual SyntaxNode VisitRefTypeExpression(RefTypeExpressionSyntax node);
    public virtual SyntaxNode VisitRefValueExpression(RefValueExpressionSyntax node);
    public virtual SyntaxNode VisitCheckedExpression(CheckedExpressionSyntax node);
    public virtual SyntaxNode VisitDefaultExpression(DefaultExpressionSyntax node);
    public virtual SyntaxNode VisitTypeOfExpression(TypeOfExpressionSyntax node);
    public virtual SyntaxNode VisitSizeOfExpression(SizeOfExpressionSyntax node);
    public virtual SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node);
    public virtual SyntaxNode VisitElementAccessExpression(ElementAccessExpressionSyntax node);
    public virtual SyntaxNode VisitArgumentList(ArgumentListSyntax node);
    public virtual SyntaxNode VisitBracketedArgumentList(BracketedArgumentListSyntax node);
    public virtual SyntaxNode VisitArgument(ArgumentSyntax node);
    public virtual SyntaxNode VisitNameColon(NameColonSyntax node);
    public virtual SyntaxNode VisitCastExpression(CastExpressionSyntax node);
    public virtual SyntaxNode VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node);
    public virtual SyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node);
    public virtual SyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node);
    public virtual SyntaxNode VisitInitializerExpression(InitializerExpressionSyntax node);
    public virtual SyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node);
    public virtual SyntaxNode VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node);
    public virtual SyntaxNode VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node);
    public virtual SyntaxNode VisitArrayCreationExpression(ArrayCreationExpressionSyntax node);
    public virtual SyntaxNode VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node);
    public virtual SyntaxNode VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node);
    public virtual SyntaxNode VisitQueryExpression(QueryExpressionSyntax node);
    public virtual SyntaxNode VisitQueryBody(QueryBodySyntax node);
    public virtual SyntaxNode VisitFromClause(FromClauseSyntax node);
    public virtual SyntaxNode VisitLetClause(LetClauseSyntax node);
    public virtual SyntaxNode VisitJoinClause(JoinClauseSyntax node);
    public virtual SyntaxNode VisitJoinIntoClause(JoinIntoClauseSyntax node);
    public virtual SyntaxNode VisitWhereClause(WhereClauseSyntax node);
    public virtual SyntaxNode VisitOrderByClause(OrderByClauseSyntax node);
    public virtual SyntaxNode VisitOrdering(OrderingSyntax node);
    public virtual SyntaxNode VisitSelectClause(SelectClauseSyntax node);
    public virtual SyntaxNode VisitGroupClause(GroupClauseSyntax node);
    public virtual SyntaxNode VisitQueryContinuation(QueryContinuationSyntax node);
    public virtual SyntaxNode VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node);
    public virtual SyntaxNode VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node);
    public virtual SyntaxNode VisitInterpolatedStringText(InterpolatedStringTextSyntax node);
    public virtual SyntaxNode VisitInterpolation(InterpolationSyntax node);
    public virtual SyntaxNode VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node);
    public virtual SyntaxNode VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node);
    public virtual SyntaxNode VisitGlobalStatement(GlobalStatementSyntax node);
    public virtual SyntaxNode VisitBlock(BlockSyntax node);
    public virtual SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node);
    public virtual SyntaxNode VisitVariableDeclaration(VariableDeclarationSyntax node);
    public virtual SyntaxNode VisitVariableDeclarator(VariableDeclaratorSyntax node);
    public virtual SyntaxNode VisitEqualsValueClause(EqualsValueClauseSyntax node);
    public virtual SyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node);
    public virtual SyntaxNode VisitEmptyStatement(EmptyStatementSyntax node);
    public virtual SyntaxNode VisitLabeledStatement(LabeledStatementSyntax node);
    public virtual SyntaxNode VisitGotoStatement(GotoStatementSyntax node);
    public virtual SyntaxNode VisitBreakStatement(BreakStatementSyntax node);
    public virtual SyntaxNode VisitContinueStatement(ContinueStatementSyntax node);
    public virtual SyntaxNode VisitReturnStatement(ReturnStatementSyntax node);
    public virtual SyntaxNode VisitThrowStatement(ThrowStatementSyntax node);
    public virtual SyntaxNode VisitYieldStatement(YieldStatementSyntax node);
    public virtual SyntaxNode VisitWhileStatement(WhileStatementSyntax node);
    public virtual SyntaxNode VisitDoStatement(DoStatementSyntax node);
    public virtual SyntaxNode VisitForStatement(ForStatementSyntax node);
    public virtual SyntaxNode VisitForEachStatement(ForEachStatementSyntax node);
    public virtual SyntaxNode VisitUsingStatement(UsingStatementSyntax node);
    public virtual SyntaxNode VisitFixedStatement(FixedStatementSyntax node);
    public virtual SyntaxNode VisitCheckedStatement(CheckedStatementSyntax node);
    public virtual SyntaxNode VisitUnsafeStatement(UnsafeStatementSyntax node);
    public virtual SyntaxNode VisitLockStatement(LockStatementSyntax node);
    public virtual SyntaxNode VisitIfStatement(IfStatementSyntax node);
    public virtual SyntaxNode VisitElseClause(ElseClauseSyntax node);
    public virtual SyntaxNode VisitSwitchStatement(SwitchStatementSyntax node);
    public virtual SyntaxNode VisitSwitchSection(SwitchSectionSyntax node);
    public virtual SyntaxNode VisitCaseSwitchLabel(CaseSwitchLabelSyntax node);
    public virtual SyntaxNode VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node);
    public virtual SyntaxNode VisitTryStatement(TryStatementSyntax node);
    public virtual SyntaxNode VisitCatchClause(CatchClauseSyntax node);
    public virtual SyntaxNode VisitCatchDeclaration(CatchDeclarationSyntax node);
    public virtual SyntaxNode VisitCatchFilterClause(CatchFilterClauseSyntax node);
    public virtual SyntaxNode VisitFinallyClause(FinallyClauseSyntax node);
    public virtual SyntaxNode VisitCompilationUnit(CompilationUnitSyntax node);
    public virtual SyntaxNode VisitExternAliasDirective(ExternAliasDirectiveSyntax node);
    public virtual SyntaxNode VisitUsingDirective(UsingDirectiveSyntax node);
    public virtual SyntaxNode VisitNamespaceDeclaration(NamespaceDeclarationSyntax node);
    public virtual SyntaxNode VisitAttributeList(AttributeListSyntax node);
    public virtual SyntaxNode VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node);
    public virtual SyntaxNode VisitAttribute(AttributeSyntax node);
    public virtual SyntaxNode VisitAttributeArgumentList(AttributeArgumentListSyntax node);
    public virtual SyntaxNode VisitAttributeArgument(AttributeArgumentSyntax node);
    public virtual SyntaxNode VisitNameEquals(NameEqualsSyntax node);
    public virtual SyntaxNode VisitTypeParameterList(TypeParameterListSyntax node);
    public virtual SyntaxNode VisitTypeParameter(TypeParameterSyntax node);
    public virtual SyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node);
    public virtual SyntaxNode VisitStructDeclaration(StructDeclarationSyntax node);
    public virtual SyntaxNode VisitInterfaceDeclaration(InterfaceDeclarationSyntax node);
    public virtual SyntaxNode VisitEnumDeclaration(EnumDeclarationSyntax node);
    public virtual SyntaxNode VisitDelegateDeclaration(DelegateDeclarationSyntax node);
    public virtual SyntaxNode VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node);
    public virtual SyntaxNode VisitBaseList(BaseListSyntax node);
    public virtual SyntaxNode VisitSimpleBaseType(SimpleBaseTypeSyntax node);
    public virtual SyntaxNode VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node);
    public virtual SyntaxNode VisitConstructorConstraint(ConstructorConstraintSyntax node);
    public virtual SyntaxNode VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node);
    public virtual SyntaxNode VisitTypeConstraint(TypeConstraintSyntax node);
    public virtual SyntaxNode VisitFieldDeclaration(FieldDeclarationSyntax node);
    public virtual SyntaxNode VisitEventFieldDeclaration(EventFieldDeclarationSyntax node);
    public virtual SyntaxNode VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node);
    public virtual SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node);
    public virtual SyntaxNode VisitOperatorDeclaration(OperatorDeclarationSyntax node);
    public virtual SyntaxNode VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node);
    public virtual SyntaxNode VisitConstructorDeclaration(ConstructorDeclarationSyntax node);
    public virtual SyntaxNode VisitConstructorInitializer(ConstructorInitializerSyntax node);
    public virtual SyntaxNode VisitDestructorDeclaration(DestructorDeclarationSyntax node);
    public virtual SyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node);
    public virtual SyntaxNode VisitArrowExpressionClause(ArrowExpressionClauseSyntax node);
    public virtual SyntaxNode VisitEventDeclaration(EventDeclarationSyntax node);
    public virtual SyntaxNode VisitIndexerDeclaration(IndexerDeclarationSyntax node);
    public virtual SyntaxNode VisitAccessorList(AccessorListSyntax node);
    public virtual SyntaxNode VisitAccessorDeclaration(AccessorDeclarationSyntax node);
    public virtual SyntaxNode VisitParameterList(ParameterListSyntax node);
    public virtual SyntaxNode VisitBracketedParameterList(BracketedParameterListSyntax node);
    public virtual SyntaxNode VisitParameter(ParameterSyntax node);
    public virtual SyntaxNode VisitIncompleteMember(IncompleteMemberSyntax node);
    public virtual SyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node);
    public virtual SyntaxNode VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node);
    public virtual SyntaxNode VisitTypeCref(TypeCrefSyntax node);
    public virtual SyntaxNode VisitQualifiedCref(QualifiedCrefSyntax node);
    public virtual SyntaxNode VisitNameMemberCref(NameMemberCrefSyntax node);
    public virtual SyntaxNode VisitIndexerMemberCref(IndexerMemberCrefSyntax node);
    public virtual SyntaxNode VisitOperatorMemberCref(OperatorMemberCrefSyntax node);
    public virtual SyntaxNode VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node);
    public virtual SyntaxNode VisitCrefParameterList(CrefParameterListSyntax node);
    public virtual SyntaxNode VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node);
    public virtual SyntaxNode VisitCrefParameter(CrefParameterSyntax node);
    public virtual SyntaxNode VisitXmlElement(XmlElementSyntax node);
    public virtual SyntaxNode VisitXmlElementStartTag(XmlElementStartTagSyntax node);
    public virtual SyntaxNode VisitXmlElementEndTag(XmlElementEndTagSyntax node);
    public virtual SyntaxNode VisitXmlEmptyElement(XmlEmptyElementSyntax node);
    public virtual SyntaxNode VisitXmlName(XmlNameSyntax node);
    public virtual SyntaxNode VisitXmlPrefix(XmlPrefixSyntax node);
    public virtual SyntaxNode VisitXmlTextAttribute(XmlTextAttributeSyntax node);
    public virtual SyntaxNode VisitXmlCrefAttribute(XmlCrefAttributeSyntax node);
    public virtual SyntaxNode VisitXmlNameAttribute(XmlNameAttributeSyntax node);
    public virtual SyntaxNode VisitXmlText(XmlTextSyntax node);
    public virtual SyntaxNode VisitXmlCDataSection(XmlCDataSectionSyntax node);
    public virtual SyntaxNode VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node);
    public virtual SyntaxNode VisitXmlComment(XmlCommentSyntax node);
    public virtual SyntaxNode VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node);
}
public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree : SyntaxTree {
    internal static SyntaxTree Dummy;
    private bool _hasDirectives;
    private DirectiveStack _directives;
    private ImmutableArray`1<int> _preprocessorStateChangePositions;
    private ImmutableArray`1<DirectiveStack> _preprocessorStates;
    private CSharpLineDirectiveMap _lazyLineDirectiveMap;
    private CSharpPragmaWarningStateMap _lazyPragmaWarningStateMap;
    public CSharpParseOptions Options { get; }
    internal bool HasReferenceDirectives { get; }
    internal bool HasReferenceOrLoadDirectives { get; }
    internal bool SupportsLocations { get; }
    protected ParseOptions OptionsCore { get; }
    private static CSharpSyntaxTree();
    public abstract virtual CSharpParseOptions get_Options();
    protected T CloneNodeAsRoot(T node);
    public abstract virtual CSharpSyntaxNode GetRoot(CancellationToken cancellationToken);
    public abstract virtual bool TryGetRoot(CSharpSyntaxNode& root);
    public virtual Task`1<CSharpSyntaxNode> GetRootAsync(CancellationToken cancellationToken);
    public CompilationUnitSyntax GetCompilationUnitRoot(CancellationToken cancellationToken);
    public virtual bool IsEquivalentTo(SyntaxTree tree, bool topLevel);
    internal bool get_HasReferenceDirectives();
    internal bool get_HasReferenceOrLoadDirectives();
    internal virtual bool get_SupportsLocations();
    internal void SetDirectiveStack(DirectiveStack directives);
    private DirectiveStack GetDirectives();
    internal bool IsAnyPreprocessorSymbolDefined(ImmutableArray`1<string> conditionalSymbols);
    internal bool IsPreprocessorSymbolDefined(string symbolName);
    private bool IsPreprocessorSymbolDefined(DirectiveStack directives, string symbolName);
    internal bool IsPreprocessorSymbolDefined(string symbolName, int position);
    private void BuildPreprocessorStateChangeMap();
    public static SyntaxTree Create(CSharpSyntaxNode root, CSharpParseOptions options, string path, Encoding encoding);
    internal static SyntaxTree CreateForDebugger(CSharpSyntaxNode root, SourceText text);
    internal static SyntaxTree CreateWithoutClone(CSharpSyntaxNode root);
    public static SyntaxTree ParseText(string text, CSharpParseOptions options, string path, Encoding encoding, CancellationToken cancellationToken);
    public static SyntaxTree ParseText(SourceText text, CSharpParseOptions options, string path, CancellationToken cancellationToken);
    public virtual SyntaxTree WithChangedText(SourceText newText);
    private SyntaxTree WithChanges(SourceText newText, IReadOnlyList`1<TextChangeRange> changes);
    public virtual IList`1<TextSpan> GetChangedSpans(SyntaxTree oldTree);
    public virtual IList`1<TextChange> GetChanges(SyntaxTree oldTree);
    public virtual FileLinePositionSpan GetLineSpan(TextSpan span, CancellationToken cancellationToken);
    public virtual FileLinePositionSpan GetMappedLineSpan(TextSpan span, CancellationToken cancellationToken);
    public virtual LineVisibility GetLineVisibility(int position, CancellationToken cancellationToken);
    internal virtual FileLinePositionSpan GetMappedLineSpanAndVisibility(TextSpan span, Boolean& isHiddenPosition);
    public virtual bool HasHiddenRegions();
    internal ReportDiagnostic GetPragmaDirectiveWarningState(string id, int position);
    private LinePosition GetLinePosition(int position);
    public virtual Location GetLocation(TextSpan span);
    public virtual IEnumerable`1<Diagnostic> GetDiagnostics(SyntaxNode node);
    private IEnumerable`1<Diagnostic> GetDiagnostics(GreenNode greenNode, int position);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree/<EnumerateDiagnostics>d__47")]
private IEnumerable`1<Diagnostic> EnumerateDiagnostics(GreenNode node, int position);
    public virtual IEnumerable`1<Diagnostic> GetDiagnostics(SyntaxToken token);
    public virtual IEnumerable`1<Diagnostic> GetDiagnostics(SyntaxTrivia trivia);
    public virtual IEnumerable`1<Diagnostic> GetDiagnostics(SyntaxNodeOrToken nodeOrToken);
    public virtual IEnumerable`1<Diagnostic> GetDiagnostics(CancellationToken cancellationToken);
    protected virtual SyntaxNode GetRootCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree/<GetRootAsyncCore>d__53")]
protected virtual Task`1<SyntaxNode> GetRootAsyncCore(CancellationToken cancellationToken);
    protected virtual bool TryGetRootCore(SyntaxNode& root);
    protected virtual ParseOptions get_OptionsCore();
}
public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor : object {
    public virtual void Visit(SyntaxNode node);
    public virtual void DefaultVisit(SyntaxNode node);
    public virtual void VisitIdentifierName(IdentifierNameSyntax node);
    public virtual void VisitQualifiedName(QualifiedNameSyntax node);
    public virtual void VisitGenericName(GenericNameSyntax node);
    public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node);
    public virtual void VisitAliasQualifiedName(AliasQualifiedNameSyntax node);
    public virtual void VisitPredefinedType(PredefinedTypeSyntax node);
    public virtual void VisitArrayType(ArrayTypeSyntax node);
    public virtual void VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node);
    public virtual void VisitPointerType(PointerTypeSyntax node);
    public virtual void VisitNullableType(NullableTypeSyntax node);
    public virtual void VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node);
    public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node);
    public virtual void VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node);
    public virtual void VisitAwaitExpression(AwaitExpressionSyntax node);
    public virtual void VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node);
    public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node);
    public virtual void VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node);
    public virtual void VisitMemberBindingExpression(MemberBindingExpressionSyntax node);
    public virtual void VisitElementBindingExpression(ElementBindingExpressionSyntax node);
    public virtual void VisitImplicitElementAccess(ImplicitElementAccessSyntax node);
    public virtual void VisitBinaryExpression(BinaryExpressionSyntax node);
    public virtual void VisitAssignmentExpression(AssignmentExpressionSyntax node);
    public virtual void VisitConditionalExpression(ConditionalExpressionSyntax node);
    public virtual void VisitThisExpression(ThisExpressionSyntax node);
    public virtual void VisitBaseExpression(BaseExpressionSyntax node);
    public virtual void VisitLiteralExpression(LiteralExpressionSyntax node);
    public virtual void VisitMakeRefExpression(MakeRefExpressionSyntax node);
    public virtual void VisitRefTypeExpression(RefTypeExpressionSyntax node);
    public virtual void VisitRefValueExpression(RefValueExpressionSyntax node);
    public virtual void VisitCheckedExpression(CheckedExpressionSyntax node);
    public virtual void VisitDefaultExpression(DefaultExpressionSyntax node);
    public virtual void VisitTypeOfExpression(TypeOfExpressionSyntax node);
    public virtual void VisitSizeOfExpression(SizeOfExpressionSyntax node);
    public virtual void VisitInvocationExpression(InvocationExpressionSyntax node);
    public virtual void VisitElementAccessExpression(ElementAccessExpressionSyntax node);
    public virtual void VisitArgumentList(ArgumentListSyntax node);
    public virtual void VisitBracketedArgumentList(BracketedArgumentListSyntax node);
    public virtual void VisitArgument(ArgumentSyntax node);
    public virtual void VisitNameColon(NameColonSyntax node);
    public virtual void VisitCastExpression(CastExpressionSyntax node);
    public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node);
    public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node);
    public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node);
    public virtual void VisitInitializerExpression(InitializerExpressionSyntax node);
    public virtual void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node);
    public virtual void VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node);
    public virtual void VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node);
    public virtual void VisitArrayCreationExpression(ArrayCreationExpressionSyntax node);
    public virtual void VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node);
    public virtual void VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node);
    public virtual void VisitQueryExpression(QueryExpressionSyntax node);
    public virtual void VisitQueryBody(QueryBodySyntax node);
    public virtual void VisitFromClause(FromClauseSyntax node);
    public virtual void VisitLetClause(LetClauseSyntax node);
    public virtual void VisitJoinClause(JoinClauseSyntax node);
    public virtual void VisitJoinIntoClause(JoinIntoClauseSyntax node);
    public virtual void VisitWhereClause(WhereClauseSyntax node);
    public virtual void VisitOrderByClause(OrderByClauseSyntax node);
    public virtual void VisitOrdering(OrderingSyntax node);
    public virtual void VisitSelectClause(SelectClauseSyntax node);
    public virtual void VisitGroupClause(GroupClauseSyntax node);
    public virtual void VisitQueryContinuation(QueryContinuationSyntax node);
    public virtual void VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node);
    public virtual void VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node);
    public virtual void VisitInterpolatedStringText(InterpolatedStringTextSyntax node);
    public virtual void VisitInterpolation(InterpolationSyntax node);
    public virtual void VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node);
    public virtual void VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node);
    public virtual void VisitGlobalStatement(GlobalStatementSyntax node);
    public virtual void VisitBlock(BlockSyntax node);
    public virtual void VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node);
    public virtual void VisitVariableDeclaration(VariableDeclarationSyntax node);
    public virtual void VisitVariableDeclarator(VariableDeclaratorSyntax node);
    public virtual void VisitEqualsValueClause(EqualsValueClauseSyntax node);
    public virtual void VisitExpressionStatement(ExpressionStatementSyntax node);
    public virtual void VisitEmptyStatement(EmptyStatementSyntax node);
    public virtual void VisitLabeledStatement(LabeledStatementSyntax node);
    public virtual void VisitGotoStatement(GotoStatementSyntax node);
    public virtual void VisitBreakStatement(BreakStatementSyntax node);
    public virtual void VisitContinueStatement(ContinueStatementSyntax node);
    public virtual void VisitReturnStatement(ReturnStatementSyntax node);
    public virtual void VisitThrowStatement(ThrowStatementSyntax node);
    public virtual void VisitYieldStatement(YieldStatementSyntax node);
    public virtual void VisitWhileStatement(WhileStatementSyntax node);
    public virtual void VisitDoStatement(DoStatementSyntax node);
    public virtual void VisitForStatement(ForStatementSyntax node);
    public virtual void VisitForEachStatement(ForEachStatementSyntax node);
    public virtual void VisitUsingStatement(UsingStatementSyntax node);
    public virtual void VisitFixedStatement(FixedStatementSyntax node);
    public virtual void VisitCheckedStatement(CheckedStatementSyntax node);
    public virtual void VisitUnsafeStatement(UnsafeStatementSyntax node);
    public virtual void VisitLockStatement(LockStatementSyntax node);
    public virtual void VisitIfStatement(IfStatementSyntax node);
    public virtual void VisitElseClause(ElseClauseSyntax node);
    public virtual void VisitSwitchStatement(SwitchStatementSyntax node);
    public virtual void VisitSwitchSection(SwitchSectionSyntax node);
    public virtual void VisitCaseSwitchLabel(CaseSwitchLabelSyntax node);
    public virtual void VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node);
    public virtual void VisitTryStatement(TryStatementSyntax node);
    public virtual void VisitCatchClause(CatchClauseSyntax node);
    public virtual void VisitCatchDeclaration(CatchDeclarationSyntax node);
    public virtual void VisitCatchFilterClause(CatchFilterClauseSyntax node);
    public virtual void VisitFinallyClause(FinallyClauseSyntax node);
    public virtual void VisitCompilationUnit(CompilationUnitSyntax node);
    public virtual void VisitExternAliasDirective(ExternAliasDirectiveSyntax node);
    public virtual void VisitUsingDirective(UsingDirectiveSyntax node);
    public virtual void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node);
    public virtual void VisitAttributeList(AttributeListSyntax node);
    public virtual void VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node);
    public virtual void VisitAttribute(AttributeSyntax node);
    public virtual void VisitAttributeArgumentList(AttributeArgumentListSyntax node);
    public virtual void VisitAttributeArgument(AttributeArgumentSyntax node);
    public virtual void VisitNameEquals(NameEqualsSyntax node);
    public virtual void VisitTypeParameterList(TypeParameterListSyntax node);
    public virtual void VisitTypeParameter(TypeParameterSyntax node);
    public virtual void VisitClassDeclaration(ClassDeclarationSyntax node);
    public virtual void VisitStructDeclaration(StructDeclarationSyntax node);
    public virtual void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node);
    public virtual void VisitEnumDeclaration(EnumDeclarationSyntax node);
    public virtual void VisitDelegateDeclaration(DelegateDeclarationSyntax node);
    public virtual void VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node);
    public virtual void VisitBaseList(BaseListSyntax node);
    public virtual void VisitSimpleBaseType(SimpleBaseTypeSyntax node);
    public virtual void VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node);
    public virtual void VisitConstructorConstraint(ConstructorConstraintSyntax node);
    public virtual void VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node);
    public virtual void VisitTypeConstraint(TypeConstraintSyntax node);
    public virtual void VisitFieldDeclaration(FieldDeclarationSyntax node);
    public virtual void VisitEventFieldDeclaration(EventFieldDeclarationSyntax node);
    public virtual void VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node);
    public virtual void VisitMethodDeclaration(MethodDeclarationSyntax node);
    public virtual void VisitOperatorDeclaration(OperatorDeclarationSyntax node);
    public virtual void VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node);
    public virtual void VisitConstructorDeclaration(ConstructorDeclarationSyntax node);
    public virtual void VisitConstructorInitializer(ConstructorInitializerSyntax node);
    public virtual void VisitDestructorDeclaration(DestructorDeclarationSyntax node);
    public virtual void VisitPropertyDeclaration(PropertyDeclarationSyntax node);
    public virtual void VisitArrowExpressionClause(ArrowExpressionClauseSyntax node);
    public virtual void VisitEventDeclaration(EventDeclarationSyntax node);
    public virtual void VisitIndexerDeclaration(IndexerDeclarationSyntax node);
    public virtual void VisitAccessorList(AccessorListSyntax node);
    public virtual void VisitAccessorDeclaration(AccessorDeclarationSyntax node);
    public virtual void VisitParameterList(ParameterListSyntax node);
    public virtual void VisitBracketedParameterList(BracketedParameterListSyntax node);
    public virtual void VisitParameter(ParameterSyntax node);
    public virtual void VisitIncompleteMember(IncompleteMemberSyntax node);
    public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node);
    public virtual void VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node);
    public virtual void VisitTypeCref(TypeCrefSyntax node);
    public virtual void VisitQualifiedCref(QualifiedCrefSyntax node);
    public virtual void VisitNameMemberCref(NameMemberCrefSyntax node);
    public virtual void VisitIndexerMemberCref(IndexerMemberCrefSyntax node);
    public virtual void VisitOperatorMemberCref(OperatorMemberCrefSyntax node);
    public virtual void VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node);
    public virtual void VisitCrefParameterList(CrefParameterListSyntax node);
    public virtual void VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node);
    public virtual void VisitCrefParameter(CrefParameterSyntax node);
    public virtual void VisitXmlElement(XmlElementSyntax node);
    public virtual void VisitXmlElementStartTag(XmlElementStartTagSyntax node);
    public virtual void VisitXmlElementEndTag(XmlElementEndTagSyntax node);
    public virtual void VisitXmlEmptyElement(XmlEmptyElementSyntax node);
    public virtual void VisitXmlName(XmlNameSyntax node);
    public virtual void VisitXmlPrefix(XmlPrefixSyntax node);
    public virtual void VisitXmlTextAttribute(XmlTextAttributeSyntax node);
    public virtual void VisitXmlCrefAttribute(XmlCrefAttributeSyntax node);
    public virtual void VisitXmlNameAttribute(XmlNameAttributeSyntax node);
    public virtual void VisitXmlText(XmlTextSyntax node);
    public virtual void VisitXmlCDataSection(XmlCDataSectionSyntax node);
    public virtual void VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node);
    public virtual void VisitXmlComment(XmlCommentSyntax node);
    public virtual void VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node);
    public virtual void VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node);
    public virtual void VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node);
    public virtual void VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node);
    public virtual void VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node);
    public virtual void VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node);
    public virtual void VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node);
    public virtual void VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node);
    public virtual void VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node);
    public virtual void VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node);
    public virtual void VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node);
    public virtual void VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node);
    public virtual void VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node);
    public virtual void VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node);
    public virtual void VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node);
    public virtual void VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node);
    public virtual void VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node);
}
public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1 : object {
    public virtual TResult Visit(SyntaxNode node);
    public virtual TResult DefaultVisit(SyntaxNode node);
    public virtual TResult VisitIdentifierName(IdentifierNameSyntax node);
    public virtual TResult VisitQualifiedName(QualifiedNameSyntax node);
    public virtual TResult VisitGenericName(GenericNameSyntax node);
    public virtual TResult VisitTypeArgumentList(TypeArgumentListSyntax node);
    public virtual TResult VisitAliasQualifiedName(AliasQualifiedNameSyntax node);
    public virtual TResult VisitPredefinedType(PredefinedTypeSyntax node);
    public virtual TResult VisitArrayType(ArrayTypeSyntax node);
    public virtual TResult VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node);
    public virtual TResult VisitPointerType(PointerTypeSyntax node);
    public virtual TResult VisitNullableType(NullableTypeSyntax node);
    public virtual TResult VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node);
    public virtual TResult VisitParenthesizedExpression(ParenthesizedExpressionSyntax node);
    public virtual TResult VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node);
    public virtual TResult VisitAwaitExpression(AwaitExpressionSyntax node);
    public virtual TResult VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node);
    public virtual TResult VisitMemberAccessExpression(MemberAccessExpressionSyntax node);
    public virtual TResult VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node);
    public virtual TResult VisitMemberBindingExpression(MemberBindingExpressionSyntax node);
    public virtual TResult VisitElementBindingExpression(ElementBindingExpressionSyntax node);
    public virtual TResult VisitImplicitElementAccess(ImplicitElementAccessSyntax node);
    public virtual TResult VisitBinaryExpression(BinaryExpressionSyntax node);
    public virtual TResult VisitAssignmentExpression(AssignmentExpressionSyntax node);
    public virtual TResult VisitConditionalExpression(ConditionalExpressionSyntax node);
    public virtual TResult VisitThisExpression(ThisExpressionSyntax node);
    public virtual TResult VisitBaseExpression(BaseExpressionSyntax node);
    public virtual TResult VisitLiteralExpression(LiteralExpressionSyntax node);
    public virtual TResult VisitMakeRefExpression(MakeRefExpressionSyntax node);
    public virtual TResult VisitRefTypeExpression(RefTypeExpressionSyntax node);
    public virtual TResult VisitRefValueExpression(RefValueExpressionSyntax node);
    public virtual TResult VisitCheckedExpression(CheckedExpressionSyntax node);
    public virtual TResult VisitDefaultExpression(DefaultExpressionSyntax node);
    public virtual TResult VisitTypeOfExpression(TypeOfExpressionSyntax node);
    public virtual TResult VisitSizeOfExpression(SizeOfExpressionSyntax node);
    public virtual TResult VisitInvocationExpression(InvocationExpressionSyntax node);
    public virtual TResult VisitElementAccessExpression(ElementAccessExpressionSyntax node);
    public virtual TResult VisitArgumentList(ArgumentListSyntax node);
    public virtual TResult VisitBracketedArgumentList(BracketedArgumentListSyntax node);
    public virtual TResult VisitArgument(ArgumentSyntax node);
    public virtual TResult VisitNameColon(NameColonSyntax node);
    public virtual TResult VisitCastExpression(CastExpressionSyntax node);
    public virtual TResult VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node);
    public virtual TResult VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node);
    public virtual TResult VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node);
    public virtual TResult VisitInitializerExpression(InitializerExpressionSyntax node);
    public virtual TResult VisitObjectCreationExpression(ObjectCreationExpressionSyntax node);
    public virtual TResult VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node);
    public virtual TResult VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node);
    public virtual TResult VisitArrayCreationExpression(ArrayCreationExpressionSyntax node);
    public virtual TResult VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node);
    public virtual TResult VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node);
    public virtual TResult VisitQueryExpression(QueryExpressionSyntax node);
    public virtual TResult VisitQueryBody(QueryBodySyntax node);
    public virtual TResult VisitFromClause(FromClauseSyntax node);
    public virtual TResult VisitLetClause(LetClauseSyntax node);
    public virtual TResult VisitJoinClause(JoinClauseSyntax node);
    public virtual TResult VisitJoinIntoClause(JoinIntoClauseSyntax node);
    public virtual TResult VisitWhereClause(WhereClauseSyntax node);
    public virtual TResult VisitOrderByClause(OrderByClauseSyntax node);
    public virtual TResult VisitOrdering(OrderingSyntax node);
    public virtual TResult VisitSelectClause(SelectClauseSyntax node);
    public virtual TResult VisitGroupClause(GroupClauseSyntax node);
    public virtual TResult VisitQueryContinuation(QueryContinuationSyntax node);
    public virtual TResult VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node);
    public virtual TResult VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node);
    public virtual TResult VisitInterpolatedStringText(InterpolatedStringTextSyntax node);
    public virtual TResult VisitInterpolation(InterpolationSyntax node);
    public virtual TResult VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node);
    public virtual TResult VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node);
    public virtual TResult VisitGlobalStatement(GlobalStatementSyntax node);
    public virtual TResult VisitBlock(BlockSyntax node);
    public virtual TResult VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node);
    public virtual TResult VisitVariableDeclaration(VariableDeclarationSyntax node);
    public virtual TResult VisitVariableDeclarator(VariableDeclaratorSyntax node);
    public virtual TResult VisitEqualsValueClause(EqualsValueClauseSyntax node);
    public virtual TResult VisitExpressionStatement(ExpressionStatementSyntax node);
    public virtual TResult VisitEmptyStatement(EmptyStatementSyntax node);
    public virtual TResult VisitLabeledStatement(LabeledStatementSyntax node);
    public virtual TResult VisitGotoStatement(GotoStatementSyntax node);
    public virtual TResult VisitBreakStatement(BreakStatementSyntax node);
    public virtual TResult VisitContinueStatement(ContinueStatementSyntax node);
    public virtual TResult VisitReturnStatement(ReturnStatementSyntax node);
    public virtual TResult VisitThrowStatement(ThrowStatementSyntax node);
    public virtual TResult VisitYieldStatement(YieldStatementSyntax node);
    public virtual TResult VisitWhileStatement(WhileStatementSyntax node);
    public virtual TResult VisitDoStatement(DoStatementSyntax node);
    public virtual TResult VisitForStatement(ForStatementSyntax node);
    public virtual TResult VisitForEachStatement(ForEachStatementSyntax node);
    public virtual TResult VisitUsingStatement(UsingStatementSyntax node);
    public virtual TResult VisitFixedStatement(FixedStatementSyntax node);
    public virtual TResult VisitCheckedStatement(CheckedStatementSyntax node);
    public virtual TResult VisitUnsafeStatement(UnsafeStatementSyntax node);
    public virtual TResult VisitLockStatement(LockStatementSyntax node);
    public virtual TResult VisitIfStatement(IfStatementSyntax node);
    public virtual TResult VisitElseClause(ElseClauseSyntax node);
    public virtual TResult VisitSwitchStatement(SwitchStatementSyntax node);
    public virtual TResult VisitSwitchSection(SwitchSectionSyntax node);
    public virtual TResult VisitCaseSwitchLabel(CaseSwitchLabelSyntax node);
    public virtual TResult VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node);
    public virtual TResult VisitTryStatement(TryStatementSyntax node);
    public virtual TResult VisitCatchClause(CatchClauseSyntax node);
    public virtual TResult VisitCatchDeclaration(CatchDeclarationSyntax node);
    public virtual TResult VisitCatchFilterClause(CatchFilterClauseSyntax node);
    public virtual TResult VisitFinallyClause(FinallyClauseSyntax node);
    public virtual TResult VisitCompilationUnit(CompilationUnitSyntax node);
    public virtual TResult VisitExternAliasDirective(ExternAliasDirectiveSyntax node);
    public virtual TResult VisitUsingDirective(UsingDirectiveSyntax node);
    public virtual TResult VisitNamespaceDeclaration(NamespaceDeclarationSyntax node);
    public virtual TResult VisitAttributeList(AttributeListSyntax node);
    public virtual TResult VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node);
    public virtual TResult VisitAttribute(AttributeSyntax node);
    public virtual TResult VisitAttributeArgumentList(AttributeArgumentListSyntax node);
    public virtual TResult VisitAttributeArgument(AttributeArgumentSyntax node);
    public virtual TResult VisitNameEquals(NameEqualsSyntax node);
    public virtual TResult VisitTypeParameterList(TypeParameterListSyntax node);
    public virtual TResult VisitTypeParameter(TypeParameterSyntax node);
    public virtual TResult VisitClassDeclaration(ClassDeclarationSyntax node);
    public virtual TResult VisitStructDeclaration(StructDeclarationSyntax node);
    public virtual TResult VisitInterfaceDeclaration(InterfaceDeclarationSyntax node);
    public virtual TResult VisitEnumDeclaration(EnumDeclarationSyntax node);
    public virtual TResult VisitDelegateDeclaration(DelegateDeclarationSyntax node);
    public virtual TResult VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node);
    public virtual TResult VisitBaseList(BaseListSyntax node);
    public virtual TResult VisitSimpleBaseType(SimpleBaseTypeSyntax node);
    public virtual TResult VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node);
    public virtual TResult VisitConstructorConstraint(ConstructorConstraintSyntax node);
    public virtual TResult VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node);
    public virtual TResult VisitTypeConstraint(TypeConstraintSyntax node);
    public virtual TResult VisitFieldDeclaration(FieldDeclarationSyntax node);
    public virtual TResult VisitEventFieldDeclaration(EventFieldDeclarationSyntax node);
    public virtual TResult VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node);
    public virtual TResult VisitMethodDeclaration(MethodDeclarationSyntax node);
    public virtual TResult VisitOperatorDeclaration(OperatorDeclarationSyntax node);
    public virtual TResult VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node);
    public virtual TResult VisitConstructorDeclaration(ConstructorDeclarationSyntax node);
    public virtual TResult VisitConstructorInitializer(ConstructorInitializerSyntax node);
    public virtual TResult VisitDestructorDeclaration(DestructorDeclarationSyntax node);
    public virtual TResult VisitPropertyDeclaration(PropertyDeclarationSyntax node);
    public virtual TResult VisitArrowExpressionClause(ArrowExpressionClauseSyntax node);
    public virtual TResult VisitEventDeclaration(EventDeclarationSyntax node);
    public virtual TResult VisitIndexerDeclaration(IndexerDeclarationSyntax node);
    public virtual TResult VisitAccessorList(AccessorListSyntax node);
    public virtual TResult VisitAccessorDeclaration(AccessorDeclarationSyntax node);
    public virtual TResult VisitParameterList(ParameterListSyntax node);
    public virtual TResult VisitBracketedParameterList(BracketedParameterListSyntax node);
    public virtual TResult VisitParameter(ParameterSyntax node);
    public virtual TResult VisitIncompleteMember(IncompleteMemberSyntax node);
    public virtual TResult VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node);
    public virtual TResult VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node);
    public virtual TResult VisitTypeCref(TypeCrefSyntax node);
    public virtual TResult VisitQualifiedCref(QualifiedCrefSyntax node);
    public virtual TResult VisitNameMemberCref(NameMemberCrefSyntax node);
    public virtual TResult VisitIndexerMemberCref(IndexerMemberCrefSyntax node);
    public virtual TResult VisitOperatorMemberCref(OperatorMemberCrefSyntax node);
    public virtual TResult VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node);
    public virtual TResult VisitCrefParameterList(CrefParameterListSyntax node);
    public virtual TResult VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node);
    public virtual TResult VisitCrefParameter(CrefParameterSyntax node);
    public virtual TResult VisitXmlElement(XmlElementSyntax node);
    public virtual TResult VisitXmlElementStartTag(XmlElementStartTagSyntax node);
    public virtual TResult VisitXmlElementEndTag(XmlElementEndTagSyntax node);
    public virtual TResult VisitXmlEmptyElement(XmlEmptyElementSyntax node);
    public virtual TResult VisitXmlName(XmlNameSyntax node);
    public virtual TResult VisitXmlPrefix(XmlPrefixSyntax node);
    public virtual TResult VisitXmlTextAttribute(XmlTextAttributeSyntax node);
    public virtual TResult VisitXmlCrefAttribute(XmlCrefAttributeSyntax node);
    public virtual TResult VisitXmlNameAttribute(XmlNameAttributeSyntax node);
    public virtual TResult VisitXmlText(XmlTextSyntax node);
    public virtual TResult VisitXmlCDataSection(XmlCDataSectionSyntax node);
    public virtual TResult VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node);
    public virtual TResult VisitXmlComment(XmlCommentSyntax node);
    public virtual TResult VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node);
    public virtual TResult VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node);
    public virtual TResult VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node);
    public virtual TResult VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node);
    public virtual TResult VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node);
    public virtual TResult VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node);
    public virtual TResult VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node);
    public virtual TResult VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node);
    public virtual TResult VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node);
    public virtual TResult VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node);
    public virtual TResult VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node);
    public virtual TResult VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node);
    public virtual TResult VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node);
    public virtual TResult VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node);
    public virtual TResult VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node);
    public virtual TResult VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node);
    public virtual TResult VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node);
}
public abstract class Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker : CSharpSyntaxVisitor {
    [CompilerGeneratedAttribute]
private SyntaxWalkerDepth <Depth>k__BackingField;
    private int _recursionDepth;
    protected SyntaxWalkerDepth Depth { get; }
    protected CSharpSyntaxWalker(SyntaxWalkerDepth depth);
    [CompilerGeneratedAttribute]
protected SyntaxWalkerDepth get_Depth();
    public virtual void Visit(SyntaxNode node);
    public virtual void DefaultVisit(SyntaxNode node);
    public virtual void VisitToken(SyntaxToken token);
    public virtual void VisitLeadingTrivia(SyntaxToken token);
    public virtual void VisitTrailingTrivia(SyntaxToken token);
    public virtual void VisitTrivia(SyntaxTrivia trivia);
}
internal class Microsoft.CodeAnalysis.CSharp.CSharpTypeInfo : ValueType {
    internal static CSharpTypeInfo None;
    public TypeSymbol Type;
    public TypeSymbol ConvertedType;
    public Conversion ImplicitConversion;
    internal CSharpTypeInfo(TypeSymbol type, TypeSymbol convertedType, Conversion implicitConversion);
    private static CSharpTypeInfo();
    public static TypeInfo op_Implicit(CSharpTypeInfo info);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CSharpTypeInfo other);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.CSharp.DataFlowPass : AbstractFlowPass`1<LocalState> {
    protected HashSet`1<Symbol> initiallyAssignedVariables;
    private PooledHashSet`1<LocalSymbol> _usedVariables;
    private PooledHashSet`1<Symbol> _writtenVariables;
    private PooledDictionary`2<Symbol, Location> _unsafeAddressTakenVariables;
    private PooledHashSet`1<Symbol> _capturedVariables;
    private SourceAssemblySymbol _sourceAssembly;
    private PooledDictionary`2<VariableIdentifier, int> _variableSlot;
    private HashSet`1<PrefixUnaryExpressionSyntax> _unassignedVariableAddressOfSyntaxes;
    protected VariableIdentifier[] variableBySlot;
    protected int nextVariableSlot;
    private BitVector _alreadyReported;
    [CompilerGeneratedAttribute]
private MethodSymbol <currentMethodOrLambda>k__BackingField;
    private EmptyStructTypeCache _emptyStructTypeCache;
    private bool _requireOutParamsAssigned;
    protected MethodSymbol topLevelMethod;
    protected bool _convertInsufficientExecutionStackExceptionToCancelledByStackGuardException;
    private Nullable`1<LocalState> _tryState;
    protected MethodSymbol currentMethodOrLambda { get; private set; }
    internal DataFlowPass(CSharpCompilation compilation, Symbol member, BoundNode node, bool trackUnassignments, HashSet`1<PrefixUnaryExpressionSyntax> unassignedVariableAddressOfSyntaxes, bool requireOutParamsAssigned);
    internal DataFlowPass(CSharpCompilation compilation, Symbol member, BoundNode node, EmptyStructTypeCache emptyStructs, bool trackUnassignments, HashSet`1<Symbol> initiallyAssignedVariables);
    internal DataFlowPass(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion, HashSet`1<Symbol> initiallyAssignedVariables, HashSet`1<PrefixUnaryExpressionSyntax> unassignedVariableAddressOfSyntaxes, bool trackUnassignments);
    [CompilerGeneratedAttribute]
protected MethodSymbol get_currentMethodOrLambda();
    [CompilerGeneratedAttribute]
private void set_currentMethodOrLambda(MethodSymbol value);
    protected virtual void Free();
    protected virtual bool ConvertInsufficientExecutionStackExceptionToCancelledByStackGuardException();
    protected virtual ImmutableArray`1<PendingBranch<LocalState>> Scan(Boolean& badRegion);
    protected virtual ImmutableArray`1<PendingBranch<LocalState>> RemoveReturns();
    protected virtual void ReportUnassignedOutParameter(ParameterSymbol parameter, CSharpSyntaxNode node, Location location);
    public static void Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, DiagnosticBag diagnostics, bool requireOutParamsAssigned);
    protected void Analyze(Boolean& badRegion, DiagnosticBag diagnostics);
    private void CheckCaptured(Symbol variable, ParameterSymbol rangeVariableUnderlyingParameter);
    private void NoteCaptured(Symbol variable);
    protected IEnumerable`1<Symbol> GetCaptured();
    protected IEnumerable`1<Symbol> GetUnsafeAddressTaken();
    protected virtual void NoteRead(Symbol variable, ParameterSymbol rangeVariableUnderlyingParameter);
    private void NoteRead(BoundNode fieldOrEventAccess);
    protected virtual void NoteWrite(Symbol variable, BoundExpression value, bool read);
    internal static bool WriteConsideredUse(TypeSymbol type, BoundExpression value);
    private void NoteWrite(BoundExpression n, BoundExpression value, bool read);
    protected int VariableSlot(Symbol symbol, int containingSlot);
    protected int GetOrCreateSlot(Symbol symbol, int containingSlot);
    private void Normalize(LocalState& state);
    protected int MakeSlot(BoundExpression node);
    protected void CheckAssigned(Symbol symbol, CSharpSyntaxNode node);
    protected virtual void ReportUnassigned(Symbol symbol, CSharpSyntaxNode node);
    protected virtual void CheckAssigned(BoundExpression expr, FieldSymbol fieldSymbol, CSharpSyntaxNode node);
    private bool IsAssigned(BoundExpression node, Int32& unassignedSlot);
    protected virtual void ReportUnassigned(FieldSymbol fieldSymbol, int unassignedSlot, CSharpSyntaxNode node);
    protected Symbol GetNonFieldSymbol(int slot);
    private Symbol UseNonFieldSymbolUnsafely(BoundExpression expression);
    protected void Assign(BoundNode node, BoundExpression value, RefKind refKind, bool read);
    protected virtual void AssignImpl(BoundNode node, BoundExpression value, RefKind refKind, bool written, bool read);
    private bool FieldsAllSet(int containingSlot, LocalState state);
    private static TypeSymbol VariableType(Symbol s);
    protected void SetSlotState(int slot, bool assigned);
    private void SetSlotAssigned(int slot, LocalState& state);
    private void SetSlotAssigned(int slot);
    private void SetSlotUnassigned(int slot, LocalState& state);
    private void SetSlotUnassigned(int slot);
    protected virtual LocalState ReachableState();
    protected virtual LocalState AllBitsSet();
    private void EnterParameters(ImmutableArray`1<ParameterSymbol> parameters);
    protected virtual void EnterParameter(ParameterSymbol parameter);
    private void LeaveParameters(ImmutableArray`1<ParameterSymbol> parameters, CSharpSyntaxNode syntax, Location location);
    private void LeaveParameter(ParameterSymbol parameter, CSharpSyntaxNode syntax, Location location);
    protected virtual LocalState UnreachableState();
    public virtual BoundNode VisitBlock(BoundBlock node);
    public virtual BoundNode VisitSwitchStatement(BoundSwitchStatement node);
    public virtual BoundNode VisitForStatement(BoundForStatement node);
    public virtual BoundNode VisitDoStatement(BoundDoStatement node);
    public virtual BoundNode VisitWhileStatement(BoundWhileStatement node);
    public virtual BoundNode VisitForEachStatement(BoundForEachStatement node);
    public virtual BoundNode VisitIfStatement(BoundIfStatement node);
    public virtual BoundNode VisitLockStatement(BoundLockStatement node);
    public virtual BoundNode VisitUsingStatement(BoundUsingStatement node);
    public virtual BoundNode VisitFixedStatement(BoundFixedStatement node);
    public virtual BoundNode VisitSequence(BoundSequence node);
    private void DeclareVariables(ImmutableArray`1<LocalSymbol> locals);
    private void DeclareVariable(LocalSymbol symbol);
    private void ReportUnusedVariables(ImmutableArray`1<LocalSymbol> locals);
    private void ReportIfUnused(LocalSymbol symbol, bool assigned);
    public virtual BoundNode VisitLocal(BoundLocal node);
    public virtual BoundNode VisitLocalDeclaration(BoundLocalDeclaration node);
    public virtual BoundNode VisitLambda(BoundLambda node);
    public virtual BoundNode VisitThisReference(BoundThisReference node);
    public virtual BoundNode VisitParameter(BoundParameter node);
    public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node);
    public virtual BoundNode VisitIncrementOperator(BoundIncrementOperator node);
    public virtual BoundNode VisitCompoundAssignmentOperator(BoundCompoundAssignmentOperator node);
    public virtual BoundNode VisitAddressOfOperator(BoundAddressOfOperator node);
    protected virtual void WriteArgument(BoundExpression arg, RefKind refKind, MethodSymbol method);
    protected void CheckAssigned(BoundExpression expr, CSharpSyntaxNode node);
    private void MarkFieldsUsed(TypeSymbol type);
    public virtual BoundNode VisitBaseReference(BoundBaseReference node);
    protected virtual void VisitTryBlock(BoundStatement tryBlock, BoundTryStatement node, LocalState& tryState);
    protected virtual void VisitCatchBlock(BoundCatchBlock catchBlock, LocalState& finallyState);
    private void VisitCatchBlockInternal(BoundCatchBlock catchBlock, LocalState& finallyState);
    protected virtual void VisitFinallyBlock(BoundStatement finallyBlock, LocalState& unsetInFinally);
    public virtual BoundNode VisitFieldAccess(BoundFieldAccess node);
    public virtual BoundNode VisitPropertyAccess(BoundPropertyAccess node);
    public virtual BoundNode VisitEventAccess(BoundEventAccess node);
    public virtual void VisitForEachIterationVariable(BoundForEachStatement node);
    public virtual BoundNode VisitObjectInitializerMember(BoundObjectInitializerMember node);
    public virtual BoundNode VisitDynamicObjectInitializerMember(BoundDynamicObjectInitializerMember node);
    protected virtual string Dump(LocalState state);
    protected void AppendBitNames(BitVector a, StringBuilder builder);
    protected void AppendBitName(int bit, StringBuilder builder);
    protected virtual void UnionWith(LocalState& self, LocalState& other);
    protected virtual bool IntersectWith(LocalState& self, LocalState& other);
}
internal class Microsoft.CodeAnalysis.CSharp.DataFlowsInWalker : AbstractRegionDataFlowPass {
    private HashSet`1<Symbol> _dataFlowsIn;
    private DataFlowsInWalker(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion, HashSet`1<Symbol> unassignedVariables, HashSet`1<PrefixUnaryExpressionSyntax> unassignedVariableAddressOfSyntaxes);
    internal static HashSet`1<Symbol> Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion, HashSet`1<Symbol> unassignedVariables, HashSet`1<PrefixUnaryExpressionSyntax> unassignedVariableAddressOfSyntaxes, Nullable`1& succeeded);
    private HashSet`1<Symbol> Analyze(Boolean& badRegion);
    private LocalState ResetState(LocalState state);
    protected virtual void EnterRegion();
    protected virtual void NoteBranch(PendingBranch<LocalState> pending, BoundStatement gotoStmt, BoundStatement targetStmt);
    public virtual BoundNode VisitRangeVariable(BoundRangeVariable node);
    protected virtual void ReportUnassigned(Symbol symbol, CSharpSyntaxNode node);
    protected virtual void ReportUnassignedOutParameter(ParameterSymbol parameter, CSharpSyntaxNode node, Location location);
    protected virtual void ReportUnassigned(FieldSymbol fieldSymbol, int unassignedSlot, CSharpSyntaxNode node);
}
internal class Microsoft.CodeAnalysis.CSharp.DataFlowsOutWalker : AbstractRegionDataFlowPass {
    private ImmutableArray`1<ISymbol> _dataFlowsIn;
    private HashSet`1<Symbol> _dataFlowsOut;
    private DataFlowsOutWalker(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion, HashSet`1<Symbol> unassignedVariables, ImmutableArray`1<ISymbol> dataFlowsIn);
    internal static HashSet`1<Symbol> Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion, HashSet`1<Symbol> unassignedVariables, ImmutableArray`1<ISymbol> dataFlowsIn);
    private HashSet`1<Symbol> Analyze(Boolean& badRegion);
    protected virtual void EnterRegion();
    protected virtual void NoteWrite(Symbol variable, BoundExpression value, bool read);
    protected virtual void AssignImpl(BoundNode node, BoundExpression value, RefKind refKind, bool written, bool read);
    private bool FlowsOut(ParameterSymbol param);
    private ParameterSymbol Param(BoundNode node);
    public virtual BoundNode VisitQueryClause(BoundQueryClause node);
    protected virtual void ReportUnassigned(Symbol symbol, CSharpSyntaxNode node);
    protected virtual void ReportUnassignedOutParameter(ParameterSymbol parameter, CSharpSyntaxNode node, Location location);
    protected virtual void ReportUnassigned(FieldSymbol fieldSymbol, int unassignedSlot, CSharpSyntaxNode node);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Declaration : object {
    protected string name;
    public string Name { get; }
    public ImmutableArray`1<Declaration> Children { get; }
    public DeclarationKind Kind { get; }
    protected Declaration(string name);
    public string get_Name();
    public ImmutableArray`1<Declaration> get_Children();
    public abstract virtual DeclarationKind get_Kind();
    protected abstract virtual ImmutableArray`1<Declaration> GetDeclarationChildren();
}
internal enum Microsoft.CodeAnalysis.CSharp.DeclarationKind : Enum {
    public byte value__;
    public static DeclarationKind Namespace;
    public static DeclarationKind Class;
    public static DeclarationKind Interface;
    public static DeclarationKind Struct;
    public static DeclarationKind Enum;
    public static DeclarationKind Delegate;
    public static DeclarationKind Script;
    public static DeclarationKind Submission;
    public static DeclarationKind ImplicitClass;
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.DeclarationModifiers : Enum {
    public int value__;
    public static DeclarationModifiers None;
    public static DeclarationModifiers Abstract;
    public static DeclarationModifiers Sealed;
    public static DeclarationModifiers Static;
    public static DeclarationModifiers New;
    public static DeclarationModifiers Public;
    public static DeclarationModifiers Protected;
    public static DeclarationModifiers Internal;
    public static DeclarationModifiers ProtectedInternal;
    public static DeclarationModifiers Private;
    public static DeclarationModifiers ReadOnly;
    public static DeclarationModifiers Const;
    public static DeclarationModifiers Volatile;
    public static DeclarationModifiers Extern;
    public static DeclarationModifiers Partial;
    public static DeclarationModifiers Unsafe;
    public static DeclarationModifiers Fixed;
    public static DeclarationModifiers Virtual;
    public static DeclarationModifiers Override;
    public static DeclarationModifiers Indexer;
    public static DeclarationModifiers Async;
    public static DeclarationModifiers All;
    public static DeclarationModifiers Unset;
    public static DeclarationModifiers AccessibilityMask;
}
internal class Microsoft.CodeAnalysis.CSharp.DeclarationTable : object {
    public static DeclarationTable Empty;
    private ImmutableSetWithInsertionOrder`1<RootSingleNamespaceDeclaration> _allOlderRootDeclarations;
    private Lazy`1<RootSingleNamespaceDeclaration> _latestLazyRootDeclaration;
    private Cache _cache;
    private MergedNamespaceDeclaration _mergedRoot;
    private Lazy`1<ICollection`1<string>> _typeNames;
    private Lazy`1<ICollection`1<string>> _namespaceNames;
    private Lazy`1<ICollection`1<ReferenceDirective>> _referenceDirectives;
    private static Predicate`1<Declaration> s_isNamespacePredicate;
    private static Predicate`1<Declaration> s_isTypePredicate;
    public ICollection`1<string> TypeNames { get; }
    public ICollection`1<string> NamespaceNames { get; }
    public IEnumerable`1<ReferenceDirective> ReferenceDirectives { get; }
    private DeclarationTable(ImmutableSetWithInsertionOrder`1<RootSingleNamespaceDeclaration> allOlderRootDeclarations, Lazy`1<RootSingleNamespaceDeclaration> latestLazyRootDeclaration, Cache cache);
    private static DeclarationTable();
    public DeclarationTable AddRootDeclaration(Lazy`1<RootSingleNamespaceDeclaration> lazyRootDeclaration);
    public DeclarationTable RemoveRootDeclaration(Lazy`1<RootSingleNamespaceDeclaration> lazyRootDeclaration);
    public MergedNamespaceDeclaration GetMergedRoot(CSharpCompilation compilation);
    internal MergedNamespaceDeclaration CalculateMergedRoot(CSharpCompilation compilation);
    private ICollection`1<string> GetMergedTypeNames();
    private ICollection`1<string> GetMergedNamespaceNames();
    private ICollection`1<ReferenceDirective> GetMergedReferenceDirectives();
    private static ISet`1<string> GetTypeNames(Declaration declaration);
    private static ISet`1<string> GetNamespaceNames(Declaration declaration);
    private static ISet`1<string> GetNames(Declaration declaration, Predicate`1<Declaration> predicate);
    public ICollection`1<string> get_TypeNames();
    public ICollection`1<string> get_NamespaceNames();
    public IEnumerable`1<ReferenceDirective> get_ReferenceDirectives();
    public static bool ContainsName(MergedNamespaceDeclaration mergedRoot, Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.DeclarationTreeBuilder : CSharpSyntaxVisitor`1<SingleNamespaceOrTypeDeclaration> {
    private SyntaxTree _syntaxTree;
    private string _scriptClassName;
    private bool _isSubmission;
    private DeclarationTreeBuilder(SyntaxTree syntaxTree, string scriptClassName, bool isSubmission);
    public static RootSingleNamespaceDeclaration ForTree(SyntaxTree syntaxTree, string scriptClassName, bool isSubmission);
    private ImmutableArray`1<SingleNamespaceOrTypeDeclaration> VisitNamespaceChildren(CSharpSyntaxNode node, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxList`1<MemberDeclarationSyntax> internalMembers);
    private static SingleNamespaceOrTypeDeclaration CreateImplicitClass(ICollection`1<string> memberNames, SyntaxReference container, TypeDeclarationFlags declFlags);
    private RootSingleNamespaceDeclaration CreateScriptRootDeclaration(CompilationUnitSyntax compilationUnit);
    private static ImmutableArray`1<ReferenceDirective> GetReferenceDirectives(CompilationUnitSyntax compilationUnit);
    private SingleNamespaceOrTypeDeclaration CreateScriptClass(CompilationUnitSyntax parent, ImmutableArray`1<SingleTypeDeclaration> children, ICollection`1<string> memberNames, TypeDeclarationFlags declFlags);
    public virtual SingleNamespaceOrTypeDeclaration VisitCompilationUnit(CompilationUnitSyntax compilationUnit);
    public virtual SingleNamespaceOrTypeDeclaration VisitNamespaceDeclaration(NamespaceDeclarationSyntax node);
    public virtual SingleNamespaceOrTypeDeclaration VisitClassDeclaration(ClassDeclarationSyntax node);
    public virtual SingleNamespaceOrTypeDeclaration VisitStructDeclaration(StructDeclarationSyntax node);
    public virtual SingleNamespaceOrTypeDeclaration VisitInterfaceDeclaration(InterfaceDeclarationSyntax node);
    private SingleNamespaceOrTypeDeclaration VisitTypeDeclaration(TypeDeclarationSyntax node, DeclarationKind kind);
    private ImmutableArray`1<SingleTypeDeclaration> VisitTypeChildren(TypeDeclarationSyntax node);
    public virtual SingleNamespaceOrTypeDeclaration VisitDelegateDeclaration(DelegateDeclarationSyntax node);
    public virtual SingleNamespaceOrTypeDeclaration VisitEnumDeclaration(EnumDeclarationSyntax node);
    private static String[] GetEnumMemberNames(SeparatedSyntaxList`1<EnumMemberDeclarationSyntax> members, TypeDeclarationFlags& declFlags);
    private static String[] GetNonTypeMemberNames(SyntaxList`1<MemberDeclarationSyntax> members, TypeDeclarationFlags& declFlags);
    private static bool CheckMethodMemberForExtensionSyntax(CSharpSyntaxNode member);
    private static bool CheckMemberForAttributes(CSharpSyntaxNode member);
    private static void AddNonTypeMemberNames(CSharpSyntaxNode member, HashSet`1<string> set, Boolean& anyNonTypeMembers);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.DiagnosticBagExtensions : object {
    [ExtensionAttribute]
internal static CSDiagnosticInfo Add(DiagnosticBag diagnostics, ErrorCode code, Location location);
    [ExtensionAttribute]
internal static CSDiagnosticInfo Add(DiagnosticBag diagnostics, ErrorCode code, Location location, Object[] args);
    [ExtensionAttribute]
internal static CSDiagnosticInfo Add(DiagnosticBag diagnostics, ErrorCode code, Location location, ImmutableArray`1<Symbol> symbols, Object[] args);
    [ExtensionAttribute]
internal static void Add(DiagnosticBag diagnostics, DiagnosticInfo info, Location location);
    [ExtensionAttribute]
internal static bool Add(DiagnosticBag diagnostics, CSharpSyntaxNode node, HashSet`1<DiagnosticInfo> useSiteDiagnostics);
    [ExtensionAttribute]
internal static bool Add(DiagnosticBag diagnostics, Location location, HashSet`1<DiagnosticInfo> useSiteDiagnostics);
}
internal class Microsoft.CodeAnalysis.CSharp.DiagnosticInfoWithSymbols : DiagnosticInfo {
    internal ImmutableArray`1<Symbol> Symbols;
    internal DiagnosticInfoWithSymbols(ErrorCode errorCode, Object[] arguments, ImmutableArray`1<Symbol> symbols);
    internal DiagnosticInfoWithSymbols(bool isWarningAsError, ErrorCode errorCode, Object[] arguments, ImmutableArray`1<Symbol> symbols);
}
internal class Microsoft.CodeAnalysis.CSharp.DiagnosticsPass : BoundTreeWalkerWithStackGuard {
    private DiagnosticBag _diagnostics;
    private CSharpCompilation _compilation;
    private bool _inExpressionLambda;
    private bool _reportedUnsafe;
    private MethodSymbol _containingSymbol;
    private DiagnosticsPass(CSharpCompilation compilation, DiagnosticBag diagnostics, MethodSymbol containingSymbol);
    public static void IssueDiagnostics(CSharpCompilation compilation, BoundNode node, DiagnosticBag diagnostics, MethodSymbol containingSymbol);
    private void Error(ErrorCode code, BoundNode node, Object[] args);
    private void CheckUnsafeType(BoundExpression e);
    private void NoteUnsafe(BoundNode node);
    public virtual BoundNode VisitArrayCreation(BoundArrayCreation node);
    public virtual BoundNode VisitSizeOfOperator(BoundSizeOfOperator node);
    public virtual BoundNode VisitBaseReference(BoundBaseReference node);
    public virtual BoundNode VisitLockStatement(BoundLockStatement node);
    public virtual BoundNode VisitTryStatement(BoundTryStatement node);
    private static Symbol GetLocalOrParameterSymbol(BoundExpression expr);
    public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node);
    public virtual BoundNode VisitDynamicObjectInitializerMember(BoundDynamicObjectInitializerMember node);
    public virtual BoundNode VisitEventAccess(BoundEventAccess node);
    public virtual BoundNode VisitEventAssignmentOperator(BoundEventAssignmentOperator node);
    public virtual BoundNode VisitCompoundAssignmentOperator(BoundCompoundAssignmentOperator node);
    private void VisitCall(MethodSymbol method, PropertySymbol propertyAccess, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<RefKind> argumentRefKindsOpt, ImmutableArray`1<string> argumentNamesOpt, bool expanded, BoundNode node);
    public virtual BoundNode VisitRefTypeOperator(BoundRefTypeOperator node);
    public virtual BoundNode VisitRefValueOperator(BoundRefValueOperator node);
    public virtual BoundNode VisitMakeRefOperator(BoundMakeRefOperator node);
    public virtual BoundNode VisitArgListOperator(BoundArgListOperator node);
    public virtual BoundNode VisitConditionalAccess(BoundConditionalAccess node);
    public virtual BoundNode VisitObjectInitializerMember(BoundObjectInitializerMember node);
    public virtual BoundNode VisitCall(BoundCall node);
    public virtual BoundNode VisitCollectionElementInitializer(BoundCollectionElementInitializer node);
    public virtual BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node);
    public virtual BoundNode VisitIndexerAccess(BoundIndexerAccess node);
    public virtual BoundNode VisitLambda(BoundLambda node);
    public virtual BoundNode VisitBinaryOperator(BoundBinaryOperator node);
    public virtual BoundNode VisitUserDefinedConditionalLogicalOperator(BoundUserDefinedConditionalLogicalOperator node);
    private void CheckDynamic(BoundUnaryOperator node);
    private void CheckDynamic(BoundBinaryOperator node);
    public virtual BoundNode VisitUnaryOperator(BoundUnaryOperator node);
    public virtual BoundNode VisitAddressOfOperator(BoundAddressOfOperator node);
    public virtual BoundNode VisitIncrementOperator(BoundIncrementOperator node);
    public virtual BoundNode VisitPointerElementAccess(BoundPointerElementAccess node);
    public virtual BoundNode VisitPointerIndirectionOperator(BoundPointerIndirectionOperator node);
    public virtual BoundNode VisitConversion(BoundConversion node);
    public virtual BoundNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node);
    public virtual BoundNode VisitMethodGroup(BoundMethodGroup node);
    private BoundNode VisitMethodGroup(BoundMethodGroup node, bool parentIsConversion);
    public virtual BoundNode VisitNameOfOperator(BoundNameOfOperator node);
    public virtual BoundNode VisitNullCoalescingOperator(BoundNullCoalescingOperator node);
    public virtual BoundNode VisitDynamicInvocation(BoundDynamicInvocation node);
    public virtual BoundNode VisitDynamicIndexerAccess(BoundDynamicIndexerAccess node);
    public virtual BoundNode VisitDynamicMemberAccess(BoundDynamicMemberAccess node);
    public virtual BoundNode VisitDynamicCollectionElementInitializer(BoundDynamicCollectionElementInitializer node);
    public virtual BoundNode VisitDynamicObjectCreationExpression(BoundDynamicObjectCreationExpression node);
    private void CheckArguments(ImmutableArray`1<RefKind> argumentRefKindsOpt, ImmutableArray`1<BoundExpression> arguments, Symbol method);
    private void CheckFieldAddress(BoundFieldAccess fieldAccess, Symbol consumerOpt);
    private void CheckFieldAsReceiver(BoundFieldAccess fieldAccess);
    private void CheckReceiverIfField(BoundExpression receiverOpt);
    internal static bool IsNonAgileFieldAccess(BoundFieldAccess fieldAccess, CSharpCompilation compilation);
    private static bool IsInstanceFieldAccessWithNonThisReceiver(BoundFieldAccess fieldAccess);
    private bool IsInterlockedAPI(Symbol method);
    private static BoundExpression StripImplicitCasts(BoundExpression expr);
    private static bool IsSameLocalOrField(BoundExpression expr1, BoundExpression expr2);
    private static bool IsComCallWithRefOmitted(MethodSymbol method, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<RefKind> argumentRefKindsOpt);
    private void CheckBinaryOperator(BoundBinaryOperator node);
    private void CheckCompoundAssignmentOperator(BoundCompoundAssignmentOperator node);
    private void CheckRelationals(BoundBinaryOperator node);
    private static bool IsExplicitCast(BoundExpression node);
    private static bool ConvertedHasEqual(BinaryOperatorKind oldOperatorKind, BoundNode node, TypeSymbol& type);
    private void CheckSelfComparisons(BoundBinaryOperator node);
    private void CheckVacuousComparisons(BoundBinaryOperator tree, ConstantValue constantValue, BoundNode operand);
    private void CheckForBitwiseOrSignExtend(BoundExpression node, BinaryOperatorKind operatorKind, BoundExpression leftOperand, BoundExpression rightOperand);
    private static ConstantValue GetConstantValueForBitwiseOrCheck(BoundExpression operand);
    private static ulong FindSurprisingSignExtensionBits(BoundExpression expr);
    private void CheckLiftedCompoundAssignment(BoundCompoundAssignmentOperator node);
    private void CheckLiftedUnaryOp(BoundUnaryOperator node);
    private void CheckNullableNullBinOp(BoundBinaryOperator node);
    private void CheckLiftedBinOp(BoundBinaryOperator node);
    private void CheckLiftedUserDefinedConditionalLogicalOperator(BoundUserDefinedConditionalLogicalOperator node);
    private static TypeSymbol GetTypeForLiftedComparisonWarning(BoundExpression node);
    private bool CheckForAssignmentToSelf(BoundAssignmentOperator node);
    public virtual BoundNode VisitFieldAccess(BoundFieldAccess node);
    public virtual BoundNode VisitPropertyAccess(BoundPropertyAccess node);
    public virtual BoundNode VisitPropertyGroup(BoundPropertyGroup node);
}
internal class Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler : CSharpSymbolVisitor {
    private string _assemblyName;
    private CSharpCompilation _compilation;
    private TextWriter _writer;
    private SyntaxTree _filterTree;
    private Nullable`1<TextSpan> _filterSpanWithinTree;
    private bool _processIncludes;
    private bool _isForSingleSymbol;
    private DiagnosticBag _diagnostics;
    private CancellationToken _cancellationToken;
    private SyntaxNodeLocationComparer _lazyComparer;
    private DocumentationCommentIncludeCache _includedFileCache;
    private int _indentDepth;
    private Stack`1<TemporaryStringBuilder> _temporaryStringBuilders;
    private static String[] s_newLineSequences;
    private IComparer`1<CSharpSyntaxNode> Comparer { get; }
    private DocumentationCommentCompiler(string assemblyName, CSharpCompilation compilation, TextWriter writer, SyntaxTree filterTree, Nullable`1<TextSpan> filterSpanWithinTree, bool processIncludes, bool isForSingleSymbol, DiagnosticBag diagnostics, CancellationToken cancellationToken);
    private static DocumentationCommentCompiler();
    public static void WriteDocumentationCommentXml(CSharpCompilation compilation, string assemblyName, Stream xmlDocStream, DiagnosticBag diagnostics, CancellationToken cancellationToken, SyntaxTree filterTree, Nullable`1<TextSpan> filterSpanWithinTree);
    internal static string GetDocumentationCommentXml(Symbol symbol, bool processIncludes, CancellationToken cancellationToken);
    public virtual void VisitNamespace(NamespaceSymbol symbol);
    public virtual void VisitNamedType(NamedTypeSymbol symbol);
    public virtual void DefaultVisit(Symbol symbol);
    private bool TryProcessDocumentationCommentTriviaNodes(Symbol symbol, bool isPartialMethodDefinitionPart, ImmutableArray`1<DocumentationCommentTriviaSyntax> docCommentNodes, bool reportParameterOrTypeParameterDiagnostics, String& withUnprocessedIncludes, Boolean& haveParseError, HashSet`1& documentedTypeParameters, HashSet`1& documentedParameters, ImmutableArray`1& includeElementNodes);
    private static Location GetLocationInTreeReportingDocumentationCommentDiagnostics(Symbol symbol);
    private static ImmutableArray`1<ParameterSymbol> GetParameters(Symbol symbol);
    private static ImmutableArray`1<TypeParameterSymbol> GetTypeParameters(Symbol symbol);
    private static bool RequiresDocumentationComment(Symbol symbol);
    private bool TryGetDocumentationCommentNodes(Symbol symbol, DocumentationMode& maxDocumentationMode, ImmutableArray`1& nodes);
    private static bool ContainsXmlParseDiagnostic(DocumentationCommentTriviaSyntax node);
    private string FormatComment(string substitutedText);
    private static int GetIndexOfFirstNonWhitespaceChar(string str);
    private static int GetIndexOfFirstNonWhitespaceChar(string str, int start, int end);
    private static bool TrimmedStringStartsWith(string str, string prefix);
    private static int IndexOfNewLine(string str, int start, Int32& newLineLength);
    private void WriteFormattedSingleLineComment(string text);
    private void WriteFormattedMultiLineComment(String[] lines, int numLines);
    private static string TrimEndOfMultiLineComment(string trimmed);
    private static string FindMultiLineCommentPattern(string line);
    private static string LongestCommonPrefix(string str1, string str2);
    private static string GetDocumentationCommentId(CrefSyntax crefSyntax, Binder binder, DiagnosticBag diagnostics);
    private static string ToBadCrefString(CrefSyntax cref);
    private static void BindName(XmlNameAttributeSyntax syntax, Binder binder, Symbol memberSymbol, HashSet`1& documentedParameters, HashSet`1& documentedTypeParameters, DiagnosticBag diagnostics);
    private IComparer`1<CSharpSyntaxNode> get_Comparer();
    private void BeginTemporaryString();
    private string GetAndEndTemporaryString();
    private void Indent();
    private void Unindent();
    private void Write(string indentedAndWrappedString);
    private void WriteLine(string message);
    private void WriteSubStringLine(string message, int start, int length);
    private void WriteLine(string format, Object[] args);
    private static string MakeIndent(int depth);
    private static string GetDescription(XmlException e);
}
internal class Microsoft.CodeAnalysis.CSharp.DocumentationCommentIDVisitor : CSharpSymbolVisitor`2<StringBuilder, object> {
    public static DocumentationCommentIDVisitor Instance;
    private static DocumentationCommentIDVisitor();
    public virtual object DefaultVisit(Symbol symbol, StringBuilder builder);
    public virtual object VisitNamespace(NamespaceSymbol symbol, StringBuilder builder);
    public virtual object VisitMethod(MethodSymbol symbol, StringBuilder builder);
    public virtual object VisitField(FieldSymbol symbol, StringBuilder builder);
    public virtual object VisitEvent(EventSymbol symbol, StringBuilder builder);
    public virtual object VisitProperty(PropertySymbol symbol, StringBuilder builder);
    public virtual object VisitNamedType(NamedTypeSymbol symbol, StringBuilder builder);
    public virtual object VisitDynamicType(DynamicTypeSymbol symbol, StringBuilder builder);
    public virtual object VisitErrorType(ErrorTypeSymbol symbol, StringBuilder builder);
    public virtual object VisitTypeParameter(TypeParameterSymbol symbol, StringBuilder builder);
}
internal static class Microsoft.CodeAnalysis.CSharp.DocumentationComments.PEDocumentationCommentUtils : object {
    internal static string GetDocumentationComment(Symbol symbol, PEModuleSymbol containingPEModule, CultureInfo preferredCulture, CancellationToken cancellationToken, Tuple`2& lazyDocComment);
}
internal class Microsoft.CodeAnalysis.CSharp.DynamicSiteContainer : SynthesizedContainer {
    private MethodSymbol _topLevelMethod;
    public Symbol ContainingSymbol { get; }
    public TypeKind TypeKind { get; }
    private bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.HasMethodBodyDependency { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.Method { get; }
    internal DynamicSiteContainer(string name, MethodSymbol topLevelMethod);
    public virtual Symbol get_ContainingSymbol();
    public virtual TypeKind get_TypeKind();
    private sealed virtual override bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_HasMethodBodyDependency();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_Method();
}
internal class Microsoft.CodeAnalysis.CSharp.EarlyWellKnownAttributeBinder : Binder {
    internal EarlyWellKnownAttributeBinder(Binder enclosing);
    internal CSharpAttributeData GetAttribute(AttributeSyntax node, NamedTypeSymbol boundAttributeType, Boolean& generatedDiagnostics);
    [ObsoleteAttribute("EarlyWellKnownAttributeBinder has a better overload - GetAttribute(AttributeSyntax, NamedTypeSymbol, out bool)", "True")]
internal CSharpAttributeData GetAttribute(AttributeSyntax node, NamedTypeSymbol boundAttributeType, DiagnosticBag diagnostics);
    internal static bool CanBeValidAttributeArgument(ExpressionSyntax node, Binder typeBinder);
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.ArgListParameterTypeInformation : object {
    private ushort _ordinal;
    private bool _isByRef;
    private ITypeReference _type;
    private ImmutableArray`1<ICustomModifier> Microsoft.Cci.IParameterTypeInformation.CustomModifiers { get; }
    private bool Microsoft.Cci.IParameterTypeInformation.IsByReference { get; }
    private ushort Microsoft.Cci.IParameterTypeInformation.CountOfCustomModifiersPrecedingByRef { get; }
    private ushort Microsoft.Cci.IParameterListEntry.Index { get; }
    public ArgListParameterTypeInformation(int ordinal, bool isByRef, ITypeReference type);
    private sealed virtual override ImmutableArray`1<ICustomModifier> Microsoft.Cci.IParameterTypeInformation.get_CustomModifiers();
    private sealed virtual override bool Microsoft.Cci.IParameterTypeInformation.get_IsByReference();
    private sealed virtual override ushort Microsoft.Cci.IParameterTypeInformation.get_CountOfCustomModifiersPrecedingByRef();
    private sealed virtual override ITypeReference Microsoft.Cci.IParameterTypeInformation.GetType(EmitContext context);
    private sealed virtual override ushort Microsoft.Cci.IParameterListEntry.get_Index();
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.AssemblyReference : object {
    private AssemblySymbol _targetAssembly;
    public AssemblyIdentity Identity { get; }
    public Version AssemblyVersionPattern { get; }
    private string Microsoft.Cci.INamedEntity.Name { get; }
    internal AssemblyReference(AssemblySymbol assemblySymbol);
    public sealed virtual AssemblyIdentity get_Identity();
    public sealed virtual Version get_AssemblyVersionPattern();
    public virtual string ToString();
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override string Microsoft.Cci.INamedEntity.get_Name();
    private sealed virtual override IAssemblyReference Microsoft.Cci.IModuleReference.GetContainingAssembly(EmitContext context);
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.GetAttributes(EmitContext context);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.CSharpDefinitionMap : DefinitionMap`1<CSharpSymbolMatcher> {
    private MetadataDecoder _metadataDecoder;
    internal CommonMessageProvider MessageProvider { get; }
    public CSharpDefinitionMap(PEModule module, IEnumerable`1<SemanticEdit> edits, MetadataDecoder metadataDecoder, CSharpSymbolMatcher mapToMetadata, CSharpSymbolMatcher mapToPrevious);
    internal virtual CommonMessageProvider get_MessageProvider();
    internal bool TryGetAnonymousTypeName(NamedTypeSymbol template, String& name, Int32& index);
    internal virtual bool TryGetTypeHandle(ITypeDefinition def, TypeDefinitionHandle& handle);
    internal virtual bool TryGetEventHandle(IEventDefinition def, EventDefinitionHandle& handle);
    internal virtual bool TryGetFieldHandle(IFieldDefinition def, FieldDefinitionHandle& handle);
    internal virtual bool TryGetMethodHandle(IMethodDefinition def, MethodDefinitionHandle& handle);
    internal virtual bool TryGetPropertyHandle(IPropertyDefinition def, PropertyDefinitionHandle& handle);
    protected virtual void GetStateMachineFieldMapFromMetadata(ITypeSymbol stateMachineType, ImmutableArray`1<LocalSlotDebugInfo> localSlotDebugInfo, IReadOnlyDictionary`2& hoistedLocalMap, IReadOnlyDictionary`2& awaiterMap, Int32& awaiterSlotCount);
    protected virtual ImmutableArray`1<EncLocalInfo> TryGetLocalSlotMapFromMetadata(MethodDefinitionHandle handle, EditAndContinueMethodDebugInformation debugInfo);
    protected virtual ITypeSymbol TryGetStateMachineType(EntityHandle methodHandle);
    private static ImmutableArray`1<EncLocalInfo> CreateLocalSlotMap(EditAndContinueMethodDebugInformation methodEncInfo, ImmutableArray`1<LocalInfo`1<TypeSymbol>> slotMetadata);
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.CSharpSymbolMatcher : SymbolMatcher {
    private MatchDefs _defs;
    private MatchSymbols _symbols;
    public CSharpSymbolMatcher(IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> anonymousTypeMap, SourceAssemblySymbol sourceAssembly, EmitContext sourceContext, SourceAssemblySymbol otherAssembly, EmitContext otherContext, ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> otherSynthesizedMembersOpt);
    public CSharpSymbolMatcher(IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> anonymousTypeMap, SourceAssemblySymbol sourceAssembly, EmitContext sourceContext, PEAssemblySymbol otherAssembly);
    public virtual IDefinition MapDefinition(IDefinition definition);
    public virtual ITypeReference MapReference(ITypeReference reference);
    internal bool TryGetAnonymousTypeName(NamedTypeSymbol template, String& name, Int32& index);
}
internal static class Microsoft.CodeAnalysis.CSharp.Emit.EmitHelpers : object {
    internal static EmitDifferenceResult EmitDifference(CSharpCompilation compilation, EmitBaseline baseline, IEnumerable`1<SemanticEdit> edits, Func`2<ISymbol, bool> isAddedSymbol, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection`1<MethodDefinitionHandle> updatedMethods, CompilationTestData testData, CancellationToken cancellationToken);
    private static EmitBaseline MapToCompilation(CSharpCompilation compilation, PEDeltaAssemblyBuilder moduleBeingBuilt);
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.ExpandedVarargsMethodReference : object {
    private IMethodReference _underlyingMethod;
    private ImmutableArray`1<IParameterTypeInformation> _argListParams;
    private bool Microsoft.Cci.IMethodReference.AcceptsExtraArguments { get; }
    private ushort Microsoft.Cci.IMethodReference.GenericParameterCount { get; }
    private bool Microsoft.Cci.IMethodReference.IsGeneric { get; }
    private ImmutableArray`1<IParameterTypeInformation> Microsoft.Cci.IMethodReference.ExtraParameters { get; }
    private IGenericMethodInstanceReference Microsoft.Cci.IMethodReference.AsGenericMethodInstanceReference { get; }
    private ISpecializedMethodReference Microsoft.Cci.IMethodReference.AsSpecializedMethodReference { get; }
    private CallingConvention Microsoft.Cci.ISignature.CallingConvention { get; }
    private ushort Microsoft.Cci.ISignature.ParameterCount { get; }
    private ImmutableArray`1<ICustomModifier> Microsoft.Cci.ISignature.ReturnValueCustomModifiers { get; }
    private bool Microsoft.Cci.ISignature.ReturnValueIsByRef { get; }
    private string Microsoft.Cci.INamedEntity.Name { get; }
    private IMethodReference Microsoft.Cci.ISpecializedMethodReference.UnspecializedVersion { get; }
    public ExpandedVarargsMethodReference(IMethodReference underlyingMethod, ImmutableArray`1<IParameterTypeInformation> argListParams);
    private sealed virtual override bool Microsoft.Cci.IMethodReference.get_AcceptsExtraArguments();
    private sealed virtual override ushort Microsoft.Cci.IMethodReference.get_GenericParameterCount();
    private sealed virtual override bool Microsoft.Cci.IMethodReference.get_IsGeneric();
    private sealed virtual override IMethodDefinition Microsoft.Cci.IMethodReference.GetResolvedMethod(EmitContext context);
    private sealed virtual override ImmutableArray`1<IParameterTypeInformation> Microsoft.Cci.IMethodReference.get_ExtraParameters();
    private sealed virtual override IGenericMethodInstanceReference Microsoft.Cci.IMethodReference.get_AsGenericMethodInstanceReference();
    private sealed virtual override ISpecializedMethodReference Microsoft.Cci.IMethodReference.get_AsSpecializedMethodReference();
    private sealed virtual override CallingConvention Microsoft.Cci.ISignature.get_CallingConvention();
    private sealed virtual override ushort Microsoft.Cci.ISignature.get_ParameterCount();
    private sealed virtual override ImmutableArray`1<IParameterTypeInformation> Microsoft.Cci.ISignature.GetParameters(EmitContext context);
    private sealed virtual override ImmutableArray`1<ICustomModifier> Microsoft.Cci.ISignature.get_ReturnValueCustomModifiers();
    private sealed virtual override bool Microsoft.Cci.ISignature.get_ReturnValueIsByRef();
    private sealed virtual override ITypeReference Microsoft.Cci.ISignature.GetType(EmitContext context);
    private sealed virtual override ITypeReference Microsoft.Cci.ITypeMemberReference.GetContainingType(EmitContext context);
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.GetAttributes(EmitContext context);
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
    private sealed virtual override string Microsoft.Cci.INamedEntity.get_Name();
    private sealed virtual override IEnumerable`1<ITypeReference> Microsoft.Cci.IGenericMethodInstanceReference.GetGenericArguments(EmitContext context);
    private sealed virtual override IMethodReference Microsoft.Cci.IGenericMethodInstanceReference.GetGenericMethod(EmitContext context);
    private sealed virtual override IMethodReference Microsoft.Cci.ISpecializedMethodReference.get_UnspecializedVersion();
    public virtual string ToString();
    private static void Append(PooledStringBuilder result, object value);
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.GenericMethodInstanceReference : MethodReference {
    public IGenericMethodInstanceReference AsGenericMethodInstanceReference { get; }
    public GenericMethodInstanceReference(MethodSymbol underlyingMethod);
    public virtual void Dispatch(MetadataVisitor visitor);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Emit.GenericMethodInstanceReference/<Microsoft-Cci-IGenericMethodInstanceReference-GetGenericArguments>d__2")]
private sealed virtual override IEnumerable`1<ITypeReference> Microsoft.Cci.IGenericMethodInstanceReference.GetGenericArguments(EmitContext context);
    private sealed virtual override IMethodReference Microsoft.Cci.IGenericMethodInstanceReference.GetGenericMethod(EmitContext context);
    public virtual IGenericMethodInstanceReference get_AsGenericMethodInstanceReference();
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.GenericNamespaceTypeInstanceReference : GenericTypeInstanceReference {
    public IGenericTypeInstanceReference AsGenericTypeInstanceReference { get; }
    public INamespaceTypeReference AsNamespaceTypeReference { get; }
    public INestedTypeReference AsNestedTypeReference { get; }
    public ISpecializedNestedTypeReference AsSpecializedNestedTypeReference { get; }
    public GenericNamespaceTypeInstanceReference(NamedTypeSymbol underlyingNamedType);
    public virtual IGenericTypeInstanceReference get_AsGenericTypeInstanceReference();
    public virtual INamespaceTypeReference get_AsNamespaceTypeReference();
    public virtual INestedTypeReference get_AsNestedTypeReference();
    public virtual ISpecializedNestedTypeReference get_AsSpecializedNestedTypeReference();
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.GenericNestedTypeInstanceReference : GenericTypeInstanceReference {
    public IGenericTypeInstanceReference AsGenericTypeInstanceReference { get; }
    public INamespaceTypeReference AsNamespaceTypeReference { get; }
    public INestedTypeReference AsNestedTypeReference { get; }
    public ISpecializedNestedTypeReference AsSpecializedNestedTypeReference { get; }
    public GenericNestedTypeInstanceReference(NamedTypeSymbol underlyingNamedType);
    private sealed virtual override ITypeReference Microsoft.Cci.ITypeMemberReference.GetContainingType(EmitContext context);
    public virtual IGenericTypeInstanceReference get_AsGenericTypeInstanceReference();
    public virtual INamespaceTypeReference get_AsNamespaceTypeReference();
    public virtual INestedTypeReference get_AsNestedTypeReference();
    public virtual ISpecializedNestedTypeReference get_AsSpecializedNestedTypeReference();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Emit.GenericTypeInstanceReference : NamedTypeReference {
    private INamedTypeReference Microsoft.Cci.IGenericTypeInstanceReference.GenericType { get; }
    public GenericTypeInstanceReference(NamedTypeSymbol underlyingNamedType);
    public sealed virtual void Dispatch(MetadataVisitor visitor);
    private sealed virtual override ImmutableArray`1<ITypeReference> Microsoft.Cci.IGenericTypeInstanceReference.GetGenericArguments(EmitContext context);
    private sealed virtual override INamedTypeReference Microsoft.Cci.IGenericTypeInstanceReference.get_GenericType();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Emit.MethodReference : TypeMemberReference {
    protected MethodSymbol UnderlyingMethod;
    protected Symbol UnderlyingSymbol { get; }
    private bool Microsoft.Cci.IMethodReference.AcceptsExtraArguments { get; }
    private ushort Microsoft.Cci.IMethodReference.GenericParameterCount { get; }
    private bool Microsoft.Cci.IMethodReference.IsGeneric { get; }
    private ushort Microsoft.Cci.ISignature.ParameterCount { get; }
    private ImmutableArray`1<IParameterTypeInformation> Microsoft.Cci.IMethodReference.ExtraParameters { get; }
    private CallingConvention Microsoft.Cci.ISignature.CallingConvention { get; }
    private ImmutableArray`1<ICustomModifier> Microsoft.Cci.ISignature.ReturnValueCustomModifiers { get; }
    private bool Microsoft.Cci.ISignature.ReturnValueIsByRef { get; }
    public IGenericMethodInstanceReference AsGenericMethodInstanceReference { get; }
    public ISpecializedMethodReference AsSpecializedMethodReference { get; }
    public MethodReference(MethodSymbol underlyingMethod);
    protected virtual Symbol get_UnderlyingSymbol();
    private sealed virtual override bool Microsoft.Cci.IMethodReference.get_AcceptsExtraArguments();
    private sealed virtual override ushort Microsoft.Cci.IMethodReference.get_GenericParameterCount();
    private sealed virtual override bool Microsoft.Cci.IMethodReference.get_IsGeneric();
    private sealed virtual override ushort Microsoft.Cci.ISignature.get_ParameterCount();
    private sealed virtual override IMethodDefinition Microsoft.Cci.IMethodReference.GetResolvedMethod(EmitContext context);
    private sealed virtual override ImmutableArray`1<IParameterTypeInformation> Microsoft.Cci.IMethodReference.get_ExtraParameters();
    private sealed virtual override CallingConvention Microsoft.Cci.ISignature.get_CallingConvention();
    private sealed virtual override ImmutableArray`1<IParameterTypeInformation> Microsoft.Cci.ISignature.GetParameters(EmitContext context);
    private sealed virtual override ImmutableArray`1<ICustomModifier> Microsoft.Cci.ISignature.get_ReturnValueCustomModifiers();
    private sealed virtual override bool Microsoft.Cci.ISignature.get_ReturnValueIsByRef();
    private sealed virtual override ITypeReference Microsoft.Cci.ISignature.GetType(EmitContext context);
    public virtual IGenericMethodInstanceReference get_AsGenericMethodInstanceReference();
    public virtual ISpecializedMethodReference get_AsSpecializedMethodReference();
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.ModuleReference : object {
    private PEModuleBuilder _moduleBeingBuilt;
    private ModuleSymbol _underlyingModule;
    private string Microsoft.Cci.INamedEntity.Name { get; }
    private bool Microsoft.Cci.IFileReference.HasMetadata { get; }
    private string Microsoft.Cci.IFileReference.FileName { get; }
    internal ModuleReference(PEModuleBuilder moduleBeingBuilt, ModuleSymbol underlyingModule);
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override string Microsoft.Cci.INamedEntity.get_Name();
    private sealed virtual override bool Microsoft.Cci.IFileReference.get_HasMetadata();
    private sealed virtual override string Microsoft.Cci.IFileReference.get_FileName();
    private sealed virtual override ImmutableArray`1<byte> Microsoft.Cci.IFileReference.GetHashValue(AssemblyHashAlgorithm algorithmId);
    private sealed virtual override IAssemblyReference Microsoft.Cci.IModuleReference.GetContainingAssembly(EmitContext context);
    public virtual string ToString();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.GetAttributes(EmitContext context);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Emit.NamedTypeReference : object {
    protected NamedTypeSymbol UnderlyingNamedType;
    private ushort Microsoft.Cci.INamedTypeReference.GenericParameterCount { get; }
    private bool Microsoft.Cci.INamedTypeReference.MangleName { get; }
    private string Microsoft.Cci.INamedEntity.Name { get; }
    private bool Microsoft.Cci.ITypeReference.IsEnum { get; }
    private bool Microsoft.Cci.ITypeReference.IsValueType { get; }
    private TypeDefinitionHandle Microsoft.Cci.ITypeReference.TypeDef { get; }
    private IGenericMethodParameterReference Microsoft.Cci.ITypeReference.AsGenericMethodParameterReference { get; }
    public IGenericTypeInstanceReference AsGenericTypeInstanceReference { get; }
    private IGenericTypeParameterReference Microsoft.Cci.ITypeReference.AsGenericTypeParameterReference { get; }
    public INamespaceTypeReference AsNamespaceTypeReference { get; }
    public INestedTypeReference AsNestedTypeReference { get; }
    public ISpecializedNestedTypeReference AsSpecializedNestedTypeReference { get; }
    public NamedTypeReference(NamedTypeSymbol underlyingNamedType);
    private sealed virtual override ushort Microsoft.Cci.INamedTypeReference.get_GenericParameterCount();
    private sealed virtual override bool Microsoft.Cci.INamedTypeReference.get_MangleName();
    private sealed virtual override string Microsoft.Cci.INamedEntity.get_Name();
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsEnum();
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsValueType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.GetResolvedType(EmitContext context);
    private sealed virtual override PrimitiveTypeCode Microsoft.Cci.ITypeReference.TypeCode(EmitContext context);
    private sealed virtual override TypeDefinitionHandle Microsoft.Cci.ITypeReference.get_TypeDef();
    private sealed virtual override IGenericMethodParameterReference Microsoft.Cci.ITypeReference.get_AsGenericMethodParameterReference();
    public abstract virtual IGenericTypeInstanceReference get_AsGenericTypeInstanceReference();
    private sealed virtual override IGenericTypeParameterReference Microsoft.Cci.ITypeReference.get_AsGenericTypeParameterReference();
    private sealed virtual override INamespaceTypeDefinition Microsoft.Cci.ITypeReference.AsNamespaceTypeDefinition(EmitContext context);
    public abstract virtual INamespaceTypeReference get_AsNamespaceTypeReference();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.ITypeReference.AsNestedTypeDefinition(EmitContext context);
    public abstract virtual INestedTypeReference get_AsNestedTypeReference();
    public abstract virtual ISpecializedNestedTypeReference get_AsSpecializedNestedTypeReference();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.AsTypeDefinition(EmitContext context);
    public virtual string ToString();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.GetAttributes(EmitContext context);
    public abstract virtual void Dispatch(MetadataVisitor visitor);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.NoPia.EmbeddedEvent : CommonEmbeddedEvent<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, CSharpSyntaxNode, CSharpAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> {
    protected bool IsRuntimeSpecial { get; }
    protected bool IsSpecialName { get; }
    protected EmbeddedType ContainingType { get; }
    protected TypeMemberVisibility Visibility { get; }
    protected string Name { get; }
    public EmbeddedEvent(EventSymbol underlyingEvent, EmbeddedMethod adder, EmbeddedMethod remover);
    protected virtual IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    protected virtual bool get_IsRuntimeSpecial();
    protected virtual bool get_IsSpecialName();
    protected virtual ITypeReference GetType(PEModuleBuilder moduleBuilder, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    protected virtual EmbeddedType get_ContainingType();
    protected virtual TypeMemberVisibility get_Visibility();
    protected virtual string get_Name();
    protected virtual void EmbedCorrespondingComEventInterfaceMethodInternal(CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, bool isUsedForComAwareEventBinding);
    private bool EmbedMatchingInterfaceMethods(NamedTypeSymbol sourceInterface, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.NoPia.EmbeddedField : CommonEmbeddedField<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, CSharpSyntaxNode, CSharpAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> {
    internal EmbeddedTypesManager TypeManager { get; }
    protected bool IsCompileTimeConstant { get; }
    protected bool IsNotSerialized { get; }
    protected bool IsReadOnly { get; }
    protected bool IsRuntimeSpecial { get; }
    protected bool IsSpecialName { get; }
    protected bool IsStatic { get; }
    protected bool IsMarshalledExplicitly { get; }
    protected IMarshallingInformation MarshallingInformation { get; }
    protected ImmutableArray`1<byte> MarshallingDescriptor { get; }
    protected Nullable`1<int> TypeLayoutOffset { get; }
    protected TypeMemberVisibility Visibility { get; }
    protected string Name { get; }
    public EmbeddedField(EmbeddedType containingType, FieldSymbol underlyingField);
    internal virtual EmbeddedTypesManager get_TypeManager();
    protected virtual IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    protected virtual IMetadataConstant GetCompileTimeValue(EmitContext context);
    protected virtual bool get_IsCompileTimeConstant();
    protected virtual bool get_IsNotSerialized();
    protected virtual bool get_IsReadOnly();
    protected virtual bool get_IsRuntimeSpecial();
    protected virtual bool get_IsSpecialName();
    protected virtual bool get_IsStatic();
    protected virtual bool get_IsMarshalledExplicitly();
    protected virtual IMarshallingInformation get_MarshallingInformation();
    protected virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    protected virtual Nullable`1<int> get_TypeLayoutOffset();
    protected virtual TypeMemberVisibility get_Visibility();
    protected virtual string get_Name();
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.NoPia.EmbeddedMethod : CommonEmbeddedMethod<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, CSharpSyntaxNode, CSharpAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> {
    internal EmbeddedTypesManager TypeManager { get; }
    protected bool IsAbstract { get; }
    protected bool IsAccessCheckedOnOverride { get; }
    protected bool IsConstructor { get; }
    protected bool IsExternal { get; }
    protected bool IsHiddenBySignature { get; }
    protected bool IsNewSlot { get; }
    protected IPlatformInvokeInformation PlatformInvokeData { get; }
    protected bool IsRuntimeSpecial { get; }
    protected bool IsSpecialName { get; }
    protected bool IsSealed { get; }
    protected bool IsStatic { get; }
    protected bool IsVirtual { get; }
    protected bool ReturnValueIsMarshalledExplicitly { get; }
    protected IMarshallingInformation ReturnValueMarshallingInformation { get; }
    protected ImmutableArray`1<byte> ReturnValueMarshallingDescriptor { get; }
    protected TypeMemberVisibility Visibility { get; }
    protected string Name { get; }
    protected bool AcceptsExtraArguments { get; }
    protected CallingConvention CallingConvention { get; }
    protected ISignature UnderlyingMethodSignature { get; }
    protected INamespace ContainingNamespace { get; }
    public EmbeddedMethod(EmbeddedType containingType, MethodSymbol underlyingMethod);
    internal virtual EmbeddedTypesManager get_TypeManager();
    protected virtual IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    protected virtual ImmutableArray`1<EmbeddedParameter> GetParameters();
    protected virtual ImmutableArray`1<EmbeddedTypeParameter> GetTypeParameters();
    protected virtual bool get_IsAbstract();
    protected virtual bool get_IsAccessCheckedOnOverride();
    protected virtual bool get_IsConstructor();
    protected virtual bool get_IsExternal();
    protected virtual bool get_IsHiddenBySignature();
    protected virtual bool get_IsNewSlot();
    protected virtual IPlatformInvokeInformation get_PlatformInvokeData();
    protected virtual bool get_IsRuntimeSpecial();
    protected virtual bool get_IsSpecialName();
    protected virtual bool get_IsSealed();
    protected virtual bool get_IsStatic();
    protected virtual bool get_IsVirtual();
    protected virtual MethodImplAttributes GetImplementationAttributes(EmitContext context);
    protected virtual bool get_ReturnValueIsMarshalledExplicitly();
    protected virtual IMarshallingInformation get_ReturnValueMarshallingInformation();
    protected virtual ImmutableArray`1<byte> get_ReturnValueMarshallingDescriptor();
    protected virtual TypeMemberVisibility get_Visibility();
    protected virtual string get_Name();
    protected virtual bool get_AcceptsExtraArguments();
    protected virtual CallingConvention get_CallingConvention();
    protected virtual ISignature get_UnderlyingMethodSignature();
    protected virtual INamespace get_ContainingNamespace();
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.NoPia.EmbeddedParameter : CommonEmbeddedParameter<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, CSharpSyntaxNode, CSharpAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> {
    protected bool HasDefaultValue { get; }
    protected bool IsIn { get; }
    protected bool IsOut { get; }
    protected bool IsOptional { get; }
    protected bool IsMarshalledExplicitly { get; }
    protected IMarshallingInformation MarshallingInformation { get; }
    protected ImmutableArray`1<byte> MarshallingDescriptor { get; }
    protected string Name { get; }
    protected IParameterTypeInformation UnderlyingParameterTypeInformation { get; }
    protected ushort Index { get; }
    public EmbeddedParameter(CommonEmbeddedMember<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, CSharpSyntaxNode, CSharpAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> containingPropertyOrMethod, ParameterSymbol underlyingParameter);
    protected virtual bool get_HasDefaultValue();
    protected virtual IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    protected virtual IMetadataConstant GetDefaultValue(EmitContext context);
    protected virtual bool get_IsIn();
    protected virtual bool get_IsOut();
    protected virtual bool get_IsOptional();
    protected virtual bool get_IsMarshalledExplicitly();
    protected virtual IMarshallingInformation get_MarshallingInformation();
    protected virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    protected virtual string get_Name();
    protected virtual IParameterTypeInformation get_UnderlyingParameterTypeInformation();
    protected virtual ushort get_Index();
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.NoPia.EmbeddedProperty : CommonEmbeddedProperty<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, CSharpSyntaxNode, CSharpAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> {
    protected bool IsRuntimeSpecial { get; }
    protected bool IsSpecialName { get; }
    protected CallingConvention CallingConvention { get; }
    protected bool ReturnValueIsModified { get; }
    protected ImmutableArray`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    protected bool ReturnValueIsByRef { get; }
    protected EmbeddedType ContainingType { get; }
    protected TypeMemberVisibility Visibility { get; }
    protected string Name { get; }
    public EmbeddedProperty(PropertySymbol underlyingProperty, EmbeddedMethod getter, EmbeddedMethod setter);
    protected virtual IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    protected virtual ImmutableArray`1<EmbeddedParameter> GetParameters();
    protected virtual bool get_IsRuntimeSpecial();
    protected virtual bool get_IsSpecialName();
    protected virtual CallingConvention get_CallingConvention();
    protected virtual bool get_ReturnValueIsModified();
    protected virtual ImmutableArray`1<ICustomModifier> get_ReturnValueCustomModifiers();
    protected virtual bool get_ReturnValueIsByRef();
    protected virtual ITypeReference GetType(PEModuleBuilder moduleBuilder, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    protected virtual EmbeddedType get_ContainingType();
    protected virtual TypeMemberVisibility get_Visibility();
    protected virtual string get_Name();
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.NoPia.EmbeddedType : CommonEmbeddedType<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, CSharpSyntaxNode, CSharpAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> {
    private bool _embeddedAllMembersOfImplementedInterface;
    protected bool IsPublic { get; }
    protected bool IsAbstract { get; }
    protected bool IsBeforeFieldInit { get; }
    protected bool IsComImport { get; }
    protected bool IsInterface { get; }
    protected bool IsSerializable { get; }
    protected bool IsSpecialName { get; }
    protected bool IsWindowsRuntimeImport { get; }
    protected bool IsSealed { get; }
    protected CharSet StringFormat { get; }
    public EmbeddedType(EmbeddedTypesManager typeManager, NamedTypeSymbol underlyingNamedType);
    public void EmbedAllMembersOfImplementedInterface(CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    protected virtual int GetAssemblyRefIndex();
    protected virtual bool get_IsPublic();
    protected virtual ITypeReference GetBaseClass(PEModuleBuilder moduleBuilder, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    protected virtual IEnumerable`1<FieldSymbol> GetFieldsToEmit();
    protected virtual IEnumerable`1<MethodSymbol> GetMethodsToEmit();
    protected virtual IEnumerable`1<EventSymbol> GetEventsToEmit();
    protected virtual IEnumerable`1<PropertySymbol> GetPropertiesToEmit();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Emit.NoPia.EmbeddedType/<GetInterfaces>d__11")]
protected virtual IEnumerable`1<ITypeReference> GetInterfaces(EmitContext context);
    protected virtual bool get_IsAbstract();
    protected virtual bool get_IsBeforeFieldInit();
    protected virtual bool get_IsComImport();
    protected virtual bool get_IsInterface();
    protected virtual bool get_IsSerializable();
    protected virtual bool get_IsSpecialName();
    protected virtual bool get_IsWindowsRuntimeImport();
    protected virtual bool get_IsSealed();
    protected virtual Nullable`1<TypeLayout> GetTypeLayoutIfStruct();
    protected virtual CharSet get_StringFormat();
    protected virtual IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    protected virtual CSharpAttributeData CreateCompilerGeneratedAttribute();
    protected virtual CSharpAttributeData CreateTypeIdentifierAttribute(bool hasGuid, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    protected virtual void ReportMissingAttribute(AttributeDescription description, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    protected virtual void EmbedDefaultMembers(string defaultMember, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.NoPia.EmbeddedTypeParameter : CommonEmbeddedTypeParameter<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, CSharpSyntaxNode, CSharpAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> {
    protected bool MustBeReferenceType { get; }
    protected bool MustBeValueType { get; }
    protected bool MustHaveDefaultConstructor { get; }
    protected string Name { get; }
    protected ushort Index { get; }
    public EmbeddedTypeParameter(EmbeddedMethod containingMethod, TypeParameterSymbol underlyingTypeParameter);
    protected virtual IEnumerable`1<ITypeReference> GetConstraints(EmitContext context);
    protected virtual bool get_MustBeReferenceType();
    protected virtual bool get_MustBeValueType();
    protected virtual bool get_MustHaveDefaultConstructor();
    protected virtual string get_Name();
    protected virtual ushort get_Index();
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.NoPia.EmbeddedTypesManager : EmbeddedTypesManager`21<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, CSharpSyntaxNode, CSharpAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> {
    private ConcurrentDictionary`2<AssemblySymbol, string> _assemblyGuidMap;
    private ConcurrentDictionary`2<Symbol, bool> _reportedSymbolsMap;
    private NamedTypeSymbol _lazySystemStringType;
    private MethodSymbol[] _lazyWellKnownTypeMethods;
    public EmbeddedTypesManager(PEModuleBuilder moduleBeingBuilt);
    public NamedTypeSymbol GetSystemStringType(CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    public MethodSymbol GetWellKnownMethod(WellKnownMember method, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    private MethodSymbol LazyGetWellKnownTypeMethod(MethodSymbol& lazyMethod, WellKnownMember member, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal virtual int GetTargetAttributeSignatureIndex(Symbol underlyingSymbol, CSharpAttributeData attrData, AttributeDescription description);
    internal virtual CSharpAttributeData CreateSynthesizedAttribute(WellKnownMember constructor, CSharpAttributeData attrData, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal string GetAssemblyGuidString(AssemblySymbol assembly);
    protected virtual void OnGetTypesCompleted(ImmutableArray`1<EmbeddedType> types, DiagnosticBag diagnostics);
    protected virtual void ReportNameCollisionBetweenEmbeddedTypes(EmbeddedType typeA, EmbeddedType typeB, DiagnosticBag diagnostics);
    protected virtual void ReportNameCollisionWithAlreadyDeclaredType(EmbeddedType type, DiagnosticBag diagnostics);
    internal virtual void ReportIndirectReferencesToLinkedAssemblies(AssemblySymbol a, DiagnosticBag diagnostics);
    internal static bool IsValidEmbeddableType(NamedTypeSymbol namedType, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, EmbeddedTypesManager optTypeManager);
    private static void ReportNotEmbeddableSymbol(ErrorCode error, Symbol symbol, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, EmbeddedTypesManager optTypeManager);
    internal static void Error(DiagnosticBag diagnostics, ErrorCode code, CSharpSyntaxNode syntaxOpt, Object[] args);
    private static void Error(DiagnosticBag diagnostics, CSharpSyntaxNode syntaxOpt, DiagnosticInfo info);
    internal INamedTypeReference EmbedTypeIfNeedTo(NamedTypeSymbol namedType, bool fromImplements, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    private EmbeddedType EmbedType(NamedTypeSymbol namedType, bool fromImplements, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal virtual EmbeddedField EmbedField(EmbeddedType type, FieldSymbol field, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal virtual EmbeddedMethod EmbedMethod(EmbeddedType type, MethodSymbol method, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal virtual EmbeddedProperty EmbedProperty(EmbeddedType type, PropertySymbol property, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal virtual EmbeddedEvent EmbedEvent(EmbeddedType type, EventSymbol event, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, bool isUsedForComAwareEventBinding);
    protected virtual EmbeddedType GetEmbeddedTypeForMember(Symbol member, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal static ImmutableArray`1<EmbeddedParameter> EmbedParameters(CommonEmbeddedMember<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, CSharpSyntaxNode, CSharpAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> containingPropertyOrMethod, ImmutableArray`1<ParameterSymbol> underlyingParameters);
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.ParameterTypeInformation : object {
    private ParameterSymbol _underlyingParameter;
    private ImmutableArray`1<ICustomModifier> Microsoft.Cci.IParameterTypeInformation.CustomModifiers { get; }
    private bool Microsoft.Cci.IParameterTypeInformation.IsByReference { get; }
    private ushort Microsoft.Cci.IParameterTypeInformation.CountOfCustomModifiersPrecedingByRef { get; }
    private ushort Microsoft.Cci.IParameterListEntry.Index { get; }
    public ParameterTypeInformation(ParameterSymbol underlyingParameter);
    private sealed virtual override ImmutableArray`1<ICustomModifier> Microsoft.Cci.IParameterTypeInformation.get_CustomModifiers();
    private sealed virtual override bool Microsoft.Cci.IParameterTypeInformation.get_IsByReference();
    private sealed virtual override ushort Microsoft.Cci.IParameterTypeInformation.get_CountOfCustomModifiersPrecedingByRef();
    private sealed virtual override ITypeReference Microsoft.Cci.IParameterTypeInformation.GetType(EmitContext context);
    private sealed virtual override ushort Microsoft.Cci.IParameterListEntry.get_Index();
    public virtual string ToString();
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.PEAssemblyBuilder : PEAssemblyBuilderBase {
    public int CurrentGenerationOrdinal { get; }
    public PEAssemblyBuilder(SourceAssemblySymbol sourceAssembly, EmitOptions emitOptions, OutputKind outputKind, ModulePropertiesForSerialization serializationProperties, IEnumerable`1<ResourceDescription> manifestResources);
    public virtual int get_CurrentGenerationOrdinal();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Emit.PEAssemblyBuilderBase : PEModuleBuilder {
    private SourceAssemblySymbol _sourceAssembly;
    private ImmutableArray`1<NamedTypeSymbol> _additionalTypes;
    private ImmutableArray`1<IFileReference> _lazyFiles;
    private string _metadataName;
    private UInt32 Microsoft.Cci.IAssembly.Flags { get; }
    private string Microsoft.Cci.IAssembly.SignatureKey { get; }
    private ImmutableArray`1<byte> Microsoft.Cci.IAssembly.PublicKey { get; }
    private AssemblyIdentity Microsoft.Cci.IAssemblyReference.Identity { get; }
    private Version Microsoft.Cci.IAssemblyReference.AssemblyVersionPattern { get; }
    internal string Name { get; }
    private AssemblyHashAlgorithm Microsoft.Cci.IAssembly.HashAlgorithm { get; }
    public PEAssemblyBuilderBase(SourceAssemblySymbol sourceAssembly, EmitOptions emitOptions, OutputKind outputKind, ModulePropertiesForSerialization serializationProperties, IEnumerable`1<ResourceDescription> manifestResources, ImmutableArray`1<NamedTypeSymbol> additionalTypes);
    public virtual void Dispatch(MetadataVisitor visitor);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetAdditionalTopLevelTypes();
    private sealed virtual override IEnumerable`1<IFileReference> Microsoft.Cci.IAssembly.GetFiles(EmitContext context);
    private sealed virtual override UInt32 Microsoft.Cci.IAssembly.get_Flags();
    private sealed virtual override string Microsoft.Cci.IAssembly.get_SignatureKey();
    private sealed virtual override ImmutableArray`1<byte> Microsoft.Cci.IAssembly.get_PublicKey();
    protected virtual void AddEmbeddedResourcesFromAddedModules(ArrayBuilder`1<ManagedResource> builder, DiagnosticBag diagnostics);
    private sealed virtual override AssemblyIdentity Microsoft.Cci.IAssemblyReference.get_Identity();
    private sealed virtual override Version Microsoft.Cci.IAssemblyReference.get_AssemblyVersionPattern();
    internal virtual string get_Name();
    private sealed virtual override AssemblyHashAlgorithm Microsoft.Cci.IAssembly.get_HashAlgorithm();
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.PEDeltaAssemblyBuilder : PEAssemblyBuilderBase {
    private EmitBaseline _previousGeneration;
    private CSharpDefinitionMap _previousDefinitions;
    private SymbolChanges _changes;
    private DeepTranslator _deepTranslator;
    public int CurrentGenerationOrdinal { get; }
    internal EmitBaseline PreviousGeneration { get; }
    internal CSharpDefinitionMap PreviousDefinitions { get; }
    internal bool SupportsPrivateImplClass { get; }
    internal SymbolChanges Changes { get; }
    internal bool IsEncDelta { get; }
    public PEDeltaAssemblyBuilder(SourceAssemblySymbol sourceAssembly, EmitOptions emitOptions, OutputKind outputKind, ModulePropertiesForSerialization serializationProperties, IEnumerable`1<ResourceDescription> manifestResources, EmitBaseline previousGeneration, IEnumerable`1<SemanticEdit> edits, Func`2<ISymbol, bool> isAddedSymbol);
    public virtual int get_CurrentGenerationOrdinal();
    internal virtual ITypeReference EncTranslateLocalVariableType(TypeSymbol type, DiagnosticBag diagnostics);
    private MetadataSymbols GetOrCreateMetadataSymbols(EmitBaseline initialBaseline, CSharpCompilation compilation);
    internal static IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> GetAnonymousTypeMapFromMetadata(MetadataReader reader, MetadataDecoder metadataDecoder);
    private static bool TryGetAnonymousTypeKey(MetadataReader reader, TypeDefinition def, ArrayBuilder`1<AnonymousTypeKeyField> builder);
    internal EmitBaseline get_PreviousGeneration();
    internal CSharpDefinitionMap get_PreviousDefinitions();
    internal virtual bool get_SupportsPrivateImplClass();
    public sealed virtual IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> GetAnonymousTypeMap();
    internal virtual VariableSlotAllocator TryCreateVariableSlotAllocator(MethodSymbol method, MethodSymbol topLevelMethod, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<AnonymousTypeKey> GetPreviousAnonymousTypes();
    internal virtual int GetNextAnonymousTypeIndex();
    internal virtual bool TryGetAnonymousTypeName(NamedTypeSymbol template, String& name, Int32& index);
    internal SymbolChanges get_Changes();
    internal virtual IEnumerable`1<INamespaceTypeDefinition> GetTopLevelTypesCore(EmitContext context);
    public sealed virtual void OnCreatedIndices(DiagnosticBag diagnostics);
    internal virtual bool get_IsEncDelta();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder : PEModuleBuilder`9<CSharpCompilation, SourceModuleSymbol, AssemblySymbol, TypeSymbol, NamedTypeSymbol, MethodSymbol, CSharpSyntaxNode, EmbeddedTypesManager, ModuleCompilationState> {
    protected ConcurrentDictionary`2<Symbol, IModuleReference> AssemblyOrModuleSymbolToModuleRefMap;
    private ConcurrentDictionary`2<Symbol, object> _genericInstanceMap;
    private ConcurrentSet`1<ErrorTypeSymbol> _reportedErrorTypesMap;
    private EmbeddedTypesManager _embeddedTypesManagerOpt;
    private string _metadataName;
    private ImmutableArray`1<NamedTypeSymbol> _lazyExportedTypes;
    private Dictionary`2<FieldSymbol, NamedTypeSymbol> _fixedImplementationTypes;
    private ConcurrentDictionary`2<string, MethodData> _testData;
    private SymbolDisplayFormat _testDataKeyFormat;
    private SymbolDisplayFormat _testDataOperatorKeyFormat;
    public EmbeddedTypesManager EmbeddedTypesManagerOpt { get; }
    internal string Name { get; }
    internal string ModuleName { get; }
    internal AssemblySymbol CorLibrary { get; }
    protected bool GenerateVisualBasicStylePdb { get; }
    protected IEnumerable`1<string> LinkedAssembliesDebugInfo { get; }
    protected string DefaultNamespace { get; }
    internal bool IgnoreAccessibility { get; }
    internal NamedTypeSymbol DynamicOperationContextType { get; }
    internal bool IsEncDelta { get; }
    internal bool SaveTestData { get; }
    internal PEModuleBuilder(SourceModuleSymbol sourceModule, EmitOptions emitOptions, OutputKind outputKind, ModulePropertiesForSerialization serializationProperties, IEnumerable`1<ResourceDescription> manifestResources);
    public virtual EmbeddedTypesManager get_EmbeddedTypesManagerOpt();
    internal virtual string get_Name();
    internal sealed virtual string get_ModuleName();
    internal sealed virtual ICustomAttribute SynthesizeAttribute(WellKnownMember attributeConstructor);
    internal sealed virtual IEnumerable`1<ICustomAttribute> GetSourceAssemblyAttributes();
    internal sealed virtual IEnumerable`1<SecurityAttribute> GetSourceAssemblySecurityAttributes();
    internal sealed virtual IEnumerable`1<ICustomAttribute> GetSourceModuleAttributes();
    internal sealed virtual AssemblySymbol get_CorLibrary();
    protected sealed virtual bool get_GenerateVisualBasicStylePdb();
    protected sealed virtual IEnumerable`1<string> get_LinkedAssembliesDebugInfo();
    protected virtual ImmutableArray`1<UsedNamespaceOrType> GetImports();
    protected virtual string get_DefaultNamespace();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder/<GetAssemblyReferencesFromAddedModules>d__30")]
protected virtual IEnumerable`1<IAssemblyReference> GetAssemblyReferencesFromAddedModules(DiagnosticBag diagnostics);
    private void ValidateReferencedAssembly(AssemblySymbol assembly, AssemblyReference asmRef, DiagnosticBag diagnostics);
    internal sealed virtual IEnumerable`1<INestedTypeDefinition> GetSynthesizedNestedTypes(NamedTypeSymbol container);
    protected virtual MultiDictionary`2<DebugSourceDocument, DefinitionWithLocation> GetSymbolToLocationMap();
    private void AddSymbolLocation(MultiDictionary`2<DebugSourceDocument, DefinitionWithLocation> result, Symbol symbol);
    private void AddSymbolLocation(MultiDictionary`2<DebugSourceDocument, DefinitionWithLocation> result, Location location, IDefinition definition);
    private Location GetSmallestSourceLocationOrNull(Symbol symbol);
    internal virtual bool get_IgnoreAccessibility();
    internal virtual NamedTypeSymbol get_DynamicOperationContextType();
    internal virtual VariableSlotAllocator TryCreateVariableSlotAllocator(MethodSymbol method, MethodSymbol topLevelMethod, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<AnonymousTypeKey> GetPreviousAnonymousTypes();
    internal virtual int GetNextAnonymousTypeIndex();
    internal virtual bool TryGetAnonymousTypeName(NamedTypeSymbol template, String& name, Int32& index);
    internal virtual ImmutableArray`1<INamespaceTypeDefinition> GetAnonymousTypes();
    internal virtual bool get_IsEncDelta();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder/<GetTopLevelTypesCore>d__48")]
internal virtual IEnumerable`1<INamespaceTypeDefinition> GetTopLevelTypesCore(EmitContext context);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetAdditionalTopLevelTypes();
    private void GetExportedTypes(NamespaceOrTypeSymbol sym, ArrayBuilder`1<NamedTypeSymbol> builder);
    public virtual IEnumerable`1<ITypeReference> GetExportedTypes(EmitContext context);
    private static void GetForwardedTypes(HashSet`1<NamedTypeSymbol> seenTopLevelTypes, CommonAssemblyWellKnownAttributeData`1<NamedTypeSymbol> wellKnownAttributeData, ArrayBuilder`1<NamedTypeSymbol> builder);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder/<GetReferencedAssembliesUsedSoFar>d__53")]
internal IEnumerable`1<AssemblySymbol> GetReferencedAssembliesUsedSoFar();
    internal sealed virtual INamedTypeReference GetSpecialType(SpecialType specialType, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal sealed virtual INamedTypeReference GetSystemType(CSharpSyntaxNode syntaxOpt, DiagnosticBag diagnostics);
    public sealed virtual IMethodReference GetInitArrayHelper();
    protected sealed virtual bool IsPlatformType(ITypeReference typeRef, PlatformType platformType);
    protected sealed virtual IAssemblyReference GetCorLibraryReferenceToEmit(EmitContext context);
    internal sealed virtual IAssemblyReference Translate(AssemblySymbol assembly, DiagnosticBag diagnostics);
    internal IModuleReference Translate(ModuleSymbol module, DiagnosticBag diagnostics);
    protected virtual IModuleReference TranslateModule(ModuleSymbol module, DiagnosticBag diagnostics);
    internal INamedTypeReference Translate(NamedTypeSymbol namedTypeSymbol, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, bool fromImplements, bool needDeclaration);
    public static bool IsGenericType(NamedTypeSymbol toCheck);
    internal static IGenericParameterReference Translate(TypeParameterSymbol param);
    internal sealed virtual ITypeReference Translate(TypeSymbol typeSymbol, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal IFieldReference Translate(FieldSymbol fieldSymbol, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, bool needDeclaration);
    public static TypeMemberVisibility MemberVisibility(Symbol symbol);
    internal virtual IMethodReference Translate(MethodSymbol symbol, DiagnosticBag diagnostics, bool needDeclaration);
    internal IMethodReference Translate(MethodSymbol methodSymbol, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, BoundArgListOperator optArgList, bool needDeclaration);
    private IMethodReference Translate(MethodSymbol methodSymbol, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, bool needDeclaration);
    internal IMethodReference TranslateOverriddenMethodReference(MethodSymbol methodSymbol, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal ImmutableArray`1<IParameterTypeInformation> Translate(ImmutableArray`1<ParameterSymbol> params);
    private static bool MustBeWrapped(ParameterSymbol param);
    private ImmutableArray`1<IParameterTypeInformation> TranslateAll(ImmutableArray`1<ParameterSymbol> params);
    private IParameterTypeInformation CreateParameterTypeInformationWrapper(ParameterSymbol param);
    private static bool ContainerIsGeneric(Symbol container);
    internal ITypeReference Translate(DynamicTypeSymbol symbol, CSharpSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal static IArrayTypeReference Translate(ArrayTypeSymbol symbol);
    internal static IPointerTypeReference Translate(PointerTypeSymbol symbol);
    public NamedTypeSymbol SetFixedImplementationType(SourceMemberFieldSymbol field);
    internal NamedTypeSymbol GetFixedImplementationType(FieldSymbol field);
    internal bool get_SaveTestData();
    internal void SetMethodTestData(MethodSymbol methodSymbol, ILBuilder builder);
    private string GetMethodKey(MethodSymbol methodSymbol);
    internal void SetMethodTestData(ConcurrentDictionary`2<string, MethodData> methods);
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.PENetModuleBuilder : PEModuleBuilder {
    public int CurrentGenerationOrdinal { get; }
    internal PENetModuleBuilder(SourceModuleSymbol sourceModule, EmitOptions emitOptions, ModulePropertiesForSerialization serializationProperties, IEnumerable`1<ResourceDescription> manifestResources);
    protected virtual void AddEmbeddedResourcesFromAddedModules(ArrayBuilder`1<ManagedResource> builder, DiagnosticBag diagnostics);
    public virtual int get_CurrentGenerationOrdinal();
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.SpecializedFieldReference : TypeMemberReference {
    private FieldSymbol _underlyingField;
    protected Symbol UnderlyingSymbol { get; }
    private IFieldReference Microsoft.Cci.ISpecializedFieldReference.UnspecializedVersion { get; }
    private ISpecializedFieldReference Microsoft.Cci.IFieldReference.AsSpecializedFieldReference { get; }
    private bool Microsoft.Cci.IFieldReference.IsContextualNamedEntity { get; }
    public SpecializedFieldReference(FieldSymbol underlyingField);
    protected virtual Symbol get_UnderlyingSymbol();
    public virtual void Dispatch(MetadataVisitor visitor);
    private sealed virtual override IFieldReference Microsoft.Cci.ISpecializedFieldReference.get_UnspecializedVersion();
    private sealed virtual override ISpecializedFieldReference Microsoft.Cci.IFieldReference.get_AsSpecializedFieldReference();
    private sealed virtual override ITypeReference Microsoft.Cci.IFieldReference.GetType(EmitContext context);
    private sealed virtual override IFieldDefinition Microsoft.Cci.IFieldReference.GetResolvedField(EmitContext context);
    private sealed virtual override bool Microsoft.Cci.IFieldReference.get_IsContextualNamedEntity();
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.SpecializedGenericMethodInstanceReference : SpecializedMethodReference {
    private SpecializedMethodReference _genericMethod;
    public IGenericMethodInstanceReference AsGenericMethodInstanceReference { get; }
    public SpecializedGenericMethodInstanceReference(MethodSymbol underlyingMethod);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Emit.SpecializedGenericMethodInstanceReference/<Microsoft-Cci-IGenericMethodInstanceReference-GetGenericArguments>d__2")]
private sealed virtual override IEnumerable`1<ITypeReference> Microsoft.Cci.IGenericMethodInstanceReference.GetGenericArguments(EmitContext context);
    private sealed virtual override IMethodReference Microsoft.Cci.IGenericMethodInstanceReference.GetGenericMethod(EmitContext context);
    public virtual IGenericMethodInstanceReference get_AsGenericMethodInstanceReference();
    public virtual void Dispatch(MetadataVisitor visitor);
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.SpecializedGenericNestedTypeInstanceReference : SpecializedNestedTypeReference {
    private INamedTypeReference Microsoft.Cci.IGenericTypeInstanceReference.GenericType { get; }
    public IGenericTypeInstanceReference AsGenericTypeInstanceReference { get; }
    public INamespaceTypeReference AsNamespaceTypeReference { get; }
    public INestedTypeReference AsNestedTypeReference { get; }
    public ISpecializedNestedTypeReference AsSpecializedNestedTypeReference { get; }
    public SpecializedGenericNestedTypeInstanceReference(NamedTypeSymbol underlyingNamedType);
    public sealed virtual void Dispatch(MetadataVisitor visitor);
    private sealed virtual override ImmutableArray`1<ITypeReference> Microsoft.Cci.IGenericTypeInstanceReference.GetGenericArguments(EmitContext context);
    private sealed virtual override INamedTypeReference Microsoft.Cci.IGenericTypeInstanceReference.get_GenericType();
    public virtual IGenericTypeInstanceReference get_AsGenericTypeInstanceReference();
    public virtual INamespaceTypeReference get_AsNamespaceTypeReference();
    public virtual INestedTypeReference get_AsNestedTypeReference();
    public virtual ISpecializedNestedTypeReference get_AsSpecializedNestedTypeReference();
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.SpecializedMethodReference : MethodReference {
    private IMethodReference Microsoft.Cci.ISpecializedMethodReference.UnspecializedVersion { get; }
    public ISpecializedMethodReference AsSpecializedMethodReference { get; }
    public SpecializedMethodReference(MethodSymbol underlyingMethod);
    public virtual void Dispatch(MetadataVisitor visitor);
    private sealed virtual override IMethodReference Microsoft.Cci.ISpecializedMethodReference.get_UnspecializedVersion();
    public virtual ISpecializedMethodReference get_AsSpecializedMethodReference();
}
internal class Microsoft.CodeAnalysis.CSharp.Emit.SpecializedNestedTypeReference : NamedTypeReference {
    private INestedTypeReference Microsoft.Cci.ISpecializedNestedTypeReference.UnspecializedVersion { get; }
    public IGenericTypeInstanceReference AsGenericTypeInstanceReference { get; }
    public INamespaceTypeReference AsNamespaceTypeReference { get; }
    public INestedTypeReference AsNestedTypeReference { get; }
    public ISpecializedNestedTypeReference AsSpecializedNestedTypeReference { get; }
    public SpecializedNestedTypeReference(NamedTypeSymbol underlyingNamedType);
    private sealed virtual override INestedTypeReference Microsoft.Cci.ISpecializedNestedTypeReference.get_UnspecializedVersion();
    public virtual void Dispatch(MetadataVisitor visitor);
    private sealed virtual override ITypeReference Microsoft.Cci.ITypeMemberReference.GetContainingType(EmitContext context);
    public virtual IGenericTypeInstanceReference get_AsGenericTypeInstanceReference();
    public virtual INamespaceTypeReference get_AsNamespaceTypeReference();
    public virtual INestedTypeReference get_AsNestedTypeReference();
    public virtual ISpecializedNestedTypeReference get_AsSpecializedNestedTypeReference();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Emit.TypeMemberReference : object {
    protected Symbol UnderlyingSymbol { get; }
    private string Microsoft.Cci.INamedEntity.Name { get; }
    protected abstract virtual Symbol get_UnderlyingSymbol();
    public virtual ITypeReference GetContainingType(EmitContext context);
    private sealed virtual override string Microsoft.Cci.INamedEntity.get_Name();
    public virtual string ToString();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.GetAttributes(EmitContext context);
    public abstract virtual void Dispatch(MetadataVisitor visitor);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache : object {
    private SmallDictionary`2<NamedTypeSymbol, bool> _cache;
    private bool _dev12CompilerCompatibility;
    private SourceAssemblySymbol _sourceAssembly;
    private SmallDictionary`2<NamedTypeSymbol, bool> Cache { get; }
    internal EmptyStructTypeCache(Compilation compilation, bool dev12CompilerCompatibility);
    private SmallDictionary`2<NamedTypeSymbol, bool> get_Cache();
    public virtual bool IsEmptyStructType(TypeSymbol type);
    private bool IsEmptyStructType(TypeSymbol type, ConsList`1<NamedTypeSymbol> typesWithMembersOfThisType);
    private bool CheckStruct(ConsList`1<NamedTypeSymbol> typesWithMembersOfThisType, NamedTypeSymbol nts);
    public static bool IsTrackableStructType(TypeSymbol type);
    private bool CheckStructInstanceFields(ConsList`1<NamedTypeSymbol> typesWithMembersOfThisType, NamedTypeSymbol type);
    public IEnumerable`1<FieldSymbol> GetStructInstanceFields(TypeSymbol type);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache/<GetStructInstanceFields>d__12")]
public IEnumerable`1<FieldSymbol> GetStructInstanceFields(NamedTypeSymbol type);
    private FieldSymbol GetActualInstanceField(Symbol member, NamedTypeSymbol type);
    private bool ShouldIgnoreStructField(Symbol member, TypeSymbol memberType);
    private static bool IsIgnorableType(TypeSymbol type);
    private static bool IsAccessibleInAssembly(Symbol symbol, SourceAssemblySymbol assembly);
}
internal class Microsoft.CodeAnalysis.CSharp.EntryPointCandidateFinder : CSharpSymbolVisitor`2<object, object> {
    private ArrayBuilder`1<MethodSymbol> _entryPointCandidates;
    private bool _visitNestedTypes;
    private CancellationToken _cancellationToken;
    private EntryPointCandidateFinder(ArrayBuilder`1<MethodSymbol> entryPointCandidates, bool visitNestedTypes, CancellationToken cancellationToken);
    public static void FindCandidatesInNamespace(NamespaceSymbol root, ArrayBuilder`1<MethodSymbol> entryPointCandidates, CancellationToken cancellationToken);
    public static void FindCandidatesInSingleType(NamedTypeSymbol root, ArrayBuilder`1<MethodSymbol> entryPointCandidates, CancellationToken cancellationToken);
    public virtual object VisitNamespace(NamespaceSymbol symbol, object arg);
    public virtual object VisitNamedType(NamedTypeSymbol symbol, object arg);
    public virtual object VisitMethod(MethodSymbol symbol, object arg);
    public virtual object VisitProperty(PropertySymbol symbol, object argument);
    public virtual object VisitEvent(EventSymbol symbol, object argument);
    public virtual object VisitField(FieldSymbol symbol, object argument);
}
internal class Microsoft.CodeAnalysis.CSharp.EntryPointsWalker : AbstractRegionControlFlowPass {
    private HashSet`1<LabeledStatementSyntax> _entryPoints;
    private EntryPointsWalker(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion);
    internal static IEnumerable`1<LabeledStatementSyntax> Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion, Nullable`1& succeeded);
    private void Analyze(Boolean& badRegion);
    protected virtual void Free();
    protected virtual void NoteBranch(PendingBranch<LocalState> pending, BoundStatement gotoStmt, BoundStatement targetStmt);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.EnumConversions : object {
    [ExtensionAttribute]
internal static DeclarationKind ToDeclarationKind(SyntaxKind kind);
}
internal static class Microsoft.CodeAnalysis.CSharp.EnumExtensions : object {
    public static T[] GetValues();
}
internal enum Microsoft.CodeAnalysis.CSharp.ErrorCode : Enum {
    public int value__;
    public static ErrorCode Void;
    public static ErrorCode Unknown;
    public static ErrorCode ERR_NoMetadataFile;
    public static ErrorCode FTL_MetadataCantOpenFile;
    public static ErrorCode ERR_NoTypeDef;
    public static ErrorCode ERR_OutputWriteFailed;
    public static ErrorCode ERR_MultipleEntryPoints;
    public static ErrorCode ERR_BadBinaryOps;
    public static ErrorCode ERR_IntDivByZero;
    public static ErrorCode ERR_BadIndexLHS;
    public static ErrorCode ERR_BadIndexCount;
    public static ErrorCode ERR_BadUnaryOp;
    public static ErrorCode ERR_ThisInStaticMeth;
    public static ErrorCode ERR_ThisInBadContext;
    public static ErrorCode WRN_InvalidMainSig;
    public static ErrorCode ERR_NoImplicitConv;
    public static ErrorCode ERR_NoExplicitConv;
    public static ErrorCode ERR_ConstOutOfRange;
    public static ErrorCode ERR_AmbigBinaryOps;
    public static ErrorCode ERR_AmbigUnaryOp;
    public static ErrorCode ERR_InAttrOnOutParam;
    public static ErrorCode ERR_ValueCantBeNull;
    public static ErrorCode ERR_NoExplicitBuiltinConv;
    public static ErrorCode FTL_DebugEmitFailure;
    public static ErrorCode ERR_BadVisReturnType;
    public static ErrorCode ERR_BadVisParamType;
    public static ErrorCode ERR_BadVisFieldType;
    public static ErrorCode ERR_BadVisPropertyType;
    public static ErrorCode ERR_BadVisIndexerReturn;
    public static ErrorCode ERR_BadVisIndexerParam;
    public static ErrorCode ERR_BadVisOpReturn;
    public static ErrorCode ERR_BadVisOpParam;
    public static ErrorCode ERR_BadVisDelegateReturn;
    public static ErrorCode ERR_BadVisDelegateParam;
    public static ErrorCode ERR_BadVisBaseClass;
    public static ErrorCode ERR_BadVisBaseInterface;
    public static ErrorCode ERR_EventNeedsBothAccessors;
    public static ErrorCode ERR_EventNotDelegate;
    public static ErrorCode WRN_UnreferencedEvent;
    public static ErrorCode ERR_InterfaceEventInitializer;
    public static ErrorCode ERR_EventPropertyInInterface;
    public static ErrorCode ERR_BadEventUsage;
    public static ErrorCode ERR_ExplicitEventFieldImpl;
    public static ErrorCode ERR_CantOverrideNonEvent;
    public static ErrorCode ERR_AddRemoveMustHaveBody;
    public static ErrorCode ERR_AbstractEventInitializer;
    public static ErrorCode ERR_ReservedEnumerator;
    public static ErrorCode ERR_AsMustHaveReferenceType;
    public static ErrorCode WRN_LowercaseEllSuffix;
    public static ErrorCode ERR_BadEventUsageNoField;
    public static ErrorCode ERR_ConstraintOnlyAllowedOnGenericDecl;
    public static ErrorCode ERR_TypeParamMustBeIdentifier;
    public static ErrorCode ERR_MemberReserved;
    public static ErrorCode ERR_DuplicateParamName;
    public static ErrorCode ERR_DuplicateNameInNS;
    public static ErrorCode ERR_DuplicateNameInClass;
    public static ErrorCode ERR_NameNotInContext;
    public static ErrorCode ERR_AmbigContext;
    public static ErrorCode WRN_DuplicateUsing;
    public static ErrorCode ERR_BadMemberFlag;
    public static ErrorCode ERR_BadMemberProtection;
    public static ErrorCode WRN_NewRequired;
    public static ErrorCode WRN_NewNotRequired;
    public static ErrorCode ERR_CircConstValue;
    public static ErrorCode ERR_MemberAlreadyExists;
    public static ErrorCode ERR_StaticNotVirtual;
    public static ErrorCode ERR_OverrideNotNew;
    public static ErrorCode WRN_NewOrOverrideExpected;
    public static ErrorCode ERR_OverrideNotExpected;
    public static ErrorCode ERR_NamespaceUnexpected;
    public static ErrorCode ERR_NoSuchMember;
    public static ErrorCode ERR_BadSKknown;
    public static ErrorCode ERR_BadSKunknown;
    public static ErrorCode ERR_ObjectRequired;
    public static ErrorCode ERR_AmbigCall;
    public static ErrorCode ERR_BadAccess;
    public static ErrorCode ERR_MethDelegateMismatch;
    public static ErrorCode ERR_RetObjectRequired;
    public static ErrorCode ERR_RetNoObjectRequired;
    public static ErrorCode ERR_LocalDuplicate;
    public static ErrorCode ERR_AssgLvalueExpected;
    public static ErrorCode ERR_StaticConstParam;
    public static ErrorCode ERR_NotConstantExpression;
    public static ErrorCode ERR_NotNullConstRefField;
    public static ErrorCode ERR_LocalIllegallyOverrides;
    public static ErrorCode ERR_BadUsingNamespace;
    public static ErrorCode ERR_NoBreakOrCont;
    public static ErrorCode ERR_DuplicateLabel;
    public static ErrorCode ERR_NoConstructors;
    public static ErrorCode ERR_NoNewAbstract;
    public static ErrorCode ERR_ConstValueRequired;
    public static ErrorCode ERR_CircularBase;
    public static ErrorCode ERR_BadDelegateConstructor;
    public static ErrorCode ERR_MethodNameExpected;
    public static ErrorCode ERR_ConstantExpected;
    public static ErrorCode ERR_SwitchGoverningTypeValueExpected;
    public static ErrorCode ERR_DuplicateCaseLabel;
    public static ErrorCode ERR_InvalidGotoCase;
    public static ErrorCode ERR_PropertyLacksGet;
    public static ErrorCode ERR_BadExceptionType;
    public static ErrorCode ERR_BadEmptyThrow;
    public static ErrorCode ERR_BadFinallyLeave;
    public static ErrorCode ERR_LabelShadow;
    public static ErrorCode ERR_LabelNotFound;
    public static ErrorCode ERR_UnreachableCatch;
    public static ErrorCode ERR_ReturnExpected;
    public static ErrorCode WRN_UnreachableCode;
    public static ErrorCode ERR_SwitchFallThrough;
    public static ErrorCode WRN_UnreferencedLabel;
    public static ErrorCode ERR_UseDefViolation;
    public static ErrorCode WRN_UnreferencedVar;
    public static ErrorCode WRN_UnreferencedField;
    public static ErrorCode ERR_UseDefViolationField;
    public static ErrorCode ERR_UnassignedThis;
    public static ErrorCode ERR_AmbigQM;
    public static ErrorCode ERR_InvalidQM;
    public static ErrorCode ERR_NoBaseClass;
    public static ErrorCode ERR_BaseIllegal;
    public static ErrorCode ERR_ObjectProhibited;
    public static ErrorCode ERR_ParamUnassigned;
    public static ErrorCode ERR_InvalidArray;
    public static ErrorCode ERR_ExternHasBody;
    public static ErrorCode ERR_AbstractAndExtern;
    public static ErrorCode ERR_BadAttributeParamType;
    public static ErrorCode ERR_BadAttributeArgument;
    public static ErrorCode WRN_IsAlwaysTrue;
    public static ErrorCode WRN_IsAlwaysFalse;
    public static ErrorCode ERR_LockNeedsReference;
    public static ErrorCode ERR_NullNotValid;
    public static ErrorCode ERR_UseDefViolationThis;
    public static ErrorCode ERR_ArgsInvalid;
    public static ErrorCode ERR_AssgReadonly;
    public static ErrorCode ERR_RefReadonly;
    public static ErrorCode ERR_PtrExpected;
    public static ErrorCode ERR_PtrIndexSingle;
    public static ErrorCode WRN_ByRefNonAgileField;
    public static ErrorCode ERR_AssgReadonlyStatic;
    public static ErrorCode ERR_RefReadonlyStatic;
    public static ErrorCode ERR_AssgReadonlyProp;
    public static ErrorCode ERR_IllegalStatement;
    public static ErrorCode ERR_BadGetEnumerator;
    public static ErrorCode ERR_TooManyLocals;
    public static ErrorCode ERR_AbstractBaseCall;
    public static ErrorCode ERR_RefProperty;
    public static ErrorCode ERR_ManagedAddr;
    public static ErrorCode ERR_BadFixedInitType;
    public static ErrorCode ERR_FixedMustInit;
    public static ErrorCode ERR_InvalidAddrOp;
    public static ErrorCode ERR_FixedNeeded;
    public static ErrorCode ERR_FixedNotNeeded;
    public static ErrorCode ERR_UnsafeNeeded;
    public static ErrorCode ERR_OpTFRetType;
    public static ErrorCode ERR_OperatorNeedsMatch;
    public static ErrorCode ERR_BadBoolOp;
    public static ErrorCode ERR_MustHaveOpTF;
    public static ErrorCode WRN_UnreferencedVarAssg;
    public static ErrorCode ERR_CheckedOverflow;
    public static ErrorCode ERR_ConstOutOfRangeChecked;
    public static ErrorCode ERR_BadVarargs;
    public static ErrorCode ERR_ParamsMustBeArray;
    public static ErrorCode ERR_IllegalArglist;
    public static ErrorCode ERR_IllegalUnsafe;
    public static ErrorCode ERR_AmbigMember;
    public static ErrorCode ERR_BadForeachDecl;
    public static ErrorCode ERR_ParamsLast;
    public static ErrorCode ERR_SizeofUnsafe;
    public static ErrorCode ERR_DottedTypeNameNotFoundInNS;
    public static ErrorCode ERR_FieldInitRefNonstatic;
    public static ErrorCode ERR_SealedNonOverride;
    public static ErrorCode ERR_CantOverrideSealed;
    public static ErrorCode ERR_VoidError;
    public static ErrorCode ERR_ConditionalOnOverride;
    public static ErrorCode ERR_PointerInAsOrIs;
    public static ErrorCode ERR_CallingFinalizeDeprecated;
    public static ErrorCode ERR_SingleTypeNameNotFound;
    public static ErrorCode ERR_NegativeStackAllocSize;
    public static ErrorCode ERR_NegativeArraySize;
    public static ErrorCode ERR_OverrideFinalizeDeprecated;
    public static ErrorCode ERR_CallingBaseFinalizeDeprecated;
    public static ErrorCode WRN_NegativeArrayIndex;
    public static ErrorCode WRN_BadRefCompareLeft;
    public static ErrorCode WRN_BadRefCompareRight;
    public static ErrorCode ERR_BadCastInFixed;
    public static ErrorCode ERR_StackallocInCatchFinally;
    public static ErrorCode ERR_VarargsLast;
    public static ErrorCode ERR_MissingPartial;
    public static ErrorCode ERR_PartialTypeKindConflict;
    public static ErrorCode ERR_PartialModifierConflict;
    public static ErrorCode ERR_PartialMultipleBases;
    public static ErrorCode ERR_PartialWrongTypeParams;
    public static ErrorCode ERR_PartialWrongConstraints;
    public static ErrorCode ERR_NoImplicitConvCast;
    public static ErrorCode ERR_PartialMisplaced;
    public static ErrorCode ERR_ImportedCircularBase;
    public static ErrorCode ERR_UseDefViolationOut;
    public static ErrorCode ERR_ArraySizeInDeclaration;
    public static ErrorCode ERR_InaccessibleGetter;
    public static ErrorCode ERR_InaccessibleSetter;
    public static ErrorCode ERR_InvalidPropertyAccessMod;
    public static ErrorCode ERR_DuplicatePropertyAccessMods;
    public static ErrorCode ERR_PropertyAccessModInInterface;
    public static ErrorCode ERR_AccessModMissingAccessor;
    public static ErrorCode ERR_UnimplementedInterfaceAccessor;
    public static ErrorCode WRN_PatternIsAmbiguous;
    public static ErrorCode WRN_PatternStaticOrInaccessible;
    public static ErrorCode WRN_PatternBadSignature;
    public static ErrorCode ERR_FriendRefNotEqualToThis;
    public static ErrorCode WRN_SequentialOnPartialClass;
    public static ErrorCode ERR_BadConstType;
    public static ErrorCode ERR_NoNewTyvar;
    public static ErrorCode ERR_BadArity;
    public static ErrorCode ERR_BadTypeArgument;
    public static ErrorCode ERR_TypeArgsNotAllowed;
    public static ErrorCode ERR_HasNoTypeVars;
    public static ErrorCode ERR_NewConstraintNotSatisfied;
    public static ErrorCode ERR_GenericConstraintNotSatisfiedRefType;
    public static ErrorCode ERR_GenericConstraintNotSatisfiedNullableEnum;
    public static ErrorCode ERR_GenericConstraintNotSatisfiedNullableInterface;
    public static ErrorCode ERR_GenericConstraintNotSatisfiedTyVar;
    public static ErrorCode ERR_GenericConstraintNotSatisfiedValType;
    public static ErrorCode ERR_DuplicateGeneratedName;
    public static ErrorCode ERR_GlobalSingleTypeNameNotFound;
    public static ErrorCode ERR_NewBoundMustBeLast;
    public static ErrorCode WRN_MainCantBeGeneric;
    public static ErrorCode ERR_TypeVarCantBeNull;
    public static ErrorCode ERR_AttributeCantBeGeneric;
    public static ErrorCode ERR_DuplicateBound;
    public static ErrorCode ERR_ClassBoundNotFirst;
    public static ErrorCode ERR_BadRetType;
    public static ErrorCode ERR_DuplicateConstraintClause;
    public static ErrorCode ERR_CantInferMethTypeArgs;
    public static ErrorCode ERR_LocalSameNameAsTypeParam;
    public static ErrorCode ERR_AsWithTypeVar;
    public static ErrorCode WRN_UnreferencedFieldAssg;
    public static ErrorCode ERR_BadIndexerNameAttr;
    public static ErrorCode ERR_AttrArgWithTypeVars;
    public static ErrorCode ERR_NewTyvarWithArgs;
    public static ErrorCode ERR_AbstractSealedStatic;
    public static ErrorCode WRN_AmbiguousXMLReference;
    public static ErrorCode WRN_VolatileByRef;
    public static ErrorCode ERR_ComImportWithImpl;
    public static ErrorCode ERR_ComImportWithBase;
    public static ErrorCode ERR_ImplBadConstraints;
    public static ErrorCode ERR_DottedTypeNameNotFoundInAgg;
    public static ErrorCode ERR_MethGrpToNonDel;
    public static ErrorCode ERR_BadExternAlias;
    public static ErrorCode ERR_ColColWithTypeAlias;
    public static ErrorCode ERR_AliasNotFound;
    public static ErrorCode ERR_SameFullNameAggAgg;
    public static ErrorCode ERR_SameFullNameNsAgg;
    public static ErrorCode WRN_SameFullNameThisNsAgg;
    public static ErrorCode WRN_SameFullNameThisAggAgg;
    public static ErrorCode WRN_SameFullNameThisAggNs;
    public static ErrorCode ERR_SameFullNameThisAggThisNs;
    public static ErrorCode ERR_ExternAfterElements;
    public static ErrorCode WRN_GlobalAliasDefn;
    public static ErrorCode ERR_SealedStaticClass;
    public static ErrorCode ERR_PrivateAbstractAccessor;
    public static ErrorCode ERR_ValueExpected;
    public static ErrorCode ERR_UnboxNotLValue;
    public static ErrorCode ERR_AnonMethGrpInForEach;
    public static ErrorCode ERR_BadIncDecRetType;
    public static ErrorCode ERR_RefValBoundMustBeFirst;
    public static ErrorCode ERR_RefValBoundWithClass;
    public static ErrorCode ERR_NewBoundWithVal;
    public static ErrorCode ERR_RefConstraintNotSatisfied;
    public static ErrorCode ERR_ValConstraintNotSatisfied;
    public static ErrorCode ERR_CircularConstraint;
    public static ErrorCode ERR_BaseConstraintConflict;
    public static ErrorCode ERR_ConWithValCon;
    public static ErrorCode ERR_AmbigUDConv;
    public static ErrorCode WRN_AlwaysNull;
    public static ErrorCode ERR_AddrOnReadOnlyLocal;
    public static ErrorCode ERR_OverrideWithConstraints;
    public static ErrorCode ERR_AmbigOverride;
    public static ErrorCode ERR_DecConstError;
    public static ErrorCode WRN_CmpAlwaysFalse;
    public static ErrorCode WRN_FinalizeMethod;
    public static ErrorCode ERR_ExplicitImplParams;
    public static ErrorCode WRN_GotoCaseShouldConvert;
    public static ErrorCode ERR_MethodImplementingAccessor;
    public static ErrorCode WRN_NubExprIsConstBool;
    public static ErrorCode WRN_ExplicitImplCollision;
    public static ErrorCode ERR_AbstractHasBody;
    public static ErrorCode ERR_ConcreteMissingBody;
    public static ErrorCode ERR_AbstractAndSealed;
    public static ErrorCode ERR_AbstractNotVirtual;
    public static ErrorCode ERR_StaticConstant;
    public static ErrorCode ERR_CantOverrideNonFunction;
    public static ErrorCode ERR_CantOverrideNonVirtual;
    public static ErrorCode ERR_CantChangeAccessOnOverride;
    public static ErrorCode ERR_CantChangeReturnTypeOnOverride;
    public static ErrorCode ERR_CantDeriveFromSealedType;
    public static ErrorCode ERR_AbstractInConcreteClass;
    public static ErrorCode ERR_StaticConstructorWithExplicitConstructorCall;
    public static ErrorCode ERR_StaticConstructorWithAccessModifiers;
    public static ErrorCode ERR_RecursiveConstructorCall;
    public static ErrorCode ERR_ObjectCallingBaseConstructor;
    public static ErrorCode ERR_PredefinedTypeNotFound;
    public static ErrorCode ERR_StructWithBaseConstructorCall;
    public static ErrorCode ERR_StructLayoutCycle;
    public static ErrorCode ERR_InterfacesCannotContainTypes;
    public static ErrorCode ERR_InterfacesCantContainFields;
    public static ErrorCode ERR_InterfacesCantContainConstructors;
    public static ErrorCode ERR_NonInterfaceInInterfaceList;
    public static ErrorCode ERR_DuplicateInterfaceInBaseList;
    public static ErrorCode ERR_CycleInInterfaceInheritance;
    public static ErrorCode ERR_InterfaceMemberHasBody;
    public static ErrorCode ERR_HidingAbstractMethod;
    public static ErrorCode ERR_UnimplementedAbstractMethod;
    public static ErrorCode ERR_UnimplementedInterfaceMember;
    public static ErrorCode ERR_ObjectCantHaveBases;
    public static ErrorCode ERR_ExplicitInterfaceImplementationNotInterface;
    public static ErrorCode ERR_InterfaceMemberNotFound;
    public static ErrorCode ERR_ClassDoesntImplementInterface;
    public static ErrorCode ERR_ExplicitInterfaceImplementationInNonClassOrStruct;
    public static ErrorCode ERR_MemberNameSameAsType;
    public static ErrorCode ERR_EnumeratorOverflow;
    public static ErrorCode ERR_CantOverrideNonProperty;
    public static ErrorCode ERR_NoGetToOverride;
    public static ErrorCode ERR_NoSetToOverride;
    public static ErrorCode ERR_PropertyCantHaveVoidType;
    public static ErrorCode ERR_PropertyWithNoAccessors;
    public static ErrorCode ERR_NewVirtualInSealed;
    public static ErrorCode ERR_ExplicitPropertyAddingAccessor;
    public static ErrorCode ERR_ExplicitPropertyMissingAccessor;
    public static ErrorCode ERR_ConversionWithInterface;
    public static ErrorCode ERR_ConversionWithBase;
    public static ErrorCode ERR_ConversionWithDerived;
    public static ErrorCode ERR_IdentityConversion;
    public static ErrorCode ERR_ConversionNotInvolvingContainedType;
    public static ErrorCode ERR_DuplicateConversionInClass;
    public static ErrorCode ERR_OperatorsMustBeStatic;
    public static ErrorCode ERR_BadIncDecSignature;
    public static ErrorCode ERR_BadUnaryOperatorSignature;
    public static ErrorCode ERR_BadBinaryOperatorSignature;
    public static ErrorCode ERR_BadShiftOperatorSignature;
    public static ErrorCode ERR_InterfacesCantContainOperators;
    public static ErrorCode ERR_StructsCantContainDefaultConstructor;
    public static ErrorCode ERR_CantOverrideBogusMethod;
    public static ErrorCode ERR_BindToBogus;
    public static ErrorCode ERR_CantCallSpecialMethod;
    public static ErrorCode ERR_BadTypeReference;
    public static ErrorCode ERR_FieldInitializerInStruct;
    public static ErrorCode ERR_BadDestructorName;
    public static ErrorCode ERR_OnlyClassesCanContainDestructors;
    public static ErrorCode ERR_ConflictAliasAndMember;
    public static ErrorCode ERR_ConditionalOnSpecialMethod;
    public static ErrorCode ERR_ConditionalMustReturnVoid;
    public static ErrorCode ERR_DuplicateAttribute;
    public static ErrorCode ERR_ConditionalOnInterfaceMethod;
    public static ErrorCode ERR_OperatorCantReturnVoid;
    public static ErrorCode ERR_InvalidAttributeArgument;
    public static ErrorCode ERR_AttributeOnBadSymbolType;
    public static ErrorCode ERR_FloatOverflow;
    public static ErrorCode ERR_InvalidReal;
    public static ErrorCode ERR_ComImportWithoutUuidAttribute;
    public static ErrorCode ERR_InvalidNamedArgument;
    public static ErrorCode ERR_DllImportOnInvalidMethod;
    public static ErrorCode ERR_FieldCantBeRefAny;
    public static ErrorCode ERR_ArrayElementCantBeRefAny;
    public static ErrorCode WRN_DeprecatedSymbol;
    public static ErrorCode ERR_NotAnAttributeClass;
    public static ErrorCode ERR_BadNamedAttributeArgument;
    public static ErrorCode WRN_DeprecatedSymbolStr;
    public static ErrorCode ERR_DeprecatedSymbolStr;
    public static ErrorCode ERR_IndexerCantHaveVoidType;
    public static ErrorCode ERR_VirtualPrivate;
    public static ErrorCode ERR_ArrayInitToNonArrayType;
    public static ErrorCode ERR_ArrayInitInBadPlace;
    public static ErrorCode ERR_MissingStructOffset;
    public static ErrorCode WRN_ExternMethodNoImplementation;
    public static ErrorCode WRN_ProtectedInSealed;
    public static ErrorCode ERR_InterfaceImplementedByConditional;
    public static ErrorCode ERR_IllegalRefParam;
    public static ErrorCode ERR_BadArgumentToAttribute;
    public static ErrorCode ERR_StructOffsetOnBadStruct;
    public static ErrorCode ERR_StructOffsetOnBadField;
    public static ErrorCode ERR_AttributeUsageOnNonAttributeClass;
    public static ErrorCode WRN_PossibleMistakenNullStatement;
    public static ErrorCode ERR_DuplicateNamedAttributeArgument;
    public static ErrorCode ERR_DeriveFromEnumOrValueType;
    public static ErrorCode ERR_DefaultMemberOnIndexedType;
    public static ErrorCode ERR_BogusType;
    public static ErrorCode WRN_UnassignedInternalField;
    public static ErrorCode ERR_CStyleArray;
    public static ErrorCode WRN_VacuousIntegralComp;
    public static ErrorCode ERR_AbstractAttributeClass;
    public static ErrorCode ERR_BadNamedAttributeArgumentType;
    public static ErrorCode ERR_MissingPredefinedMember;
    public static ErrorCode WRN_AttributeLocationOnBadDeclaration;
    public static ErrorCode WRN_InvalidAttributeLocation;
    public static ErrorCode WRN_EqualsWithoutGetHashCode;
    public static ErrorCode WRN_EqualityOpWithoutEquals;
    public static ErrorCode WRN_EqualityOpWithoutGetHashCode;
    public static ErrorCode ERR_OutAttrOnRefParam;
    public static ErrorCode ERR_OverloadRefOut;
    public static ErrorCode ERR_LiteralDoubleCast;
    public static ErrorCode WRN_IncorrectBooleanAssg;
    public static ErrorCode ERR_ProtectedInStruct;
    public static ErrorCode ERR_InconsistentIndexerNames;
    public static ErrorCode ERR_ComImportWithUserCtor;
    public static ErrorCode ERR_FieldCantHaveVoidType;
    public static ErrorCode WRN_NonObsoleteOverridingObsolete;
    public static ErrorCode ERR_SystemVoid;
    public static ErrorCode ERR_ExplicitParamArray;
    public static ErrorCode WRN_BitwiseOrSignExtend;
    public static ErrorCode ERR_VolatileStruct;
    public static ErrorCode ERR_VolatileAndReadonly;
    public static ErrorCode ERR_AbstractField;
    public static ErrorCode ERR_BogusExplicitImpl;
    public static ErrorCode ERR_ExplicitMethodImplAccessor;
    public static ErrorCode WRN_CoClassWithoutComImport;
    public static ErrorCode ERR_ConditionalWithOutParam;
    public static ErrorCode ERR_AccessorImplementingMethod;
    public static ErrorCode ERR_AliasQualAsExpression;
    public static ErrorCode ERR_DerivingFromATyVar;
    public static ErrorCode ERR_DuplicateTypeParameter;
    public static ErrorCode WRN_TypeParameterSameAsOuterTypeParameter;
    public static ErrorCode ERR_TypeVariableSameAsParent;
    public static ErrorCode ERR_UnifyingInterfaceInstantiations;
    public static ErrorCode ERR_GenericDerivingFromAttribute;
    public static ErrorCode ERR_TyVarNotFoundInConstraint;
    public static ErrorCode ERR_BadBoundType;
    public static ErrorCode ERR_SpecialTypeAsBound;
    public static ErrorCode ERR_BadVisBound;
    public static ErrorCode ERR_LookupInTypeVariable;
    public static ErrorCode ERR_BadConstraintType;
    public static ErrorCode ERR_InstanceMemberInStaticClass;
    public static ErrorCode ERR_StaticBaseClass;
    public static ErrorCode ERR_ConstructorInStaticClass;
    public static ErrorCode ERR_DestructorInStaticClass;
    public static ErrorCode ERR_InstantiatingStaticClass;
    public static ErrorCode ERR_StaticDerivedFromNonObject;
    public static ErrorCode ERR_StaticClassInterfaceImpl;
    public static ErrorCode ERR_OperatorInStaticClass;
    public static ErrorCode ERR_ConvertToStaticClass;
    public static ErrorCode ERR_ConstraintIsStaticClass;
    public static ErrorCode ERR_GenericArgIsStaticClass;
    public static ErrorCode ERR_ArrayOfStaticClass;
    public static ErrorCode ERR_IndexerInStaticClass;
    public static ErrorCode ERR_ParameterIsStaticClass;
    public static ErrorCode ERR_ReturnTypeIsStaticClass;
    public static ErrorCode ERR_VarDeclIsStaticClass;
    public static ErrorCode ERR_BadEmptyThrowInFinally;
    public static ErrorCode ERR_InvalidSpecifier;
    public static ErrorCode WRN_AssignmentToLockOrDispose;
    public static ErrorCode ERR_ForwardedTypeInThisAssembly;
    public static ErrorCode ERR_ForwardedTypeIsNested;
    public static ErrorCode ERR_CycleInTypeForwarder;
    public static ErrorCode ERR_AssemblyNameOnNonModule;
    public static ErrorCode ERR_InvalidFwdType;
    public static ErrorCode ERR_CloseUnimplementedInterfaceMemberStatic;
    public static ErrorCode ERR_CloseUnimplementedInterfaceMemberNotPublic;
    public static ErrorCode ERR_CloseUnimplementedInterfaceMemberWrongReturnType;
    public static ErrorCode ERR_DuplicateTypeForwarder;
    public static ErrorCode ERR_ExpectedSelectOrGroup;
    public static ErrorCode ERR_ExpectedContextualKeywordOn;
    public static ErrorCode ERR_ExpectedContextualKeywordEquals;
    public static ErrorCode ERR_ExpectedContextualKeywordBy;
    public static ErrorCode ERR_InvalidAnonymousTypeMemberDeclarator;
    public static ErrorCode ERR_InvalidInitializerElementInitializer;
    public static ErrorCode ERR_InconsistentLambdaParameterUsage;
    public static ErrorCode ERR_PartialMethodInvalidModifier;
    public static ErrorCode ERR_PartialMethodOnlyInPartialClass;
    public static ErrorCode ERR_PartialMethodCannotHaveOutParameters;
    public static ErrorCode ERR_PartialMethodOnlyMethods;
    public static ErrorCode ERR_PartialMethodNotExplicit;
    public static ErrorCode ERR_PartialMethodExtensionDifference;
    public static ErrorCode ERR_PartialMethodOnlyOneLatent;
    public static ErrorCode ERR_PartialMethodOnlyOneActual;
    public static ErrorCode ERR_PartialMethodParamsDifference;
    public static ErrorCode ERR_PartialMethodMustHaveLatent;
    public static ErrorCode ERR_PartialMethodInconsistentConstraints;
    public static ErrorCode ERR_PartialMethodToDelegate;
    public static ErrorCode ERR_PartialMethodStaticDifference;
    public static ErrorCode ERR_PartialMethodUnsafeDifference;
    public static ErrorCode ERR_PartialMethodInExpressionTree;
    public static ErrorCode ERR_PartialMethodMustReturnVoid;
    public static ErrorCode ERR_ExplicitImplCollisionOnRefOut;
    public static ErrorCode ERR_IndirectRecursiveConstructorCall;
    public static ErrorCode WRN_ObsoleteOverridingNonObsolete;
    public static ErrorCode WRN_DebugFullNameTooLong;
    public static ErrorCode ERR_ImplicitlyTypedVariableAssignedBadValue;
    public static ErrorCode ERR_ImplicitlyTypedVariableWithNoInitializer;
    public static ErrorCode ERR_ImplicitlyTypedVariableMultipleDeclarator;
    public static ErrorCode ERR_ImplicitlyTypedVariableAssignedArrayInitializer;
    public static ErrorCode ERR_ImplicitlyTypedLocalCannotBeFixed;
    public static ErrorCode ERR_ImplicitlyTypedVariableCannotBeConst;
    public static ErrorCode WRN_ExternCtorNoImplementation;
    public static ErrorCode ERR_TypeVarNotFound;
    public static ErrorCode ERR_ImplicitlyTypedArrayNoBestType;
    public static ErrorCode ERR_AnonymousTypePropertyAssignedBadValue;
    public static ErrorCode ERR_ExpressionTreeContainsBaseAccess;
    public static ErrorCode ERR_ExpressionTreeContainsAssignment;
    public static ErrorCode ERR_AnonymousTypeDuplicatePropertyName;
    public static ErrorCode ERR_StatementLambdaToExpressionTree;
    public static ErrorCode ERR_ExpressionTreeMustHaveDelegate;
    public static ErrorCode ERR_AnonymousTypeNotAvailable;
    public static ErrorCode ERR_LambdaInIsAs;
    public static ErrorCode ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer;
    public static ErrorCode ERR_MissingArgument;
    public static ErrorCode ERR_VariableUsedBeforeDeclaration;
    public static ErrorCode ERR_ExplicitLayoutAndAutoImplementedProperty;
    public static ErrorCode ERR_UnassignedThisAutoProperty;
    public static ErrorCode ERR_VariableUsedBeforeDeclarationAndHidesField;
    public static ErrorCode ERR_ExpressionTreeContainsBadCoalesce;
    public static ErrorCode ERR_ArrayInitializerExpected;
    public static ErrorCode ERR_ArrayInitializerIncorrectLength;
    public static ErrorCode ERR_OverloadRefOutCtor;
    public static ErrorCode ERR_ExpressionTreeContainsNamedArgument;
    public static ErrorCode ERR_ExpressionTreeContainsOptionalArgument;
    public static ErrorCode ERR_ExpressionTreeContainsIndexedProperty;
    public static ErrorCode ERR_IndexedPropertyRequiresParams;
    public static ErrorCode ERR_IndexedPropertyMustHaveAllOptionalParams;
    public static ErrorCode ERR_IdentifierExpected;
    public static ErrorCode ERR_SemicolonExpected;
    public static ErrorCode ERR_SyntaxError;
    public static ErrorCode ERR_DuplicateModifier;
    public static ErrorCode ERR_DuplicateAccessor;
    public static ErrorCode ERR_IntegralTypeExpected;
    public static ErrorCode ERR_IllegalEscape;
    public static ErrorCode ERR_NewlineInConst;
    public static ErrorCode ERR_EmptyCharConst;
    public static ErrorCode ERR_TooManyCharsInConst;
    public static ErrorCode ERR_InvalidNumber;
    public static ErrorCode ERR_GetOrSetExpected;
    public static ErrorCode ERR_ClassTypeExpected;
    public static ErrorCode ERR_NamedArgumentExpected;
    public static ErrorCode ERR_TooManyCatches;
    public static ErrorCode ERR_ThisOrBaseExpected;
    public static ErrorCode ERR_OvlUnaryOperatorExpected;
    public static ErrorCode ERR_OvlBinaryOperatorExpected;
    public static ErrorCode ERR_IntOverflow;
    public static ErrorCode ERR_EOFExpected;
    public static ErrorCode ERR_BadEmbeddedStmt;
    public static ErrorCode ERR_PPDirectiveExpected;
    public static ErrorCode ERR_EndOfPPLineExpected;
    public static ErrorCode ERR_CloseParenExpected;
    public static ErrorCode ERR_EndifDirectiveExpected;
    public static ErrorCode ERR_UnexpectedDirective;
    public static ErrorCode ERR_ErrorDirective;
    public static ErrorCode WRN_WarningDirective;
    public static ErrorCode ERR_TypeExpected;
    public static ErrorCode ERR_PPDefFollowsToken;
    public static ErrorCode ERR_OpenEndedComment;
    public static ErrorCode ERR_OvlOperatorExpected;
    public static ErrorCode ERR_EndRegionDirectiveExpected;
    public static ErrorCode ERR_UnterminatedStringLit;
    public static ErrorCode ERR_BadDirectivePlacement;
    public static ErrorCode ERR_IdentifierExpectedKW;
    public static ErrorCode ERR_SemiOrLBraceExpected;
    public static ErrorCode ERR_MultiTypeInDeclaration;
    public static ErrorCode ERR_AddOrRemoveExpected;
    public static ErrorCode ERR_UnexpectedCharacter;
    public static ErrorCode ERR_ProtectedInStatic;
    public static ErrorCode WRN_UnreachableGeneralCatch;
    public static ErrorCode ERR_IncrementLvalueExpected;
    public static ErrorCode ERR_NoSuchMemberOrExtension;
    public static ErrorCode WRN_DeprecatedCollectionInitAddStr;
    public static ErrorCode ERR_DeprecatedCollectionInitAddStr;
    public static ErrorCode WRN_DeprecatedCollectionInitAdd;
    public static ErrorCode ERR_DefaultValueNotAllowed;
    public static ErrorCode WRN_DefaultValueForUnconsumedLocation;
    public static ErrorCode ERR_PartialWrongTypeParamsVariance;
    public static ErrorCode ERR_GlobalSingleTypeNameNotFoundFwd;
    public static ErrorCode ERR_DottedTypeNameNotFoundInNSFwd;
    public static ErrorCode ERR_SingleTypeNameNotFoundFwd;
    public static ErrorCode WRN_IdentifierOrNumericLiteralExpected;
    public static ErrorCode ERR_UnexpectedToken;
    public static ErrorCode ERR_BadThisParam;
    public static ErrorCode ERR_BadRefWithThis;
    public static ErrorCode ERR_BadOutWithThis;
    public static ErrorCode ERR_BadTypeforThis;
    public static ErrorCode ERR_BadParamModThis;
    public static ErrorCode ERR_BadExtensionMeth;
    public static ErrorCode ERR_BadExtensionAgg;
    public static ErrorCode ERR_DupParamMod;
    public static ErrorCode ERR_MultiParamMod;
    public static ErrorCode ERR_ExtensionMethodsDecl;
    public static ErrorCode ERR_ExtensionAttrNotFound;
    public static ErrorCode ERR_ExplicitExtension;
    public static ErrorCode ERR_ValueTypeExtDelegate;
    public static ErrorCode ERR_BadArgCount;
    public static ErrorCode ERR_BadArgType;
    public static ErrorCode ERR_NoSourceFile;
    public static ErrorCode ERR_CantRefResource;
    public static ErrorCode ERR_ResourceNotUnique;
    public static ErrorCode ERR_ImportNonAssembly;
    public static ErrorCode ERR_RefLvalueExpected;
    public static ErrorCode ERR_BaseInStaticMeth;
    public static ErrorCode ERR_BaseInBadContext;
    public static ErrorCode ERR_RbraceExpected;
    public static ErrorCode ERR_LbraceExpected;
    public static ErrorCode ERR_InExpected;
    public static ErrorCode ERR_InvalidPreprocExpr;
    public static ErrorCode ERR_InvalidMemberDecl;
    public static ErrorCode ERR_MemberNeedsType;
    public static ErrorCode ERR_BadBaseType;
    public static ErrorCode WRN_EmptySwitch;
    public static ErrorCode ERR_ExpectedEndTry;
    public static ErrorCode ERR_InvalidExprTerm;
    public static ErrorCode ERR_BadNewExpr;
    public static ErrorCode ERR_NoNamespacePrivate;
    public static ErrorCode ERR_BadVarDecl;
    public static ErrorCode ERR_UsingAfterElements;
    public static ErrorCode ERR_BadBinOpArgs;
    public static ErrorCode ERR_BadUnOpArgs;
    public static ErrorCode ERR_NoVoidParameter;
    public static ErrorCode ERR_DuplicateAlias;
    public static ErrorCode ERR_BadProtectedAccess;
    public static ErrorCode ERR_AddModuleAssembly;
    public static ErrorCode ERR_BindToBogusProp2;
    public static ErrorCode ERR_BindToBogusProp1;
    public static ErrorCode ERR_NoVoidHere;
    public static ErrorCode ERR_IndexerNeedsParam;
    public static ErrorCode ERR_BadArraySyntax;
    public static ErrorCode ERR_BadOperatorSyntax;
    public static ErrorCode ERR_MainClassNotFound;
    public static ErrorCode ERR_MainClassNotClass;
    public static ErrorCode ERR_NoMainInClass;
    public static ErrorCode ERR_OutputNeedsName;
    public static ErrorCode ERR_CantHaveWin32ResAndManifest;
    public static ErrorCode ERR_CantHaveWin32ResAndIcon;
    public static ErrorCode ERR_CantReadResource;
    public static ErrorCode WRN_XMLParseError;
    public static ErrorCode WRN_DuplicateParamTag;
    public static ErrorCode WRN_UnmatchedParamTag;
    public static ErrorCode WRN_MissingParamTag;
    public static ErrorCode WRN_BadXMLRef;
    public static ErrorCode ERR_BadStackAllocExpr;
    public static ErrorCode ERR_InvalidLineNumber;
    public static ErrorCode ERR_MissingPPFile;
    public static ErrorCode ERR_ForEachMissingMember;
    public static ErrorCode WRN_BadXMLRefParamType;
    public static ErrorCode WRN_BadXMLRefReturnType;
    public static ErrorCode ERR_BadWin32Res;
    public static ErrorCode WRN_BadXMLRefSyntax;
    public static ErrorCode ERR_BadModifierLocation;
    public static ErrorCode ERR_MissingArraySize;
    public static ErrorCode WRN_UnprocessedXMLComment;
    public static ErrorCode WRN_FailedInclude;
    public static ErrorCode WRN_InvalidInclude;
    public static ErrorCode WRN_MissingXMLComment;
    public static ErrorCode WRN_XMLParseIncludeError;
    public static ErrorCode ERR_BadDelArgCount;
    public static ErrorCode ERR_UnexpectedSemicolon;
    public static ErrorCode ERR_MethodReturnCantBeRefAny;
    public static ErrorCode ERR_CompileCancelled;
    public static ErrorCode ERR_MethodArgCantBeRefAny;
    public static ErrorCode ERR_AssgReadonlyLocal;
    public static ErrorCode ERR_RefReadonlyLocal;
    public static ErrorCode WRN_ALinkWarn;
    public static ErrorCode ERR_CantUseRequiredAttribute;
    public static ErrorCode ERR_NoModifiersOnAccessor;
    public static ErrorCode ERR_ParamsCantBeRefOut;
    public static ErrorCode ERR_ReturnNotLValue;
    public static ErrorCode ERR_MissingCoClass;
    public static ErrorCode ERR_AmbiguousAttribute;
    public static ErrorCode ERR_BadArgExtraRef;
    public static ErrorCode WRN_CmdOptionConflictsSource;
    public static ErrorCode ERR_BadCompatMode;
    public static ErrorCode ERR_DelegateOnConditional;
    public static ErrorCode ERR_CantMakeTempFile;
    public static ErrorCode ERR_BadArgRef;
    public static ErrorCode ERR_YieldInAnonMeth;
    public static ErrorCode ERR_ReturnInIterator;
    public static ErrorCode ERR_BadIteratorArgType;
    public static ErrorCode ERR_BadIteratorReturn;
    public static ErrorCode ERR_BadYieldInFinally;
    public static ErrorCode ERR_BadYieldInTryOfCatch;
    public static ErrorCode ERR_EmptyYield;
    public static ErrorCode ERR_AnonDelegateCantUse;
    public static ErrorCode ERR_IllegalInnerUnsafe;
    public static ErrorCode ERR_BadYieldInCatch;
    public static ErrorCode ERR_BadDelegateLeave;
    public static ErrorCode WRN_IllegalPragma;
    public static ErrorCode WRN_IllegalPPWarning;
    public static ErrorCode WRN_BadRestoreNumber;
    public static ErrorCode ERR_VarargsIterator;
    public static ErrorCode ERR_UnsafeIteratorArgType;
    public static ErrorCode ERR_BadCoClassSig;
    public static ErrorCode ERR_MultipleIEnumOfT;
    public static ErrorCode ERR_FixedDimsRequired;
    public static ErrorCode ERR_FixedNotInStruct;
    public static ErrorCode ERR_AnonymousReturnExpected;
    public static ErrorCode WRN_NonECMAFeature;
    public static ErrorCode ERR_ExpectedVerbatimLiteral;
    public static ErrorCode ERR_AssgReadonly2;
    public static ErrorCode ERR_RefReadonly2;
    public static ErrorCode ERR_AssgReadonlyStatic2;
    public static ErrorCode ERR_RefReadonlyStatic2;
    public static ErrorCode ERR_AssgReadonlyLocal2Cause;
    public static ErrorCode ERR_RefReadonlyLocal2Cause;
    public static ErrorCode ERR_AssgReadonlyLocalCause;
    public static ErrorCode ERR_RefReadonlyLocalCause;
    public static ErrorCode WRN_ErrorOverride;
    public static ErrorCode ERR_AnonMethToNonDel;
    public static ErrorCode ERR_CantConvAnonMethParams;
    public static ErrorCode ERR_CantConvAnonMethReturns;
    public static ErrorCode ERR_IllegalFixedType;
    public static ErrorCode ERR_FixedOverflow;
    public static ErrorCode ERR_InvalidFixedArraySize;
    public static ErrorCode ERR_FixedBufferNotFixed;
    public static ErrorCode ERR_AttributeNotOnAccessor;
    public static ErrorCode WRN_InvalidSearchPathDir;
    public static ErrorCode ERR_IllegalVarArgs;
    public static ErrorCode ERR_IllegalParams;
    public static ErrorCode ERR_BadModifiersOnNamespace;
    public static ErrorCode ERR_BadPlatformType;
    public static ErrorCode ERR_ThisStructNotInAnonMeth;
    public static ErrorCode ERR_NoConvToIDisp;
    public static ErrorCode ERR_BadParamRef;
    public static ErrorCode ERR_BadParamExtraRef;
    public static ErrorCode ERR_BadParamType;
    public static ErrorCode ERR_BadExternIdentifier;
    public static ErrorCode ERR_AliasMissingFile;
    public static ErrorCode ERR_GlobalExternAlias;
    public static ErrorCode WRN_MultiplePredefTypes;
    public static ErrorCode ERR_LocalCantBeFixedAndHoisted;
    public static ErrorCode WRN_TooManyLinesForDebugger;
    public static ErrorCode ERR_CantConvAnonMethNoParams;
    public static ErrorCode ERR_ConditionalOnNonAttributeClass;
    public static ErrorCode WRN_CallOnNonAgileField;
    public static ErrorCode WRN_InvalidNumber;
    public static ErrorCode WRN_IllegalPPChecksum;
    public static ErrorCode WRN_EndOfPPLineExpected;
    public static ErrorCode WRN_ConflictingChecksum;
    public static ErrorCode WRN_InvalidAssemblyName;
    public static ErrorCode WRN_UnifyReferenceMajMin;
    public static ErrorCode WRN_UnifyReferenceBldRev;
    public static ErrorCode ERR_DuplicateImport;
    public static ErrorCode ERR_DuplicateImportSimple;
    public static ErrorCode ERR_AssemblyMatchBadVersion;
    public static ErrorCode ERR_FixedNeedsLvalue;
    public static ErrorCode WRN_DuplicateTypeParamTag;
    public static ErrorCode WRN_UnmatchedTypeParamTag;
    public static ErrorCode WRN_MissingTypeParamTag;
    public static ErrorCode ERR_CantChangeTypeOnOverride;
    public static ErrorCode ERR_DoNotUseFixedBufferAttr;
    public static ErrorCode WRN_AssignmentToSelf;
    public static ErrorCode WRN_ComparisonToSelf;
    public static ErrorCode ERR_CantOpenWin32Res;
    public static ErrorCode WRN_DotOnDefault;
    public static ErrorCode ERR_NoMultipleInheritance;
    public static ErrorCode ERR_BaseClassMustBeFirst;
    public static ErrorCode WRN_BadXMLRefTypeVar;
    public static ErrorCode ERR_FriendAssemblyBadArgs;
    public static ErrorCode ERR_FriendAssemblySNReq;
    public static ErrorCode ERR_DelegateOnNullable;
    public static ErrorCode ERR_BadCtorArgCount;
    public static ErrorCode ERR_GlobalAttributesNotFirst;
    public static ErrorCode ERR_ExpressionExpected;
    public static ErrorCode WRN_UnmatchedParamRefTag;
    public static ErrorCode WRN_UnmatchedTypeParamRefTag;
    public static ErrorCode ERR_DefaultValueMustBeConstant;
    public static ErrorCode ERR_DefaultValueBeforeRequiredValue;
    public static ErrorCode ERR_NamedArgumentSpecificationBeforeFixedArgument;
    public static ErrorCode ERR_BadNamedArgument;
    public static ErrorCode ERR_DuplicateNamedArgument;
    public static ErrorCode ERR_RefOutDefaultValue;
    public static ErrorCode ERR_NamedArgumentForArray;
    public static ErrorCode ERR_DefaultValueForExtensionParameter;
    public static ErrorCode ERR_NamedArgumentUsedInPositional;
    public static ErrorCode ERR_DefaultValueUsedWithAttributes;
    public static ErrorCode ERR_BadNamedArgumentForDelegateInvoke;
    public static ErrorCode ERR_NoPIAAssemblyMissingAttribute;
    public static ErrorCode ERR_NoCanonicalView;
    public static ErrorCode ERR_NoConversionForDefaultParam;
    public static ErrorCode ERR_DefaultValueForParamsParameter;
    public static ErrorCode ERR_NewCoClassOnLink;
    public static ErrorCode ERR_NoPIANestedType;
    public static ErrorCode ERR_InteropTypeMissingAttribute;
    public static ErrorCode ERR_InteropStructContainsMethods;
    public static ErrorCode ERR_InteropTypesWithSameNameAndGuid;
    public static ErrorCode ERR_NoPIAAssemblyMissingAttributes;
    public static ErrorCode ERR_AssemblySpecifiedForLinkAndRef;
    public static ErrorCode ERR_LocalTypeNameClash;
    public static ErrorCode WRN_ReferencedAssemblyReferencesLinkedPIA;
    public static ErrorCode ERR_NotNullRefDefaultParameter;
    public static ErrorCode ERR_FixedLocalInLambda;
    public static ErrorCode ERR_MissingMethodOnSourceInterface;
    public static ErrorCode ERR_MissingSourceInterface;
    public static ErrorCode ERR_GenericsUsedInNoPIAType;
    public static ErrorCode ERR_GenericsUsedAcrossAssemblies;
    public static ErrorCode ERR_NoConversionForNubDefaultParam;
    public static ErrorCode ERR_InvalidSubsystemVersion;
    public static ErrorCode ERR_InteropMethodWithBody;
    public static ErrorCode ERR_BadWarningLevel;
    public static ErrorCode ERR_BadDebugType;
    public static ErrorCode ERR_BadResourceVis;
    public static ErrorCode ERR_DefaultValueTypeMustMatch;
    public static ErrorCode ERR_DefaultValueBadValueType;
    public static ErrorCode ERR_MemberAlreadyInitialized;
    public static ErrorCode ERR_MemberCannotBeInitialized;
    public static ErrorCode ERR_StaticMemberInObjectInitializer;
    public static ErrorCode ERR_ReadonlyValueTypeInObjectInitializer;
    public static ErrorCode ERR_ValueTypePropertyInObjectInitializer;
    public static ErrorCode ERR_UnsafeTypeInObjectCreation;
    public static ErrorCode ERR_EmptyElementInitializer;
    public static ErrorCode ERR_InitializerAddHasWrongSignature;
    public static ErrorCode ERR_CollectionInitRequiresIEnumerable;
    public static ErrorCode ERR_CantOpenWin32Manifest;
    public static ErrorCode WRN_CantHaveManifestForModule;
    public static ErrorCode ERR_BadExtensionArgTypes;
    public static ErrorCode ERR_BadInstanceArgType;
    public static ErrorCode ERR_QueryDuplicateRangeVariable;
    public static ErrorCode ERR_QueryRangeVariableOverrides;
    public static ErrorCode ERR_QueryRangeVariableAssignedBadValue;
    public static ErrorCode ERR_QueryNoProviderCastable;
    public static ErrorCode ERR_QueryNoProviderStandard;
    public static ErrorCode ERR_QueryNoProvider;
    public static ErrorCode ERR_QueryOuterKey;
    public static ErrorCode ERR_QueryInnerKey;
    public static ErrorCode ERR_QueryOutRefRangeVariable;
    public static ErrorCode ERR_QueryMultipleProviders;
    public static ErrorCode ERR_QueryTypeInferenceFailedMulti;
    public static ErrorCode ERR_QueryTypeInferenceFailed;
    public static ErrorCode ERR_QueryTypeInferenceFailedSelectMany;
    public static ErrorCode ERR_ExpressionTreeContainsPointerOp;
    public static ErrorCode ERR_ExpressionTreeContainsAnonymousMethod;
    public static ErrorCode ERR_AnonymousMethodToExpressionTree;
    public static ErrorCode ERR_QueryRangeVariableReadOnly;
    public static ErrorCode ERR_QueryRangeVariableSameAsTypeParam;
    public static ErrorCode ERR_TypeVarNotFoundRangeVariable;
    public static ErrorCode ERR_BadArgTypesForCollectionAdd;
    public static ErrorCode ERR_ByRefParameterInExpressionTree;
    public static ErrorCode ERR_VarArgsInExpressionTree;
    public static ErrorCode ERR_InitializerAddHasParamModifiers;
    public static ErrorCode ERR_NonInvocableMemberCalled;
    public static ErrorCode WRN_MultipleRuntimeImplementationMatches;
    public static ErrorCode WRN_MultipleRuntimeOverrideMatches;
    public static ErrorCode ERR_ObjectOrCollectionInitializerWithDelegateCreation;
    public static ErrorCode ERR_InvalidConstantDeclarationType;
    public static ErrorCode ERR_IllegalVarianceSyntax;
    public static ErrorCode ERR_UnexpectedVariance;
    public static ErrorCode ERR_BadDynamicTypeof;
    public static ErrorCode ERR_ExpressionTreeContainsDynamicOperation;
    public static ErrorCode ERR_BadDynamicConversion;
    public static ErrorCode ERR_DeriveFromDynamic;
    public static ErrorCode ERR_DeriveFromConstructedDynamic;
    public static ErrorCode ERR_DynamicTypeAsBound;
    public static ErrorCode ERR_ConstructedDynamicTypeAsBound;
    public static ErrorCode ERR_DynamicRequiredTypesMissing;
    public static ErrorCode ERR_ExplicitDynamicAttr;
    public static ErrorCode ERR_NoDynamicPhantomOnBase;
    public static ErrorCode ERR_NoDynamicPhantomOnBaseIndexer;
    public static ErrorCode ERR_BadArgTypeDynamicExtension;
    public static ErrorCode WRN_DynamicDispatchToConditionalMethod;
    public static ErrorCode ERR_NoDynamicPhantomOnBaseCtor;
    public static ErrorCode ERR_BadDynamicMethodArgMemgrp;
    public static ErrorCode ERR_BadDynamicMethodArgLambda;
    public static ErrorCode ERR_BadDynamicMethodArg;
    public static ErrorCode ERR_BadDynamicQuery;
    public static ErrorCode ERR_DynamicAttributeMissing;
    public static ErrorCode WRN_IsDynamicIsConfusing;
    public static ErrorCode ERR_DynamicNotAllowedInAttribute;
    public static ErrorCode ERR_BadAsyncReturn;
    public static ErrorCode ERR_BadAwaitInFinally;
    public static ErrorCode ERR_BadAwaitInCatch;
    public static ErrorCode ERR_BadAwaitArg;
    public static ErrorCode ERR_BadAsyncArgType;
    public static ErrorCode ERR_BadAsyncExpressionTree;
    public static ErrorCode ERR_WindowsRuntimeTypesMissing;
    public static ErrorCode ERR_MixingWinRTEventWithRegular;
    public static ErrorCode ERR_BadAwaitWithoutAsync;
    public static ErrorCode ERR_MissingAsyncTypes;
    public static ErrorCode ERR_BadAsyncLacksBody;
    public static ErrorCode ERR_BadAwaitInQuery;
    public static ErrorCode ERR_BadAwaitInLock;
    public static ErrorCode ERR_TaskRetNoObjectRequired;
    public static ErrorCode WRN_AsyncLacksAwaits;
    public static ErrorCode ERR_FileNotFound;
    public static ErrorCode WRN_FileAlreadyIncluded;
    public static ErrorCode ERR_NoFileSpec;
    public static ErrorCode ERR_SwitchNeedsString;
    public static ErrorCode ERR_BadSwitch;
    public static ErrorCode WRN_NoSources;
    public static ErrorCode ERR_OpenResponseFile;
    public static ErrorCode ERR_CantOpenFileWrite;
    public static ErrorCode ERR_BadBaseNumber;
    public static ErrorCode ERR_BinaryFile;
    public static ErrorCode FTL_BadCodepage;
    public static ErrorCode ERR_NoMainOnDLL;
    public static ErrorCode FTL_InvalidTarget;
    public static ErrorCode FTL_InputFileNameTooLong;
    public static ErrorCode WRN_NoConfigNotOnCommandLine;
    public static ErrorCode ERR_InvalidFileAlignment;
    public static ErrorCode WRN_DefineIdentifierRequired;
    public static ErrorCode FTL_OutputFileExists;
    public static ErrorCode ERR_OneAliasPerReference;
    public static ErrorCode ERR_SwitchNeedsNumber;
    public static ErrorCode ERR_MissingDebugSwitch;
    public static ErrorCode ERR_ComRefCallInExpressionTree;
    public static ErrorCode WRN_BadUILang;
    public static ErrorCode ERR_InvalidFormatForGuidForOption;
    public static ErrorCode ERR_MissingGuidForOption;
    public static ErrorCode ERR_InvalidOutputName;
    public static ErrorCode ERR_InvalidDebugInformationFormat;
    public static ErrorCode ERR_LegacyObjectIdSyntax;
    public static ErrorCode WRN_CLS_NoVarArgs;
    public static ErrorCode WRN_CLS_BadArgType;
    public static ErrorCode WRN_CLS_BadReturnType;
    public static ErrorCode WRN_CLS_BadFieldPropType;
    public static ErrorCode WRN_CLS_BadIdentifierCase;
    public static ErrorCode WRN_CLS_OverloadRefOut;
    public static ErrorCode WRN_CLS_OverloadUnnamed;
    public static ErrorCode WRN_CLS_BadIdentifier;
    public static ErrorCode WRN_CLS_BadBase;
    public static ErrorCode WRN_CLS_BadInterfaceMember;
    public static ErrorCode WRN_CLS_NoAbstractMembers;
    public static ErrorCode WRN_CLS_NotOnModules;
    public static ErrorCode WRN_CLS_ModuleMissingCLS;
    public static ErrorCode WRN_CLS_AssemblyNotCLS;
    public static ErrorCode WRN_CLS_BadAttributeType;
    public static ErrorCode WRN_CLS_ArrayArgumentToAttribute;
    public static ErrorCode WRN_CLS_NotOnModules2;
    public static ErrorCode WRN_CLS_IllegalTrueInFalse;
    public static ErrorCode WRN_CLS_MeaninglessOnPrivateType;
    public static ErrorCode WRN_CLS_AssemblyNotCLS2;
    public static ErrorCode WRN_CLS_MeaninglessOnParam;
    public static ErrorCode WRN_CLS_MeaninglessOnReturn;
    public static ErrorCode WRN_CLS_BadTypeVar;
    public static ErrorCode WRN_CLS_VolatileField;
    public static ErrorCode WRN_CLS_BadInterface;
    public static ErrorCode FTL_BadChecksumAlgorithm;
    public static ErrorCode ERR_BadAwaitArgIntrinsic;
    public static ErrorCode ERR_BadAwaitAsIdentifier;
    public static ErrorCode ERR_AwaitInUnsafeContext;
    public static ErrorCode ERR_UnsafeAsyncArgType;
    public static ErrorCode ERR_VarargsAsync;
    public static ErrorCode ERR_ByRefTypeAndAwait;
    public static ErrorCode ERR_BadAwaitArgVoidCall;
    public static ErrorCode ERR_MainCantBeAsync;
    public static ErrorCode ERR_CantConvAsyncAnonFuncReturns;
    public static ErrorCode ERR_BadAwaiterPattern;
    public static ErrorCode ERR_BadSpecialByRefLocal;
    public static ErrorCode ERR_SpecialByRefInLambda;
    public static ErrorCode WRN_UnobservedAwaitableExpression;
    public static ErrorCode ERR_SynchronizedAsyncMethod;
    public static ErrorCode ERR_BadAsyncReturnExpression;
    public static ErrorCode ERR_NoConversionForCallerLineNumberParam;
    public static ErrorCode ERR_NoConversionForCallerFilePathParam;
    public static ErrorCode ERR_NoConversionForCallerMemberNameParam;
    public static ErrorCode ERR_BadCallerLineNumberParamWithoutDefaultValue;
    public static ErrorCode ERR_BadCallerFilePathParamWithoutDefaultValue;
    public static ErrorCode ERR_BadCallerMemberNameParamWithoutDefaultValue;
    public static ErrorCode ERR_BadPrefer32OnLib;
    public static ErrorCode WRN_CallerLineNumberParamForUnconsumedLocation;
    public static ErrorCode WRN_CallerFilePathParamForUnconsumedLocation;
    public static ErrorCode WRN_CallerMemberNameParamForUnconsumedLocation;
    public static ErrorCode ERR_DoesntImplementAwaitInterface;
    public static ErrorCode ERR_BadAwaitArg_NeedSystem;
    public static ErrorCode ERR_CantReturnVoid;
    public static ErrorCode ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync;
    public static ErrorCode ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct;
    public static ErrorCode ERR_BadAwaitWithoutAsyncMethod;
    public static ErrorCode ERR_BadAwaitWithoutVoidAsyncMethod;
    public static ErrorCode ERR_BadAwaitWithoutAsyncLambda;
    public static ErrorCode ERR_NoSuchMemberOrExtensionNeedUsing;
    public static ErrorCode ERR_NoEntryPoint;
    public static ErrorCode ERR_UnexpectedAliasedName;
    public static ErrorCode ERR_UnexpectedGenericName;
    public static ErrorCode ERR_UnexpectedUnboundGenericName;
    public static ErrorCode ERR_GlobalStatement;
    public static ErrorCode ERR_BadUsingType;
    public static ErrorCode ERR_ReservedAssemblyName;
    public static ErrorCode ERR_PPReferenceFollowsToken;
    public static ErrorCode ERR_ExpectedPPFile;
    public static ErrorCode ERR_ReferenceDirectiveOnlyAllowedInScripts;
    public static ErrorCode ERR_NameNotInContextPossibleMissingReference;
    public static ErrorCode ERR_MetadataNameTooLong;
    public static ErrorCode ERR_AttributesNotAllowed;
    public static ErrorCode ERR_ExternAliasNotAllowed;
    public static ErrorCode ERR_ConflictingAliasAndDefinition;
    public static ErrorCode ERR_GlobalDefinitionOrStatementExpected;
    public static ErrorCode ERR_ExpectedSingleScript;
    public static ErrorCode ERR_RecursivelyTypedVariable;
    public static ErrorCode ERR_YieldNotAllowedInScript;
    public static ErrorCode ERR_NamespaceNotAllowedInScript;
    public static ErrorCode WRN_MainIgnored;
    public static ErrorCode ERR_StaticInAsOrIs;
    public static ErrorCode ERR_InvalidDelegateType;
    public static ErrorCode ERR_BadVisEventType;
    public static ErrorCode ERR_GlobalAttributesNotAllowed;
    public static ErrorCode ERR_PublicKeyFileFailure;
    public static ErrorCode ERR_PublicKeyContainerFailure;
    public static ErrorCode ERR_FriendRefSigningMismatch;
    public static ErrorCode ERR_CannotPassNullForFriendAssembly;
    public static ErrorCode ERR_SignButNoPrivateKey;
    public static ErrorCode WRN_DelaySignButNoKey;
    public static ErrorCode ERR_InvalidVersionFormat;
    public static ErrorCode WRN_InvalidVersionFormat;
    public static ErrorCode ERR_NoCorrespondingArgument;
    public static ErrorCode ERR_ModuleEmitFailure;
    public static ErrorCode ERR_ResourceFileNameNotUnique;
    public static ErrorCode ERR_DllImportOnGenericMethod;
    public static ErrorCode ERR_EncUpdateFailedMissingAttribute;
    public static ErrorCode ERR_ParameterNotValidForType;
    public static ErrorCode ERR_AttributeParameterRequired1;
    public static ErrorCode ERR_AttributeParameterRequired2;
    public static ErrorCode ERR_SecurityAttributeMissingAction;
    public static ErrorCode ERR_SecurityAttributeInvalidAction;
    public static ErrorCode ERR_SecurityAttributeInvalidActionAssembly;
    public static ErrorCode ERR_SecurityAttributeInvalidActionTypeOrMethod;
    public static ErrorCode ERR_PrincipalPermissionInvalidAction;
    public static ErrorCode ERR_FeatureNotValidInExpressionTree;
    public static ErrorCode ERR_MarshalUnmanagedTypeNotValidForFields;
    public static ErrorCode ERR_MarshalUnmanagedTypeOnlyValidForFields;
    public static ErrorCode ERR_PermissionSetAttributeInvalidFile;
    public static ErrorCode ERR_PermissionSetAttributeFileReadError;
    public static ErrorCode ERR_InvalidVersionFormat2;
    public static ErrorCode ERR_InvalidAssemblyCultureForExe;
    public static ErrorCode ERR_DuplicateAttributeInNetModule;
    public static ErrorCode ERR_CantOpenIcon;
    public static ErrorCode ERR_ErrorBuildingWin32Resources;
    public static ErrorCode ERR_IteratorInInteractive;
    public static ErrorCode ERR_BadAttributeParamDefaultArgument;
    public static ErrorCode ERR_MissingTypeInSource;
    public static ErrorCode ERR_MissingTypeInAssembly;
    public static ErrorCode ERR_SecurityAttributeInvalidTarget;
    public static ErrorCode ERR_InvalidAssemblyName;
    public static ErrorCode ERR_NoTypeDefFromModule;
    public static ErrorCode WRN_CallerFilePathPreferredOverCallerMemberName;
    public static ErrorCode WRN_CallerLineNumberPreferredOverCallerMemberName;
    public static ErrorCode WRN_CallerLineNumberPreferredOverCallerFilePath;
    public static ErrorCode ERR_InvalidDynamicCondition;
    public static ErrorCode ERR_WinRtEventPassedByRef;
    public static ErrorCode ERR_ByRefReturnUnsupported;
    public static ErrorCode ERR_NetModuleNameMismatch;
    public static ErrorCode ERR_BadCompilationOption;
    public static ErrorCode ERR_BadCompilationOptionValue;
    public static ErrorCode ERR_BadAppConfigPath;
    public static ErrorCode WRN_AssemblyAttributeFromModuleIsOverridden;
    public static ErrorCode ERR_CmdOptionConflictsSource;
    public static ErrorCode ERR_FixedBufferTooManyDimensions;
    public static ErrorCode ERR_CantReadConfigFile;
    public static ErrorCode ERR_BadAwaitInCatchFilter;
    public static ErrorCode WRN_FilterIsConstant;
    public static ErrorCode ERR_EncNoPIAReference;
    public static ErrorCode ERR_LinkedNetmoduleMetadataMustProvideFullPEImage;
    public static ErrorCode ERR_MetadataReferencesNotSupported;
    public static ErrorCode ERR_InvalidAssemblyCulture;
    public static ErrorCode ERR_EncReferenceToAddedMember;
    public static ErrorCode ERR_MutuallyExclusiveOptions;
    public static ErrorCode WRN_UnimplementedCommandLineSwitch;
    public static ErrorCode WRN_ReferencedAssemblyDoesNotHaveStrongName;
    public static ErrorCode ERR_InvalidSignaturePublicKey;
    public static ErrorCode ERR_ExportedTypeConflictsWithDeclaration;
    public static ErrorCode ERR_ExportedTypesConflict;
    public static ErrorCode ERR_ForwardedTypeConflictsWithDeclaration;
    public static ErrorCode ERR_ForwardedTypesConflict;
    public static ErrorCode ERR_ForwardedTypeConflictsWithExportedType;
    public static ErrorCode WRN_RefCultureMismatch;
    public static ErrorCode ERR_AgnosticToMachineModule;
    public static ErrorCode ERR_ConflictingMachineModule;
    public static ErrorCode WRN_ConflictingMachineAssembly;
    public static ErrorCode ERR_CryptoHashFailed;
    public static ErrorCode ERR_MissingNetModuleReference;
    public static ErrorCode ERR_NetModuleNameMustBeUnique;
    public static ErrorCode ERR_UnsupportedTransparentIdentifierAccess;
    public static ErrorCode ERR_ParamDefaultValueDiffersFromAttribute;
    public static ErrorCode WRN_UnqualifiedNestedTypeInCref;
    public static ErrorCode HDN_UnusedUsingDirective;
    public static ErrorCode HDN_UnusedExternAlias;
    public static ErrorCode WRN_NoRuntimeMetadataVersion;
    public static ErrorCode ERR_FeatureNotAvailableInVersion1;
    public static ErrorCode ERR_FeatureNotAvailableInVersion2;
    public static ErrorCode ERR_FeatureNotAvailableInVersion3;
    public static ErrorCode ERR_FeatureNotAvailableInVersion4;
    public static ErrorCode ERR_FeatureNotAvailableInVersion5;
    public static ErrorCode ERR_FieldHasMultipleDistinctConstantValues;
    public static ErrorCode ERR_ComImportWithInitializers;
    public static ErrorCode WRN_PdbLocalNameTooLong;
    public static ErrorCode ERR_RetNoObjectRequiredLambda;
    public static ErrorCode ERR_TaskRetNoObjectRequiredLambda;
    public static ErrorCode WRN_AnalyzerCannotBeCreated;
    public static ErrorCode WRN_NoAnalyzerInAssembly;
    public static ErrorCode WRN_UnableToLoadAnalyzer;
    public static ErrorCode ERR_CantReadRulesetFile;
    public static ErrorCode ERR_BadPdbData;
    public static ErrorCode INF_UnableToLoadSomeTypesInAnalyzer;
    public static ErrorCode ERR_InitializerOnNonAutoProperty;
    public static ErrorCode ERR_AutoPropertyMustHaveGetAccessor;
    public static ErrorCode ERR_AutoPropertyInitializerInInterface;
    public static ErrorCode ERR_EnumsCantContainDefaultConstructor;
    public static ErrorCode ERR_EncodinglessSyntaxTree;
    public static ErrorCode ERR_AccessorListAndExpressionBody;
    public static ErrorCode ERR_BlockBodyAndExpressionBody;
    public static ErrorCode ERR_FeatureIsExperimental;
    public static ErrorCode ERR_FeatureNotAvailableInVersion6;
    public static ErrorCode ERR_SwitchFallOut;
    public static ErrorCode ERR_NullPropagatingOpInExpressionTree;
    public static ErrorCode WRN_NubExprIsConstBool2;
    public static ErrorCode ERR_DictionaryInitializerInExpressionTree;
    public static ErrorCode ERR_ExtensionCollectionElementInitializerInExpressionTree;
    public static ErrorCode ERR_UnclosedExpressionHole;
    public static ErrorCode ERR_SingleLineCommentInExpressionHole;
    public static ErrorCode ERR_InsufficientStack;
    public static ErrorCode ERR_UseDefViolationProperty;
    public static ErrorCode ERR_AutoPropertyMustOverrideSet;
    public static ErrorCode ERR_ExpressionHasNoName;
    public static ErrorCode ERR_SubexpressionNotInNameof;
    public static ErrorCode ERR_AliasQualifiedNameNotAnExpression;
    public static ErrorCode ERR_NameofMethodGroupWithTypeParameters;
    public static ErrorCode ERR_NoAliasHere;
    public static ErrorCode ERR_UnescapedCurly;
    public static ErrorCode ERR_EscapedCurly;
    public static ErrorCode ERR_TrailingWhitespaceInFormatSpecifier;
    public static ErrorCode ERR_EmptyFormatSpecifier;
    public static ErrorCode ERR_ErrorInReferencedAssembly;
    public static ErrorCode ERR_ExternHasConstructorInitializer;
    public static ErrorCode ERR_ExpressionOrDeclarationExpected;
    public static ErrorCode ERR_NameofExtensionMethod;
    public static ErrorCode WRN_AlignmentMagnitude;
    public static ErrorCode ERR_ConstantStringTooLong;
    public static ErrorCode ERR_DebugEntryPointNotSourceMethodDefinition;
    public static ErrorCode ERR_LoadDirectiveOnlyAllowedInScripts;
    public static ErrorCode ERR_PPLoadFollowsToken;
    public static ErrorCode ERR_SourceFileReferencesNotSupported;
    public static ErrorCode ERR_BadAwaitInStaticVariableInitializer;
    public static ErrorCode ERR_InvalidPathMap;
    public static ErrorCode ERR_PublicSignButNoKey;
    public static ErrorCode ERR_TooManyUserStrings;
    public static ErrorCode ERR_PeWritingFailure;
    public static ErrorCode WRN_AttributeIgnoredWhenPublicSigning;
    public static ErrorCode ERR_OptionMustBeAbsolutePath;
}
internal static class Microsoft.CodeAnalysis.CSharp.ErrorFacts : object {
    private static string s_titleSuffix;
    private static string s_descriptionSuffix;
    private static Lazy`1<ImmutableDictionary`2<ErrorCode, string>> s_helpLinksMap;
    private static Lazy`1<ImmutableDictionary`2<ErrorCode, string>> s_categoriesMap;
    private static ResourceManager s_resourceManager;
    private static ResourceManager ResourceManager { get; }
    private static ErrorFacts();
    private static ImmutableDictionary`2<ErrorCode, string> CreateHelpLinks();
    private static ImmutableDictionary`2<ErrorCode, string> CreateCategoriesMap();
    internal static DiagnosticSeverity GetSeverity(ErrorCode code);
    public static string GetMessage(MessageID code, CultureInfo culture);
    public static string GetMessage(ErrorCode code, CultureInfo culture);
    public static LocalizableResourceString GetMessageFormat(ErrorCode code);
    public static LocalizableResourceString GetTitle(ErrorCode code);
    public static LocalizableResourceString GetDescription(ErrorCode code);
    public static string GetHelpLink(ErrorCode code);
    public static string GetCategory(ErrorCode code);
    public static string GetMessage(XmlParseErrorCode id, CultureInfo culture);
    private static ResourceManager get_ResourceManager();
    internal static int GetWarningLevel(ErrorCode code);
    internal static bool PreventsSuccessfulDelegateConversion(ErrorCode code);
    internal static bool PreventsSuccessfulDelegateConversion(DiagnosticBag diagnostics);
    internal static bool PreventsSuccessfulDelegateConversion(ImmutableArray`1<Diagnostic> diagnostics);
    public static bool IsWarning(ErrorCode code);
    public static bool IsFatal(ErrorCode code);
    public static bool IsInfo(ErrorCode code);
    public static bool IsHidden(ErrorCode code);
}
internal class Microsoft.CodeAnalysis.CSharp.ExecutableCodeBinder : Binder {
    private Symbol _memberSymbol;
    private CSharpSyntaxNode _root;
    private MethodSymbol _owner;
    private SmallDictionary`2<CSharpSyntaxNode, Binder> _lazyBinderMap;
    internal Symbol ContainingMemberOrLambda { get; }
    internal Symbol MemberSymbol { get; }
    private SmallDictionary`2<CSharpSyntaxNode, Binder> BinderMap { get; }
    internal ExecutableCodeBinder(CSharpSyntaxNode root, Symbol memberSymbol, Binder next);
    internal ExecutableCodeBinder(CSharpSyntaxNode root, Symbol memberSymbol, Binder next, BinderFlags additionalFlags);
    internal virtual Symbol get_ContainingMemberOrLambda();
    internal Symbol get_MemberSymbol();
    internal virtual Binder GetBinder(CSharpSyntaxNode node);
    private SmallDictionary`2<CSharpSyntaxNode, Binder> get_BinderMap();
}
internal class Microsoft.CodeAnalysis.CSharp.ExitPointsWalker : AbstractRegionControlFlowPass {
    private ArrayBuilder`1<LabelSymbol> _labelsInside;
    private ArrayBuilder`1<StatementSyntax> _branchesOutOf;
    private ExitPointsWalker(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion);
    protected virtual void Free();
    internal static IEnumerable`1<StatementSyntax> Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion);
    private void Analyze(Boolean& badRegion);
    public virtual BoundNode VisitLabelStatement(BoundLabelStatement node);
    public virtual BoundNode VisitDoStatement(BoundDoStatement node);
    public virtual BoundNode VisitForEachStatement(BoundForEachStatement node);
    public virtual BoundNode VisitForStatement(BoundForStatement node);
    public virtual BoundNode VisitSwitchStatement(BoundSwitchStatement node);
    public virtual BoundNode VisitWhileStatement(BoundWhileStatement node);
    protected virtual void EnterRegion();
    protected virtual void LeaveRegion();
}
internal class Microsoft.CodeAnalysis.CSharp.Expression : object {
    internal static BinaryOperationKind DeriveBinaryOperationKind(UnaryOperationKind incrementKind);
    internal static UnaryOperationKind DeriveUnaryOperationKind(UnaryOperatorKind operatorKind);
    internal static BinaryOperationKind DeriveBinaryOperationKind(BinaryOperatorKind operatorKind);
}
internal class Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter : object {
    private SyntheticBoundNodeFactory _bound;
    private TypeMap _typeMap;
    private Dictionary`2<ParameterSymbol, BoundExpression> _parameterMap;
    private bool _ignoreAccessibility;
    private int _recursionDepth;
    private NamedTypeSymbol _ExpressionType;
    private NamedTypeSymbol _ParameterExpressionType;
    private NamedTypeSymbol _ElementInitType;
    private NamedTypeSymbol _MemberBindingType;
    private NamedTypeSymbol _int32Type;
    private NamedTypeSymbol _objectType;
    private NamedTypeSymbol _nullableType;
    private NamedTypeSymbol _MemberInfoType;
    private NamedTypeSymbol _IEnumerableType;
    private NamedTypeSymbol ExpressionType { get; }
    private NamedTypeSymbol ParameterExpressionType { get; }
    private NamedTypeSymbol ElementInitType { get; }
    public NamedTypeSymbol MemberBindingType { get; }
    private NamedTypeSymbol MemberInfoType { get; }
    private DiagnosticBag Diagnostics { get; }
    private ExpressionLambdaRewriter(TypeCompilationState compilationState, TypeMap typeMap, CSharpSyntaxNode node, int recursionDepth, DiagnosticBag diagnostics);
    private NamedTypeSymbol get_ExpressionType();
    private NamedTypeSymbol get_ParameterExpressionType();
    private NamedTypeSymbol get_ElementInitType();
    public NamedTypeSymbol get_MemberBindingType();
    private NamedTypeSymbol get_MemberInfoType();
    private DiagnosticBag get_Diagnostics();
    internal static BoundNode RewriteLambda(BoundLambda node, TypeCompilationState compilationState, TypeMap typeMap, int recursionDepth, DiagnosticBag diagnostics);
    private BoundExpression TranslateLambdaBody(BoundBlock block);
    private BoundExpression Visit(BoundExpression node);
    private BoundExpression VisitExpressionWithoutStackGuard(BoundExpression node);
    private BoundExpression VisitInternal(BoundExpression node);
    private BoundExpression VisitExpressionWithStackGuard(BoundExpression node);
    private BoundExpression VisitArrayAccess(BoundArrayAccess node);
    private BoundExpression Indices(ImmutableArray`1<BoundExpression> expressions);
    private BoundExpression Expressions(ImmutableArray`1<BoundExpression> expressions);
    private BoundExpression VisitArrayCreation(BoundArrayCreation node);
    private BoundExpression VisitArrayLength(BoundArrayLength node);
    private BoundExpression VisitAsOperator(BoundAsOperator node);
    private BoundExpression VisitBaseReference(BoundBaseReference node);
    private string GetBinaryOperatorName(BinaryOperatorKind opKind, Boolean& isChecked, Boolean& isLifted, Boolean& requiresLifted);
    private BoundExpression VisitBinaryOperator(BinaryOperatorKind opKind, MethodSymbol methodOpt, TypeSymbol type, BoundExpression left, BoundExpression right);
    private static BoundExpression DemoteEnumOperand(BoundExpression operand);
    private BoundExpression VisitAndPromoteEnumOperand(BoundExpression operand, TypeSymbol promotedType, bool isChecked);
    private BoundExpression MakeBinary(MethodSymbol methodOpt, TypeSymbol type, bool isLifted, bool requiresLifted, string opName, BoundExpression loweredLeft, BoundExpression loweredRight);
    private TypeSymbol PromotedType(TypeSymbol underlying);
    private BoundExpression Demote(BoundExpression node, TypeSymbol type, bool isChecked);
    private BoundExpression ConvertIndex(BoundExpression expr, TypeSymbol oldType, TypeSymbol newType);
    private BoundExpression VisitCall(BoundCall node);
    private BoundExpression VisitConditionalOperator(BoundConditionalOperator node);
    private BoundExpression VisitExactType(BoundExpression e);
    private BoundExpression VisitConversion(BoundConversion node);
    private BoundExpression Convert(BoundExpression operand, TypeSymbol oldType, TypeSymbol newType, bool isChecked, bool isExplicit);
    private BoundExpression Convert(BoundExpression expr, TypeSymbol type, bool isChecked);
    private BoundExpression DelegateCreation(BoundExpression receiver, MethodSymbol method, TypeSymbol delegateType, bool staticMember);
    private BoundExpression VisitDelegateCreationExpression(BoundDelegateCreationExpression node);
    private BoundExpression VisitFieldAccess(BoundFieldAccess node);
    private BoundExpression VisitIsOperator(BoundIsOperator node);
    private BoundExpression VisitLambda(BoundLambda node);
    private BoundExpression VisitLambdaInternal(BoundLambda node);
    private BoundExpression VisitNewT(BoundNewT node);
    private BoundExpression VisitNullCoalescingOperator(BoundNullCoalescingOperator node);
    private BoundExpression MakeConversionLambda(Conversion conversion, TypeSymbol fromType, TypeSymbol toType);
    private BoundExpression InitializerMemberSetter(Symbol symbol);
    private BoundExpression InitializerMemberGetter(Symbol symbol);
    private BoundExpression VisitInitializer(BoundExpression node, InitializerKind& kind);
    private BoundExpression VisitObjectCreationExpression(BoundObjectCreationExpression node);
    private BoundExpression VisitObjectCreationContinued(BoundExpression creation, BoundExpression initializerExpressionOpt);
    private BoundExpression VisitObjectCreationExpressionInternal(BoundObjectCreationExpression node);
    private BoundExpression VisitParameter(BoundParameter node);
    private static BoundExpression VisitPointerIndirectionOperator(BoundPointerIndirectionOperator node);
    private static BoundExpression VisitPointerElementAccess(BoundPointerElementAccess node);
    private BoundExpression VisitPropertyAccess(BoundPropertyAccess node);
    private static BoundExpression VisitSizeOfOperator(BoundSizeOfOperator node);
    private BoundExpression VisitUnaryOperator(BoundUnaryOperator node);
    private BoundExpression ExprFactory(string name, BoundExpression[] arguments);
    private BoundExpression ExprFactory(string name, ImmutableArray`1<TypeSymbol> typeArgs, BoundExpression[] arguments);
    private BoundExpression ExprFactory(WellKnownMember method, ImmutableArray`1<TypeSymbol> typeArgs, BoundExpression[] arguments);
    private BoundExpression Constant(BoundExpression node);
}
internal class Microsoft.CodeAnalysis.CSharp.ExtensionMethodScope : ValueType {
    public Binder Binder;
    public bool SearchUsingsNotNamespace;
    public ExtensionMethodScope(Binder binder, bool searchUsingsNotNamespace);
}
internal class Microsoft.CodeAnalysis.CSharp.ExtensionMethodScopeEnumerator : ValueType {
    private Binder _binder;
    private ExtensionMethodScope _current;
    public ExtensionMethodScope Current { get; }
    public ExtensionMethodScopeEnumerator(Binder binder);
    public ExtensionMethodScope get_Current();
    public bool MoveNext();
    private static ExtensionMethodScope GetNextScope(Binder binder);
}
internal class Microsoft.CodeAnalysis.CSharp.ExtensionMethodScopes : ValueType {
    private Binder _binder;
    public ExtensionMethodScopes(Binder binder);
    public ExtensionMethodScopeEnumerator GetEnumerator();
}
internal class Microsoft.CodeAnalysis.CSharp.FirstAmongEqualsSet`1 : object {
    private HashSet`1<T> _hashSet;
    private Dictionary`2<T, T> _dictionary;
    private Func`3<T, T, int> _canonicalComparer;
    public FirstAmongEqualsSet`1(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer, Func`3<T, T, int> canonicalComparer);
    public void UnionWith(IEnumerable`1<T> items);
    private bool IsMoreCanonical(T newItem, T oldItem);
    public void IntersectWith(IEnumerable`1<T> items);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.CodeAnalysis.CSharp.FixedStatementBinder : LocalScopeBinder {
    private FixedStatementSyntax _syntax;
    public FixedStatementBinder(Binder enclosing, FixedStatementSyntax syntax);
    protected virtual ImmutableArray`1<LocalSymbol> BuildLocals();
    internal virtual ImmutableArray`1<LocalSymbol> GetDeclaredLocalsForScope(CSharpSyntaxNode node);
}
internal class Microsoft.CodeAnalysis.CSharp.FlowAnalysisPass : object {
    public static BoundBlock Rewrite(MethodSymbol method, BoundBlock block, DiagnosticBag diagnostics, bool hasTrailingExpression, bool originalBodyNested);
    private static BoundBlock AppendImplicitReturn(BoundBlock body, MethodSymbol method, CSharpSyntaxNode syntax, bool originalBodyNested);
    internal static BoundBlock AppendImplicitReturn(BoundBlock body, MethodSymbol method, CSharpSyntaxNode syntax);
    private static bool Analyze(CSharpCompilation compilation, MethodSymbol method, BoundBlock block, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.CSharp.ForEachEnumeratorInfo : object {
    public TypeSymbol CollectionType;
    public TypeSymbol ElementType;
    public MethodSymbol GetEnumeratorMethod;
    public MethodSymbol CurrentPropertyGetter;
    public MethodSymbol MoveNextMethod;
    public bool NeedsDisposeMethod;
    public Conversion CollectionConversion;
    public Conversion CurrentConversion;
    public Conversion EnumeratorConversion;
    public BinderFlags Location;
    private ForEachEnumeratorInfo(TypeSymbol collectionType, TypeSymbol elementType, MethodSymbol getEnumeratorMethod, MethodSymbol currentPropertyGetter, MethodSymbol moveNextMethod, bool needsDisposeMethod, Conversion collectionConversion, Conversion currentConversion, Conversion enumeratorConversion, BinderFlags location);
}
internal class Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder : LoopBinder {
    private static string GetEnumeratorMethodName;
    private static string CurrentPropertyName;
    private static string MoveNextMethodName;
    private ForEachStatementSyntax _syntax;
    private SourceLocalSymbol IterationVariable { get; }
    public ForEachLoopBinder(Binder enclosing, ForEachStatementSyntax syntax);
    private SourceLocalSymbol get_IterationVariable();
    protected virtual ImmutableArray`1<LocalSymbol> BuildLocals();
    internal virtual BoundStatement BindForEachParts(DiagnosticBag diagnostics, Binder originalBinder);
    private BoundForEachStatement BindForEachPartsWorker(DiagnosticBag diagnostics, Binder originalBinder);
    internal TypeSymbol InferCollectionElementType(DiagnosticBag diagnostics, ExpressionSyntax collectionSyntax);
    private bool GetEnumeratorInfoAndInferCollectionElementType(Builder& builder, BoundExpression& collectionExpr, DiagnosticBag diagnostics, TypeSymbol& inferredType);
    private void UnwrapCollectionExpressionIfNullable(BoundExpression& collectionExpr, DiagnosticBag diagnostics);
    private bool GetEnumeratorInfo(Builder& builder, BoundExpression collectionExpr, DiagnosticBag diagnostics);
    private Builder GetDefaultEnumeratorInfo(Builder builder, DiagnosticBag diagnostics, TypeSymbol collectionExprType);
    private bool SatisfiesGetEnumeratorPattern(Builder& builder, TypeSymbol collectionExprType, DiagnosticBag diagnostics);
    private MethodSymbol FindForEachPatternMethod(TypeSymbol patternType, string methodName, LookupResult lookupResult, bool warningsOnly, DiagnosticBag diagnostics);
    private MethodSymbol PerformForEachPatternOverloadResolution(TypeSymbol patternType, ArrayBuilder`1<MethodSymbol> candidateMethods, bool warningsOnly, DiagnosticBag diagnostics);
    private bool SatisfiesForEachPattern(Builder& builder, DiagnosticBag diagnostics);
    private void ReportEnumerableWarning(DiagnosticBag diagnostics, TypeSymbol enumeratorType, Symbol patternMemberCandidate);
    private static bool IsIEnumerable(TypeSymbol type);
    private bool AllInterfacesContainsIEnumerable(Builder& builder, TypeSymbol type, DiagnosticBag diagnostics, Boolean& foundMultiple);
    private static void GetIEnumerableOfT(ImmutableArray`1<NamedTypeSymbol> interfaces, NamedTypeSymbol& result, Boolean& foundMultiple);
    private void ReportPatternMemberLookupDiagnostics(LookupResult lookupResult, TypeSymbol patternType, string memberName, bool warningsOnly, DiagnosticBag diagnostics);
}
public class Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo : ValueType {
    [CompilerGeneratedAttribute]
private IMethodSymbol <GetEnumeratorMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <MoveNextMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IPropertySymbol <CurrentProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <DisposeMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeSymbol <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private Conversion <ElementConversion>k__BackingField;
    [CompilerGeneratedAttribute]
private Conversion <CurrentConversion>k__BackingField;
    public IMethodSymbol GetEnumeratorMethod { get; }
    public IMethodSymbol MoveNextMethod { get; }
    public IPropertySymbol CurrentProperty { get; }
    public IMethodSymbol DisposeMethod { get; }
    public ITypeSymbol ElementType { get; }
    public Conversion ElementConversion { get; }
    public Conversion CurrentConversion { get; }
    internal ForEachStatementInfo(IMethodSymbol getEnumeratorMethod, IMethodSymbol moveNextMethod, IPropertySymbol currentProperty, IMethodSymbol disposeMethod, ITypeSymbol elementType, Conversion elementConversion, Conversion currentConversion);
    [CompilerGeneratedAttribute]
public IMethodSymbol get_GetEnumeratorMethod();
    [CompilerGeneratedAttribute]
public IMethodSymbol get_MoveNextMethod();
    [CompilerGeneratedAttribute]
public IPropertySymbol get_CurrentProperty();
    [CompilerGeneratedAttribute]
public IMethodSymbol get_DisposeMethod();
    [CompilerGeneratedAttribute]
public ITypeSymbol get_ElementType();
    [CompilerGeneratedAttribute]
public Conversion get_ElementConversion();
    [CompilerGeneratedAttribute]
public Conversion get_CurrentConversion();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ForEachStatementInfo other);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.CSharp.ForLoopBinder : LoopBinder {
    private ForStatementSyntax _syntax;
    public ForLoopBinder(Binder enclosing, ForStatementSyntax syntax);
    protected virtual ImmutableArray`1<LocalSymbol> BuildLocals();
    internal virtual BoundForStatement BindForParts(DiagnosticBag diagnostics, Binder originalBinder);
    private BoundForStatement BindForParts(ForStatementSyntax node, Binder originalBinder, DiagnosticBag diagnostics);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.FunctionExtensions : object {
    [ExtensionAttribute]
public static HashSet`1<T> TransitiveClosure(Func`2<T, IEnumerable`1<T>> relation, T item);
}
internal class Microsoft.CodeAnalysis.CSharp.HostObjectModelBinder : Binder {
    public HostObjectModelBinder(Binder next);
    private TypeSymbol GetHostObjectType();
    internal virtual void LookupSymbolsInSingleBinder(LookupResult result, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, HashSet`1& useSiteDiagnostics);
    protected virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo result, LookupOptions options, Binder originalBinder);
}
internal class Microsoft.CodeAnalysis.CSharp.ImplicitlyTypedFieldBinder : Binder {
    private ConsList`1<FieldSymbol> _fieldsBeingBound;
    internal ConsList`1<FieldSymbol> FieldsBeingBound { get; }
    public ImplicitlyTypedFieldBinder(Binder next, ConsList`1<FieldSymbol> fieldsBeingBound);
    internal virtual ConsList`1<FieldSymbol> get_FieldsBeingBound();
}
internal class Microsoft.CodeAnalysis.CSharp.ImplicitlyTypedLocalBinder : Binder {
    private ConsList`1<LocalSymbol> _symbols;
    public ConsList`1<LocalSymbol> ImplicitlyTypedLocalsBeingBound { get; }
    internal LocalSymbol LocalInProgress { get; }
    public ImplicitlyTypedLocalBinder(Binder next, LocalSymbol symbol);
    public virtual ConsList`1<LocalSymbol> get_ImplicitlyTypedLocalsBeingBound();
    internal virtual LocalSymbol get_LocalInProgress();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.CSharp.ImportChain : object {
    public Imports Imports;
    public ImportChain ParentOpt;
    private ImmutableArray`1<UsedNamespaceOrType> _lazyTranslatedImports;
    private IImportScope Microsoft.Cci.IImportScope.Parent { get; }
    public ImportChain(Imports imports, ImportChain parentOpt);
    private string GetDebuggerDisplay();
    private sealed virtual override ImmutableArray`1<UsedNamespaceOrType> Microsoft.Cci.IImportScope.GetUsedNamespaces();
    public IImportScope Translate(PEModuleBuilder moduleBuilder, DiagnosticBag diagnostics);
    private ImmutableArray`1<UsedNamespaceOrType> TranslateImports(PEModuleBuilder moduleBuilder, DiagnosticBag diagnostics);
    private static ITypeReference GetTypeReference(TypeSymbol type, SyntaxNode syntaxNode, PEModuleBuilder moduleBuilder, DiagnosticBag diagnostics);
    private IAssemblyReference TryGetAssemblyScope(NamespaceSymbol namespace, PEModuleBuilder moduleBuilder, DiagnosticBag diagnostics);
    private sealed virtual override IImportScope Microsoft.Cci.IImportScope.get_Parent();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.CSharp.Imports : object {
    internal static Imports Empty;
    private CSharpCompilation _compilation;
    private DiagnosticBag _diagnostics;
    private SymbolCompletionState _state;
    public ImmutableDictionary`2<string, AliasAndUsingDirective> UsingAliases;
    public ImmutableArray`1<NamespaceOrTypeAndUsingDirective> Usings;
    public ImmutableArray`1<AliasAndExternAliasDirective> ExternAliases;
    private Imports(CSharpCompilation compilation, ImmutableDictionary`2<string, AliasAndUsingDirective> usingAliases, ImmutableArray`1<NamespaceOrTypeAndUsingDirective> usings, ImmutableArray`1<AliasAndExternAliasDirective> externs, DiagnosticBag diagnostics);
    private static Imports();
    internal string GetDebuggerDisplay();
    public static Imports FromSyntax(CSharpSyntaxNode declarationSyntax, InContainerBinder binder, ConsList`1<Symbol> basesBeingResolved, bool inUsing);
    public static Imports FromGlobalUsings(CSharpCompilation compilation);
    internal static Imports ExpandPreviousSubmissionImports(Imports previousSubmissionImports, CSharpCompilation newSubmission);
    internal static NamespaceSymbol ExpandPreviousSubmissionNamespace(NamespaceSymbol originalNamespace, NamespaceSymbol expandedGlobalNamespace);
    public static Imports FromCustomDebugInfo(CSharpCompilation compilation, ImmutableDictionary`2<string, AliasAndUsingDirective> usingAliases, ImmutableArray`1<NamespaceOrTypeAndUsingDirective> usings, ImmutableArray`1<AliasAndExternAliasDirective> externs);
    internal Imports Concat(Imports otherImports);
    private static ImmutableArray`1<AliasAndExternAliasDirective> ConcatExternAliases(ImmutableArray`1<AliasAndExternAliasDirective> externs1, ImmutableArray`1<AliasAndExternAliasDirective> externs2);
    private static ImmutableArray`1<AliasAndExternAliasDirective> BuildExternAliases(SyntaxList`1<ExternAliasDirectiveSyntax> syntaxList, InContainerBinder binder, DiagnosticBag diagnostics);
    private void MarkImportDirective(CSharpSyntaxNode directive, bool callerIsSemanticModel);
    private static void MarkImportDirective(CSharpCompilation compilation, CSharpSyntaxNode directive, bool callerIsSemanticModel);
    internal void Complete(CancellationToken cancellationToken);
    private void Validate();
    internal bool IsUsingAlias(string name, bool callerIsSemanticModel);
    internal void LookupSymbol(Binder originalBinder, LookupResult result, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, bool diagnose, HashSet`1& useSiteDiagnostics);
    internal void LookupSymbolInAliases(Binder originalBinder, LookupResult result, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, bool diagnose, HashSet`1& useSiteDiagnostics);
    internal static void LookupSymbolInUsings(ImmutableArray`1<NamespaceOrTypeAndUsingDirective> usings, Binder originalBinder, LookupResult result, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, bool diagnose, HashSet`1& useSiteDiagnostics);
    private static bool IsValidLookupCandidateInUsings(Symbol symbol);
    internal void LookupExtensionMethodsInUsings(ArrayBuilder`1<MethodSymbol> methods, string name, int arity, LookupOptions options, Binder originalBinder);
    internal void AddLookupSymbolsInfo(LookupSymbolsInfo result, LookupOptions options, Binder originalBinder);
    internal void AddLookupSymbolsInfoInAliases(LookupSymbolsInfo result, LookupOptions options, Binder originalBinder);
    private static void AddAliasSymbolToResult(LookupSymbolsInfo result, AliasSymbol aliasSymbol, LookupOptions options, Binder originalBinder);
    private static void AddLookupSymbolsInfoInUsings(ImmutableArray`1<NamespaceOrTypeAndUsingDirective> usings, LookupSymbolsInfo result, LookupOptions options, Binder originalBinder);
}
internal class Microsoft.CodeAnalysis.CSharp.InContainerBinder : Binder {
    private NamespaceOrTypeSymbol _container;
    private Func`2<ConsList`1<Symbol>, Imports> _computeImports;
    private Imports _lazyImports;
    private ImportChain _lazyImportChain;
    internal NamespaceOrTypeSymbol Container { get; }
    internal ImportChain ImportChain { get; }
    internal Symbol ContainingMemberOrLambda { get; }
    private bool IsSubmissionClass { get; }
    private bool IsScriptClass { get; }
    internal bool SupportsExtensionMethods { get; }
    internal InContainerBinder(NamespaceOrTypeSymbol container, Binder next, CSharpSyntaxNode declarationSyntax, bool inUsing);
    internal InContainerBinder(NamespaceOrTypeSymbol container, Binder next, Imports imports);
    internal InContainerBinder(Binder next, Func`2<ConsList`1<Symbol>, Imports> computeImports);
    internal NamespaceOrTypeSymbol get_Container();
    internal virtual Imports GetImports(ConsList`1<Symbol> basesBeingResolved);
    internal virtual ImportChain get_ImportChain();
    internal virtual Symbol get_ContainingMemberOrLambda();
    private bool get_IsSubmissionClass();
    private bool get_IsScriptClass();
    internal virtual bool IsAccessibleHelper(Symbol symbol, TypeSymbol accessThroughType, Boolean& failedThroughTypeCheck, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    internal virtual bool get_SupportsExtensionMethods();
    internal virtual void GetCandidateExtensionMethods(bool searchUsingsNotNamespace, ArrayBuilder`1<MethodSymbol> methods, string name, int arity, LookupOptions options, Binder originalBinder);
    internal virtual TypeSymbol GetIteratorElementType(YieldStatementSyntax node, DiagnosticBag diagnostics);
    internal virtual void LookupSymbolsInSingleBinder(LookupResult result, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, HashSet`1& useSiteDiagnostics);
    protected virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo result, LookupOptions options, Binder originalBinder);
    protected virtual SourceLocalSymbol LookupLocal(SyntaxToken nameToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.InitializerRewriter : object {
    internal static BoundTypeOrInstanceInitializers RewriteConstructor(ImmutableArray`1<BoundInitializer> boundInitializers, MethodSymbol method);
    internal static BoundTypeOrInstanceInitializers RewriteScriptInitializer(ImmutableArray`1<BoundInitializer> boundInitializers, SynthesizedInteractiveInitializerMethod method, Boolean& hasTrailingExpression);
    internal static BoundExpression GetTrailingScriptExpression(BoundStatement statement);
    private static BoundStatement RewriteFieldInitializer(BoundFieldInitializer fieldInit);
    private static BoundStatement RewriteInitializersAsStatements(BoundInitializer initializer);
}
internal class Microsoft.CodeAnalysis.CSharp.InitializerSemanticModel : MemberSemanticModel {
    private InitializerSemanticModel(CSharpCompilation compilation, CSharpSyntaxNode syntax, Symbol symbol, Binder rootBinder, SyntaxTreeSemanticModel parentSemanticModelOpt, int speculatedPosition);
    internal static InitializerSemanticModel Create(CSharpCompilation compilation, CSharpSyntaxNode syntax, FieldSymbol fieldSymbol, Binder rootBinder);
    internal static InitializerSemanticModel Create(CSharpCompilation compilation, CSharpSyntaxNode syntax, PropertySymbol propertySymbol, Binder rootBinder);
    internal static InitializerSemanticModel Create(CSharpCompilation compilation, ConstructorInitializerSyntax syntax, MethodSymbol methodSymbol, Binder rootBinder);
    internal static InitializerSemanticModel Create(CSharpCompilation compilation, ArgumentListSyntax syntax, MethodSymbol methodSymbol, Binder rootBinder);
    internal static InitializerSemanticModel Create(CSharpCompilation compilation, ParameterSyntax syntax, ParameterSymbol parameterSymbol, Binder rootBinder);
    internal static InitializerSemanticModel CreateSpeculative(SyntaxTreeSemanticModel parentSemanticModel, Symbol owner, CSharpSyntaxNode syntax, Binder rootBinder, int position);
    protected internal virtual CSharpSyntaxNode GetBindableSyntaxNode(CSharpSyntaxNode node);
    internal virtual BoundNode GetBoundRoot();
    internal virtual BoundNode Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics);
    private BoundEqualsValue BindEqualsValue(Binder binder, EqualsValueClauseSyntax equalsValue, DiagnosticBag diagnostics);
    private bool IsBindableInitializer(CSharpSyntaxNode node);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, EqualsValueClauseSyntax initializer, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, ConstructorInitializerSyntax constructorInitializer, SemanticModel& speculativeModel);
    private bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, CSharpSyntaxNode initializer, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, ArrowExpressionClauseSyntax expressionBody, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, StatementSyntax statement, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelForMethodBodyCore(SyntaxTreeSemanticModel parentModel, int position, BaseMethodDeclarationSyntax method, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelForMethodBodyCore(SyntaxTreeSemanticModel parentModel, int position, AccessorDeclarationSyntax accessor, SemanticModel& speculativeModel);
}
internal class Microsoft.CodeAnalysis.CSharp.InMethodBinder : LocalScopeBinder {
    private MultiDictionary`2<string, ParameterSymbol> _parameterMap;
    private MethodSymbol _methodSymbol;
    private SmallDictionary`2<string, Symbol> _definitionMap;
    private IteratorInfo _iteratorInfo;
    private static HashSet`1<string> s_emptySet;
    internal Symbol ContainingMemberOrLambda { get; }
    internal bool IsInMethodBody { get; }
    internal bool IsDirectlyInIterator { get; }
    internal bool IsIndirectlyInIterator { get; }
    internal GeneratedLabelSymbol BreakLabel { get; }
    internal GeneratedLabelSymbol ContinueLabel { get; }
    public InMethodBinder(MethodSymbol owner, Binder enclosing);
    private static InMethodBinder();
    private void RecordDefinition(ImmutableArray`1<T> definitions);
    protected virtual SourceLocalSymbol LookupLocal(SyntaxToken nameToken);
    internal virtual Symbol get_ContainingMemberOrLambda();
    internal virtual bool get_IsInMethodBody();
    internal void MakeIterator();
    internal virtual bool get_IsDirectlyInIterator();
    internal virtual bool get_IsIndirectlyInIterator();
    internal virtual GeneratedLabelSymbol get_BreakLabel();
    internal virtual GeneratedLabelSymbol get_ContinueLabel();
    internal virtual TypeSymbol GetIteratorElementType(YieldStatementSyntax node, DiagnosticBag diagnostics);
    private TypeSymbol GetIteratorElementTypeFromReturnType(TypeSymbol returnType, CSharpSyntaxNode errorLocationNode, DiagnosticBag diagnostics);
    internal virtual void LookupSymbolsInSingleBinder(LookupResult result, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, HashSet`1& useSiteDiagnostics);
    protected virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo result, LookupOptions options, Binder originalBinder);
    internal static bool ReportConflictWithParameter(Symbol parameter, Symbol newSymbol, string name, Location newLocation, DiagnosticBag diagnostics);
    internal virtual bool EnsureSingleDefinition(Symbol symbol, string name, Location location, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.CSharp.IteratorAndAsyncCaptureWalker : DataFlowPass {
    private OrderedSet`1<Symbol> _variablesToHoist;
    private MultiDictionary`2<Symbol, CSharpSyntaxNode> _lazyDisallowedCaptures;
    private bool _seenYieldInCurrentTry;
    private IteratorAndAsyncCaptureWalker(CSharpCompilation compilation, MethodSymbol method, BoundNode node, NeverEmptyStructTypeCache emptyStructCache, HashSet`1<Symbol> initiallyAssignedVariables);
    public static OrderedSet`1<Symbol> Analyze(CSharpCompilation compilation, MethodSymbol method, BoundNode node, DiagnosticBag diagnostics);
    private static bool HoistInDebugBuild(Symbol symbol);
    private void MarkLocalsUnassigned();
    public virtual BoundNode VisitAwaitExpression(BoundAwaitExpression node);
    public virtual BoundNode VisitYieldReturnStatement(BoundYieldReturnStatement node);
    protected virtual ImmutableArray`1<PendingBranch<LocalState>> Scan(Boolean& badRegion);
    private void CaptureVariable(Symbol variable, CSharpSyntaxNode syntax);
    protected virtual void EnterParameter(ParameterSymbol parameter);
    protected virtual void ReportUnassigned(Symbol symbol, CSharpSyntaxNode node);
    protected virtual LocalState UnreachableState();
    protected virtual void ReportUnassigned(FieldSymbol fieldSymbol, int unassignedSlot, CSharpSyntaxNode node);
    protected virtual void VisitLvalueParameter(BoundParameter node);
    public virtual BoundNode VisitParameter(BoundParameter node);
    private void TryHoistTopLevelParameter(BoundParameter node);
    public virtual BoundNode VisitFieldAccess(BoundFieldAccess node);
    public virtual BoundNode VisitThisReference(BoundThisReference node);
    public virtual BoundNode VisitBaseReference(BoundBaseReference node);
    public virtual BoundNode VisitTryStatement(BoundTryStatement node);
    protected virtual void VisitFinallyBlock(BoundStatement finallyBlock, LocalState& unsetInFinally);
}
internal class Microsoft.CodeAnalysis.CSharp.IteratorConstructor : SynthesizedInstanceConstructor {
    private ImmutableArray`1<ParameterSymbol> _parameters;
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public Accessibility DeclaredAccessibility { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.Method { get; }
    private bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.HasMethodBodyDependency { get; }
    internal IteratorConstructor(IteratorStateMachine container);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual Accessibility get_DeclaredAccessibility();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_Method();
    private sealed virtual override bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_HasMethodBodyDependency();
}
internal class Microsoft.CodeAnalysis.CSharp.IteratorFinallyMethodSymbol : SynthesizedInstanceMethodSymbol {
    private IteratorStateMachine _stateMachineType;
    private string _name;
    public string Name { get; }
    internal bool IsMetadataFinal { get; }
    public MethodKind MethodKind { get; }
    public int Arity { get; }
    public bool IsExtensionMethod { get; }
    internal bool HasSpecialName { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal MarshalPseudoCustomAttributeData ReturnValueMarshallingInformation { get; }
    internal bool RequiresSecurityObject { get; }
    public bool HidesBaseMethodsByName { get; }
    public bool IsVararg { get; }
    public bool ReturnsVoid { get; }
    public bool IsAsync { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public Symbol AssociatedSymbol { get; }
    internal CallingConvention CallingConvention { get; }
    internal bool GenerateDebugInfo { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.Method { get; }
    private bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.HasMethodBodyDependency { get; }
    public IteratorFinallyMethodSymbol(IteratorStateMachine stateMachineType, string name);
    public virtual string get_Name();
    internal virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal virtual bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_IsMetadataFinal();
    public virtual MethodKind get_MethodKind();
    public virtual int get_Arity();
    public virtual bool get_IsExtensionMethod();
    internal virtual bool get_HasSpecialName();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    internal virtual bool get_HasDeclarativeSecurity();
    public virtual DllImportData GetDllImportData();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnValueMarshallingInformation();
    internal virtual bool get_RequiresSecurityObject();
    public virtual bool get_HidesBaseMethodsByName();
    public virtual bool get_IsVararg();
    public virtual bool get_ReturnsVoid();
    public virtual bool get_IsAsync();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual Symbol get_AssociatedSymbol();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual CallingConvention get_CallingConvention();
    internal virtual bool get_GenerateDebugInfo();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsStatic();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsExtern();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_Method();
    private sealed virtual override bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_HasMethodBodyDependency();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal class Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter : MethodToStateMachineRewriter {
    private FieldSymbol _current;
    private YieldsInTryAnalysis _yieldsInTryAnalysis;
    private int _tryNestingLevel;
    private LabelSymbol _exitLabel;
    private LocalSymbol _methodValue;
    private IteratorFinallyFrame _currentFinallyFrame;
    private int _nextFinalizeState;
    internal IteratorMethodToStateMachineRewriter(SyntheticBoundNodeFactory F, MethodSymbol originalMethod, FieldSymbol state, FieldSymbol current, IReadOnlySet`1<Symbol> hoistedVariables, IReadOnlyDictionary`2<Symbol, CapturedSymbolReplacement> nonReusableLocalProxies, SynthesizedLocalOrdinalsDispenser synthesizedLocalOrdinals, VariableSlotAllocator slotAllocatorOpt, int nextFreeHoistedLocalSlot, DiagnosticBag diagnostics);
    internal void GenerateMoveNextAndDispose(BoundStatement body, SynthesizedImplementationMethod moveNextMethod, SynthesizedImplementationMethod disposeMethod);
    private BoundStatement HandleReturn(BoundStatement newBody);
    private BoundStatement EmitFinallyFrame(IteratorFinallyFrame frame, BoundLocal state);
    protected virtual BoundStatement GenerateReturn(bool finished);
    public virtual BoundNode VisitYieldBreakStatement(BoundYieldBreakStatement node);
    public virtual BoundNode VisitYieldReturnStatement(BoundYieldReturnStatement node);
    public virtual BoundNode VisitGotoStatement(BoundGotoStatement node);
    public virtual BoundNode VisitConditionalGoto(BoundConditionalGoto node);
    public virtual BoundNode VisitTryStatement(BoundTryStatement node);
    private IteratorFinallyFrame PushFrame(BoundTryStatement statement);
    private void PopFrame();
    private bool ContainsYields(BoundTryStatement statement);
    private IteratorFinallyMethodSymbol MakeSynthesizedFinally(int state);
}
internal class Microsoft.CodeAnalysis.CSharp.IteratorRewriter : StateMachineRewriter {
    private TypeSymbol _elementType;
    private bool _isEnumerable;
    private FieldSymbol _currentField;
    private FieldSymbol _initialThreadIdField;
    protected bool PreserveInitialParameterValues { get; }
    private IteratorRewriter(BoundStatement body, MethodSymbol method, bool isEnumerable, IteratorStateMachine stateMachineType, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics);
    internal static BoundStatement Rewrite(BoundStatement body, MethodSymbol method, int methodOrdinal, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics, IteratorStateMachine& stateMachineType);
    protected bool VerifyPresenceOfRequiredAPIs();
    private Symbol EnsureSpecialMember(SpecialMember member, DiagnosticBag bag);
    private void EnsureSpecialType(SpecialType type, DiagnosticBag bag);
    private void EnsureSpecialPropertyGetter(SpecialMember member, DiagnosticBag bag);
    protected virtual bool get_PreserveInitialParameterValues();
    protected virtual void GenerateControlFields();
    protected virtual void GenerateMethodImplementations();
    private void GenerateEnumeratorImplementation();
    private void GenerateEnumerableImplementation(BoundExpression& managedThreadId);
    private void GenerateConstructor(BoundExpression managedThreadId);
    protected virtual void InitializeStateMachine(ArrayBuilder`1<BoundStatement> bodyBuilder, NamedTypeSymbol frameType, LocalSymbol stateMachineLocal);
    protected virtual BoundStatement GenerateStateMachineCreation(LocalSymbol stateMachineVariable, NamedTypeSymbol frameType);
    private void GenerateMoveNextAndDispose(SynthesizedImplementationMethod moveNextMethod, SynthesizedImplementationMethod disposeMethod);
    [CompilerGeneratedAttribute]
private BoundExpression <GenerateEnumerableImplementation>b__15_1(NamedTypeSymbol stateMachineType);
    [CompilerGeneratedAttribute]
private BoundExpression <GenerateEnumerableImplementation>b__15_3(NamedTypeSymbol stateMachineType);
}
internal class Microsoft.CodeAnalysis.CSharp.IteratorStateMachine : StateMachineTypeSymbol {
    private MethodSymbol _constructor;
    private ImmutableArray`1<NamedTypeSymbol> _interfaces;
    internal TypeSymbol ElementType;
    public TypeKind TypeKind { get; }
    internal MethodSymbol Constructor { get; }
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    public IteratorStateMachine(VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, MethodSymbol iteratorMethod, int iteratorMethodOrdinal, bool isEnumerable, TypeSymbol elementType);
    public virtual TypeKind get_TypeKind();
    internal virtual MethodSymbol get_Constructor();
    internal virtual ImmutableArray`1<NamedTypeSymbol> InterfacesNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
    internal virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.LabelCollector : BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator {
    protected HashSet`1<LabelSymbol> currentLabels;
    public virtual BoundNode VisitLabelStatement(BoundLabelStatement node);
    public virtual BoundNode VisitSwitchStatement(BoundSwitchStatement node);
    public virtual BoundNode VisitSwitchLabel(BoundSwitchLabel node);
    private void CollectLabel(LabelSymbol label);
}
internal class Microsoft.CodeAnalysis.CSharp.LambdaCapturedVariable : SynthesizedFieldSymbolBase {
    private TypeSymbol _type;
    private bool _isThis;
    internal bool IsCapturedFrame { get; }
    internal bool SuppressDynamicAttribute { get; }
    private LambdaCapturedVariable(SynthesizedContainer frame, TypeSymbol type, string fieldName, bool isThisParameter);
    public static LambdaCapturedVariable Create(LambdaFrame frame, Symbol captured, Int32& uniqueId);
    private static bool IsThis(Symbol captured);
    private static string GetCapturedVariableFieldName(Symbol variable, Int32& uniqueId);
    private static TypeSymbol GetCapturedVariableFieldType(SynthesizedContainer frame, Symbol variable);
    internal virtual TypeSymbol GetFieldType(ConsList`1<FieldSymbol> fieldsBeingBound);
    internal virtual bool get_IsCapturedFrame();
    internal virtual bool get_SuppressDynamicAttribute();
}
internal enum Microsoft.CodeAnalysis.CSharp.LambdaConversionResult : Enum {
    public int value__;
    public static LambdaConversionResult Success;
    public static LambdaConversionResult BadTargetType;
    public static LambdaConversionResult BadParameterCount;
    public static LambdaConversionResult MissingSignatureWithOutParameter;
    public static LambdaConversionResult MismatchedParameterType;
    public static LambdaConversionResult RefInImplicitlyTypedLambda;
    public static LambdaConversionResult StaticTypeInImplicitlyTypedLambda;
    public static LambdaConversionResult ExpressionTreeMustHaveDelegateTypeArgument;
    public static LambdaConversionResult ExpressionTreeFromAnonymousMethod;
    public static LambdaConversionResult BindingFailed;
}
internal class Microsoft.CodeAnalysis.CSharp.LambdaFrame : SynthesizedContainer {
    private MethodSymbol _topLevelMethod;
    private MethodSymbol _constructor;
    private MethodSymbol _staticConstructor;
    private FieldSymbol _singletonCache;
    internal CSharpSyntaxNode ScopeSyntaxOpt;
    internal int ClosureOrdinal;
    public TypeKind TypeKind { get; }
    internal MethodSymbol Constructor { get; }
    internal MethodSymbol StaticConstructor { get; }
    internal FieldSymbol SingletonCache { get; }
    internal bool IsSerializable { get; }
    public Symbol ContainingSymbol { get; }
    private bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.HasMethodBodyDependency { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.Method { get; }
    internal LambdaFrame(MethodSymbol topLevelMethod, CSharpSyntaxNode scopeSyntaxOpt, DebugId methodId, DebugId closureId);
    private static string MakeName(SyntaxNode scopeSyntaxOpt, DebugId methodId, DebugId closureId);
    [ConditionalAttribute("DEBUG")]
private static void AssertIsClosureScopeSyntax(CSharpSyntaxNode syntaxOpt);
    public virtual TypeKind get_TypeKind();
    internal virtual MethodSymbol get_Constructor();
    internal MethodSymbol get_StaticConstructor();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    internal FieldSymbol get_SingletonCache();
    internal virtual bool get_IsSerializable();
    public virtual Symbol get_ContainingSymbol();
    private sealed virtual override bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_HasMethodBodyDependency();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_Method();
}
internal class Microsoft.CodeAnalysis.CSharp.LambdaFrameConstructor : SynthesizedInstanceConstructor {
    private IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.Method { get; }
    private bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.HasMethodBodyDependency { get; }
    internal LambdaFrameConstructor(LambdaFrame frame);
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_Method();
    private sealed virtual override bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_HasMethodBodyDependency();
}
internal class Microsoft.CodeAnalysis.CSharp.LambdaRewriter : MethodToClassRewriter {
    private Analysis _analysis;
    private MethodSymbol _topLevelMethod;
    private int _topLevelMethodOrdinal;
    private LambdaFrame _lazyStaticLambdaFrame;
    private Dictionary`2<ParameterSymbol, ParameterSymbol> _parameterMap;
    private Dictionary`2<BoundNode, LambdaFrame> _frames;
    private Dictionary`2<NamedTypeSymbol, Symbol> _framePointers;
    private bool _assignLocals;
    private MethodSymbol _currentMethod;
    private ParameterSymbol _currentFrameThis;
    private ArrayBuilder`1<LambdaDebugInfo> _lambdaDebugInfoBuilder;
    private int _synthesizedFieldNameIdDispenser;
    private Symbol _innermostFramePointer;
    private TypeMap _currentLambdaBodyTypeMap;
    private ImmutableArray`1<TypeParameterSymbol> _currentTypeParameters;
    private BoundExpression _thisProxyInitDeferred;
    private bool _seenBaseCall;
    private bool _inExpressionLambda;
    private ArrayBuilder`1<LocalSymbol> _addedLocals;
    private ArrayBuilder`1<BoundStatement> _addedStatements;
    protected TypeMap TypeMap { get; }
    protected MethodSymbol CurrentMethod { get; }
    protected NamedTypeSymbol ContainingType { get; }
    private LambdaRewriter(Analysis analysis, NamedTypeSymbol thisType, ParameterSymbol thisParameterOpt, MethodSymbol method, int methodOrdinal, ArrayBuilder`1<LambdaDebugInfo> lambdaDebugInfoBuilder, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics, bool assignLocals);
    protected virtual bool NeedsProxy(Symbol localOrParameter);
    public static BoundStatement Rewrite(BoundStatement loweredBody, NamedTypeSymbol thisType, ParameterSymbol thisParameter, MethodSymbol method, int methodOrdinal, ArrayBuilder`1<LambdaDebugInfo> lambdaDebugInfoBuilder, ArrayBuilder`1<ClosureDebugInfo> closureDebugInfoBuilder, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics, bool assignLocals);
    private BoundStatement AddStatementsIfNeeded(BoundStatement body);
    protected virtual TypeMap get_TypeMap();
    protected virtual MethodSymbol get_CurrentMethod();
    protected virtual NamedTypeSymbol get_ContainingType();
    private void MakeFrames(ArrayBuilder`1<ClosureDebugInfo> closureDebugInfo);
    private LambdaFrame GetFrameForScope(BoundNode scope, ArrayBuilder`1<ClosureDebugInfo> closureDebugInfo);
    private LambdaFrame GetStaticFrame(DiagnosticBag diagnostics, BoundNode lambda);
    private BoundExpression FrameOfType(CSharpSyntaxNode syntax, NamedTypeSymbol frameType);
    protected virtual BoundExpression FramePointer(CSharpSyntaxNode syntax, NamedTypeSymbol frameClass);
    private static void InsertAndFreePrologue(ArrayBuilder`1<BoundStatement> result, ArrayBuilder`1<BoundExpression> prologue);
    private T IntroduceFrame(BoundNode node, LambdaFrame frame, Func`3<ArrayBuilder`1<BoundExpression>, ArrayBuilder`1<LocalSymbol>, T> F);
    private void InitVariableProxy(CSharpSyntaxNode syntax, Symbol symbol, LocalSymbol framePointer, ArrayBuilder`1<BoundExpression> prologue);
    protected virtual BoundNode VisitUnhoistedParameter(BoundParameter node);
    public virtual BoundNode VisitThisReference(BoundThisReference node);
    public virtual BoundNode VisitBaseReference(BoundBaseReference node);
    public virtual BoundNode VisitCall(BoundCall node);
    private BoundSequence RewriteSequence(BoundSequence node, ArrayBuilder`1<BoundExpression> prologue, ArrayBuilder`1<LocalSymbol> newLocals);
    public virtual BoundNode VisitBlock(BoundBlock node);
    private BoundBlock RewriteBlock(BoundBlock node, ArrayBuilder`1<BoundExpression> prologue, ArrayBuilder`1<LocalSymbol> newLocals);
    public virtual BoundNode VisitCatchBlock(BoundCatchBlock node);
    private BoundNode RewriteCatch(BoundCatchBlock node, ArrayBuilder`1<BoundExpression> prologue, ArrayBuilder`1<LocalSymbol> newLocals);
    public virtual BoundNode VisitSequence(BoundSequence node);
    public virtual BoundNode VisitStatementList(BoundStatementList node);
    public virtual BoundNode VisitSwitchStatement(BoundSwitchStatement node);
    public virtual BoundNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node);
    public virtual BoundNode VisitConversion(BoundConversion conversion);
    private DebugId GetTopLevelMethodId();
    private DebugId GetClosureId(SyntaxNode syntax, ArrayBuilder`1<ClosureDebugInfo> closureDebugInfo);
    private DebugId GetLambdaId(SyntaxNode syntax, ClosureKind closureKind, int closureOrdinal);
    private BoundNode RewriteLambdaConversion(BoundLambda node);
    private static bool InLoopOrLambda(SyntaxNode lambdaSyntax, SyntaxNode scopeSyntax);
    public virtual BoundNode VisitLambda(BoundLambda node);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private BoundNode <>n__0(BoundSwitchStatement node);
}
internal static class Microsoft.CodeAnalysis.CSharp.LambdaUtilities : object {
    public static bool IsLambda(SyntaxNode node);
    public static bool IsNotLambda(SyntaxNode node);
    public static SyntaxNode GetLambda(SyntaxNode lambdaBody);
    internal static SyntaxNode TryGetCorrespondingLambdaBody(SyntaxNode oldBody, SyntaxNode newLambda);
    public static bool IsNotLambdaBody(SyntaxNode node);
    public static bool IsLambdaBody(SyntaxNode node, bool allowReducedLambdas);
    private static bool IsReducedSelectOrGroupByClause(SelectOrGroupClauseSyntax selectOrGroupClause, ExpressionSyntax selectOrGroupExpression);
    public static bool IsLambdaBodyStatementOrExpression(SyntaxNode node);
    public static bool IsLambdaBodyStatementOrExpression(SyntaxNode node, SyntaxNode& lambdaBody);
    public static bool TryGetLambdaBodies(SyntaxNode node, SyntaxNode& lambdaBody1, SyntaxNode& lambdaBody2);
    public static bool AreEquivalentIgnoringLambdaBodies(SyntaxNode oldNode, SyntaxNode newNode);
    internal static bool IsQueryPairLambda(SyntaxNode syntax);
    internal static bool IsClosureScope(SyntaxNode node);
}
public enum Microsoft.CodeAnalysis.CSharp.LanguageVersion : Enum {
    public int value__;
    public static LanguageVersion CSharp1;
    public static LanguageVersion CSharp2;
    public static LanguageVersion CSharp3;
    public static LanguageVersion CSharp4;
    public static LanguageVersion CSharp5;
    public static LanguageVersion CSharp6;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.LanguageVersionExtensions : object {
    [ExtensionAttribute]
internal static bool IsValid(LanguageVersion value);
    [ExtensionAttribute]
internal static object Localize(LanguageVersion value);
    [ExtensionAttribute]
internal static ErrorCode GetErrorCode(LanguageVersion version);
}
internal class Microsoft.CodeAnalysis.CSharp.LazyObsoleteDiagnosticInfo : DiagnosticInfo {
    private DiagnosticInfo _lazyActualObsoleteDiagnostic;
    private Symbol _symbol;
    private Symbol _containingSymbol;
    private BinderFlags _binderFlags;
    internal LazyObsoleteDiagnosticInfo(Symbol symbol, Symbol containingSymbol, BinderFlags binderFlags);
    internal virtual DiagnosticInfo GetResolvedInfo();
}
internal class Microsoft.CodeAnalysis.CSharp.LexicalOrderSymbolComparer : object {
    public static LexicalOrderSymbolComparer Instance;
    private static LexicalOrderSymbolComparer();
    public sealed virtual int Compare(Symbol x, Symbol y);
}
internal class Microsoft.CodeAnalysis.CSharp.LocalBinderFactory : CSharpSyntaxVisitor {
    private SmallDictionary`2<CSharpSyntaxNode, Binder> _map;
    private bool _sawYield;
    private MethodSymbol _method;
    private Binder _enclosing;
    private LocalBinderFactory(MethodSymbol method, Binder enclosing);
    private void Visit(CSharpSyntaxNode syntax, Binder enclosing);
    public static SmallDictionary`2<CSharpSyntaxNode, Binder> BuildMap(MethodSymbol method, CSharpSyntaxNode syntax, Binder enclosing, Boolean& sawYield);
    public virtual void VisitCompilationUnit(CompilationUnitSyntax node);
    public virtual void VisitMethodDeclaration(MethodDeclarationSyntax node);
    public virtual void VisitConstructorDeclaration(ConstructorDeclarationSyntax node);
    public virtual void VisitDestructorDeclaration(DestructorDeclarationSyntax node);
    public virtual void VisitAccessorDeclaration(AccessorDeclarationSyntax node);
    public virtual void VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node);
    public virtual void VisitOperatorDeclaration(OperatorDeclarationSyntax node);
    public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node);
    public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node);
    public virtual void VisitArrowExpressionClause(ArrowExpressionClauseSyntax node);
    public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node);
    public virtual void VisitGlobalStatement(GlobalStatementSyntax node);
    public virtual void VisitBlock(BlockSyntax node);
    public virtual void VisitUsingStatement(UsingStatementSyntax node);
    public virtual void VisitWhileStatement(WhileStatementSyntax node);
    public virtual void VisitDoStatement(DoStatementSyntax node);
    public virtual void VisitForStatement(ForStatementSyntax node);
    public virtual void VisitForEachStatement(ForEachStatementSyntax node);
    public virtual void VisitCheckedStatement(CheckedStatementSyntax node);
    public virtual void VisitUnsafeStatement(UnsafeStatementSyntax node);
    public virtual void VisitFixedStatement(FixedStatementSyntax node);
    public virtual void VisitLockStatement(LockStatementSyntax node);
    public virtual void VisitSwitchStatement(SwitchStatementSyntax node);
    public virtual void VisitSwitchSection(SwitchSectionSyntax node);
    public virtual void VisitIfStatement(IfStatementSyntax node);
    public virtual void VisitElseClause(ElseClauseSyntax node);
    public virtual void VisitLabeledStatement(LabeledStatementSyntax node);
    public virtual void VisitTryStatement(TryStatementSyntax node);
    public virtual void VisitCatchClause(CatchClauseSyntax node);
    public virtual void VisitCatchFilterClause(CatchFilterClauseSyntax node);
    public virtual void VisitFinallyClause(FinallyClauseSyntax node);
    public virtual void VisitYieldStatement(YieldStatementSyntax node);
    public virtual void DefaultVisit(SyntaxNode node);
    private void AddToMap(CSharpSyntaxNode node, Binder binder);
    private void VisitPossibleEmbeddedStatement(StatementSyntax statement, Binder enclosing);
}
internal class Microsoft.CodeAnalysis.CSharp.LocalInProgressBinder : Binder {
    private LocalSymbol _inProgress;
    internal LocalSymbol LocalInProgress { get; }
    internal LocalInProgressBinder(LocalSymbol inProgress, Binder next);
    internal virtual LocalSymbol get_LocalInProgress();
}
internal class Microsoft.CodeAnalysis.CSharp.LocalizableErrorArgument : ValueType {
    private MessageID _id;
    internal LocalizableErrorArgument(MessageID id);
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
internal class Microsoft.CodeAnalysis.CSharp.LocalRewriter : BoundTreeRewriterWithStackGuard {
    private CSharpCompilation _compilation;
    private SyntheticBoundNodeFactory _factory;
    private SynthesizedSubmissionFields _previousSubmissionFields;
    private bool _allowOmissionOfConditionalCalls;
    private LoweredDynamicOperationFactory _dynamicFactory;
    private bool _sawLambdas;
    private bool _inExpressionLambda;
    private bool _sawAwait;
    private bool _sawAwaitInExceptionHandler;
    private DiagnosticBag _diagnostics;
    private BoundExpression _currentConditionalAccessTarget;
    private int _currentConditionalAccessID;
    private static bool y;
    private static bool n;
    private static Boolean[0...,0...] s_needsChecked;
    private Dictionary`2<BoundNode, HashSet`1<LabelSymbol>> _lazyUnmatchedLabelCache;
    private bool GenerateDebugInfo { get; }
    private PEModuleBuilder EmitModule { get; }
    private bool IsLambdaOrExpressionBodiedMember { get; }
    private LocalRewriter(CSharpCompilation compilation, MethodSymbol containingMethod, int containingMethodOrdinal, NamedTypeSymbol containingType, SyntheticBoundNodeFactory factory, SynthesizedSubmissionFields previousSubmissionFields, bool allowOmissionOfConditionalCalls, DiagnosticBag diagnostics);
    private static LocalRewriter();
    public static BoundStatement Rewrite(CSharpCompilation compilation, MethodSymbol method, int methodOrdinal, NamedTypeSymbol containingType, BoundStatement statement, TypeCompilationState compilationState, SynthesizedSubmissionFields previousSubmissionFields, bool allowOmissionOfConditionalCalls, DiagnosticBag diagnostics, Boolean& sawLambdas, Boolean& sawAwaitInExceptionHandler);
    private bool get_GenerateDebugInfo();
    private static BoundStatement InsertPrologueSequencePoint(BoundBlock body, MethodSymbol method);
    private PEModuleBuilder get_EmitModule();
    private BoundStatement AddSequencePoint(BoundStatement node);
    public virtual BoundNode Visit(BoundNode node);
    private BoundExpression VisitExpression(BoundExpression node);
    private BoundStatement VisitStatement(BoundStatement node);
    private BoundExpression VisitExpressionImpl(BoundExpression node);
    public virtual BoundNode VisitLambda(BoundLambda node);
    public virtual BoundNode VisitBadExpression(BoundBadExpression node);
    private static BoundStatement BadStatement(BoundNode node);
    private static BoundExpression BadExpression(BoundExpression node);
    private bool TryGetWellKnownTypeMember(CSharpSyntaxNode syntax, WellKnownMember member, TSymbol& symbol, bool isOptional);
    private MethodSymbol GetSpecialTypeMethod(CSharpSyntaxNode syntax, SpecialMember specialMember);
    public virtual BoundNode VisitTypeOfOperator(BoundTypeOfOperator node);
    public virtual BoundNode VisitRefTypeOperator(BoundRefTypeOperator node);
    public virtual BoundNode VisitTypeOrInstanceInitializers(BoundTypeOrInstanceInitializers node);
    private static bool ShouldOptimizeOutInitializer(BoundStatement initializer);
    public virtual BoundNode VisitAnonymousObjectCreationExpression(BoundAnonymousObjectCreationExpression node);
    public virtual BoundNode VisitAsOperator(BoundAsOperator node);
    private BoundExpression MakeAsOperator(BoundAsOperator oldNode, CSharpSyntaxNode syntax, BoundExpression rewrittenOperand, BoundTypeExpression rewrittenTargetType, Conversion conversion, TypeSymbol rewrittenType);
    public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node);
    private BoundExpression VisitAssignmentOperator(BoundAssignmentOperator node, bool used);
    private BoundExpression MakeAssignmentOperator(CSharpSyntaxNode syntax, BoundExpression rewrittenLeft, BoundExpression rewrittenRight, TypeSymbol type, bool used, bool isChecked, bool isCompoundAssignment);
    private BoundExpression MakeDynamicSetIndex(BoundDynamicIndexerAccess indexerAccess, BoundExpression loweredReceiver, ImmutableArray`1<BoundExpression> loweredArguments, ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> refKinds, BoundExpression loweredRight, bool isCompoundAssignment, bool isChecked);
    private BoundExpression MakeStaticAssignmentOperator(CSharpSyntaxNode syntax, BoundExpression rewrittenLeft, BoundExpression rewrittenRight, TypeSymbol type, bool used);
    private BoundExpression MakePropertyAssignment(CSharpSyntaxNode syntax, BoundExpression rewrittenReceiver, PropertySymbol property, ImmutableArray`1<BoundExpression> rewrittenArguments, ImmutableArray`1<RefKind> argumentRefKindsOpt, bool expanded, ImmutableArray`1<int> argsToParamsOpt, BoundExpression rewrittenRight, TypeSymbol type, bool used);
    private static ImmutableArray`1<T> AppendToPossibleNull(ImmutableArray`1<T> possibleNull, T newElement);
    public virtual BoundNode VisitAwaitExpression(BoundAwaitExpression node);
    public virtual BoundNode VisitBinaryOperator(BoundBinaryOperator node);
    public virtual BoundNode VisitUserDefinedConditionalLogicalOperator(BoundUserDefinedConditionalLogicalOperator node);
    public BoundExpression VisitBinaryOperator(BoundBinaryOperator node, BoundUnaryOperator applyParentUnaryOperator);
    private BoundExpression MakeBinaryOperator(CSharpSyntaxNode syntax, BinaryOperatorKind operatorKind, BoundExpression loweredLeft, BoundExpression loweredRight, TypeSymbol type, MethodSymbol method, bool isPointerElementAccess, bool isCompoundAssignment, BoundUnaryOperator applyParentUnaryOperator);
    private BoundExpression MakeBinaryOperator(BoundBinaryOperator oldNode, CSharpSyntaxNode syntax, BinaryOperatorKind operatorKind, BoundExpression loweredLeft, BoundExpression loweredRight, TypeSymbol type, MethodSymbol method, bool isPointerElementAccess, bool isCompoundAssignment, BoundUnaryOperator applyParentUnaryOperator);
    private BoundExpression RewriteLiftedBinaryOperator(CSharpSyntaxNode syntax, BinaryOperatorKind operatorKind, BoundExpression loweredLeft, BoundExpression loweredRight, TypeSymbol type, MethodSymbol method);
    private BoundExpression UnconvertArrayLength(BoundArrayLength arrLength);
    private BoundExpression MakeDynamicLogicalBinaryOperator(CSharpSyntaxNode syntax, BinaryOperatorKind operatorKind, BoundExpression loweredLeft, BoundExpression loweredRight, MethodSymbol leftTruthOperator, TypeSymbol type, bool isCompoundAssignment, BoundUnaryOperator applyParentUnaryOperator);
    private static ConstantValue UnboxConstant(BoundExpression expression);
    private BoundExpression MakeTruthTestForDynamicLogicalOperator(CSharpSyntaxNode syntax, BoundExpression loweredLeft, TypeSymbol boolean, MethodSymbol leftTruthOperator, bool negative);
    private BoundExpression LowerUserDefinedBinaryOperator(CSharpSyntaxNode syntax, BinaryOperatorKind operatorKind, BoundExpression loweredLeft, BoundExpression loweredRight, TypeSymbol type, MethodSymbol method);
    private BoundExpression TrivialLiftedComparisonOperatorOptimizations(CSharpSyntaxNode syntax, BinaryOperatorKind kind, BoundExpression left, BoundExpression right, MethodSymbol method);
    private BoundExpression MakeOptimizedGetValueOrDefault(CSharpSyntaxNode syntax, BoundExpression expression);
    private BoundExpression MakeBooleanConstant(CSharpSyntaxNode syntax, bool value);
    private BoundExpression MakeOptimizedHasValue(CSharpSyntaxNode syntax, BoundExpression expression);
    private BoundExpression MakeNullableHasValue(CSharpSyntaxNode syntax, BoundExpression expression);
    private BoundExpression LowerLiftedBuiltInComparisonOperator(CSharpSyntaxNode syntax, BinaryOperatorKind kind, BoundExpression loweredLeft, BoundExpression loweredRight);
    private BoundExpression LowerLiftedUserDefinedComparisonOperator(CSharpSyntaxNode syntax, BinaryOperatorKind kind, BoundExpression loweredLeft, BoundExpression loweredRight, MethodSymbol method);
    private BoundExpression TrivialLiftedBinaryArithmeticOptimizations(CSharpSyntaxNode syntax, BinaryOperatorKind kind, BoundExpression left, BoundExpression right, TypeSymbol type, MethodSymbol method);
    private BoundExpression MakeLiftedBinaryOperatorConsequence(CSharpSyntaxNode syntax, BinaryOperatorKind kind, BoundExpression left, BoundExpression right, TypeSymbol type, MethodSymbol method);
    private static BoundExpression OptimizeLiftedArithmeticOperatorOneNull(CSharpSyntaxNode syntax, BoundExpression left, BoundExpression right, TypeSymbol type);
    private BoundExpression LowerLiftedBinaryArithmeticOperator(CSharpSyntaxNode syntax, BinaryOperatorKind kind, BoundExpression loweredLeft, BoundExpression loweredRight, TypeSymbol type, MethodSymbol method);
    private BoundExpression CaptureNullableOperandInTempIfNeeded(BoundExpression operand, ArrayBuilder`1<BoundExpression> sideeffects, ArrayBuilder`1<LocalSymbol> locals);
    private BoundExpression OptimizeLiftedBinaryArithmetic(CSharpSyntaxNode syntax, BinaryOperatorKind kind, BoundExpression left, BoundExpression right, TypeSymbol type, MethodSymbol method);
    private BoundExpression MakeNewNullableBoolean(CSharpSyntaxNode syntax, Nullable`1<bool> value);
    private BoundExpression OptimizeLiftedBooleanOperatorOneNull(CSharpSyntaxNode syntax, BinaryOperatorKind kind, BoundExpression left, BoundExpression right);
    private BoundExpression OptimizeLiftedBooleanOperatorOneNonNull(CSharpSyntaxNode syntax, BinaryOperatorKind kind, BoundExpression left, BoundExpression right);
    private BoundExpression LowerLiftedBooleanOperator(CSharpSyntaxNode syntax, BinaryOperatorKind kind, BoundExpression loweredLeft, BoundExpression loweredRight);
    private MethodSymbol GetNullableMethod(CSharpSyntaxNode syntax, TypeSymbol nullableType, SpecialMember member);
    private BoundExpression RewriteNullableNullEquality(CSharpSyntaxNode syntax, BinaryOperatorKind kind, BoundExpression loweredLeft, BoundExpression loweredRight, TypeSymbol returnType);
    private static MethodSymbol GetTruthOperator(TypeSymbol type, bool negative);
    private BoundExpression RewriteStringEquality(BoundBinaryOperator oldNode, CSharpSyntaxNode syntax, BinaryOperatorKind operatorKind, BoundExpression loweredLeft, BoundExpression loweredRight, TypeSymbol type, SpecialMember member);
    private BoundExpression RewriteDelegateOperation(CSharpSyntaxNode syntax, BinaryOperatorKind operatorKind, BoundExpression loweredLeft, BoundExpression loweredRight, TypeSymbol type, SpecialMember member);
    private BoundExpression RewriteDecimalBinaryOperation(CSharpSyntaxNode syntax, BoundExpression loweredLeft, BoundExpression loweredRight, BinaryOperatorKind operatorKind);
    private BoundExpression MakeNullCheck(CSharpSyntaxNode syntax, BoundExpression rewrittenExpr, BinaryOperatorKind operatorKind);
    private BoundExpression RewriteBuiltInShiftOperation(BoundBinaryOperator oldNode, CSharpSyntaxNode syntax, BinaryOperatorKind operatorKind, BoundExpression loweredLeft, BoundExpression loweredRight, TypeSymbol type, int rightMask);
    private BoundExpression RewritePointerNumericOperator(CSharpSyntaxNode syntax, BinaryOperatorKind kind, BoundExpression loweredLeft, BoundExpression loweredRight, TypeSymbol returnType, bool isPointerElementAccess, bool isLeftPointer);
    private BoundExpression MakeSizeOfMultiplication(BoundExpression numericOperand, PointerTypeSymbol pointerType, bool isChecked);
    private BoundExpression RewritePointerSubtraction(BinaryOperatorKind kind, BoundExpression loweredLeft, BoundExpression loweredRight, TypeSymbol returnType);
    public virtual BoundNode VisitBlock(BoundBlock node);
    public virtual BoundNode VisitNoOpStatement(BoundNoOpStatement node);
    public virtual BoundNode VisitBreakStatement(BoundBreakStatement node);
    public virtual BoundNode VisitDynamicInvocation(BoundDynamicInvocation node);
    public BoundExpression VisitDynamicInvocation(BoundDynamicInvocation node, bool resultDiscarded);
    private void EmbedIfNeedTo(BoundExpression receiver, ImmutableArray`1<MethodSymbol> methods, CSharpSyntaxNode syntaxNode);
    private void EmbedIfNeedTo(BoundExpression receiver, ImmutableArray`1<PropertySymbol> properties, CSharpSyntaxNode syntaxNode);
    public virtual BoundNode VisitCall(BoundCall node);
    private BoundExpression MakeCall(CSharpSyntaxNode syntax, BoundExpression rewrittenReceiver, MethodSymbol method, ImmutableArray`1<BoundExpression> rewrittenArguments, ImmutableArray`1<RefKind> argumentRefKindsOpt, bool expanded, bool invokedAsExtensionMethod, ImmutableArray`1<int> argsToParamsOpt, LookupResultKind resultKind, TypeSymbol type, BoundCall nodeOpt);
    private BoundExpression MakeCall(BoundCall node, CSharpSyntaxNode syntax, BoundExpression rewrittenReceiver, MethodSymbol method, ImmutableArray`1<BoundExpression> rewrittenArguments, ImmutableArray`1<RefKind> argumentRefKinds, bool invokedAsExtensionMethod, LookupResultKind resultKind, TypeSymbol type, ImmutableArray`1<LocalSymbol> temps);
    private BoundExpression MakeCall(CSharpSyntaxNode syntax, BoundExpression rewrittenReceiver, MethodSymbol method, ImmutableArray`1<BoundExpression> rewrittenArguments, TypeSymbol type);
    private static bool IsSafeForReordering(BoundExpression expression, RefKind kind);
    private ImmutableArray`1<BoundExpression> MakeArguments(CSharpSyntaxNode syntax, ImmutableArray`1<BoundExpression> rewrittenArguments, Symbol methodOrIndexer, MethodSymbol optionalParametersMethod, bool expanded, ImmutableArray`1<int> argsToParamsOpt, ImmutableArray`1& argumentRefKindsOpt, ImmutableArray`1& temps, bool invokedAsExtensionMethod, ThreeState enableCallerInfo);
    private static ImmutableArray`1<RefKind> GetRefKindsOrNull(ArrayBuilder`1<RefKind> refKinds);
    private void BuildStoresToTemps(bool expanded, ImmutableArray`1<int> argsToParamsOpt, ImmutableArray`1<RefKind> argumentRefKinds, ImmutableArray`1<BoundExpression> rewrittenArguments, BoundExpression[] arguments, ArrayBuilder`1<RefKind> refKinds, ArrayBuilder`1<BoundAssignmentOperator> storesToTemps);
    private BoundExpression BuildParamsArray(CSharpSyntaxNode syntax, Symbol methodOrIndexer, ImmutableArray`1<int> argsToParamsOpt, ImmutableArray`1<BoundExpression> rewrittenArguments, ImmutableArray`1<ParameterSymbol> parameters, BoundExpression tempStoreArgument);
    private static void OptimizeTemporaries(BoundExpression[] arguments, ArrayBuilder`1<RefKind> refKinds, ArrayBuilder`1<BoundAssignmentOperator> storesToTemps, ArrayBuilder`1<LocalSymbol> temporariesBuilder);
    private static int MergeArgumentsAndSideEffects(BoundExpression[] arguments, ArrayBuilder`1<RefKind> refKinds, ArrayBuilder`1<BoundAssignmentOperator> tempStores);
    private void InsertMissingOptionalArguments(CSharpSyntaxNode syntax, ImmutableArray`1<ParameterSymbol> parameters, BoundExpression[] arguments, ThreeState enableCallerInfo);
    private static SourceLocation GetCallerLocation(CSharpSyntaxNode syntax, ThreeState enableCallerInfo);
    private BoundExpression GetDefaultParameterValue(CSharpSyntaxNode syntax, ParameterSymbol parameter, ThreeState enableCallerInfo);
    private BoundExpression GetDefaultParameterSpecial(CSharpSyntaxNode syntax, ParameterSymbol parameter);
    private void RewriteArgumentsForComCall(ImmutableArray`1<ParameterSymbol> parameters, BoundExpression[] actualArguments, ArrayBuilder`1<RefKind> argsRefKindsBuilder, ArrayBuilder`1<LocalSymbol> temporariesBuilder);
    public virtual BoundNode VisitDynamicMemberAccess(BoundDynamicMemberAccess node);
    public virtual BoundNode VisitCompoundAssignmentOperator(BoundCompoundAssignmentOperator node);
    private BoundExpression VisitCompoundAssignmentOperator(BoundCompoundAssignmentOperator node, bool used);
    private BoundExpression TransformCompoundAssignmentLHS(BoundExpression originalLHS, ArrayBuilder`1<BoundExpression> stores, ArrayBuilder`1<LocalSymbol> temps, bool isDynamicAssignment);
    private BoundExpression BoxReceiver(BoundExpression rewrittenReceiver, NamedTypeSymbol memberContainingType);
    private BoundExpression SpillArrayElementAccess(BoundExpression loweredExpression, ImmutableArray`1<BoundExpression> loweredIndices, ArrayBuilder`1<BoundExpression> stores, ArrayBuilder`1<LocalSymbol> temps);
    internal static bool CanChangeValueBetweenReads(BoundExpression expression, bool localsMayBeAssignedOrCaptured);
    internal static bool ReadIsSideeffecting(BoundExpression expression);
    private static bool ConstantValueIsTrivial(TypeSymbol type);
    public virtual BoundNode VisitConditionalAccess(BoundConditionalAccess node);
    internal BoundExpression RewriteConditionalAccess(BoundConditionalAccess node, bool used);
    public virtual BoundNode VisitConditionalReceiver(BoundConditionalReceiver node);
    public virtual BoundNode VisitConditionalOperator(BoundConditionalOperator node);
    private static BoundExpression RewriteConditionalOperator(CSharpSyntaxNode syntax, BoundExpression rewrittenCondition, BoundExpression rewrittenConsequence, BoundExpression rewrittenAlternative, ConstantValue constantValueOpt, TypeSymbol rewrittenType);
    public virtual BoundNode VisitContinueStatement(BoundContinueStatement node);
    public virtual BoundNode VisitConversion(BoundConversion node);
    private static bool IsFloatPointExpressionOfUnknownPrecision(BoundExpression rewrittenNode);
    private BoundExpression MakeConversion(BoundConversion oldNode, CSharpSyntaxNode syntax, BoundExpression rewrittenOperand, ConversionKind conversionKind, MethodSymbol symbolOpt, bool checked, bool explicitCastInCode, bool isExtensionMethod, bool isArrayIndex, ConstantValue constantValueOpt, TypeSymbol rewrittenType);
    private static bool DistinctSpecialTypes(TypeSymbol source, TypeSymbol target);
    private static bool NeedsChecked(TypeSymbol source, TypeSymbol target);
    private BoundExpression MakeConversion(BoundExpression rewrittenOperand, TypeSymbol rewrittenType, bool checked, bool acceptFailingConversion);
    private BoundExpression MakeImplicitConversion(BoundExpression rewrittenOperand, TypeSymbol rewrittenType);
    private BoundExpression MakeConversion(CSharpSyntaxNode syntax, BoundExpression rewrittenOperand, ConversionKind conversionKind, TypeSymbol rewrittenType, bool checked, ConstantValue constantValueOpt);
    private BoundExpression MakeConversion(CSharpSyntaxNode syntax, BoundExpression rewrittenOperand, Conversion conversion, TypeSymbol rewrittenType, bool checked, bool explicitCastInCode, ConstantValue constantValueOpt);
    private BoundExpression RewriteNullableConversion(CSharpSyntaxNode syntaxNode, BoundExpression rewrittenOperand, TypeSymbol rewrittenType);
    private static bool NullableNeverHasValue(BoundExpression expression);
    private static BoundExpression NullableAlwaysHasValue(BoundExpression expression);
    private BoundExpression RewriteNullableConversion(CSharpSyntaxNode syntax, BoundExpression rewrittenOperand, ConversionKind conversionKind, bool checked, bool explicitCastInCode, TypeSymbol rewrittenType);
    private BoundExpression RewriteLiftedConversionInExpressionTree(CSharpSyntaxNode syntax, BoundExpression rewrittenOperand, ConversionKind conversionKind, bool checked, bool explicitCastInCode, TypeSymbol rewrittenType);
    private BoundExpression RewriteFullyLiftedBuiltInConversion(CSharpSyntaxNode syntax, BoundExpression operand, ConversionKind kind, bool checked, TypeSymbol type);
    private BoundExpression OptimizeLiftedUserDefinedConversion(CSharpSyntaxNode syntax, BoundExpression operand, ConversionKind kind, MethodSymbol method, TypeSymbol type);
    private BoundExpression OptimizeLiftedBuiltInConversion(CSharpSyntaxNode syntax, BoundExpression operand, ConversionKind kind, bool checked, TypeSymbol type);
    private BoundExpression DistributeLiftedConversionIntoLiftedOperand(CSharpSyntaxNode syntax, BoundExpression operand, ConversionKind kind, bool checked, MethodSymbol method, TypeSymbol type);
    private BoundExpression RewriteUserDefinedConversion(CSharpSyntaxNode syntax, BoundExpression rewrittenOperand, MethodSymbol method, TypeSymbol rewrittenType, ConversionKind conversionKind);
    private BoundExpression MakeLiftedUserDefinedConversionConsequence(BoundCall call, TypeSymbol resultType);
    private BoundExpression RewriteLiftedUserDefinedConversion(CSharpSyntaxNode syntax, BoundExpression rewrittenOperand, MethodSymbol method, TypeSymbol rewrittenType, ConversionKind conversionKind);
    private BoundExpression RewriteIntPtrConversion(BoundConversion oldNode, CSharpSyntaxNode syntax, BoundExpression rewrittenOperand, ConversionKind conversionKind, MethodSymbol symbolOpt, bool checked, bool explicitCastInCode, bool isExtensionMethod, bool isArrayIndex, ConstantValue constantValueOpt, TypeSymbol rewrittenType);
    public static SpecialMember GetIntPtrConversionMethod(TypeSymbol source, TypeSymbol target);
    internal static SpecialMember DecimalConversionMethod(TypeSymbol typeFrom, TypeSymbol typeTo);
    private BoundExpression RewriteDecimalConversion(BoundConversion oldNode, CSharpSyntaxNode syntax, BoundExpression operand, TypeSymbol fromType, TypeSymbol toType);
    private Conversion MakeConversion(CSharpSyntaxNode syntax, Conversion conversion, TypeSymbol fromType, TypeSymbol toType);
    private Conversion MakeConversion(CSharpSyntaxNode syntax, TypeSymbol fromType, TypeSymbol toType);
    private Conversion MakeUserDefinedConversion(CSharpSyntaxNode syntax, MethodSymbol meth, TypeSymbol fromType, TypeSymbol toType, bool isImplicit);
    public virtual BoundNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node);
    public virtual BoundNode VisitDoStatement(BoundDoStatement node);
    public virtual BoundNode VisitEventAssignmentOperator(BoundEventAssignmentOperator node);
    private BoundExpression RewriteWindowsRuntimeEventAssignmentOperator(CSharpSyntaxNode syntax, EventSymbol eventSymbol, EventAssignmentKind kind, bool isDynamic, BoundExpression rewrittenReceiverOpt, BoundExpression rewrittenArgument);
    private BoundExpression VisitWindowsRuntimeEventFieldAssignmentOperator(CSharpSyntaxNode syntax, BoundEventAccess left, BoundExpression right);
    public virtual BoundNode VisitEventAccess(BoundEventAccess node);
    private BoundExpression MakeEventAccess(CSharpSyntaxNode syntax, BoundExpression rewrittenReceiver, EventSymbol eventSymbol, ConstantValue constantValueOpt, LookupResultKind resultKind, TypeSymbol type);
    private BoundExpression RewriteNoPiaEventAssignmentOperator(BoundEventAssignmentOperator node, BoundExpression rewrittenReceiver, BoundExpression rewrittenArgument);
    public virtual BoundNode VisitExpressionStatement(BoundExpressionStatement node);
    private BoundExpression VisitUnusedExpression(BoundExpression expression);
    public virtual BoundNode VisitFieldAccess(BoundFieldAccess node);
    private static BoundExpression MakeFieldAccess(CSharpSyntaxNode syntax, BoundExpression rewrittenReceiver, FieldSymbol fieldSymbol, ConstantValue constantValueOpt, LookupResultKind resultKind, TypeSymbol type, BoundFieldAccess oldNodeOpt);
    public virtual BoundNode VisitFixedStatement(BoundFixedStatement node);
    private static bool IsInTryBlock(BoundFixedStatement boundFixed);
    private bool HasGotoOut(BoundNode node);
    public virtual BoundNode VisitFixedLocalCollectionInitializer(BoundFixedLocalCollectionInitializer node);
    private BoundStatement InitializeFixedStatementLocal(BoundLocalDeclaration localDecl, SyntheticBoundNodeFactory factory, LocalSymbol& temp, LocalSymbol& localToClear);
    private BoundStatement InitializeFixedStatementStringLocal(LocalSymbol localSymbol, BoundFixedLocalCollectionInitializer fixedInitializer, SyntheticBoundNodeFactory factory, LocalSymbol& stringTemp, LocalSymbol& localToClear);
    private BoundStatement InitializeFixedStatementArrayLocal(LocalSymbol localSymbol, BoundFixedLocalCollectionInitializer fixedInitializer, SyntheticBoundNodeFactory factory, LocalSymbol& arrayTemp);
    public virtual BoundNode VisitForEachStatement(BoundForEachStatement node);
    private BoundStatement RewriteEnumeratorForEachStatement(BoundForEachStatement node);
    private BoundExpression SynthesizeCall(CSharpSyntaxNode syntax, BoundExpression receiver, MethodSymbol method, Conversion receiverConversion, TypeSymbol convertedReceiverType);
    private BoundStatement RewriteStringForEachStatement(BoundForEachStatement node);
    private static BoundBlock CreateBlockDeclaringIterationVariable(LocalSymbol iterationVariable, BoundStatement iteratorVariableInitialization, BoundStatement rewrittenBody, ForEachStatementSyntax forEachSyntax);
    private BoundStatement RewriteSingleDimensionalArrayForEachStatement(BoundForEachStatement node);
    private BoundStatement RewriteMultiDimensionalArrayForEachStatement(BoundForEachStatement node);
    private static BoundExpression GetUnconvertedCollectionExpression(BoundForEachStatement node);
    private static BoundLocal MakeBoundLocal(CSharpSyntaxNode syntax, LocalSymbol local, TypeSymbol type);
    private BoundStatement MakeLocalDeclaration(CSharpSyntaxNode syntax, LocalSymbol local, BoundExpression rewrittenInitialValue);
    private BoundStatement MakePositionIncrement(CSharpSyntaxNode syntax, BoundLocal boundPositionVar, TypeSymbol intType);
    private void AddForEachExpressionSequencePoint(ForEachStatementSyntax forEachSyntax, BoundStatement& collectionVarDecl);
    private void AddForEachIterationVariableSequencePoint(ForEachStatementSyntax forEachSyntax, BoundStatement& iterationVarDecl);
    private void AddForEachKeywordSequencePoint(ForEachStatementSyntax forEachSyntax, BoundStatement& result);
    public virtual BoundNode VisitForStatement(BoundForStatement node);
    private BoundStatement RewriteForStatement(CSharpSyntaxNode syntax, ImmutableArray`1<LocalSymbol> outerLocals, BoundStatement rewrittenInitializer, BoundExpression rewrittenCondition, CSharpSyntaxNode conditionSyntaxOpt, TextSpan conditionSpanOpt, BoundStatement rewrittenIncrement, BoundStatement rewrittenBody, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel, bool hasErrors);
    public virtual BoundNode VisitGotoStatement(BoundGotoStatement node);
    public virtual BoundNode VisitLabel(BoundLabel node);
    public virtual BoundNode VisitSwitchLabel(BoundSwitchLabel node);
    public virtual BoundNode VisitHostObjectMemberReference(BoundHostObjectMemberReference node);
    public virtual BoundNode VisitIfStatement(BoundIfStatement node);
    private static BoundStatement RewriteIfStatement(CSharpSyntaxNode syntax, BoundExpression rewrittenCondition, BoundStatement rewrittenConsequence, BoundStatement rewrittenAlternativeOpt, bool hasErrors);
    private BoundExpression MakeDynamicIndexerAccessReceiver(BoundDynamicIndexerAccess indexerAccess, BoundExpression loweredReceiver);
    public virtual BoundNode VisitDynamicIndexerAccess(BoundDynamicIndexerAccess node);
    private BoundExpression MakeDynamicGetIndex(BoundDynamicIndexerAccess node, BoundExpression loweredReceiver, ImmutableArray`1<BoundExpression> loweredArguments, ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> refKinds);
    public virtual BoundNode VisitIndexerAccess(BoundIndexerAccess node);
    private BoundExpression VisitIndexerAccess(BoundIndexerAccess node, bool isLeftOfAssignment);
    private BoundExpression MakeIndexerAccess(CSharpSyntaxNode syntax, BoundExpression rewrittenReceiver, PropertySymbol indexer, ImmutableArray`1<BoundExpression> rewrittenArguments, ImmutableArray`1<string> argumentNamesOpt, ImmutableArray`1<RefKind> argumentRefKindsOpt, bool expanded, ImmutableArray`1<int> argsToParamsOpt, TypeSymbol type, BoundIndexerAccess oldNodeOpt, bool isLeftOfAssignment);
    public virtual BoundNode VisitIsOperator(BoundIsOperator node);
    private BoundExpression MakeIsOperator(BoundIsOperator oldNode, CSharpSyntaxNode syntax, BoundExpression rewrittenOperand, BoundTypeExpression rewrittenTargetType, Conversion conversion, TypeSymbol rewrittenType);
    private BoundExpression RewriteConstantIsOperator(CSharpSyntaxNode syntax, BoundExpression loweredOperand, ConstantValue constantValue, TypeSymbol type);
    public virtual BoundNode VisitLabeledStatement(BoundLabeledStatement node);
    public virtual BoundNode VisitLiteral(BoundLiteral node);
    private BoundExpression MakeLiteral(CSharpSyntaxNode syntax, ConstantValue constantValue, TypeSymbol type, BoundLiteral oldNodeOpt);
    private BoundExpression MakeDecimalLiteral(CSharpSyntaxNode syntax, ConstantValue constantValue);
    private BoundExpression MakeDateTimeLiteral(CSharpSyntaxNode syntax, ConstantValue constantValue);
    public virtual BoundNode VisitLocalDeclaration(BoundLocalDeclaration node);
    private BoundStatement RewriteLocalDeclaration(CSharpSyntaxNode syntax, LocalSymbol localSymbol, BoundExpression rewrittenInitializer, bool wasCompilerGenerated, bool hasErrors);
    private BoundStatement AddLocalDeclarationSequencePointIfNecessary(CSharpSyntaxNode syntax, LocalSymbol localSymbol, BoundStatement rewrittenLocalDeclaration, bool wasCompilerGenerated);
    public virtual BoundNode VisitLockStatement(BoundLockStatement node);
    private BoundStatement MakeInitialLockSequencePoint(BoundStatement statement, LockStatementSyntax lockSyntax);
    public virtual BoundNode VisitMultipleLocalDeclarations(BoundMultipleLocalDeclarations node);
    public virtual BoundNode VisitNullCoalescingOperator(BoundNullCoalescingOperator node);
    private BoundExpression MakeNullCoalescingOperator(CSharpSyntaxNode syntax, BoundExpression rewrittenLeft, BoundExpression rewrittenRight, Conversion leftConversion, TypeSymbol rewrittenResultType);
    private BoundExpression GetConvertedLeftForNullCoalescingOperator(BoundExpression rewrittenLeft, Conversion leftConversion, TypeSymbol rewrittenResultType);
    public virtual BoundNode VisitDynamicObjectCreationExpression(BoundDynamicObjectCreationExpression node);
    public virtual BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node);
    private BoundExpression MakeObjectCreationInitializerForExpressionTree(BoundExpression initializerExpressionOpt);
    private BoundExpression MakeObjectCreationWithInitializer(CSharpSyntaxNode syntax, BoundExpression rewrittenObjectCreation, BoundExpression initializerExpression, TypeSymbol type);
    public virtual BoundNode VisitNewT(BoundNewT node);
    private BoundExpression MakeNewT(CSharpSyntaxNode syntax, TypeParameterSymbol typeParameter);
    public virtual BoundNode VisitNoPiaObjectCreationExpression(BoundNoPiaObjectCreationExpression node);
    private static BoundExpression UpdateInitializers(BoundExpression initializerExpression, ImmutableArray`1<BoundExpression> newInitializers);
    private void AddObjectOrCollectionInitializers(ArrayBuilder`1& dynamicSiteInitializers, ArrayBuilder`1& temps, ArrayBuilder`1<BoundExpression> result, BoundExpression rewrittenReceiver, BoundExpression initializerExpression);
    private ImmutableArray`1<BoundExpression> MakeObjectOrCollectionInitializersForExpressionTree(BoundExpression initializerExpression);
    private void AddCollectionInitializers(ArrayBuilder`1& dynamicSiteInitializers, ArrayBuilder`1<BoundExpression> result, BoundExpression rewrittenReceiver, ImmutableArray`1<BoundExpression> initializers);
    private BoundExpression MakeDynamicCollectionInitializer(BoundExpression rewrittenReceiver, BoundDynamicCollectionElementInitializer initializer);
    private BoundExpression MakeCollectionInitializer(BoundExpression rewrittenReceiver, BoundCollectionElementInitializer initializer);
    private void AddObjectInitializers(ArrayBuilder`1& dynamicSiteInitializers, ArrayBuilder`1& temps, ArrayBuilder`1<BoundExpression> result, BoundExpression rewrittenReceiver, ImmutableArray`1<BoundExpression> initializers);
    private void AddObjectInitializer(ArrayBuilder`1& dynamicSiteInitializers, ArrayBuilder`1& temps, ArrayBuilder`1<BoundExpression> result, BoundExpression rewrittenReceiver, BoundAssignmentOperator assignment);
    private ImmutableArray`1<BoundExpression> EvaluateSideEffectingArgumentsToTemps(ImmutableArray`1<BoundExpression> args, ArrayBuilder`1<BoundExpression> sideeffects, ArrayBuilder`1& temps);
    private BoundExpression MakeObjectInitializerMemberAccess(BoundExpression rewrittenReceiver, BoundObjectInitializerMember rewrittenLeft, bool isRhsNestedInitializer);
    public virtual BoundNode VisitPointerElementAccess(BoundPointerElementAccess node);
    private BoundExpression RewritePointerElementAccess(BoundPointerElementAccess node, BoundExpression rewrittenExpression, BoundExpression rewrittenIndex);
    public virtual BoundNode VisitPreviousSubmissionReference(BoundPreviousSubmissionReference node);
    public virtual BoundNode VisitPropertyAccess(BoundPropertyAccess node);
    private BoundExpression VisitPropertyAccess(BoundPropertyAccess node, bool isLeftOfAssignment);
    private BoundExpression MakePropertyAccess(CSharpSyntaxNode syntax, BoundExpression rewrittenReceiverOpt, PropertySymbol propertySymbol, LookupResultKind resultKind, TypeSymbol type, bool isLeftOfAssignment, BoundPropertyAccess oldNodeOpt);
    private BoundExpression MakePropertyGetAccess(CSharpSyntaxNode syntax, BoundExpression rewrittenReceiver, PropertySymbol property, BoundPropertyAccess oldNodeOpt);
    private BoundExpression MakePropertyGetAccess(CSharpSyntaxNode syntax, BoundExpression rewrittenReceiver, PropertySymbol property, ImmutableArray`1<BoundExpression> rewrittenArguments, MethodSymbol getMethodOpt, BoundPropertyAccess oldNodeOpt);
    public virtual BoundNode VisitRangeVariable(BoundRangeVariable node);
    public virtual BoundNode VisitQueryClause(BoundQueryClause node);
    public virtual BoundNode VisitReturnStatement(BoundReturnStatement node);
    private bool get_IsLambdaOrExpressionBodiedMember();
    internal static BoundStatement AddSequencePoint(VariableDeclaratorSyntax declaratorSyntax, BoundStatement rewrittenStatement);
    internal static BoundStatement AddSequencePoint(PropertyDeclarationSyntax declarationSyntax, BoundStatement rewrittenStatement);
    internal static BoundStatement AddSequencePoint(UsingStatementSyntax usingSyntax, BoundStatement rewrittenStatement);
    internal static BoundStatement AddSequencePoint(BlockSyntax blockSyntax, BoundStatement rewrittenStatement);
    private static TextSpan CreateSpanForConstructorDeclaration(ConstructorDeclarationSyntax constructorSyntax);
    private static TextSpan CreateSpan(SyntaxTokenList startOpt, SyntaxNodeOrToken startFallbackOpt, SyntaxNodeOrToken endOpt);
    private static int GetEndPosition(SyntaxNodeOrToken nodeOrToken);
    internal static void GetBreakpointSpan(VariableDeclaratorSyntax declaratorSyntax, SyntaxNode& node, Nullable`1& part);
    internal static void GetFirstLocalOrFieldBreakpointSpan(SyntaxTokenList modifiers, VariableDeclaratorSyntax declaratorSyntax, SyntaxNode& node, Nullable`1& part);
    internal BoundExpression AddConditionSequencePoint(BoundExpression condition, BoundStatement containingStatement);
    internal BoundExpression AddConditionSequencePoint(BoundExpression condition, BoundCatchBlock containingCatchWithFilter);
    private BoundExpression AddConditionSequencePoint(BoundExpression condition, SyntaxNode synthesizedVariableSyntax, bool wasGenerated);
    public virtual BoundNode VisitStackAllocArrayCreation(BoundStackAllocArrayCreation node);
    private BoundExpression RewriteStringConcatenation(CSharpSyntaxNode syntax, BinaryOperatorKind operatorKind, BoundExpression loweredLeft, BoundExpression loweredRight, TypeSymbol type);
    private void FlattenConcatArg(BoundExpression lowered, ArrayBuilder`1<BoundExpression> flattened);
    private BoundExpression TryFoldTwoConcatOperands(CSharpSyntaxNode syntax, BoundExpression loweredLeft, BoundExpression loweredRight);
    private static bool IsNullOrEmptyStringConstant(BoundExpression operand);
    private static ConstantValue TryFoldTwoConcatConsts(ConstantValue leftConst, ConstantValue rightConst);
    private BoundExpression RewriteStringConcatenationOneExpr(CSharpSyntaxNode syntax, BoundExpression loweredOperand);
    private BoundExpression RewriteStringConcatenationTwoExprs(CSharpSyntaxNode syntax, BoundExpression loweredLeft, BoundExpression loweredRight);
    private BoundExpression RewriteStringConcatenationThreeExprs(CSharpSyntaxNode syntax, BoundExpression loweredFirst, BoundExpression loweredSecond, BoundExpression loweredThird);
    private BoundExpression RewriteStringConcatenationManyExprs(CSharpSyntaxNode syntax, ImmutableArray`1<BoundExpression> loweredArgs);
    private BoundExpression RewriteStringConcatInExpressionLambda(CSharpSyntaxNode syntax, BinaryOperatorKind operatorKind, BoundExpression loweredLeft, BoundExpression loweredRight, TypeSymbol type);
    private BoundExpression ConvertConcatExprToStringIfPossible(CSharpSyntaxNode syntax, BoundExpression expr);
    private static bool ConcatExprCanBeOptimizedWithToString(TypeSymbol symbol);
    private BoundExpression RewriteInterpolatedStringConversion(BoundConversion conversion);
    private void MakeInterpolatedStringFormat(BoundInterpolatedString node, BoundExpression& format, ArrayBuilder`1& expressions);
    public virtual BoundNode VisitInterpolatedString(BoundInterpolatedString node);
    public virtual BoundNode VisitSwitchStatement(BoundSwitchStatement node);
    private BoundStatement MakeSwitchStatement(CSharpSyntaxNode syntax, BoundExpression rewrittenExpression, ImmutableArray`1<BoundSwitchSection> rewrittenSections, LabelSymbol constantTargetOpt, ImmutableArray`1<LocalSymbol> locals, GeneratedLabelSymbol breakLabel, BoundSwitchStatement oldNode);
    private BoundStatement MakeSwitchStatementWithNonNullableExpression(CSharpSyntaxNode syntax, BoundStatement preambleOpt, BoundExpression rewrittenExpression, ImmutableArray`1<BoundSwitchSection> rewrittenSections, LabelSymbol constantTargetOpt, ImmutableArray`1<LocalSymbol> locals, GeneratedLabelSymbol breakLabel, BoundSwitchStatement oldNode);
    private BoundStatement MakeSwitchStatementWithNullableExpression(CSharpSyntaxNode syntax, BoundExpression rewrittenExpression, ImmutableArray`1<BoundSwitchSection> rewrittenSections, LabelSymbol constantTargetOpt, ImmutableArray`1<LocalSymbol> locals, GeneratedLabelSymbol breakLabel, BoundSwitchStatement oldNode);
    private static LabelSymbol GetNullValueTargetSwitchLabel(ImmutableArray`1<BoundSwitchSection> sections, GeneratedLabelSymbol breakLabel);
    private ImmutableArray`1<BoundSwitchSection> VisitSwitchSections(ImmutableArray`1<BoundSwitchSection> sections);
    public virtual BoundNode VisitSwitchSection(BoundSwitchSection node);
    private static int CountLabels(ImmutableArray`1<BoundSwitchSection> rewrittenSections);
    private void EnsureStringHashFunction(ImmutableArray`1<BoundSwitchSection> rewrittenSections, CSharpSyntaxNode syntaxNode);
    public virtual BoundNode VisitThrowStatement(BoundThrowStatement node);
    public virtual BoundNode VisitTryStatement(BoundTryStatement node);
    private static bool HasSideEffects(BoundStatement statement);
    public virtual BoundNode VisitCatchBlock(BoundCatchBlock node);
    public virtual BoundNode VisitUnaryOperator(BoundUnaryOperator node);
    private BoundExpression MakeUnaryOperator(UnaryOperatorKind kind, CSharpSyntaxNode syntax, MethodSymbol method, BoundExpression loweredOperand, TypeSymbol type);
    private BoundExpression MakeUnaryOperator(BoundUnaryOperator oldNode, UnaryOperatorKind kind, CSharpSyntaxNode syntax, MethodSymbol method, BoundExpression loweredOperand, TypeSymbol type);
    private BoundExpression LowerLiftedUnaryOperator(UnaryOperatorKind kind, CSharpSyntaxNode syntax, MethodSymbol method, BoundExpression loweredOperand, TypeSymbol type);
    private BoundExpression OptimizeLiftedUnaryOperator(UnaryOperatorKind operatorKind, CSharpSyntaxNode syntax, MethodSymbol method, BoundExpression loweredOperand, TypeSymbol type);
    private BoundExpression GetLiftedUnaryOperatorConsequence(UnaryOperatorKind kind, CSharpSyntaxNode syntax, MethodSymbol method, TypeSymbol type, BoundExpression nonNullOperand);
    private static bool IsIncrement(BoundIncrementOperator node);
    private static bool IsPrefix(BoundIncrementOperator node);
    public virtual BoundNode VisitIncrementOperator(BoundIncrementOperator node);
    private static bool IsIndirectOrInstanceField(BoundExpression expression);
    private BoundNode RewriteWithNotRefOperand(bool isPrefix, bool isChecked, ArrayBuilder`1<LocalSymbol> tempSymbols, ArrayBuilder`1<BoundExpression> tempInitializers, CSharpSyntaxNode syntax, BoundExpression transformedLHS, TypeSymbol operandType, BoundExpression boundTemp, BoundExpression newValue);
    private BoundNode RewriteWithRefOperand(bool isPrefix, bool isChecked, ArrayBuilder`1<LocalSymbol> tempSymbols, ArrayBuilder`1<BoundExpression> tempInitializers, CSharpSyntaxNode syntax, BoundExpression operand, TypeSymbol operandType, BoundExpression boundTemp, BoundExpression newValue);
    private BoundExpression MakeIncrementOperator(BoundIncrementOperator node, BoundExpression rewrittenValueToIncrement);
    private BoundExpression MakeUserDefinedIncrementOperator(BoundIncrementOperator node, BoundExpression rewrittenValueToIncrement);
    private BoundExpression MakeBuiltInIncrementOperator(BoundIncrementOperator node, BoundExpression rewrittenValueToIncrement);
    private MethodSymbol GetDecimalIncDecOperator(BinaryOperatorKind oper);
    private BoundExpression MakeDecimalIncDecOperator(CSharpSyntaxNode syntax, BinaryOperatorKind oper, BoundExpression operand);
    private BoundExpression MakeLiftedDecimalIncDecOperator(CSharpSyntaxNode syntax, BinaryOperatorKind oper, BoundExpression operand);
    private BoundExpression MakeRValue(BoundExpression transformedExpression);
    private TypeSymbol GetUnaryOperatorType(BoundIncrementOperator node);
    private static BinaryOperatorKind GetCorrespondingBinaryOperator(BoundIncrementOperator node);
    private static ConstantValue GetConstantOneForBinOp(BinaryOperatorKind binaryOperatorKind);
    public virtual BoundNode VisitUsingStatement(BoundUsingStatement node);
    private BoundBlock RewriteExpressionUsingStatement(BoundUsingStatement node, BoundBlock tryBlock);
    private BoundBlock RewriteDeclarationUsingStatement(CSharpSyntaxNode usingSyntax, BoundLocalDeclaration localDeclaration, BoundBlock tryBlock, Conversion idisposableConversion);
    private BoundStatement RewriteUsingStatementTryFinally(CSharpSyntaxNode syntax, BoundBlock tryBlock, BoundLocal local);
    public virtual BoundNode VisitWhileStatement(BoundWhileStatement node);
    private BoundStatement RewriteWhileStatement(CSharpSyntaxNode syntax, BoundExpression rewrittenCondition, TextSpan conditionSequencePointSpan, BoundStatement rewrittenBody, GeneratedLabelSymbol breakLabel, GeneratedLabelSymbol continueLabel, bool hasErrors);
    public virtual BoundNode VisitYieldBreakStatement(BoundYieldBreakStatement node);
    public virtual BoundNode VisitYieldReturnStatement(BoundYieldReturnStatement node);
}
internal class Microsoft.CodeAnalysis.CSharp.LocalScopeBinder : Binder {
    private ImmutableArray`1<LocalSymbol> _locals;
    private ImmutableArray`1<LabelSymbol> _labels;
    private SmallDictionary`2<string, LocalSymbol> _lazyLocalsMap;
    private SmallDictionary`2<string, LabelSymbol> _lazyLabelsMap;
    internal ImmutableArray`1<LocalSymbol> Locals { get; }
    internal ImmutableArray`1<LabelSymbol> Labels { get; }
    private SmallDictionary`2<string, LocalSymbol> LocalsMap { get; }
    private SmallDictionary`2<string, LabelSymbol> LabelsMap { get; }
    internal LocalScopeBinder(Binder next);
    internal LocalScopeBinder(Binder next, BinderFlags flags);
    internal sealed virtual ImmutableArray`1<LocalSymbol> get_Locals();
    protected virtual ImmutableArray`1<LocalSymbol> BuildLocals();
    internal sealed virtual ImmutableArray`1<LabelSymbol> get_Labels();
    protected virtual ImmutableArray`1<LabelSymbol> BuildLabels();
    private SmallDictionary`2<string, LocalSymbol> get_LocalsMap();
    private SmallDictionary`2<string, LabelSymbol> get_LabelsMap();
    private static SmallDictionary`2<string, TSymbol> BuildMap(ImmutableArray`1<TSymbol> array);
    protected ImmutableArray`1<LocalSymbol> BuildLocals(SyntaxList`1<StatementSyntax> statements);
    protected SourceLocalSymbol MakeLocal(VariableDeclarationSyntax declaration, VariableDeclaratorSyntax declarator, LocalDeclarationKind kind);
    protected void BuildLabels(SyntaxList`1<StatementSyntax> statements, ArrayBuilder`1& labels);
    internal static void BuildLabels(MethodSymbol containingMethod, StatementSyntax statement, ArrayBuilder`1& labels);
    protected virtual SourceLocalSymbol LookupLocal(SyntaxToken nameToken);
    internal virtual void LookupSymbolsInSingleBinder(LookupResult result, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, HashSet`1& useSiteDiagnostics);
    protected virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo result, LookupOptions options, Binder originalBinder);
    private bool ReportConflictWithLocal(LocalSymbol local, Symbol newSymbol, string name, Location newLocation, DiagnosticBag diagnostics);
    internal virtual bool EnsureSingleDefinition(Symbol symbol, string name, Location location, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<LocalSymbol> GetDeclaredLocalsForScope(CSharpSyntaxNode node);
}
internal class Microsoft.CodeAnalysis.CSharp.LockBinder : LockOrUsingBinder {
    private LockStatementSyntax _syntax;
    protected ExpressionSyntax TargetExpressionSyntax { get; }
    public LockBinder(Binder enclosing, LockStatementSyntax syntax);
    protected virtual ExpressionSyntax get_TargetExpressionSyntax();
    internal virtual BoundStatement BindLockStatementParts(DiagnosticBag diagnostics, Binder originalBinder);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.LockOrUsingBinder : LocalScopeBinder {
    private ImmutableHashSet`1<Symbol> _lazyLockedOrDisposedVariables;
    private ExpressionAndDiagnostics _lazyExpressionAndDiagnostics;
    protected ExpressionSyntax TargetExpressionSyntax { get; }
    internal ImmutableHashSet`1<Symbol> LockedOrDisposedVariables { get; }
    internal LockOrUsingBinder(Binder enclosing);
    protected abstract virtual ExpressionSyntax get_TargetExpressionSyntax();
    internal sealed virtual ImmutableHashSet`1<Symbol> get_LockedOrDisposedVariables();
    protected BoundExpression BindTargetExpression(DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.CSharp.LookupFilter : MulticastDelegate {
    public LookupFilter(object object, IntPtr method);
    public virtual SingleLookupResult Invoke(Symbol sym);
    public virtual IAsyncResult BeginInvoke(Symbol sym, AsyncCallback callback, object object);
    public virtual SingleLookupResult EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.LookupOptionExtensions : object {
    [ExtensionAttribute]
internal static bool AreValid(LookupOptions options);
    [ExtensionAttribute]
internal static void ThrowIfInvalid(LookupOptions options);
    private static bool OnlyOneBitSet(LookupOptions o);
    [ExtensionAttribute]
internal static bool CanConsiderMembers(LookupOptions options);
    [ExtensionAttribute]
internal static bool CanConsiderLocals(LookupOptions options);
    [ExtensionAttribute]
internal static bool CanConsiderTypes(LookupOptions options);
    [ExtensionAttribute]
internal static bool CanConsiderNamespaces(LookupOptions options);
    [ExtensionAttribute]
internal static bool IsAttributeTypeLookup(LookupOptions options);
    [ExtensionAttribute]
internal static bool IsVerbatimNameAttributeTypeLookup(LookupOptions options);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.LookupOptions : Enum {
    public int value__;
    public static LookupOptions Default;
    public static LookupOptions NamespaceAliasesOnly;
    public static LookupOptions NamespacesOrTypesOnly;
    public static LookupOptions MustBeInvocableIfMember;
    public static LookupOptions MustBeInstance;
    public static LookupOptions MustNotBeInstance;
    public static LookupOptions MustNotBeNamespace;
    public static LookupOptions AllMethodsOnArityZero;
    public static LookupOptions LabelsOnly;
    public static LookupOptions UseBaseReferenceAccessibility;
    public static LookupOptions IncludeExtensionMethods;
    public static LookupOptions AttributeTypeOnly;
    public static LookupOptions VerbatimNameAttributeTypeOnly;
    public static LookupOptions AllNamedTypesOnArityZero;
    public static LookupOptions MustNotBeMethodTypeParameter;
}
internal class Microsoft.CodeAnalysis.CSharp.LookupResult : object {
    private LookupResultKind _kind;
    private ArrayBuilder`1<Symbol> _symbolList;
    private DiagnosticInfo _error;
    private ObjectPool`1<LookupResult> _pool;
    private static ObjectPool`1<LookupResult> s_poolInstance;
    internal bool IsClear { get; }
    internal LookupResultKind Kind { get; }
    internal Symbol SingleSymbolOrDefault { get; }
    internal ArrayBuilder`1<Symbol> Symbols { get; }
    internal DiagnosticInfo Error { get; }
    internal bool IsMultiViable { get; }
    internal bool IsSingleViable { get; }
    private LookupResult(ObjectPool`1<LookupResult> pool);
    private static LookupResult();
    internal bool get_IsClear();
    internal void Clear();
    internal LookupResultKind get_Kind();
    internal Symbol get_SingleSymbolOrDefault();
    internal ArrayBuilder`1<Symbol> get_Symbols();
    internal DiagnosticInfo get_Error();
    internal bool get_IsMultiViable();
    internal bool get_IsSingleViable();
    internal static SingleLookupResult Good(Symbol symbol);
    internal static SingleLookupResult WrongArity(Symbol symbol, DiagnosticInfo error);
    internal static SingleLookupResult NotReferencable(Symbol symbol, DiagnosticInfo error);
    internal static SingleLookupResult StaticInstanceMismatch(Symbol symbol, DiagnosticInfo error);
    internal static SingleLookupResult Inaccessible(Symbol symbol, DiagnosticInfo error);
    internal static SingleLookupResult NotInvocable(Symbol unwrappedSymbol, Symbol symbol, bool diagnose);
    internal static SingleLookupResult NotLabel(Symbol symbol, DiagnosticInfo error);
    internal static SingleLookupResult NotTypeOrNamespace(Symbol symbol, DiagnosticInfo error);
    internal static SingleLookupResult NotTypeOrNamespace(Symbol unwrappedSymbol, Symbol symbol, bool diagnose);
    internal static SingleLookupResult NotAnAttributeType(Symbol symbol, DiagnosticInfo error);
    internal void SetFrom(SingleLookupResult other);
    internal void SetFrom(LookupResult other);
    internal void SetFrom(DiagnosticInfo error);
    internal void MergePrioritized(LookupResult other);
    internal void MergeEqual(LookupResult other);
    internal void MergeEqual(SingleLookupResult result);
    internal static ObjectPool`1<LookupResult> CreatePool();
    internal static LookupResult GetInstance();
    internal void Free();
}
internal enum Microsoft.CodeAnalysis.CSharp.LookupResultKind : Enum {
    public byte value__;
    public static LookupResultKind Empty;
    public static LookupResultKind NotATypeOrNamespace;
    public static LookupResultKind NotAnAttributeType;
    public static LookupResultKind WrongArity;
    public static LookupResultKind NotCreatable;
    public static LookupResultKind Inaccessible;
    public static LookupResultKind NotReferencable;
    public static LookupResultKind NotAValue;
    public static LookupResultKind NotAVariable;
    public static LookupResultKind NotInvocable;
    public static LookupResultKind NotLabel;
    public static LookupResultKind StaticInstanceMismatch;
    public static LookupResultKind OverloadResolutionFailure;
    public static LookupResultKind Ambiguous;
    public static LookupResultKind MemberGroup;
    public static LookupResultKind Viable;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.LookupResultKindExtensions : object {
    [ExtensionAttribute]
public static CandidateReason ToCandidateReason(LookupResultKind resultKind);
    [ExtensionAttribute]
public static LookupResultKind WorseResultKind(LookupResultKind resultKind1, LookupResultKind resultKind2);
}
internal class Microsoft.CodeAnalysis.CSharp.LookupSymbolsInfo : AbstractLookupSymbolsInfo`1<Symbol> {
    private static int poolSize;
    private static ObjectPool`1<LookupSymbolsInfo> s_pool;
    private static LookupSymbolsInfo();
    public void Free();
    public static LookupSymbolsInfo GetInstance();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.LoopBinder : LocalScopeBinder {
    private GeneratedLabelSymbol _breakLabel;
    private GeneratedLabelSymbol _continueLabel;
    internal GeneratedLabelSymbol BreakLabel { get; }
    internal GeneratedLabelSymbol ContinueLabel { get; }
    protected LoopBinder(Binder enclosing);
    internal virtual GeneratedLabelSymbol get_BreakLabel();
    internal virtual GeneratedLabelSymbol get_ContinueLabel();
}
internal class Microsoft.CodeAnalysis.CSharp.LoweredDynamicOperation : ValueType {
    private SyntheticBoundNodeFactory _factory;
    private TypeSymbol _resultType;
    public BoundExpression SiteInitialization;
    public BoundExpression SiteInvocation;
    public LoweredDynamicOperation(SyntheticBoundNodeFactory factory, BoundExpression siteInitialization, BoundExpression siteInvocation, TypeSymbol resultType);
    public static LoweredDynamicOperation Bad(BoundExpression loweredReceiver, ImmutableArray`1<BoundExpression> loweredArguments, BoundExpression loweredRight, TypeSymbol resultType);
    public static LoweredDynamicOperation Bad(TypeSymbol resultType, ImmutableArray`1<BoundNode> children);
    public BoundExpression ToExpression();
}
internal class Microsoft.CodeAnalysis.CSharp.LoweredDynamicOperationFactory : object {
    private SyntheticBoundNodeFactory _factory;
    private int _methodOrdinal;
    private NamedTypeSymbol _currentDynamicCallSiteContainer;
    private int _callSiteIdDispenser;
    internal LoweredDynamicOperationFactory(SyntheticBoundNodeFactory factory, int methodOrdinal);
    internal LoweredDynamicOperation MakeDynamicConversion(BoundExpression loweredOperand, bool isExplicit, bool isArrayIndex, bool isChecked, TypeSymbol resultType);
    internal LoweredDynamicOperation MakeDynamicUnaryOperator(UnaryOperatorKind operatorKind, BoundExpression loweredOperand, TypeSymbol resultType);
    internal LoweredDynamicOperation MakeDynamicBinaryOperator(BinaryOperatorKind operatorKind, BoundExpression loweredLeft, BoundExpression loweredRight, bool isCompoundAssignment, TypeSymbol resultType);
    internal LoweredDynamicOperation MakeDynamicMemberInvocation(string name, BoundExpression loweredReceiver, ImmutableArray`1<TypeSymbol> typeArguments, ImmutableArray`1<BoundExpression> loweredArguments, ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> refKinds, bool hasImplicitReceiver, bool resultDiscarded);
    internal LoweredDynamicOperation MakeDynamicEventAccessorInvocation(string accessorName, BoundExpression loweredReceiver, BoundExpression loweredHandler);
    internal LoweredDynamicOperation MakeDynamicInvocation(BoundExpression loweredReceiver, ImmutableArray`1<BoundExpression> loweredArguments, ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> refKinds, bool resultDiscarded);
    internal LoweredDynamicOperation MakeDynamicConstructorInvocation(CSharpSyntaxNode syntax, TypeSymbol type, ImmutableArray`1<BoundExpression> loweredArguments, ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> refKinds);
    internal LoweredDynamicOperation MakeDynamicGetMember(BoundExpression loweredReceiver, string name, bool resultIndexed);
    internal LoweredDynamicOperation MakeDynamicSetMember(BoundExpression loweredReceiver, string name, BoundExpression loweredRight, bool isCompoundAssignment, bool isChecked);
    internal LoweredDynamicOperation MakeDynamicGetIndex(BoundExpression loweredReceiver, ImmutableArray`1<BoundExpression> loweredArguments, ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> refKinds);
    internal LoweredDynamicOperation MakeDynamicSetIndex(BoundExpression loweredReceiver, ImmutableArray`1<BoundExpression> loweredArguments, ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> refKinds, BoundExpression loweredRight, bool isCompoundAssignment, bool isChecked);
    internal LoweredDynamicOperation MakeDynamicIsEventTest(string name, BoundExpression loweredReceiver);
    private MethodSymbol GetArgumentInfoFactory();
    private BoundExpression MakeBinderConstruction(WellKnownMember factoryMethod, BoundExpression[] args);
    internal static RefKind GetReceiverRefKind(BoundExpression loweredReceiver);
    internal BoundExpression MakeCallSiteArgumentInfos(MethodSymbol argumentInfoFactory, ImmutableArray`1<BoundExpression> loweredArguments, ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> refKinds, BoundExpression loweredReceiver, RefKind receiverRefKind, bool receiverIsStaticType, BoundExpression loweredRight);
    internal LoweredDynamicOperation MakeDynamicOperation(BoundExpression binderConstruction, BoundExpression loweredReceiver, RefKind receiverRefKind, ImmutableArray`1<BoundExpression> loweredArguments, ImmutableArray`1<RefKind> refKinds, BoundExpression loweredRight, TypeSymbol resultType);
    private static NamedTypeSymbol CreateCallSiteContainer(SyntheticBoundNodeFactory factory, int methodOrdinal);
    internal FieldSymbol DefineCallSiteStorageSymbol(NamedTypeSymbol containerDefinition, NamedTypeSymbol delegateTypeOverMethodTypeParameters, TypeMap methodToContainerTypeParametersMap);
    internal NamedTypeSymbol GetDelegateType(BoundExpression loweredReceiver, RefKind receiverRefKind, ImmutableArray`1<BoundExpression> loweredArguments, ImmutableArray`1<RefKind> refKinds, BoundExpression loweredRight, TypeSymbol resultType);
    internal BoundExpression GetArgumentInfo(MethodSymbol argumentInfoFactory, BoundExpression boundArgument, string name, RefKind refKind, bool isStaticType);
    internal static ImmutableArray`1<BoundExpression> GetCallSiteArguments(BoundExpression callSiteFieldAccess, BoundExpression receiver, ImmutableArray`1<BoundExpression> arguments, BoundExpression right);
    internal TypeSymbol[] MakeCallSiteDelegateSignature(TypeSymbol callSiteType, BoundExpression receiver, ImmutableArray`1<BoundExpression> arguments, BoundExpression right, TypeSymbol resultType);
}
internal class Microsoft.CodeAnalysis.CSharp.MemberAnalysisResult : ValueType {
    public ImmutableArray`1<Conversion> ConversionsOpt;
    public ImmutableArray`1<int> BadArgumentsOpt;
    public ImmutableArray`1<int> ArgsToParamsOpt;
    public int BadParameter;
    public MemberResolutionKind Kind;
    public bool HasAnyRefOmittedArgument;
    public bool IsApplicable { get; }
    public bool IsValid { get; }
    private MemberAnalysisResult(MemberResolutionKind kind);
    private MemberAnalysisResult(MemberResolutionKind kind, ImmutableArray`1<int> badArgumentsOpt, ImmutableArray`1<int> argsToParamsOpt, ImmutableArray`1<Conversion> conversionsOpt, int missingParameter, bool hasAnyRefOmittedArgument);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Conversion ConversionForArg(int arg);
    public int ParameterFromArgument(int arg);
    public bool get_IsApplicable();
    public bool get_IsValid();
    internal bool HasUseSiteDiagnosticToReportFor(Symbol symbol);
    private static bool SuppressUseSiteDiagnosticsForKind(MemberResolutionKind kind);
    public static MemberAnalysisResult ArgumentParameterMismatch(ArgumentAnalysisResult argAnalysis);
    public static MemberAnalysisResult NameUsedForPositional(int argumentPosition);
    public static MemberAnalysisResult NoCorrespondingParameter(int argumentPosition);
    public static MemberAnalysisResult NoCorrespondingNamedParameter(int argumentPosition);
    public static MemberAnalysisResult RequiredParameterMissing(int parameterPosition);
    public static MemberAnalysisResult UseSiteError();
    public static MemberAnalysisResult UnsupportedMetadata();
    public static MemberAnalysisResult BadArgumentConversions(ImmutableArray`1<int> argsToParamsOpt, ImmutableArray`1<int> badArguments, ImmutableArray`1<Conversion> conversions);
    public static MemberAnalysisResult InaccessibleTypeArgument();
    public static MemberAnalysisResult TypeInferenceFailed();
    public static MemberAnalysisResult TypeInferenceExtensionInstanceArgumentFailed();
    public static MemberAnalysisResult ConstructedParameterFailedConstraintsCheck(int parameterPosition);
    public static MemberAnalysisResult LessDerived();
    public static MemberAnalysisResult NormalForm(ImmutableArray`1<int> argsToParamsOpt, ImmutableArray`1<Conversion> conversions, bool hasAnyRefOmittedArgument);
    public static MemberAnalysisResult ExpandedForm(ImmutableArray`1<int> argsToParamsOpt, ImmutableArray`1<Conversion> conversions, bool hasAnyRefOmittedArgument);
    public static MemberAnalysisResult Worse();
    public static MemberAnalysisResult Worst();
}
internal enum Microsoft.CodeAnalysis.CSharp.MemberResolutionKind : Enum {
    public byte value__;
    public static MemberResolutionKind None;
    public static MemberResolutionKind ApplicableInNormalForm;
    public static MemberResolutionKind ApplicableInExpandedForm;
    public static MemberResolutionKind InaccessibleTypeArgument;
    public static MemberResolutionKind NoCorrespondingParameter;
    public static MemberResolutionKind NoCorrespondingNamedParameter;
    public static MemberResolutionKind RequiredParameterMissing;
    public static MemberResolutionKind NameUsedForPositional;
    public static MemberResolutionKind UseSiteError;
    public static MemberResolutionKind UnsupportedMetadata;
    public static MemberResolutionKind BadArguments;
    public static MemberResolutionKind TypeInferenceFailed;
    public static MemberResolutionKind TypeInferenceExtensionInstanceArgument;
    public static MemberResolutionKind ConstructedParameterFailedConstraintCheck;
    public static MemberResolutionKind LessDerived;
    public static MemberResolutionKind Worse;
    public static MemberResolutionKind Worst;
}
internal class Microsoft.CodeAnalysis.CSharp.MemberResolutionResult`1 : ValueType {
    private TMember _member;
    private TMember _leastOverriddenMember;
    private MemberAnalysisResult _result;
    internal bool IsNull { get; }
    internal bool IsNotNull { get; }
    public TMember Member { get; }
    internal TMember LeastOverriddenMember { get; }
    public MemberResolutionKind Resolution { get; }
    public bool IsValid { get; }
    public bool IsApplicable { get; }
    internal bool HasUseSiteDiagnosticToReport { get; }
    internal MemberAnalysisResult Result { get; }
    internal MemberResolutionResult`1(TMember member, TMember leastOverriddenMember, MemberAnalysisResult result);
    internal bool get_IsNull();
    internal bool get_IsNotNull();
    public TMember get_Member();
    internal TMember get_LeastOverriddenMember();
    public MemberResolutionKind get_Resolution();
    public bool get_IsValid();
    public bool get_IsApplicable();
    internal bool get_HasUseSiteDiagnosticToReport();
    internal MemberAnalysisResult get_Result();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.MemberSemanticModel : CSharpSemanticModel {
    private CSharpCompilation _compilation;
    private Symbol _memberSymbol;
    private CSharpSyntaxNode _root;
    private DiagnosticBag _ignoredDiagnostics;
    private ReaderWriterLockSlim _nodeMapLock;
    private Dictionary`2<CSharpSyntaxNode, ImmutableArray`1<BoundNode>> _guardedNodeMap;
    internal Binder RootBinder;
    private SyntaxTreeSemanticModel _parentSemanticModelOpt;
    private int _speculatedPosition;
    public CSharpCompilation Compilation { get; }
    internal CSharpSyntaxNode Root { get; }
    internal Symbol MemberSymbol { get; }
    public bool IsSpeculativeSemanticModel { get; }
    public int OriginalPositionForSpeculation { get; }
    public CSharpSemanticModel ParentModel { get; }
    public SyntaxTree SyntaxTree { get; }
    protected MemberSemanticModel(CSharpCompilation compilation, CSharpSyntaxNode root, Symbol memberSymbol, Binder rootBinder, SyntaxTreeSemanticModel parentSemanticModelOpt, int speculatedPosition);
    public virtual CSharpCompilation get_Compilation();
    internal virtual CSharpSyntaxNode get_Root();
    internal Symbol get_MemberSymbol();
    public virtual bool get_IsSpeculativeSemanticModel();
    public virtual int get_OriginalPositionForSpeculation();
    public virtual CSharpSemanticModel get_ParentModel();
    internal virtual MemberSemanticModel GetMemberModel(CSharpSyntaxNode node);
    internal sealed virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, TypeSyntax type, SpeculativeBindingOption bindingOption, SemanticModel& speculativeModel);
    internal sealed virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, CrefSyntax crefSyntax, SemanticModel& speculativeModel);
    private Binder GetEnclosingBinder(CSharpSyntaxNode node, int position);
    private static Binder AdjustBinderForPositionWithinStatement(int position, Binder binder, StatementSyntax stmt);
    public virtual Conversion ClassifyConversion(ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource);
    internal virtual Conversion ClassifyConversionForCast(ExpressionSyntax expression, TypeSymbol destination);
    internal virtual BoundNode GetBoundRoot();
    internal BoundNode GetUpperBoundNode(CSharpSyntaxNode node, bool promoteToBindable);
    internal BoundNode GetLowerBoundNode(CSharpSyntaxNode node);
    public virtual ImmutableArray`1<Diagnostic> GetSyntaxDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetDeclarationDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetMethodBodyDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public virtual INamespaceSymbol GetDeclaredSymbol(NamespaceDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual INamedTypeSymbol GetDeclaredSymbol(BaseTypeDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual INamedTypeSymbol GetDeclaredSymbol(DelegateDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IFieldSymbol GetDeclaredSymbol(EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual ISymbol GetDeclaredSymbol(MemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IMethodSymbol GetDeclaredSymbol(BaseMethodDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual ISymbol GetDeclaredSymbol(BasePropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IPropertySymbol GetDeclaredSymbol(PropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IPropertySymbol GetDeclaredSymbol(IndexerDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IEventSymbol GetDeclaredSymbol(EventDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IMethodSymbol GetDeclaredSymbol(AccessorDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IMethodSymbol GetDeclaredSymbol(ArrowExpressionClauseSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual ISymbol GetDeclaredSymbol(VariableDeclaratorSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual ILabelSymbol GetDeclaredSymbol(LabeledStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual ILabelSymbol GetDeclaredSymbol(SwitchLabelSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IAliasSymbol GetDeclaredSymbol(UsingDirectiveSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IAliasSymbol GetDeclaredSymbol(ExternAliasDirectiveSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IParameterSymbol GetDeclaredSymbol(ParameterSyntax declarationSyntax, CancellationToken cancellationToken);
    internal virtual ImmutableArray`1<ISymbol> GetDeclaredSymbols(BaseFieldDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    private ParameterSymbol GetLambdaParameterSymbol(ParameterSyntax parameter, CancellationToken cancellationToken);
    private ParameterSymbol GetLambdaParameterSymbol(ParameterSyntax parameter, ExpressionSyntax lambda, CancellationToken cancellationToken);
    public virtual ITypeParameterSymbol GetDeclaredSymbol(TypeParameterSyntax typeParameter, CancellationToken cancellationToken);
    public virtual IRangeVariableSymbol GetDeclaredSymbol(JoinIntoClauseSyntax node, CancellationToken cancellationToken);
    public virtual IRangeVariableSymbol GetDeclaredSymbol(QueryClauseSyntax queryClause, CancellationToken cancellationToken);
    public virtual IRangeVariableSymbol GetDeclaredSymbol(QueryContinuationSyntax node, CancellationToken cancellationToken);
    public virtual AwaitExpressionInfo GetAwaitExpressionInfo(AwaitExpressionSyntax node);
    public virtual ForEachStatementInfo GetForEachStatementInfo(ForEachStatementSyntax node);
    private BoundQueryClause GetBoundQueryClause(CSharpSyntaxNode node);
    private QueryClauseInfo GetQueryClauseInfo(BoundQueryClause bound);
    private SymbolInfo GetSymbolInfoForQuery(BoundQueryClause bound);
    private CSharpTypeInfo GetTypeInfoForQuery(BoundQueryClause bound);
    public virtual QueryClauseInfo GetQueryClauseInfo(QueryClauseSyntax node, CancellationToken cancellationToken);
    public virtual IPropertySymbol GetDeclaredSymbol(AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, CancellationToken cancellationToken);
    public virtual INamedTypeSymbol GetDeclaredSymbol(AnonymousObjectCreationExpressionSyntax declaratorSyntax, CancellationToken cancellationToken);
    public virtual SyntaxTree get_SyntaxTree();
    internal virtual IOperation GetOperationWorker(CSharpSyntaxNode node, GetOperationOptions options, CancellationToken cancellationToken);
    internal virtual SymbolInfo GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken);
    internal virtual CSharpTypeInfo GetTypeInfoWorker(CSharpSyntaxNode node, CancellationToken cancellationToken);
    internal virtual ImmutableArray`1<Symbol> GetMemberGroupWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken);
    internal virtual ImmutableArray`1<PropertySymbol> GetIndexerGroupWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken);
    internal virtual Optional`1<object> GetConstantValueWorker(CSharpSyntaxNode node, CancellationToken cancellationToken);
    internal virtual SymbolInfo GetCollectionInitializerSymbolInfoWorker(InitializerExpressionSyntax collectionInitializer, ExpressionSyntax node, CancellationToken cancellationToken);
    public virtual SymbolInfo GetSymbolInfo(OrderingSyntax node, CancellationToken cancellationToken);
    public virtual SymbolInfo GetSymbolInfo(SelectOrGroupClauseSyntax node, CancellationToken cancellationToken);
    public virtual TypeInfo GetTypeInfo(SelectOrGroupClauseSyntax node, CancellationToken cancellationToken);
    private void GetBoundNodes(CSharpSyntaxNode node, CSharpSyntaxNode& bindableNode, BoundNode& lowestBoundNode, BoundNode& highestBoundNode, BoundNode& boundParent);
    private CSharpSyntaxNode GetInnermostLambdaOrQuery(CSharpSyntaxNode node, int position, bool allowStarting);
    private static bool NodeIsExplicitType(CSharpSyntaxNode node, CSharpSyntaxNode lambda);
    private CSharpSyntaxNode GetOutermostLambdaOrQuery(CSharpSyntaxNode node);
    private ImmutableArray`1<BoundNode> GuardedGetBoundNodesFromMap(CSharpSyntaxNode node);
    private ImmutableArray`1<BoundNode> GuardedAddBoundTreeAndGetBoundNodeFromMap(CSharpSyntaxNode syntax, BoundNode bound);
    internal void UnguardedAddBoundTreeForStandaloneSyntax(CSharpSyntaxNode syntax, BoundNode bound);
    protected void GuardedAddBoundTreeForStandaloneSyntax(CSharpSyntaxNode syntax, BoundNode bound);
    private CSharpSyntaxNode GetBindingRoot(CSharpSyntaxNode node);
    internal virtual Binder GetEnclosingBinderInternal(int position);
    private static Binder GetQueryEnclosingBinder(int position, BoundQueryClause queryClause);
    private static Binder GetLambdaEnclosingBinder(int position, CSharpSyntaxNode startingNode, CSharpSyntaxNode containingLambda, Binder lambdaBinder);
    internal ImmutableArray`1<BoundNode> GetBoundNodes(CSharpSyntaxNode node);
    protected internal virtual CSharpSyntaxNode GetBindableSyntaxNode(CSharpSyntaxNode node);
    protected CSharpSyntaxNode GetBindableParentNode(CSharpSyntaxNode node);
}
internal class Microsoft.CodeAnalysis.CSharp.MergedNamespaceDeclaration : MergedNamespaceOrTypeDeclaration {
    private ImmutableArray`1<SingleNamespaceDeclaration> _declarations;
    private ImmutableArray`1<MergedNamespaceOrTypeDeclaration> _lazyChildren;
    public DeclarationKind Kind { get; }
    public ImmutableArray`1<Location> NameLocations { get; }
    public ImmutableArray`1<SingleNamespaceDeclaration> Declarations { get; }
    public ImmutableArray`1<MergedNamespaceOrTypeDeclaration> Children { get; }
    private MergedNamespaceDeclaration(ImmutableArray`1<SingleNamespaceDeclaration> declarations);
    public static MergedNamespaceDeclaration Create(ImmutableArray`1<SingleNamespaceDeclaration> declarations);
    public static MergedNamespaceDeclaration Create(SingleNamespaceDeclaration declaration);
    public virtual DeclarationKind get_Kind();
    public LexicalSortKey GetLexicalSortKey(CSharpCompilation compilation);
    public ImmutableArray`1<Location> get_NameLocations();
    public ImmutableArray`1<SingleNamespaceDeclaration> get_Declarations();
    protected virtual ImmutableArray`1<Declaration> GetDeclarationChildren();
    private ImmutableArray`1<MergedNamespaceOrTypeDeclaration> MakeChildren();
    public ImmutableArray`1<MergedNamespaceOrTypeDeclaration> get_Children();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.MergedNamespaceOrTypeDeclaration : Declaration {
    protected MergedNamespaceOrTypeDeclaration(string name);
}
internal class Microsoft.CodeAnalysis.CSharp.MergedTypeDeclaration : MergedNamespaceOrTypeDeclaration {
    private ImmutableArray`1<SingleTypeDeclaration> _declarations;
    private ImmutableArray`1<MergedTypeDeclaration> _lazyChildren;
    private ICollection`1<string> _lazyMemberNames;
    public ImmutableArray`1<SingleTypeDeclaration> Declarations { get; }
    public ImmutableArray`1<SyntaxReference> SyntaxReferences { get; }
    public DeclarationKind Kind { get; }
    public int Arity { get; }
    public bool ContainsExtensionMethods { get; }
    public bool AnyMemberHasAttributes { get; }
    public ImmutableArray`1<SourceLocation> NameLocations { get; }
    public ImmutableArray`1<MergedTypeDeclaration> Children { get; }
    public IEnumerable`1<string> MemberNames { get; }
    internal MergedTypeDeclaration(ImmutableArray`1<SingleTypeDeclaration> declarations);
    public ImmutableArray`1<SingleTypeDeclaration> get_Declarations();
    public ImmutableArray`1<SyntaxReference> get_SyntaxReferences();
    public ImmutableArray`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    public virtual DeclarationKind get_Kind();
    public int get_Arity();
    public bool get_ContainsExtensionMethods();
    public bool get_AnyMemberHasAttributes();
    public LexicalSortKey GetLexicalSortKey(CSharpCompilation compilation);
    public ImmutableArray`1<SourceLocation> get_NameLocations();
    private ImmutableArray`1<MergedTypeDeclaration> MakeChildren();
    public ImmutableArray`1<MergedTypeDeclaration> get_Children();
    protected virtual ImmutableArray`1<Declaration> GetDeclarationChildren();
    public IEnumerable`1<string> get_MemberNames();
}
internal enum Microsoft.CodeAnalysis.CSharp.MessageID : Enum {
    public int value__;
    public static MessageID MessageBase;
    public static MessageID IDS_SK_METHOD;
    public static MessageID IDS_SK_TYPE;
    public static MessageID IDS_SK_NAMESPACE;
    public static MessageID IDS_SK_FIELD;
    public static MessageID IDS_SK_PROPERTY;
    public static MessageID IDS_SK_UNKNOWN;
    public static MessageID IDS_SK_VARIABLE;
    public static MessageID IDS_SK_EVENT;
    public static MessageID IDS_SK_TYVAR;
    public static MessageID IDS_SK_ALIAS;
    public static MessageID IDS_SK_LABEL;
    public static MessageID IDS_NULL;
    public static MessageID IDS_XMLIGNORED;
    public static MessageID IDS_XMLIGNORED2;
    public static MessageID IDS_XMLFAILEDINCLUDE;
    public static MessageID IDS_XMLBADINCLUDE;
    public static MessageID IDS_XMLNOINCLUDE;
    public static MessageID IDS_XMLMISSINGINCLUDEFILE;
    public static MessageID IDS_XMLMISSINGINCLUDEPATH;
    public static MessageID IDS_GlobalNamespace;
    public static MessageID IDS_FeatureGenerics;
    public static MessageID IDS_FeatureAnonDelegates;
    public static MessageID IDS_FeatureModuleAttrLoc;
    public static MessageID IDS_FeatureGlobalNamespace;
    public static MessageID IDS_FeatureFixedBuffer;
    public static MessageID IDS_FeaturePragma;
    public static MessageID IDS_FOREACHLOCAL;
    public static MessageID IDS_USINGLOCAL;
    public static MessageID IDS_FIXEDLOCAL;
    public static MessageID IDS_FeatureStaticClasses;
    public static MessageID IDS_FeaturePartialTypes;
    public static MessageID IDS_MethodGroup;
    public static MessageID IDS_AnonMethod;
    public static MessageID IDS_FeatureSwitchOnBool;
    public static MessageID IDS_Collection;
    public static MessageID IDS_FeaturePropertyAccessorMods;
    public static MessageID IDS_FeatureExternAlias;
    public static MessageID IDS_FeatureIterators;
    public static MessageID IDS_FeatureDefault;
    public static MessageID IDS_FeatureNullable;
    public static MessageID IDS_Lambda;
    public static MessageID IDS_FeatureImplicitArray;
    public static MessageID IDS_FeatureImplicitLocal;
    public static MessageID IDS_FeatureAnonymousTypes;
    public static MessageID IDS_FeatureAutoImplementedProperties;
    public static MessageID IDS_FeatureObjectInitializer;
    public static MessageID IDS_FeatureCollectionInitializer;
    public static MessageID IDS_FeatureLambda;
    public static MessageID IDS_FeatureQueryExpression;
    public static MessageID IDS_FeatureExtensionMethod;
    public static MessageID IDS_FeaturePartialMethod;
    public static MessageID IDS_FeatureDynamic;
    public static MessageID IDS_FeatureTypeVariance;
    public static MessageID IDS_FeatureNamedArgument;
    public static MessageID IDS_FeatureOptionalParameter;
    public static MessageID IDS_FeatureExceptionFilter;
    public static MessageID IDS_FeatureAutoPropertyInitializer;
    public static MessageID IDS_SK_TYPE_OR_NAMESPACE;
    public static MessageID IDS_Contravariant;
    public static MessageID IDS_Contravariantly;
    public static MessageID IDS_Covariant;
    public static MessageID IDS_Covariantly;
    public static MessageID IDS_Invariantly;
    public static MessageID IDS_FeatureAsync;
    public static MessageID IDS_LIB_ENV;
    public static MessageID IDS_LIB_OPTION;
    public static MessageID IDS_REFERENCEPATH_OPTION;
    public static MessageID IDS_DirectoryDoesNotExist;
    public static MessageID IDS_DirectoryHasInvalidPath;
    public static MessageID IDS_Namespace1;
    public static MessageID IDS_PathList;
    public static MessageID IDS_Text;
    public static MessageID IDS_FeatureNullPropagatingOperator;
    public static MessageID IDS_FeatureExpressionBodiedMethod;
    public static MessageID IDS_FeatureExpressionBodiedProperty;
    public static MessageID IDS_FeatureExpressionBodiedIndexer;
    public static MessageID IDS_FeatureNameof;
    public static MessageID IDS_FeatureDictionaryInitializer;
    public static MessageID IDS_ToolName;
    public static MessageID IDS_LogoLine1;
    public static MessageID IDS_LogoLine2;
    public static MessageID IDS_CSCHelp;
    public static MessageID IDS_FeatureUsingStatic;
    public static MessageID IDS_FeatureInterpolatedStrings;
    public static MessageID IDS_OperationCausedStackOverflow;
    public static MessageID IDS_AwaitInCatchAndFinally;
    public static MessageID IDS_FeatureReadonlyAutoImplementedProperties;
    public static MessageID IDS_FeatureIOperation;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.MessageIDExtensions : object {
    [ExtensionAttribute]
public static LocalizableErrorArgument Localize(MessageID id);
    [ExtensionAttribute]
internal static string RequiredFeature(MessageID feature);
    [ExtensionAttribute]
internal static LanguageVersion RequiredVersion(MessageID feature);
}
internal class Microsoft.CodeAnalysis.CSharp.MessageProvider : CommonMessageProvider {
    public static MessageProvider Instance;
    public string CodePrefix { get; }
    public Type ErrorCodeType { get; }
    public int ERR_FailedToCreateTempFile { get; }
    public int ERR_ExpectedSingleScript { get; }
    public int ERR_OpenResponseFile { get; }
    public int ERR_InvalidPathMap { get; }
    public int FTL_InputFileNameTooLong { get; }
    public int ERR_FileNotFound { get; }
    public int ERR_NoSourceFile { get; }
    public int ERR_CantOpenFileWrite { get; }
    public int ERR_OutputWriteFailed { get; }
    public int WRN_NoConfigNotOnCommandLine { get; }
    public int ERR_BinaryFile { get; }
    public int WRN_AnalyzerCannotBeCreated { get; }
    public int WRN_NoAnalyzerInAssembly { get; }
    public int WRN_UnableToLoadAnalyzer { get; }
    public int INF_UnableToLoadSomeTypesInAnalyzer { get; }
    public int ERR_CantReadRulesetFile { get; }
    public int ERR_CompileCancelled { get; }
    public int ERR_BadCompilationOptionValue { get; }
    public int ERR_MutuallyExclusiveOptions { get; }
    public int ERR_InvalidDebugInformationFormat { get; }
    public int ERR_InvalidOutputName { get; }
    public int ERR_InvalidFileAlignment { get; }
    public int ERR_InvalidSubsystemVersion { get; }
    public int ERR_MetadataFileNotAssembly { get; }
    public int ERR_MetadataFileNotModule { get; }
    public int ERR_InvalidAssemblyMetadata { get; }
    public int ERR_InvalidModuleMetadata { get; }
    public int ERR_ErrorOpeningAssemblyFile { get; }
    public int ERR_ErrorOpeningModuleFile { get; }
    public int ERR_MetadataFileNotFound { get; }
    public int ERR_MetadataReferencesNotSupported { get; }
    public int ERR_LinkedNetmoduleMetadataMustProvideFullPEImage { get; }
    public int ERR_PublicKeyFileFailure { get; }
    public int ERR_PublicKeyContainerFailure { get; }
    public int ERR_OptionMustBeAbsolutePath { get; }
    public int ERR_CantReadResource { get; }
    public int ERR_CantOpenWin32Resource { get; }
    public int ERR_CantOpenWin32Manifest { get; }
    public int ERR_CantOpenWin32Icon { get; }
    public int ERR_ErrorBuildingWin32Resource { get; }
    public int ERR_BadWin32Resource { get; }
    public int ERR_ResourceFileNameNotUnique { get; }
    public int ERR_ResourceNotUnique { get; }
    public int ERR_ResourceInModule { get; }
    public int ERR_PermissionSetAttributeFileReadError { get; }
    public int WRN_PdbUsingNameTooLong { get; }
    public int WRN_PdbLocalNameTooLong { get; }
    public int ERR_PdbWritingFailed { get; }
    public int ERR_MetadataNameTooLong { get; }
    public int ERR_EncReferenceToAddedMember { get; }
    public int ERR_TooManyUserStrings { get; }
    public int ERR_PeWritingFailure { get; }
    public int ERR_ModuleEmitFailure { get; }
    public int ERR_EncUpdateFailedMissingAttribute { get; }
    private static MessageProvider();
    private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    private sealed virtual override Func`2<ObjectReader, object> Roslyn.Utilities.IObjectReadable.GetReader();
    public virtual DiagnosticSeverity GetSeverity(int code);
    public virtual string LoadMessage(int code, CultureInfo language);
    public virtual LocalizableString GetMessageFormat(int code);
    public virtual LocalizableString GetDescription(int code);
    public virtual LocalizableString GetTitle(int code);
    public virtual string GetHelpLink(int code);
    public virtual string GetCategory(int code);
    public virtual string get_CodePrefix();
    public virtual string GetMessagePrefix(string id, DiagnosticSeverity severity, bool isWarningAsError, CultureInfo culture);
    public virtual int GetWarningLevel(int code);
    public virtual Type get_ErrorCodeType();
    public virtual Diagnostic CreateDiagnostic(int code, Location location, Object[] args);
    public virtual string GetErrorDisplayString(ISymbol symbol);
    public virtual ReportDiagnostic GetDiagnosticReport(DiagnosticInfo diagnosticInfo, CompilationOptions options);
    public virtual int get_ERR_FailedToCreateTempFile();
    public virtual int get_ERR_ExpectedSingleScript();
    public virtual int get_ERR_OpenResponseFile();
    public virtual int get_ERR_InvalidPathMap();
    public virtual int get_FTL_InputFileNameTooLong();
    public virtual int get_ERR_FileNotFound();
    public virtual int get_ERR_NoSourceFile();
    public virtual int get_ERR_CantOpenFileWrite();
    public virtual int get_ERR_OutputWriteFailed();
    public virtual int get_WRN_NoConfigNotOnCommandLine();
    public virtual int get_ERR_BinaryFile();
    public virtual int get_WRN_AnalyzerCannotBeCreated();
    public virtual int get_WRN_NoAnalyzerInAssembly();
    public virtual int get_WRN_UnableToLoadAnalyzer();
    public virtual int get_INF_UnableToLoadSomeTypesInAnalyzer();
    public virtual int get_ERR_CantReadRulesetFile();
    public virtual int get_ERR_CompileCancelled();
    public virtual int get_ERR_BadCompilationOptionValue();
    public virtual int get_ERR_MutuallyExclusiveOptions();
    public virtual int get_ERR_InvalidDebugInformationFormat();
    public virtual int get_ERR_InvalidOutputName();
    public virtual int get_ERR_InvalidFileAlignment();
    public virtual int get_ERR_InvalidSubsystemVersion();
    public virtual int get_ERR_MetadataFileNotAssembly();
    public virtual int get_ERR_MetadataFileNotModule();
    public virtual int get_ERR_InvalidAssemblyMetadata();
    public virtual int get_ERR_InvalidModuleMetadata();
    public virtual int get_ERR_ErrorOpeningAssemblyFile();
    public virtual int get_ERR_ErrorOpeningModuleFile();
    public virtual int get_ERR_MetadataFileNotFound();
    public virtual int get_ERR_MetadataReferencesNotSupported();
    public virtual int get_ERR_LinkedNetmoduleMetadataMustProvideFullPEImage();
    public virtual void ReportDuplicateMetadataReferenceStrong(DiagnosticBag diagnostics, Location location, MetadataReference reference, AssemblyIdentity identity, MetadataReference equivalentReference, AssemblyIdentity equivalentIdentity);
    public virtual void ReportDuplicateMetadataReferenceWeak(DiagnosticBag diagnostics, Location location, MetadataReference reference, AssemblyIdentity identity, MetadataReference equivalentReference, AssemblyIdentity equivalentIdentity);
    public virtual int get_ERR_PublicKeyFileFailure();
    public virtual int get_ERR_PublicKeyContainerFailure();
    public virtual int get_ERR_OptionMustBeAbsolutePath();
    public virtual int get_ERR_CantReadResource();
    public virtual int get_ERR_CantOpenWin32Resource();
    public virtual int get_ERR_CantOpenWin32Manifest();
    public virtual int get_ERR_CantOpenWin32Icon();
    public virtual int get_ERR_ErrorBuildingWin32Resource();
    public virtual int get_ERR_BadWin32Resource();
    public virtual int get_ERR_ResourceFileNameNotUnique();
    public virtual int get_ERR_ResourceNotUnique();
    public virtual int get_ERR_ResourceInModule();
    public virtual int get_ERR_PermissionSetAttributeFileReadError();
    public virtual int get_WRN_PdbUsingNameTooLong();
    public virtual int get_WRN_PdbLocalNameTooLong();
    public virtual int get_ERR_PdbWritingFailed();
    public virtual int get_ERR_MetadataNameTooLong();
    public virtual int get_ERR_EncReferenceToAddedMember();
    public virtual int get_ERR_TooManyUserStrings();
    public virtual int get_ERR_PeWritingFailure();
    public virtual int get_ERR_ModuleEmitFailure();
    public virtual int get_ERR_EncUpdateFailedMissingAttribute();
    public virtual void ReportInvalidAttributeArgument(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int parameterIndex, AttributeData attribute);
    public virtual void ReportInvalidNamedArgument(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int namedArgumentIndex, ITypeSymbol attributeClass, string parameterName);
    public virtual void ReportParameterNotValidForType(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int namedArgumentIndex);
    public virtual void ReportMarshalUnmanagedTypeNotValidForFields(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int parameterIndex, string unmanagedTypeName, AttributeData attribute);
    public virtual void ReportMarshalUnmanagedTypeOnlyValidForFields(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int parameterIndex, string unmanagedTypeName, AttributeData attribute);
    public virtual void ReportAttributeParameterRequired(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, string parameterName);
    public virtual void ReportAttributeParameterRequired(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, string parameterName1, string parameterName2);
}
internal class Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel : MemberSemanticModel {
    private MethodBodySemanticModel(CSharpCompilation compilation, Symbol owner, Binder rootBinder, CSharpSyntaxNode syntax, SyntaxTreeSemanticModel parentSemanticModelOpt, int speculatedPosition);
    internal static MethodBodySemanticModel Create(CSharpCompilation compilation, MethodSymbol owner, Binder rootBinder, CSharpSyntaxNode syntax);
    internal virtual BoundNode Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics);
    internal virtual BoundNode GetBoundRoot();
    internal static MethodBodySemanticModel CreateSpeculative(SyntaxTreeSemanticModel parentSemanticModel, MethodSymbol owner, StatementSyntax syntax, Binder rootBinder, int position);
    internal static MethodBodySemanticModel CreateSpeculative(SyntaxTreeSemanticModel parentSemanticModel, MethodSymbol owner, ArrowExpressionClauseSyntax syntax, Binder rootBinder, int position);
    internal virtual bool TryGetSpeculativeSemanticModelForMethodBodyCore(SyntaxTreeSemanticModel parentModel, int position, BaseMethodDeclarationSyntax method, SemanticModel& speculativeModel);
    private bool GetSpeculativeSemanticModelForMethodBody(SyntaxTreeSemanticModel parentModel, int position, BlockSyntax body, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelForMethodBodyCore(SyntaxTreeSemanticModel parentModel, int position, AccessorDeclarationSyntax accessor, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, StatementSyntax statement, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, ArrowExpressionClauseSyntax expressionBody, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, ConstructorInitializerSyntax constructorInitializer, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, EqualsValueClauseSyntax initializer, SemanticModel& speculativeModel);
}
internal static class Microsoft.CodeAnalysis.CSharp.MethodBodySynthesizer : object {
    internal static ImmutableArray`1<BoundStatement> ConstructScriptConstructorBody(BoundStatement loweredBody, MethodSymbol constructor, SynthesizedSubmissionFields previousSubmissionFields, CSharpCompilation compilation);
    private static void MakeSubmissionInitialization(ArrayBuilder`1<BoundStatement> statements, CSharpSyntaxNode syntax, MethodSymbol submissionConstructor, SynthesizedSubmissionFields synthesizedFields, CSharpCompilation compilation);
    internal static BoundBlock ConstructAutoPropertyAccessorBody(SourceMethodSymbol accessor);
    internal static BoundBlock ConstructFieldLikeEventAccessorBody(SourceEventSymbol eventSymbol, bool isAddMethod, CSharpCompilation compilation, DiagnosticBag diagnostics);
    internal static BoundBlock ConstructFieldLikeEventAccessorBody_WinRT(SourceEventSymbol eventSymbol, bool isAddMethod, CSharpCompilation compilation, DiagnosticBag diagnostics);
    internal static BoundBlock ConstructFieldLikeEventAccessorBody_Regular(SourceEventSymbol eventSymbol, bool isAddMethod, CSharpCompilation compilation, DiagnosticBag diagnostics);
    internal static BoundBlock ConstructDestructorBody(MethodSymbol method, BoundBlock block);
    private static MethodSymbol GetBaseTypeFinalizeMethod(MethodSymbol method);
}
internal class Microsoft.CodeAnalysis.CSharp.MethodCompiler : CSharpSymbolVisitor`2<TypeCompilationState, object> {
    private CSharpCompilation _compilation;
    private bool _emittingPdb;
    private CancellationToken _cancellationToken;
    private DiagnosticBag _diagnostics;
    private bool _hasDeclarationErrors;
    private PEModuleBuilder _moduleBeingBuiltOpt;
    private Predicate`1<Symbol> _filterOpt;
    private DebugDocumentProvider _debugDocumentProvider;
    private ConcurrentStack`1<Task> _compilerTasks;
    private bool _globalHasErrors;
    internal MethodCompiler(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, bool emittingPdb, bool hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1<Symbol> filterOpt, CancellationToken cancellationToken);
    private void SetGlobalErrorIfTrue(bool arg);
    public static void CompileMethodBodies(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, bool generateDebugInfo, bool hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1<Symbol> filterOpt, CancellationToken cancellationToken);
    private static MethodSymbol GetEntryPoint(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuilt, bool hasDeclarationErrors, DiagnosticBag diagnostics, CancellationToken cancellationToken);
    private void WaitForWorkers();
    private static void WarnUnusedFields(CSharpCompilation compilation, DiagnosticBag diagnostics, CancellationToken cancellationToken);
    public virtual object VisitNamespace(NamespaceSymbol symbol, TypeCompilationState arg);
    private Task CompileNamespaceAsTask(NamespaceSymbol symbol);
    private void CompileNamespace(NamespaceSymbol symbol);
    public virtual object VisitNamedType(NamedTypeSymbol symbol, TypeCompilationState arg);
    private Task CompileNamedTypeAsTask(NamedTypeSymbol symbol);
    private void CompileNamedType(NamedTypeSymbol containingType);
    private void CompileSynthesizedMethods(PrivateImplementationDetails privateImplClass, DiagnosticBag diagnostics);
    private void CompileSynthesizedMethods(ImmutableArray`1<NamedTypeSymbol> additionalTypes, DiagnosticBag diagnostics);
    private void CompileSynthesizedMethods(TypeCompilationState compilationState);
    private static bool IsFieldLikeEventAccessor(MethodSymbol method);
    private void CompileSynthesizedExplicitImplementations(SourceMemberContainerTypeSymbol sourceTypeSymbol, TypeCompilationState compilationState);
    private void CompileSynthesizedSealedAccessors(SourcePropertySymbol sourceProperty, TypeCompilationState compilationState);
    private void CompileFieldLikeEventAccessor(SourceEventSymbol eventSymbol, bool isAddMethod);
    public virtual object VisitMethod(MethodSymbol symbol, TypeCompilationState arg);
    public virtual object VisitProperty(PropertySymbol symbol, TypeCompilationState argument);
    public virtual object VisitEvent(EventSymbol symbol, TypeCompilationState argument);
    public virtual object VisitField(FieldSymbol symbol, TypeCompilationState argument);
    private void CompileMethod(MethodSymbol methodSymbol, int methodOrdinal, ProcessedFieldInitializers& processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState);
    private BoundStatement ChainImplicitStructConstructor(MethodSymbol methodSymbol, SourceMemberContainerTypeSymbol containingType);
    internal static BoundStatement LowerBodyOrInitializer(MethodSymbol method, int methodOrdinal, BoundStatement body, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState, DiagnosticBag diagnostics, VariableSlotAllocator& lazyVariableSlotAllocator, ArrayBuilder`1<LambdaDebugInfo> lambdaDebugInfoBuilder, ArrayBuilder`1<ClosureDebugInfo> closureDebugInfoBuilder, StateMachineTypeSymbol& stateMachineTypeOpt);
    private static MethodBody GenerateMethodBody(PEModuleBuilder moduleBuilder, MethodSymbol method, int methodOrdinal, BoundStatement block, ImmutableArray`1<LambdaDebugInfo> lambdaDebugInfo, ImmutableArray`1<ClosureDebugInfo> closureDebugInfo, StateMachineTypeSymbol stateMachineTypeOpt, VariableSlotAllocator variableSlotAllocatorOpt, DiagnosticBag diagnostics, DebugDocumentProvider debugDocumentProvider, ImportChain importChainOpt, bool emittingPdb);
    private static void GetStateMachineSlotDebugInfo(PEModuleBuilder moduleBuilder, IEnumerable`1<IFieldDefinition> fieldDefs, VariableSlotAllocator variableSlotAllocatorOpt, DiagnosticBag diagnostics, ImmutableArray`1& hoistedVariableSlots, ImmutableArray`1& awaiterSlots);
    internal static BoundBlock BindMethodBody(MethodSymbol method, TypeCompilationState compilationState, DiagnosticBag diagnostics);
    private static BoundBlock BindMethodBody(MethodSymbol method, TypeCompilationState compilationState, DiagnosticBag diagnostics, ImportChain& importChain, Boolean& originalBodyNested);
    private static BoundStatement BindConstructorInitializerIfAny(MethodSymbol method, TypeCompilationState compilationState, DiagnosticBag diagnostics);
    internal static BoundExpression BindConstructorInitializer(MethodSymbol constructor, DiagnosticBag diagnostics, CSharpCompilation compilation);
    private static SyntaxToken GetImplicitConstructorBodyToken(CSharpSyntaxNode containerNode);
    internal static BoundCall GenerateObjectConstructorInitializer(MethodSymbol constructor, DiagnosticBag diagnostics);
    private static void GenerateExternalMethodWarnings(SourceMethodSymbol methodSymbol, DiagnosticBag diagnostics);
    private static bool HasThisConstructorInitializer(MethodSymbol method);
    private static DebugSourceDocument CreateDebugDocumentForFile(string normalizedPath);
    private static bool PassesFilter(Predicate`1<Symbol> filterOpt, Symbol symbol);
}
internal class Microsoft.CodeAnalysis.CSharp.MethodGroup : object {
    [CompilerGeneratedAttribute]
private BoundExpression <Receiver>k__BackingField;
    [CompilerGeneratedAttribute]
private ArrayBuilder`1<MethodSymbol> <Methods>k__BackingField;
    [CompilerGeneratedAttribute]
private ArrayBuilder`1<TypeSymbol> <TypeArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExtensionMethodGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticInfo <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private LookupResultKind <ResultKind>k__BackingField;
    public static ObjectPool`1<MethodGroup> Pool;
    internal BoundExpression Receiver { get; private set; }
    internal ArrayBuilder`1<MethodSymbol> Methods { get; }
    internal ArrayBuilder`1<TypeSymbol> TypeArguments { get; }
    internal bool IsExtensionMethodGroup { get; private set; }
    internal DiagnosticInfo Error { get; private set; }
    internal LookupResultKind ResultKind { get; private set; }
    public string Name { get; }
    public BoundExpression InstanceOpt { get; }
    private static MethodGroup();
    [CompilerGeneratedAttribute]
internal BoundExpression get_Receiver();
    [CompilerGeneratedAttribute]
private void set_Receiver(BoundExpression value);
    [CompilerGeneratedAttribute]
internal ArrayBuilder`1<MethodSymbol> get_Methods();
    [CompilerGeneratedAttribute]
internal ArrayBuilder`1<TypeSymbol> get_TypeArguments();
    [CompilerGeneratedAttribute]
internal bool get_IsExtensionMethodGroup();
    [CompilerGeneratedAttribute]
private void set_IsExtensionMethodGroup(bool value);
    [CompilerGeneratedAttribute]
internal DiagnosticInfo get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(DiagnosticInfo value);
    [CompilerGeneratedAttribute]
internal LookupResultKind get_ResultKind();
    [CompilerGeneratedAttribute]
private void set_ResultKind(LookupResultKind value);
    internal void PopulateWithSingleMethod(BoundExpression receiverOpt, MethodSymbol method, LookupResultKind resultKind, DiagnosticInfo error);
    internal void PopulateWithExtensionMethods(BoundExpression receiverOpt, ArrayBuilder`1<Symbol> members, ImmutableArray`1<TypeSymbol> typeArguments, LookupResultKind resultKind, DiagnosticInfo error);
    internal void PopulateWithNonExtensionMethods(BoundExpression receiverOpt, ImmutableArray`1<MethodSymbol> methods, ImmutableArray`1<TypeSymbol> typeArguments, LookupResultKind resultKind, DiagnosticInfo error);
    private void PopulateHelper(BoundExpression receiverOpt, LookupResultKind resultKind, DiagnosticInfo error);
    public void Clear();
    public string get_Name();
    public BoundExpression get_InstanceOpt();
    [ConditionalAttribute("DEBUG")]
private void VerifyClear();
    public static MethodGroup GetInstance();
    public void Free();
    private static ObjectPool`1<MethodGroup> CreatePool();
}
internal class Microsoft.CodeAnalysis.CSharp.MethodGroupResolution : ValueType {
    public MethodGroup MethodGroup;
    public Symbol OtherSymbol;
    public OverloadResolutionResult`1<MethodSymbol> OverloadResolutionResult;
    public AnalyzedArguments AnalyzedArguments;
    public ImmutableArray`1<Diagnostic> Diagnostics;
    public LookupResultKind ResultKind;
    public bool ExtensionMethodsOfSameViabilityAreAvailable;
    public bool IsEmpty { get; }
    public bool HasAnyErrors { get; }
    public bool HasAnyApplicableMethod { get; }
    public bool IsExtensionMethodGroup { get; }
    public MethodGroupResolution(MethodGroup methodGroup, ImmutableArray`1<Diagnostic> diagnostics);
    public MethodGroupResolution(MethodGroup methodGroup, OverloadResolutionResult`1<MethodSymbol> overloadResolutionResult, AnalyzedArguments analyzedArguments, ImmutableArray`1<Diagnostic> diagnostics);
    public MethodGroupResolution(Symbol otherSymbol, LookupResultKind resultKind, ImmutableArray`1<Diagnostic> diagnostics);
    public MethodGroupResolution(MethodGroup methodGroup, Symbol otherSymbol, OverloadResolutionResult`1<MethodSymbol> overloadResolutionResult, AnalyzedArguments analyzedArguments, LookupResultKind resultKind, ImmutableArray`1<Diagnostic> diagnostics, bool extensionMethodsOfSameViabilityAreAvailable);
    public bool get_IsEmpty();
    public bool get_HasAnyErrors();
    public bool get_HasAnyApplicableMethod();
    public bool get_IsExtensionMethodGroup();
    public void Free();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter : MethodToClassRewriter {
    internal MethodSymbol OriginalMethod;
    private bool _useFinalizerBookkeeping;
    protected SyntheticBoundNodeFactory F;
    protected FieldSymbol stateField;
    protected LocalSymbol cachedState;
    private int _nextState;
    private Dictionary`2<LabelSymbol, List`1<int>> _dispatches;
    protected Dictionary`2<int, int> finalizerStateMap;
    private bool _hasFinalizerState;
    private int _currentFinalizerState;
    private Dictionary`2<TypeSymbol, ArrayBuilder`1<StateMachineFieldSymbol>> _lazyAvailableReusableHoistedFields;
    private int _nextHoistedFieldId;
    private EmptyStructTypeCache _emptyStructTypeCache;
    private IReadOnlySet`1<Symbol> _hoistedVariables;
    private SynthesizedLocalOrdinalsDispenser _synthesizedLocalOrdinals;
    private int _nextFreeHoistedLocalSlot;
    protected TypeMap TypeMap { get; }
    protected MethodSymbol CurrentMethod { get; }
    protected NamedTypeSymbol ContainingType { get; }
    internal IReadOnlySet`1<Symbol> HoistedVariables { get; }
    public MethodToStateMachineRewriter(SyntheticBoundNodeFactory F, MethodSymbol originalMethod, FieldSymbol state, IReadOnlySet`1<Symbol> hoistedVariables, IReadOnlyDictionary`2<Symbol, CapturedSymbolReplacement> nonReusableLocalProxies, SynthesizedLocalOrdinalsDispenser synthesizedLocalOrdinals, VariableSlotAllocator slotAllocatorOpt, int nextFreeHoistedLocalSlot, DiagnosticBag diagnostics, bool useFinalizerBookkeeping);
    protected abstract virtual BoundStatement GenerateReturn(bool finished);
    protected virtual bool NeedsProxy(Symbol localOrParameter);
    protected virtual TypeMap get_TypeMap();
    protected virtual MethodSymbol get_CurrentMethod();
    protected virtual NamedTypeSymbol get_ContainingType();
    internal IReadOnlySet`1<Symbol> get_HoistedVariables();
    protected virtual BoundExpression FramePointer(CSharpSyntaxNode syntax, NamedTypeSymbol frameClass);
    protected void AddState(Int32& stateNumber, GeneratedLabelSymbol& resumeLabel);
    protected BoundStatement Dispatch();
    private BoundStatement PossibleIteratorScope(ImmutableArray`1<LocalSymbol> locals, Func`1<BoundStatement> wrapped);
    internal BoundBlock MakeStateMachineScope(ImmutableArray`1<StateMachineFieldSymbol> hoistedLocals, BoundStatement statement);
    internal bool TryUnwrapBoundStateMachineScope(BoundStatement& statement, ImmutableArray`1& hoistedLocals);
    private void AddVariableCleanup(ArrayBuilder`1<BoundAssignmentOperator> cleanup, FieldSymbol field);
    private bool MightContainReferences(TypeSymbol type);
    private StateMachineFieldSymbol GetOrAllocateReusableHoistedField(TypeSymbol type);
    private void FreeReusableHoistedField(StateMachineFieldSymbol field);
    private BoundExpression HoistRefInitialization(SynthesizedLocal local, BoundAssignmentOperator node);
    private BoundExpression HoistExpression(BoundExpression expr, AwaitExpressionSyntax awaitSyntaxOpt, int syntaxOffset, bool isRef, ArrayBuilder`1<BoundExpression> sideEffects, ArrayBuilder`1<StateMachineFieldSymbol> hoistedFields, Boolean& needsSacrificialEvaluation);
    public virtual BoundNode Visit(BoundNode node);
    public virtual BoundNode VisitBlock(BoundBlock node);
    public virtual BoundNode VisitSwitchStatement(BoundSwitchStatement node);
    public virtual BoundNode VisitForStatement(BoundForStatement node);
    public virtual BoundNode VisitUsingStatement(BoundUsingStatement node);
    public virtual BoundNode VisitExpressionStatement(BoundExpressionStatement node);
    public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node);
    public virtual BoundNode VisitTryStatement(BoundTryStatement node);
    public virtual BoundNode VisitThisReference(BoundThisReference node);
    public virtual BoundNode VisitBaseReference(BoundBaseReference node);
    [CompilerGeneratedAttribute]
private BoundSwitchSection <Dispatch>b__29_1(KeyValuePair`2<LabelSymbol, List`1<int>> kv);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private BoundNode <>n__0(BoundBlock node);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private BoundNode <>n__1(BoundSwitchStatement node);
    [CompilerGeneratedAttribute]
private BoundExpression <VisitThisReference>b__47_0(NamedTypeSymbol frameType);
    [CompilerGeneratedAttribute]
private BoundExpression <VisitBaseReference>b__48_0(NamedTypeSymbol frameType);
}
internal class Microsoft.CodeAnalysis.CSharp.MethodTypeInferenceResult : ValueType {
    public ImmutableArray`1<TypeSymbol> InferredTypeArguments;
    public bool Success;
    public MethodTypeInferenceResult(bool success, ImmutableArray`1<TypeSymbol> inferredTypeArguments);
}
internal class Microsoft.CodeAnalysis.CSharp.MethodTypeInferrer : object {
    private ConversionsBase _conversions;
    private ImmutableArray`1<TypeParameterSymbol> _methodTypeParameters;
    private NamedTypeSymbol _constructedContainingTypeOfMethod;
    private ImmutableArray`1<TypeSymbol> _formalParameterTypes;
    private ImmutableArray`1<RefKind> _formalParameterRefKinds;
    private ImmutableArray`1<TypeSymbol> _argumentTypes;
    private ImmutableArray`1<BoundExpression> _arguments;
    private TypeSymbol[] _fixedResults;
    private HashSet`1[] _exactBounds;
    private HashSet`1[] _upperBounds;
    private HashSet`1[] _lowerBounds;
    private Dependency[0...,0...] _dependencies;
    private bool _dependenciesDirty;
    private MethodTypeInferrer(ConversionsBase conversions, ImmutableArray`1<TypeParameterSymbol> methodTypeParameters, NamedTypeSymbol constructedContainingTypeOfMethod, ImmutableArray`1<TypeSymbol> formalParameterTypes, ImmutableArray`1<RefKind> formalParameterRefKinds, ImmutableArray`1<TypeSymbol> argumentTypes, ImmutableArray`1<BoundExpression> arguments);
    public static MethodTypeInferenceResult Infer(Binder binder, ImmutableArray`1<TypeParameterSymbol> methodTypeParameters, NamedTypeSymbol constructedContainingTypeOfMethod, ImmutableArray`1<TypeSymbol> formalParameterTypes, ImmutableArray`1<RefKind> formalParameterRefKinds, ImmutableArray`1<TypeSymbol> argumentTypes, ImmutableArray`1<BoundExpression> arguments, HashSet`1& useSiteDiagnostics);
    private RefKind GetRefKind(int index);
    private ImmutableArray`1<TypeSymbol> GetResults();
    private bool ValidIndex(int index);
    private bool IsUnfixed(int methodTypeParameterIndex);
    private bool IsUnfixedTypeParameter(TypeSymbol type);
    private bool AllFixed();
    private void AddLowerBound(TypeParameterSymbol methodTypeParameter, TypeSymbol lowerBound);
    private void AddUpperBound(TypeParameterSymbol methodTypeParameter, TypeSymbol upperBound);
    private void AddExactBound(TypeParameterSymbol methodTypeParameter, TypeSymbol exactBound);
    private bool HasBound(int methodTypeParameterIndex);
    private NamedTypeSymbol GetFixedDelegate(NamedTypeSymbol delegateType);
    private MethodTypeInferenceResult InferTypeArgs(Binder binder, HashSet`1& useSiteDiagnostics);
    private void InferTypeArgsFirstPhase(HashSet`1& useSiteDiagnostics);
    private bool InferTypeArgsSecondPhase(Binder binder, HashSet`1& useSiteDiagnostics);
    private InferenceResult DoSecondPhase(Binder binder, HashSet`1& useSiteDiagnostics);
    private void MakeOutputTypeInferences(Binder binder, HashSet`1& useSiteDiagnostics);
    private InferenceResult FixNondependentParameters(HashSet`1& useSiteDiagnostics);
    private InferenceResult FixDependentParameters(HashSet`1& useSiteDiagnostics);
    private static bool DoesInputTypeContain(BoundExpression argument, TypeSymbol formalParameterType, TypeParameterSymbol typeParameter);
    private bool HasUnfixedParamInInputType(BoundExpression pSource, TypeSymbol pDest);
    private static bool DoesOutputTypeContain(BoundExpression argument, TypeSymbol formalParameterType, TypeParameterSymbol typeParameter);
    private bool HasUnfixedParamInOutputType(BoundExpression argument, TypeSymbol formalParameterType);
    private bool DependsDirectlyOn(int iParam, int jParam);
    private void InitializeDependencies();
    private bool DependsOn(int iParam, int jParam);
    private bool DependsTransitivelyOn(int iParam, int jParam);
    private void DeduceAllDependencies();
    private bool DeduceDependencies();
    private void SetUnknownsToNotDependent();
    private void SetIndirectsToUnknown();
    private void UpdateDependenciesAfterFix(int iParam);
    private bool DependsOnAny(int iParam);
    private bool AnyDependsOn(int iParam);
    private void OutputTypeInference(Binder binder, BoundExpression expression, TypeSymbol source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private bool InferredReturnTypeInference(BoundExpression source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private bool MethodGroupReturnTypeInference(Binder binder, BoundExpression source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private static TypeSymbol MethodGroupReturnType(Binder binder, BoundMethodGroup source, ImmutableArray`1<ParameterSymbol> delegateParameters, HashSet`1& useSiteDiagnostics);
    private void ExplicitParameterTypeInference(BoundExpression source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private void ExactInference(TypeSymbol source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private bool ExactTypeParameterInference(TypeSymbol source, TypeSymbol target);
    private bool ExactArrayInference(TypeSymbol source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private bool LowerNullableInference(TypeSymbol source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private bool ExactNullableInference(TypeSymbol source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private bool ExactConstructedInference(TypeSymbol source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private void ExactTypeArgumentInference(NamedTypeSymbol source, NamedTypeSymbol target, HashSet`1& useSiteDiagnostics);
    private void LowerBoundInference(TypeSymbol source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private bool LowerBoundTypeParameterInference(TypeSymbol source, TypeSymbol target);
    private static TypeSymbol GetMatchingElementType(ArrayTypeSymbol source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private bool LowerBoundArrayInference(TypeSymbol source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private bool LowerBoundNullableInference(TypeSymbol source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private bool LowerBoundConstructedInference(TypeSymbol source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private bool LowerBoundClassInference(TypeSymbol source, NamedTypeSymbol target, HashSet`1& useSiteDiagnostics);
    private bool LowerBoundInterfaceInference(TypeSymbol source, NamedTypeSymbol target, HashSet`1& useSiteDiagnostics);
    private void LowerBoundTypeArgumentInference(NamedTypeSymbol source, NamedTypeSymbol target, HashSet`1& useSiteDiagnostics);
    private void UpperBoundInference(TypeSymbol source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private bool UpperBoundTypeParameterInference(TypeSymbol source, TypeSymbol target);
    private bool UpperBoundArrayInference(TypeSymbol source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private bool UpperBoundConstructedInference(TypeSymbol source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private bool UpperBoundClassInference(NamedTypeSymbol source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private bool UpperBoundInterfaceInference(NamedTypeSymbol source, TypeSymbol target, HashSet`1& useSiteDiagnostics);
    private void UpperBoundTypeArgumentInference(NamedTypeSymbol source, NamedTypeSymbol target, HashSet`1& useSiteDiagnostics);
    private bool Fix(int iParam, HashSet`1& useSiteDiagnostics);
    private bool ImplicitConversionExists(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private TypeSymbol InferReturnType(BoundExpression source, NamedTypeSymbol target, HashSet`1& useSiteDiagnostics);
    private static NamedTypeSymbol GetInterfaceInferenceBound(ImmutableArray`1<NamedTypeSymbol> interfaces, NamedTypeSymbol target);
    public static ImmutableArray`1<TypeSymbol> InferTypeArgumentsFromFirstArgument(ConversionsBase conversions, MethodSymbol method, ImmutableArray`1<TypeSymbol> argumentTypes, ImmutableArray`1<BoundExpression> arguments, HashSet`1& useSiteDiagnostics);
    private bool InferTypeArgumentsFromFirstArgument(HashSet`1& useSiteDiagnostics);
    private ImmutableArray`1<TypeSymbol> GetInferredTypeArguments();
    private static bool IsReallyAType(TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.CSharp.ModuleCompilationState : ModuleCompilationState`2<NamedTypeSymbol, MethodSymbol> {
}
internal class Microsoft.CodeAnalysis.CSharp.NameofBinder : Binder {
    private SyntaxNode _nameofArgument;
    protected SyntaxNode EnclosingNameofArgument { get; }
    public NameofBinder(SyntaxNode nameofArgument, Binder next);
    protected virtual SyntaxNode get_EnclosingNameofArgument();
}
internal class Microsoft.CodeAnalysis.CSharp.NamespaceDeclarationSyntaxReference : TranslationSyntaxReference {
    public NamespaceDeclarationSyntaxReference(SyntaxReference reference);
    protected virtual SyntaxNode Translate(SyntaxReference reference, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.NamespaceOrTypeAndUsingDirective : ValueType {
    public NamespaceOrTypeSymbol NamespaceOrType;
    public UsingDirectiveSyntax UsingDirective;
    public NamespaceOrTypeAndUsingDirective(NamespaceOrTypeSymbol namespaceOrType, UsingDirectiveSyntax usingDirective);
}
internal class Microsoft.CodeAnalysis.CSharp.NeverEmptyStructTypeCache : EmptyStructTypeCache {
    public virtual bool IsEmptyStructType(TypeSymbol type);
}
internal enum Microsoft.CodeAnalysis.CSharp.NoOpStatementFlavor : Enum {
    public int value__;
    public static NoOpStatementFlavor Default;
    public static NoOpStatementFlavor AwaitYieldPoint;
    public static NoOpStatementFlavor AwaitResumePoint;
}
internal static class Microsoft.CodeAnalysis.CSharp.ObjectDisplay : object {
    internal static string NullLiteral { get; }
    public static string FormatPrimitive(object obj, ObjectDisplayOptions options);
    internal static string get_NullLiteral();
    internal static string FormatLiteral(bool value);
    private static bool TryReplaceQuote(char c, char quote, String& replaceWith);
    private static bool TryReplaceChar(char c, String& replaceWith);
    public static string FormatLiteral(string value, ObjectDisplayOptions options);
    private static bool ContainsNewLine(string s);
    internal static string FormatLiteral(char c, ObjectDisplayOptions options);
    internal static string FormatLiteral(sbyte value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(byte value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(short value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(ushort value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(int value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(UInt32 value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(long value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(ulong value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(double value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(float value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(decimal value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    private static CultureInfo GetFormatCulture(CultureInfo cultureInfo);
}
internal enum Microsoft.CodeAnalysis.CSharp.OperatorAnalysisResultKind : Enum {
    public byte value__;
    public static OperatorAnalysisResultKind Undefined;
    public static OperatorAnalysisResultKind Inapplicable;
    public static OperatorAnalysisResultKind Worse;
    public static OperatorAnalysisResultKind Applicable;
}
internal static class Microsoft.CodeAnalysis.CSharp.OperatorFacts : object {
    public static bool DefinitelyHasNoUserDefinedOperators(TypeSymbol type);
    public static string BinaryOperatorNameFromSyntaxKind(SyntaxKind kind);
    internal static string BinaryOperatorNameFromSyntaxKindIfAny(SyntaxKind kind);
    public static string UnaryOperatorNameFromSyntaxKind(SyntaxKind kind);
    internal static string UnaryOperatorNameFromSyntaxKindIfAny(SyntaxKind kind);
    public static string OperatorNameFromDeclaration(OperatorDeclarationSyntax declaration);
    public static string OperatorNameFromDeclaration(OperatorDeclarationSyntax declaration);
    public static string UnaryOperatorNameFromOperatorKind(UnaryOperatorKind kind);
    public static string BinaryOperatorNameFromOperatorKind(BinaryOperatorKind kind);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.OperatorKindExtensions : object {
    [ExtensionAttribute]
public static int OperatorIndex(UnaryOperatorKind kind);
    [ExtensionAttribute]
public static UnaryOperatorKind Operator(UnaryOperatorKind kind);
    [ExtensionAttribute]
public static UnaryOperatorKind Unlifted(UnaryOperatorKind kind);
    [ExtensionAttribute]
public static bool IsLifted(UnaryOperatorKind kind);
    [ExtensionAttribute]
public static bool IsChecked(UnaryOperatorKind kind);
    [ExtensionAttribute]
public static bool IsUserDefined(UnaryOperatorKind kind);
    [ExtensionAttribute]
public static UnaryOperatorKind OverflowChecks(UnaryOperatorKind kind);
    [ExtensionAttribute]
public static UnaryOperatorKind WithOverflowChecksIfApplicable(UnaryOperatorKind kind, bool enabled);
    [ExtensionAttribute]
public static UnaryOperatorKind OperandTypes(UnaryOperatorKind kind);
    [ExtensionAttribute]
public static bool IsDynamic(UnaryOperatorKind kind);
    [ExtensionAttribute]
public static bool IsIntegral(UnaryOperatorKind kind);
    [ExtensionAttribute]
public static UnaryOperatorKind WithType(UnaryOperatorKind kind, UnaryOperatorKind type);
    [ExtensionAttribute]
public static int OperatorIndex(BinaryOperatorKind kind);
    [ExtensionAttribute]
public static BinaryOperatorKind Operator(BinaryOperatorKind kind);
    [ExtensionAttribute]
public static BinaryOperatorKind Unlifted(BinaryOperatorKind kind);
    [ExtensionAttribute]
public static BinaryOperatorKind OperatorWithLogical(BinaryOperatorKind kind);
    [ExtensionAttribute]
public static BinaryOperatorKind WithType(BinaryOperatorKind kind, SpecialType type);
    [ExtensionAttribute]
public static UnaryOperatorKind WithType(UnaryOperatorKind kind, SpecialType type);
    [ExtensionAttribute]
public static BinaryOperatorKind WithType(BinaryOperatorKind kind, BinaryOperatorKind type);
    [ExtensionAttribute]
public static bool IsLifted(BinaryOperatorKind kind);
    [ExtensionAttribute]
public static bool IsDynamic(BinaryOperatorKind kind);
    [ExtensionAttribute]
public static bool IsComparison(BinaryOperatorKind kind);
    [ExtensionAttribute]
public static bool IsChecked(BinaryOperatorKind kind);
    [ExtensionAttribute]
public static bool EmitsAsCheckedInstruction(BinaryOperatorKind kind);
    [ExtensionAttribute]
public static BinaryOperatorKind WithOverflowChecksIfApplicable(BinaryOperatorKind kind, bool enabled);
    [ExtensionAttribute]
public static bool IsEnum(BinaryOperatorKind kind);
    [ExtensionAttribute]
public static bool IsEnum(UnaryOperatorKind kind);
    [ExtensionAttribute]
public static bool IsIntegral(BinaryOperatorKind kind);
    [ExtensionAttribute]
public static bool IsLogical(BinaryOperatorKind kind);
    [ExtensionAttribute]
public static BinaryOperatorKind OperandTypes(BinaryOperatorKind kind);
    [ExtensionAttribute]
public static bool IsUserDefined(BinaryOperatorKind kind);
    [ExtensionAttribute]
public static bool IsShift(BinaryOperatorKind kind);
    [ExtensionAttribute]
public static ExpressionType ToExpressionType(BinaryOperatorKind kind, bool isCompoundAssignment);
    [ExtensionAttribute]
public static ExpressionType ToExpressionType(UnaryOperatorKind kind);
    [ExtensionAttribute]
public static RefKind RefKinds(ImmutableArray`1<RefKind> ArgumentRefKinds, int index);
}
internal class Microsoft.CodeAnalysis.CSharp.OverloadResolution : object {
    private Binder _binder;
    private Nullable`1<bool> _strict;
    private CSharpCompilation Compilation { get; }
    private Conversions Conversions { get; }
    private bool Strict { get; }
    public OverloadResolution(Binder binder);
    private void BinaryOperatorEasyOut(BinaryOperatorKind kind, BoundExpression left, BoundExpression right, BinaryOperatorOverloadResolutionResult result);
    private static bool PossiblyUnusualConstantOperation(BoundExpression left, BoundExpression right);
    public void BinaryOperatorOverloadResolution(BinaryOperatorKind kind, BoundExpression left, BoundExpression right, BinaryOperatorOverloadResolutionResult result, HashSet`1& useSiteDiagnostics);
    private void AddDelegateOperation(BinaryOperatorKind kind, TypeSymbol delegateType, ArrayBuilder`1<BinaryOperatorSignature> operators);
    private void GetDelegateOperations(BinaryOperatorKind kind, BoundExpression left, BoundExpression right, ArrayBuilder`1<BinaryOperatorSignature> operators, HashSet`1& useSiteDiagnostics);
    private void GetEnumOperation(BinaryOperatorKind kind, TypeSymbol enumType, BoundExpression left, BoundExpression right, ArrayBuilder`1<BinaryOperatorSignature> operators);
    private void GetPointerArithmeticOperators(BinaryOperatorKind kind, PointerTypeSymbol pointerType, ArrayBuilder`1<BinaryOperatorSignature> operators);
    private void GetPointerComparisonOperators(BinaryOperatorKind kind, ArrayBuilder`1<BinaryOperatorSignature> operators);
    private void GetEnumOperations(BinaryOperatorKind kind, BoundExpression left, BoundExpression right, ArrayBuilder`1<BinaryOperatorSignature> results);
    private void GetPointerOperators(BinaryOperatorKind kind, BoundExpression left, BoundExpression right, ArrayBuilder`1<BinaryOperatorSignature> results);
    private void GetAllBuiltInOperators(BinaryOperatorKind kind, BoundExpression left, BoundExpression right, ArrayBuilder`1<BinaryOperatorAnalysisResult> results, HashSet`1& useSiteDiagnostics);
    private bool UseOnlyReferenceEquality(BoundExpression left, BoundExpression right, HashSet`1& useSiteDiagnostics);
    private void GetReferenceEquality(BinaryOperatorKind kind, ArrayBuilder`1<BinaryOperatorSignature> operators);
    private bool CandidateOperators(ArrayBuilder`1<BinaryOperatorSignature> operators, BoundExpression left, BoundExpression right, ArrayBuilder`1<BinaryOperatorAnalysisResult> results, HashSet`1& useSiteDiagnostics);
    private bool GetUserDefinedOperators(BinaryOperatorKind kind, BoundExpression left, BoundExpression right, ArrayBuilder`1<BinaryOperatorAnalysisResult> results, HashSet`1& useSiteDiagnostics);
    private static void AddDistinctOperators(ArrayBuilder`1<BinaryOperatorAnalysisResult> result, ArrayBuilder`1<BinaryOperatorAnalysisResult> additionalOperators);
    private bool GetUserDefinedOperators(BinaryOperatorKind kind, TypeSymbol type0, BoundExpression left, BoundExpression right, ArrayBuilder`1<BinaryOperatorAnalysisResult> results, HashSet`1& useSiteDiagnostics);
    private void GetUserDefinedBinaryOperatorsFromType(NamedTypeSymbol type, BinaryOperatorKind kind, string name, ArrayBuilder`1<BinaryOperatorSignature> operators);
    private static LiftingResult UserDefinedBinaryOperatorCanBeLifted(TypeSymbol left, TypeSymbol right, TypeSymbol result, BinaryOperatorKind kind);
    private void BinaryOperatorOverloadResolution(BoundExpression left, BoundExpression right, BinaryOperatorOverloadResolutionResult result, HashSet`1& useSiteDiagnostics);
    private bool IsApplicable(BinaryOperatorSignature binaryOperator, BoundExpression left, BoundExpression right, HashSet`1& useSiteDiagnostics);
    private BetterResult BetterOperator(BinaryOperatorSignature op1, BinaryOperatorSignature op2, BoundExpression left, BoundExpression right, HashSet`1& useSiteDiagnostics);
    private BetterResult MoreSpecificOperator(BinaryOperatorSignature op1, BinaryOperatorSignature op2, HashSet`1& useSiteDiagnostics);
    [ConditionalAttribute("DEBUG")]
private static void AssertNotChecked(BinaryOperatorKind kind);
    private void UnaryOperatorEasyOut(UnaryOperatorKind kind, BoundExpression operand, UnaryOperatorOverloadResolutionResult result);
    private NamedTypeSymbol MakeNullable(TypeSymbol type);
    public void UnaryOperatorOverloadResolution(UnaryOperatorKind kind, BoundExpression operand, UnaryOperatorOverloadResolutionResult result, HashSet`1& useSiteDiagnostics);
    private void UnaryOperatorOverloadResolution(BoundExpression operand, UnaryOperatorOverloadResolutionResult result, HashSet`1& useSiteDiagnostics);
    private BetterResult BetterOperator(UnaryOperatorSignature op1, UnaryOperatorSignature op2, BoundExpression operand, HashSet`1& useSiteDiagnostics);
    private void GetAllBuiltInOperators(UnaryOperatorKind kind, BoundExpression operand, ArrayBuilder`1<UnaryOperatorAnalysisResult> results, HashSet`1& useSiteDiagnostics);
    private bool CandidateOperators(ArrayBuilder`1<UnaryOperatorSignature> operators, BoundExpression operand, ArrayBuilder`1<UnaryOperatorAnalysisResult> results, HashSet`1& useSiteDiagnostics);
    private void GetEnumOperations(UnaryOperatorKind kind, BoundExpression operand, ArrayBuilder`1<UnaryOperatorSignature> operators);
    private static Nullable`1<UnaryOperatorSignature> GetPointerOperation(UnaryOperatorKind kind, BoundExpression operand);
    private bool GetUserDefinedOperators(UnaryOperatorKind kind, BoundExpression operand, ArrayBuilder`1<UnaryOperatorAnalysisResult> results, HashSet`1& useSiteDiagnostics);
    private void GetUserDefinedUnaryOperatorsFromType(NamedTypeSymbol type, UnaryOperatorKind kind, string name, ArrayBuilder`1<UnaryOperatorSignature> operators);
    private CSharpCompilation get_Compilation();
    private Conversions get_Conversions();
    private bool get_Strict();
    private static int RemainingCandidatesCount(ArrayBuilder`1<MemberResolutionResult`1<TMember>> list);
    public void ObjectCreationOverloadResolution(ImmutableArray`1<MethodSymbol> constructors, AnalyzedArguments arguments, OverloadResolutionResult`1<MethodSymbol> result, HashSet`1& useSiteDiagnostics);
    public void MethodInvocationOverloadResolution(ArrayBuilder`1<MethodSymbol> methods, ArrayBuilder`1<TypeSymbol> typeArguments, AnalyzedArguments arguments, OverloadResolutionResult`1<MethodSymbol> result, HashSet`1& useSiteDiagnostics, bool isMethodGroupConversion, bool allowRefOmittedArguments, bool inferWithDynamic, bool allowUnexpandedForm);
    public void PropertyOverloadResolution(ArrayBuilder`1<PropertySymbol> indexers, AnalyzedArguments arguments, OverloadResolutionResult`1<PropertySymbol> result, bool allowRefOmittedArguments, HashSet`1& useSiteDiagnostics);
    internal void MethodOrPropertyOverloadResolution(ArrayBuilder`1<TMember> members, ArrayBuilder`1<TypeSymbol> typeArguments, AnalyzedArguments arguments, OverloadResolutionResult`1<TMember> result, bool isMethodGroupConversion, bool allowRefOmittedArguments, HashSet`1& useSiteDiagnostics, bool inferWithDynamic, bool allowUnexpandedForm);
    private static bool OverloadResolutionResultIsValid(ArrayBuilder`1<MemberResolutionResult`1<TMember>> results, bool hasDynamicArgument);
    private void PerformMemberOverloadResolution(ArrayBuilder`1<MemberResolutionResult`1<TMember>> results, ArrayBuilder`1<TMember> members, ArrayBuilder`1<TypeSymbol> typeArguments, AnalyzedArguments arguments, bool completeResults, bool isMethodGroupConversion, bool allowRefOmittedArguments, HashSet`1& useSiteDiagnostics, bool inferWithDynamic, bool allowUnexpandedForm);
    private static Dictionary`2<NamedTypeSymbol, ArrayBuilder`1<TMember>> PartitionMembersByContainingType(ArrayBuilder`1<TMember> members);
    private static void ClearContainingTypeMap(Dictionary`2& containingTypeMapOpt);
    private void AddConstructorToCandidateSet(MethodSymbol constructor, ArrayBuilder`1<MemberResolutionResult`1<MethodSymbol>> results, AnalyzedArguments arguments, bool completeResults, HashSet`1& useSiteDiagnostics);
    private MemberAnalysisResult IsConstructorApplicableInNormalForm(MethodSymbol constructor, AnalyzedArguments arguments, HashSet`1& useSiteDiagnostics);
    private MemberAnalysisResult IsConstructorApplicableInExpandedForm(MethodSymbol constructor, AnalyzedArguments arguments, HashSet`1& useSiteDiagnostics);
    private void AddMemberToCandidateSet(TMember member, ArrayBuilder`1<MemberResolutionResult`1<TMember>> results, ArrayBuilder`1<TMember> members, ArrayBuilder`1<TypeSymbol> typeArguments, AnalyzedArguments arguments, bool completeResults, bool isMethodGroupConversion, bool allowRefOmittedArguments, Dictionary`2<NamedTypeSymbol, ArrayBuilder`1<TMember>> containingTypeMapOpt, bool inferWithDynamic, HashSet`1& useSiteDiagnostics, bool allowUnexpandedForm);
    private static bool PreferExpandedFormOverNormalForm(MemberAnalysisResult normalResult, MemberAnalysisResult expandedResult);
    public static bool IsValidParams(Symbol member);
    private static bool IsOverride(Symbol overridden, Symbol overrider);
    private static bool MemberGroupContainsOverride(ArrayBuilder`1<TMember> members, TMember member);
    private static bool MemberGroupHidesByName(ArrayBuilder`1<TMember> members, TMember member, HashSet`1& useSiteDiagnostics);
    private static bool HidesByName(Symbol member);
    private void RemoveInaccessibleTypeArguments(ArrayBuilder`1<MemberResolutionResult`1<TMember>> results, HashSet`1& useSiteDiagnostics);
    private bool TypeArgumentsAccessible(ImmutableArray`1<TypeSymbol> typeArguments, HashSet`1& useSiteDiagnostics);
    private static void RemoveLessDerivedMembers(ArrayBuilder`1<MemberResolutionResult`1<TMember>> results, HashSet`1& useSiteDiagnostics);
    private static bool IsLessDerivedThanAny(TypeSymbol type, ArrayBuilder`1<MemberResolutionResult`1<TMember>> results, HashSet`1& useSiteDiagnostics);
    private static void RemoveAllInterfaceMembers(ArrayBuilder`1<MemberResolutionResult`1<TMember>> results);
    private void PerformObjectCreationOverloadResolution(ArrayBuilder`1<MemberResolutionResult`1<MethodSymbol>> results, ImmutableArray`1<MethodSymbol> constructors, AnalyzedArguments arguments, bool completeResults, HashSet`1& useSiteDiagnostics);
    private static void ReportUseSiteDiagnostics(ArrayBuilder`1<MemberResolutionResult`1<TMember>> results, HashSet`1& useSiteDiagnostics);
    private void RemoveWorseMembers(ArrayBuilder`1<MemberResolutionResult`1<TMember>> results, AnalyzedArguments arguments, HashSet`1& useSiteDiagnostics);
    private static TypeSymbol GetParameterType(int argIndex, MemberAnalysisResult result, ImmutableArray`1<ParameterSymbol> parameters);
    private static TypeSymbol GetParameterType(int argIndex, MemberAnalysisResult result, ImmutableArray`1<ParameterSymbol> parameters, RefKind& refKind);
    private BetterResult BetterFunctionMember(MemberResolutionResult`1<TMember> m1, MemberResolutionResult`1<TMember> m2, ArrayBuilder`1<BoundExpression> arguments, HashSet`1& useSiteDiagnostics);
    private BetterResult BetterFunctionMember(MemberResolutionResult`1<TMember> m1, MemberResolutionResult`1<TMember> m2, ArrayBuilder`1<BoundExpression> arguments, bool considerRefKinds, HashSet`1& useSiteDiagnostics);
    private static void GetParameterCounts(MemberResolutionResult`1<TMember> m, ArrayBuilder`1<BoundExpression> arguments, Int32& declaredParameterCount, Int32& parametersUsedIncludingExpansionAndOptional);
    private static BetterResult MoreSpecificType(ArrayBuilder`1<TypeSymbol> t1, ArrayBuilder`1<TypeSymbol> t2, HashSet`1& useSiteDiagnostics);
    private static BetterResult MoreSpecificType(TypeSymbol t1, TypeSymbol t2, HashSet`1& useSiteDiagnostics);
    private BetterResult BetterConversionFromExpression(BoundExpression node, TypeSymbol t1, TypeSymbol t2, HashSet`1& useSiteDiagnostics);
    private BetterResult BetterConversionFromExpression(BoundExpression node, TypeSymbol t1, Conversion conv1, RefKind refKind1, TypeSymbol t2, Conversion conv2, RefKind refKind2, bool considerRefKinds, HashSet`1& useSiteDiagnostics, Boolean& okToDowngradeToNeither);
    private BetterResult BetterConversionFromExpression(BoundExpression node, TypeSymbol t1, Conversion conv1, TypeSymbol t2, Conversion conv2, HashSet`1& useSiteDiagnostics, Boolean& okToDowngradeToNeither);
    private bool ExpressionMatchExactly(BoundExpression node, TypeSymbol t, HashSet`1& useSiteDiagnostics);
    private BetterResult BetterConversionTarget(TypeSymbol type1, TypeSymbol type2, HashSet`1& useSiteDiagnostics);
    private BetterResult BetterConversionTarget(BoundExpression node, TypeSymbol type1, Conversion conv1, TypeSymbol type2, Conversion conv2, HashSet`1& useSiteDiagnostics, Boolean& okToDowngradeToNeither);
    private bool IsMethodGroupConversionIncompatibleWithDelegate(BoundMethodGroup node, NamedTypeSymbol delegateType, Conversion conv);
    private bool CanDowngradeConversionFromLambdaToNeither(BetterResult currentResult, UnboundLambda lambda, TypeSymbol type1, TypeSymbol type2, HashSet`1& useSiteDiagnostics, bool fromTypeAnalysis);
    private static bool IdenticalParameters(ImmutableArray`1<ParameterSymbol> p1, ImmutableArray`1<ParameterSymbol> p2);
    private static bool IsSignedIntegralType(TypeSymbol type);
    private static bool IsUnsignedIntegralType(TypeSymbol type);
    private EffectiveParameters GetEffectiveParametersInNormalForm(TMember member, int argumentCount, ImmutableArray`1<int> argToParamMap, ArrayBuilder`1<RefKind> argumentRefKinds, bool allowRefOmittedArguments);
    private EffectiveParameters GetEffectiveParametersInNormalForm(TMember member, int argumentCount, ImmutableArray`1<int> argToParamMap, ArrayBuilder`1<RefKind> argumentRefKinds, bool allowRefOmittedArguments, Boolean& hasAnyRefOmittedArgument);
    private RefKind GetEffectiveParameterRefKind(ParameterSymbol parameter, RefKind argRefKind, bool allowRefOmittedArguments, Boolean& hasAnyRefOmittedArgument);
    private EffectiveParameters GetEffectiveParametersInExpandedForm(TMember member, int argumentCount, ImmutableArray`1<int> argToParamMap, ArrayBuilder`1<RefKind> argumentRefKinds, bool allowRefOmittedArguments);
    private EffectiveParameters GetEffectiveParametersInExpandedForm(TMember member, int argumentCount, ImmutableArray`1<int> argToParamMap, ArrayBuilder`1<RefKind> argumentRefKinds, bool allowRefOmittedArguments, Boolean& hasAnyRefOmittedArgument);
    internal MemberResolutionResult`1<TMember> IsMemberApplicableInNormalForm(TMember member, TMember leastOverriddenMember, ArrayBuilder`1<TypeSymbol> typeArguments, AnalyzedArguments arguments, bool isMethodGroupConversion, bool allowRefOmittedArguments, bool inferWithDynamic, HashSet`1& useSiteDiagnostics);
    private MemberResolutionResult`1<TMember> IsMemberApplicableInExpandedForm(TMember member, TMember leastOverriddenMember, ArrayBuilder`1<TypeSymbol> typeArguments, AnalyzedArguments arguments, bool allowRefOmittedArguments, HashSet`1& useSiteDiagnostics);
    private MemberResolutionResult`1<TMember> IsApplicable(TMember member, TMember leastOverriddenMember, ArrayBuilder`1<TypeSymbol> typeArgumentsBuilder, AnalyzedArguments arguments, EffectiveParameters originalEffectiveParameters, EffectiveParameters constructedEffectiveParameters, ImmutableArray`1<int> argsToParamsMap, bool hasAnyRefOmittedArgument, HashSet`1& useSiteDiagnostics, bool inferWithDynamic);
    private ImmutableArray`1<TypeSymbol> InferMethodTypeArguments(MethodSymbol method, ImmutableArray`1<TypeParameterSymbol> originalTypeParameters, AnalyzedArguments arguments, EffectiveParameters originalEffectiveParameters, MemberAnalysisResult& error, HashSet`1& useSiteDiagnostics);
    private MemberAnalysisResult IsApplicable(Symbol candidate, EffectiveParameters parameters, AnalyzedArguments arguments, ImmutableArray`1<int> argsToParameters, bool isVararg, bool hasAnyRefOmittedArgument, bool ignoreOpenTypes, HashSet`1& useSiteDiagnostics);
    private Conversion CheckArgumentForApplicability(Symbol candidate, BoundExpression argument, RefKind argRefKind, TypeSymbol parameterType, RefKind parRefKind, bool ignoreOpenTypes, HashSet`1& useSiteDiagnostics);
    private static TMember GetConstructedFrom(TMember member);
    private static ArgumentAnalysisResult AnalyzeArguments(Symbol symbol, AnalyzedArguments arguments, bool isMethodGroupConversion, bool expanded);
    private static Nullable`1<int> CorrespondsToAnyParameter(ImmutableArray`1<ParameterSymbol> memberParameters, bool expanded, AnalyzedArguments arguments, int argumentPosition, Boolean& isNamedArgument);
    private static ArgumentAnalysisResult AnalyzeArgumentsForNormalFormNoNamedArguments(ImmutableArray`1<ParameterSymbol> parameters, AnalyzedArguments arguments, bool isMethodGroupConversion, bool isVararg);
    private static bool CanBeOptional(ParameterSymbol parameter, bool isMethodGroupConversion);
    private static Nullable`1<int> NameUsedForPositional(AnalyzedArguments arguments, ParameterMap argsToParameters);
    private static Nullable`1<int> CheckForMissingRequiredParameter(ParameterMap argsToParameters, ImmutableArray`1<ParameterSymbol> parameters, bool isMethodGroupConversion, bool expanded);
}
internal class Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1 : object {
    private MemberResolutionResult`1<TMember> _bestResult;
    private ThreeState _bestResultState;
    internal ArrayBuilder`1<MemberResolutionResult`1<TMember>> ResultsBuilder;
    private static ObjectPool`1<OverloadResolutionResult`1<TMember>> s_pool;
    public bool Succeeded { get; }
    public MemberResolutionResult`1<TMember> ValidResult { get; }
    public MemberResolutionResult`1<TMember> BestResult { get; }
    private bool HasBestResult { get; }
    public ImmutableArray`1<MemberResolutionResult`1<TMember>> Results { get; }
    internal bool HasAnyApplicableMember { get; }
    private static OverloadResolutionResult`1();
    internal void Clear();
    public bool get_Succeeded();
    public MemberResolutionResult`1<TMember> get_ValidResult();
    public MemberResolutionResult`1<TMember> get_BestResult();
    private bool get_HasBestResult();
    public ImmutableArray`1<MemberResolutionResult`1<TMember>> get_Results();
    internal bool get_HasAnyApplicableMember();
    internal ImmutableArray`1<TMember> GetAllApplicableMembers();
    private static ThreeState TryGetBestResult(ArrayBuilder`1<MemberResolutionResult`1<TMember>> allResults, MemberResolutionResult`1& best);
    internal void ReportDiagnostics(Binder binder, Location location, DiagnosticBag diagnostics, string name, BoundExpression receiver, AnalyzedArguments arguments, ImmutableArray`1<T> memberGroup, NamedTypeSymbol typeContainingConstructor, NamedTypeSymbol delegateTypeBeingInvoked, CSharpSyntaxNode queryClause, bool isMethodGroupConversion);
    private static void ReportUnsupportedMetadata(Location location, DiagnosticBag diagnostics, ImmutableArray`1<Symbol> symbols, MemberResolutionResult`1<TMember> firstUnsupported);
    private bool UseSiteError(DiagnosticBag diagnostics, ImmutableArray`1<Symbol> symbols, Location location);
    private bool InaccessibleTypeArgument(DiagnosticBag diagnostics, ImmutableArray`1<Symbol> symbols, AnalyzedArguments arguments, Location location);
    private bool TypeInferenceFailed(Binder binder, DiagnosticBag diagnostics, ImmutableArray`1<Symbol> symbols, BoundExpression receiver, AnalyzedArguments arguments, Location location, CSharpSyntaxNode queryClause);
    private static void ReportNameUsedForPositional(MemberResolutionResult`1<TMember> bad, DiagnosticBag diagnostics, AnalyzedArguments arguments, ImmutableArray`1<Symbol> symbols);
    private static void ReportNoCorrespondingNamedParameter(MemberResolutionResult`1<TMember> bad, string methodName, DiagnosticBag diagnostics, AnalyzedArguments arguments, NamedTypeSymbol delegateTypeBeingInvoked, ImmutableArray`1<Symbol> symbols);
    private static void ReportMissingRequiredParameter(MemberResolutionResult`1<TMember> bad, DiagnosticBag diagnostics, AnalyzedArguments arguments, NamedTypeSymbol delegateTypeBeingInvoked, ImmutableArray`1<Symbol> symbols, Location location);
    private static void ReportBadParameterCount(DiagnosticBag diagnostics, string name, AnalyzedArguments arguments, ImmutableArray`1<Symbol> symbols, Location location, NamedTypeSymbol typeContainingConstructor, NamedTypeSymbol delegateTypeBeingInvoked);
    private bool ConstraintsCheckFailed(ConversionsBase conversions, Compilation compilation, DiagnosticBag diagnostics, AnalyzedArguments arguments, Location location);
    private static bool HadLambdaConversionError(DiagnosticBag diagnostics, AnalyzedArguments arguments);
    private bool HadBadArguments(DiagnosticBag diagnostics, Compilation compilation, string name, AnalyzedArguments arguments, ImmutableArray`1<Symbol> symbols, Location location, BinderFlags flags, bool isMethodGroupConversion);
    private static void ReportBadArgumentError(DiagnosticBag diagnostics, Compilation compilation, string name, AnalyzedArguments arguments, ImmutableArray`1<Symbol> symbols, Location location, MemberResolutionResult`1<TMember> badArg, TMember method, int arg);
    private static Symbol UnwrapIfParamsArray(ParameterSymbol parameter);
    private bool HadAmbiguousWorseMethods(DiagnosticBag diagnostics, ImmutableArray`1<Symbol> symbols, Location location, bool isQuery, BoundExpression receiver, string name);
    private int TryGetFirstTwoWorseResults(MemberResolutionResult`1& first, MemberResolutionResult`1& second);
    private bool HadAmbiguousBestMethods(DiagnosticBag diagnostics, ImmutableArray`1<Symbol> symbols, Location location);
    private int TryGetFirstTwoValidResults(MemberResolutionResult`1& first, MemberResolutionResult`1& second);
    [ConditionalAttribute("DEBUG")]
private void AssertNone(MemberResolutionKind kind);
    private MemberResolutionResult`1<TMember> GetFirstMemberKind(MemberResolutionKind kind);
    internal static OverloadResolutionResult`1<TMember> GetInstance();
    internal void Free();
    private static ObjectPool`1<OverloadResolutionResult`1<TMember>> CreatePool();
}
internal class Microsoft.CodeAnalysis.CSharp.PlainUnboundLambdaState : UnboundLambdaState {
    private ImmutableArray`1<string> _parameterNames;
    private ImmutableArray`1<TypeSymbol> _parameterTypes;
    private ImmutableArray`1<RefKind> _parameterRefKinds;
    private bool _isAsync;
    public bool HasSignature { get; }
    public bool HasExplicitlyTypedParameterList { get; }
    public int ParameterCount { get; }
    public bool IsAsync { get; }
    public MessageID MessageID { get; }
    private CSharpSyntaxNode Body { get; }
    private bool IsExpressionLambda { get; }
    internal PlainUnboundLambdaState(UnboundLambda unboundLambda, Binder binder, ImmutableArray`1<string> parameterNames, ImmutableArray`1<TypeSymbol> parameterTypes, ImmutableArray`1<RefKind> parameterRefKinds, bool isAsync);
    public virtual bool get_HasSignature();
    public virtual bool get_HasExplicitlyTypedParameterList();
    public virtual int get_ParameterCount();
    public virtual bool get_IsAsync();
    public virtual MessageID get_MessageID();
    private CSharpSyntaxNode get_Body();
    public virtual Location ParameterLocation(int index);
    private bool get_IsExpressionLambda();
    public virtual string ParameterName(int index);
    public virtual RefKind RefKind(int index);
    public virtual TypeSymbol ParameterType(int index);
    protected virtual BoundBlock BindLambdaBody(LambdaSymbol lambdaSymbol, Binder& lambdaBodyBinder, DiagnosticBag diagnostics);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1 : BoundTreeVisitor {
    protected int _recursionDepth;
    protected CSharpCompilation compilation;
    private Symbol _member;
    protected BoundNode methodMainNode;
    private PooledDictionary`2<LabelSymbol, LocalState> _labels;
    internal bool backwardBranchChanged;
    private ArrayBuilder`1<PendingBranch<LocalState>> _pendingBranches;
    private PooledHashSet`1<BoundStatement> _labelsSeen;
    private bool _trackExceptions;
    protected LocalState State;
    protected LocalState StateWhenTrue;
    protected LocalState StateWhenFalse;
    protected bool IsConditionalState;
    [CompilerGeneratedAttribute]
private DiagnosticBag <Diagnostics>k__BackingField;
    protected RegionPlace<LocalState> regionPlace;
    protected BoundNode firstInRegion;
    protected BoundNode lastInRegion;
    private bool _trackRegions;
    private Dictionary`2<BoundLoopStatement, LocalState> _loopHeadState;
    protected TextSpan RegionSpan;
    protected ArrayBuilder`1<PendingBranch<LocalState>> PendingBranches { get; }
    protected DiagnosticBag Diagnostics { get; }
    protected bool IsInside { get; }
    protected ImmutableArray`1<ParameterSymbol> MethodParameters { get; }
    protected ParameterSymbol MethodThisParameter { get; }
    protected PreciseAbstractFlowPass`1(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion, bool trackRegions, bool trackExceptions);
    protected abstract virtual bool IntersectWith(LocalState& self, LocalState& other);
    protected ArrayBuilder`1<PendingBranch<LocalState>> get_PendingBranches();
    protected void SetConditionalState(LocalState whenTrue, LocalState whenFalse);
    protected void SetState(LocalState newState);
    protected void Split();
    protected void Unsplit();
    [CompilerGeneratedAttribute]
protected DiagnosticBag get_Diagnostics();
    protected abstract virtual string Dump(LocalState state);
    protected string Dump();
    protected virtual void EnterRegion();
    protected virtual void LeaveRegion();
    protected bool RegionContains(TextSpan span);
    protected bool get_IsInside();
    public virtual BoundNode Visit(BoundNode node);
    protected BoundNode VisitAlways(BoundNode node);
    private BoundNode VisitWithStackGuard(BoundNode node);
    protected virtual BoundExpression VisitExpressionWithoutStackGuard(BoundExpression node);
    protected virtual bool ConvertInsufficientExecutionStackExceptionToCancelledByStackGuardException();
    protected abstract virtual LocalState ReachableState();
    protected abstract virtual LocalState UnreachableState();
    protected virtual ImmutableArray`1<PendingBranch<LocalState>> Scan(Boolean& badRegion);
    protected ImmutableArray`1<PendingBranch<LocalState>> Analyze(Boolean& badRegion);
    protected virtual void Free();
    protected ImmutableArray`1<ParameterSymbol> get_MethodParameters();
    protected ParameterSymbol get_MethodThisParameter();
    protected bool ShouldAnalyzeOutParameters(Location& location);
    protected virtual LocalState LabelState(LabelSymbol label);
    protected virtual ImmutableArray`1<PendingBranch<LocalState>> RemoveReturns();
    protected void SetUnreachable();
    protected void VisitLvalue(BoundExpression node);
    protected void VisitCondition(BoundExpression node);
    private void AdjustConditionalState(BoundExpression node);
    protected BoundNode VisitRvalue(BoundExpression node);
    [DebuggerHiddenAttribute]
protected virtual void VisitStatement(BoundStatement statement);
    private static bool IsConstantTrue(BoundExpression node);
    private static bool IsConstantFalse(BoundExpression node);
    private static bool IsConstantNull(BoundExpression node);
    private void LoopHead(BoundLoopStatement node);
    private void LoopTail(BoundLoopStatement node);
    private void ResolveBreaks(LocalState breakState, LabelSymbol label);
    private void ResolveContinues(LabelSymbol continueLabel);
    protected virtual void NoteBranch(PendingBranch<LocalState> pending, BoundStatement gotoStmt, BoundStatement target);
    protected virtual void NotePossibleException(BoundNode node);
    private bool ResolveBranches(LabelSymbol label, BoundStatement target);
    protected virtual void ResolveBranch(PendingBranch<LocalState> pending, LabelSymbol label, BoundStatement target, Boolean& labelStateChanged);
    private bool ResolveBranches(BoundLabeledStatement target);
    protected SavedPending<LocalState> SavePending();
    protected void RestorePending(SavedPending<LocalState> oldPending);
    public virtual BoundNode DefaultVisit(BoundNode node);
    public virtual BoundNode VisitAttribute(BoundAttribute node);
    public virtual BoundNode VisitDynamicObjectCreationExpression(BoundDynamicObjectCreationExpression node);
    public virtual BoundNode VisitDynamicIndexerAccess(BoundDynamicIndexerAccess node);
    public virtual BoundNode VisitDynamicMemberAccess(BoundDynamicMemberAccess node);
    public virtual BoundNode VisitDynamicInvocation(BoundDynamicInvocation node);
    public virtual BoundNode VisitInterpolatedString(BoundInterpolatedString node);
    public virtual BoundNode VisitStringInsert(BoundStringInsert node);
    public virtual BoundNode VisitArgList(BoundArgList node);
    public virtual BoundNode VisitArgListOperator(BoundArgListOperator node);
    public virtual BoundNode VisitRefTypeOperator(BoundRefTypeOperator node);
    public virtual BoundNode VisitMakeRefOperator(BoundMakeRefOperator node);
    public virtual BoundNode VisitRefValueOperator(BoundRefValueOperator node);
    public virtual BoundNode VisitGlobalStatementInitializer(BoundGlobalStatementInitializer node);
    public virtual BoundNode VisitLambda(BoundLambda node);
    public virtual BoundNode VisitLocal(BoundLocal node);
    public virtual BoundNode VisitLocalDeclaration(BoundLocalDeclaration node);
    public virtual BoundNode VisitBlock(BoundBlock node);
    public virtual BoundNode VisitFieldInitializer(BoundFieldInitializer node);
    public virtual BoundNode VisitExpressionStatement(BoundExpressionStatement node);
    public virtual BoundNode VisitCall(BoundCall node);
    protected virtual void UpdateStateForCall(BoundCall node);
    private void VisitReceiverBeforeCall(BoundExpression receiverOpt, MethodSymbol method);
    private void VisitReceiverAfterCall(BoundExpression receiverOpt, MethodSymbol method);
    private static bool TypeIsImmutable(TypeSymbol t);
    public virtual BoundNode VisitIndexerAccess(BoundIndexerAccess node);
    public virtual BoundNode VisitEventAssignmentOperator(BoundEventAssignmentOperator node);
    private void VisitArguments(ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<RefKind> refKindsOpt, MethodSymbol method);
    protected virtual void WriteArgument(BoundExpression arg, RefKind refKind, MethodSymbol method);
    public virtual BoundNode VisitBadExpression(BoundBadExpression node);
    public virtual BoundNode VisitBadStatement(BoundBadStatement node);
    public virtual BoundNode VisitArrayInitialization(BoundArrayInitialization node);
    public virtual BoundNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node);
    public virtual BoundNode VisitTypeExpression(BoundTypeExpression node);
    public virtual BoundNode VisitTypeOrValueExpression(BoundTypeOrValueExpression node);
    public virtual BoundNode VisitLiteral(BoundLiteral node);
    public virtual BoundNode VisitConversion(BoundConversion node);
    public virtual BoundNode VisitIfStatement(BoundIfStatement node);
    public virtual BoundNode VisitTryStatement(BoundTryStatement node);
    protected virtual LocalState AllBitsSet();
    public virtual BoundNode VisitReturnStatement(BoundReturnStatement node);
    public virtual BoundNode VisitThisReference(BoundThisReference node);
    public virtual BoundNode VisitPreviousSubmissionReference(BoundPreviousSubmissionReference node);
    public virtual BoundNode VisitHostObjectMemberReference(BoundHostObjectMemberReference node);
    public virtual BoundNode VisitParameter(BoundParameter node);
    protected virtual void VisitLvalueParameter(BoundParameter node);
    public virtual BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node);
    public virtual BoundNode VisitNewT(BoundNewT node);
    public virtual BoundNode VisitNoPiaObjectCreationExpression(BoundNoPiaObjectCreationExpression node);
    protected virtual void PropertySetter(BoundExpression node, BoundExpression receiver, MethodSymbol setter, BoundExpression value);
    private bool RegularPropertyAccess(BoundExpression expr);
    public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node);
    public virtual BoundNode VisitCompoundAssignmentOperator(BoundCompoundAssignmentOperator node);
    public virtual BoundNode VisitFieldAccess(BoundFieldAccess node);
    private void VisitFieldAccessInternal(BoundExpression receiverOpt, FieldSymbol fieldSymbol);
    public virtual BoundNode VisitFieldInfo(BoundFieldInfo node);
    public virtual BoundNode VisitMethodInfo(BoundMethodInfo node);
    protected static bool MayRequireTracking(BoundExpression receiverOpt, FieldSymbol fieldSymbol);
    public virtual BoundNode VisitPropertyAccess(BoundPropertyAccess node);
    public virtual BoundNode VisitEventAccess(BoundEventAccess node);
    public virtual BoundNode VisitRangeVariable(BoundRangeVariable node);
    public virtual BoundNode VisitQueryClause(BoundQueryClause node);
    public virtual BoundNode VisitMultipleLocalDeclarations(BoundMultipleLocalDeclarations node);
    public virtual BoundNode VisitWhileStatement(BoundWhileStatement node);
    public virtual BoundNode VisitSwitchStatement(BoundSwitchStatement node);
    private LocalState VisitSwitchHeader(BoundSwitchStatement node);
    private void VisitSwitchBlock(BoundSwitchStatement node);
    public virtual BoundNode VisitSwitchSection(BoundSwitchSection node, bool lastSection);
    public virtual BoundNode VisitSwitchSection(BoundSwitchSection node);
    public virtual BoundNode VisitArrayAccess(BoundArrayAccess node);
    public virtual BoundNode VisitBinaryOperator(BoundBinaryOperator node);
    public virtual BoundNode VisitUserDefinedConditionalLogicalOperator(BoundUserDefinedConditionalLogicalOperator node);
    private void VisitBinaryLogicalOperatorChildren(BoundExpression node);
    private void VisitBinaryOperatorChildren(BoundBinaryOperator node);
    public virtual BoundNode VisitUnaryOperator(BoundUnaryOperator node);
    public virtual BoundNode VisitAwaitExpression(BoundAwaitExpression node);
    public virtual BoundNode VisitIncrementOperator(BoundIncrementOperator node);
    public virtual BoundNode VisitArrayCreation(BoundArrayCreation node);
    public virtual BoundNode VisitForStatement(BoundForStatement node);
    public virtual BoundNode VisitForEachStatement(BoundForEachStatement node);
    public virtual void VisitForEachIterationVariable(BoundForEachStatement node);
    public virtual BoundNode VisitAsOperator(BoundAsOperator node);
    public virtual BoundNode VisitIsOperator(BoundIsOperator node);
    public virtual BoundNode VisitMethodGroup(BoundMethodGroup node);
    public virtual BoundNode VisitNullCoalescingOperator(BoundNullCoalescingOperator node);
    public virtual BoundNode VisitConditionalAccess(BoundConditionalAccess node);
    public virtual BoundNode VisitLoweredConditionalAccess(BoundLoweredConditionalAccess node);
    public virtual BoundNode VisitConditionalReceiver(BoundConditionalReceiver node);
    public virtual BoundNode VisitComplexConditionalReceiver(BoundComplexConditionalReceiver node);
    public virtual BoundNode VisitSequence(BoundSequence node);
    public virtual BoundNode VisitSequencePoint(BoundSequencePoint node);
    public virtual BoundNode VisitSequencePointExpression(BoundSequencePointExpression node);
    public virtual BoundNode VisitSequencePointWithSpan(BoundSequencePointWithSpan node);
    public virtual BoundNode VisitStatementList(BoundStatementList node);
    private BoundNode VisitStatementListWorker(BoundStatementList node);
    public virtual BoundNode VisitTypeOrInstanceInitializers(BoundTypeOrInstanceInitializers node);
    public virtual BoundNode VisitUnboundLambda(UnboundLambda node);
    public virtual BoundNode VisitBreakStatement(BoundBreakStatement node);
    public virtual BoundNode VisitContinueStatement(BoundContinueStatement node);
    public virtual BoundNode VisitConditionalOperator(BoundConditionalOperator node);
    public virtual BoundNode VisitBaseReference(BoundBaseReference node);
    public virtual BoundNode VisitDoStatement(BoundDoStatement node);
    public virtual BoundNode VisitGotoStatement(BoundGotoStatement node);
    private void VisitLabel(LabelSymbol label, BoundStatement node);
    protected virtual void VisitLabel(BoundLabeledStatement node);
    protected virtual void VisitSwitchSectionLabel(LabelSymbol label, BoundSwitchSection node);
    public virtual BoundNode VisitLabelStatement(BoundLabelStatement node);
    public virtual BoundNode VisitLabeledStatement(BoundLabeledStatement node);
    public virtual BoundNode VisitLockStatement(BoundLockStatement node);
    public virtual BoundNode VisitNoOpStatement(BoundNoOpStatement node);
    public virtual BoundNode VisitNamespaceExpression(BoundNamespaceExpression node);
    public virtual BoundNode VisitUsingStatement(BoundUsingStatement node);
    public virtual BoundNode VisitFixedStatement(BoundFixedStatement node);
    public virtual BoundNode VisitFixedLocalCollectionInitializer(BoundFixedLocalCollectionInitializer node);
    public virtual BoundNode VisitThrowStatement(BoundThrowStatement node);
    public virtual BoundNode VisitYieldBreakStatement(BoundYieldBreakStatement node);
    public virtual BoundNode VisitYieldReturnStatement(BoundYieldReturnStatement node);
    public virtual BoundNode VisitDefaultOperator(BoundDefaultOperator node);
    public virtual BoundNode VisitTypeOfOperator(BoundTypeOfOperator node);
    public virtual BoundNode VisitNameOfOperator(BoundNameOfOperator node);
    public virtual BoundNode VisitAddressOfOperator(BoundAddressOfOperator node);
    protected void VisitAddressOfOperator(BoundAddressOfOperator node, bool shouldReadOperand);
    public virtual BoundNode VisitPointerIndirectionOperator(BoundPointerIndirectionOperator node);
    public virtual BoundNode VisitPointerElementAccess(BoundPointerElementAccess node);
    public virtual BoundNode VisitSizeOfOperator(BoundSizeOfOperator node);
    public virtual BoundNode VisitStackAllocArrayCreation(BoundStackAllocArrayCreation node);
    public virtual BoundNode VisitAnonymousObjectCreationExpression(BoundAnonymousObjectCreationExpression node);
    public virtual BoundNode VisitArrayLength(BoundArrayLength node);
    public virtual BoundNode VisitConditionalGoto(BoundConditionalGoto node);
    public virtual BoundNode VisitObjectInitializerExpression(BoundObjectInitializerExpression node);
    public virtual BoundNode VisitCollectionInitializerExpression(BoundCollectionInitializerExpression node);
    private BoundNode VisitObjectOrCollectionInitializerExpression(ImmutableArray`1<BoundExpression> initializers);
    public virtual BoundNode VisitObjectInitializerMember(BoundObjectInitializerMember node);
    public virtual BoundNode VisitDynamicObjectInitializerMember(BoundDynamicObjectInitializerMember node);
    public virtual BoundNode VisitCollectionElementInitializer(BoundCollectionElementInitializer node);
    public virtual BoundNode VisitDynamicCollectionElementInitializer(BoundDynamicCollectionElementInitializer node);
    public virtual BoundNode VisitImplicitReceiver(BoundImplicitReceiver node);
    public virtual BoundNode VisitFieldEqualsValue(BoundFieldEqualsValue node);
    public virtual BoundNode VisitPropertyEqualsValue(BoundPropertyEqualsValue node);
    public virtual BoundNode VisitParameterEqualsValue(BoundParameterEqualsValue node);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.PseudoVariableExpressions : object {
    internal abstract virtual BoundExpression GetValue(BoundPseudoVariable variable, DiagnosticBag diagnostics);
    internal abstract virtual BoundExpression GetAddress(BoundPseudoVariable variable);
}
public class Microsoft.CodeAnalysis.CSharp.QueryClauseInfo : ValueType {
    private SymbolInfo _castInfo;
    private SymbolInfo _operationInfo;
    public SymbolInfo CastInfo { get; }
    public SymbolInfo OperationInfo { get; }
    internal QueryClauseInfo(SymbolInfo castInfo, SymbolInfo operationInfo);
    public SymbolInfo get_CastInfo();
    public SymbolInfo get_OperationInfo();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(QueryClauseInfo other);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.CSharp.ReadWriteWalker : AbstractRegionDataFlowPass {
    private HashSet`1<Symbol> _readInside;
    private HashSet`1<Symbol> _writtenInside;
    private HashSet`1<Symbol> _readOutside;
    private HashSet`1<Symbol> _writtenOutside;
    private ReadWriteWalker(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion, HashSet`1<PrefixUnaryExpressionSyntax> unassignedVariableAddressOfSyntaxes);
    internal static void Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion, HashSet`1<PrefixUnaryExpressionSyntax> unassignedVariableAddressOfSyntaxes, IEnumerable`1& readInside, IEnumerable`1& writtenInside, IEnumerable`1& readOutside, IEnumerable`1& writtenOutside, IEnumerable`1& captured, IEnumerable`1& unsafeAddressTaken);
    protected virtual void EnterRegion();
    protected virtual void NoteRead(Symbol variable, ParameterSymbol rangeVariableUnderlyingParameter);
    protected virtual void NoteWrite(Symbol variable, BoundExpression value, bool read);
    protected virtual void CheckAssigned(BoundExpression expr, FieldSymbol fieldSymbol, CSharpSyntaxNode node);
    private void NoteReceiverWritten(BoundFieldAccess expr);
    private void NoteReceiverRead(BoundFieldAccess expr);
    private void NoteReceiverReadOrWritten(BoundFieldAccess expr, HashSet`1<Symbol> readOrWritten);
    protected virtual void AssignImpl(BoundNode node, BoundExpression value, RefKind refKind, bool written, bool read);
    public virtual BoundNode VisitUnboundLambda(UnboundLambda node);
    public virtual void VisitForEachIterationVariable(BoundForEachStatement node);
    public virtual BoundNode VisitRangeVariable(BoundRangeVariable node);
    private ParameterSymbol GetRangeVariableUnderlyingParameter(BoundNode underlying);
    public virtual BoundNode VisitQueryClause(BoundQueryClause node);
}
internal class Microsoft.CodeAnalysis.CSharp.RegionAnalysisContext : ValueType {
    public CSharpCompilation Compilation;
    public Symbol Member;
    public BoundNode BoundNode;
    public BoundNode FirstInRegion;
    public BoundNode LastInRegion;
    public bool Failed;
    public RegionAnalysisContext(CSharpCompilation compilation, Symbol member, BoundNode boundNode, BoundNode firstInRegion, BoundNode lastInRegion);
}
internal class Microsoft.CodeAnalysis.CSharp.RegionReachableWalker : AbstractRegionControlFlowPass {
    private Nullable`1<bool> _regionStartPointIsReachable;
    private Nullable`1<bool> _regionEndPointIsReachable;
    private RegionReachableWalker(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion);
    internal static void Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion, Boolean& startPointIsReachable, Boolean& endPointIsReachable);
    protected virtual void EnterRegion();
    protected virtual void LeaveRegion();
}
internal class Microsoft.CodeAnalysis.CSharp.RootSingleNamespaceDeclaration : SingleNamespaceDeclaration {
    private ImmutableArray`1<ReferenceDirective> _referenceDirectives;
    private bool _hasAssemblyAttributes;
    private bool _hasUsings;
    private bool _hasExternAliases;
    public ImmutableArray`1<ReferenceDirective> ReferenceDirectives { get; }
    public bool HasAssemblyAttributes { get; }
    public bool HasUsings { get; }
    public bool HasExternAliases { get; }
    public RootSingleNamespaceDeclaration(bool hasUsings, bool hasExternAliases, SyntaxReference treeNode, ImmutableArray`1<SingleNamespaceOrTypeDeclaration> children, ImmutableArray`1<ReferenceDirective> referenceDirectives, bool hasAssemblyAttributes);
    public ImmutableArray`1<ReferenceDirective> get_ReferenceDirectives();
    public bool get_HasAssemblyAttributes();
    public virtual bool get_HasUsings();
    public virtual bool get_HasExternAliases();
}
internal class Microsoft.CodeAnalysis.CSharp.ScriptLocalScopeBinder : LocalScopeBinder {
    private Labels _labels;
    internal Symbol ContainingMemberOrLambda { get; }
    internal ScriptLocalScopeBinder(Labels labels, Binder next);
    internal virtual Symbol get_ContainingMemberOrLambda();
    protected virtual ImmutableArray`1<LabelSymbol> BuildLabels();
}
internal class Microsoft.CodeAnalysis.CSharp.SimpleLocalScopeBinder : LocalScopeBinder {
    private ImmutableArray`1<LocalSymbol> _locals;
    public SimpleLocalScopeBinder(ImmutableArray`1<LocalSymbol> locals, Binder next);
    protected virtual ImmutableArray`1<LocalSymbol> BuildLocals();
}
internal class Microsoft.CodeAnalysis.CSharp.SimpleSyntaxReference : SyntaxReference {
    private SyntaxNode _node;
    public SyntaxTree SyntaxTree { get; }
    public TextSpan Span { get; }
    internal SimpleSyntaxReference(SyntaxNode node);
    public virtual SyntaxTree get_SyntaxTree();
    public virtual TextSpan get_Span();
    public virtual SyntaxNode GetSyntax(CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.SingleLookupResult : ValueType {
    internal LookupResultKind Kind;
    internal Symbol Symbol;
    internal DiagnosticInfo Error;
    internal SingleLookupResult(LookupResultKind kind, Symbol symbol, DiagnosticInfo error);
}
internal class Microsoft.CodeAnalysis.CSharp.SingleNamespaceDeclaration : SingleNamespaceOrTypeDeclaration {
    private ImmutableArray`1<SingleNamespaceOrTypeDeclaration> _children;
    public DeclarationKind Kind { get; }
    public bool HasUsings { get; }
    public bool HasExternAliases { get; }
    protected SingleNamespaceDeclaration(string name, SyntaxReference syntaxReference, SourceLocation nameLocation, ImmutableArray`1<SingleNamespaceOrTypeDeclaration> children);
    public virtual DeclarationKind get_Kind();
    protected virtual ImmutableArray`1<SingleNamespaceOrTypeDeclaration> GetNamespaceOrTypeDeclarationChildren();
    public virtual bool get_HasUsings();
    public virtual bool get_HasExternAliases();
    public static SingleNamespaceDeclaration Create(string name, bool hasUsings, bool hasExternAliases, SyntaxReference syntaxReference, SourceLocation nameLocation, ImmutableArray`1<SingleNamespaceOrTypeDeclaration> children);
}
internal class Microsoft.CodeAnalysis.CSharp.SingleNamespaceDeclarationEx : SingleNamespaceDeclaration {
    private bool _hasUsings;
    private bool _hasExternAliases;
    public bool HasUsings { get; }
    public bool HasExternAliases { get; }
    public SingleNamespaceDeclarationEx(string name, bool hasUsings, bool hasExternAliases, SyntaxReference syntaxReference, SourceLocation nameLocation, ImmutableArray`1<SingleNamespaceOrTypeDeclaration> children);
    public virtual bool get_HasUsings();
    public virtual bool get_HasExternAliases();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.SingleNamespaceOrTypeDeclaration : Declaration {
    private SyntaxReference _syntaxReference;
    private SourceLocation _nameLocation;
    public SourceLocation Location { get; }
    public SyntaxReference SyntaxReference { get; }
    public SourceLocation NameLocation { get; }
    public ImmutableArray`1<SingleNamespaceOrTypeDeclaration> Children { get; }
    protected SingleNamespaceOrTypeDeclaration(string name, SyntaxReference syntaxReference, SourceLocation nameLocation);
    public SourceLocation get_Location();
    public SyntaxReference get_SyntaxReference();
    public SourceLocation get_NameLocation();
    protected virtual ImmutableArray`1<Declaration> GetDeclarationChildren();
    public ImmutableArray`1<SingleNamespaceOrTypeDeclaration> get_Children();
    protected abstract virtual ImmutableArray`1<SingleNamespaceOrTypeDeclaration> GetNamespaceOrTypeDeclarationChildren();
}
internal class Microsoft.CodeAnalysis.CSharp.SingleTypeDeclaration : SingleNamespaceOrTypeDeclaration {
    private DeclarationKind _kind;
    private TypeDeclarationFlags _flags;
    private ushort _arity;
    private DeclarationModifiers _modifiers;
    private ImmutableArray`1<SingleTypeDeclaration> _children;
    private ICollection`1<string> _memberNames;
    public DeclarationKind Kind { get; }
    public ImmutableArray`1<SingleTypeDeclaration> Children { get; }
    public int Arity { get; }
    public DeclarationModifiers Modifiers { get; }
    public ICollection`1<string> MemberNames { get; }
    public bool AnyMemberHasExtensionMethodSyntax { get; }
    public bool HasAnyAttributes { get; }
    public bool HasBaseDeclarations { get; }
    public bool AnyMemberHasAttributes { get; }
    public bool HasAnyNontypeMembers { get; }
    internal TypeDeclarationIdentity Identity { get; }
    internal SingleTypeDeclaration(DeclarationKind kind, string name, int arity, DeclarationModifiers modifiers, TypeDeclarationFlags declFlags, SyntaxReference syntaxReference, SourceLocation nameLocation, ICollection`1<string> memberNames, ImmutableArray`1<SingleTypeDeclaration> children);
    public virtual DeclarationKind get_Kind();
    public ImmutableArray`1<SingleTypeDeclaration> get_Children();
    public int get_Arity();
    public DeclarationModifiers get_Modifiers();
    public ICollection`1<string> get_MemberNames();
    public bool get_AnyMemberHasExtensionMethodSyntax();
    public bool get_HasAnyAttributes();
    public bool get_HasBaseDeclarations();
    public bool get_AnyMemberHasAttributes();
    public bool get_HasAnyNontypeMembers();
    protected virtual ImmutableArray`1<SingleNamespaceOrTypeDeclaration> GetNamespaceOrTypeDeclarationChildren();
    internal TypeDeclarationIdentity get_Identity();
}
internal static class Microsoft.CodeAnalysis.CSharp.SourceDocumentationCommentUtils : object {
    internal static string GetAndCacheDocumentationComment(Symbol symbol, bool expandIncludes, String& lazyXmlText);
    internal static ImmutableArray`1<DocumentationCommentTriviaSyntax> GetDocumentationCommentTriviaFromSyntaxNode(CSharpSyntaxNode syntaxNode, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.CSharp.SpeculativeSyntaxTreeSemanticModel : SyntaxTreeSemanticModel {
    private CSharpSemanticModel _parentSemanticModel;
    private CSharpSyntaxNode _root;
    private Binder _rootBinder;
    private int _position;
    private SpeculativeBindingOption _bindingOption;
    public bool IsSpeculativeSemanticModel { get; }
    public int OriginalPositionForSpeculation { get; }
    public CSharpSemanticModel ParentModel { get; }
    internal CSharpSyntaxNode Root { get; }
    private SpeculativeSyntaxTreeSemanticModel(CSharpSemanticModel parentSemanticModel, CSharpSyntaxNode root, Binder rootBinder, int position, SpeculativeBindingOption bindingOption);
    public static SpeculativeSyntaxTreeSemanticModel Create(CSharpSemanticModel parentSemanticModel, TypeSyntax root, Binder rootBinder, int position, SpeculativeBindingOption bindingOption);
    public static SpeculativeSyntaxTreeSemanticModel Create(CSharpSemanticModel parentSemanticModel, CrefSyntax root, Binder rootBinder, int position);
    private static SpeculativeSyntaxTreeSemanticModel CreateCore(CSharpSemanticModel parentSemanticModel, CSharpSyntaxNode root, Binder rootBinder, int position, SpeculativeBindingOption bindingOption);
    public virtual bool get_IsSpeculativeSemanticModel();
    public virtual int get_OriginalPositionForSpeculation();
    public virtual CSharpSemanticModel get_ParentModel();
    internal virtual CSharpSyntaxNode get_Root();
    internal virtual BoundNode Bind(Binder binder, CSharpSyntaxNode node, DiagnosticBag diagnostics);
    internal virtual Binder GetEnclosingBinderInternal(int position);
    private SpeculativeBindingOption GetSpeculativeBindingOption(ExpressionSyntax node);
    internal virtual SymbolInfo GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken);
    internal virtual CSharpTypeInfo GetTypeInfoWorker(CSharpSyntaxNode node, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.StateMachineFieldSymbol : SynthesizedFieldSymbolBase {
    private TypeSymbol _type;
    internal int SlotIndex;
    internal LocalSlotDebugInfo SlotDebugInfo;
    internal bool SuppressDynamicAttribute { get; }
    private bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.HasMethodBodyDependency { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.Method { get; }
    public StateMachineFieldSymbol(NamedTypeSymbol stateMachineType, TypeSymbol type, string name, bool isPublic);
    public StateMachineFieldSymbol(NamedTypeSymbol stateMachineType, TypeSymbol type, string name, SynthesizedLocalKind synthesizedKind, int slotIndex, bool isPublic);
    public StateMachineFieldSymbol(NamedTypeSymbol stateMachineType, TypeSymbol type, string name, LocalSlotDebugInfo slotDebugInfo, int slotIndex, bool isPublic);
    internal virtual bool get_SuppressDynamicAttribute();
    internal virtual TypeSymbol GetFieldType(ConsList`1<FieldSymbol> fieldsBeingBound);
    private sealed virtual override bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_HasMethodBodyDependency();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_Method();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.StateMachineRewriter : object {
    protected BoundStatement body;
    protected MethodSymbol method;
    protected DiagnosticBag diagnostics;
    protected SyntheticBoundNodeFactory F;
    protected SynthesizedContainer stateMachineType;
    protected VariableSlotAllocator slotAllocatorOpt;
    protected SynthesizedLocalOrdinalsDispenser synthesizedLocalOrdinals;
    protected FieldSymbol stateField;
    protected IReadOnlyDictionary`2<Symbol, CapturedSymbolReplacement> nonReusableLocalProxies;
    protected int nextFreeHoistedLocalSlot;
    protected IReadOnlySet`1<Symbol> hoistedVariables;
    protected Dictionary`2<Symbol, CapturedSymbolReplacement> initialParameters;
    protected bool PreserveInitialParameterValues { get; }
    protected StateMachineRewriter(BoundStatement body, MethodSymbol method, SynthesizedContainer stateMachineType, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics);
    protected abstract virtual bool get_PreserveInitialParameterValues();
    protected abstract virtual void GenerateControlFields();
    protected abstract virtual void InitializeStateMachine(ArrayBuilder`1<BoundStatement> bodyBuilder, NamedTypeSymbol frameType, LocalSymbol stateMachineLocal);
    protected abstract virtual BoundStatement GenerateStateMachineCreation(LocalSymbol stateMachineVariable, NamedTypeSymbol frameType);
    protected abstract virtual void GenerateMethodImplementations();
    protected BoundStatement Rewrite();
    private void CreateNonReusableLocalProxies(IEnumerable`1<Symbol> variablesToHoist, IReadOnlyDictionary`2& proxies, Int32& nextFreeHoistedLocalSlot);
    private BoundStatement GenerateKickoffMethodBody();
    protected SynthesizedImplementationMethod OpenMethodImplementation(MethodSymbol methodToImplement, string methodName, bool hasMethodBodyDependency);
    protected MethodSymbol OpenPropertyImplementation(MethodSymbol getterToImplement);
    protected SynthesizedImplementationMethod OpenMoveNextMethodImplementation(MethodSymbol methodToImplement);
}
internal static class Microsoft.CodeAnalysis.CSharp.StateMachineStates : object {
    internal static int FinishedStateMachine;
    internal static int NotStartedStateMachine;
    internal static int FirstUnusedState;
    private static StateMachineStates();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.StateMachineTypeSymbol : SynthesizedContainer {
    private ImmutableArray`1<CSharpAttributeData> _attributes;
    public MethodSymbol KickoffMethod;
    public Symbol ContainingSymbol { get; }
    private bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.HasMethodBodyDependency { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.Method { get; }
    public StateMachineTypeSymbol(VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, MethodSymbol kickoffMethod, int kickoffMethodOrdinal);
    private static string MakeName(VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, MethodSymbol kickoffMethod, int kickoffMethodOrdinal);
    private static int SequenceNumber(MethodSymbol kickoffMethod);
    public virtual Symbol get_ContainingSymbol();
    private sealed virtual override bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_HasMethodBodyDependency();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_Method();
    public sealed virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
}
internal class Microsoft.CodeAnalysis.CSharp.SwitchBinder : LocalScopeBinder {
    private SwitchStatementSyntax _switchSyntax;
    private TypeSymbol _switchGoverningType;
    private GeneratedLabelSymbol _breakLabel;
    private Dictionary`2<object, List`1<SourceLabelSymbol>> _lazySwitchLabelsMap;
    private static object s_defaultKey;
    private static List`1<SourceLabelSymbol> s_emptyLabelsList;
    private Dictionary`2<object, List`1<SourceLabelSymbol>> SwitchLabelsMap { get; }
    internal GeneratedLabelSymbol BreakLabel { get; }
    internal SwitchBinder(Binder next, SwitchStatementSyntax switchSyntax);
    private static SwitchBinder();
    private Dictionary`2<object, List`1<SourceLabelSymbol>> get_SwitchLabelsMap();
    private static Dictionary`2<object, List`1<SourceLabelSymbol>> BuildMap(ImmutableArray`1<LabelSymbol> labels);
    protected virtual ImmutableArray`1<LocalSymbol> BuildLocals();
    internal virtual GeneratedLabelSymbol get_BreakLabel();
    protected virtual ImmutableArray`1<LabelSymbol> BuildLabels();
    private void BuildSwitchLabels(SyntaxList`1<SwitchLabelSyntax> labelsSyntax, ArrayBuilder`1& labels);
    private BoundExpression ConvertCaseExpression(TypeSymbol switchGoverningType, CSharpSyntaxNode node, BoundExpression caseExpression, ConstantValue& constantValueOpt, DiagnosticBag diagnostics, bool isGotoCaseExpr);
    private List`1<SourceLabelSymbol> FindMatchingSwitchCaseLabels(ConstantValue constantValue, SyntaxNodeOrToken labelSyntax);
    private List`1<SourceLabelSymbol> GetDefaultLabels();
    private List`1<SourceLabelSymbol> FindMatchingSwitchLabels(object key);
    internal virtual BoundSwitchStatement BindSwitchExpressionAndSections(SwitchStatementSyntax node, Binder originalBinder, DiagnosticBag diagnostics);
    private BoundExpression BindSwitchExpressionAndGoverningType(ExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindSwitchExpression(ExpressionSyntax node, DiagnosticBag diagnostics);
    private LabelSymbol BindConstantJumpTarget(ConstantValue constantValue);
    private ImmutableArray`1<BoundSwitchSection> BindSwitchSections(SyntaxList`1<SwitchSectionSyntax> switchSections, Binder originalBinder, DiagnosticBag diagnostics);
    private BoundSwitchSection BindSwitchSection(SwitchSectionSyntax node, Binder originalBinder, DiagnosticBag diagnostics);
    private BoundSwitchLabel BindSwitchSectionLabel(SwitchLabelSyntax node, DiagnosticBag diagnostics);
    internal BoundStatement BindGotoCaseOrDefault(GotoStatementSyntax node, DiagnosticBag diagnostics);
    private TypeSymbol GetSwitchGoverningType(DiagnosticBag diagnostics);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbol : object {
    internal bool RequiresCompletion { get; }
    public string Name { get; }
    public string MetadataName { get; }
    public SymbolKind Kind { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public NamespaceSymbol ContainingNamespace { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    internal ModuleSymbol ContainingModule { get; }
    public Symbol OriginalDefinition { get; }
    protected Symbol OriginalSymbolDefinition { get; }
    public bool IsDefinition { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    public bool IsImplicitlyDeclared { get; }
    public bool CanBeReferencedByName { get; }
    internal bool CanBeReferencedByNameIgnoringIllegalCharacters { get; }
    internal bool Dangerous_IsFromSomeCompilation { get; }
    internal bool HasUseSiteError { get; }
    protected int HighestPriorityUseSiteError { get; }
    public bool HasUnsupportedMetadata { get; }
    internal ThreeState ObsoleteState { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    private SymbolKind Microsoft.CodeAnalysis.ISymbol.Kind { get; }
    public string Language { get; }
    private string Microsoft.CodeAnalysis.ISymbol.Name { get; }
    private bool Microsoft.CodeAnalysis.ISymbol.IsImplicitlyDeclared { get; }
    private ISymbol Microsoft.CodeAnalysis.ISymbol.ContainingSymbol { get; }
    private IAssemblySymbol Microsoft.CodeAnalysis.ISymbol.ContainingAssembly { get; }
    private IModuleSymbol Microsoft.CodeAnalysis.ISymbol.ContainingModule { get; }
    private INamedTypeSymbol Microsoft.CodeAnalysis.ISymbol.ContainingType { get; }
    private INamespaceSymbol Microsoft.CodeAnalysis.ISymbol.ContainingNamespace { get; }
    private bool Microsoft.CodeAnalysis.ISymbol.IsDefinition { get; }
    private bool Microsoft.CodeAnalysis.ISymbol.IsStatic { get; }
    private bool Microsoft.CodeAnalysis.ISymbol.IsVirtual { get; }
    private bool Microsoft.CodeAnalysis.ISymbol.IsOverride { get; }
    private bool Microsoft.CodeAnalysis.ISymbol.IsAbstract { get; }
    private bool Microsoft.CodeAnalysis.ISymbol.IsSealed { get; }
    private ImmutableArray`1<Location> Microsoft.CodeAnalysis.ISymbol.Locations { get; }
    private ImmutableArray`1<SyntaxReference> Microsoft.CodeAnalysis.ISymbol.DeclaringSyntaxReferences { get; }
    private Accessibility Microsoft.CodeAnalysis.ISymbol.DeclaredAccessibility { get; }
    private ISymbol Microsoft.CodeAnalysis.ISymbol.OriginalDefinition { get; }
    public static bool IsSymbolAccessible(Symbol symbol, NamedTypeSymbol within, NamedTypeSymbol throughTypeOpt);
    public static bool IsSymbolAccessible(Symbol symbol, AssemblySymbol within);
    [ConditionalAttribute("DEBUG")]
protected internal void CheckDefinitionInvariant();
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    internal bool IsDefinitionOrDistinct();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.GetAttributes(EmitContext context);
    internal virtual IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    internal IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState, bool emittingAssemblyAttributesInNetModule);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbol/<GetCustomAttributesToEmit>d__9")]
internal IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ImmutableArray`1<CSharpAttributeData> userDefined, ArrayBuilder`1<SynthesizedAttributeData> synthesized, bool isReturnType, bool emittingAssemblyAttributesInNetModule);
    internal virtual bool get_RequiresCompletion();
    internal virtual void ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken);
    internal virtual bool HasComplete(CompletionPart part);
    public virtual string get_Name();
    public virtual string get_MetadataName();
    public abstract virtual SymbolKind get_Kind();
    public abstract virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual NamespaceSymbol get_ContainingNamespace();
    public virtual AssemblySymbol get_ContainingAssembly();
    internal virtual CSharpCompilation get_DeclaringCompilation();
    internal virtual ModuleSymbol get_ContainingModule();
    public Symbol get_OriginalDefinition();
    protected virtual Symbol get_OriginalSymbolDefinition();
    public bool get_IsDefinition();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public abstract virtual ImmutableArray`1<Location> get_Locations();
    public abstract virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal static ImmutableArray`1<SyntaxReference> GetDeclaringSyntaxReferenceHelper(ImmutableArray`1<Location> locations);
    public abstract virtual Accessibility get_DeclaredAccessibility();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsVirtual();
    public abstract virtual bool get_IsOverride();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsSealed();
    public abstract virtual bool get_IsExtern();
    public virtual bool get_IsImplicitlyDeclared();
    public sealed virtual bool get_CanBeReferencedByName();
    internal bool get_CanBeReferencedByNameIgnoringIllegalCharacters();
    internal virtual void AfterAddingTypeMembersChecks(ConversionsBase conversions, DiagnosticBag diagnostics);
    public static bool op_Equality(Symbol left, Symbol right);
    public static bool op_Inequality(Symbol left, Symbol right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ISymbol other);
    public virtual int GetHashCode();
    public sealed virtual string ToString();
    internal abstract virtual TResult Accept(CSharpSymbolVisitor`2<TArgument, TResult> visitor, TArgument a);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal static void AddSynthesizedAttribute(ArrayBuilder`1& attributes, SynthesizedAttributeData attribute);
    internal Nullable`1<CharSet> GetEffectiveDefaultMarshallingCharSet();
    internal bool IsFromCompilation(CSharpCompilation compilation);
    internal bool get_Dangerous_IsFromSomeCompilation();
    internal virtual bool IsDefinedInSourceTree(SyntaxTree tree, Nullable`1<TextSpan> definedWithinSpan, CancellationToken cancellationToken);
    internal static void ForceCompleteMemberByLocation(SourceLocation locationOpt, Symbol member, CancellationToken cancellationToken);
    public virtual string GetDocumentationCommentId();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal string GetDebuggerDisplay();
    internal void AddDeclarationDiagnostics(DiagnosticBag diagnostics);
    internal bool get_HasUseSiteError();
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    protected virtual int get_HighestPriorityUseSiteError();
    public virtual bool get_HasUnsupportedMetadata();
    internal DiagnosticInfo GetUseSiteDiagnosticForSymbolOrContainingType();
    internal bool MergeUseSiteDiagnostics(DiagnosticInfo& result, DiagnosticInfo info);
    internal static bool ReportUseSiteDiagnostic(DiagnosticInfo info, DiagnosticBag diagnostics, Location location);
    internal bool DeriveUseSiteDiagnosticFromType(DiagnosticInfo& result, TypeSymbol type);
    internal bool DeriveUseSiteDiagnosticFromParameter(DiagnosticInfo& result, ParameterSymbol param);
    internal bool DeriveUseSiteDiagnosticFromParameters(DiagnosticInfo& result, ImmutableArray`1<ParameterSymbol> parameters);
    internal bool DeriveUseSiteDiagnosticFromCustomModifiers(DiagnosticInfo& result, ImmutableArray`1<CustomModifier> customModifiers);
    internal static bool GetUnificationUseSiteDiagnosticRecursive(DiagnosticInfo& result, ImmutableArray`1<T> types, Symbol owner, HashSet`1& checkedTypes);
    internal static bool GetUnificationUseSiteDiagnosticRecursive(DiagnosticInfo& result, ImmutableArray`1<CustomModifier> modifiers, Symbol owner, HashSet`1& checkedTypes);
    internal static bool GetUnificationUseSiteDiagnosticRecursive(DiagnosticInfo& result, ImmutableArray`1<ParameterSymbol> parameters, Symbol owner, HashSet`1& checkedTypes);
    internal static bool GetUnificationUseSiteDiagnosticRecursive(DiagnosticInfo& result, ImmutableArray`1<TypeParameterSymbol> typeParameters, Symbol owner, HashSet`1& checkedTypes);
    internal ThreeState get_ObsoleteState();
    internal abstract virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal bool GetGuidStringDefaultImplementation(String& guidString);
    public string ToDisplayString(SymbolDisplayFormat format);
    public ImmutableArray`1<SymbolDisplayPart> ToDisplayParts(SymbolDisplayFormat format);
    public string ToMinimalDisplayString(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    public ImmutableArray`1<SymbolDisplayPart> ToMinimalDisplayParts(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    private sealed virtual override SymbolKind Microsoft.CodeAnalysis.ISymbol.get_Kind();
    public sealed virtual string get_Language();
    private sealed virtual override string Microsoft.CodeAnalysis.ISymbol.get_Name();
    private sealed virtual override string Microsoft.CodeAnalysis.ISymbol.ToDisplayString(SymbolDisplayFormat format);
    private sealed virtual override ImmutableArray`1<SymbolDisplayPart> Microsoft.CodeAnalysis.ISymbol.ToDisplayParts(SymbolDisplayFormat format);
    private sealed virtual override string Microsoft.CodeAnalysis.ISymbol.ToMinimalDisplayString(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    private sealed virtual override ImmutableArray`1<SymbolDisplayPart> Microsoft.CodeAnalysis.ISymbol.ToMinimalDisplayParts(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    private sealed virtual override bool Microsoft.CodeAnalysis.ISymbol.get_IsImplicitlyDeclared();
    private sealed virtual override ISymbol Microsoft.CodeAnalysis.ISymbol.get_ContainingSymbol();
    private sealed virtual override IAssemblySymbol Microsoft.CodeAnalysis.ISymbol.get_ContainingAssembly();
    private sealed virtual override IModuleSymbol Microsoft.CodeAnalysis.ISymbol.get_ContainingModule();
    private sealed virtual override INamedTypeSymbol Microsoft.CodeAnalysis.ISymbol.get_ContainingType();
    private sealed virtual override INamespaceSymbol Microsoft.CodeAnalysis.ISymbol.get_ContainingNamespace();
    private sealed virtual override bool Microsoft.CodeAnalysis.ISymbol.get_IsDefinition();
    private sealed virtual override bool Microsoft.CodeAnalysis.ISymbol.get_IsStatic();
    private sealed virtual override bool Microsoft.CodeAnalysis.ISymbol.get_IsVirtual();
    private sealed virtual override bool Microsoft.CodeAnalysis.ISymbol.get_IsOverride();
    private sealed virtual override bool Microsoft.CodeAnalysis.ISymbol.get_IsAbstract();
    private sealed virtual override bool Microsoft.CodeAnalysis.ISymbol.get_IsSealed();
    private sealed virtual override ImmutableArray`1<Location> Microsoft.CodeAnalysis.ISymbol.get_Locations();
    private sealed virtual override ImmutableArray`1<SyntaxReference> Microsoft.CodeAnalysis.ISymbol.get_DeclaringSyntaxReferences();
    private sealed virtual override ImmutableArray`1<AttributeData> Microsoft.CodeAnalysis.ISymbol.GetAttributes();
    private sealed virtual override Accessibility Microsoft.CodeAnalysis.ISymbol.get_DeclaredAccessibility();
    private sealed virtual override ISymbol Microsoft.CodeAnalysis.ISymbol.get_OriginalDefinition();
    public abstract virtual void Accept(SymbolVisitor visitor);
    public abstract virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public abstract virtual void Accept(CSharpSymbolVisitor visitor);
    public abstract virtual TResult Accept(CSharpSymbolVisitor`1<TResult> visitor);
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal virtual AttributeTargets GetAttributeTarget();
    internal virtual void EarlyDecodeWellKnownAttributeType(NamedTypeSymbol attributeType, AttributeSyntax attributeSyntax);
    internal virtual void PostEarlyDecodeWellKnownAttributeTypes();
    internal virtual CSharpAttributeData EarlyDecodeWellKnownAttribute(EarlyDecodeWellKnownAttributeArguments`4& arguments);
    internal bool EarlyDecodeDeprecatedOrObsoleteAttribute(EarlyDecodeWellKnownAttributeArguments`4& arguments, CSharpAttributeData& attributeData, ObsoleteAttributeData& obsoleteData);
    internal virtual void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    internal virtual void PostDecodeWellKnownAttributes(ImmutableArray`1<CSharpAttributeData> boundAttributes, ImmutableArray`1<AttributeSyntax> allAttributeSyntaxNodes, DiagnosticBag diagnostics, AttributeLocation symbolPart, WellKnownAttributeData decodedData);
    internal bool LoadAndValidateAttributes(OneOrMany`1<SyntaxList`1<AttributeListSyntax>> attributesSyntaxLists, CustomAttributesBag`1& lazyCustomAttributesBag, AttributeLocation symbolPart, bool earlyDecodingOnly);
    private void RecordPresenceOfBadAttributes(ImmutableArray`1<CSharpAttributeData> boundAttributes);
    private ImmutableArray`1<AttributeSyntax> GetAttributesToBind(OneOrMany`1<SyntaxList`1<AttributeListSyntax>> attributeDeclarationSyntaxLists, AttributeLocation symbolPart, DiagnosticBag diagnostics, CSharpCompilation compilation, ImmutableArray`1& binders);
    private static bool MatchAttributeTarget(IAttributeTargetSymbol attributeTarget, AttributeLocation symbolPart, AttributeTargetSpecifierSyntax targetOpt, DiagnosticBag diagnostics);
    internal EarlyWellKnownAttributeData EarlyDecodeWellKnownAttributes(ImmutableArray`1<Binder> binders, ImmutableArray`1<NamedTypeSymbol> boundAttributeTypes, ImmutableArray`1<AttributeSyntax> attributesToBind, AttributeLocation symbolPart, CSharpAttributeData[] boundAttributesBuilder);
    private void EarlyDecodeWellKnownAttributeTypes(ImmutableArray`1<NamedTypeSymbol> attributeTypes, ImmutableArray`1<AttributeSyntax> attributeSyntaxList);
    private WellKnownAttributeData ValidateAttributeUsageAndDecodeWellKnownAttributes(ImmutableArray`1<Binder> binders, ImmutableArray`1<AttributeSyntax> attributeSyntaxList, ImmutableArray`1<CSharpAttributeData> boundAttributes, DiagnosticBag diagnostics, AttributeLocation symbolPart);
    private bool ValidateAttributeUsage(CSharpAttributeData attribute, AttributeSyntax node, CSharpCompilation compilation, AttributeLocation symbolPart, DiagnosticBag diagnostics, HashSet`1<NamedTypeSymbol> uniqueAttributeTypes);
    internal void ForceCompleteObsoleteAttribute();
}
public static class Microsoft.CodeAnalysis.CSharp.SymbolDisplay : object {
    public static string ToDisplayString(ISymbol symbol, SymbolDisplayFormat format);
    public static string ToMinimalDisplayString(ISymbol symbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    public static ImmutableArray`1<SymbolDisplayPart> ToDisplayParts(ISymbol symbol, SymbolDisplayFormat format);
    public static ImmutableArray`1<SymbolDisplayPart> ToMinimalDisplayParts(ISymbol symbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    private static ImmutableArray`1<SymbolDisplayPart> ToDisplayParts(ISymbol symbol, SemanticModel semanticModelOpt, int positionOpt, SymbolDisplayFormat format, bool minimal);
    public static string FormatPrimitive(object obj, bool quoteStrings, bool useHexadecimalNumbers);
    public static string FormatLiteral(string value, bool quote);
    public static string FormatLiteral(char c, bool quote);
}
internal class Microsoft.CodeAnalysis.CSharp.SymbolDisplayVisitor : AbstractSymbolDisplayVisitor`1<SemanticModel> {
    private bool _escapeKeywordIdentifiers;
    private IDictionary`2<INamespaceOrTypeSymbol, IAliasSymbol> _lazyAliasMap;
    private static string IL_KEYWORD_MODOPT;
    private static string IL_KEYWORD_MODREQ;
    private IDictionary`2<INamespaceOrTypeSymbol, IAliasSymbol> AliasMap { get; }
    internal SymbolDisplayVisitor(ArrayBuilder`1<SymbolDisplayPart> builder, SymbolDisplayFormat format, SemanticModel semanticModelOpt, int positionOpt);
    private SymbolDisplayVisitor(ArrayBuilder`1<SymbolDisplayPart> builder, SymbolDisplayFormat format, SemanticModel semanticModelOpt, int positionOpt, bool escapeKeywordIdentifiers, IDictionary`2<INamespaceOrTypeSymbol, IAliasSymbol> aliasMap, bool isFirstSymbolVisited);
    protected virtual AbstractSymbolDisplayVisitor`1<SemanticModel> MakeNotFirstVisitor();
    internal SymbolDisplayPart CreatePart(SymbolDisplayPartKind kind, ISymbol symbol, string text);
    private static bool IsEscapable(SymbolDisplayPartKind kind);
    private static string EscapeIdentifier(string identifier);
    public virtual void VisitAssembly(IAssemblySymbol symbol);
    public virtual void VisitModule(IModuleSymbol symbol);
    public virtual void VisitNamespace(INamespaceSymbol symbol);
    private void AddGlobalNamespace(INamespaceSymbol globalNamespace);
    public virtual void VisitLocal(ILocalSymbol symbol);
    public virtual void VisitRangeVariable(IRangeVariableSymbol symbol);
    public virtual void VisitLabel(ILabelSymbol symbol);
    public virtual void VisitAlias(IAliasSymbol symbol);
    protected virtual void AddSpace();
    private void AddPunctuation(SyntaxKind punctuationKind);
    private void AddKeyword(SyntaxKind keywordKind);
    private void AddAccessibilityIfRequired(ISymbol symbol);
    private bool ShouldVisitNamespace(ISymbol containingSymbol);
    private bool IncludeNamedType(INamedTypeSymbol namedType);
    private static bool IsEnumMember(ISymbol symbol);
    public virtual void VisitField(IFieldSymbol symbol);
    public virtual void VisitProperty(IPropertySymbol symbol);
    private void AddPropertyNameAndParameters(IPropertySymbol symbol);
    public virtual void VisitEvent(IEventSymbol symbol);
    private void AddEventName(IEventSymbol symbol);
    public virtual void VisitMethod(IMethodSymbol symbol);
    private void AddTypeParameterConstraints(IMethodSymbol symbol);
    private void AddParameters(IMethodSymbol symbol);
    public virtual void VisitParameter(IParameterSymbol symbol);
    private static bool CanAddConstant(ITypeSymbol type, object value);
    private void AddFieldModifiersIfRequired(IFieldSymbol symbol);
    private void AddMemberModifiersIfRequired(ISymbol symbol);
    private void AddParametersIfRequired(bool hasThisParameter, bool isVarargs, ImmutableArray`1<IParameterSymbol> parameters);
    private void AddAccessor(ISymbol property, IMethodSymbol method, SyntaxKind keyword);
    private void AddExplicitInterfaceIfRequired(ImmutableArray`1<T> implementedMethods);
    private void AddCustomModifiersIfRequired(ImmutableArray`1<CustomModifier> customModifiers, bool leadingSpace, bool trailingSpace);
    public virtual void VisitArrayType(IArrayTypeSymbol symbol);
    private void AddArrayRank(IArrayTypeSymbol symbol);
    public virtual void VisitPointerType(IPointerTypeSymbol symbol);
    public virtual void VisitTypeParameter(ITypeParameterSymbol symbol);
    public virtual void VisitDynamicType(IDynamicTypeSymbol symbol);
    public virtual void VisitNamedType(INamedTypeSymbol symbol);
    private static bool IsNullableType(INamedTypeSymbol type);
    private void AddNameAndTypeArgumentsOrParameters(INamedTypeSymbol symbol);
    private void AddDelegateParameters(INamedTypeSymbol symbol);
    private void AddAnonymousTypeName(INamedTypeSymbol symbol);
    private string CreateAnonymousTypeMember(IPropertySymbol property);
    private bool CanShowDelegateSignature(INamedTypeSymbol symbol);
    private static SymbolDisplayPartKind GetPartKind(INamedTypeSymbol symbol);
    private bool AddSpecialTypeKeyword(INamedTypeSymbol symbol);
    private static string GetSpecialTypeName(SpecialType specialType);
    private void AddTypeKind(INamedTypeSymbol symbol);
    private static SyntaxKind GetKindKeyword(TypeKind typeKind);
    private void AddTypeParameterVarianceIfRequired(ITypeParameterSymbol symbol);
    private void AddTypeArguments(ImmutableArray`1<ITypeSymbol> typeArguments, ImmutableArray`1<ImmutableArray`1<CustomModifier>> modifiers);
    private static bool TypeParameterHasConstraints(ITypeParameterSymbol typeParam);
    private void AddTypeParameterConstraints(ImmutableArray`1<ITypeSymbol> typeArguments);
    private void AddConstantValue(ITypeSymbol type, object constantValue, bool preferNumericValueOrExpandedFlagsForEnum);
    protected virtual void AddExplicitlyCastedLiteralValue(INamedTypeSymbol namedType, SpecialType type, object value);
    protected virtual void AddLiteralValue(SpecialType type, object value);
    protected virtual void AddBitwiseOr();
    private bool TryAddAlias(INamespaceOrTypeSymbol symbol, ArrayBuilder`1<SymbolDisplayPart> builder);
    protected virtual bool ShouldRestrictMinimallyQualifyLookupToNamespacesAndTypes();
    private void MinimallyQualify(INamespaceSymbol symbol);
    private void MinimallyQualify(INamedTypeSymbol symbol);
    private IDictionary`2<INamespaceOrTypeSymbol, IAliasSymbol> CreateAliasMap();
    private ITypeSymbol GetRangeVariableType(IRangeVariableSymbol symbol);
    private static QueryBodySyntax GetQueryBody(SyntaxToken token);
    private string RemoveAttributeSufficeIfNecessary(INamedTypeSymbol symbol, string symbolName);
    private static T GetAncestorOrThis(SyntaxNode node);
    private static IEnumerable`1<T> GetAncestorsOrThis(SyntaxNode node);
    private IDictionary`2<INamespaceOrTypeSymbol, IAliasSymbol> get_AliasMap();
    private IAliasSymbol GetAliasSymbol(INamespaceOrTypeSymbol symbol);
    [CompilerGeneratedAttribute]
private IAliasSymbol <CreateAliasMap>b__70_3(UsingDirectiveSyntax u);
}
internal class Microsoft.CodeAnalysis.CSharp.SymbolDistinguisher : object {
    private Compilation _compilation;
    private Symbol _symbol0;
    private Symbol _symbol1;
    private ImmutableArray`1<string> _lazyDescriptions;
    public IMessageSerializable First { get; }
    public IMessageSerializable Second { get; }
    public SymbolDistinguisher(Compilation compilation, Symbol symbol0, Symbol symbol1);
    public IMessageSerializable get_First();
    public IMessageSerializable get_Second();
    [ConditionalAttribute("DEBUG")]
private static void CheckSymbolKind(Symbol symbol);
    private void MakeDescriptions();
    private static Symbol UnwrapSymbol(Symbol symbol);
    private static string GetLocationString(Compilation compilation, Symbol unwrappedSymbol);
    private string GetDescription(int index);
}
internal static class Microsoft.CodeAnalysis.CSharp.SymbolInfoFactory : object {
    internal static SymbolInfo Create(ImmutableArray`1<Symbol> symbols, LookupResultKind resultKind, bool isDynamic);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.SymbolKindExtensions : object {
    [ExtensionAttribute]
public static LocalizableErrorArgument Localize(SymbolKind kind);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.AbstractTypeMap : object {
    private NamedTypeSymbol SubstituteMemberType(NamedTypeSymbol previous);
    internal NamedTypeSymbol SubstituteNamedType(NamedTypeSymbol previous);
    internal TypeWithModifiers SubstituteType(TypeSymbol previous);
    private static bool IsPossiblyByRefTypeParameter(TypeSymbol type);
    internal ImmutableArray`1<CustomModifier> SubstituteCustomModifiers(TypeSymbol type, ImmutableArray`1<CustomModifier> customModifiers);
    internal ImmutableArray`1<CustomModifier> SubstituteCustomModifiers(ImmutableArray`1<CustomModifier> customModifiers);
    protected virtual TypeSymbol SubstituteDynamicType();
    protected virtual TypeWithModifiers SubstituteTypeParameter(TypeParameterSymbol typeParameter);
    private ArrayTypeSymbol SubstituteArrayType(ArrayTypeSymbol t);
    private PointerTypeSymbol SubstitutePointerType(PointerTypeSymbol t);
    internal ImmutableArray`1<TypeSymbol> SubstituteTypesWithoutModifiers(ImmutableArray`1<TypeSymbol> original);
    internal ImmutableArray`1<TypeWithModifiers> SubstituteTypes(ImmutableArray`1<TypeSymbol> original);
    internal void SubstituteTypesDistinctWithoutModifiers(ImmutableArray`1<TypeSymbol> original, ArrayBuilder`1<TypeSymbol> result);
    internal ImmutableArray`1<TypeParameterSymbol> SubstituteTypeParameters(ImmutableArray`1<TypeParameterSymbol> original);
    internal ImmutableArray`1<NamedTypeSymbol> SubstituteNamedTypes(ImmutableArray`1<NamedTypeSymbol> original);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.AbstractTypeParameterMap : AbstractTypeMap {
    protected SmallDictionary`2<TypeParameterSymbol, TypeWithModifiers> Mapping;
    protected AbstractTypeParameterMap(SmallDictionary`2<TypeParameterSymbol, TypeWithModifiers> mapping);
    protected sealed virtual TypeWithModifiers SubstituteTypeParameter(TypeParameterSymbol typeParameter);
    private string GetDebuggerDisplay();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.AccessibilityExtensions : object {
    [ExtensionAttribute]
public static bool HasProtected(Accessibility accessibility);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol : Symbol {
    private SyntaxToken _aliasName;
    private Binder _binder;
    private SymbolCompletionState _state;
    private NamespaceOrTypeSymbol _aliasTarget;
    private ImmutableArray`1<Location> _locations;
    private NameSyntax _aliasTargetName;
    private bool _isExtern;
    private DiagnosticBag _aliasTargetDiagnostics;
    public string Name { get; }
    public SymbolKind Kind { get; }
    public NamespaceOrTypeSymbol Target { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsExtern { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public bool IsOverride { get; }
    public bool IsVirtual { get; }
    public bool IsStatic { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public Accessibility DeclaredAccessibility { get; }
    public Symbol ContainingSymbol { get; }
    internal DiagnosticBag AliasTargetDiagnostics { get; }
    internal bool RequiresCompletion { get; }
    private INamespaceOrTypeSymbol Microsoft.CodeAnalysis.IAliasSymbol.Target { get; }
    private AliasSymbol(Binder binder, NamespaceOrTypeSymbol target, SyntaxToken aliasName, ImmutableArray`1<Location> locations);
    private AliasSymbol(Binder binder, SyntaxToken aliasName);
    internal AliasSymbol(Binder binder, UsingDirectiveSyntax syntax);
    internal AliasSymbol(Binder binder, ExternAliasDirectiveSyntax syntax);
    internal static AliasSymbol CreateGlobalNamespaceAlias(NamespaceSymbol globalNamespace, Binder globalNamespaceBinder);
    internal static AliasSymbol CreateCustomDebugInfoAlias(NamespaceOrTypeSymbol targetSymbol, SyntaxToken aliasToken, Binder binder);
    internal AliasSymbol ToNewSubmission(CSharpCompilation compilation);
    public virtual string get_Name();
    public virtual SymbolKind get_Kind();
    public NamespaceOrTypeSymbol get_Target();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool get_IsExtern();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsOverride();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsStatic();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual Symbol get_ContainingSymbol();
    internal virtual TResult Accept(CSharpSymbolVisitor`2<TArg, TResult> visitor, TArg a);
    public virtual void Accept(CSharpSymbolVisitor visitor);
    public virtual TResult Accept(CSharpSymbolVisitor`1<TResult> visitor);
    internal NamespaceOrTypeSymbol GetAliasTarget(ConsList`1<Symbol> basesBeingResolved);
    internal DiagnosticBag get_AliasTargetDiagnostics();
    internal void CheckConstraints(DiagnosticBag diagnostics);
    private NamespaceSymbol ResolveExternAliasTarget(DiagnosticBag diagnostics);
    private static NamespaceOrTypeSymbol ResolveAliasTarget(Binder binder, NameSyntax syntax, DiagnosticBag diagnostics, ConsList`1<Symbol> basesBeingResolved);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual bool get_RequiresCompletion();
    private sealed virtual override INamespaceOrTypeSymbol Microsoft.CodeAnalysis.IAliasSymbol.get_Target();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor : ValueType {
    public Location Location;
    public ImmutableArray`1<AnonymousTypeField> Fields;
    public string Key;
    public AnonymousTypeDescriptor(ImmutableArray`1<AnonymousTypeField> fields, Location location);
    internal static string ComputeKey(ImmutableArray`1<T> fields, Func`2<T, string> getName);
    [ConditionalAttribute("DEBUG")]
internal void AssertIsGood();
    public sealed virtual bool Equals(AnonymousTypeDescriptor desc);
    internal bool Equals(AnonymousTypeDescriptor other, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal AnonymousTypeDescriptor WithNewFieldsTypes(ImmutableArray`1<TypeSymbol> newFieldTypes);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeField : ValueType {
    public string Name;
    public Location Location;
    public TypeSymbol Type;
    public AnonymousTypeField(string name, Location location, TypeSymbol type);
    [ConditionalAttribute("DEBUG")]
internal void AssertIsGood();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager : CommonAnonymousTypeManager {
    [CompilerGeneratedAttribute]
private CSharpCompilation <Compilation>k__BackingField;
    private ConcurrentDictionary`2<string, AnonymousTypeTemplateSymbol> _lazyAnonymousTypeTemplates;
    private ConcurrentDictionary`2<SynthesizedDelegateKey, SynthesizedDelegateValue> _lazySynthesizedDelegates;
    public CSharpCompilation Compilation { get; }
    public NamedTypeSymbol System_Object { get; }
    public NamedTypeSymbol System_Void { get; }
    public NamedTypeSymbol System_Boolean { get; }
    public NamedTypeSymbol System_String { get; }
    public NamedTypeSymbol System_Int32 { get; }
    public NamedTypeSymbol System_Diagnostics_DebuggerBrowsableState { get; }
    public MethodSymbol System_Object__Equals { get; }
    public MethodSymbol System_Object__ToString { get; }
    public MethodSymbol System_Object__GetHashCode { get; }
    public MethodSymbol System_Runtime_CompilerServices_CompilerGeneratedAttribute__ctor { get; }
    public MethodSymbol System_Diagnostics_DebuggerHiddenAttribute__ctor { get; }
    public MethodSymbol System_Diagnostics_DebuggerBrowsableAttribute__ctor { get; }
    public MethodSymbol System_Collections_Generic_EqualityComparer_T__Equals { get; }
    public MethodSymbol System_Collections_Generic_EqualityComparer_T__GetHashCode { get; }
    public MethodSymbol System_Collections_Generic_EqualityComparer_T__get_Default { get; }
    public MethodSymbol System_String__Format_IFormatProvider { get; }
    private ConcurrentDictionary`2<string, AnonymousTypeTemplateSymbol> AnonymousTypeTemplates { get; }
    private ConcurrentDictionary`2<SynthesizedDelegateKey, SynthesizedDelegateValue> SynthesizedDelegates { get; }
    internal AnonymousTypeManager(CSharpCompilation compilation);
    [CompilerGeneratedAttribute]
public CSharpCompilation get_Compilation();
    public NamedTypeSymbol ConstructAnonymousTypeSymbol(AnonymousTypeDescriptor typeDescr);
    internal static PropertySymbol GetAnonymousTypeProperty(NamedTypeSymbol type, int index);
    internal static ImmutableArray`1<TypeSymbol> GetAnonymousTypePropertyTypes(NamedTypeSymbol type);
    public static NamedTypeSymbol ConstructAnonymousTypeSymbol(NamedTypeSymbol type, ImmutableArray`1<TypeSymbol> newFieldTypes);
    internal static bool IsSameType(TypeSymbol type1, TypeSymbol type2, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
    public bool ReportMissingOrErroneousSymbols(DiagnosticBag diagnostics);
    private static void ReportErrorOnSymbol(Symbol symbol, DiagnosticBag diagnostics, Boolean& hasError);
    private static void ReportErrorOnSpecialMember(Symbol symbol, SpecialMember member, DiagnosticBag diagnostics, Boolean& hasError);
    private static void ReportErrorOnWellKnownMember(Symbol symbol, WellKnownMember member, DiagnosticBag diagnostics, Boolean& hasError);
    public NamedTypeSymbol get_System_Object();
    public NamedTypeSymbol get_System_Void();
    public NamedTypeSymbol get_System_Boolean();
    public NamedTypeSymbol get_System_String();
    public NamedTypeSymbol get_System_Int32();
    public NamedTypeSymbol get_System_Diagnostics_DebuggerBrowsableState();
    public MethodSymbol get_System_Object__Equals();
    public MethodSymbol get_System_Object__ToString();
    public MethodSymbol get_System_Object__GetHashCode();
    public MethodSymbol get_System_Runtime_CompilerServices_CompilerGeneratedAttribute__ctor();
    public MethodSymbol get_System_Diagnostics_DebuggerHiddenAttribute__ctor();
    public MethodSymbol get_System_Diagnostics_DebuggerBrowsableAttribute__ctor();
    public MethodSymbol get_System_Collections_Generic_EqualityComparer_T__Equals();
    public MethodSymbol get_System_Collections_Generic_EqualityComparer_T__GetHashCode();
    public MethodSymbol get_System_Collections_Generic_EqualityComparer_T__get_Default();
    public MethodSymbol get_System_String__Format_IFormatProvider();
    [ConditionalAttribute("DEBUG")]
private void CheckSourceLocationSeen(AnonymousTypePublicSymbol anonymous);
    private ConcurrentDictionary`2<string, AnonymousTypeTemplateSymbol> get_AnonymousTypeTemplates();
    private ConcurrentDictionary`2<SynthesizedDelegateKey, SynthesizedDelegateValue> get_SynthesizedDelegates();
    internal SynthesizedDelegateSymbol SynthesizeDelegate(int parameterCount, BitVector byRefParameters, bool returnsVoid, int generation);
    private NamedTypeSymbol ConstructAnonymousTypeImplementationSymbol(AnonymousTypePublicSymbol anonymous);
    private AnonymousTypeTemplateSymbol CreatePlaceholderTemplate(AnonymousTypeKey key);
    public void AssignTemplatesNamesAndCompile(MethodCompiler compiler, PEModuleBuilder moduleBeingBuilt, DiagnosticBag diagnostics);
    private void GetCreatedAnonymousTypeTemplates(ArrayBuilder`1<AnonymousTypeTemplateSymbol> builder);
    private void GetCreatedSynthesizedDelegates(ArrayBuilder`1<SynthesizedDelegateSymbol> builder);
    internal static AnonymousTypeKey GetAnonymousTypeKey(NamedTypeSymbol type);
    internal IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> GetAnonymousTypeMap();
    internal ImmutableArray`1<NamedTypeSymbol> GetAllCreatedTemplates();
    internal static bool IsAnonymousTypeTemplate(NamedTypeSymbol type);
    internal static ImmutableArray`1<MethodSymbol> GetAnonymousTypeHiddenMethods(NamedTypeSymbol type);
    internal static NamedTypeSymbol TranslateAnonymousTypeSymbol(NamedTypeSymbol type);
    internal static MethodSymbol TranslateAnonymousTypeMethodSymbol(MethodSymbol method);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol : TypeSymbol {
    private TypeSymbol _elementType;
    private NamedTypeSymbol _baseType;
    private ImmutableArray`1<CustomModifier> _customModifiers;
    private bool Microsoft.Cci.IArrayTypeReference.IsSZArray { get; }
    private IEnumerable`1<int> Microsoft.Cci.IArrayTypeReference.LowerBounds { get; }
    private UInt32 Microsoft.Cci.IArrayTypeReference.Rank { get; }
    private IEnumerable`1<ulong> Microsoft.Cci.IArrayTypeReference.Sizes { get; }
    private bool Microsoft.Cci.ITypeReference.IsEnum { get; }
    private bool Microsoft.Cci.ITypeReference.IsValueType { get; }
    private TypeDefinitionHandle Microsoft.Cci.ITypeReference.TypeDef { get; }
    private IGenericMethodParameterReference Microsoft.Cci.ITypeReference.AsGenericMethodParameterReference { get; }
    private IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.AsGenericTypeInstanceReference { get; }
    private IGenericTypeParameterReference Microsoft.Cci.ITypeReference.AsGenericTypeParameterReference { get; }
    private INamespaceTypeReference Microsoft.Cci.ITypeReference.AsNamespaceTypeReference { get; }
    private INestedTypeReference Microsoft.Cci.ITypeReference.AsNestedTypeReference { get; }
    private ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.AsSpecializedNestedTypeReference { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public int Rank { get; }
    internal bool IsSZArray { get; }
    internal ImmutableArray`1<int> Sizes { get; }
    internal ImmutableArray`1<int> LowerBounds { get; }
    internal bool HasDefaultSizesAndLowerBounds { get; }
    public TypeSymbol ElementType { get; }
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    internal bool IsManagedType { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public SymbolKind Kind { get; }
    public TypeKind TypeKind { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    private ITypeSymbol Microsoft.CodeAnalysis.IArrayTypeSymbol.ElementType { get; }
    private ImmutableArray`1<CustomModifier> Microsoft.CodeAnalysis.IArrayTypeSymbol.CustomModifiers { get; }
    private ArrayTypeSymbol(TypeSymbol elementType, NamedTypeSymbol array, ImmutableArray`1<CustomModifier> customModifiers);
    private sealed virtual override ITypeReference Microsoft.Cci.IArrayTypeReference.GetElementType(EmitContext context);
    private sealed virtual override bool Microsoft.Cci.IArrayTypeReference.get_IsSZArray();
    private sealed virtual override IEnumerable`1<int> Microsoft.Cci.IArrayTypeReference.get_LowerBounds();
    private sealed virtual override UInt32 Microsoft.Cci.IArrayTypeReference.get_Rank();
    private sealed virtual override IEnumerable`1<ulong> Microsoft.Cci.IArrayTypeReference.get_Sizes();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol/<GetSizes>d__9")]
private IEnumerable`1<ulong> GetSizes();
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsEnum();
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsValueType();
    private sealed virtual override TypeDefinitionHandle Microsoft.Cci.ITypeReference.get_TypeDef();
    private sealed virtual override PrimitiveTypeCode Microsoft.Cci.ITypeReference.TypeCode(EmitContext context);
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.GetResolvedType(EmitContext context);
    private sealed virtual override IGenericMethodParameterReference Microsoft.Cci.ITypeReference.get_AsGenericMethodParameterReference();
    private sealed virtual override IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.get_AsGenericTypeInstanceReference();
    private sealed virtual override IGenericTypeParameterReference Microsoft.Cci.ITypeReference.get_AsGenericTypeParameterReference();
    private sealed virtual override INamespaceTypeDefinition Microsoft.Cci.ITypeReference.AsNamespaceTypeDefinition(EmitContext context);
    private sealed virtual override INamespaceTypeReference Microsoft.Cci.ITypeReference.get_AsNamespaceTypeReference();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.ITypeReference.AsNestedTypeDefinition(EmitContext context);
    private sealed virtual override INestedTypeReference Microsoft.Cci.ITypeReference.get_AsNestedTypeReference();
    private sealed virtual override ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.get_AsSpecializedNestedTypeReference();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.AsTypeDefinition(EmitContext context);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
    internal static ArrayTypeSymbol CreateCSharpArray(AssemblySymbol declaringAssembly, TypeSymbol elementType, ImmutableArray`1<CustomModifier> customModifiers, int rank);
    internal static ArrayTypeSymbol CreateMDArray(TypeSymbol elementType, int rank, ImmutableArray`1<int> sizes, ImmutableArray`1<int> lowerBounds, NamedTypeSymbol array, ImmutableArray`1<CustomModifier> customModifiers);
    internal static ArrayTypeSymbol CreateMDArray(AssemblySymbol declaringAssembly, TypeSymbol elementType, int rank, ImmutableArray`1<int> sizes, ImmutableArray`1<int> lowerBounds, ImmutableArray`1<CustomModifier> customModifiers);
    internal static ArrayTypeSymbol CreateSZArray(TypeSymbol elementType, NamedTypeSymbol array, ImmutableArray`1<NamedTypeSymbol> constructedInterfaces, ImmutableArray`1<CustomModifier> customModifiers);
    internal static ArrayTypeSymbol CreateSZArray(AssemblySymbol declaringAssembly, TypeSymbol elementType, ImmutableArray`1<CustomModifier> customModifiers);
    private static ImmutableArray`1<NamedTypeSymbol> GetSZArrayInterfaces(TypeSymbol elementType, AssemblySymbol declaringAssembly);
    public ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public abstract virtual int get_Rank();
    internal abstract virtual bool get_IsSZArray();
    internal bool HasSameShapeAs(ArrayTypeSymbol other);
    internal virtual ImmutableArray`1<int> get_Sizes();
    internal virtual ImmutableArray`1<int> get_LowerBounds();
    internal bool HasSameSizesAndLowerBoundsAs(ArrayTypeSymbol other);
    internal abstract virtual bool get_HasDefaultSizesAndLowerBounds();
    public TypeSymbol get_ElementType();
    internal virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsValueType();
    internal sealed virtual bool get_IsManagedType();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public virtual SymbolKind get_Kind();
    public virtual TypeKind get_TypeKind();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual TResult Accept(CSharpSymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual void Accept(CSharpSymbolVisitor visitor);
    public virtual TResult Accept(CSharpSymbolVisitor`1<TResult> visitor);
    internal virtual bool Equals(TypeSymbol t2, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
    internal bool Equals(ArrayTypeSymbol other);
    private bool Equals(ArrayTypeSymbol other, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
    public virtual int GetHashCode();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsStatic();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    internal virtual bool GetUnificationUseSiteDiagnosticRecursive(DiagnosticInfo& result, Symbol owner, HashSet`1& checkedTypes);
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.IArrayTypeSymbol.get_ElementType();
    private sealed virtual override ImmutableArray`1<CustomModifier> Microsoft.CodeAnalysis.IArrayTypeSymbol.get_CustomModifiers();
    private sealed virtual override bool Microsoft.CodeAnalysis.IArrayTypeSymbol.Equals(IArrayTypeSymbol symbol);
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol : Symbol {
    private AssemblySymbol _corLibrary;
    private static Char[] s_nestedTypeNameSeparators;
    internal AssemblySymbol CorLibrary { get; }
    public string Name { get; }
    public AssemblyIdentity Identity { get; }
    public Version AssemblyVersionPattern { get; }
    internal Machine Machine { get; }
    internal bool Bit32Required { get; }
    public NamespaceSymbol GlobalNamespace { get; }
    public ImmutableArray`1<ModuleSymbol> Modules { get; }
    public SymbolKind Kind { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal bool IsMissing { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsInteractive { get; }
    public Symbol ContainingSymbol { get; }
    internal bool KeepLookingForDeclaredSpecialTypes { get; }
    internal bool IsLinked { get; }
    public ICollection`1<string> TypeNames { get; }
    public ICollection`1<string> NamespaceNames { get; }
    public bool MightContainExtensionMethods { get; }
    internal static TypeSymbol DynamicType { get; }
    internal NamedTypeSymbol ObjectType { get; }
    internal ImmutableArray`1<byte> PublicKey { get; }
    private INamespaceSymbol Microsoft.CodeAnalysis.IAssemblySymbol.GlobalNamespace { get; }
    private IEnumerable`1<IModuleSymbol> Microsoft.CodeAnalysis.IAssemblySymbol.Modules { get; }
    private static AssemblySymbol();
    internal AssemblySymbol get_CorLibrary();
    internal void SetCorLibrary(AssemblySymbol corLibrary);
    public virtual string get_Name();
    public abstract virtual AssemblyIdentity get_Identity();
    public abstract virtual Version get_AssemblyVersionPattern();
    internal Machine get_Machine();
    internal bool get_Bit32Required();
    public abstract virtual NamespaceSymbol get_GlobalNamespace();
    internal NamespaceSymbol GetAssemblyNamespace(NamespaceSymbol namespaceSymbol);
    public abstract virtual ImmutableArray`1<ModuleSymbol> get_Modules();
    internal virtual TResult Accept(CSharpSymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual void Accept(CSharpSymbolVisitor visitor);
    public virtual TResult Accept(CSharpSymbolVisitor`1<TResult> visitor);
    public sealed virtual SymbolKind get_Kind();
    public sealed virtual AssemblySymbol get_ContainingAssembly();
    internal abstract virtual bool get_IsMissing();
    public sealed virtual Accessibility get_DeclaredAccessibility();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsExtern();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool get_IsInteractive();
    public sealed virtual Symbol get_ContainingSymbol();
    internal NamedTypeSymbol LookupTopLevelMetadataType(MetadataTypeName& emittedName, bool digThroughForwardedTypes);
    internal abstract virtual NamedTypeSymbol LookupTopLevelMetadataTypeWithCycleDetection(MetadataTypeName& emittedName, ConsList`1<AssemblySymbol> visitedAssemblies, bool digThroughForwardedTypes);
    public NamedTypeSymbol ResolveForwardedType(string fullyQualifiedMetadataName);
    internal NamedTypeSymbol TryLookupForwardedMetadataType(MetadataTypeName& emittedName);
    internal virtual NamedTypeSymbol TryLookupForwardedMetadataTypeWithCycleDetection(MetadataTypeName& emittedName, ConsList`1<AssemblySymbol> visitedAssemblies);
    internal ErrorTypeSymbol CreateCycleInTypeForwarderErrorTypeSymbol(MetadataTypeName& emittedName);
    internal abstract virtual NamedTypeSymbol GetDeclaredSpecialType(SpecialType type);
    internal virtual void RegisterDeclaredSpecialType(NamedTypeSymbol corType);
    internal virtual bool get_KeepLookingForDeclaredSpecialTypes();
    internal abstract virtual ImmutableArray`1<AssemblySymbol> GetNoPiaResolutionAssemblies();
    internal abstract virtual void SetNoPiaResolutionAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal abstract virtual ImmutableArray`1<AssemblySymbol> GetLinkedReferencedAssemblies();
    internal abstract virtual void SetLinkedReferencedAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal abstract virtual IEnumerable`1<ImmutableArray`1<byte>> GetInternalsVisibleToPublicKeys(string simpleName);
    internal abstract virtual bool AreInternalsVisibleToThisAssembly(AssemblySymbol other);
    internal abstract virtual bool get_IsLinked();
    internal virtual bool GetGuidString(String& guidString);
    public abstract virtual ICollection`1<string> get_TypeNames();
    public abstract virtual ICollection`1<string> get_NamespaceNames();
    public abstract virtual bool get_MightContainExtensionMethods();
    internal NamedTypeSymbol GetSpecialType(SpecialType type);
    internal NamedTypeSymbol GetWellKnownType(WellKnownType type);
    internal static TypeSymbol get_DynamicType();
    internal NamedTypeSymbol get_ObjectType();
    internal NamedTypeSymbol GetPrimitiveType(PrimitiveTypeCode type);
    public NamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName);
    internal NamedTypeSymbol GetTypeByMetadataName(string metadataName, bool includeReferences, bool isWellKnownType, bool useCLSCompliantNameArityEncoding, DiagnosticBag warnings);
    internal TypeSymbol GetTypeByReflectionType(Type type, bool includeReferences);
    private NamedTypeSymbol ApplyGenericArguments(NamedTypeSymbol symbol, Type[] typeArguments, Int32& currentTypeArgument, bool includeReferences);
    internal NamedTypeSymbol GetTopLevelTypeByMetadataName(MetadataTypeName& metadataName, AssemblyIdentity assemblyOpt, bool includeReferences, bool isWellKnownType, DiagnosticBag warnings);
    private bool IsValidWellKnownType(NamedTypeSymbol result);
    private static NamedTypeSymbol GetTopLevelTypeByMetadataName(AssemblySymbol assembly, MetadataTypeName& metadataName, AssemblyIdentity assemblyOpt);
    private static bool IsAcceptableMatchForGetTypeByMetadataName(NamedTypeSymbol candidate);
    internal virtual Symbol GetDeclaredSpecialTypeMember(SpecialMember member);
    internal virtual Symbol GetSpecialTypeMember(SpecialMember member);
    internal abstract virtual ImmutableArray`1<byte> get_PublicKey();
    protected IVTConclusion PerformIVTCheck(ImmutableArray`1<byte> key, AssemblyIdentity otherIdentity);
    private sealed virtual override INamespaceSymbol Microsoft.CodeAnalysis.IAssemblySymbol.get_GlobalNamespace();
    private sealed virtual override IEnumerable`1<IModuleSymbol> Microsoft.CodeAnalysis.IAssemblySymbol.get_Modules();
    public abstract virtual AssemblyMetadata GetMetadata();
    private sealed virtual override INamedTypeSymbol Microsoft.CodeAnalysis.IAssemblySymbol.ResolveForwardedType(string fullyQualifiedMetadataName);
    private sealed virtual override bool Microsoft.CodeAnalysis.IAssemblySymbol.GivesAccessTo(IAssemblySymbol assemblyWantingAccess);
    private sealed virtual override INamedTypeSymbol Microsoft.CodeAnalysis.IAssemblySymbol.GetTypeByMetadataName(string metadataName);
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.AttributeDataExtensions : object {
    [ExtensionAttribute]
internal static int IndexOfAttribute(ImmutableArray`1<CSharpAttributeData> attributes, Symbol targetSymbol, AttributeDescription description);
    [ExtensionAttribute]
internal static CSharpSyntaxNode GetAttributeArgumentSyntax(AttributeData attribute, int parameterIndex, AttributeSyntax attributeSyntax);
    [ExtensionAttribute]
internal static Location GetAttributeArgumentSyntaxLocation(AttributeData attribute, int parameterIndex, AttributeSyntax attributeSyntaxOpt);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation : Enum {
    public short value__;
    public static AttributeLocation None;
    public static AttributeLocation Assembly;
    public static AttributeLocation Module;
    public static AttributeLocation Type;
    public static AttributeLocation Method;
    public static AttributeLocation Field;
    public static AttributeLocation Property;
    public static AttributeLocation Event;
    public static AttributeLocation Parameter;
    public static AttributeLocation Return;
    public static AttributeLocation TypeParameter;
    public static AttributeLocation Unknown;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocationExtensions : object {
    [ExtensionAttribute]
internal static string ToDisplayString(AttributeLocation locations);
    [ExtensionAttribute]
internal static AttributeLocation ToAttributeLocation(SyntaxToken token);
    [ExtensionAttribute]
internal static AttributeLocation ToAttributeLocation(SyntaxToken token);
    private static AttributeLocation ToAttributeLocation(string text);
}
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.BaseTypeAnalysis : object {
    internal static bool ClassDependsOn(NamedTypeSymbol depends, NamedTypeSymbol on);
    private static void ClassDependsClosure(NamedTypeSymbol type, CSharpCompilation currentCompilation, HashSet`1<Symbol> partialClosure);
    internal static bool StructDependsOn(NamedTypeSymbol depends, NamedTypeSymbol on);
    private static void StructDependsClosure(NamedTypeSymbol type, HashSet`1<Symbol> partialClosure, NamedTypeSymbol on);
    internal static bool IsManagedType(NamedTypeSymbol type);
    private static bool DependsOnDefinitelyManagedType(NamedTypeSymbol type, HashSet`1<Symbol> partialClosure);
    private static ThreeState IsManagedTypeHelper(NamedTypeSymbol type);
    internal static bool InterfaceDependsOn(NamedTypeSymbol depends, NamedTypeSymbol on);
    private static void InterfaceDependsClosure(NamedTypeSymbol type, HashSet`1<Symbol> partialClosure);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.ByRefReturnErrorTypeSymbol : ErrorTypeSymbol {
    private TypeSymbol _referencedType;
    private ushort _countOfCustomModifiersPrecedingByRef;
    internal TypeSymbol ReferencedType { get; }
    internal DiagnosticInfo ErrorInfo { get; }
    internal bool MangleName { get; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    internal bool IsManagedType { get; }
    internal ByRefReturnErrorTypeSymbol(TypeSymbol referencedType, ushort countOfCustomModifiersPrecedingByRef);
    internal TypeSymbol get_ReferencedType();
    internal virtual TypeWithModifiers Substitute(AbstractTypeMap typeMap);
    internal virtual bool Equals(TypeSymbol t2, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
    public virtual int GetHashCode();
    internal virtual DiagnosticInfo get_ErrorInfo();
    internal virtual bool get_MangleName();
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsValueType();
    internal virtual bool get_IsManagedType();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.Symbols.CompletionPart : Enum {
    public int value__;
    public static CompletionPart None;
    public static CompletionPart Attributes;
    public static CompletionPart ReturnTypeAttributes;
    public static CompletionPart Parameters;
    public static CompletionPart Type;
    public static CompletionPart StartBaseType;
    public static CompletionPart FinishBaseType;
    public static CompletionPart StartInterfaces;
    public static CompletionPart FinishInterfaces;
    public static CompletionPart EnumUnderlyingType;
    public static CompletionPart TypeArguments;
    public static CompletionPart TypeParameters;
    public static CompletionPart Members;
    public static CompletionPart TypeMembers;
    public static CompletionPart SynthesizedExplicitImplementations;
    public static CompletionPart StartMemberChecks;
    public static CompletionPart FinishMemberChecks;
    public static CompletionPart MembersCompleted;
    public static CompletionPart All;
    public static CompletionPart NamedTypeSymbolWithLocationAll;
    public static CompletionPart NamedTypeSymbolAll;
    public static CompletionPart StartValidatingImports;
    public static CompletionPart FinishValidatingImports;
    public static CompletionPart ImportsAll;
    public static CompletionPart NameToMembersMap;
    public static CompletionPart NamespaceSymbolAll;
    public static CompletionPart FixedSize;
    public static CompletionPart ConstantValue;
    public static CompletionPart FieldSymbolAll;
    public static CompletionPart StartAsyncMethodChecks;
    public static CompletionPart FinishAsyncMethodChecks;
    public static CompletionPart StartMethodChecks;
    public static CompletionPart FinishMethodChecks;
    public static CompletionPart MethodSymbolAll;
    public static CompletionPart TypeParameterConstraints;
    public static CompletionPart TypeParameterSymbolAll;
    public static CompletionPart PropertySymbolAll;
    public static CompletionPart AliasTarget;
    public static CompletionPart StartAttributeChecks;
    public static CompletionPart FinishAttributeChecks;
    public static CompletionPart Module;
    public static CompletionPart StartValidatingAddedModules;
    public static CompletionPart FinishValidatingAddedModules;
    public static CompletionPart AssemblySymbolAll;
    public static CompletionPart StartValidatingReferencedAssemblies;
    public static CompletionPart FinishValidatingReferencedAssemblies;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.ConstantEvaluationHelpers : object {
    [ExtensionAttribute]
internal static void OrderAllDependencies(SourceFieldSymbolWithSyntaxReference field, ArrayBuilder`1<FieldInfo> order, bool earlyDecodingWellKnownAttributes);
    private static void CreateGraph(Dictionary`2<SourceFieldSymbolWithSyntaxReference, Node`1<SourceFieldSymbolWithSyntaxReference>> graph, SourceFieldSymbolWithSyntaxReference field, bool earlyDecodingWellKnownAttributes);
    private static void OrderGraph(Dictionary`2<SourceFieldSymbolWithSyntaxReference, Node`1<SourceFieldSymbolWithSyntaxReference>> graph, ArrayBuilder`1<FieldInfo> order);
    private static SourceFieldSymbolWithSyntaxReference GetStartOfFirstCycle(Dictionary`2<SourceFieldSymbolWithSyntaxReference, Node`1<SourceFieldSymbolWithSyntaxReference>> graph);
    private static void OrderCompilations(Dictionary`2<SourceFieldSymbolWithSyntaxReference, Node`1<SourceFieldSymbolWithSyntaxReference>> fields, Dictionary`2<Compilation, int> compilations);
    private static SourceFieldSymbolWithSyntaxReference GetMemberOfCycle(Dictionary`2<SourceFieldSymbolWithSyntaxReference, Node`1<SourceFieldSymbolWithSyntaxReference>> graph);
    private static void GetAllReachable(Dictionary`2<SourceFieldSymbolWithSyntaxReference, Node`1<SourceFieldSymbolWithSyntaxReference>> graph, ArrayBuilder`1<SourceFieldSymbolWithSyntaxReference> fields, SourceFieldSymbolWithSyntaxReference field);
    [ConditionalAttribute("DEBUG")]
private static void CheckGraph(Dictionary`2<SourceFieldSymbolWithSyntaxReference, Node`1<SourceFieldSymbolWithSyntaxReference>> graph);
}
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.ConstantValueUtils : object {
    public static ConstantValue EvaluateFieldConstant(SourceFieldSymbol symbol, EqualsValueClauseSyntax equalsValueNode, HashSet`1<SourceFieldSymbolWithSyntaxReference> dependencies, bool earlyDecodingWellKnownAttributes, DiagnosticBag diagnostics);
    private static BoundExpression BindFieldOrEnumInitializer(Binder binder, FieldSymbol fieldSymbol, EqualsValueClauseSyntax initializer, DiagnosticBag diagnostics);
    internal static ConstantValue GetAndValidateConstantValue(BoundExpression boundValue, Symbol thisSymbol, TypeSymbol typeSymbol, Location initValueNodeLocation, DiagnosticBag diagnostics);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.ConstraintsHelper : object {
    private static Func`4<TypeSymbol, CheckConstraintsArgs, bool, bool> s_checkConstraintsSingleTypeFunc;
    private static ConstraintsHelper();
    [ExtensionAttribute]
public static TypeParameterBounds ResolveBounds(TypeParameterSymbol typeParameter, AssemblySymbol corLibrary, ConsList`1<TypeParameterSymbol> inProgress, ImmutableArray`1<TypeSymbol> constraintTypes, bool inherited, CSharpCompilation currentCompilation, DiagnosticBag diagnostics);
    [ExtensionAttribute]
public static TypeParameterBounds ResolveBounds(TypeParameterSymbol typeParameter, AssemblySymbol corLibrary, ConsList`1<TypeParameterSymbol> inProgress, ImmutableArray`1<TypeSymbol> constraintTypes, bool inherited, CSharpCompilation currentCompilation, ArrayBuilder`1<TypeParameterDiagnosticInfo> diagnosticsBuilder, ArrayBuilder`1& useSiteDiagnosticsBuilder);
    [ExtensionAttribute]
internal static void CheckConstraintTypesVisibility(Symbol containingSymbol, Location location, ImmutableArray`1<TypeParameterConstraintClause> constraintClauses, DiagnosticBag diagnostics);
    private static void CheckOverrideConstraints(TypeParameterSymbol typeParameter, TypeParameterBounds bounds, ArrayBuilder`1<TypeParameterDiagnosticInfo> diagnosticsBuilder);
    [ExtensionAttribute]
public static void CheckAllConstraints(TypeSymbol type, ConversionsBase conversions, Location location, DiagnosticBag diagnostics);
    [ExtensionAttribute]
public static bool CheckAllConstraints(TypeSymbol type, ConversionsBase conversions);
    private static bool CheckConstraintsSingleType(TypeSymbol type, CheckConstraintsArgs args);
    [ExtensionAttribute]
public static bool CheckConstraints(NamedTypeSymbol type, ConversionsBase conversions, CSharpSyntaxNode typeSyntax, SeparatedSyntaxList`1<TypeSyntax> typeArgumentsSyntax, Compilation currentCompilation, ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    [ExtensionAttribute]
public static bool CheckConstraints(NamedTypeSymbol type, CSharpCompilation currentCompilation, ConversionsBase conversions, Location location, DiagnosticBag diagnostics);
    private static bool HasDuplicateInterfaces(NamedTypeSymbol type, ConsList`1<Symbol> basesBeingResolved);
    [ExtensionAttribute]
public static bool CheckConstraints(MethodSymbol method, ConversionsBase conversions, CSharpSyntaxNode syntaxNode, Compilation currentCompilation, DiagnosticBag diagnostics, BitVector skipParameters);
    [ExtensionAttribute]
public static bool CheckConstraints(MethodSymbol method, ConversionsBase conversions, Location location, Compilation currentCompilation, DiagnosticBag diagnostics);
    private static bool CheckTypeConstraints(NamedTypeSymbol type, ConversionsBase conversions, Compilation currentCompilation, ArrayBuilder`1<TypeParameterDiagnosticInfo> diagnosticsBuilder, ArrayBuilder`1& useSiteDiagnosticsBuilder);
    private static bool CheckMethodConstraints(MethodSymbol method, ConversionsBase conversions, Compilation currentCompilation, ArrayBuilder`1<TypeParameterDiagnosticInfo> diagnosticsBuilder, ArrayBuilder`1& useSiteDiagnosticsBuilder, BitVector skipParameters);
    [ExtensionAttribute]
public static bool CheckConstraints(Symbol containingSymbol, ConversionsBase conversions, TypeMap substitution, ImmutableArray`1<TypeParameterSymbol> typeParameters, ImmutableArray`1<TypeSymbol> typeArguments, Compilation currentCompilation, ArrayBuilder`1<TypeParameterDiagnosticInfo> diagnosticsBuilder, ArrayBuilder`1& useSiteDiagnosticsBuilder, BitVector skipParameters);
    private static bool CheckConstraints(Symbol containingSymbol, ConversionsBase conversions, TypeMap substitution, TypeParameterSymbol typeParameter, TypeSymbol typeArgument, Compilation currentCompilation, ArrayBuilder`1<TypeParameterDiagnosticInfo> diagnosticsBuilder, ArrayBuilder`1& useSiteDiagnosticsBuilder);
    private static bool AppendUseSiteDiagnostics(HashSet`1<DiagnosticInfo> useSiteDiagnostics, TypeParameterSymbol typeParameter, ArrayBuilder`1& useSiteDiagnosticsBuilder);
    private static bool SatisfiesConstraintType(ConversionsBase conversions, TypeSymbol typeArgument, TypeSymbol constraintType, HashSet`1& useSiteDiagnostics);
    private static bool IsReferenceType(TypeParameterSymbol typeParameter, ImmutableArray`1<TypeSymbol> constraintTypes);
    private static bool IsValueType(TypeParameterSymbol typeParameter, ImmutableArray`1<TypeSymbol> constraintTypes);
    private static TypeParameterDiagnosticInfo GenerateConflictingConstraintsError(TypeParameterSymbol typeParameter, TypeSymbol deducedBase, bool classConflict);
    private static void AddInterfaces(ArrayBuilder`1<NamedTypeSymbol> builder, ImmutableArray`1<NamedTypeSymbol> interfaces);
    private static void AddInterface(ArrayBuilder`1<NamedTypeSymbol> builder, NamedTypeSymbol interface);
    private static bool SatisfiesConstructorConstraint(TypeSymbol typeArgument);
    private static bool HasPublicParameterlessConstructor(NamedTypeSymbol type);
    private static bool IsEncompassedBy(ConversionsBase conversions, TypeSymbol a, TypeSymbol b, HashSet`1& useSiteDiagnostics);
    private static bool IsValidEncompassedByArgument(TypeSymbol type);
    private static bool RequiresChecking(NamedTypeSymbol type);
    private static bool RequiresChecking(MethodSymbol method);
    [ConditionalAttribute("DEBUG")]
private static void CheckEffectiveAndDeducedBaseTypes(ConversionsBase conversions, TypeSymbol effectiveBase, TypeSymbol deducedBase);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.ConstructedErrorTypeSymbol : SubstitutedErrorTypeSymbol {
    private ErrorTypeSymbol _constructedFrom;
    private ImmutableArray`1<TypeSymbol> _typeArguments;
    private bool _hasTypeArgumentsCustomModifiers;
    private TypeMap _map;
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    internal ImmutableArray`1<TypeSymbol> TypeArgumentsNoUseSiteDiagnostics { get; }
    internal bool HasTypeArgumentsCustomModifiers { get; }
    internal ImmutableArray`1<ImmutableArray`1<CustomModifier>> TypeArgumentsCustomModifiers { get; }
    public NamedTypeSymbol ConstructedFrom { get; }
    public Symbol ContainingSymbol { get; }
    internal TypeMap TypeSubstitution { get; }
    public ConstructedErrorTypeSymbol(ErrorTypeSymbol constructedFrom, ImmutableArray`1<TypeWithModifiers> typeArguments);
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal virtual ImmutableArray`1<TypeSymbol> get_TypeArgumentsNoUseSiteDiagnostics();
    internal virtual bool get_HasTypeArgumentsCustomModifiers();
    internal virtual ImmutableArray`1<ImmutableArray`1<CustomModifier>> get_TypeArgumentsCustomModifiers();
    public virtual NamedTypeSymbol get_ConstructedFrom();
    public virtual Symbol get_ContainingSymbol();
    internal virtual TypeMap get_TypeSubstitution();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.ConstructedMethodSymbol : SubstitutedMethodSymbol {
    private ImmutableArray`1<TypeSymbol> _typeArguments;
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    internal ConstructedMethodSymbol(MethodSymbol constructedFrom, ImmutableArray`1<TypeSymbol> typeArguments);
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.ConstructedNamedTypeSymbol : SubstitutedNamedTypeSymbol {
    private ImmutableArray`1<TypeSymbol> _typeArguments;
    private bool _hasTypeArgumentsCustomModifiers;
    private NamedTypeSymbol _constructedFrom;
    public NamedTypeSymbol ConstructedFrom { get; }
    internal ImmutableArray`1<TypeSymbol> TypeArgumentsNoUseSiteDiagnostics { get; }
    internal bool HasTypeArgumentsCustomModifiers { get; }
    internal ImmutableArray`1<ImmutableArray`1<CustomModifier>> TypeArgumentsCustomModifiers { get; }
    internal ConstructedNamedTypeSymbol(NamedTypeSymbol constructedFrom, ImmutableArray`1<TypeWithModifiers> typeArguments, bool unbound);
    public virtual NamedTypeSymbol get_ConstructedFrom();
    internal virtual ImmutableArray`1<TypeSymbol> get_TypeArgumentsNoUseSiteDiagnostics();
    internal virtual bool get_HasTypeArgumentsCustomModifiers();
    internal virtual ImmutableArray`1<ImmutableArray`1<CustomModifier>> get_TypeArgumentsCustomModifiers();
    internal static bool TypeParametersMatchTypeArguments(ImmutableArray`1<TypeParameterSymbol> typeParameters, ImmutableArray`1<TypeWithModifiers> typeArguments);
    internal sealed virtual bool GetUnificationUseSiteDiagnosticRecursive(DiagnosticInfo& result, Symbol owner, HashSet`1& checkedTypes);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.ConversionSignatureComparer : object {
    private static ConversionSignatureComparer s_comparer;
    public static ConversionSignatureComparer Comparer { get; }
    private static ConversionSignatureComparer();
    public static ConversionSignatureComparer get_Comparer();
    public sealed virtual bool Equals(SourceUserDefinedConversionSymbol member1, SourceUserDefinedConversionSymbol member2);
    public sealed virtual int GetHashCode(SourceUserDefinedConversionSymbol member);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.CrefTypeParameterSymbol : TypeParameterSymbol {
    private string _name;
    private int _ordinal;
    private SyntaxReference _declaringSyntax;
    public TypeParameterKind TypeParameterKind { get; }
    public string Name { get; }
    public int Ordinal { get; }
    public VarianceKind Variance { get; }
    public bool HasValueTypeConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasConstructorConstraint { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsImplicitlyDeclared { get; }
    public CrefTypeParameterSymbol(string name, int ordinal, IdentifierNameSyntax declaringSyntax);
    public virtual TypeParameterKind get_TypeParameterKind();
    public virtual string get_Name();
    public virtual int get_Ordinal();
    internal virtual bool Equals(TypeSymbol t2, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
    public virtual int GetHashCode();
    public virtual VarianceKind get_Variance();
    public virtual bool get_HasValueTypeConstraint();
    public virtual bool get_HasReferenceTypeConstraint();
    public virtual bool get_HasConstructorConstraint();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual void EnsureAllConstraintsAreResolved();
    internal virtual ImmutableArray`1<TypeSymbol> GetConstraintTypes(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetInterfaces(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual NamedTypeSymbol GetEffectiveBaseClass(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual TypeSymbol GetDeducedBaseType(ConsList`1<TypeParameterSymbol> inProgress);
    public virtual bool get_IsImplicitlyDeclared();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData : AttributeData {
    private ThreeState _lazyIsSecurityAttribute;
    private int Microsoft.Cci.ICustomAttribute.ArgumentCount { get; }
    private ushort Microsoft.Cci.ICustomAttribute.NamedArgumentCount { get; }
    private bool Microsoft.Cci.ICustomAttribute.AllowMultiple { get; }
    public NamedTypeSymbol AttributeClass { get; }
    public MethodSymbol AttributeConstructor { get; }
    public SyntaxReference ApplicationSyntaxReference { get; }
    public IEnumerable`1<TypedConstant> ConstructorArguments { get; }
    public IEnumerable`1<KeyValuePair`2<string, TypedConstant>> NamedArguments { get; }
    protected INamedTypeSymbol CommonAttributeClass { get; }
    protected IMethodSymbol CommonAttributeConstructor { get; }
    protected SyntaxReference CommonApplicationSyntaxReference { get; }
    private sealed virtual override ImmutableArray`1<IMetadataExpression> Microsoft.Cci.ICustomAttribute.GetArguments(EmitContext context);
    private sealed virtual override IMethodReference Microsoft.Cci.ICustomAttribute.Constructor(EmitContext context);
    private sealed virtual override ImmutableArray`1<IMetadataNamedArgument> Microsoft.Cci.ICustomAttribute.GetNamedArguments(EmitContext context);
    private sealed virtual override int Microsoft.Cci.ICustomAttribute.get_ArgumentCount();
    private sealed virtual override ushort Microsoft.Cci.ICustomAttribute.get_NamedArgumentCount();
    private sealed virtual override ITypeReference Microsoft.Cci.ICustomAttribute.GetType(EmitContext context);
    private sealed virtual override bool Microsoft.Cci.ICustomAttribute.get_AllowMultiple();
    private IMetadataExpression CreateMetadataExpression(TypedConstant argument, EmitContext context);
    private MetadataCreateArray CreateMetadataArray(TypedConstant argument, EmitContext context);
    private static MetadataTypeOf CreateType(TypedConstant argument, EmitContext context);
    private static MetadataConstant CreateMetadataConstant(ITypeSymbol type, object value, EmitContext context);
    private IMetadataNamedArgument CreateMetadataNamedArgument(string name, TypedConstant argument, EmitContext context);
    private Symbol LookupName(string name);
    public abstract virtual NamedTypeSymbol get_AttributeClass();
    public abstract virtual MethodSymbol get_AttributeConstructor();
    public abstract virtual SyntaxReference get_ApplicationSyntaxReference();
    public IEnumerable`1<TypedConstant> get_ConstructorArguments();
    public IEnumerable`1<KeyValuePair`2<string, TypedConstant>> get_NamedArguments();
    internal virtual bool IsTargetAttribute(string namespaceName, string typeName);
    internal bool IsTargetAttribute(Symbol targetSymbol, AttributeDescription description);
    internal abstract virtual int GetTargetAttributeSignatureIndex(Symbol targetSymbol, AttributeDescription description);
    internal static bool IsTargetEarlyAttribute(NamedTypeSymbol attributeType, AttributeSyntax attributeSyntax, AttributeDescription description);
    internal bool IsSecurityAttribute(CSharpCompilation compilation);
    public virtual string ToString();
    protected virtual INamedTypeSymbol get_CommonAttributeClass();
    protected virtual IMethodSymbol get_CommonAttributeConstructor();
    protected virtual SyntaxReference get_CommonApplicationSyntaxReference();
    internal void DecodeSecurityAttribute(Symbol targetSymbol, CSharpCompilation compilation, DecodeWellKnownAttributeArguments`3& arguments);
    private DeclarativeSecurityAction DecodeSecurityAttributeAction(Symbol targetSymbol, CSharpCompilation compilation, AttributeSyntax nodeOpt, Boolean& hasErrors, DiagnosticBag diagnostics);
    private DeclarativeSecurityAction DecodeSecurityAction(TypedConstant typedValue, Symbol targetSymbol, AttributeSyntax nodeOpt, DiagnosticBag diagnostics, Boolean& hasErrors);
    private static Location GetSecurityAttributeActionSyntaxLocation(AttributeSyntax nodeOpt, TypedConstant typedValue, String& displayString);
    private string DecodePermissionSetAttribute(CSharpCompilation compilation, AttributeSyntax nodeOpt, DiagnosticBag diagnostics);
    private static bool PermissionSetAttributeTypeHasRequiredProperty(NamedTypeSymbol permissionSetType, string propName);
    internal void DecodeClassInterfaceAttribute(AttributeSyntax nodeOpt, DiagnosticBag diagnostics);
    internal void DecodeInterfaceTypeAttribute(AttributeSyntax node, DiagnosticBag diagnostics);
    internal string DecodeGuidAttribute(AttributeSyntax nodeOpt, DiagnosticBag diagnostics);
    internal bool ShouldEmitAttribute(Symbol target, bool isReturnType, bool emittingAssemblyAttributesInNetModule);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.CSharpCustomModifier : CustomModifier {
    protected NamedTypeSymbol modifier;
    private bool Microsoft.Cci.ICustomModifier.IsOptional { get; }
    public INamedTypeSymbol Modifier { get; }
    private CSharpCustomModifier(NamedTypeSymbol modifier);
    private sealed virtual override bool Microsoft.Cci.ICustomModifier.get_IsOptional();
    private sealed virtual override ITypeReference Microsoft.Cci.ICustomModifier.GetModifier(EmitContext context);
    public virtual INamedTypeSymbol get_Modifier();
    public abstract virtual int GetHashCode();
    public abstract virtual bool Equals(object obj);
    internal static CustomModifier CreateOptional(NamedTypeSymbol modifier);
    internal static CustomModifier CreateRequired(NamedTypeSymbol modifier);
    internal static ImmutableArray`1<CustomModifier> Convert(ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers);
    private static CustomModifier Convert(ModifierInfo`1<TypeSymbol> customModifier);
}
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.CustomModifierUtils : object {
    internal static void CopyMethodCustomModifiers(MethodSymbol sourceMethod, MethodSymbol destinationMethod, TypeSymbol& returnType, ImmutableArray`1& returnTypeCustomModifiers, ImmutableArray`1& parameters, bool alsoCopyParamsModifier);
    internal static TypeSymbol CopyTypeCustomModifiers(TypeSymbol sourceType, TypeSymbol destinationType, RefKind refKind, AssemblySymbol containingAssembly);
    internal static ImmutableArray`1<ParameterSymbol> CopyParameterCustomModifiers(ImmutableArray`1<ParameterSymbol> sourceParameters, ImmutableArray`1<ParameterSymbol> destinationParameters, bool alsoCopyParamsModifier);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.DynamicTypeEraser : AbstractTypeMap {
    private TypeSymbol _objectType;
    public DynamicTypeEraser(TypeSymbol objectType);
    public TypeSymbol EraseDynamic(TypeSymbol type);
    protected virtual TypeSymbol SubstituteDynamicType();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.DynamicTypeSymbol : TypeSymbol {
    internal static DynamicTypeSymbol Instance;
    private bool Microsoft.Cci.ITypeReference.IsEnum { get; }
    private bool Microsoft.Cci.ITypeReference.IsValueType { get; }
    private TypeDefinitionHandle Microsoft.Cci.ITypeReference.TypeDef { get; }
    private IGenericMethodParameterReference Microsoft.Cci.ITypeReference.AsGenericMethodParameterReference { get; }
    private IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.AsGenericTypeInstanceReference { get; }
    private IGenericTypeParameterReference Microsoft.Cci.ITypeReference.AsGenericTypeParameterReference { get; }
    private INamespaceTypeReference Microsoft.Cci.ITypeReference.AsNamespaceTypeReference { get; }
    private INestedTypeReference Microsoft.Cci.ITypeReference.AsNestedTypeReference { get; }
    private ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.AsSpecializedNestedTypeReference { get; }
    private ushort Microsoft.Cci.INamedTypeReference.GenericParameterCount { get; }
    private bool Microsoft.Cci.INamedTypeReference.MangleName { get; }
    private string Microsoft.Cci.INamedEntity.Name { get; }
    private string Microsoft.Cci.INamespaceTypeReference.NamespaceName { get; }
    public string Name { get; }
    public bool IsAbstract { get; }
    public bool IsReferenceType { get; }
    public bool IsSealed { get; }
    public SymbolKind Kind { get; }
    public TypeKind TypeKind { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    public bool IsStatic { get; }
    public bool IsValueType { get; }
    internal bool IsManagedType { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public Symbol ContainingSymbol { get; }
    public Accessibility DeclaredAccessibility { get; }
    private static DynamicTypeSymbol();
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsEnum();
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsValueType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.GetResolvedType(EmitContext context);
    private sealed virtual override PrimitiveTypeCode Microsoft.Cci.ITypeReference.TypeCode(EmitContext context);
    private sealed virtual override TypeDefinitionHandle Microsoft.Cci.ITypeReference.get_TypeDef();
    private sealed virtual override IGenericMethodParameterReference Microsoft.Cci.ITypeReference.get_AsGenericMethodParameterReference();
    private sealed virtual override IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.get_AsGenericTypeInstanceReference();
    private sealed virtual override IGenericTypeParameterReference Microsoft.Cci.ITypeReference.get_AsGenericTypeParameterReference();
    private sealed virtual override INamespaceTypeReference Microsoft.Cci.ITypeReference.get_AsNamespaceTypeReference();
    private sealed virtual override INamespaceTypeDefinition Microsoft.Cci.ITypeReference.AsNamespaceTypeDefinition(EmitContext context);
    private sealed virtual override INestedTypeReference Microsoft.Cci.ITypeReference.get_AsNestedTypeReference();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.ITypeReference.AsNestedTypeDefinition(EmitContext context);
    private sealed virtual override ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.get_AsSpecializedNestedTypeReference();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.AsTypeDefinition(EmitContext context);
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
    private sealed virtual override ushort Microsoft.Cci.INamedTypeReference.get_GenericParameterCount();
    private sealed virtual override bool Microsoft.Cci.INamedTypeReference.get_MangleName();
    private sealed virtual override string Microsoft.Cci.INamedEntity.get_Name();
    private sealed virtual override IUnitReference Microsoft.Cci.INamespaceTypeReference.GetUnit(EmitContext context);
    private sealed virtual override string Microsoft.Cci.INamespaceTypeReference.get_NamespaceName();
    public virtual string get_Name();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsSealed();
    public virtual SymbolKind get_Kind();
    public virtual TypeKind get_TypeKind();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
    internal virtual ImmutableArray`1<NamedTypeSymbol> InterfacesNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
    public virtual bool get_IsStatic();
    public virtual bool get_IsValueType();
    internal sealed virtual bool get_IsManagedType();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    internal virtual TResult Accept(CSharpSymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual void Accept(CSharpSymbolVisitor visitor);
    public virtual TResult Accept(CSharpSymbolVisitor`1<TResult> visitor);
    public virtual Symbol get_ContainingSymbol();
    public virtual Accessibility get_DeclaredAccessibility();
    internal virtual bool GetUnificationUseSiteDiagnosticRecursive(DiagnosticInfo& result, Symbol owner, HashSet`1& checkedTypes);
    public virtual int GetHashCode();
    internal virtual bool Equals(TypeSymbol t2, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.EnumConversions : object {
    [ExtensionAttribute]
internal static TypeKind ToTypeKind(DeclarationKind kind);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.ErrorMethodSymbol : MethodSymbol {
    public static ErrorMethodSymbol UnknownMethod;
    private TypeSymbol _containingType;
    private TypeSymbol _returnType;
    private string _name;
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    public bool IsExtern { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public bool IsOverride { get; }
    public bool IsVirtual { get; }
    public bool IsStatic { get; }
    public bool IsAsync { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Symbol ContainingSymbol { get; }
    internal CallingConvention CallingConvention { get; }
    public Symbol AssociatedSymbol { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    internal int ParameterCount { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public TypeSymbol ReturnType { get; }
    public bool ReturnsVoid { get; }
    public bool IsVararg { get; }
    public bool HidesBaseMethodsByName { get; }
    public bool IsExtensionMethod { get; }
    public int Arity { get; }
    public MethodKind MethodKind { get; }
    internal bool IsMetadataFinal { get; }
    internal bool RequiresSecurityObject { get; }
    internal MarshalPseudoCustomAttributeData ReturnValueMarshallingInformation { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal bool GenerateDebugInfo { get; }
    public ErrorMethodSymbol(TypeSymbol containingType, TypeSymbol returnType, string name);
    private static ErrorMethodSymbol();
    public virtual string get_Name();
    internal sealed virtual bool get_HasSpecialName();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    public virtual bool get_IsExtern();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsOverride();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsStatic();
    public virtual bool get_IsAsync();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual Symbol get_ContainingSymbol();
    internal virtual CallingConvention get_CallingConvention();
    public virtual Symbol get_AssociatedSymbol();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    internal virtual int get_ParameterCount();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual TypeSymbol get_ReturnType();
    public virtual bool get_ReturnsVoid();
    public virtual bool get_IsVararg();
    public virtual bool get_HidesBaseMethodsByName();
    public virtual bool get_IsExtensionMethod();
    public virtual int get_Arity();
    public virtual MethodKind get_MethodKind();
    internal sealed virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal sealed virtual bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_IsMetadataFinal();
    internal sealed virtual bool get_RequiresSecurityObject();
    public sealed virtual DllImportData GetDllImportData();
    internal sealed virtual MarshalPseudoCustomAttributeData get_ReturnValueMarshallingInformation();
    internal sealed virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal sealed virtual bool get_HasDeclarativeSecurity();
    internal sealed virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    internal virtual bool get_GenerateDebugInfo();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.ErrorPropertySymbol : PropertySymbol {
    private Symbol _containingSymbol;
    private TypeSymbol _type;
    private string _name;
    private bool _isIndexer;
    private bool _isIndexedProperty;
    public Symbol ContainingSymbol { get; }
    public TypeSymbol Type { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    public bool IsIndexer { get; }
    public bool IsIndexedProperty { get; }
    public MethodSymbol GetMethod { get; }
    public MethodSymbol SetMethod { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    internal CallingConvention CallingConvention { get; }
    internal bool MustCallMethodsDirectly { get; }
    public ImmutableArray`1<PropertySymbol> ExplicitInterfaceImplementations { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public ErrorPropertySymbol(Symbol containingSymbol, TypeSymbol type, string name, bool isIndexer, bool isIndexedProperty);
    public virtual Symbol get_ContainingSymbol();
    public virtual TypeSymbol get_Type();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    public virtual bool get_IsIndexer();
    public virtual bool get_IsIndexedProperty();
    public virtual MethodSymbol get_GetMethod();
    public virtual MethodSymbol get_SetMethod();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsStatic();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsExtern();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal virtual CallingConvention get_CallingConvention();
    internal virtual bool get_MustCallMethodsDirectly();
    public virtual ImmutableArray`1<PropertySymbol> get_ExplicitInterfaceImplementations();
    public virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol : NamedTypeSymbol {
    internal static ErrorTypeSymbol UnknownResultType;
    private ImmutableArray`1<TypeParameterSymbol> _lazyTypeParameters;
    internal DiagnosticInfo ErrorInfo { get; }
    internal LookupResultKind ResultKind { get; }
    public ImmutableArray`1<Symbol> CandidateSymbols { get; }
    public CandidateReason CandidateReason { get; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public SymbolKind Kind { get; }
    public TypeKind TypeKind { get; }
    internal bool IsInterface { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public int Arity { get; }
    public string Name { get; }
    internal ImmutableArray`1<TypeSymbol> TypeArgumentsNoUseSiteDiagnostics { get; }
    internal bool HasTypeArgumentsCustomModifiers { get; }
    internal ImmutableArray`1<ImmutableArray`1<CustomModifier>> TypeArgumentsCustomModifiers { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public NamedTypeSymbol ConstructedFrom { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    internal bool HasSpecialName { get; }
    public bool MightContainExtensionMethods { get; }
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    internal bool ShouldAddWinRTMembers { get; }
    internal bool IsWindowsRuntimeImport { get; }
    internal TypeLayout Layout { get; }
    internal CharSet MarshallingCharSet { get; }
    internal bool IsSerializable { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal bool IsComImport { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool Unreported { get; }
    private ImmutableArray`1<ISymbol> Microsoft.CodeAnalysis.IErrorTypeSymbol.CandidateSymbols { get; }
    private static ErrorTypeSymbol();
    internal abstract virtual DiagnosticInfo get_ErrorInfo();
    internal virtual LookupResultKind get_ResultKind();
    internal virtual TypeWithModifiers Substitute(AbstractTypeMap typeMap);
    public virtual ImmutableArray`1<Symbol> get_CandidateSymbols();
    public sealed virtual CandidateReason get_CandidateReason();
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsValueType();
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    internal sealed virtual IEnumerable`1<FieldSymbol> GetFieldsToEmit();
    internal virtual ImmutableArray`1<Symbol> GetEarlyAttributeDecodingMembers();
    internal virtual ImmutableArray`1<Symbol> GetEarlyAttributeDecodingMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public sealed virtual SymbolKind get_Kind();
    public sealed virtual TypeKind get_TypeKind();
    internal sealed virtual bool get_IsInterface();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual int get_Arity();
    public virtual string get_Name();
    internal virtual ImmutableArray`1<TypeSymbol> get_TypeArgumentsNoUseSiteDiagnostics();
    internal virtual bool get_HasTypeArgumentsCustomModifiers();
    internal virtual ImmutableArray`1<ImmutableArray`1<CustomModifier>> get_TypeArgumentsCustomModifiers();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    private ImmutableArray`1<TypeParameterSymbol> GetTypeParameters();
    public virtual NamedTypeSymbol get_ConstructedFrom();
    internal virtual TResult Accept(CSharpSymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public sealed virtual Accessibility get_DeclaredAccessibility();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    internal sealed virtual bool get_HasSpecialName();
    public sealed virtual bool get_MightContainExtensionMethods();
    internal virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
    internal virtual ImmutableArray`1<NamedTypeSymbol> InterfacesNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetInterfacesToEmit();
    internal virtual NamedTypeSymbol GetDeclaredBaseType(ConsList`1<Symbol> basesBeingResolved);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved);
    protected virtual NamedTypeSymbol ConstructCore(ImmutableArray`1<TypeWithModifiers> typeArguments, bool unbound);
    internal virtual NamedTypeSymbol AsMember(NamedTypeSymbol newOwner);
    internal sealed virtual bool get_ShouldAddWinRTMembers();
    internal sealed virtual bool get_IsWindowsRuntimeImport();
    internal sealed virtual TypeLayout get_Layout();
    internal virtual CharSet get_MarshallingCharSet();
    internal sealed virtual bool get_IsSerializable();
    internal sealed virtual bool get_HasDeclarativeSecurity();
    internal sealed virtual bool get_IsComImport();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal sealed virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal sealed virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual AttributeUsageInfo GetAttributeUsageInfo();
    internal virtual bool get_Unreported();
    private sealed virtual override ImmutableArray`1<ISymbol> Microsoft.CodeAnalysis.IErrorTypeSymbol.get_CandidateSymbols();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.EvaluatedConstant : object {
    public ConstantValue Value;
    public ImmutableArray`1<Diagnostic> Diagnostics;
    public EvaluatedConstant(ConstantValue value, ImmutableArray`1<Diagnostic> diagnostics);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol : Symbol {
    private IEnumerable`1<IMethodReference> Microsoft.Cci.IEventDefinition.Accessors { get; }
    private IMethodReference Microsoft.Cci.IEventDefinition.Adder { get; }
    private IMethodReference Microsoft.Cci.IEventDefinition.Remover { get; }
    private bool Microsoft.Cci.IEventDefinition.IsRuntimeSpecial { get; }
    internal bool HasRuntimeSpecialName { get; }
    private bool Microsoft.Cci.IEventDefinition.IsSpecialName { get; }
    private IMethodReference Microsoft.Cci.IEventDefinition.Caller { get; }
    private ITypeDefinition Microsoft.Cci.ITypeDefinitionMember.ContainingTypeDefinition { get; }
    private TypeMemberVisibility Microsoft.Cci.ITypeDefinitionMember.Visibility { get; }
    private string Microsoft.Cci.INamedEntity.Name { get; }
    public EventSymbol OriginalDefinition { get; }
    protected Symbol OriginalSymbolDefinition { get; }
    public TypeSymbol Type { get; }
    public MethodSymbol AddMethod { get; }
    public MethodSymbol RemoveMethod { get; }
    internal bool HasAssociatedField { get; }
    public bool IsWindowsRuntimeEvent { get; }
    internal bool HasSpecialName { get; }
    internal FieldSymbol AssociatedField { get; }
    public EventSymbol OverriddenEvent { get; }
    internal OverriddenOrHiddenMembersResult OverriddenOrHiddenMembers { get; }
    internal bool HidesBaseEventsByName { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<EventSymbol> ExplicitInterfaceImplementations { get; }
    public SymbolKind Kind { get; }
    internal bool MustCallMethodsDirectly { get; }
    protected int HighestPriorityUseSiteError { get; }
    public bool HasUnsupportedMetadata { get; }
    private ITypeSymbol Microsoft.CodeAnalysis.IEventSymbol.Type { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.IEventSymbol.AddMethod { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.IEventSymbol.RemoveMethod { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.IEventSymbol.RaiseMethod { get; }
    private IEventSymbol Microsoft.CodeAnalysis.IEventSymbol.OriginalDefinition { get; }
    private IEventSymbol Microsoft.CodeAnalysis.IEventSymbol.OverriddenEvent { get; }
    private ImmutableArray`1<IEventSymbol> Microsoft.CodeAnalysis.IEventSymbol.ExplicitInterfaceImplementations { get; }
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol/<Microsoft-Cci-IEventDefinition-get_Accessors>d__1")]
private sealed virtual override IEnumerable`1<IMethodReference> Microsoft.Cci.IEventDefinition.get_Accessors();
    private sealed virtual override IMethodReference Microsoft.Cci.IEventDefinition.get_Adder();
    private sealed virtual override IMethodReference Microsoft.Cci.IEventDefinition.get_Remover();
    private sealed virtual override bool Microsoft.Cci.IEventDefinition.get_IsRuntimeSpecial();
    internal virtual bool get_HasRuntimeSpecialName();
    private sealed virtual override bool Microsoft.Cci.IEventDefinition.get_IsSpecialName();
    private sealed virtual override IMethodReference Microsoft.Cci.IEventDefinition.get_Caller();
    private sealed virtual override ITypeReference Microsoft.Cci.IEventDefinition.GetType(EmitContext context);
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeDefinitionMember.get_ContainingTypeDefinition();
    private sealed virtual override TypeMemberVisibility Microsoft.Cci.ITypeDefinitionMember.get_Visibility();
    private sealed virtual override ITypeReference Microsoft.Cci.ITypeMemberReference.GetContainingType(EmitContext context);
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
    private sealed virtual override string Microsoft.Cci.INamedEntity.get_Name();
    public virtual EventSymbol get_OriginalDefinition();
    protected sealed virtual Symbol get_OriginalSymbolDefinition();
    public abstract virtual TypeSymbol get_Type();
    public abstract virtual MethodSymbol get_AddMethod();
    public abstract virtual MethodSymbol get_RemoveMethod();
    internal bool get_HasAssociatedField();
    public abstract virtual bool get_IsWindowsRuntimeEvent();
    internal abstract virtual bool get_HasSpecialName();
    public ImmutableArray`1<CSharpAttributeData> GetFieldAttributes();
    internal virtual FieldSymbol get_AssociatedField();
    public EventSymbol get_OverriddenEvent();
    internal virtual OverriddenOrHiddenMembersResult get_OverriddenOrHiddenMembers();
    internal bool get_HidesBaseEventsByName();
    internal EventSymbol GetLeastOverriddenEvent(NamedTypeSymbol accessingTypeOpt);
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public abstract virtual ImmutableArray`1<EventSymbol> get_ExplicitInterfaceImplementations();
    public sealed virtual SymbolKind get_Kind();
    internal virtual TResult Accept(CSharpSymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual void Accept(CSharpSymbolVisitor visitor);
    public virtual TResult Accept(CSharpSymbolVisitor`1<TResult> visitor);
    internal EventSymbol AsMember(NamedTypeSymbol newOwner);
    internal abstract virtual bool get_MustCallMethodsDirectly();
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    internal bool CalculateUseSiteDiagnostic(DiagnosticInfo& result);
    protected virtual int get_HighestPriorityUseSiteError();
    public sealed virtual bool get_HasUnsupportedMetadata();
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.IEventSymbol.get_Type();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.IEventSymbol.get_AddMethod();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.IEventSymbol.get_RemoveMethod();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.IEventSymbol.get_RaiseMethod();
    private sealed virtual override IEventSymbol Microsoft.CodeAnalysis.IEventSymbol.get_OriginalDefinition();
    private sealed virtual override IEventSymbol Microsoft.CodeAnalysis.IEventSymbol.get_OverriddenEvent();
    private sealed virtual override ImmutableArray`1<IEventSymbol> Microsoft.CodeAnalysis.IEventSymbol.get_ExplicitInterfaceImplementations();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public sealed virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbolExtensions : object {
    [ExtensionAttribute]
internal static MethodSymbol GetOwnOrInheritedAccessor(EventSymbol event, bool isAdder);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.ExplicitInterfaceHelpers : object {
    public static string GetMemberName(Binder binder, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifierOpt, string name);
    public static string GetMemberNameAndInterfaceSymbol(Binder binder, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifierOpt, string name, DiagnosticBag diagnostics, TypeSymbol& explicitInterfaceTypeOpt, String& aliasQualifierOpt);
    public static string GetMemberName(string name, TypeSymbol explicitInterfaceTypeOpt, string aliasQualifierOpt);
    [ExtensionAttribute]
public static string GetMethodNameWithoutInterfaceName(MethodSymbol method);
    public static string GetMemberNameWithoutInterfaceName(string fullName);
    public static ImmutableArray`1<T> SubstituteExplicitInterfaceImplementations(ImmutableArray`1<T> unsubstitutedExplicitInterfaceImplementations, TypeMap map);
    [ExtensionAttribute]
internal static MethodSymbol FindExplicitlyImplementedMethod(MethodSymbol implementingMethod, TypeSymbol explicitInterfaceType, string interfaceMethodName, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifierSyntax, DiagnosticBag diagnostics);
    [ExtensionAttribute]
internal static PropertySymbol FindExplicitlyImplementedProperty(PropertySymbol implementingProperty, TypeSymbol explicitInterfaceType, string interfacePropertyName, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifierSyntax, DiagnosticBag diagnostics);
    [ExtensionAttribute]
internal static EventSymbol FindExplicitlyImplementedEvent(EventSymbol implementingEvent, TypeSymbol explicitInterfaceType, string interfaceEventName, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifierSyntax, DiagnosticBag diagnostics);
    private static Symbol FindExplicitlyImplementedMember(Symbol implementingMember, TypeSymbol explicitInterfaceType, string interfaceMemberName, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifierSyntax, DiagnosticBag diagnostics);
    private static void FindExplicitImplementationCollisions(Symbol implementingMember, Symbol implementedMember, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.ExplicitInterfaceMethodTypeParameterMap : OverriddenMethodTypeParameterMapBase {
    public ExplicitInterfaceMethodTypeParameterMap(SourceMemberMethodSymbol implementationMethod);
    protected virtual MethodSymbol GetOverriddenMethod(SourceMemberMethodSymbol overridingMethod);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.ExtendedErrorTypeSymbol : ErrorTypeSymbol {
    private string _name;
    private int _arity;
    private DiagnosticInfo _errorInfo;
    private NamespaceOrTypeSymbol _containingSymbol;
    private bool _unreported;
    public bool VariableUsedBeforeDeclaration;
    private ImmutableArray`1<Symbol> _candidateSymbols;
    private LookupResultKind _resultKind;
    internal DiagnosticInfo ErrorInfo { get; }
    internal LookupResultKind ResultKind { get; }
    public ImmutableArray`1<Symbol> CandidateSymbols { get; }
    internal bool Unreported { get; }
    public int Arity { get; }
    internal bool MangleName { get; }
    public Symbol ContainingSymbol { get; }
    public string Name { get; }
    public NamedTypeSymbol OriginalDefinition { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public NamedTypeSymbol ConstructedFrom { get; }
    internal ExtendedErrorTypeSymbol(CSharpCompilation compilation, string name, int arity, DiagnosticInfo errorInfo, bool unreported, bool variableUsedBeforeDeclaration);
    internal ExtendedErrorTypeSymbol(NamespaceOrTypeSymbol containingSymbol, string name, int arity, DiagnosticInfo errorInfo, bool unreported, bool variableUsedBeforeDeclaration);
    private ExtendedErrorTypeSymbol(NamespaceOrTypeSymbol containingSymbol, string name, int arity, DiagnosticInfo errorInfo, bool unreported, bool variableUsedBeforeDeclaration, ImmutableArray`1<Symbol> candidateSymbols, LookupResultKind resultKind);
    internal ExtendedErrorTypeSymbol(NamespaceOrTypeSymbol guessSymbol, LookupResultKind resultKind, DiagnosticInfo errorInfo, bool unreported);
    internal ExtendedErrorTypeSymbol(NamespaceOrTypeSymbol containingSymbol, Symbol guessSymbol, LookupResultKind resultKind, DiagnosticInfo errorInfo, bool unreported);
    internal ExtendedErrorTypeSymbol(NamespaceOrTypeSymbol containingSymbol, ImmutableArray`1<Symbol> candidateSymbols, LookupResultKind resultKind, DiagnosticInfo errorInfo, int arity, bool unreported);
    internal ExtendedErrorTypeSymbol AsUnreported();
    private static ImmutableArray`1<Symbol> UnwrapErrorCandidates(ImmutableArray`1<Symbol> candidateSymbols);
    internal virtual DiagnosticInfo get_ErrorInfo();
    internal virtual LookupResultKind get_ResultKind();
    public virtual ImmutableArray`1<Symbol> get_CandidateSymbols();
    internal virtual bool get_Unreported();
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    public virtual int get_Arity();
    internal virtual bool get_MangleName();
    public virtual Symbol get_ContainingSymbol();
    public virtual string get_Name();
    public virtual NamedTypeSymbol get_OriginalDefinition();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual NamedTypeSymbol get_ConstructedFrom();
    internal virtual NamedTypeSymbol GetDeclaredBaseType(ConsList`1<Symbol> basesBeingResolved);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved);
    internal static TypeSymbol ExtractNonErrorType(TypeSymbol oldSymbol);
    internal static TypeKind ExtractNonErrorTypeKind(TypeSymbol oldSymbol);
    internal virtual bool Equals(TypeSymbol t2, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
    public virtual int GetHashCode();
    private static int GetArity(Symbol symbol);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.FieldOrPropertyInitializer : ValueType {
    internal FieldSymbol FieldOpt;
    internal SyntaxReference Syntax;
    internal int PrecedingInitializersLength;
    public FieldOrPropertyInitializer(FieldSymbol fieldOpt, SyntaxNode syntax, int precedingInitializersLength);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol : Symbol {
    private ISpecializedFieldReference Microsoft.Cci.IFieldReference.AsSpecializedFieldReference { get; }
    private string Microsoft.Cci.INamedEntity.Name { get; }
    private bool Microsoft.Cci.IFieldReference.IsContextualNamedEntity { get; }
    private ImmutableArray`1<byte> Microsoft.Cci.IFieldDefinition.MappedData { get; }
    private bool Microsoft.Cci.IFieldDefinition.IsCompileTimeConstant { get; }
    private bool Microsoft.Cci.IFieldDefinition.IsNotSerialized { get; }
    private bool Microsoft.Cci.IFieldDefinition.IsReadOnly { get; }
    private bool Microsoft.Cci.IFieldDefinition.IsRuntimeSpecial { get; }
    private bool Microsoft.Cci.IFieldDefinition.IsSpecialName { get; }
    private bool Microsoft.Cci.IFieldDefinition.IsStatic { get; }
    private bool Microsoft.Cci.IFieldDefinition.IsMarshalledExplicitly { get; }
    internal bool IsMarshalledExplicitly { get; }
    private IMarshallingInformation Microsoft.Cci.IFieldDefinition.MarshallingInformation { get; }
    private ImmutableArray`1<byte> Microsoft.Cci.IFieldDefinition.MarshallingDescriptor { get; }
    internal ImmutableArray`1<byte> MarshallingDescriptor { get; }
    private UInt32 Microsoft.Cci.IFieldDefinition.Offset { get; }
    private ITypeDefinition Microsoft.Cci.ITypeDefinitionMember.ContainingTypeDefinition { get; }
    private TypeMemberVisibility Microsoft.Cci.ITypeDefinitionMember.Visibility { get; }
    private IFieldReference Microsoft.Cci.ISpecializedFieldReference.UnspecializedVersion { get; }
    public FieldSymbol OriginalDefinition { get; }
    protected Symbol OriginalSymbolDefinition { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public Symbol AssociatedSymbol { get; }
    public bool IsReadOnly { get; }
    public bool IsVolatile { get; }
    public bool IsFixed { get; }
    public int FixedSize { get; }
    internal bool IsCapturedFrame { get; }
    public bool IsConst { get; }
    public bool IsMetadataConstant { get; }
    public bool HasConstantValue { get; }
    public object ConstantValue { get; }
    public SymbolKind Kind { get; }
    public bool IsAbstract { get; }
    public bool IsExtern { get; }
    public bool IsOverride { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    internal bool HasSpecialName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal bool IsNotSerialized { get; }
    internal bool HasPointerType { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal UnmanagedType MarshallingType { get; }
    internal Nullable`1<int> TypeLayoutOffset { get; }
    protected int HighestPriorityUseSiteError { get; }
    public bool HasUnsupportedMetadata { get; }
    private ISymbol Microsoft.CodeAnalysis.IFieldSymbol.AssociatedSymbol { get; }
    private ITypeSymbol Microsoft.CodeAnalysis.IFieldSymbol.Type { get; }
    private ImmutableArray`1<CustomModifier> Microsoft.CodeAnalysis.IFieldSymbol.CustomModifiers { get; }
    private IFieldSymbol Microsoft.CodeAnalysis.IFieldSymbol.OriginalDefinition { get; }
    private sealed virtual override ITypeReference Microsoft.Cci.IFieldReference.GetType(EmitContext context);
    private sealed virtual override IFieldDefinition Microsoft.Cci.IFieldReference.GetResolvedField(EmitContext context);
    private IFieldDefinition ResolvedFieldImpl(PEModuleBuilder moduleBeingBuilt);
    private sealed virtual override ISpecializedFieldReference Microsoft.Cci.IFieldReference.get_AsSpecializedFieldReference();
    private sealed virtual override ITypeReference Microsoft.Cci.ITypeMemberReference.GetContainingType(EmitContext context);
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
    private sealed virtual override string Microsoft.Cci.INamedEntity.get_Name();
    private sealed virtual override bool Microsoft.Cci.IFieldReference.get_IsContextualNamedEntity();
    private sealed virtual override IMetadataConstant Microsoft.Cci.IFieldDefinition.GetCompileTimeValue(EmitContext context);
    internal IMetadataConstant GetMetadataConstantValue(EmitContext context);
    private sealed virtual override ImmutableArray`1<byte> Microsoft.Cci.IFieldDefinition.get_MappedData();
    private sealed virtual override bool Microsoft.Cci.IFieldDefinition.get_IsCompileTimeConstant();
    private sealed virtual override bool Microsoft.Cci.IFieldDefinition.get_IsNotSerialized();
    private sealed virtual override bool Microsoft.Cci.IFieldDefinition.get_IsReadOnly();
    private sealed virtual override bool Microsoft.Cci.IFieldDefinition.get_IsRuntimeSpecial();
    private sealed virtual override bool Microsoft.Cci.IFieldDefinition.get_IsSpecialName();
    private sealed virtual override bool Microsoft.Cci.IFieldDefinition.get_IsStatic();
    private sealed virtual override bool Microsoft.Cci.IFieldDefinition.get_IsMarshalledExplicitly();
    internal virtual bool get_IsMarshalledExplicitly();
    private sealed virtual override IMarshallingInformation Microsoft.Cci.IFieldDefinition.get_MarshallingInformation();
    private sealed virtual override ImmutableArray`1<byte> Microsoft.Cci.IFieldDefinition.get_MarshallingDescriptor();
    internal virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    private sealed virtual override UInt32 Microsoft.Cci.IFieldDefinition.get_Offset();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeDefinitionMember.get_ContainingTypeDefinition();
    private sealed virtual override TypeMemberVisibility Microsoft.Cci.ITypeDefinitionMember.get_Visibility();
    private sealed virtual override IFieldReference Microsoft.Cci.ISpecializedFieldReference.get_UnspecializedVersion();
    public virtual FieldSymbol get_OriginalDefinition();
    protected sealed virtual Symbol get_OriginalSymbolDefinition();
    public TypeSymbol get_Type();
    internal abstract virtual TypeSymbol GetFieldType(ConsList`1<FieldSymbol> fieldsBeingBound);
    public abstract virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public abstract virtual Symbol get_AssociatedSymbol();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsVolatile();
    public virtual bool get_IsFixed();
    public virtual int get_FixedSize();
    internal virtual NamedTypeSymbol FixedImplementationType(PEModuleBuilder emitModule);
    internal virtual bool get_IsCapturedFrame();
    public abstract virtual bool get_IsConst();
    public bool get_IsMetadataConstant();
    public virtual bool get_HasConstantValue();
    public virtual object get_ConstantValue();
    internal abstract virtual ConstantValue GetConstantValue(ConstantFieldsInProgress inProgress, bool earlyDecodingWellKnownAttributes);
    public sealed virtual SymbolKind get_Kind();
    internal virtual TResult Accept(CSharpSymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual void Accept(CSharpSymbolVisitor visitor);
    public virtual TResult Accept(CSharpSymbolVisitor`1<TResult> visitor);
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    internal abstract virtual bool get_HasSpecialName();
    internal abstract virtual bool get_HasRuntimeSpecialName();
    internal abstract virtual bool get_IsNotSerialized();
    internal virtual bool get_HasPointerType();
    internal abstract virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual UnmanagedType get_MarshallingType();
    internal abstract virtual Nullable`1<int> get_TypeLayoutOffset();
    internal FieldSymbol AsMember(NamedTypeSymbol newOwner);
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    internal bool CalculateUseSiteDiagnostic(DiagnosticInfo& result);
    protected virtual int get_HighestPriorityUseSiteError();
    public sealed virtual bool get_HasUnsupportedMetadata();
    private sealed virtual override ISymbol Microsoft.CodeAnalysis.IFieldSymbol.get_AssociatedSymbol();
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.IFieldSymbol.get_Type();
    private sealed virtual override ImmutableArray`1<CustomModifier> Microsoft.CodeAnalysis.IFieldSymbol.get_CustomModifiers();
    private sealed virtual override IFieldSymbol Microsoft.CodeAnalysis.IFieldSymbol.get_OriginalDefinition();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.FixedFieldImplementationType : SynthesizedContainer {
    internal static string FixedElementFieldName;
    private SourceMemberFieldSymbol _field;
    private MethodSymbol _constructor;
    private FieldSymbol _internalField;
    public Symbol ContainingSymbol { get; }
    public TypeKind TypeKind { get; }
    internal MethodSymbol Constructor { get; }
    internal TypeLayout Layout { get; }
    internal CharSet MarshallingCharSet { get; }
    internal FieldSymbol FixedElementField { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public Accessibility DeclaredAccessibility { get; }
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    public FixedFieldImplementationType(SourceMemberFieldSymbol field);
    public virtual Symbol get_ContainingSymbol();
    public virtual TypeKind get_TypeKind();
    internal virtual MethodSymbol get_Constructor();
    internal virtual TypeLayout get_Layout();
    internal virtual CharSet get_MarshallingCharSet();
    internal virtual FieldSymbol get_FixedElementField();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    public virtual Accessibility get_DeclaredAccessibility();
    internal virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.GeneratedLabelSymbol : LabelSymbol {
    private string _name;
    public string Name { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsImplicitlyDeclared { get; }
    public GeneratedLabelSymbol(string name);
    public virtual string get_Name();
    private static string LabelName(string name);
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool get_IsImplicitlyDeclared();
}
internal enum Microsoft.CodeAnalysis.CSharp.Symbols.GeneratedNameKind : Enum {
    public int value__;
    public static GeneratedNameKind None;
    public static GeneratedNameKind ThisProxyField;
    public static GeneratedNameKind HoistedLocalField;
    public static GeneratedNameKind DisplayClassLocalOrField;
    public static GeneratedNameKind LambdaMethod;
    public static GeneratedNameKind LambdaDisplayClass;
    public static GeneratedNameKind StateMachineType;
    public static GeneratedNameKind AwaiterField;
    public static GeneratedNameKind HoistedSynthesizedLocalField;
    public static GeneratedNameKind StateMachineStateField;
    public static GeneratedNameKind IteratorCurrentBackingField;
    public static GeneratedNameKind StateMachineParameterProxyField;
    public static GeneratedNameKind ReusableHoistedLocalField;
    public static GeneratedNameKind LambdaCacheField;
    public static GeneratedNameKind FixedBufferField;
    public static GeneratedNameKind AnonymousType;
    public static GeneratedNameKind TransparentIdentifier;
    public static GeneratedNameKind AnonymousTypeField;
    public static GeneratedNameKind AutoPropertyBackingField;
    public static GeneratedNameKind IteratorCurrentThreadIdField;
    public static GeneratedNameKind IteratorFinallyMethod;
    public static GeneratedNameKind BaseMethodWrapper;
    public static GeneratedNameKind AsyncBuilderField;
    public static GeneratedNameKind DynamicCallSiteContainerType;
    public static GeneratedNameKind DynamicCallSiteField;
    [ObsoleteAttribute]
public static GeneratedNameKind Deprecated_OuterscopeLocals;
    [ObsoleteAttribute]
public static GeneratedNameKind Deprecated_IteratorInstance;
    [ObsoleteAttribute]
public static GeneratedNameKind Deprecated_InitializerLocal;
    [ObsoleteAttribute]
public static GeneratedNameKind Deprecated_AnonymousTypeTypeParameter;
    [ObsoleteAttribute]
public static GeneratedNameKind Deprecated_DynamicDelegate;
    [ObsoleteAttribute]
public static GeneratedNameKind Deprecated_ComrefCallLocal;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.GeneratedNameKindExtensions : object {
    [ExtensionAttribute]
internal static bool IsTypeName(GeneratedNameKind kind);
}
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.GeneratedNames : object {
    internal static string SynthesizedLocalNamePrefix;
    internal static char DotReplacementInTypeNames;
    private static string SuffixSeparator;
    private static char IdSeparator;
    private static char GenerationSeparator;
    internal static string AnonymousNamePrefix;
    internal static bool IsGeneratedMemberName(string memberName);
    internal static string MakeBackingFieldName(string propertyName);
    internal static string MakeIteratorFinallyMethodName(int iteratorState);
    internal static string MakeStaticLambdaDisplayClassName(int methodOrdinal, int generation);
    internal static string MakeLambdaDisplayClassName(int methodOrdinal, int generation, int closureOrdinal, int closureGeneration);
    internal static string MakeAnonymousTypeTemplateName(int index, int submissionSlotIndex, string moduleId);
    internal static bool TryParseAnonymousTypeTemplateName(string name, Int32& index);
    internal static string MakeAnonymousTypeBackingFieldName(string propertyName);
    internal static string MakeAnonymousTypeParameterName(string propertyName);
    internal static bool TryParseAnonymousTypeParameterName(string typeParameterName, String& propertyName);
    internal static string MakeStateMachineTypeName(string methodName, int methodOrdinal, int generation);
    internal static string MakeBaseMethodWrapperName(int uniqueId);
    internal static string MakeLambdaMethodName(string methodName, int methodOrdinal, int methodGeneration, int lambdaOrdinal, int lambdaGeneration);
    internal static string MakeLambdaCacheFieldName(int methodOrdinal, int generation, int lambdaOrdinal, int lambdaGeneration);
    private static string MakeMethodScopedSynthesizedName(GeneratedNameKind kind, int methodOrdinal, int methodGeneration, string methodNameOpt, string suffix, int entityOrdinal, int entityGeneration, bool isTypeName);
    private static void AppendOptionalGeneration(StringBuilder builder, int generation);
    internal static string MakeHoistedLocalFieldName(SynthesizedLocalKind kind, int slotIndex, string localNameOpt);
    internal static GeneratedNameKind GetKind(string name);
    internal static bool TryParseGeneratedName(string name, GeneratedNameKind& kind, Int32& openBracketOffset, Int32& closeBracketOffset);
    internal static bool TryParseSourceMethodNameFromGeneratedName(string generatedName, GeneratedNameKind requiredKind, String& methodName);
    internal static string AsyncAwaiterFieldName(int slotIndex);
    internal static bool TryParseSlotIndex(string fieldName, Int32& slotIndex);
    internal static string MakeCachedFrameInstanceFieldName();
    internal static string MakeSynthesizedLocalName(SynthesizedLocalKind kind, Int32& uniqueId);
    internal static string MakeLambdaDisplayLocalName(int uniqueId);
    internal static bool IsSynthesizedLocalName(string name);
    internal static string MakeFixedFieldImplementationName(string fieldName);
    internal static string MakeStateMachineStateFieldName();
    internal static string MakeIteratorCurrentFieldName();
    internal static string MakeIteratorCurrentThreadIdFieldName();
    internal static string ThisProxyFieldName();
    internal static string StateMachineThisParameterProxyName();
    internal static string StateMachineParameterProxyFieldName(string parameterName);
    internal static string MakeDynamicCallSiteContainerName(int methodOrdinal, int generation);
    internal static string MakeDynamicCallSiteFieldName(int uniqueId);
    internal static string MakeDynamicCallSiteDelegateName(BitVector byRefs, bool returnsVoid, int generation);
    internal static string AsyncBuilderFieldName();
    internal static string ReusableHoistedLocalFieldName(int number);
    internal static string LambdaCopyParameterName(ParameterSymbol sourceParameter);
}
internal interface Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol {
    public IAttributeTargetSymbol AttributesOwner { get; }
    public AttributeLocation AllowedAttributeLocations { get; }
    public AttributeLocation DefaultAttributeLocation { get; }
    public abstract virtual IAttributeTargetSymbol get_AttributesOwner();
    public abstract virtual AttributeLocation get_AllowedAttributeLocations();
    public abstract virtual AttributeLocation get_DefaultAttributeLocation();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.ImplicitNamedTypeSymbol : SourceMemberContainerTypeSymbol {
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    internal ImmutableArray`1<TypeSymbol> TypeArgumentsNoUseSiteDiagnostics { get; }
    internal bool HasTypeArgumentsCustomModifiers { get; }
    internal ImmutableArray`1<ImmutableArray`1<CustomModifier>> TypeArgumentsCustomModifiers { get; }
    internal bool IsComImport { get; }
    internal NamedTypeSymbol ComImportCoClass { get; }
    internal bool HasSpecialName { get; }
    internal bool ShouldAddWinRTMembers { get; }
    internal bool IsWindowsRuntimeImport { get; }
    internal bool IsSerializable { get; }
    internal TypeLayout Layout { get; }
    internal bool HasStructLayoutAttribute { get; }
    internal CharSet MarshallingCharSet { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal ImplicitNamedTypeSymbol(NamespaceOrTypeSymbol containingSymbol, MergedTypeDeclaration declaration, DiagnosticBag diagnostics);
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal virtual AttributeUsageInfo GetAttributeUsageInfo();
    protected virtual Location GetCorrespondingBaseListLocation(NamedTypeSymbol base);
    internal virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
    protected virtual void CheckBase(DiagnosticBag diagnostics);
    internal virtual NamedTypeSymbol GetDeclaredBaseType(ConsList`1<Symbol> basesBeingResolved);
    internal virtual ImmutableArray`1<NamedTypeSymbol> InterfacesNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved);
    protected virtual void CheckInterfaces(DiagnosticBag diagnostics);
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal virtual ImmutableArray`1<TypeSymbol> get_TypeArgumentsNoUseSiteDiagnostics();
    internal virtual bool get_HasTypeArgumentsCustomModifiers();
    internal virtual ImmutableArray`1<ImmutableArray`1<CustomModifier>> get_TypeArgumentsCustomModifiers();
    internal virtual bool get_IsComImport();
    internal virtual NamedTypeSymbol get_ComImportCoClass();
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_ShouldAddWinRTMembers();
    internal sealed virtual bool get_IsWindowsRuntimeImport();
    internal sealed virtual bool get_IsSerializable();
    internal sealed virtual TypeLayout get_Layout();
    internal bool get_HasStructLayoutAttribute();
    internal virtual CharSet get_MarshallingCharSet();
    internal sealed virtual bool get_HasDeclarativeSecurity();
    internal sealed virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.IndexedTypeParameterSymbol : TypeParameterSymbol {
    private static TypeParameterSymbol[] s_parameterPool;
    private int _index;
    public TypeParameterKind TypeParameterKind { get; }
    public int Ordinal { get; }
    public VarianceKind Variance { get; }
    public bool HasValueTypeConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasConstructorConstraint { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsImplicitlyDeclared { get; }
    private IndexedTypeParameterSymbol(int index);
    private static IndexedTypeParameterSymbol();
    public virtual TypeParameterKind get_TypeParameterKind();
    internal static TypeParameterSymbol GetTypeParameter(int index);
    private static void GrowPool(int count);
    internal static ImmutableArray`1<TypeParameterSymbol> Take(int count);
    public virtual int get_Ordinal();
    internal virtual bool Equals(TypeSymbol t2, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
    public virtual int GetHashCode();
    public virtual VarianceKind get_Variance();
    public virtual bool get_HasValueTypeConstraint();
    public virtual bool get_HasReferenceTypeConstraint();
    public virtual bool get_HasConstructorConstraint();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual void EnsureAllConstraintsAreResolved();
    internal virtual ImmutableArray`1<TypeSymbol> GetConstraintTypes(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetInterfaces(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual NamedTypeSymbol GetEffectiveBaseClass(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual TypeSymbol GetDeducedBaseType(ConsList`1<TypeParameterSymbol> inProgress);
    public virtual bool get_IsImplicitlyDeclared();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol : Symbol {
    public bool IsExtern { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public bool IsOverride { get; }
    public bool IsVirtual { get; }
    public bool IsStatic { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<Location> Locations { get; }
    internal SyntaxNodeOrToken IdentifierNodeOrToken { get; }
    public MethodSymbol ContainingMethod { get; }
    public Symbol ContainingSymbol { get; }
    public SymbolKind Kind { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.ILabelSymbol.ContainingMethod { get; }
    public virtual bool get_IsExtern();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsOverride();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsStatic();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<Location> get_Locations();
    internal virtual SyntaxNodeOrToken get_IdentifierNodeOrToken();
    internal virtual TResult Accept(CSharpSymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual void Accept(CSharpSymbolVisitor visitor);
    public virtual TResult Accept(CSharpSymbolVisitor`1<TResult> visitor);
    public virtual MethodSymbol get_ContainingMethod();
    public virtual Symbol get_ContainingSymbol();
    public virtual SymbolKind get_Kind();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.ILabelSymbol.get_ContainingMethod();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.LambdaSymbol : MethodSymbol {
    private Symbol _containingSymbol;
    private MessageID _messageID;
    private CSharpSyntaxNode _syntax;
    private ImmutableArray`1<ParameterSymbol> _parameters;
    private TypeSymbol _returnType;
    private bool _isSynthesized;
    private bool _isAsync;
    public MessageID MessageID { get; }
    public MethodKind MethodKind { get; }
    public bool IsExtern { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsAsync { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool IsMetadataFinal { get; }
    public bool IsVararg { get; }
    internal bool HasSpecialName { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool RequiresSecurityObject { get; }
    internal MarshalPseudoCustomAttributeData ReturnValueMarshallingInformation { get; }
    internal bool HasDeclarativeSecurity { get; }
    public bool ReturnsVoid { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public Symbol AssociatedSymbol { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public int Arity { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Symbol ContainingSymbol { get; }
    internal CallingConvention CallingConvention { get; }
    public bool IsExtensionMethod { get; }
    public bool HidesBaseMethodsByName { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool GenerateDebugInfo { get; }
    public LambdaSymbol(CSharpCompilation compilation, Symbol containingSymbol, UnboundLambda unboundLambda, ImmutableArray`1<ParameterSymbol> delegateParameters, TypeSymbol returnType);
    public LambdaSymbol(Symbol containingSymbol, ImmutableArray`1<ParameterSymbol> parameters, TypeSymbol returnType, MessageID messageID, CSharpSyntaxNode syntax, bool isSynthesized, bool isAsync);
    internal LambdaSymbol ToContainer(Symbol containingSymbol);
    public MessageID get_MessageID();
    public virtual MethodKind get_MethodKind();
    public virtual bool get_IsExtern();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsStatic();
    public virtual bool get_IsAsync();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal sealed virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal sealed virtual bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_IsMetadataFinal();
    public virtual bool get_IsVararg();
    internal virtual bool get_HasSpecialName();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    internal virtual bool get_RequiresSecurityObject();
    public virtual DllImportData GetDllImportData();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnValueMarshallingInformation();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    public virtual bool get_ReturnsVoid();
    public virtual TypeSymbol get_ReturnType();
    internal void SetInferredReturnType(TypeSymbol inferredReturnType);
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual Symbol get_AssociatedSymbol();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual int get_Arity();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal virtual bool TryGetThisParameter(ParameterSymbol& thisParameter);
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual Symbol get_ContainingSymbol();
    internal virtual CallingConvention get_CallingConvention();
    public virtual bool get_IsExtensionMethod();
    public virtual bool get_HidesBaseMethodsByName();
    private ImmutableArray`1<ParameterSymbol> MakeParameters(CSharpCompilation compilation, UnboundLambda unboundLambda, ImmutableArray`1<ParameterSymbol> delegateParameters);
    private static ParameterSymbol CopyParameter(ParameterSymbol parameter, MethodSymbol owner);
    public sealed virtual bool Equals(object symbol);
    public virtual int GetHashCode();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual bool get_GenerateDebugInfo();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.LexicalSortKey : ValueType {
    private int _treeOrdinal;
    private int _position;
    public static LexicalSortKey NotInSource;
    public static LexicalSortKey NotInitialized;
    public static LexicalSortKey SynthesizedCtor;
    public static LexicalSortKey SynthesizedCCtor;
    public int TreeOrdinal { get; }
    public int Position { get; }
    public bool IsInitialized { get; }
    private LexicalSortKey(int treeOrdinal, int position);
    private LexicalSortKey(SyntaxTree tree, int position, CSharpCompilation compilation);
    public LexicalSortKey(SyntaxReference syntaxRef, CSharpCompilation compilation);
    public LexicalSortKey(Location location, CSharpCompilation compilation);
    public LexicalSortKey(CSharpSyntaxNode node, CSharpCompilation compilation);
    public LexicalSortKey(SyntaxToken token, CSharpCompilation compilation);
    private static LexicalSortKey();
    public int get_TreeOrdinal();
    public int get_Position();
    public static int Compare(LexicalSortKey xSortKey, LexicalSortKey ySortKey);
    public static LexicalSortKey First(LexicalSortKey xSortKey, LexicalSortKey ySortKey);
    public bool get_IsInitialized();
    public void SetFrom(LexicalSortKey other);
}
internal enum Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind : Enum {
    public byte value__;
    public static LocalDeclarationKind None;
    public static LocalDeclarationKind RegularVariable;
    public static LocalDeclarationKind Constant;
    public static LocalDeclarationKind FixedVariable;
    public static LocalDeclarationKind UsingVariable;
    public static LocalDeclarationKind CatchVariable;
    public static LocalDeclarationKind ForInitializerVariable;
    public static LocalDeclarationKind ForEachIterationVariable;
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol : Symbol {
    internal LocalDeclarationKind DeclarationKind { get; }
    internal SynthesizedLocalKind SynthesizedKind { get; }
    internal bool IsImportedFromMetadata { get; }
    internal bool CanScheduleToStack { get; }
    internal SyntaxToken IdentifierToken { get; }
    public TypeSymbol Type { get; }
    internal bool IsPinned { get; }
    public bool IsExtern { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public bool IsOverride { get; }
    public bool IsVirtual { get; }
    public bool IsStatic { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public Accessibility DeclaredAccessibility { get; }
    public SymbolKind Kind { get; }
    public bool IsCatch { get; }
    public bool IsConst { get; }
    public bool IsUsing { get; }
    public bool IsFixed { get; }
    public bool IsFor { get; }
    public bool IsForEach { get; }
    internal bool IsWritable { get; }
    public bool HasConstantValue { get; }
    public object ConstantValue { get; }
    internal bool IsCompilerGenerated { get; }
    internal RefKind RefKind { get; }
    private ITypeSymbol Microsoft.CodeAnalysis.ILocalSymbol.Type { get; }
    private bool Microsoft.CodeAnalysis.ILocalSymbol.IsFunctionValue { get; }
    private SynthesizedLocalKind Microsoft.CodeAnalysis.ILocalSymbolInternal.SynthesizedKind { get; }
    private bool Microsoft.CodeAnalysis.ILocalSymbolInternal.IsImportedFromMetadata { get; }
    internal abstract virtual LocalDeclarationKind get_DeclarationKind();
    internal abstract virtual SynthesizedLocalKind get_SynthesizedKind();
    internal abstract virtual LocalSymbol WithSynthesizedLocalKindAndSyntax(SynthesizedLocalKind kind, SyntaxNode syntax);
    internal abstract virtual bool get_IsImportedFromMetadata();
    internal virtual bool get_CanScheduleToStack();
    internal abstract virtual SyntaxToken get_IdentifierToken();
    public abstract virtual TypeSymbol get_Type();
    internal abstract virtual bool get_IsPinned();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsStatic();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public sealed virtual Accessibility get_DeclaredAccessibility();
    public sealed virtual SymbolKind get_Kind();
    internal sealed virtual TResult Accept(CSharpSymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public sealed virtual void Accept(CSharpSymbolVisitor visitor);
    public sealed virtual TResult Accept(CSharpSymbolVisitor`1<TResult> visitor);
    public bool get_IsCatch();
    public sealed virtual bool get_IsConst();
    public bool get_IsUsing();
    public bool get_IsFixed();
    public bool get_IsFor();
    public bool get_IsForEach();
    internal abstract virtual SyntaxNode GetDeclaratorSyntax();
    internal virtual bool get_IsWritable();
    public sealed virtual bool get_HasConstantValue();
    public sealed virtual object get_ConstantValue();
    internal abstract virtual bool get_IsCompilerGenerated();
    internal abstract virtual ConstantValue GetConstantValue(SyntaxNode node, LocalSymbol inProgress, DiagnosticBag diagnostics);
    internal abstract virtual ImmutableArray`1<Diagnostic> GetConstantValueDiagnostics(BoundExpression boundInitValue);
    internal abstract virtual RefKind get_RefKind();
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.ILocalSymbol.get_Type();
    private sealed virtual override bool Microsoft.CodeAnalysis.ILocalSymbol.get_IsFunctionValue();
    public sealed virtual void Accept(SymbolVisitor visitor);
    public sealed virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    private sealed virtual override SynthesizedLocalKind Microsoft.CodeAnalysis.ILocalSymbolInternal.get_SynthesizedKind();
    private sealed virtual override bool Microsoft.CodeAnalysis.ILocalSymbolInternal.get_IsImportedFromMetadata();
    private sealed virtual override SyntaxNode Microsoft.CodeAnalysis.ILocalSymbolInternal.GetDeclaratorSyntax();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer : object {
    public static MemberSignatureComparer ExplicitImplementationComparer;
    public static MemberSignatureComparer CSharpImplicitImplementationComparer;
    public static MemberSignatureComparer CSharpCloseImplicitImplementationComparer;
    public static MemberSignatureComparer DuplicateSourceComparer;
    public static MemberSignatureComparer CSharpOverrideComparer;
    public static MemberSignatureComparer CSharpAccessorOverrideComparer;
    public static MemberSignatureComparer CSharpCustomModifierOverrideComparer;
    internal static MemberSignatureComparer SloppyOverrideComparer;
    public static MemberSignatureComparer RuntimeSignatureComparer;
    public static MemberSignatureComparer RuntimePlusRefOutSignatureComparer;
    public static MemberSignatureComparer RuntimeImplicitImplementationComparer;
    public static MemberSignatureComparer CSharpSignatureAndConstraintsAndReturnTypeComparer;
    public static MemberSignatureComparer RetargetedExplicitImplementationComparer;
    public static MemberSignatureComparer CrefComparer;
    public static MemberSignatureComparer LambdaReturnInferenceCacheComparer;
    private bool _considerName;
    private bool _considerExplicitlyImplementedInterfaces;
    private bool _considerReturnType;
    private bool _considerTypeConstraints;
    private bool _considerCallingConvention;
    private bool _considerRefOutDifference;
    private bool _considerCustomModifiers;
    private bool _ignoreDynamic;
    private MemberSignatureComparer(bool considerName, bool considerExplicitlyImplementedInterfaces, bool considerReturnType, bool considerTypeConstraints, bool considerCallingConvention, bool considerRefOutDifference, bool considerCustomModifiers, bool ignoreDynamic);
    private static MemberSignatureComparer();
    public sealed virtual bool Equals(Symbol member1, Symbol member2);
    public sealed virtual int GetHashCode(Symbol member);
    public static bool HaveSameReturnTypes(MethodSymbol member1, MethodSymbol member2, bool considerCustomModifiers);
    private static bool HaveSameReturnTypes(Symbol member1, TypeMap typeMap1, Symbol member2, TypeMap typeMap2, bool considerCustomModifiers, bool ignoreDynamic);
    private static TypeMap GetTypeMap(Symbol member);
    private static bool HaveSameConstraints(Symbol member1, TypeMap typeMap1, Symbol member2, TypeMap typeMap2);
    public static bool HaveSameConstraints(ImmutableArray`1<TypeParameterSymbol> typeParameters1, TypeMap typeMap1, ImmutableArray`1<TypeParameterSymbol> typeParameters2, TypeMap typeMap2);
    public static bool HaveSameConstraints(TypeParameterSymbol typeParameter1, TypeMap typeMap1, TypeParameterSymbol typeParameter2, TypeMap typeMap2);
    private static bool AreConstraintTypesSubset(HashSet`1<TypeSymbol> constraintTypes1, HashSet`1<TypeSymbol> constraintTypes2, TypeParameterSymbol typeParameter2);
    private static void SubstituteConstraintTypes(ImmutableArray`1<TypeSymbol> types, TypeMap typeMap, HashSet`1<TypeSymbol> result);
    private static bool HaveSameParameterTypes(ImmutableArray`1<ParameterSymbol> params1, TypeMap typeMap1, ImmutableArray`1<ParameterSymbol> params2, TypeMap typeMap2, bool considerRefOutDifference, bool considerCustomModifiers, bool ignoreDynamic);
    private static TypeWithModifiers SubstituteType(TypeMap typeMap, TypeWithModifiers typeSymbol);
    private static CallingConvention GetCallingConvention(Symbol member);
    private static bool IsVarargMethod(Symbol member);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.MergedNamespaceSymbol : NamespaceSymbol {
    private NamespaceExtent _extent;
    private ImmutableArray`1<NamespaceSymbol> _namespacesToMerge;
    private NamespaceSymbol _containingNamespace;
    private string _nameOpt;
    private CachingDictionary`2<string, Symbol> _cachedLookup;
    private ImmutableArray`1<Symbol> _allMembers;
    public string Name { get; }
    internal NamespaceExtent Extent { get; }
    public ImmutableArray`1<NamespaceSymbol> ConstituentNamespaces { get; }
    public Symbol ContainingSymbol { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    private MergedNamespaceSymbol(NamespaceExtent extent, NamespaceSymbol containingNamespace, ImmutableArray`1<NamespaceSymbol> namespacesToMerge, string nameOpt);
    internal static NamespaceSymbol Create(NamespaceExtent extent, NamespaceSymbol containingNamespace, ImmutableArray`1<NamespaceSymbol> namespacesToMerge, string nameOpt);
    internal NamespaceSymbol GetConstituentForCompilation(CSharpCompilation compilation);
    internal virtual void ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken);
    private ImmutableArray`1<Symbol> SlowGetChildrenOfName(string name);
    private HashSet`1<string> SlowGetChildNames(IEqualityComparer`1<string> comparer);
    public virtual string get_Name();
    internal virtual NamespaceExtent get_Extent();
    public virtual ImmutableArray`1<NamespaceSymbol> get_ConstituentNamespaces();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    internal sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembersUnordered();
    public sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual Symbol get_ContainingSymbol();
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual void GetExtensionMethods(ArrayBuilder`1<MethodSymbol> methods, string name, int arity, LookupOptions options);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.DynamicTypeDecoder : ValueType {
    private ImmutableArray`1<bool> _dynamicTransformFlags;
    private AssemblySymbol _containingAssembly;
    private bool _haveCustomModifierFlags;
    private bool _checkLength;
    private int _index;
    private bool HasFlag { get; }
    private DynamicTypeDecoder(ImmutableArray`1<bool> dynamicTransformFlags, bool haveCustomModifierFlags, bool checkLength, AssemblySymbol containingAssembly);
    internal static TypeSymbol TransformType(TypeSymbol metadataType, int targetSymbolCustomModifierCount, EntityHandle targetSymbolToken, PEModuleSymbol containingModule, RefKind targetSymbolRefKind);
    internal static TypeSymbol TransformTypeWithoutCustomModifierFlags(TypeSymbol type, AssemblySymbol containingAssembly, RefKind targetSymbolRefKind, ImmutableArray`1<bool> dynamicTransformFlags, bool checkLength);
    private static TypeSymbol TransformTypeInternal(TypeSymbol metadataType, AssemblySymbol containingAssembly, int targetSymbolCustomModifierCount, RefKind targetSymbolRefKind, ImmutableArray`1<bool> dynamicTransformFlags, bool haveCustomModifierFlags, bool checkLength);
    private TypeSymbol TransformType(TypeSymbol type);
    private bool HandleCustomModifiers(int customModifiersCount);
    private bool HandleParameterRefKind(RefKind refKind);
    private NamedTypeSymbol TransformNamedType(NamedTypeSymbol namedType, bool isContaining);
    private ImmutableArray`1<TypeSymbol> TransformTypeArguments(ImmutableArray`1<TypeSymbol> typeArguments);
    private ArrayTypeSymbol TransformArrayType(ArrayTypeSymbol arrayType);
    private PointerTypeSymbol TransformPointerType(PointerTypeSymbol pointerType);
    private bool get_HasFlag();
    private bool PeekFlag();
    private bool ConsumeFlag();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MemberRefMetadataDecoder : MetadataDecoder {
    private TypeSymbol _containingType;
    public MemberRefMetadataDecoder(PEModuleSymbol moduleSymbol, TypeSymbol containingType);
    protected virtual TypeSymbol GetGenericMethodTypeParamSymbol(int position);
    protected virtual TypeSymbol GetGenericTypeParamSymbol(int position);
    private static void GetGenericTypeArgumentSymbol(int position, NamedTypeSymbol namedType, Int32& cumulativeArity, TypeSymbol& typeArgument);
    internal Symbol FindMember(TypeSymbol targetTypeSymbol, MemberReferenceHandle memberRef, bool methodsOnly);
    private static FieldSymbol FindFieldBySignature(TypeSymbol targetTypeSymbol, string targetMemberName, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers, TypeSymbol type);
    private static MethodSymbol FindMethodBySignature(TypeSymbol targetTypeSymbol, string targetMemberName, SignatureHeader targetMemberSignatureHeader, int targetMemberTypeParamCount, ParamInfo`1[] targetParamInfo);
    private static bool MethodSymbolMatchesParamInfo(MethodSymbol candidateMethod, ParamInfo`1[] targetParamInfo);
    private static bool ParametersMatch(ParameterSymbol candidateParam, TypeMap candidateMethodTypeMap, ParamInfo`1& targetParam);
    private static bool ReturnTypesMatch(MethodSymbol candidateMethod, TypeMap candidateMethodTypeMap, ParamInfo`1& targetReturnParam);
    private static bool CustomModifiersMatch(ImmutableArray`1<CustomModifier> candidateCustomModifiers, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> targetCustomModifiers);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder : MetadataDecoder`5<PEModuleSymbol, TypeSymbol, MethodSymbol, FieldSymbol, Symbol> {
    private PENamedTypeSymbol _typeContextOpt;
    private PEMethodSymbol _methodContextOpt;
    internal PEModuleSymbol ModuleSymbol { get; }
    public MetadataDecoder(PEModuleSymbol moduleSymbol, PENamedTypeSymbol context);
    public MetadataDecoder(PEModuleSymbol moduleSymbol, PEMethodSymbol context);
    public MetadataDecoder(PEModuleSymbol moduleSymbol);
    private MetadataDecoder(PEModuleSymbol moduleSymbol, PENamedTypeSymbol typeContextOpt, PEMethodSymbol methodContextOpt);
    internal PEModuleSymbol get_ModuleSymbol();
    protected virtual TypeSymbol GetGenericMethodTypeParamSymbol(int position);
    protected virtual TypeSymbol GetGenericTypeParamSymbol(int position);
    protected virtual ConcurrentDictionary`2<TypeDefinitionHandle, TypeSymbol> GetTypeHandleToTypeMap();
    protected virtual ConcurrentDictionary`2<TypeReferenceHandle, TypeSymbol> GetTypeRefHandleToTypeMap();
    protected virtual TypeSymbol LookupNestedTypeDefSymbol(TypeSymbol container, MetadataTypeName& emittedName);
    protected virtual TypeSymbol LookupTopLevelTypeDefSymbol(int referencedAssemblyIndex, MetadataTypeName& emittedName);
    protected virtual TypeSymbol LookupTopLevelTypeDefSymbol(string moduleName, MetadataTypeName& emittedName, Boolean& isNoPiaLocalType);
    protected virtual TypeSymbol LookupTopLevelTypeDefSymbol(MetadataTypeName& emittedName, Boolean& isNoPiaLocalType);
    protected virtual int GetIndexOfReferencedAssembly(AssemblyIdentity identity);
    public static bool IsOrClosedOverATypeFromAssemblies(TypeSymbol symbol, ImmutableArray`1<AssemblySymbol> assemblies);
    protected virtual TypeSymbol SubstituteNoPiaLocalType(TypeDefinitionHandle typeDef, MetadataTypeName& name, string interfaceGuid, string scope, string identifier);
    internal static NamedTypeSymbol SubstituteNoPiaLocalType(MetadataTypeName& name, bool isInterface, TypeSymbol baseType, string interfaceGuid, string scope, string identifier, AssemblySymbol referringAssembly);
    protected virtual MethodSymbol FindMethodSymbolInType(TypeSymbol typeSymbol, MethodDefinitionHandle targetMethodDef);
    protected virtual FieldSymbol FindFieldSymbolInType(TypeSymbol typeSymbol, FieldDefinitionHandle fieldDef);
    internal virtual Symbol GetSymbolForMemberRef(MemberReferenceHandle memberRef, TypeSymbol scope, bool methodsOnly);
    protected virtual void EnqueueTypeSymbolInterfacesAndBaseTypes(Queue`1<TypeDefinitionHandle> typeDefsToSearch, Queue`1<TypeSymbol> typeSymbolsToSearch, TypeSymbol typeSymbol);
    protected virtual void EnqueueTypeSymbol(Queue`1<TypeDefinitionHandle> typeDefsToSearch, Queue`1<TypeSymbol> typeSymbolsToSearch, TypeSymbol typeSymbol);
    protected virtual MethodDefinitionHandle GetMethodHandle(MethodSymbol method);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol : MetadataOrSourceAssemblySymbol {
    private PEAssembly _assembly;
    private DocumentationProvider _documentationProvider;
    private ImmutableArray`1<ModuleSymbol> _modules;
    private ImmutableArray`1<AssemblySymbol> _noPiaResolutionAssemblies;
    private ImmutableArray`1<AssemblySymbol> _linkedReferencedAssemblies;
    private bool _isLinked;
    private ImmutableArray`1<CSharpAttributeData> _lazyCustomAttributes;
    internal PEAssembly Assembly { get; }
    public AssemblyIdentity Identity { get; }
    public Version AssemblyVersionPattern { get; }
    public ImmutableArray`1<ModuleSymbol> Modules { get; }
    public ImmutableArray`1<Location> Locations { get; }
    internal ImmutableArray`1<byte> PublicKey { get; }
    internal DocumentationProvider DocumentationProvider { get; }
    internal bool IsLinked { get; }
    public bool MightContainExtensionMethods { get; }
    internal PEModuleSymbol PrimaryModule { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    internal PEAssemblySymbol(PEAssembly assembly, DocumentationProvider documentationProvider, bool isLinked, MetadataImportOptions importOptions);
    internal PEAssembly get_Assembly();
    public virtual AssemblyIdentity get_Identity();
    public virtual Version get_AssemblyVersionPattern();
    public virtual ImmutableArray`1<ModuleSymbol> get_Modules();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal AssemblySymbol LookupAssemblyForForwardedMetadataType(MetadataTypeName& emittedName);
    internal virtual NamedTypeSymbol TryLookupForwardedMetadataTypeWithCycleDetection(MetadataTypeName& emittedName, ConsList`1<AssemblySymbol> visitedAssemblies);
    internal virtual ImmutableArray`1<AssemblySymbol> GetNoPiaResolutionAssemblies();
    internal virtual void SetNoPiaResolutionAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal virtual void SetLinkedReferencedAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal virtual ImmutableArray`1<AssemblySymbol> GetLinkedReferencedAssemblies();
    internal virtual ImmutableArray`1<byte> get_PublicKey();
    internal virtual bool GetGuidString(String& guidString);
    internal virtual bool AreInternalsVisibleToThisAssembly(AssemblySymbol potentialGiverOfAccess);
    internal virtual IEnumerable`1<ImmutableArray`1<byte>> GetInternalsVisibleToPublicKeys(string simpleName);
    internal DocumentationProvider get_DocumentationProvider();
    internal virtual bool get_IsLinked();
    public virtual bool get_MightContainExtensionMethods();
    internal PEModuleSymbol get_PrimaryModule();
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
    public virtual AssemblyMetadata GetMetadata();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAttributeData : CSharpAttributeData {
    private MetadataDecoder _decoder;
    private CustomAttributeHandle _handle;
    private NamedTypeSymbol _lazyAttributeClass;
    private MethodSymbol _lazyAttributeConstructor;
    private ImmutableArray`1<TypedConstant> _lazyConstructorArguments;
    private ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> _lazyNamedArguments;
    private ThreeState _lazyHasErrors;
    public NamedTypeSymbol AttributeClass { get; }
    public MethodSymbol AttributeConstructor { get; }
    public SyntaxReference ApplicationSyntaxReference { get; }
    protected internal ImmutableArray`1<TypedConstant> CommonConstructorArguments { get; }
    protected internal ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> CommonNamedArguments { get; }
    internal bool HasErrors { get; }
    internal PEAttributeData(PEModuleSymbol moduleSymbol, CustomAttributeHandle handle);
    public virtual NamedTypeSymbol get_AttributeClass();
    public virtual MethodSymbol get_AttributeConstructor();
    public virtual SyntaxReference get_ApplicationSyntaxReference();
    protected internal virtual ImmutableArray`1<TypedConstant> get_CommonConstructorArguments();
    protected internal virtual ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> get_CommonNamedArguments();
    private void EnsureClassAndConstructorSymbolsAreLoaded();
    private void EnsureAttributeArgumentsAreLoaded();
    internal virtual bool IsTargetAttribute(string namespaceName, string typeName);
    internal virtual int GetTargetAttributeSignatureIndex(Symbol targetSymbol, AttributeDescription description);
    internal virtual bool get_HasErrors();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEEventSymbol : EventSymbol {
    private string _name;
    private PENamedTypeSymbol _containingType;
    private EventDefinitionHandle _handle;
    private TypeSymbol _eventType;
    private PEMethodSymbol _addMethod;
    private PEMethodSymbol _removeMethod;
    private PEFieldSymbol _associatedFieldOpt;
    private ImmutableArray`1<CSharpAttributeData> _lazyCustomAttributes;
    private Tuple`2<CultureInfo, string> _lazyDocComment;
    private DiagnosticInfo _lazyUseSiteDiagnostic;
    private ObsoleteAttributeData _lazyObsoleteAttributeData;
    private static int UnsetAccessibility;
    private int _lazyDeclaredAccessibility;
    private Flags _flags;
    public bool IsWindowsRuntimeEvent { get; }
    internal FieldSymbol AssociatedField { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal EventDefinitionHandle Handle { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsExtern { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public TypeSymbol Type { get; }
    public MethodSymbol AddMethod { get; }
    public MethodSymbol RemoveMethod { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public ImmutableArray`1<EventSymbol> ExplicitInterfaceImplementations { get; }
    internal bool MustCallMethodsDirectly { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    internal PEEventSymbol(PEModuleSymbol moduleSymbol, PENamedTypeSymbol containingType, EventDefinitionHandle handle, PEMethodSymbol addMethod, PEMethodSymbol removeMethod, MultiDictionary`2<string, PEFieldSymbol> privateFieldNameToSymbols);
    private PEFieldSymbol GetAssociatedField(MultiDictionary`2<string, PEFieldSymbol> privateFieldNameToSymbols, bool isWindowsRuntimeEvent);
    public virtual bool get_IsWindowsRuntimeEvent();
    internal virtual FieldSymbol get_AssociatedField();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_HasRuntimeSpecialName();
    internal EventDefinitionHandle get_Handle();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsExtern();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsStatic();
    public virtual TypeSymbol get_Type();
    public virtual MethodSymbol get_AddMethod();
    public virtual MethodSymbol get_RemoveMethod();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal virtual IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public virtual ImmutableArray`1<EventSymbol> get_ExplicitInterfaceImplementations();
    internal virtual bool get_MustCallMethodsDirectly();
    private static bool DoSignaturesMatch(PEModuleSymbol moduleSymbol, TypeSymbol eventType, PEMethodSymbol addMethod, PEMethodSymbol removeMethod);
    private static bool DoModifiersMatch(PEMethodSymbol addMethod, PEMethodSymbol removeMethod);
    private static bool DoesSignatureMatch(PEModuleSymbol moduleSymbol, TypeSymbol eventType, PEMethodSymbol method);
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEFieldSymbol : FieldSymbol {
    private FieldDefinitionHandle _handle;
    private string _name;
    private FieldAttributes _flags;
    private PENamedTypeSymbol _containingType;
    private bool _lazyIsVolatile;
    private ImmutableArray`1<CSharpAttributeData> _lazyCustomAttributes;
    private ImmutableArray`1<CustomModifier> _lazyCustomModifiers;
    private ConstantValue _lazyConstantValue;
    private Tuple`2<CultureInfo, string> _lazyDocComment;
    private DiagnosticInfo _lazyUseSiteDiagnostic;
    private ObsoleteAttributeData _lazyObsoleteAttributeData;
    private TypeSymbol _lazyType;
    private int _lazyFixedSize;
    private NamedTypeSymbol _lazyFixedImplementationType;
    private PEEventSymbol _associatedEventOpt;
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public string Name { get; }
    internal FieldAttributes Flags { get; }
    internal bool HasSpecialName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal bool IsNotSerialized { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal bool IsMarshalledExplicitly { get; }
    internal UnmanagedType MarshallingType { get; }
    internal ImmutableArray`1<byte> MarshallingDescriptor { get; }
    internal Nullable`1<int> TypeLayoutOffset { get; }
    internal FieldDefinitionHandle Handle { get; }
    private PEModuleSymbol ContainingPEModule { get; }
    public bool IsFixed { get; }
    public int FixedSize { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public Symbol AssociatedSymbol { get; }
    public bool IsReadOnly { get; }
    public bool IsVolatile { get; }
    public bool IsConst { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    internal PEFieldSymbol(PEModuleSymbol moduleSymbol, PENamedTypeSymbol containingType, FieldDefinitionHandle fieldDef);
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual string get_Name();
    internal FieldAttributes get_Flags();
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_HasRuntimeSpecialName();
    internal virtual bool get_IsNotSerialized();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual bool get_IsMarshalledExplicitly();
    internal virtual UnmanagedType get_MarshallingType();
    internal virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    internal virtual Nullable`1<int> get_TypeLayoutOffset();
    internal FieldDefinitionHandle get_Handle();
    internal void SetAssociatedEvent(PEEventSymbol eventSymbol);
    private void EnsureSignatureIsLoaded();
    private bool IsFixedBuffer(Int32& fixedSize, TypeSymbol& fixedElementType);
    private PEModuleSymbol get_ContainingPEModule();
    internal virtual TypeSymbol GetFieldType(ConsList`1<FieldSymbol> fieldsBeingBound);
    public virtual bool get_IsFixed();
    public virtual int get_FixedSize();
    internal virtual NamedTypeSymbol FixedImplementationType(PEModuleBuilder emitModule);
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual Symbol get_AssociatedSymbol();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsVolatile();
    public virtual bool get_IsConst();
    internal virtual ConstantValue GetConstantValue(ConstantFieldsInProgress inProgress, bool earlyDecodingWellKnownAttributes);
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsStatic();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    private bool FilterOutDecimalConstantAttribute();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEFieldSymbol/<GetCustomAttributesToEmit>d__74")]
internal virtual IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEGlobalNamespaceSymbol : PENamespaceSymbol {
    private PEModuleSymbol _moduleSymbol;
    public Symbol ContainingSymbol { get; }
    internal PEModuleSymbol ContainingPEModule { get; }
    public string Name { get; }
    public bool IsGlobalNamespace { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal ModuleSymbol ContainingModule { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    internal PEGlobalNamespaceSymbol(PEModuleSymbol moduleSymbol);
    public virtual Symbol get_ContainingSymbol();
    internal virtual PEModuleSymbol get_ContainingPEModule();
    public virtual string get_Name();
    public virtual bool get_IsGlobalNamespace();
    public virtual AssemblySymbol get_ContainingAssembly();
    internal virtual ModuleSymbol get_ContainingModule();
    protected virtual void EnsureAllMembersLoaded();
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol : MethodSymbol {
    private MethodDefinitionHandle _handle;
    private string _name;
    private PENamedTypeSymbol _containingType;
    private Symbol _associatedPropertyOrEventOpt;
    private PackedFlags _packedFlags;
    private ushort _flags;
    private ushort _implFlags;
    private ImmutableArray`1<TypeParameterSymbol> _lazyTypeParameters;
    private SignatureData _lazySignature;
    private ImmutableArray`1<MethodSymbol> _lazyExplicitMethodImplementations;
    private UncommonFields _uncommonFields;
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public string Name { get; }
    internal MethodAttributes Flags { get; }
    internal bool HasSpecialName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool RequiresSecurityObject { get; }
    internal bool ReturnValueIsMarshalledExplicitly { get; }
    internal MarshalPseudoCustomAttributeData ReturnValueMarshallingInformation { get; }
    internal ImmutableArray`1<byte> ReturnValueMarshallingDescriptor { get; }
    internal bool IsAccessCheckedOnOverride { get; }
    internal bool HasDeclarativeSecurity { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsExtern { get; }
    internal bool IsExternal { get; }
    public bool IsVararg { get; }
    public bool IsGenericMethod { get; }
    public bool IsAsync { get; }
    public int Arity { get; }
    internal MethodDefinitionHandle Handle { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool HidesBaseMethodsByName { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    internal bool IsMetadataFinal { get; }
    private bool IsExplicitFinalizerOverride { get; }
    private bool IsExplicitClassOverride { get; }
    private bool IsDestructor { get; }
    public bool ReturnsVoid { get; }
    internal int ParameterCount { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    internal PEParameterSymbol ReturnTypeParameter { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    private SignatureData Signature { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public Symbol AssociatedSymbol { get; }
    public bool IsExtensionMethod { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public MethodKind MethodKind { get; }
    internal CallingConvention CallingConvention { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool GenerateDebugInfo { get; }
    internal OverriddenOrHiddenMembersResult OverriddenOrHiddenMembers { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    internal bool TestIsExtensionBitSet { get; }
    internal bool TestIsExtensionBitTrue { get; }
    internal PEMethodSymbol(PEModuleSymbol moduleSymbol, PENamedTypeSymbol containingType, MethodDefinitionHandle methodDef);
    private UncommonFields CreateUncommonFields();
    private UncommonFields AccessUncommonFields();
    internal virtual bool TryGetThisParameter(ParameterSymbol& thisParameter);
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual string get_Name();
    private bool HasFlag(MethodAttributes flag);
    internal MethodAttributes get_Flags();
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_HasRuntimeSpecialName();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    internal virtual bool get_RequiresSecurityObject();
    public virtual DllImportData GetDllImportData();
    internal virtual bool get_ReturnValueIsMarshalledExplicitly();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnValueMarshallingInformation();
    internal virtual ImmutableArray`1<byte> get_ReturnValueMarshallingDescriptor();
    internal virtual bool get_IsAccessCheckedOnOverride();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsExtern();
    internal virtual bool get_IsExternal();
    public virtual bool get_IsVararg();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsAsync();
    public virtual int get_Arity();
    internal MethodDefinitionHandle get_Handle();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_HidesBaseMethodsByName();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsStatic();
    internal virtual bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges);
    internal virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_IsMetadataFinal();
    private bool get_IsExplicitFinalizerOverride();
    private bool get_IsExplicitClassOverride();
    private bool get_IsDestructor();
    public virtual bool get_ReturnsVoid();
    internal virtual int get_ParameterCount();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal PEParameterSymbol get_ReturnTypeParameter();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    internal bool SetAssociatedProperty(PEPropertySymbol propertySymbol, MethodKind methodKind);
    internal bool SetAssociatedEvent(PEEventSymbol eventSymbol, MethodKind methodKind);
    private bool SetAssociatedPropertyOrEvent(Symbol propertyOrEventSymbol, MethodKind methodKind);
    private SignatureData get_Signature();
    private SignatureData LoadSignature();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    private ImmutableArray`1<TypeParameterSymbol> EnsureTypeParametersAreLoaded(DiagnosticInfo& diagnosticInfo);
    private ImmutableArray`1<TypeParameterSymbol> LoadTypeParameters(DiagnosticInfo& diagnosticInfo);
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual Symbol get_AssociatedSymbol();
    public virtual bool get_IsExtensionMethod();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal virtual IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public virtual ImmutableArray`1<CSharpAttributeData> GetReturnTypeAttributes();
    public virtual MethodKind get_MethodKind();
    private bool IsValidExtensionMethodSignature();
    private bool IsValidUserDefinedOperatorSignature(int parameterCount);
    private MethodKind ComputeMethodKind();
    internal virtual CallingConvention get_CallingConvention();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    private DiagnosticInfo InitializeUseSiteDiagnostic(DiagnosticInfo diagnostic);
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual bool get_GenerateDebugInfo();
    internal virtual OverriddenOrHiddenMembersResult get_OverriddenOrHiddenMembers();
    internal virtual CSharpCompilation get_DeclaringCompilation();
    internal bool get_TestIsExtensionBitSet();
    internal bool get_TestIsExtensionBitTrue();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol : NonMissingModuleSymbol {
    private AssemblySymbol _assemblySymbol;
    private int _ordinal;
    private PEModule _module;
    private PENamespaceSymbol _globalNamespace;
    private NamedTypeSymbol _lazySystemTypeSymbol;
    private NamedTypeSymbol _lazyEventRegistrationTokenSymbol;
    private NamedTypeSymbol _lazyEventRegistrationTokenTableSymbol;
    private static int DefaultTypeMapCapacity;
    internal ConcurrentDictionary`2<TypeDefinitionHandle, TypeSymbol> TypeHandleToTypeMap;
    internal ConcurrentDictionary`2<TypeReferenceHandle, TypeSymbol> TypeRefHandleToTypeMap;
    internal ImmutableArray`1<MetadataLocation> MetadataLocation;
    internal MetadataImportOptions ImportOptions;
    private ImmutableArray`1<CSharpAttributeData> _lazyCustomAttributes;
    private ImmutableArray`1<CSharpAttributeData> _lazyAssemblyAttributes;
    private ICollection`1<string> _lazyTypeNames;
    private ICollection`1<string> _lazyNamespaceNames;
    internal int Ordinal { get; }
    internal Machine Machine { get; }
    internal bool Bit32Required { get; }
    internal PEModule Module { get; }
    public NamespaceSymbol GlobalNamespace { get; }
    public string Name { get; }
    private static EntityHandle Token { get; }
    public Symbol ContainingSymbol { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public ImmutableArray`1<Location> Locations { get; }
    internal ICollection`1<string> TypeNames { get; }
    internal ICollection`1<string> NamespaceNames { get; }
    internal DocumentationProvider DocumentationProvider { get; }
    internal NamedTypeSymbol EventRegistrationToken { get; }
    internal NamedTypeSymbol EventRegistrationTokenTable_T { get; }
    internal NamedTypeSymbol SystemTypeSymbol { get; }
    internal bool HasAssemblyCompilationRelaxationsAttribute { get; }
    internal bool HasAssemblyRuntimeCompatibilityAttribute { get; }
    internal Nullable`1<CharSet> DefaultMarshallingCharSet { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    internal PEModuleSymbol(PEAssemblySymbol assemblySymbol, PEModule module, MetadataImportOptions importOptions, int ordinal);
    internal PEModuleSymbol(SourceAssemblySymbol assemblySymbol, PEModule module, MetadataImportOptions importOptions, int ordinal);
    internal PEModuleSymbol(RetargetingAssemblySymbol assemblySymbol, PEModule module, MetadataImportOptions importOptions, int ordinal);
    private PEModuleSymbol(AssemblySymbol assemblySymbol, PEModule module, MetadataImportOptions importOptions, int ordinal);
    internal virtual int get_Ordinal();
    internal virtual Machine get_Machine();
    internal virtual bool get_Bit32Required();
    internal PEModule get_Module();
    public virtual NamespaceSymbol get_GlobalNamespace();
    public virtual string get_Name();
    private static EntityHandle get_Token();
    public virtual Symbol get_ContainingSymbol();
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal ImmutableArray`1<CSharpAttributeData> GetAssemblyAttributes();
    internal void LoadCustomAttributes(EntityHandle token, ImmutableArray`1& customAttributes);
    internal void LoadCustomAttributesFilterExtensions(EntityHandle token, ImmutableArray`1& customAttributes, Boolean& foundExtension);
    internal void LoadCustomAttributesFilterExtensions(EntityHandle token, ImmutableArray`1& customAttributes);
    internal ImmutableArray`1<CSharpAttributeData> GetCustomAttributesForToken(EntityHandle token, CustomAttributeHandle& filteredOutAttribute1, AttributeDescription filterOut1, CustomAttributeHandle& filteredOutAttribute2, AttributeDescription filterOut2);
    internal ImmutableArray`1<CSharpAttributeData> GetCustomAttributesForToken(EntityHandle token);
    internal ImmutableArray`1<CSharpAttributeData> GetCustomAttributesForToken(EntityHandle token, CustomAttributeHandle& paramArrayAttribute);
    internal bool HasAnyCustomAttributes(EntityHandle token);
    internal TypeSymbol TryDecodeAttributeWithTypeArgument(EntityHandle handle, AttributeDescription attributeDescription);
    internal ImmutableArray`1<CSharpAttributeData> GetCustomAttributesFilterExtensions(EntityHandle token, Boolean& foundExtension);
    internal void OnNewTypeDeclarationsLoaded(Dictionary`2<string, ImmutableArray`1<PENamedTypeSymbol>> typesDict);
    internal virtual ICollection`1<string> get_TypeNames();
    internal virtual ICollection`1<string> get_NamespaceNames();
    internal virtual ImmutableArray`1<byte> GetHash(AssemblyHashAlgorithm algorithmId);
    internal DocumentationProvider get_DocumentationProvider();
    internal NamedTypeSymbol get_EventRegistrationToken();
    internal NamedTypeSymbol get_EventRegistrationTokenTable_T();
    internal NamedTypeSymbol get_SystemTypeSymbol();
    private NamedTypeSymbol GetTypeSymbolForWellKnownType(WellKnownType type);
    private static bool IsAcceptableSystemTypeSymbol(NamedTypeSymbol candidate);
    internal virtual bool get_HasAssemblyCompilationRelaxationsAttribute();
    internal virtual bool get_HasAssemblyRuntimeCompatibilityAttribute();
    internal virtual Nullable`1<CharSet> get_DefaultMarshallingCharSet();
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
    internal NamedTypeSymbol LookupTopLevelMetadataType(MetadataTypeName& emittedName, Boolean& isNoPiaLocalType);
    internal AssemblySymbol GetAssemblyForForwardedType(MetadataTypeName& fullName);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol/<GetForwardedTypes>d__77")]
internal IEnumerable`1<NamedTypeSymbol> GetForwardedTypes();
    public virtual ModuleMetadata GetMetadata();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol : NamedTypeSymbol {
    private static Dictionary`2<string, ImmutableArray`1<PENamedTypeSymbol>> s_emptyNestedTypes;
    private NamespaceOrTypeSymbol _container;
    private TypeDefinitionHandle _handle;
    private string _name;
    private TypeAttributes _flags;
    private SpecialType _corTypeId;
    private ICollection`1<string> _lazyMemberNames;
    private ImmutableArray`1<Symbol> _lazyMembersInDeclarationOrder;
    private Dictionary`2<string, ImmutableArray`1<Symbol>> _lazyMembersByName;
    private Dictionary`2<string, ImmutableArray`1<PENamedTypeSymbol>> _lazyNestedTypes;
    private TypeKind _lazyKind;
    private NamedTypeSymbol _lazyBaseType;
    private ImmutableArray`1<NamedTypeSymbol> _lazyInterfaces;
    private NamedTypeSymbol _lazyDeclaredBaseType;
    private ImmutableArray`1<NamedTypeSymbol> _lazyDeclaredInterfaces;
    private Tuple`2<CultureInfo, string> _lazyDocComment;
    private DiagnosticInfo _lazyUseSiteDiagnostic;
    private static UncommonProperties s_noUncommonProperties;
    private UncommonProperties _lazyUncommonProperties;
    [CompilerGeneratedAttribute]
private IEnumerable`1<object> <fieldDefs>k__BackingField;
    public SpecialType SpecialType { get; }
    internal PEModuleSymbol ContainingPEModule { get; }
    internal ModuleSymbol ContainingModule { get; }
    public int Arity { get; }
    internal bool MangleName { get; }
    internal int MetadataArity { get; }
    internal TypeDefinitionHandle Handle { get; }
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    public NamedTypeSymbol ConstructedFrom { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public Accessibility DeclaredAccessibility { get; }
    public NamedTypeSymbol EnumUnderlyingType { get; }
    public IEnumerable`1<string> MemberNames { get; }
    internal FieldSymbol FixedElementField { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal ImmutableArray`1<TypeSymbol> TypeArgumentsNoUseSiteDiagnostics { get; }
    internal bool HasTypeArgumentsCustomModifiers { get; }
    internal ImmutableArray`1<ImmutableArray`1<CustomModifier>> TypeArgumentsCustomModifiers { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    internal bool IsMetadataAbstract { get; }
    public bool IsSealed { get; }
    internal bool IsMetadataSealed { get; }
    internal TypeAttributes Flags { get; }
    public bool MightContainExtensionMethods { get; }
    public TypeKind TypeKind { get; }
    internal bool IsInterface { get; }
    internal string DefaultMemberName { get; }
    internal bool IsComImport { get; }
    internal bool ShouldAddWinRTMembers { get; }
    internal bool IsWindowsRuntimeImport { get; }
    internal TypeLayout Layout { get; }
    internal CharSet MarshallingCharSet { get; }
    internal bool IsSerializable { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal NamedTypeSymbol ComImportCoClass { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    public IEnumerable`1<object> fieldDefs { get; public set; }
    private PENamedTypeSymbol(PEModuleSymbol moduleSymbol, NamespaceOrTypeSymbol container, TypeDefinitionHandle handle, string emittedNamespaceName, ushort arity, Boolean& mangleName);
    private static PENamedTypeSymbol();
    private UncommonProperties GetUncommonProperties();
    private bool IsUncommon();
    internal static PENamedTypeSymbol Create(PEModuleSymbol moduleSymbol, PENamespaceSymbol containingNamespace, TypeDefinitionHandle handle, string emittedNamespaceName);
    private static void GetGenericInfo(PEModuleSymbol moduleSymbol, TypeDefinitionHandle handle, GenericParameterHandleCollection& genericParameterHandles, UInt16& arity, BadImageFormatException& mrEx);
    internal static PENamedTypeSymbol Create(PEModuleSymbol moduleSymbol, PENamedTypeSymbol containingType, TypeDefinitionHandle handle);
    public virtual SpecialType get_SpecialType();
    internal PEModuleSymbol get_ContainingPEModule();
    internal virtual ModuleSymbol get_ContainingModule();
    public abstract virtual int get_Arity();
    internal abstract virtual bool get_MangleName();
    internal abstract virtual int get_MetadataArity();
    internal TypeDefinitionHandle get_Handle();
    internal virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
    internal virtual ImmutableArray`1<NamedTypeSymbol> InterfacesNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetInterfacesToEmit();
    internal virtual NamedTypeSymbol GetDeclaredBaseType(ConsList`1<Symbol> basesBeingResolved);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved);
    private NamedTypeSymbol MakeDeclaredBaseType();
    private ImmutableArray`1<NamedTypeSymbol> MakeDeclaredInterfaces();
    public virtual NamedTypeSymbol get_ConstructedFrom();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual NamedTypeSymbol get_EnumUnderlyingType();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal virtual IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public virtual IEnumerable`1<string> get_MemberNames();
    private void EnsureNonTypeMemberNamesAreLoaded();
    private static ICollection`1<string> CreateReadOnlyMemberNames(HashSet`1<string> names);
    internal virtual ImmutableArray`1<Symbol> GetMembersUnordered();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol/<GetEnumFieldsToEmit>d__66")]
private IEnumerable`1<FieldSymbol> GetEnumFieldsToEmit();
    internal virtual IEnumerable`1<FieldSymbol> GetFieldsToEmit();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol/<GetMethodsToEmit>d__68")]
internal virtual IEnumerable`1<MethodSymbol> GetMethodsToEmit();
    internal virtual IEnumerable`1<PropertySymbol> GetPropertiesToEmit();
    internal virtual IEnumerable`1<EventSymbol> GetEventsToEmit();
    internal virtual ImmutableArray`1<Symbol> GetEarlyAttributeDecodingMembers();
    internal virtual ImmutableArray`1<Symbol> GetEarlyAttributeDecodingMembers(string name);
    private void EnsureEnumUnderlyingTypeIsLoaded(UncommonProperties uncommon);
    private void EnsureAllMembersAreLoaded();
    private void LoadMembers();
    internal virtual ImmutableArray`1<Symbol> GetSimpleNonTypeMembers(string name);
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    internal virtual FieldSymbol get_FixedElementField();
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembersUnordered();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    private ImmutableArray`1<NamedTypeSymbol> GetMemberTypesPrivate();
    private void EnsureNestedTypesAreLoaded();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    internal virtual ImmutableArray`1<TypeSymbol> get_TypeArgumentsNoUseSiteDiagnostics();
    internal virtual bool get_HasTypeArgumentsCustomModifiers();
    internal virtual ImmutableArray`1<ImmutableArray`1<CustomModifier>> get_TypeArgumentsCustomModifiers();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual bool get_IsStatic();
    public virtual bool get_IsAbstract();
    internal virtual bool get_IsMetadataAbstract();
    public virtual bool get_IsSealed();
    internal virtual bool get_IsMetadataSealed();
    internal TypeAttributes get_Flags();
    public virtual bool get_MightContainExtensionMethods();
    public virtual TypeKind get_TypeKind();
    internal sealed virtual bool get_IsInterface();
    private static ExtendedErrorTypeSymbol CyclicInheritanceError(PENamedTypeSymbol type, TypeSymbol declaredBase);
    private NamedTypeSymbol MakeAcyclicBaseType();
    private ImmutableArray`1<NamedTypeSymbol> MakeAcyclicInterfaces();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol/<CreateNestedTypes>d__125")]
private IEnumerable`1<PENamedTypeSymbol> CreateNestedTypes();
    private MultiDictionary`2<string, PEFieldSymbol> CreateFields(ArrayBuilder`1<PEFieldSymbol> fieldMembers);
    private PooledDictionary`2<MethodDefinitionHandle, PEMethodSymbol> CreateMethods(ArrayBuilder`1<Symbol> members);
    private void CreateProperties(Dictionary`2<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol, ArrayBuilder`1<Symbol> members);
    private void CreateEvents(MultiDictionary`2<string, PEFieldSymbol> privateFieldNameToSymbols, Dictionary`2<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol, ArrayBuilder`1<Symbol> members);
    private PEMethodSymbol GetAccessorMethod(PEModule module, Dictionary`2<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol, MethodDefinitionHandle methodDef);
    private static Dictionary`2<string, ImmutableArray`1<Symbol>> GroupByName(ArrayBuilder`1<Symbol> symbols);
    private static Dictionary`2<string, ImmutableArray`1<PENamedTypeSymbol>> GroupByName(ArrayBuilder`1<PENamedTypeSymbol> symbols);
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    protected virtual DiagnosticInfo GetUseSiteDiagnosticImpl();
    internal string get_DefaultMemberName();
    internal virtual bool get_IsComImport();
    internal virtual bool get_ShouldAddWinRTMembers();
    internal virtual bool get_IsWindowsRuntimeImport();
    internal virtual bool GetGuidString(String& guidString);
    internal virtual TypeLayout get_Layout();
    internal virtual CharSet get_MarshallingCharSet();
    internal virtual bool get_IsSerializable();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual NamedTypeSymbol get_ComImportCoClass();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual AttributeUsageInfo GetAttributeUsageInfo();
    private AttributeUsageInfo DecodeAttributeUsageInfo();
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
    [CompilerGeneratedAttribute]
public IEnumerable`1<object> get_fieldDefs();
    [CompilerGeneratedAttribute]
public void set_fieldDefs(IEnumerable`1<object> value);
    private static int GetIndexOfFirstMember(ImmutableArray`1<Symbol> members, SymbolKind kind);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol/<GetMembers>d__167`1")]
private static IEnumerable`1<TSymbol> GetMembers(ImmutableArray`1<Symbol> members, SymbolKind kind, int offset);
    [CompilerGeneratedAttribute]
private NamedTypeSymbol <MakeAcyclicInterfaces>b__123_0(NamedTypeSymbol t);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol : NamespaceSymbol {
    protected Dictionary`2<string, PENestedNamespaceSymbol> lazyNamespaces;
    protected Dictionary`2<string, ImmutableArray`1<PENamedTypeSymbol>> lazyTypes;
    private Dictionary`2<string, TypeDefinitionHandle> _lazyNoPiaLocalTypes;
    private ImmutableArray`1<PENamedTypeSymbol> _lazyFlattenedTypes;
    internal NamespaceExtent Extent { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal PEModuleSymbol ContainingPEModule { get; }
    internal sealed virtual NamespaceExtent get_Extent();
    public sealed virtual ImmutableArray`1<Symbol> GetMembers();
    private ImmutableArray`1<NamedTypeSymbol> GetMemberTypesPrivate();
    private IEnumerable`1<PENestedNamespaceSymbol> GetMemberNamespacesPrivate();
    public sealed virtual ImmutableArray`1<Symbol> GetMembers(string name);
    public sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal abstract virtual PEModuleSymbol get_ContainingPEModule();
    protected abstract virtual void EnsureAllMembersLoaded();
    protected void LoadAllMembers(IEnumerable`1<IGrouping`2<string, TypeDefinitionHandle>> typesByNS);
    private int GetQualifiedNameLength();
    private void LazyInitializeNamespaces(IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<IGrouping`2<string, TypeDefinitionHandle>>>> childNamespaces);
    private void LazyInitializeTypes(IEnumerable`1<IGrouping`2<string, TypeDefinitionHandle>> typeGroups);
    internal NamedTypeSymbol LookupMetadataType(MetadataTypeName& emittedTypeName, Boolean& isNoPiaLocalType);
    [CompilerGeneratedAttribute]
private PENestedNamespaceSymbol <LazyInitializeNamespaces>b__22_0(KeyValuePair`2<string, IEnumerable`1<IGrouping`2<string, TypeDefinitionHandle>>> child);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENestedNamespaceSymbol : PENamespaceSymbol {
    private PENamespaceSymbol _containingNamespaceSymbol;
    private string _name;
    private IEnumerable`1<IGrouping`2<string, TypeDefinitionHandle>> _typesByNS;
    public Symbol ContainingSymbol { get; }
    internal PEModuleSymbol ContainingPEModule { get; }
    public string Name { get; }
    public bool IsGlobalNamespace { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal ModuleSymbol ContainingModule { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    internal PENestedNamespaceSymbol(string name, PENamespaceSymbol containingNamespace, IEnumerable`1<IGrouping`2<string, TypeDefinitionHandle>> typesByNS);
    public virtual Symbol get_ContainingSymbol();
    internal virtual PEModuleSymbol get_ContainingPEModule();
    public virtual string get_Name();
    public virtual bool get_IsGlobalNamespace();
    public virtual AssemblySymbol get_ContainingAssembly();
    internal virtual ModuleSymbol get_ContainingModule();
    protected virtual void EnsureAllMembersLoaded();
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEParameterSymbol : ParameterSymbol {
    private Symbol _containingSymbol;
    private string _name;
    private TypeSymbol _type;
    private ParameterHandle _handle;
    private ParameterAttributes _flags;
    private PEModuleSymbol _moduleSymbol;
    private ImmutableArray`1<CSharpAttributeData> _lazyCustomAttributes;
    private ConstantValue _lazyDefaultValue;
    private ThreeState _lazyIsParams;
    private ImmutableArray`1<CSharpAttributeData> _lazyHiddenAttributes;
    private ushort _ordinal;
    private PackedFlags _packedFlags;
    private bool HasNameInMetadata { get; }
    public RefKind RefKind { get; }
    public string Name { get; }
    public string MetadataName { get; }
    internal ParameterAttributes Flags { get; }
    public int Ordinal { get; }
    internal ParameterHandle Handle { get; }
    public Symbol ContainingSymbol { get; }
    internal bool HasMetadataConstantValue { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    internal bool IsMetadataOptional { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    private bool HasCallerLineNumberAttribute { get; }
    private bool HasCallerFilePathAttribute { get; }
    private bool HasCallerMemberNameAttribute { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerFilePath { get; }
    internal bool IsCallerMemberName { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    internal bool IsMetadataIn { get; }
    internal bool IsMetadataOut { get; }
    internal bool IsMarshalledExplicitly { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal ImmutableArray`1<byte> MarshallingDescriptor { get; }
    internal UnmanagedType MarshallingType { get; }
    public bool IsParams { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    private PEParameterSymbol(PEModuleSymbol moduleSymbol, Symbol containingSymbol, int ordinal, bool isByRef, TypeSymbol type, ParameterHandle handle, int countOfCustomModifiers, Boolean& isBad);
    internal static PEParameterSymbol Create(PEModuleSymbol moduleSymbol, PEMethodSymbol containingSymbol, int ordinal, ParamInfo`1<TypeSymbol> parameter, Boolean& isBad);
    internal static PEParameterSymbol Create(PEModuleSymbol moduleSymbol, PEPropertySymbol containingSymbol, int ordinal, ParameterHandle handle, ParamInfo`1<TypeSymbol> parameter, Boolean& isBad);
    private bool get_HasNameInMetadata();
    private static PEParameterSymbol Create(PEModuleSymbol moduleSymbol, Symbol containingSymbol, int ordinal, bool isByRef, ushort countOfCustomModifiersPrecedingByRef, TypeSymbol type, ParameterHandle handle, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers, Boolean& isBad);
    public virtual RefKind get_RefKind();
    public virtual string get_Name();
    public virtual string get_MetadataName();
    internal ParameterAttributes get_Flags();
    public virtual int get_Ordinal();
    internal ParameterHandle get_Handle();
    public virtual Symbol get_ContainingSymbol();
    internal virtual bool get_HasMetadataConstantValue();
    internal ConstantValue ImportConstantValue(bool ignoreAttributes);
    internal virtual ConstantValue get_ExplicitDefaultConstantValue();
    private ConstantValue GetDefaultDecimalOrDateTimeValue();
    internal virtual bool get_IsMetadataOptional();
    internal virtual bool get_IsIDispatchConstant();
    internal virtual bool get_IsIUnknownConstant();
    private bool get_HasCallerLineNumberAttribute();
    private bool get_HasCallerFilePathAttribute();
    private bool get_HasCallerMemberNameAttribute();
    internal virtual bool get_IsCallerLineNumber();
    internal virtual bool get_IsCallerFilePath();
    internal virtual bool get_IsCallerMemberName();
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    internal virtual ushort get_CountOfCustomModifiersPrecedingByRef();
    internal virtual bool get_IsMetadataIn();
    internal virtual bool get_IsMetadataOut();
    internal virtual bool get_IsMarshalledExplicitly();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    internal virtual UnmanagedType get_MarshallingType();
    public virtual bool get_IsParams();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEParameterSymbol/<GetCustomAttributesToEmit>d__84")]
internal virtual IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEPropertySymbol : PropertySymbol {
    private string _name;
    private PENamedTypeSymbol _containingType;
    private PropertyDefinitionHandle _handle;
    private ImmutableArray`1<ParameterSymbol> _parameters;
    private TypeSymbol _propertyType;
    private PEMethodSymbol _getMethod;
    private PEMethodSymbol _setMethod;
    private ImmutableArray`1<CustomModifier> _typeCustomModifiers;
    private ImmutableArray`1<CSharpAttributeData> _lazyCustomAttributes;
    private Tuple`2<CultureInfo, string> _lazyDocComment;
    private DiagnosticInfo _lazyUseSiteDiagnostic;
    private ObsoleteAttributeData _lazyObsoleteAttributeData;
    private static int UnsetAccessibility;
    private int _declaredAccessibility;
    private Flags _flags;
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    public string MetadataName { get; }
    internal PropertyDefinitionHandle Handle { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsExtern { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public bool IsIndexer { get; }
    public bool IsIndexedProperty { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public MethodSymbol GetMethod { get; }
    public MethodSymbol SetMethod { get; }
    internal CallingConvention CallingConvention { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public ImmutableArray`1<PropertySymbol> ExplicitInterfaceImplementations { get; }
    internal bool MustCallMethodsDirectly { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    internal PEPropertySymbol(PEModuleSymbol moduleSymbol, PENamedTypeSymbol containingType, PropertyDefinitionHandle handle, PEMethodSymbol getMethod, PEMethodSymbol setMethod);
    private bool MustCallMethodsDirectlyCore();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    public virtual string get_MetadataName();
    internal PropertyDefinitionHandle get_Handle();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsExtern();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsStatic();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual bool get_IsIndexer();
    public virtual bool get_IsIndexedProperty();
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
    public virtual MethodSymbol get_GetMethod();
    public virtual MethodSymbol get_SetMethod();
    internal virtual CallingConvention get_CallingConvention();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal virtual IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public virtual ImmutableArray`1<PropertySymbol> get_ExplicitInterfaceImplementations();
    internal virtual bool get_MustCallMethodsDirectly();
    private static bool DoSignaturesMatch(PEModule module, MetadataDecoder metadataDecoder, ParamInfo`1[] propertyParams, PEMethodSymbol getMethod, ParamInfo`1[] getMethodParams, PEMethodSymbol setMethod, ParamInfo`1[] setMethodParams);
    private static ImmutableArray`1<ParameterSymbol> GetParameters(PEModuleSymbol moduleSymbol, PEPropertySymbol property, ParamInfo`1[] propertyParams, ParamInfo`1[] accessorParams, Boolean& anyParameterIsBad);
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual bool get_HasRuntimeSpecialName();
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PETypeParameterSymbol : TypeParameterSymbol {
    private Symbol _containingSymbol;
    private GenericParameterHandle _handle;
    private string _name;
    private ushort _ordinal;
    private GenericParameterAttributes _flags;
    private TypeParameterBounds _lazyBounds;
    private DiagnosticInfo _lazyBoundsErrorInfo;
    private ImmutableArray`1<CSharpAttributeData> _lazyCustomAttributes;
    public TypeParameterKind TypeParameterKind { get; }
    public int Ordinal { get; }
    public string Name { get; }
    internal GenericParameterHandle Handle { get; }
    public Symbol ContainingSymbol { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool HasConstructorConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public VarianceKind Variance { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    internal PETypeParameterSymbol(PEModuleSymbol moduleSymbol, PENamedTypeSymbol definingNamedType, ushort ordinal, GenericParameterHandle handle);
    internal PETypeParameterSymbol(PEModuleSymbol moduleSymbol, PEMethodSymbol definingMethod, ushort ordinal, GenericParameterHandle handle);
    private PETypeParameterSymbol(PEModuleSymbol moduleSymbol, Symbol definingSymbol, ushort ordinal, GenericParameterHandle handle);
    public virtual TypeParameterKind get_TypeParameterKind();
    public virtual int get_Ordinal();
    public virtual string get_Name();
    internal GenericParameterHandle get_Handle();
    public virtual Symbol get_ContainingSymbol();
    public virtual AssemblySymbol get_ContainingAssembly();
    private ImmutableArray`1<TypeSymbol> GetDeclaredConstraintTypes();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool get_HasConstructorConstraint();
    public virtual bool get_HasReferenceTypeConstraint();
    public virtual bool get_HasValueTypeConstraint();
    public virtual VarianceKind get_Variance();
    internal virtual void EnsureAllConstraintsAreResolved();
    internal virtual ImmutableArray`1<TypeSymbol> GetConstraintTypes(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetInterfaces(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual NamedTypeSymbol GetEffectiveBaseClass(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual TypeSymbol GetDeducedBaseType(ConsList`1<TypeParameterSymbol> inProgress);
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    private TypeParameterBounds GetBounds(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual DiagnosticInfo GetConstraintsUseSiteErrorInfo();
    private NamedTypeSymbol GetDefaultBaseType();
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.SymbolFactory : SymbolFactory`2<PEModuleSymbol, TypeSymbol> {
    internal static SymbolFactory Instance;
    private static SymbolFactory();
    internal virtual TypeSymbol GetMDArrayTypeSymbol(PEModuleSymbol moduleSymbol, int rank, TypeSymbol elementType, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers, ImmutableArray`1<int> sizes, ImmutableArray`1<int> lowerBounds);
    internal virtual TypeSymbol GetByRefReturnTypeSymbol(PEModuleSymbol moduleSymbol, TypeSymbol referencedType, ushort countOfCustomModifiersPrecedingByRef);
    internal virtual TypeSymbol GetSpecialType(PEModuleSymbol moduleSymbol, SpecialType specialType);
    internal virtual TypeSymbol GetSystemTypeSymbol(PEModuleSymbol moduleSymbol);
    internal virtual TypeSymbol MakePointerTypeSymbol(PEModuleSymbol moduleSymbol, TypeSymbol type, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers);
    internal virtual TypeSymbol GetEnumUnderlyingType(PEModuleSymbol moduleSymbol, TypeSymbol type);
    internal virtual PrimitiveTypeCode GetPrimitiveTypeCode(PEModuleSymbol moduleSymbol, TypeSymbol type);
    internal virtual bool IsVolatileModifierType(PEModuleSymbol moduleSymbol, TypeSymbol type);
    internal virtual TypeSymbol GetSZArrayTypeSymbol(PEModuleSymbol moduleSymbol, TypeSymbol elementType, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers);
    internal virtual TypeSymbol GetUnsupportedMetadataTypeSymbol(PEModuleSymbol moduleSymbol, BadImageFormatException exception);
    internal virtual TypeSymbol SubstituteTypeParameters(PEModuleSymbol moduleSymbol, TypeSymbol genericTypeDef, ImmutableArray`1<KeyValuePair`2<TypeSymbol, ImmutableArray`1<ModifierInfo`1<TypeSymbol>>>> arguments, ImmutableArray`1<bool> refersToNoPiaLocalType);
    internal virtual TypeSymbol MakeUnboundIfGeneric(PEModuleSymbol moduleSymbol, TypeSymbol type);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.MetadataOrSourceAssemblySymbol : NonMissingAssemblySymbol {
    private NamedTypeSymbol[] _lazySpecialTypes;
    private int _cachedSpecialTypes;
    private ICollection`1<string> _lazyTypeNames;
    private ICollection`1<string> _lazyNamespaceNames;
    private Symbol[] _lazySpecialTypeMembers;
    private ConcurrentDictionary`2<AssemblySymbol, IVTConclusion> _assembliesToWhichInternalAccessHasBeenAnalyzed;
    internal bool KeepLookingForDeclaredSpecialTypes { get; }
    public ICollection`1<string> TypeNames { get; }
    public ICollection`1<string> NamespaceNames { get; }
    private ConcurrentDictionary`2<AssemblySymbol, IVTConclusion> AssembliesToWhichInternalAccessHasBeenDetermined { get; }
    internal virtual NamedTypeSymbol GetDeclaredSpecialType(SpecialType type);
    internal sealed virtual void RegisterDeclaredSpecialType(NamedTypeSymbol corType);
    internal virtual bool get_KeepLookingForDeclaredSpecialTypes();
    public virtual ICollection`1<string> get_TypeNames();
    public virtual ICollection`1<string> get_NamespaceNames();
    internal virtual Symbol GetDeclaredSpecialTypeMember(SpecialMember member);
    protected IVTConclusion MakeFinalIVTDetermination(AssemblySymbol potentialGiverOfAccess);
    private ConcurrentDictionary`2<AssemblySymbol, IVTConclusion> get_AssembliesToWhichInternalAccessHasBeenDetermined();
}
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.MethodBodySynthesizer : object {
    internal static BoundBlock ConstructSingleInvocationMethodBody(SyntheticBoundNodeFactory F, MethodSymbol methodToInvoke, bool useBaseReference);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol : Symbol {
    internal static MethodSymbol None;
    internal static Func`2<TypeSymbol, bool> TypeSymbolIsNullFunction;
    private ParameterSignature _lazyParameterSignature;
    private IGenericMethodInstanceReference Microsoft.Cci.IMethodReference.AsGenericMethodInstanceReference { get; }
    private ISpecializedMethodReference Microsoft.Cci.IMethodReference.AsSpecializedMethodReference { get; }
    private string Microsoft.Cci.INamedEntity.Name { get; }
    private bool Microsoft.Cci.IMethodReference.AcceptsExtraArguments { get; }
    private ushort Microsoft.Cci.IMethodReference.GenericParameterCount { get; }
    private bool Microsoft.Cci.IMethodReference.IsGeneric { get; }
    private ushort Microsoft.Cci.ISignature.ParameterCount { get; }
    private ImmutableArray`1<IParameterTypeInformation> Microsoft.Cci.IMethodReference.ExtraParameters { get; }
    private CallingConvention Microsoft.Cci.ISignature.CallingConvention { get; }
    private ImmutableArray`1<ICustomModifier> Microsoft.Cci.ISignature.ReturnValueCustomModifiers { get; }
    private bool Microsoft.Cci.ISignature.ReturnValueIsByRef { get; }
    private IMethodReference Microsoft.Cci.ISpecializedMethodReference.UnspecializedVersion { get; }
    private ITypeDefinition Microsoft.Cci.ITypeDefinitionMember.ContainingTypeDefinition { get; }
    private TypeMemberVisibility Microsoft.Cci.ITypeDefinitionMember.Visibility { get; }
    private IEnumerable`1<IGenericMethodParameter> Microsoft.Cci.IMethodDefinition.GenericParameters { get; }
    private bool Microsoft.Cci.IMethodDefinition.HasDeclarativeSecurity { get; }
    private IEnumerable`1<SecurityAttribute> Microsoft.Cci.IMethodDefinition.SecurityAttributes { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsAbstract { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsAccessCheckedOnOverride { get; }
    internal bool IsAccessCheckedOnOverride { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsConstructor { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsExternal { get; }
    internal bool IsExternal { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsHiddenBySignature { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsNewSlot { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsPlatformInvoke { get; }
    private IPlatformInvokeInformation Microsoft.Cci.IMethodDefinition.PlatformInvokeData { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsRuntimeSpecial { get; }
    internal bool HasRuntimeSpecialName { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsSealed { get; }
    internal bool IsMetadataFinal { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsSpecialName { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsStatic { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsVirtual { get; }
    private ImmutableArray`1<IParameterDefinition> Microsoft.Cci.IMethodDefinition.Parameters { get; }
    private bool Microsoft.Cci.IMethodDefinition.RequiresSecurityObject { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IMethodDefinition.ReturnValueAttributes { get; }
    private bool Microsoft.Cci.IMethodDefinition.ReturnValueIsMarshalledExplicitly { get; }
    internal bool ReturnValueIsMarshalledExplicitly { get; }
    private IMarshallingInformation Microsoft.Cci.IMethodDefinition.ReturnValueMarshallingInformation { get; }
    private ImmutableArray`1<byte> Microsoft.Cci.IMethodDefinition.ReturnValueMarshallingDescriptor { get; }
    internal ImmutableArray`1<byte> ReturnValueMarshallingDescriptor { get; }
    private INamespace Microsoft.Cci.IMethodDefinition.ContainingNamespace { get; }
    public MethodSymbol OriginalDefinition { get; }
    protected Symbol OriginalSymbolDefinition { get; }
    public MethodKind MethodKind { get; }
    public int Arity { get; }
    public bool IsGenericMethod { get; }
    public bool IsExtensionMethod { get; }
    internal bool HasSpecialName { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal MarshalPseudoCustomAttributeData ReturnValueMarshallingInformation { get; }
    internal bool RequiresSecurityObject { get; }
    public bool HidesBaseMethodsByName { get; }
    public bool IsVararg { get; }
    public bool IsCheckedBuiltin { get; }
    public bool ReturnsVoid { get; }
    public bool IsAsync { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    internal ParameterSymbol ThisParameter { get; }
    internal int ParameterCount { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public MethodSymbol ConstructedFrom { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public Symbol AssociatedSymbol { get; }
    public MethodSymbol OverriddenMethod { get; }
    internal bool IsConditional { get; }
    internal OverriddenOrHiddenMembersResult OverriddenOrHiddenMembers { get; }
    public SymbolKind Kind { get; }
    internal bool IsScriptConstructor { get; }
    internal bool IsScriptInitializer { get; }
    internal bool IsImplicitConstructor { get; }
    internal bool IsImplicitInstanceConstructor { get; }
    internal bool IsSubmissionConstructor { get; }
    internal bool IsSubmissionInitializer { get; }
    internal bool IsEntryPointCandidate { get; }
    internal MethodSymbol CallsiteReducedFromMethod { get; }
    public MethodSymbol PartialImplementationPart { get; }
    public MethodSymbol PartialDefinitionPart { get; }
    public MethodSymbol ReducedFrom { get; }
    public TypeSymbol ReceiverType { get; }
    internal ImmutableArray`1<TypeSymbol> ParameterTypes { get; }
    internal ImmutableArray`1<RefKind> ParameterRefKinds { get; }
    internal CallingConvention CallingConvention { get; }
    internal TypeMap TypeSubstitution { get; }
    protected int HighestPriorityUseSiteError { get; }
    public bool HasUnsupportedMetadata { get; }
    internal bool IsIterator { get; }
    internal TypeSymbol IteratorElementType { get; internal set; }
    internal bool SynthesizesLoweredBoundBody { get; }
    internal bool GenerateDebugInfo { get; }
    private MethodKind Microsoft.CodeAnalysis.IMethodSymbol.MethodKind { get; }
    private ITypeSymbol Microsoft.CodeAnalysis.IMethodSymbol.ReturnType { get; }
    private ImmutableArray`1<ITypeSymbol> Microsoft.CodeAnalysis.IMethodSymbol.TypeArguments { get; }
    private ImmutableArray`1<ITypeParameterSymbol> Microsoft.CodeAnalysis.IMethodSymbol.TypeParameters { get; }
    private ImmutableArray`1<IParameterSymbol> Microsoft.CodeAnalysis.IMethodSymbol.Parameters { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.IMethodSymbol.ConstructedFrom { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.IMethodSymbol.OriginalDefinition { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.IMethodSymbol.OverriddenMethod { get; }
    private ITypeSymbol Microsoft.CodeAnalysis.IMethodSymbol.ReceiverType { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.IMethodSymbol.ReducedFrom { get; }
    private ImmutableArray`1<IMethodSymbol> Microsoft.CodeAnalysis.IMethodSymbol.ExplicitInterfaceImplementations { get; }
    private ISymbol Microsoft.CodeAnalysis.IMethodSymbol.AssociatedSymbol { get; }
    private bool Microsoft.CodeAnalysis.IMethodSymbol.IsGenericMethod { get; }
    private bool Microsoft.CodeAnalysis.IMethodSymbol.IsAsync { get; }
    private bool Microsoft.CodeAnalysis.IMethodSymbol.HidesBaseMethodsByName { get; }
    private ImmutableArray`1<CustomModifier> Microsoft.CodeAnalysis.IMethodSymbol.ReturnTypeCustomModifiers { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.IMethodSymbol.PartialImplementationPart { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.IMethodSymbol.PartialDefinitionPart { get; }
    private INamedTypeSymbol Microsoft.CodeAnalysis.IMethodSymbol.AssociatedAnonymousDelegate { get; }
    private bool Microsoft.CodeAnalysis.Symbols.IMethodSymbolInternal.IsIterator { get; }
    private static MethodSymbol();
    private sealed virtual override IGenericMethodInstanceReference Microsoft.Cci.IMethodReference.get_AsGenericMethodInstanceReference();
    private sealed virtual override ISpecializedMethodReference Microsoft.Cci.IMethodReference.get_AsSpecializedMethodReference();
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
    private sealed virtual override ITypeReference Microsoft.Cci.ITypeMemberReference.GetContainingType(EmitContext context);
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override string Microsoft.Cci.INamedEntity.get_Name();
    private sealed virtual override bool Microsoft.Cci.IMethodReference.get_AcceptsExtraArguments();
    private sealed virtual override ushort Microsoft.Cci.IMethodReference.get_GenericParameterCount();
    private sealed virtual override bool Microsoft.Cci.IMethodReference.get_IsGeneric();
    private sealed virtual override ushort Microsoft.Cci.ISignature.get_ParameterCount();
    private sealed virtual override IMethodDefinition Microsoft.Cci.IMethodReference.GetResolvedMethod(EmitContext context);
    private IMethodDefinition ResolvedMethodImpl(EmitContext context);
    private sealed virtual override ImmutableArray`1<IParameterTypeInformation> Microsoft.Cci.IMethodReference.get_ExtraParameters();
    private sealed virtual override CallingConvention Microsoft.Cci.ISignature.get_CallingConvention();
    private sealed virtual override ImmutableArray`1<IParameterTypeInformation> Microsoft.Cci.ISignature.GetParameters(EmitContext context);
    private ImmutableArray`1<IParameterDefinition> EnumerateDefinitionParameters();
    private sealed virtual override ImmutableArray`1<ICustomModifier> Microsoft.Cci.ISignature.get_ReturnValueCustomModifiers();
    private sealed virtual override bool Microsoft.Cci.ISignature.get_ReturnValueIsByRef();
    private sealed virtual override ITypeReference Microsoft.Cci.ISignature.GetType(EmitContext context);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol/<Microsoft-Cci-IGenericMethodInstanceReference-GetGenericArguments>d__30")]
private sealed virtual override IEnumerable`1<ITypeReference> Microsoft.Cci.IGenericMethodInstanceReference.GetGenericArguments(EmitContext context);
    private sealed virtual override IMethodReference Microsoft.Cci.IGenericMethodInstanceReference.GetGenericMethod(EmitContext context);
    private sealed virtual override IMethodReference Microsoft.Cci.ISpecializedMethodReference.get_UnspecializedVersion();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeDefinitionMember.get_ContainingTypeDefinition();
    private sealed virtual override TypeMemberVisibility Microsoft.Cci.ITypeDefinitionMember.get_Visibility();
    private sealed virtual override IMethodBody Microsoft.Cci.IMethodDefinition.GetBody(EmitContext context);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol/<Microsoft-Cci-IMethodDefinition-get_GenericParameters>d__40")]
private sealed virtual override IEnumerable`1<IGenericMethodParameter> Microsoft.Cci.IMethodDefinition.get_GenericParameters();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_HasDeclarativeSecurity();
    private sealed virtual override IEnumerable`1<SecurityAttribute> Microsoft.Cci.IMethodDefinition.get_SecurityAttributes();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsAbstract();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsAccessCheckedOnOverride();
    internal virtual bool get_IsAccessCheckedOnOverride();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsConstructor();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsExternal();
    internal virtual bool get_IsExternal();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsHiddenBySignature();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsNewSlot();
    internal abstract virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsPlatformInvoke();
    private sealed virtual override IPlatformInvokeInformation Microsoft.Cci.IMethodDefinition.get_PlatformInvokeData();
    private sealed virtual override MethodImplAttributes Microsoft.Cci.IMethodDefinition.GetImplementationAttributes(EmitContext context);
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsRuntimeSpecial();
    internal virtual bool get_HasRuntimeSpecialName();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsSealed();
    internal virtual bool get_IsMetadataFinal();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsSpecialName();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsStatic();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsVirtual();
    internal abstract virtual bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges);
    private sealed virtual override ImmutableArray`1<IParameterDefinition> Microsoft.Cci.IMethodDefinition.get_Parameters();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_RequiresSecurityObject();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IMethodDefinition.get_ReturnValueAttributes();
    private IEnumerable`1<CSharpAttributeData> GetReturnValueCustomAttributesToEmit();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_ReturnValueIsMarshalledExplicitly();
    internal virtual bool get_ReturnValueIsMarshalledExplicitly();
    private sealed virtual override IMarshallingInformation Microsoft.Cci.IMethodDefinition.get_ReturnValueMarshallingInformation();
    private sealed virtual override ImmutableArray`1<byte> Microsoft.Cci.IMethodDefinition.get_ReturnValueMarshallingDescriptor();
    internal virtual ImmutableArray`1<byte> get_ReturnValueMarshallingDescriptor();
    private sealed virtual override INamespace Microsoft.Cci.IMethodDefinition.get_ContainingNamespace();
    public virtual MethodSymbol get_OriginalDefinition();
    protected sealed virtual Symbol get_OriginalSymbolDefinition();
    public abstract virtual MethodKind get_MethodKind();
    public abstract virtual int get_Arity();
    public virtual bool get_IsGenericMethod();
    public abstract virtual bool get_IsExtensionMethod();
    internal abstract virtual bool get_HasSpecialName();
    internal abstract virtual MethodImplAttributes get_ImplementationAttributes();
    internal abstract virtual bool get_HasDeclarativeSecurity();
    public abstract virtual DllImportData GetDllImportData();
    internal abstract virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal abstract virtual MarshalPseudoCustomAttributeData get_ReturnValueMarshallingInformation();
    internal abstract virtual bool get_RequiresSecurityObject();
    public abstract virtual bool get_HidesBaseMethodsByName();
    public abstract virtual bool get_IsVararg();
    public virtual bool get_IsCheckedBuiltin();
    public abstract virtual bool get_ReturnsVoid();
    public abstract virtual bool get_IsAsync();
    public abstract virtual TypeSymbol get_ReturnType();
    public abstract virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public abstract virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal ParameterSymbol get_ThisParameter();
    internal virtual bool TryGetThisParameter(ParameterSymbol& thisParameter);
    internal virtual int get_ParameterCount();
    public abstract virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual MethodSymbol get_ConstructedFrom();
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public abstract virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public abstract virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual ImmutableArray`1<CSharpAttributeData> GetReturnTypeAttributes();
    public abstract virtual Symbol get_AssociatedSymbol();
    internal MethodSymbol GetLeastOverriddenMethod(NamedTypeSymbol accessingTypeOpt);
    internal MethodSymbol GetConstructedLeastOverriddenMethod(NamedTypeSymbol accessingTypeOpt);
    public MethodSymbol get_OverriddenMethod();
    internal virtual bool CallsAreOmitted(SyntaxTree syntaxTree);
    private bool CallsAreConditionallyOmitted(SyntaxTree syntaxTree);
    internal abstract virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal bool get_IsConditional();
    internal static bool CanOverrideOrHide(MethodKind kind);
    internal virtual OverriddenOrHiddenMembersResult get_OverriddenOrHiddenMembers();
    public sealed virtual SymbolKind get_Kind();
    internal bool get_IsScriptConstructor();
    internal virtual bool get_IsScriptInitializer();
    internal bool get_IsImplicitConstructor();
    internal bool get_IsImplicitInstanceConstructor();
    internal bool get_IsSubmissionConstructor();
    internal bool get_IsSubmissionInitializer();
    internal bool get_IsEntryPointCandidate();
    internal bool HasEntryPointSignature();
    internal virtual TResult Accept(CSharpSymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual void Accept(CSharpSymbolVisitor visitor);
    public virtual TResult Accept(CSharpSymbolVisitor`1<TResult> visitor);
    public MethodSymbol ReduceExtensionMethod(TypeSymbol receiverType);
    public MethodSymbol ReduceExtensionMethod();
    internal virtual MethodSymbol get_CallsiteReducedFromMethod();
    public virtual MethodSymbol get_PartialImplementationPart();
    public virtual MethodSymbol get_PartialDefinitionPart();
    public virtual MethodSymbol get_ReducedFrom();
    public virtual TypeSymbol get_ReceiverType();
    public virtual TypeSymbol GetTypeInferredDuringReduction(TypeParameterSymbol reducedFromTypeParameter);
    public MethodSymbol Construct(TypeSymbol[] typeArguments);
    public MethodSymbol Construct(ImmutableArray`1<TypeSymbol> typeArguments);
    internal static bool TypeParametersMatchTypeArguments(ImmutableArray`1<TypeParameterSymbol> typeParameters, ImmutableArray`1<TypeSymbol> typeArguments);
    internal MethodSymbol AsMember(NamedTypeSymbol newOwner);
    internal ImmutableArray`1<TypeSymbol> get_ParameterTypes();
    internal ImmutableArray`1<RefKind> get_ParameterRefKinds();
    internal abstract virtual CallingConvention get_CallingConvention();
    internal virtual TypeMap get_TypeSubstitution();
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    internal bool CalculateUseSiteDiagnostic(DiagnosticInfo& result);
    protected virtual int get_HighestPriorityUseSiteError();
    public sealed virtual bool get_HasUnsupportedMetadata();
    internal bool get_IsIterator();
    internal virtual TypeSymbol get_IteratorElementType();
    internal virtual void set_IteratorElementType(TypeSymbol value);
    internal virtual void GenerateMethodBody(TypeCompilationState compilationState, DiagnosticBag diagnostics);
    internal virtual bool get_SynthesizesLoweredBoundBody();
    internal abstract virtual bool get_GenerateDebugInfo();
    internal abstract virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    private sealed virtual override MethodKind Microsoft.CodeAnalysis.IMethodSymbol.get_MethodKind();
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.IMethodSymbol.get_ReturnType();
    private sealed virtual override ImmutableArray`1<ITypeSymbol> Microsoft.CodeAnalysis.IMethodSymbol.get_TypeArguments();
    private sealed virtual override ImmutableArray`1<ITypeParameterSymbol> Microsoft.CodeAnalysis.IMethodSymbol.get_TypeParameters();
    private sealed virtual override ImmutableArray`1<IParameterSymbol> Microsoft.CodeAnalysis.IMethodSymbol.get_Parameters();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.IMethodSymbol.get_ConstructedFrom();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.IMethodSymbol.get_OriginalDefinition();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.IMethodSymbol.get_OverriddenMethod();
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.IMethodSymbol.get_ReceiverType();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.IMethodSymbol.get_ReducedFrom();
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.IMethodSymbol.GetTypeInferredDuringReduction(ITypeParameterSymbol reducedFromTypeParameter);
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.IMethodSymbol.ReduceExtensionMethod(ITypeSymbol receiverType);
    private sealed virtual override ImmutableArray`1<IMethodSymbol> Microsoft.CodeAnalysis.IMethodSymbol.get_ExplicitInterfaceImplementations();
    private sealed virtual override ISymbol Microsoft.CodeAnalysis.IMethodSymbol.get_AssociatedSymbol();
    private sealed virtual override bool Microsoft.CodeAnalysis.IMethodSymbol.get_IsGenericMethod();
    private sealed virtual override bool Microsoft.CodeAnalysis.IMethodSymbol.get_IsAsync();
    private sealed virtual override bool Microsoft.CodeAnalysis.IMethodSymbol.get_HidesBaseMethodsByName();
    private sealed virtual override ImmutableArray`1<CustomModifier> Microsoft.CodeAnalysis.IMethodSymbol.get_ReturnTypeCustomModifiers();
    private sealed virtual override ImmutableArray`1<AttributeData> Microsoft.CodeAnalysis.IMethodSymbol.GetReturnTypeAttributes();
    internal virtual void AddSynthesizedReturnTypeAttributes(ArrayBuilder`1& attributes);
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.IMethodSymbol.Construct(ITypeSymbol[] arguments);
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.IMethodSymbol.get_PartialImplementationPart();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.IMethodSymbol.get_PartialDefinitionPart();
    private sealed virtual override INamedTypeSymbol Microsoft.CodeAnalysis.IMethodSymbol.get_AssociatedAnonymousDelegate();
    private sealed virtual override bool Microsoft.CodeAnalysis.Symbols.IMethodSymbolInternal.get_IsIterator();
    private sealed virtual override int Microsoft.CodeAnalysis.Symbols.IMethodSymbolInternal.CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsParams(MethodSymbol method);
    [ExtensionAttribute]
public static MethodSymbol InferExtensionMethodTypeArguments(MethodSymbol method, TypeSymbol thisType, Compilation compilation, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
internal static bool IsSynthesizedLambda(MethodSymbol method);
    [ExtensionAttribute]
public static bool IsRuntimeFinalizer(MethodSymbol method, bool skipFirstMethodKindCheck);
    [ExtensionAttribute]
public static MethodSymbol ConstructIfGeneric(MethodSymbol method, ImmutableArray`1<TypeSymbol> typeArguments);
    [ExtensionAttribute]
public static bool CanBeHiddenByMemberKind(MethodSymbol hiddenMethod, SymbolKind hidingMemberKind);
    private static bool CanBeHiddenByMethodPropertyOrType(MethodSymbol method);
    [ExtensionAttribute]
public static bool IsVoidReturningAsync(MethodSymbol method);
    [ExtensionAttribute]
public static bool IsTaskReturningAsync(MethodSymbol method, CSharpCompilation compilation);
    [ExtensionAttribute]
public static bool IsGenericTaskReturningAsync(MethodSymbol method, CSharpCompilation compilation);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter : BoundTreeRewriterWithStackGuard {
    protected Dictionary`2<Symbol, CapturedSymbolReplacement> proxies;
    protected Dictionary`2<LocalSymbol, LocalSymbol> localMap;
    protected TypeCompilationState CompilationState;
    protected DiagnosticBag Diagnostics;
    protected VariableSlotAllocator slotAllocatorOpt;
    protected TypeMap TypeMap { get; }
    protected MethodSymbol CurrentMethod { get; }
    protected NamedTypeSymbol ContainingType { get; }
    protected MethodToClassRewriter(VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics);
    protected abstract virtual TypeMap get_TypeMap();
    protected abstract virtual BoundExpression FramePointer(CSharpSyntaxNode syntax, NamedTypeSymbol frameClass);
    protected abstract virtual MethodSymbol get_CurrentMethod();
    protected abstract virtual NamedTypeSymbol get_ContainingType();
    protected abstract virtual bool NeedsProxy(Symbol localOrParameter);
    protected void RewriteLocals(ImmutableArray`1<LocalSymbol> locals, ArrayBuilder`1<LocalSymbol> newLocals);
    protected bool TryRewriteLocal(LocalSymbol local, LocalSymbol& newLocal);
    private ImmutableArray`1<LocalSymbol> RewriteLocals(ImmutableArray`1<LocalSymbol> locals);
    public virtual BoundNode VisitCatchBlock(BoundCatchBlock node);
    public virtual BoundNode VisitBlock(BoundBlock node);
    public virtual BoundNode VisitSequence(BoundSequence node);
    public virtual BoundNode VisitSwitchStatement(BoundSwitchStatement node);
    public virtual BoundNode VisitForStatement(BoundForStatement node);
    public virtual BoundNode VisitUsingStatement(BoundUsingStatement node);
    private Conversion RewriteConversion(Conversion conversion);
    public sealed virtual TypeSymbol VisitType(TypeSymbol type);
    public virtual BoundNode VisitMethodInfo(BoundMethodInfo node);
    public virtual BoundNode VisitPropertyAccess(BoundPropertyAccess node);
    public virtual BoundNode VisitCall(BoundCall node);
    private MethodSymbol GetMethodWrapperForBaseNonVirtualCall(MethodSymbol methodBeingCalled, CSharpSyntaxNode syntax);
    private MethodSymbol GetOrCreateBaseFunctionWrapper(MethodSymbol methodBeingWrapped, CSharpSyntaxNode syntax);
    private bool TryReplaceWithProxy(Symbol parameterOrLocal, CSharpSyntaxNode syntax, BoundNode& replacement);
    public sealed virtual BoundNode VisitParameter(BoundParameter node);
    protected virtual BoundNode VisitUnhoistedParameter(BoundParameter node);
    public sealed virtual BoundNode VisitLocal(BoundLocal node);
    private BoundNode VisitUnhoistedLocal(BoundLocal node);
    public virtual BoundNode VisitAwaitExpression(BoundAwaitExpression node);
    public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node);
    private static bool IsStackAlloc(BoundExpression expr);
    public virtual BoundNode VisitFieldInfo(BoundFieldInfo node);
    public virtual BoundNode VisitFieldAccess(BoundFieldAccess node);
    public virtual BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node);
    public virtual BoundNode VisitConversion(BoundConversion conversion);
    public virtual BoundNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node);
    protected MethodSymbol VisitMethodSymbol(MethodSymbol method);
    private PropertySymbol VisitPropertySymbol(PropertySymbol property);
    private FieldSymbol VisitFieldSymbol(FieldSymbol field);
    public virtual BoundNode VisitObjectInitializerMember(BoundObjectInitializerMember node);
    private static bool BaseReferenceInReceiverWasRewritten(BoundExpression originalReceiver, BoundExpression rewrittenReceiver);
    private BoundNode RewriteMethodGroupConversion(BoundConversion conversion);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.MissingAssemblySymbol : AssemblySymbol {
    protected AssemblyIdentity identity;
    protected MissingModuleSymbol moduleSymbol;
    private ImmutableArray`1<ModuleSymbol> _lazyModules;
    internal bool IsMissing { get; }
    internal bool IsLinked { get; }
    public AssemblyIdentity Identity { get; }
    public Version AssemblyVersionPattern { get; }
    internal ImmutableArray`1<byte> PublicKey { get; }
    public ImmutableArray`1<ModuleSymbol> Modules { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public NamespaceSymbol GlobalNamespace { get; }
    public ICollection`1<string> TypeNames { get; }
    public ICollection`1<string> NamespaceNames { get; }
    public bool MightContainExtensionMethods { get; }
    public MissingAssemblySymbol(AssemblyIdentity identity);
    internal sealed virtual bool get_IsMissing();
    internal virtual bool get_IsLinked();
    internal virtual Symbol GetDeclaredSpecialTypeMember(SpecialMember member);
    public virtual AssemblyIdentity get_Identity();
    public virtual Version get_AssemblyVersionPattern();
    internal virtual ImmutableArray`1<byte> get_PublicKey();
    public virtual ImmutableArray`1<ModuleSymbol> get_Modules();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(MissingAssemblySymbol other);
    public virtual ImmutableArray`1<Location> get_Locations();
    internal virtual void SetLinkedReferencedAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal virtual ImmutableArray`1<AssemblySymbol> GetLinkedReferencedAssemblies();
    internal virtual void SetNoPiaResolutionAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal virtual ImmutableArray`1<AssemblySymbol> GetNoPiaResolutionAssemblies();
    public sealed virtual NamespaceSymbol get_GlobalNamespace();
    public virtual ICollection`1<string> get_TypeNames();
    public virtual ICollection`1<string> get_NamespaceNames();
    internal virtual NamedTypeSymbol LookupTopLevelMetadataTypeWithCycleDetection(MetadataTypeName& emittedName, ConsList`1<AssemblySymbol> visitedAssemblies, bool digThroughForwardedTypes);
    internal virtual NamedTypeSymbol GetDeclaredSpecialType(SpecialType type);
    internal virtual bool AreInternalsVisibleToThisAssembly(AssemblySymbol other);
    internal virtual IEnumerable`1<ImmutableArray`1<byte>> GetInternalsVisibleToPublicKeys(string simpleName);
    public virtual bool get_MightContainExtensionMethods();
    public virtual AssemblyMetadata GetMetadata();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.MissingCorLibrarySymbol : MissingAssemblySymbol {
    internal static MissingCorLibrarySymbol Instance;
    private NamedTypeSymbol[] _lazySpecialTypes;
    private static MissingCorLibrarySymbol();
    internal virtual NamedTypeSymbol GetDeclaredSpecialType(SpecialType type);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.MissingMetadataTypeSymbol : ErrorTypeSymbol {
    protected string name;
    protected int arity;
    protected bool mangleName;
    public string Name { get; }
    internal bool MangleName { get; }
    public int Arity { get; }
    internal DiagnosticInfo ErrorInfo { get; }
    private MissingMetadataTypeSymbol(string name, int arity, bool mangleName);
    public virtual string get_Name();
    internal virtual bool get_MangleName();
    public virtual int get_Arity();
    internal virtual DiagnosticInfo get_ErrorInfo();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.MissingModuleSymbol : ModuleSymbol {
    protected AssemblySymbol assembly;
    protected int ordinal;
    protected MissingNamespaceSymbol globalNamespace;
    internal int Ordinal { get; }
    internal Machine Machine { get; }
    internal bool Bit32Required { get; }
    internal bool IsMissing { get; }
    public string Name { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public Symbol ContainingSymbol { get; }
    public NamespaceSymbol GlobalNamespace { get; }
    public ImmutableArray`1<Location> Locations { get; }
    internal ICollection`1<string> NamespaceNames { get; }
    internal ICollection`1<string> TypeNames { get; }
    internal bool HasUnifiedReferences { get; }
    internal bool HasAssemblyCompilationRelaxationsAttribute { get; }
    internal bool HasAssemblyRuntimeCompatibilityAttribute { get; }
    internal Nullable`1<CharSet> DefaultMarshallingCharSet { get; }
    public MissingModuleSymbol(AssemblySymbol assembly, int ordinal);
    internal virtual int get_Ordinal();
    internal virtual Machine get_Machine();
    internal virtual bool get_Bit32Required();
    internal sealed virtual bool get_IsMissing();
    public virtual string get_Name();
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamespaceSymbol get_GlobalNamespace();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual ImmutableArray`1<Location> get_Locations();
    internal virtual ICollection`1<string> get_NamespaceNames();
    internal virtual ICollection`1<string> get_TypeNames();
    internal virtual NamedTypeSymbol LookupTopLevelMetadataType(MetadataTypeName& emittedName);
    internal virtual ImmutableArray`1<AssemblyIdentity> GetReferencedAssemblies();
    internal virtual ImmutableArray`1<AssemblySymbol> GetReferencedAssemblySymbols();
    internal virtual void SetReferences(ModuleReferences`1<AssemblySymbol> moduleReferences, SourceAssemblySymbol originatingSourceAssemblyDebugOnly);
    internal virtual bool get_HasUnifiedReferences();
    internal virtual bool GetUnificationUseSiteDiagnostic(DiagnosticInfo& result, TypeSymbol dependentType);
    internal virtual bool get_HasAssemblyCompilationRelaxationsAttribute();
    internal virtual bool get_HasAssemblyRuntimeCompatibilityAttribute();
    internal virtual Nullable`1<CharSet> get_DefaultMarshallingCharSet();
    public virtual ModuleMetadata GetMetadata();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.MissingModuleSymbolWithName : MissingModuleSymbol {
    private string _name;
    public string Name { get; }
    public MissingModuleSymbolWithName(AssemblySymbol assembly, string name);
    public virtual string get_Name();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.MissingNamespaceSymbol : NamespaceSymbol {
    private string _name;
    private Symbol _containingSymbol;
    public string Name { get; }
    public Symbol ContainingSymbol { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal NamespaceExtent Extent { get; }
    internal ModuleSymbol ContainingModule { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public MissingNamespaceSymbol(MissingModuleSymbol containingModule);
    public MissingNamespaceSymbol(NamespaceSymbol containingNamespace, string name);
    public virtual string get_Name();
    public virtual Symbol get_ContainingSymbol();
    public virtual AssemblySymbol get_ContainingAssembly();
    internal virtual NamespaceExtent get_Extent();
    internal virtual ModuleSymbol get_ContainingModule();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public virtual ImmutableArray`1<Symbol> GetMembers();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.ModifierUtils : object {
    internal static DeclarationModifiers MakeAndCheckNontypeMemberModifiers(SyntaxTokenList modifiers, DeclarationModifiers defaultAccess, DeclarationModifiers allowedModifiers, Location errorLocation, DiagnosticBag diagnostics, Boolean& modifierErrors, bool ignoreParameterModifiers);
    internal static DeclarationModifiers CheckModifiers(DeclarationModifiers modifiers, DeclarationModifiers allowedModifiers, Location errorLocation, DiagnosticBag diagnostics, Boolean& modifierErrors);
    private static string ConvertSingleModifierToSyntaxText(DeclarationModifiers modifier);
    [ExtensionAttribute]
public static DeclarationModifiers ToDeclarationModifiers(SyntaxTokenList modifiers, bool ignoreParameterModifiers);
    internal static CSDiagnosticInfo CheckAccessibility(DeclarationModifiers modifiers);
    internal static Accessibility EffectiveAccessibility(DeclarationModifiers modifiers);
    internal static bool IsValidAccessibility(DeclarationModifiers modifiers);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol : Symbol {
    public NamespaceSymbol GlobalNamespace { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal ModuleSymbol ContainingModule { get; }
    public SymbolKind Kind { get; }
    internal int Ordinal { get; }
    internal Machine Machine { get; }
    internal bool Bit32Required { get; }
    internal bool IsMissing { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public ImmutableArray`1<AssemblyIdentity> ReferencedAssemblies { get; }
    public ImmutableArray`1<AssemblySymbol> ReferencedAssemblySymbols { get; }
    internal bool HasUnifiedReferences { get; }
    internal ICollection`1<string> TypeNames { get; }
    internal ICollection`1<string> NamespaceNames { get; }
    internal bool HasAssemblyCompilationRelaxationsAttribute { get; }
    internal bool HasAssemblyRuntimeCompatibilityAttribute { get; }
    internal Nullable`1<CharSet> DefaultMarshallingCharSet { get; }
    private INamespaceSymbol Microsoft.CodeAnalysis.IModuleSymbol.GlobalNamespace { get; }
    private ImmutableArray`1<IAssemblySymbol> Microsoft.CodeAnalysis.IModuleSymbol.ReferencedAssemblySymbols { get; }
    public abstract virtual NamespaceSymbol get_GlobalNamespace();
    public virtual AssemblySymbol get_ContainingAssembly();
    internal sealed virtual ModuleSymbol get_ContainingModule();
    public sealed virtual SymbolKind get_Kind();
    internal virtual TResult Accept(CSharpSymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual void Accept(CSharpSymbolVisitor visitor);
    public virtual TResult Accept(CSharpSymbolVisitor`1<TResult> visitor);
    internal abstract virtual int get_Ordinal();
    internal abstract virtual Machine get_Machine();
    internal abstract virtual bool get_Bit32Required();
    internal abstract virtual bool get_IsMissing();
    public sealed virtual Accessibility get_DeclaredAccessibility();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsExtern();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public sealed virtual ImmutableArray`1<AssemblyIdentity> get_ReferencedAssemblies();
    internal abstract virtual ImmutableArray`1<AssemblyIdentity> GetReferencedAssemblies();
    public ImmutableArray`1<AssemblySymbol> get_ReferencedAssemblySymbols();
    internal abstract virtual ImmutableArray`1<AssemblySymbol> GetReferencedAssemblySymbols();
    internal abstract virtual void SetReferences(ModuleReferences`1<AssemblySymbol> moduleReferences, SourceAssemblySymbol originatingSourceAssemblyDebugOnly);
    internal abstract virtual bool get_HasUnifiedReferences();
    internal abstract virtual bool GetUnificationUseSiteDiagnostic(DiagnosticInfo& result, TypeSymbol dependentType);
    internal abstract virtual NamedTypeSymbol LookupTopLevelMetadataType(MetadataTypeName& emittedName);
    internal abstract virtual ICollection`1<string> get_TypeNames();
    internal abstract virtual ICollection`1<string> get_NamespaceNames();
    internal abstract virtual bool get_HasAssemblyCompilationRelaxationsAttribute();
    internal abstract virtual bool get_HasAssemblyRuntimeCompatibilityAttribute();
    internal abstract virtual Nullable`1<CharSet> get_DefaultMarshallingCharSet();
    internal virtual ImmutableArray`1<byte> GetHash(AssemblyHashAlgorithm algorithmId);
    public NamespaceSymbol GetModuleNamespace(INamespaceSymbol namespaceSymbol);
    private sealed virtual override INamespaceSymbol Microsoft.CodeAnalysis.IModuleSymbol.get_GlobalNamespace();
    private sealed virtual override INamespaceSymbol Microsoft.CodeAnalysis.IModuleSymbol.GetModuleNamespace(INamespaceSymbol namespaceSymbol);
    private sealed virtual override ImmutableArray`1<IAssemblySymbol> Microsoft.CodeAnalysis.IModuleSymbol.get_ReferencedAssemblySymbols();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public abstract virtual ModuleMetadata GetMetadata();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.MutableTypeMap : AbstractTypeParameterMap {
    internal void Add(TypeParameterSymbol key, TypeWithModifiers value);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol : TypeSymbol {
    private bool _hasNoBaseCycles;
    protected static Func`2<Symbol, bool> IsInstanceFieldOrEvent;
    internal static Func`2<TypeWithModifiers, bool> TypeSymbolIsNullFunction;
    internal static Func`2<TypeWithModifiers, bool> TypeSymbolIsErrorType;
    private bool Microsoft.Cci.ITypeReference.IsEnum { get; }
    private bool Microsoft.Cci.ITypeReference.IsValueType { get; }
    private TypeDefinitionHandle Microsoft.Cci.ITypeReference.TypeDef { get; }
    private IGenericMethodParameterReference Microsoft.Cci.ITypeReference.AsGenericMethodParameterReference { get; }
    private IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.AsGenericTypeInstanceReference { get; }
    private IGenericTypeParameterReference Microsoft.Cci.ITypeReference.AsGenericTypeParameterReference { get; }
    private INamespaceTypeReference Microsoft.Cci.ITypeReference.AsNamespaceTypeReference { get; }
    private INestedTypeReference Microsoft.Cci.ITypeReference.AsNestedTypeReference { get; }
    private ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.AsSpecializedNestedTypeReference { get; }
    private IEnumerable`1<IEventDefinition> Microsoft.Cci.ITypeDefinition.Events { get; }
    private IEnumerable`1<IGenericTypeParameter> Microsoft.Cci.ITypeDefinition.GenericParameters { get; }
    private ushort Microsoft.Cci.ITypeDefinition.GenericParameterCount { get; }
    private ushort GenericParameterCountImpl { get; }
    private bool Microsoft.Cci.ITypeDefinition.IsAbstract { get; }
    internal bool IsMetadataAbstract { get; }
    private bool Microsoft.Cci.ITypeDefinition.IsBeforeFieldInit { get; }
    private bool Microsoft.Cci.ITypeDefinition.IsComObject { get; }
    private bool Microsoft.Cci.ITypeDefinition.IsGeneric { get; }
    private bool Microsoft.Cci.ITypeDefinition.IsInterface { get; }
    private bool Microsoft.Cci.ITypeDefinition.IsRuntimeSpecial { get; }
    private bool Microsoft.Cci.ITypeDefinition.IsSerializable { get; }
    private bool Microsoft.Cci.ITypeDefinition.IsSpecialName { get; }
    private bool Microsoft.Cci.ITypeDefinition.IsWindowsRuntimeImport { get; }
    private bool Microsoft.Cci.ITypeDefinition.IsSealed { get; }
    internal bool IsMetadataSealed { get; }
    private bool Microsoft.Cci.ITypeDefinition.HasDeclarativeSecurity { get; }
    private IEnumerable`1<SecurityAttribute> Microsoft.Cci.ITypeDefinition.SecurityAttributes { get; }
    private ushort Microsoft.Cci.ITypeDefinition.Alignment { get; }
    private LayoutKind Microsoft.Cci.ITypeDefinition.Layout { get; }
    private UInt32 Microsoft.Cci.ITypeDefinition.SizeOf { get; }
    private CharSet Microsoft.Cci.ITypeDefinition.StringFormat { get; }
    private ushort Microsoft.Cci.INamedTypeReference.GenericParameterCount { get; }
    private bool Microsoft.Cci.INamedTypeReference.MangleName { get; }
    private string Microsoft.Cci.INamedEntity.Name { get; }
    private string Microsoft.Cci.INamespaceTypeReference.NamespaceName { get; }
    private bool Microsoft.Cci.INamespaceTypeDefinition.IsPublic { get; }
    private ITypeDefinition Microsoft.Cci.ITypeDefinitionMember.ContainingTypeDefinition { get; }
    private TypeMemberVisibility Microsoft.Cci.ITypeDefinitionMember.Visibility { get; }
    private INamedTypeReference Microsoft.Cci.IGenericTypeInstanceReference.GenericType { get; }
    private INamedTypeReference GenericTypeImpl { get; }
    private INestedTypeReference Microsoft.Cci.ISpecializedNestedTypeReference.UnspecializedVersion { get; }
    public int Arity { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    internal ImmutableArray`1<ImmutableArray`1<CustomModifier>> TypeArgumentsCustomModifiers { get; }
    internal bool HasTypeArgumentsCustomModifiers { get; }
    internal ImmutableArray`1<TypeSymbol> TypeArgumentsNoUseSiteDiagnostics { get; }
    public NamedTypeSymbol ConstructedFrom { get; }
    public NamedTypeSymbol EnumUnderlyingType { get; }
    public NamedTypeSymbol ContainingType { get; }
    internal bool KnownCircularStruct { get; }
    internal bool KnownToHaveNoDeclaredBaseCycles { get; }
    internal bool IsExplicitDefinitionOfNoPiaLocalType { get; }
    public MethodSymbol DelegateInvokeMethod { get; }
    public ImmutableArray`1<MethodSymbol> InstanceConstructors { get; }
    public ImmutableArray`1<MethodSymbol> StaticConstructors { get; }
    public ImmutableArray`1<MethodSymbol> Constructors { get; }
    public ImmutableArray`1<PropertySymbol> Indexers { get; }
    public bool MightContainExtensionMethods { get; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    internal bool IsManagedType { get; }
    public bool IsScriptClass { get; }
    internal bool IsSubmissionClass { get; }
    public bool IsImplicitClass { get; }
    public string Name { get; }
    public string MetadataName { get; }
    internal bool MangleName { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public Accessibility DeclaredAccessibility { get; }
    public SymbolKind Kind { get; }
    public bool IsGenericType { get; }
    public bool IsUnboundGenericType { get; }
    public NamedTypeSymbol OriginalDefinition { get; }
    protected TypeSymbol OriginalTypeSymbolDefinition { get; }
    internal TypeMap TypeSubstitution { get; }
    internal bool HasSpecialName { get; }
    internal bool IsComImport { get; }
    internal bool IsWindowsRuntimeImport { get; }
    internal bool ShouldAddWinRTMembers { get; }
    internal bool IsConditional { get; }
    internal bool IsSerializable { get; }
    internal TypeLayout Layout { get; }
    protected CharSet DefaultMarshallingCharSet { get; }
    internal CharSet MarshallingCharSet { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal NamedTypeSymbol ComImportCoClass { get; }
    internal FieldSymbol FixedElementField { get; }
    internal bool IsInterface { get; }
    private int Microsoft.CodeAnalysis.INamedTypeSymbol.Arity { get; }
    private ImmutableArray`1<IMethodSymbol> Microsoft.CodeAnalysis.INamedTypeSymbol.InstanceConstructors { get; }
    private ImmutableArray`1<IMethodSymbol> Microsoft.CodeAnalysis.INamedTypeSymbol.StaticConstructors { get; }
    private ImmutableArray`1<IMethodSymbol> Microsoft.CodeAnalysis.INamedTypeSymbol.Constructors { get; }
    private IEnumerable`1<string> Microsoft.CodeAnalysis.INamedTypeSymbol.MemberNames { get; }
    private ImmutableArray`1<ITypeParameterSymbol> Microsoft.CodeAnalysis.INamedTypeSymbol.TypeParameters { get; }
    private ImmutableArray`1<ITypeSymbol> Microsoft.CodeAnalysis.INamedTypeSymbol.TypeArguments { get; }
    private INamedTypeSymbol Microsoft.CodeAnalysis.INamedTypeSymbol.OriginalDefinition { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.INamedTypeSymbol.DelegateInvokeMethod { get; }
    private INamedTypeSymbol Microsoft.CodeAnalysis.INamedTypeSymbol.EnumUnderlyingType { get; }
    private INamedTypeSymbol Microsoft.CodeAnalysis.INamedTypeSymbol.ConstructedFrom { get; }
    private ISymbol Microsoft.CodeAnalysis.INamedTypeSymbol.AssociatedSymbol { get; }
    private static NamedTypeSymbol();
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsEnum();
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsValueType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.GetResolvedType(EmitContext context);
    private sealed virtual override PrimitiveTypeCode Microsoft.Cci.ITypeReference.TypeCode(EmitContext context);
    private sealed virtual override TypeDefinitionHandle Microsoft.Cci.ITypeReference.get_TypeDef();
    private sealed virtual override IGenericMethodParameterReference Microsoft.Cci.ITypeReference.get_AsGenericMethodParameterReference();
    private sealed virtual override IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.get_AsGenericTypeInstanceReference();
    private sealed virtual override IGenericTypeParameterReference Microsoft.Cci.ITypeReference.get_AsGenericTypeParameterReference();
    private sealed virtual override INamespaceTypeReference Microsoft.Cci.ITypeReference.get_AsNamespaceTypeReference();
    private sealed virtual override INamespaceTypeDefinition Microsoft.Cci.ITypeReference.AsNamespaceTypeDefinition(EmitContext context);
    private sealed virtual override INestedTypeReference Microsoft.Cci.ITypeReference.get_AsNestedTypeReference();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.ITypeReference.AsNestedTypeDefinition(EmitContext context);
    private INestedTypeDefinition AsNestedTypeDefinitionImpl(PEModuleBuilder moduleBeingBuilt);
    private sealed virtual override ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.get_AsSpecializedNestedTypeReference();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.AsTypeDefinition(EmitContext context);
    private ITypeDefinition AsTypeDefinitionImpl(PEModuleBuilder moduleBeingBuilt);
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
    private sealed virtual override ITypeReference Microsoft.Cci.ITypeDefinition.GetBaseClass(EmitContext context);
    private sealed virtual override IEnumerable`1<IEventDefinition> Microsoft.Cci.ITypeDefinition.get_Events();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol/<GetEventsToEmit>d__30")]
internal virtual IEnumerable`1<EventSymbol> GetEventsToEmit();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol/<Microsoft-Cci-ITypeDefinition-GetExplicitImplementationOverrides>d__31")]
private sealed virtual override IEnumerable`1<MethodImplementation> Microsoft.Cci.ITypeDefinition.GetExplicitImplementationOverrides(EmitContext context);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol/<Microsoft-Cci-ITypeDefinition-GetFields>d__32")]
private sealed virtual override IEnumerable`1<IFieldDefinition> Microsoft.Cci.ITypeDefinition.GetFields(EmitContext context);
    internal abstract virtual IEnumerable`1<FieldSymbol> GetFieldsToEmit();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol/<Microsoft-Cci-ITypeDefinition-get_GenericParameters>d__35")]
private sealed virtual override IEnumerable`1<IGenericTypeParameter> Microsoft.Cci.ITypeDefinition.get_GenericParameters();
    private sealed virtual override ushort Microsoft.Cci.ITypeDefinition.get_GenericParameterCount();
    private ushort get_GenericParameterCountImpl();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol/<Microsoft-Cci-ITypeDefinition-Interfaces>d__40")]
private sealed virtual override IEnumerable`1<ITypeReference> Microsoft.Cci.ITypeDefinition.Interfaces(EmitContext context);
    internal abstract virtual ImmutableArray`1<NamedTypeSymbol> GetInterfacesToEmit();
    protected ImmutableArray`1<NamedTypeSymbol> CalculateInterfacesToEmit();
    private static void InterfacesVisit(NamedTypeSymbol namedType, ArrayBuilder`1<NamedTypeSymbol> builder, HashSet`1& seen);
    private sealed virtual override bool Microsoft.Cci.ITypeDefinition.get_IsAbstract();
    internal virtual bool get_IsMetadataAbstract();
    private sealed virtual override bool Microsoft.Cci.ITypeDefinition.get_IsBeforeFieldInit();
    private sealed virtual override bool Microsoft.Cci.ITypeDefinition.get_IsComObject();
    private sealed virtual override bool Microsoft.Cci.ITypeDefinition.get_IsGeneric();
    private sealed virtual override bool Microsoft.Cci.ITypeDefinition.get_IsInterface();
    private sealed virtual override bool Microsoft.Cci.ITypeDefinition.get_IsRuntimeSpecial();
    private sealed virtual override bool Microsoft.Cci.ITypeDefinition.get_IsSerializable();
    private sealed virtual override bool Microsoft.Cci.ITypeDefinition.get_IsSpecialName();
    private sealed virtual override bool Microsoft.Cci.ITypeDefinition.get_IsWindowsRuntimeImport();
    private sealed virtual override bool Microsoft.Cci.ITypeDefinition.get_IsSealed();
    internal virtual bool get_IsMetadataSealed();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol/<Microsoft-Cci-ITypeDefinition-GetMethods>d__68")]
private sealed virtual override IEnumerable`1<IMethodDefinition> Microsoft.Cci.ITypeDefinition.GetMethods(EmitContext context);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol/<GetMethodsToEmit>d__69")]
internal virtual IEnumerable`1<MethodSymbol> GetMethodsToEmit();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol/<Microsoft-Cci-ITypeDefinition-GetNestedTypes>d__70")]
private sealed virtual override IEnumerable`1<INestedTypeDefinition> Microsoft.Cci.ITypeDefinition.GetNestedTypes(EmitContext context);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol/<Microsoft-Cci-ITypeDefinition-GetProperties>d__71")]
private sealed virtual override IEnumerable`1<IPropertyDefinition> Microsoft.Cci.ITypeDefinition.GetProperties(EmitContext context);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol/<GetPropertiesToEmit>d__72")]
internal virtual IEnumerable`1<PropertySymbol> GetPropertiesToEmit();
    private sealed virtual override bool Microsoft.Cci.ITypeDefinition.get_HasDeclarativeSecurity();
    private sealed virtual override IEnumerable`1<SecurityAttribute> Microsoft.Cci.ITypeDefinition.get_SecurityAttributes();
    private sealed virtual override ushort Microsoft.Cci.ITypeDefinition.get_Alignment();
    private sealed virtual override LayoutKind Microsoft.Cci.ITypeDefinition.get_Layout();
    private sealed virtual override UInt32 Microsoft.Cci.ITypeDefinition.get_SizeOf();
    private sealed virtual override CharSet Microsoft.Cci.ITypeDefinition.get_StringFormat();
    private sealed virtual override ushort Microsoft.Cci.INamedTypeReference.get_GenericParameterCount();
    private sealed virtual override bool Microsoft.Cci.INamedTypeReference.get_MangleName();
    private sealed virtual override string Microsoft.Cci.INamedEntity.get_Name();
    private sealed virtual override IUnitReference Microsoft.Cci.INamespaceTypeReference.GetUnit(EmitContext context);
    private sealed virtual override string Microsoft.Cci.INamespaceTypeReference.get_NamespaceName();
    private sealed virtual override bool Microsoft.Cci.INamespaceTypeDefinition.get_IsPublic();
    private sealed virtual override ITypeReference Microsoft.Cci.ITypeMemberReference.GetContainingType(EmitContext context);
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeDefinitionMember.get_ContainingTypeDefinition();
    private sealed virtual override TypeMemberVisibility Microsoft.Cci.ITypeDefinitionMember.get_Visibility();
    private sealed virtual override ImmutableArray`1<ITypeReference> Microsoft.Cci.IGenericTypeInstanceReference.GetGenericArguments(EmitContext context);
    private sealed virtual override INamedTypeReference Microsoft.Cci.IGenericTypeInstanceReference.get_GenericType();
    private INamedTypeReference get_GenericTypeImpl();
    private sealed virtual override INestedTypeReference Microsoft.Cci.ISpecializedNestedTypeReference.get_UnspecializedVersion();
    public abstract virtual int get_Arity();
    public abstract virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public ImmutableArray`1<TypeSymbol> get_TypeArguments();
    internal abstract virtual ImmutableArray`1<ImmutableArray`1<CustomModifier>> get_TypeArgumentsCustomModifiers();
    internal ImmutableArray`1<ImmutableArray`1<CustomModifier>> CreateEmptyTypeArgumentsCustomModifiers();
    internal static ImmutableArray`1<ImmutableArray`1<CustomModifier>> CreateEmptyTypeArgumentsCustomModifiers(int arity);
    internal abstract virtual bool get_HasTypeArgumentsCustomModifiers();
    internal abstract virtual ImmutableArray`1<TypeSymbol> get_TypeArgumentsNoUseSiteDiagnostics();
    internal ImmutableArray`1<TypeSymbol> TypeArgumentsWithDefinitionUseSiteDiagnostics(HashSet`1& useSiteDiagnostics);
    internal TypeSymbol TypeArgumentWithDefinitionUseSiteDiagnostics(int index, HashSet`1& useSiteDiagnostics);
    public abstract virtual NamedTypeSymbol get_ConstructedFrom();
    public virtual NamedTypeSymbol get_EnumUnderlyingType();
    public virtual NamedTypeSymbol get_ContainingType();
    internal virtual bool get_KnownCircularStruct();
    internal bool get_KnownToHaveNoDeclaredBaseCycles();
    internal void SetKnownToHaveNoDeclaredBaseCycles();
    internal virtual bool get_IsExplicitDefinitionOfNoPiaLocalType();
    internal virtual bool GetGuidString(String& guidString);
    public MethodSymbol get_DelegateInvokeMethod();
    internal ImmutableArray`1<MethodSymbol> GetOperators(string name);
    public ImmutableArray`1<MethodSymbol> get_InstanceConstructors();
    public ImmutableArray`1<MethodSymbol> get_StaticConstructors();
    public ImmutableArray`1<MethodSymbol> get_Constructors();
    private ImmutableArray`1<TMethodSymbol> GetConstructors(bool includeInstance, bool includeStatic);
    public ImmutableArray`1<PropertySymbol> get_Indexers();
    public abstract virtual bool get_MightContainExtensionMethods();
    internal void GetExtensionMethods(ArrayBuilder`1<MethodSymbol> methods, string nameOpt, int arity, LookupOptions options);
    internal void DoGetExtensionMethods(ArrayBuilder`1<MethodSymbol> methods, string nameOpt, int arity, LookupOptions options);
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsValueType();
    internal virtual bool get_IsManagedType();
    internal abstract virtual AttributeUsageInfo GetAttributeUsageInfo();
    public virtual bool get_IsScriptClass();
    internal bool get_IsSubmissionClass();
    internal SynthesizedInstanceConstructor GetScriptConstructor();
    internal SynthesizedInteractiveInitializerMethod GetScriptInitializer();
    internal SynthesizedEntryPointSymbol GetScriptEntryPoint();
    public virtual bool get_IsImplicitClass();
    public abstract virtual string get_Name();
    public virtual string get_MetadataName();
    internal abstract virtual bool get_MangleName();
    public abstract virtual IEnumerable`1<string> get_MemberNames();
    public abstract virtual ImmutableArray`1<Symbol> GetMembers();
    public abstract virtual ImmutableArray`1<Symbol> GetMembers(string name);
    internal virtual ImmutableArray`1<Symbol> GetSimpleNonTypeMembers(string name);
    public abstract virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public abstract virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public abstract virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    internal virtual IEnumerable`1<Symbol> GetInstanceFieldsAndEvents();
    public abstract virtual Accessibility get_DeclaredAccessibility();
    internal virtual TResult Accept(CSharpSymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual void Accept(CSharpSymbolVisitor visitor);
    public virtual TResult Accept(CSharpSymbolVisitor`1<TResult> visitor);
    internal abstract virtual ImmutableArray`1<Symbol> GetEarlyAttributeDecodingMembers();
    internal abstract virtual ImmutableArray`1<Symbol> GetEarlyAttributeDecodingMembers(string name);
    public virtual SymbolKind get_Kind();
    internal abstract virtual NamedTypeSymbol GetDeclaredBaseType(ConsList`1<Symbol> basesBeingResolved);
    internal abstract virtual ImmutableArray`1<NamedTypeSymbol> GetDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved);
    public virtual int GetHashCode();
    internal virtual bool Equals(TypeSymbol t2, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
    private bool EqualsComplicatedCases(NamedTypeSymbol other, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
    public NamedTypeSymbol Construct(TypeSymbol[] typeArguments);
    public NamedTypeSymbol Construct(ImmutableArray`1<TypeSymbol> typeArguments);
    public NamedTypeSymbol Construct(IEnumerable`1<TypeSymbol> typeArguments);
    public NamedTypeSymbol ConstructUnboundGenericType();
    internal NamedTypeSymbol GetUnboundGenericTypeOrSelf();
    internal NamedTypeSymbol ConstructWithoutModifiers(ImmutableArray`1<TypeSymbol> arguments, bool unbound);
    internal NamedTypeSymbol Construct(ImmutableArray`1<TypeWithModifiers> arguments, bool unbound);
    protected virtual NamedTypeSymbol ConstructCore(ImmutableArray`1<TypeWithModifiers> typeArguments, bool unbound);
    public sealed virtual bool get_IsGenericType();
    public virtual bool get_IsUnboundGenericType();
    internal void GetAllTypeArguments(ArrayBuilder`1<TypeSymbol> builder, HashSet`1& useSiteDiagnostics);
    internal ImmutableArray`1<TypeWithModifiers> GetAllTypeArguments(HashSet`1& useSiteDiagnostics);
    internal void GetAllTypeArguments(ArrayBuilder`1<TypeWithModifiers> builder, HashSet`1& useSiteDiagnostics);
    internal int AllTypeArgumentCount();
    public virtual NamedTypeSymbol get_OriginalDefinition();
    protected sealed virtual TypeSymbol get_OriginalTypeSymbolDefinition();
    internal virtual TypeMap get_TypeSubstitution();
    internal virtual NamedTypeSymbol AsMember(NamedTypeSymbol newOwner);
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    private bool DeriveUseSiteDiagnosticFromTypeArguments(DiagnosticInfo& result);
    internal DiagnosticInfo CalculateUseSiteDiagnostic();
    private DiagnosticInfo DeriveUseSiteDiagnosticFromBase();
    internal virtual bool GetUnificationUseSiteDiagnosticRecursive(DiagnosticInfo& result, Symbol owner, HashSet`1& checkedTypes);
    internal abstract virtual bool get_HasSpecialName();
    internal abstract virtual bool get_IsComImport();
    internal abstract virtual bool get_IsWindowsRuntimeImport();
    internal abstract virtual bool get_ShouldAddWinRTMembers();
    internal bool get_IsConditional();
    internal abstract virtual bool get_IsSerializable();
    internal abstract virtual TypeLayout get_Layout();
    protected CharSet get_DefaultMarshallingCharSet();
    internal abstract virtual CharSet get_MarshallingCharSet();
    internal abstract virtual bool get_HasDeclarativeSecurity();
    internal abstract virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal abstract virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual NamedTypeSymbol get_ComImportCoClass();
    internal virtual FieldSymbol get_FixedElementField();
    internal abstract virtual bool get_IsInterface();
    private sealed virtual override int Microsoft.CodeAnalysis.INamedTypeSymbol.get_Arity();
    private sealed virtual override ImmutableArray`1<IMethodSymbol> Microsoft.CodeAnalysis.INamedTypeSymbol.get_InstanceConstructors();
    private sealed virtual override ImmutableArray`1<IMethodSymbol> Microsoft.CodeAnalysis.INamedTypeSymbol.get_StaticConstructors();
    private sealed virtual override ImmutableArray`1<IMethodSymbol> Microsoft.CodeAnalysis.INamedTypeSymbol.get_Constructors();
    private sealed virtual override IEnumerable`1<string> Microsoft.CodeAnalysis.INamedTypeSymbol.get_MemberNames();
    private sealed virtual override ImmutableArray`1<ITypeParameterSymbol> Microsoft.CodeAnalysis.INamedTypeSymbol.get_TypeParameters();
    private sealed virtual override ImmutableArray`1<ITypeSymbol> Microsoft.CodeAnalysis.INamedTypeSymbol.get_TypeArguments();
    private sealed virtual override INamedTypeSymbol Microsoft.CodeAnalysis.INamedTypeSymbol.get_OriginalDefinition();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.INamedTypeSymbol.get_DelegateInvokeMethod();
    private sealed virtual override INamedTypeSymbol Microsoft.CodeAnalysis.INamedTypeSymbol.get_EnumUnderlyingType();
    private sealed virtual override INamedTypeSymbol Microsoft.CodeAnalysis.INamedTypeSymbol.get_ConstructedFrom();
    private sealed virtual override INamedTypeSymbol Microsoft.CodeAnalysis.INamedTypeSymbol.Construct(ITypeSymbol[] arguments);
    private sealed virtual override INamedTypeSymbol Microsoft.CodeAnalysis.INamedTypeSymbol.ConstructUnboundGenericType();
    private sealed virtual override ISymbol Microsoft.CodeAnalysis.INamedTypeSymbol.get_AssociatedSymbol();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent : ValueType {
    private NamespaceKind _kind;
    private object _symbolOrCompilation;
    public NamespaceKind Kind { get; }
    public ModuleSymbol Module { get; }
    public AssemblySymbol Assembly { get; }
    public CSharpCompilation Compilation { get; }
    internal NamespaceExtent(ModuleSymbol module);
    internal NamespaceExtent(AssemblySymbol assembly);
    internal NamespaceExtent(CSharpCompilation compilation);
    public NamespaceKind get_Kind();
    public ModuleSymbol get_Module();
    public AssemblySymbol get_Assembly();
    public CSharpCompilation get_Compilation();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(NamespaceExtent other);
    public virtual int GetHashCode();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol : Symbol {
    public bool IsNamespace { get; }
    public bool IsType { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsExtern { get; }
    public sealed virtual bool get_IsNamespace();
    public sealed virtual bool get_IsType();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsExtern();
    public abstract virtual ImmutableArray`1<Symbol> GetMembers();
    internal virtual ImmutableArray`1<Symbol> GetMembersUnordered();
    public abstract virtual ImmutableArray`1<Symbol> GetMembers(string name);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembersUnordered();
    public abstract virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public abstract virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    internal SourceNamedTypeSymbol GetSourceTypeMember(TypeDeclarationSyntax syntax);
    internal SourceNamedTypeSymbol GetSourceTypeMember(DelegateDeclarationSyntax syntax);
    internal SourceNamedTypeSymbol GetSourceTypeMember(string name, int arity, SyntaxKind kind, CSharpSyntaxNode syntax);
    internal virtual NamedTypeSymbol LookupMetadataType(MetadataTypeName& emittedTypeName);
    internal IEnumerable`1<NamespaceOrTypeSymbol> GetNamespaceOrTypeByQualifiedName(IEnumerable`1<string> qualifiedName);
    private sealed virtual override ImmutableArray`1<ISymbol> Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.GetMembers();
    private sealed virtual override ImmutableArray`1<ISymbol> Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.GetMembers(string name);
    private sealed virtual override ImmutableArray`1<INamedTypeSymbol> Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.GetTypeMembers();
    private sealed virtual override ImmutableArray`1<INamedTypeSymbol> Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.GetTypeMembers(string name);
    private sealed virtual override ImmutableArray`1<INamedTypeSymbol> Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.GetTypeMembers(string name, int arity);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol : NamespaceOrTypeSymbol {
    private ImmutableArray`1<NamedTypeSymbol> _lazyTypesMightContainExtensionMethods;
    private string _lazyQualifiedName;
    private INamespace Microsoft.Cci.INamespace.ContainingNamespace { get; }
    private string Microsoft.Cci.INamedEntity.Name { get; }
    public bool IsGlobalNamespace { get; }
    internal NamespaceExtent Extent { get; }
    public NamespaceKind NamespaceKind { get; }
    public CSharpCompilation ContainingCompilation { get; }
    public ImmutableArray`1<NamespaceSymbol> ConstituentNamespaces { get; }
    public NamedTypeSymbol ContainingType { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal ModuleSymbol ContainingModule { get; }
    public SymbolKind Kind { get; }
    public bool IsImplicitlyDeclared { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal NamedTypeSymbol ImplicitType { get; }
    private ImmutableArray`1<NamedTypeSymbol> TypesMightContainExtensionMethods { get; }
    private NamespaceKind Microsoft.CodeAnalysis.INamespaceSymbol.NamespaceKind { get; }
    private Compilation Microsoft.CodeAnalysis.INamespaceSymbol.ContainingCompilation { get; }
    private ImmutableArray`1<INamespaceSymbol> Microsoft.CodeAnalysis.INamespaceSymbol.ConstituentNamespaces { get; }
    internal string QualifiedName { get; }
    private sealed virtual override INamespace Microsoft.Cci.INamespace.get_ContainingNamespace();
    private sealed virtual override string Microsoft.Cci.INamedEntity.get_Name();
    public IEnumerable`1<NamespaceSymbol> GetNamespaceMembers();
    public virtual bool get_IsGlobalNamespace();
    internal abstract virtual NamespaceExtent get_Extent();
    public NamespaceKind get_NamespaceKind();
    public CSharpCompilation get_ContainingCompilation();
    public virtual ImmutableArray`1<NamespaceSymbol> get_ConstituentNamespaces();
    public sealed virtual NamedTypeSymbol get_ContainingType();
    public abstract virtual AssemblySymbol get_ContainingAssembly();
    internal virtual ModuleSymbol get_ContainingModule();
    public sealed virtual SymbolKind get_Kind();
    public sealed virtual bool get_IsImplicitlyDeclared();
    internal virtual TResult Accept(CSharpSymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual void Accept(CSharpSymbolVisitor visitor);
    public virtual TResult Accept(CSharpSymbolVisitor`1<TResult> visitor);
    public sealed virtual Accessibility get_DeclaredAccessibility();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal NamedTypeSymbol get_ImplicitType();
    internal NamespaceSymbol LookupNestedNamespace(ImmutableArray`1<string> names);
    internal NamespaceSymbol GetNestedNamespace(string name);
    internal NamespaceSymbol GetNestedNamespace(NameSyntax name);
    private ImmutableArray`1<NamedTypeSymbol> get_TypesMightContainExtensionMethods();
    internal virtual void GetExtensionMethods(ArrayBuilder`1<MethodSymbol> methods, string nameOpt, int arity, LookupOptions options);
    private sealed virtual override IEnumerable`1<INamespaceOrTypeSymbol> Microsoft.CodeAnalysis.INamespaceSymbol.GetMembers();
    private sealed virtual override IEnumerable`1<INamespaceOrTypeSymbol> Microsoft.CodeAnalysis.INamespaceSymbol.GetMembers(string name);
    private sealed virtual override IEnumerable`1<INamespaceSymbol> Microsoft.CodeAnalysis.INamespaceSymbol.GetNamespaceMembers();
    private sealed virtual override NamespaceKind Microsoft.CodeAnalysis.INamespaceSymbol.get_NamespaceKind();
    private sealed virtual override Compilation Microsoft.CodeAnalysis.INamespaceSymbol.get_ContainingCompilation();
    private sealed virtual override ImmutableArray`1<INamespaceSymbol> Microsoft.CodeAnalysis.INamespaceSymbol.get_ConstituentNamespaces();
    internal string get_QualifiedName();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingAssemblySymbol : AssemblySymbol {
    private ConcurrentDictionary`2<Key, NamedTypeSymbol> _emittedNameToTypeMap;
    private NamespaceSymbol _globalNamespace;
    internal bool IsMissing { get; }
    public NamespaceSymbol GlobalNamespace { get; }
    internal int EmittedNameToTypeMapCount { get; }
    internal sealed virtual bool get_IsMissing();
    public sealed virtual NamespaceSymbol get_GlobalNamespace();
    internal sealed virtual NamedTypeSymbol LookupTopLevelMetadataTypeWithCycleDetection(MetadataTypeName& emittedName, ConsList`1<AssemblySymbol> visitedAssemblies, bool digThroughForwardedTypes);
    internal abstract virtual NamedTypeSymbol TryLookupForwardedMetadataTypeWithCycleDetection(MetadataTypeName& emittedName, ConsList`1<AssemblySymbol> visitedAssemblies);
    private NamedTypeSymbol LookupTopLevelMetadataTypeInCache(MetadataTypeName& emittedName);
    internal NamedTypeSymbol CachedTypeByEmittedName(string emittedname);
    internal int get_EmittedNameToTypeMapCount();
    private void CacheTopLevelMetadataType(MetadataTypeName& emittedName, NamedTypeSymbol result);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingModuleSymbol : ModuleSymbol {
    private ModuleReferences`1<AssemblySymbol> _moduleReferences;
    internal bool IsMissing { get; }
    internal bool HasUnifiedReferences { get; }
    internal sealed virtual bool get_IsMissing();
    internal sealed virtual ImmutableArray`1<AssemblyIdentity> GetReferencedAssemblies();
    internal sealed virtual ImmutableArray`1<AssemblySymbol> GetReferencedAssemblySymbols();
    internal ImmutableArray`1<UnifiedAssembly`1<AssemblySymbol>> GetUnifiedAssemblies();
    internal virtual bool get_HasUnifiedReferences();
    internal virtual bool GetUnificationUseSiteDiagnostic(DiagnosticInfo& result, TypeSymbol dependentType);
    internal virtual void SetReferences(ModuleReferences`1<AssemblySymbol> moduleReferences, SourceAssemblySymbol originatingSourceAssemblyDebugOnly);
    [ConditionalAttribute("DEBUG")]
internal void AssertReferencesUninitialized();
    [ConditionalAttribute("DEBUG")]
internal void AssertReferencesInitialized();
    internal sealed virtual NamedTypeSymbol LookupTopLevelMetadataType(MetadataTypeName& emittedName);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.NoPiaAmbiguousCanonicalTypeSymbol : ErrorTypeSymbol {
    private AssemblySymbol _embeddingAssembly;
    private NamedTypeSymbol _firstCandidate;
    private NamedTypeSymbol _secondCandidate;
    internal bool MangleName { get; }
    public AssemblySymbol EmbeddingAssembly { get; }
    public NamedTypeSymbol FirstCandidate { get; }
    public NamedTypeSymbol SecondCandidate { get; }
    internal DiagnosticInfo ErrorInfo { get; }
    public NoPiaAmbiguousCanonicalTypeSymbol(AssemblySymbol embeddingAssembly, NamedTypeSymbol firstCandidate, NamedTypeSymbol secondCandidate);
    internal virtual bool get_MangleName();
    public AssemblySymbol get_EmbeddingAssembly();
    public NamedTypeSymbol get_FirstCandidate();
    public NamedTypeSymbol get_SecondCandidate();
    internal virtual DiagnosticInfo get_ErrorInfo();
    public virtual int GetHashCode();
    internal virtual bool Equals(TypeSymbol t2, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.NoPiaIllegalGenericInstantiationSymbol : ErrorTypeSymbol {
    private ModuleSymbol _exposingModule;
    private NamedTypeSymbol _underlyingSymbol;
    internal bool MangleName { get; }
    public NamedTypeSymbol UnderlyingSymbol { get; }
    internal DiagnosticInfo ErrorInfo { get; }
    public NoPiaIllegalGenericInstantiationSymbol(ModuleSymbol exposingModule, NamedTypeSymbol underlyingSymbol);
    internal virtual bool get_MangleName();
    public NamedTypeSymbol get_UnderlyingSymbol();
    internal virtual DiagnosticInfo get_ErrorInfo();
    public virtual int GetHashCode();
    internal virtual bool Equals(TypeSymbol t2, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.NoPiaMissingCanonicalTypeSymbol : ErrorTypeSymbol {
    private AssemblySymbol _embeddingAssembly;
    private string _fullTypeName;
    private string _guid;
    private string _scope;
    private string _identifier;
    public AssemblySymbol EmbeddingAssembly { get; }
    public string FullTypeName { get; }
    internal bool MangleName { get; }
    public string Guid { get; }
    public string Scope { get; }
    public string Identifier { get; }
    internal DiagnosticInfo ErrorInfo { get; }
    public NoPiaMissingCanonicalTypeSymbol(AssemblySymbol embeddingAssembly, string fullTypeName, string guid, string scope, string identifier);
    public AssemblySymbol get_EmbeddingAssembly();
    public string get_FullTypeName();
    internal virtual bool get_MangleName();
    public string get_Guid();
    public string get_Scope();
    public string get_Identifier();
    internal virtual DiagnosticInfo get_ErrorInfo();
    public virtual int GetHashCode();
    internal virtual bool Equals(TypeSymbol t2, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
}
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.ObsoleteAttributeHelpers : object {
    internal static void InitializeObsoleteDataFromMetadata(ObsoleteAttributeData& data, EntityHandle token, PEModuleSymbol containingModule);
    internal static ObsoleteAttributeData GetObsoleteDataFromMetadata(EntityHandle token, PEModuleSymbol containingModule);
    internal static ThreeState GetObsoleteContextState(Symbol symbol, bool forceComplete);
    internal static DiagnosticInfo CreateObsoleteDiagnostic(Symbol symbol, BinderFlags location);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenMethodTypeParameterMap : OverriddenMethodTypeParameterMapBase {
    public OverriddenMethodTypeParameterMap(SourceMemberMethodSymbol overridingMethod);
    protected virtual MethodSymbol GetOverriddenMethod(SourceMemberMethodSymbol overridingMethod);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenMethodTypeParameterMapBase : object {
    private SourceMemberMethodSymbol _overridingMethod;
    private TypeMap _lazyTypeMap;
    private MethodSymbol _lazyOverriddenMethod;
    public SourceMemberMethodSymbol OverridingMethod { get; }
    public TypeMap TypeMap { get; }
    private MethodSymbol OverriddenMethod { get; }
    protected OverriddenMethodTypeParameterMapBase(SourceMemberMethodSymbol overridingMethod);
    public SourceMemberMethodSymbol get_OverridingMethod();
    public TypeParameterSymbol GetOverriddenTypeParameter(int ordinal);
    public TypeMap get_TypeMap();
    private MethodSymbol get_OverriddenMethod();
    protected abstract virtual MethodSymbol GetOverriddenMethod(SourceMemberMethodSymbol overridingMethod);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers : object {
    [ExtensionAttribute]
internal static OverriddenOrHiddenMembersResult MakeOverriddenOrHiddenMembers(MethodSymbol member);
    [ExtensionAttribute]
internal static OverriddenOrHiddenMembersResult MakeOverriddenOrHiddenMembers(PropertySymbol member);
    [ExtensionAttribute]
internal static OverriddenOrHiddenMembersResult MakeOverriddenOrHiddenMembers(EventSymbol member);
    private static OverriddenOrHiddenMembersResult MakeOverriddenOrHiddenMembersWorker(Symbol member);
    private static OverriddenOrHiddenMembersResult MakePropertyAccessorOverriddenOrHiddenMembers(MethodSymbol accessor, PropertySymbol associatedProperty);
    private static OverriddenOrHiddenMembersResult MakeEventAccessorOverriddenOrHiddenMembers(MethodSymbol accessor, EventSymbol associatedEvent);
    private static OverriddenOrHiddenMembersResult MakeInterfaceOverriddenOrHiddenMembers(Symbol member, bool memberIsFromSomeCompilation);
    private static void FindOverriddenOrHiddenMembersInType(Symbol member, bool memberIsFromSomeCompilation, NamedTypeSymbol memberContainingType, NamedTypeSymbol currType, Symbol& currTypeBestMatch, Boolean& currTypeHasSameKindNonMatch, ArrayBuilder`1& hiddenBuilder);
    private static void FindRelatedMembers(bool isOverride, bool overridingMemberIsFromSomeCompilation, SymbolKind overridingMemberKind, Symbol representativeMember, ImmutableArray`1& overriddenMembers, ImmutableArray`1& runtimeOverriddenMembers, ArrayBuilder`1& hiddenBuilder);
    private static void AddHiddenMemberIfApplicable(ArrayBuilder`1& hiddenBuilder, SymbolKind hidingMemberKind, Symbol hiddenMember);
    private static ArrayBuilder`1<T> AccessOrGetInstance(ArrayBuilder`1& builder);
    private static void FindOtherOverriddenMethodsInContainingType(Symbol representativeMember, bool overridingMemberIsFromSomeCompilation, ArrayBuilder`1<Symbol> overriddenBuilder, ArrayBuilder`1<Symbol> runtimeOverriddenBuilder);
    private static void FindOtherHiddenMembersInContainingType(SymbolKind hidingMemberKind, Symbol representativeMember, ArrayBuilder`1& hiddenBuilder);
    private static bool CanOverrideOrHide(Symbol member);
    private static bool TypeOrReturnTypeHasCustomModifiers(Symbol member);
    private static int CustomModifierCount(Symbol member);
    [ExtensionAttribute]
internal static bool RequiresExplicitOverride(MethodSymbol method);
    [ExtensionAttribute]
internal static MethodSymbol GetFirstRuntimeOverriddenMethodIgnoringNewSlot(MethodSymbol method, bool ignoreInterfaceImplementationChanges);
    private static bool IsOverriddenSymbolAccessible(Symbol overridden, NamedTypeSymbol overridingContainingType);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersResult : object {
    public static OverriddenOrHiddenMembersResult Empty;
    private ImmutableArray`1<Symbol> _overriddenMembers;
    private ImmutableArray`1<Symbol> _hiddenMembers;
    private ImmutableArray`1<Symbol> _runtimeOverriddenMembers;
    public ImmutableArray`1<Symbol> OverriddenMembers { get; }
    public ImmutableArray`1<Symbol> HiddenMembers { get; }
    public ImmutableArray`1<Symbol> RuntimeOverriddenMembers { get; }
    private OverriddenOrHiddenMembersResult(ImmutableArray`1<Symbol> overriddenMembers, ImmutableArray`1<Symbol> hiddenMembers, ImmutableArray`1<Symbol> runtimeOverriddenMembers);
    private static OverriddenOrHiddenMembersResult();
    public ImmutableArray`1<Symbol> get_OverriddenMembers();
    public ImmutableArray`1<Symbol> get_HiddenMembers();
    public ImmutableArray`1<Symbol> get_RuntimeOverriddenMembers();
    public static OverriddenOrHiddenMembersResult Create(ImmutableArray`1<Symbol> overriddenMembers, ImmutableArray`1<Symbol> hiddenMembers, ImmutableArray`1<Symbol> runtimeOverriddenMembers);
    internal static Symbol GetOverriddenMember(Symbol substitutedOverridingMember, Symbol overriddenByDefinitionMember);
    internal Symbol GetOverriddenMember();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.ParameterEarlyWellKnownAttributeData : CommonParameterEarlyWellKnownAttributeData {
}
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.ParameterHelpers : object {
    public static ImmutableArray`1<ParameterSymbol> MakeParameters(Binder binder, Symbol owner, BaseParameterListSyntax syntax, bool allowRefOrOut, SyntaxToken& arglistToken, DiagnosticBag diagnostics);
    private static void ReportParameterErrors(Symbol owner, ParameterSyntax parameterSyntax, SourceParameterSymbol parameter, int firstDefault, DiagnosticBag diagnostics);
    internal static bool ReportDefaultParameterErrors(Binder binder, Symbol owner, ParameterSyntax parameterSyntax, SourceParameterSymbol parameter, BoundExpression defaultExpression, DiagnosticBag diagnostics);
    private static bool IsValidDefaultValue(BoundExpression expression);
    private static bool IsValidDefaultValue(BoundObjectCreationExpression expression);
    internal static MethodSymbol FindContainingGenericMethod(Symbol symbol);
    private static RefKind GetModifiers(SyntaxTokenList modifiers, SyntaxToken& outKeyword, SyntaxToken& refKeyword, SyntaxToken& paramsKeyword, SyntaxToken& thisKeyword);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSignature : object {
    internal ImmutableArray`1<TypeSymbol> parameterTypes;
    internal ImmutableArray`1<RefKind> parameterRefKinds;
    internal static ParameterSignature NoParams;
    private ParameterSignature(ImmutableArray`1<TypeSymbol> parameterTypes, ImmutableArray`1<RefKind> parameterRefKinds);
    private static ParameterSignature();
    private static ParameterSignature MakeParamTypesAndRefKinds(ImmutableArray`1<ParameterSymbol> parameters);
    internal static void PopulateParameterSignature(ImmutableArray`1<ParameterSymbol> parameters, ParameterSignature& lazySignature);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol : Symbol {
    internal static string ValueParameterName;
    private ImmutableArray`1<ICustomModifier> Microsoft.Cci.IParameterTypeInformation.CustomModifiers { get; }
    private bool Microsoft.Cci.IParameterTypeInformation.IsByReference { get; }
    private ushort Microsoft.Cci.IParameterTypeInformation.CountOfCustomModifiersPrecedingByRef { get; }
    private ushort Microsoft.Cci.IParameterListEntry.Index { get; }
    internal bool HasMetadataConstantValue { get; }
    private bool Microsoft.Cci.IParameterDefinition.HasDefaultValue { get; }
    private bool Microsoft.Cci.IParameterDefinition.IsOptional { get; }
    private bool Microsoft.Cci.IParameterDefinition.IsIn { get; }
    private bool Microsoft.Cci.IParameterDefinition.IsMarshalledExplicitly { get; }
    internal bool IsMarshalledExplicitly { get; }
    private bool Microsoft.Cci.IParameterDefinition.IsOut { get; }
    private IMarshallingInformation Microsoft.Cci.IParameterDefinition.MarshallingInformation { get; }
    private ImmutableArray`1<byte> Microsoft.Cci.IParameterDefinition.MarshallingDescriptor { get; }
    internal ImmutableArray`1<byte> MarshallingDescriptor { get; }
    private string Microsoft.Cci.INamedEntity.Name { get; }
    public ParameterSymbol OriginalDefinition { get; }
    protected Symbol OriginalSymbolDefinition { get; }
    public TypeSymbol Type { get; }
    public RefKind RefKind { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal UnmanagedType MarshallingType { get; }
    internal bool IsMarshalAsObject { get; }
    public int Ordinal { get; }
    public bool IsParams { get; }
    public bool IsOptional { get; }
    internal bool IsMetadataOptional { get; }
    internal bool IsMetadataIn { get; }
    internal bool IsMetadataOut { get; }
    public bool HasExplicitDefaultValue { get; }
    [DebuggerBrowsableAttribute("0")]
public object ExplicitDefaultValue { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    public SymbolKind Kind { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsExtern { get; }
    public bool IsThis { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    internal bool IsCallerFilePath { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerMemberName { get; }
    protected int HighestPriorityUseSiteError { get; }
    public bool HasUnsupportedMetadata { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    private ITypeSymbol Microsoft.CodeAnalysis.IParameterSymbol.Type { get; }
    private ImmutableArray`1<CustomModifier> Microsoft.CodeAnalysis.IParameterSymbol.CustomModifiers { get; }
    private IParameterSymbol Microsoft.CodeAnalysis.IParameterSymbol.OriginalDefinition { get; }
    private sealed virtual override ImmutableArray`1<ICustomModifier> Microsoft.Cci.IParameterTypeInformation.get_CustomModifiers();
    private sealed virtual override bool Microsoft.Cci.IParameterTypeInformation.get_IsByReference();
    private sealed virtual override ushort Microsoft.Cci.IParameterTypeInformation.get_CountOfCustomModifiersPrecedingByRef();
    private sealed virtual override ITypeReference Microsoft.Cci.IParameterTypeInformation.GetType(EmitContext context);
    private sealed virtual override ushort Microsoft.Cci.IParameterListEntry.get_Index();
    private sealed virtual override IMetadataConstant Microsoft.Cci.IParameterDefinition.GetDefaultValue(EmitContext context);
    internal IMetadataConstant GetMetadataConstantValue(EmitContext context);
    internal virtual bool get_HasMetadataConstantValue();
    private sealed virtual override bool Microsoft.Cci.IParameterDefinition.get_HasDefaultValue();
    private sealed virtual override bool Microsoft.Cci.IParameterDefinition.get_IsOptional();
    private sealed virtual override bool Microsoft.Cci.IParameterDefinition.get_IsIn();
    private sealed virtual override bool Microsoft.Cci.IParameterDefinition.get_IsMarshalledExplicitly();
    internal virtual bool get_IsMarshalledExplicitly();
    private sealed virtual override bool Microsoft.Cci.IParameterDefinition.get_IsOut();
    private sealed virtual override IMarshallingInformation Microsoft.Cci.IParameterDefinition.get_MarshallingInformation();
    private sealed virtual override ImmutableArray`1<byte> Microsoft.Cci.IParameterDefinition.get_MarshallingDescriptor();
    internal virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
    private sealed virtual override string Microsoft.Cci.INamedEntity.get_Name();
    public virtual ParameterSymbol get_OriginalDefinition();
    protected sealed virtual Symbol get_OriginalSymbolDefinition();
    public abstract virtual TypeSymbol get_Type();
    public abstract virtual RefKind get_RefKind();
    public abstract virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    internal abstract virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual UnmanagedType get_MarshallingType();
    internal bool get_IsMarshalAsObject();
    public abstract virtual int get_Ordinal();
    public abstract virtual bool get_IsParams();
    public sealed virtual bool get_IsOptional();
    internal abstract virtual bool get_IsMetadataOptional();
    internal abstract virtual bool get_IsMetadataIn();
    internal abstract virtual bool get_IsMetadataOut();
    public sealed virtual bool get_HasExplicitDefaultValue();
    public sealed virtual object get_ExplicitDefaultValue();
    internal abstract virtual ConstantValue get_ExplicitDefaultConstantValue();
    public sealed virtual SymbolKind get_Kind();
    internal virtual TResult Accept(CSharpSymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual void Accept(CSharpSymbolVisitor visitor);
    public virtual TResult Accept(CSharpSymbolVisitor`1<TResult> visitor);
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsStatic();
    public virtual bool get_IsExtern();
    public virtual bool get_IsThis();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal abstract virtual bool get_IsIDispatchConstant();
    internal abstract virtual bool get_IsIUnknownConstant();
    internal abstract virtual bool get_IsCallerFilePath();
    internal abstract virtual bool get_IsCallerLineNumber();
    internal abstract virtual bool get_IsCallerMemberName();
    protected sealed virtual int get_HighestPriorityUseSiteError();
    public sealed virtual bool get_HasUnsupportedMetadata();
    internal abstract virtual ushort get_CountOfCustomModifiersPrecedingByRef();
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.IParameterSymbol.get_Type();
    private sealed virtual override ImmutableArray`1<CustomModifier> Microsoft.CodeAnalysis.IParameterSymbol.get_CustomModifiers();
    private sealed virtual override IParameterSymbol Microsoft.CodeAnalysis.IParameterSymbol.get_OriginalDefinition();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
}
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.PEPropertyOrEventHelpers : object {
    internal static ISet`1<PropertySymbol> GetPropertiesForExplicitlyImplementedAccessor(MethodSymbol accessor);
    internal static ISet`1<EventSymbol> GetEventsForExplicitlyImplementedAccessor(MethodSymbol accessor);
    private static ISet`1<T> GetSymbolsForExplicitlyImplementedAccessor(MethodSymbol accessor);
    internal static Accessibility GetDeclaredAccessibilityFromAccessors(MethodSymbol accessor1, MethodSymbol accessor2);
    internal static Accessibility GetDeclaredAccessibilityFromAccessors(Accessibility accessibility1, Accessibility accessibility2);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol : TypeSymbol {
    private TypeSymbol _pointedAtType;
    private ImmutableArray`1<CustomModifier> _customModifiers;
    private bool Microsoft.Cci.ITypeReference.IsEnum { get; }
    private bool Microsoft.Cci.ITypeReference.IsValueType { get; }
    private TypeDefinitionHandle Microsoft.Cci.ITypeReference.TypeDef { get; }
    private IGenericMethodParameterReference Microsoft.Cci.ITypeReference.AsGenericMethodParameterReference { get; }
    private IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.AsGenericTypeInstanceReference { get; }
    private IGenericTypeParameterReference Microsoft.Cci.ITypeReference.AsGenericTypeParameterReference { get; }
    private INamespaceTypeReference Microsoft.Cci.ITypeReference.AsNamespaceTypeReference { get; }
    private INestedTypeReference Microsoft.Cci.ITypeReference.AsNestedTypeReference { get; }
    private ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.AsSpecializedNestedTypeReference { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public TypeSymbol PointedAtType { get; }
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    internal bool IsManagedType { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public SymbolKind Kind { get; }
    public TypeKind TypeKind { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    private ITypeSymbol Microsoft.CodeAnalysis.IPointerTypeSymbol.PointedAtType { get; }
    private ImmutableArray`1<CustomModifier> Microsoft.CodeAnalysis.IPointerTypeSymbol.CustomModifiers { get; }
    internal PointerTypeSymbol(TypeSymbol pointedAtType);
    internal PointerTypeSymbol(TypeSymbol pointedAtType, ImmutableArray`1<CustomModifier> customModifiers);
    private sealed virtual override ITypeReference Microsoft.Cci.IPointerTypeReference.GetTargetType(EmitContext context);
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsEnum();
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsValueType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.GetResolvedType(EmitContext context);
    private sealed virtual override PrimitiveTypeCode Microsoft.Cci.ITypeReference.TypeCode(EmitContext context);
    private sealed virtual override TypeDefinitionHandle Microsoft.Cci.ITypeReference.get_TypeDef();
    private sealed virtual override IGenericMethodParameterReference Microsoft.Cci.ITypeReference.get_AsGenericMethodParameterReference();
    private sealed virtual override IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.get_AsGenericTypeInstanceReference();
    private sealed virtual override IGenericTypeParameterReference Microsoft.Cci.ITypeReference.get_AsGenericTypeParameterReference();
    private sealed virtual override INamespaceTypeDefinition Microsoft.Cci.ITypeReference.AsNamespaceTypeDefinition(EmitContext context);
    private sealed virtual override INamespaceTypeReference Microsoft.Cci.ITypeReference.get_AsNamespaceTypeReference();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.ITypeReference.AsNestedTypeDefinition(EmitContext context);
    private sealed virtual override INestedTypeReference Microsoft.Cci.ITypeReference.get_AsNestedTypeReference();
    private sealed virtual override ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.get_AsSpecializedNestedTypeReference();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.AsTypeDefinition(EmitContext context);
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
    public ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsStatic();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public TypeSymbol get_PointedAtType();
    internal virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
    internal virtual ImmutableArray`1<NamedTypeSymbol> InterfacesNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsValueType();
    internal sealed virtual bool get_IsManagedType();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public virtual SymbolKind get_Kind();
    public virtual TypeKind get_TypeKind();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual TResult Accept(CSharpSymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual void Accept(CSharpSymbolVisitor visitor);
    public virtual TResult Accept(CSharpSymbolVisitor`1<TResult> visitor);
    public virtual int GetHashCode();
    internal virtual bool Equals(TypeSymbol t2, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
    internal bool Equals(PointerTypeSymbol other);
    private bool Equals(PointerTypeSymbol other, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    internal virtual bool GetUnificationUseSiteDiagnosticRecursive(DiagnosticInfo& result, Symbol owner, HashSet`1& checkedTypes);
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.IPointerTypeSymbol.get_PointedAtType();
    private sealed virtual override ImmutableArray`1<CustomModifier> Microsoft.CodeAnalysis.IPointerTypeSymbol.get_CustomModifiers();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.PreprocessingSymbol : Symbol {
    private string _name;
    public string Name { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public SymbolKind Kind { get; }
    public Symbol ContainingSymbol { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal PreprocessingSymbol(string name);
    public virtual string get_Name();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual SymbolKind get_Kind();
    public virtual Symbol get_ContainingSymbol();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsStatic();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsExtern();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual TResult Accept(CSharpSymbolVisitor`2<TArgument, TResult> visitor, TArgument a);
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSymbolVisitor visitor);
    public virtual TResult Accept(CSharpSymbolVisitor`1<TResult> visitor);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.PropertyEarlyWellKnownAttributeData : CommonPropertyEarlyWellKnownAttributeData {
    private string _indexerName;
    public string IndexerName { get; public set; }
    public string get_IndexerName();
    public void set_IndexerName(string value);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol : Symbol {
    private ParameterSignature _lazyParameterSignature;
    private IEnumerable`1<IMethodReference> Microsoft.Cci.IPropertyDefinition.Accessors { get; }
    private IMetadataConstant Microsoft.Cci.IPropertyDefinition.DefaultValue { get; }
    private IMethodReference Microsoft.Cci.IPropertyDefinition.Getter { get; }
    private bool Microsoft.Cci.IPropertyDefinition.HasDefaultValue { get; }
    private bool Microsoft.Cci.IPropertyDefinition.IsRuntimeSpecial { get; }
    internal bool HasRuntimeSpecialName { get; }
    private bool Microsoft.Cci.IPropertyDefinition.IsSpecialName { get; }
    private ImmutableArray`1<IParameterDefinition> Microsoft.Cci.IPropertyDefinition.Parameters { get; }
    private IMethodReference Microsoft.Cci.IPropertyDefinition.Setter { get; }
    private CallingConvention Microsoft.Cci.ISignature.CallingConvention { get; }
    private ushort Microsoft.Cci.ISignature.ParameterCount { get; }
    private ImmutableArray`1<ICustomModifier> Microsoft.Cci.ISignature.ReturnValueCustomModifiers { get; }
    private bool Microsoft.Cci.ISignature.ReturnValueIsByRef { get; }
    private ITypeDefinition Microsoft.Cci.ITypeDefinitionMember.ContainingTypeDefinition { get; }
    private TypeMemberVisibility Microsoft.Cci.ITypeDefinitionMember.Visibility { get; }
    private string Microsoft.Cci.INamedEntity.Name { get; }
    public PropertySymbol OriginalDefinition { get; }
    protected Symbol OriginalSymbolDefinition { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    internal int ParameterCount { get; }
    internal ImmutableArray`1<TypeSymbol> ParameterTypes { get; }
    internal ImmutableArray`1<RefKind> ParameterRefKinds { get; }
    public bool IsIndexer { get; }
    public bool IsIndexedProperty { get; }
    public bool IsReadOnly { get; }
    public bool IsWriteOnly { get; }
    internal bool HasSpecialName { get; }
    public MethodSymbol GetMethod { get; }
    public MethodSymbol SetMethod { get; }
    internal CallingConvention CallingConvention { get; }
    internal bool MustCallMethodsDirectly { get; }
    public PropertySymbol OverriddenProperty { get; }
    internal OverriddenOrHiddenMembersResult OverriddenOrHiddenMembers { get; }
    internal bool HidesBasePropertiesByName { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<PropertySymbol> ExplicitInterfaceImplementations { get; }
    public SymbolKind Kind { get; }
    protected int HighestPriorityUseSiteError { get; }
    public bool HasUnsupportedMetadata { get; }
    private bool Microsoft.CodeAnalysis.IPropertySymbol.IsIndexer { get; }
    private ITypeSymbol Microsoft.CodeAnalysis.IPropertySymbol.Type { get; }
    private ImmutableArray`1<IParameterSymbol> Microsoft.CodeAnalysis.IPropertySymbol.Parameters { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.IPropertySymbol.GetMethod { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.IPropertySymbol.SetMethod { get; }
    private IPropertySymbol Microsoft.CodeAnalysis.IPropertySymbol.OriginalDefinition { get; }
    private IPropertySymbol Microsoft.CodeAnalysis.IPropertySymbol.OverriddenProperty { get; }
    private ImmutableArray`1<IPropertySymbol> Microsoft.CodeAnalysis.IPropertySymbol.ExplicitInterfaceImplementations { get; }
    private bool Microsoft.CodeAnalysis.IPropertySymbol.IsReadOnly { get; }
    private bool Microsoft.CodeAnalysis.IPropertySymbol.IsWriteOnly { get; }
    private bool Microsoft.CodeAnalysis.IPropertySymbol.IsWithEvents { get; }
    private ImmutableArray`1<CustomModifier> Microsoft.CodeAnalysis.IPropertySymbol.TypeCustomModifiers { get; }
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol/<Microsoft-Cci-IPropertyDefinition-get_Accessors>d__1")]
private sealed virtual override IEnumerable`1<IMethodReference> Microsoft.Cci.IPropertyDefinition.get_Accessors();
    private sealed virtual override IMetadataConstant Microsoft.Cci.IPropertyDefinition.get_DefaultValue();
    private sealed virtual override IMethodReference Microsoft.Cci.IPropertyDefinition.get_Getter();
    private sealed virtual override bool Microsoft.Cci.IPropertyDefinition.get_HasDefaultValue();
    private sealed virtual override bool Microsoft.Cci.IPropertyDefinition.get_IsRuntimeSpecial();
    internal virtual bool get_HasRuntimeSpecialName();
    private sealed virtual override bool Microsoft.Cci.IPropertyDefinition.get_IsSpecialName();
    private sealed virtual override ImmutableArray`1<IParameterDefinition> Microsoft.Cci.IPropertyDefinition.get_Parameters();
    private sealed virtual override IMethodReference Microsoft.Cci.IPropertyDefinition.get_Setter();
    private sealed virtual override CallingConvention Microsoft.Cci.ISignature.get_CallingConvention();
    private sealed virtual override ushort Microsoft.Cci.ISignature.get_ParameterCount();
    private sealed virtual override ImmutableArray`1<IParameterTypeInformation> Microsoft.Cci.ISignature.GetParameters(EmitContext context);
    private sealed virtual override ImmutableArray`1<ICustomModifier> Microsoft.Cci.ISignature.get_ReturnValueCustomModifiers();
    private sealed virtual override bool Microsoft.Cci.ISignature.get_ReturnValueIsByRef();
    private sealed virtual override ITypeReference Microsoft.Cci.ISignature.GetType(EmitContext context);
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeDefinitionMember.get_ContainingTypeDefinition();
    private sealed virtual override TypeMemberVisibility Microsoft.Cci.ITypeDefinitionMember.get_Visibility();
    private sealed virtual override ITypeReference Microsoft.Cci.ITypeMemberReference.GetContainingType(EmitContext context);
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
    private sealed virtual override string Microsoft.Cci.INamedEntity.get_Name();
    private IMethodReference GetSynthesizedSealedAccessor(MethodKind targetMethodKind);
    public virtual PropertySymbol get_OriginalDefinition();
    protected sealed virtual Symbol get_OriginalSymbolDefinition();
    public abstract virtual TypeSymbol get_Type();
    public abstract virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
    public abstract virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal int get_ParameterCount();
    internal ImmutableArray`1<TypeSymbol> get_ParameterTypes();
    internal ImmutableArray`1<RefKind> get_ParameterRefKinds();
    public abstract virtual bool get_IsIndexer();
    public virtual bool get_IsIndexedProperty();
    public bool get_IsReadOnly();
    public bool get_IsWriteOnly();
    internal abstract virtual bool get_HasSpecialName();
    public abstract virtual MethodSymbol get_GetMethod();
    public abstract virtual MethodSymbol get_SetMethod();
    internal abstract virtual CallingConvention get_CallingConvention();
    internal abstract virtual bool get_MustCallMethodsDirectly();
    public PropertySymbol get_OverriddenProperty();
    internal virtual OverriddenOrHiddenMembersResult get_OverriddenOrHiddenMembers();
    internal bool get_HidesBasePropertiesByName();
    internal PropertySymbol GetLeastOverriddenProperty(NamedTypeSymbol accessingTypeOpt);
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public abstract virtual ImmutableArray`1<PropertySymbol> get_ExplicitInterfaceImplementations();
    public sealed virtual SymbolKind get_Kind();
    internal virtual TResult Accept(CSharpSymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual void Accept(CSharpSymbolVisitor visitor);
    public virtual TResult Accept(CSharpSymbolVisitor`1<TResult> visitor);
    internal virtual PropertySymbol AsMember(NamedTypeSymbol newOwner);
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    internal bool CalculateUseSiteDiagnostic(DiagnosticInfo& result);
    protected virtual int get_HighestPriorityUseSiteError();
    public sealed virtual bool get_HasUnsupportedMetadata();
    private sealed virtual override bool Microsoft.CodeAnalysis.IPropertySymbol.get_IsIndexer();
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.IPropertySymbol.get_Type();
    private sealed virtual override ImmutableArray`1<IParameterSymbol> Microsoft.CodeAnalysis.IPropertySymbol.get_Parameters();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.IPropertySymbol.get_GetMethod();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.IPropertySymbol.get_SetMethod();
    private sealed virtual override IPropertySymbol Microsoft.CodeAnalysis.IPropertySymbol.get_OriginalDefinition();
    private sealed virtual override IPropertySymbol Microsoft.CodeAnalysis.IPropertySymbol.get_OverriddenProperty();
    private sealed virtual override ImmutableArray`1<IPropertySymbol> Microsoft.CodeAnalysis.IPropertySymbol.get_ExplicitInterfaceImplementations();
    private sealed virtual override bool Microsoft.CodeAnalysis.IPropertySymbol.get_IsReadOnly();
    private sealed virtual override bool Microsoft.CodeAnalysis.IPropertySymbol.get_IsWriteOnly();
    private sealed virtual override bool Microsoft.CodeAnalysis.IPropertySymbol.get_IsWithEvents();
    private sealed virtual override ImmutableArray`1<CustomModifier> Microsoft.CodeAnalysis.IPropertySymbol.get_TypeCustomModifiers();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbolExtensions : object {
    [ExtensionAttribute]
public static MethodSymbol GetOwnOrInheritedGetMethod(PropertySymbol property);
    [ExtensionAttribute]
public static MethodSymbol GetOwnOrInheritedSetMethod(PropertySymbol property);
    [ExtensionAttribute]
public static bool CanCallMethodsDirectly(PropertySymbol property);
    [ExtensionAttribute]
public static bool HasRefOrOutParameter(PropertySymbol property);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.RangeVariableSymbol : Symbol {
    private string _name;
    private ImmutableArray`1<Location> _locations;
    private Symbol _containingSymbol;
    [CompilerGeneratedAttribute]
private bool <IsTransparent>k__BackingField;
    internal bool IsTransparent { get; }
    public string Name { get; }
    public SymbolKind Kind { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsExtern { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public bool IsOverride { get; }
    public bool IsVirtual { get; }
    public bool IsStatic { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public Accessibility DeclaredAccessibility { get; }
    public Symbol ContainingSymbol { get; }
    internal RangeVariableSymbol(string Name, Symbol containingSymbol, Location location, bool isTransparent);
    [CompilerGeneratedAttribute]
internal bool get_IsTransparent();
    public virtual string get_Name();
    public virtual SymbolKind get_Kind();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool get_IsExtern();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsOverride();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsStatic();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual Symbol get_ContainingSymbol();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    internal virtual TResult Accept(CSharpSymbolVisitor`2<TArg, TResult> visitor, TArg a);
    public virtual void Accept(CSharpSymbolVisitor visitor);
    public virtual TResult Accept(CSharpSymbolVisitor`1<TResult> visitor);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.ReducedExtensionMethodSymbol : MethodSymbol {
    private MethodSymbol _reducedFrom;
    private TypeMap _typeMap;
    private ImmutableArray`1<TypeParameterSymbol> _typeParameters;
    private ImmutableArray`1<TypeSymbol> _typeArguments;
    private ImmutableArray`1<ParameterSymbol> _lazyParameters;
    internal MethodSymbol CallsiteReducedFromMethod { get; }
    public TypeSymbol ReceiverType { get; }
    public MethodSymbol ReducedFrom { get; }
    public MethodSymbol ConstructedFrom { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    internal CallingConvention CallingConvention { get; }
    public int Arity { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool RequiresSecurityObject { get; }
    internal MarshalPseudoCustomAttributeData ReturnValueMarshallingInformation { get; }
    internal bool HasDeclarativeSecurity { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public MethodSymbol OriginalDefinition { get; }
    public bool IsExtern { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsAbstract { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsAsync { get; }
    public bool IsExtensionMethod { get; }
    internal bool IsMetadataFinal { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public Accessibility DeclaredAccessibility { get; }
    public Symbol ContainingSymbol { get; }
    public Symbol AssociatedSymbol { get; }
    public MethodKind MethodKind { get; }
    public bool ReturnsVoid { get; }
    public bool IsGenericMethod { get; }
    public bool IsVararg { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    internal int ParameterCount { get; }
    internal bool GenerateDebugInfo { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public bool HidesBaseMethodsByName { get; }
    private ReducedExtensionMethodSymbol(MethodSymbol reducedFrom);
    public static MethodSymbol Create(MethodSymbol method, TypeSymbol receiverType, Compilation compilation);
    public static MethodSymbol Create(MethodSymbol method);
    internal virtual MethodSymbol get_CallsiteReducedFromMethod();
    public virtual TypeSymbol get_ReceiverType();
    public virtual TypeSymbol GetTypeInferredDuringReduction(TypeParameterSymbol reducedFromTypeParameter);
    public virtual MethodSymbol get_ReducedFrom();
    public virtual MethodSymbol get_ConstructedFrom();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    internal virtual CallingConvention get_CallingConvention();
    public virtual int get_Arity();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    internal virtual bool get_RequiresSecurityObject();
    public virtual DllImportData GetDllImportData();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnValueMarshallingInformation();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    public virtual MethodSymbol get_OriginalDefinition();
    public virtual bool get_IsExtern();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsOverride();
    public virtual bool get_IsStatic();
    public virtual bool get_IsAsync();
    public virtual bool get_IsExtensionMethod();
    internal sealed virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal sealed virtual bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_IsMetadataFinal();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    public virtual Symbol get_AssociatedSymbol();
    public virtual MethodKind get_MethodKind();
    public virtual bool get_ReturnsVoid();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsVararg();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    internal virtual int get_ParameterCount();
    internal virtual bool get_GenerateDebugInfo();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual bool get_HidesBaseMethodsByName();
    internal virtual bool CallsAreOmitted(SyntaxTree syntaxTree);
    private ImmutableArray`1<ParameterSymbol> MakeParameters();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.RefKindExtensions : object {
    [ExtensionAttribute]
public static SyntaxToken GetToken(RefKind refKind);
    [ExtensionAttribute]
public static RefKind GetRefKind(SyntaxKind syntaxKind);
    [ExtensionAttribute]
internal static SpecialType GetSpecialType(SyntaxKind kind);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol : NonMissingAssemblySymbol {
    private SourceAssemblySymbol _underlyingAssembly;
    private ImmutableArray`1<ModuleSymbol> _modules;
    private ImmutableArray`1<AssemblySymbol> _noPiaResolutionAssemblies;
    private ImmutableArray`1<AssemblySymbol> _linkedReferencedAssemblies;
    private ConcurrentDictionary`2<NamedTypeSymbol, NamedTypeSymbol> _noPiaUnificationMap;
    private bool _isLinked;
    private ImmutableArray`1<CSharpAttributeData> _lazyCustomAttributes;
    internal ConcurrentDictionary`2<NamedTypeSymbol, NamedTypeSymbol> NoPiaUnificationMap { get; }
    private RetargetingSymbolTranslator RetargetingTranslator { get; }
    public AssemblySymbol UnderlyingAssembly { get; }
    public bool IsImplicitlyDeclared { get; }
    public AssemblyIdentity Identity { get; }
    public Version AssemblyVersionPattern { get; }
    internal ImmutableArray`1<byte> PublicKey { get; }
    public ImmutableArray`1<ModuleSymbol> Modules { get; }
    internal bool KeepLookingForDeclaredSpecialTypes { get; }
    public ImmutableArray`1<Location> Locations { get; }
    internal bool IsLinked { get; }
    public ICollection`1<string> TypeNames { get; }
    public ICollection`1<string> NamespaceNames { get; }
    public bool MightContainExtensionMethods { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    public RetargetingAssemblySymbol(SourceAssemblySymbol underlyingAssembly, bool isLinked);
    internal ConcurrentDictionary`2<NamedTypeSymbol, NamedTypeSymbol> get_NoPiaUnificationMap();
    private RetargetingSymbolTranslator get_RetargetingTranslator();
    public AssemblySymbol get_UnderlyingAssembly();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual AssemblyIdentity get_Identity();
    public virtual Version get_AssemblyVersionPattern();
    internal virtual ImmutableArray`1<byte> get_PublicKey();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<ModuleSymbol> get_Modules();
    internal virtual bool get_KeepLookingForDeclaredSpecialTypes();
    public virtual ImmutableArray`1<Location> get_Locations();
    internal virtual IEnumerable`1<ImmutableArray`1<byte>> GetInternalsVisibleToPublicKeys(string simpleName);
    internal virtual bool AreInternalsVisibleToThisAssembly(AssemblySymbol other);
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal virtual NamedTypeSymbol GetDeclaredSpecialType(SpecialType type);
    internal virtual ImmutableArray`1<AssemblySymbol> GetNoPiaResolutionAssemblies();
    internal virtual void SetNoPiaResolutionAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal virtual void SetLinkedReferencedAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal virtual ImmutableArray`1<AssemblySymbol> GetLinkedReferencedAssemblies();
    internal virtual bool get_IsLinked();
    public virtual ICollection`1<string> get_TypeNames();
    public virtual ICollection`1<string> get_NamespaceNames();
    public virtual bool get_MightContainExtensionMethods();
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
    internal virtual bool GetGuidString(String& guidString);
    internal virtual NamedTypeSymbol TryLookupForwardedMetadataTypeWithCycleDetection(MetadataTypeName& emittedName, ConsList`1<AssemblySymbol> visitedAssemblies);
    public virtual AssemblyMetadata GetMetadata();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAttributeData : SourceAttributeData {
    internal RetargetingAttributeData(SyntaxReference applicationNode, NamedTypeSymbol attributeClass, MethodSymbol attributeConstructor, ImmutableArray`1<TypedConstant> constructorArguments, ImmutableArray`1<int> constructorArgumentsSourceIndices, ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArguments, bool hasErrors, bool isConditionallyOmitted);
    internal virtual TypeSymbol GetSystemType(Symbol targetSymbol);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingEventSymbol : EventSymbol {
    private RetargetingModuleSymbol _retargetingModule;
    private EventSymbol _underlyingEvent;
    private ImmutableArray`1<EventSymbol> _lazyExplicitInterfaceImplementations;
    private DiagnosticInfo _lazyUseSiteDiagnostic;
    private RetargetingSymbolTranslator RetargetingTranslator { get; }
    public EventSymbol UnderlyingEvent { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool HasSpecialName { get; }
    public TypeSymbol Type { get; }
    public MethodSymbol AddMethod { get; }
    public MethodSymbol RemoveMethod { get; }
    internal FieldSymbol AssociatedField { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<EventSymbol> ExplicitInterfaceImplementations { get; }
    public Symbol ContainingSymbol { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal ModuleSymbol ContainingModule { get; }
    public string Name { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool MustCallMethodsDirectly { get; }
    public bool IsWindowsRuntimeEvent { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    public RetargetingEventSymbol(RetargetingModuleSymbol retargetingModule, EventSymbol underlyingEvent);
    private RetargetingSymbolTranslator get_RetargetingTranslator();
    public EventSymbol get_UnderlyingEvent();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual bool get_HasSpecialName();
    public virtual TypeSymbol get_Type();
    public virtual MethodSymbol get_AddMethod();
    public virtual MethodSymbol get_RemoveMethod();
    internal virtual FieldSymbol get_AssociatedField();
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public virtual ImmutableArray`1<EventSymbol> get_ExplicitInterfaceImplementations();
    private ImmutableArray`1<EventSymbol> RetargetExplicitInterfaceImplementations();
    public virtual Symbol get_ContainingSymbol();
    public virtual AssemblySymbol get_ContainingAssembly();
    internal virtual ModuleSymbol get_ContainingModule();
    public virtual string get_Name();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsStatic();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsExtern();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal virtual IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    internal virtual bool get_MustCallMethodsDirectly();
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    public virtual bool get_IsWindowsRuntimeEvent();
    internal virtual bool get_HasRuntimeSpecialName();
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingFieldSymbol : FieldSymbol {
    private RetargetingModuleSymbol _retargetingModule;
    private FieldSymbol _underlyingField;
    private ImmutableArray`1<CustomModifier> _lazyCustomModifiers;
    private ImmutableArray`1<CSharpAttributeData> _lazyCustomAttributes;
    private DiagnosticInfo _lazyUseSiteDiagnostic;
    private RetargetingSymbolTranslator RetargetingTranslator { get; }
    public FieldSymbol UnderlyingField { get; }
    public RetargetingModuleSymbol RetargetingModule { get; }
    public bool IsImplicitlyDeclared { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public Symbol ContainingSymbol { get; }
    public Accessibility DeclaredAccessibility { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal ModuleSymbol ContainingModule { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal bool IsNotSerialized { get; }
    internal bool IsMarshalledExplicitly { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal ImmutableArray`1<byte> MarshallingDescriptor { get; }
    internal Nullable`1<int> TypeLayoutOffset { get; }
    public Symbol AssociatedSymbol { get; }
    public bool IsReadOnly { get; }
    public bool IsVolatile { get; }
    public bool IsConst { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public object ConstantValue { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsStatic { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    public RetargetingFieldSymbol(RetargetingModuleSymbol retargetingModule, FieldSymbol underlyingField);
    private RetargetingSymbolTranslator get_RetargetingTranslator();
    public FieldSymbol get_UnderlyingField();
    public RetargetingModuleSymbol get_RetargetingModule();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual TypeSymbol GetFieldType(ConsList`1<FieldSymbol> fieldsBeingBound);
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual Symbol get_ContainingSymbol();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal virtual IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public virtual AssemblySymbol get_ContainingAssembly();
    internal virtual ModuleSymbol get_ContainingModule();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_HasRuntimeSpecialName();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual bool get_IsNotSerialized();
    internal virtual bool get_IsMarshalledExplicitly();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    internal virtual Nullable`1<int> get_TypeLayoutOffset();
    public virtual Symbol get_AssociatedSymbol();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsVolatile();
    public virtual bool get_IsConst();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual object get_ConstantValue();
    internal virtual ConstantValue GetConstantValue(ConstantFieldsInProgress inProgress, bool earlyDecodingWellKnownAttributes);
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool get_IsStatic();
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingMethodParameterSymbol : RetargetingParameterSymbol {
    private RetargetingMethodSymbol _retargetingMethod;
    protected RetargetingModuleSymbol RetargetingModule { get; }
    public RetargetingMethodParameterSymbol(RetargetingMethodSymbol retargetingMethod, ParameterSymbol underlyingParameter);
    protected virtual RetargetingModuleSymbol get_RetargetingModule();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingMethodSymbol : MethodSymbol {
    private RetargetingModuleSymbol _retargetingModule;
    private MethodSymbol _underlyingMethod;
    private ImmutableArray`1<TypeParameterSymbol> _lazyTypeParameters;
    private ImmutableArray`1<ParameterSymbol> _lazyParameters;
    private ImmutableArray`1<CustomModifier> _lazyCustomModifiers;
    private ImmutableArray`1<CSharpAttributeData> _lazyCustomAttributes;
    private ImmutableArray`1<CSharpAttributeData> _lazyReturnTypeCustomAttributes;
    private ImmutableArray`1<MethodSymbol> _lazyExplicitInterfaceImplementations;
    private DiagnosticInfo _lazyUseSiteDiagnostic;
    private TypeSymbol _lazyReturnType;
    private RetargetingSymbolTranslator RetargetingTranslator { get; }
    public MethodSymbol UnderlyingMethod { get; }
    public RetargetingModuleSymbol RetargetingModule { get; }
    public bool IsVararg { get; }
    public bool IsGenericMethod { get; }
    public int Arity { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public bool ReturnsVoid { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    internal int ParameterCount { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public Symbol AssociatedSymbol { get; }
    public bool IsExtensionMethod { get; }
    public bool HidesBaseMethodsByName { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsAsync { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool IsMetadataFinal { get; }
    internal bool RequiresSecurityObject { get; }
    internal MarshalPseudoCustomAttributeData ReturnValueMarshallingInformation { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal ModuleSymbol ContainingModule { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    public MethodKind MethodKind { get; }
    internal CallingConvention CallingConvention { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    internal bool IsAccessCheckedOnOverride { get; }
    internal bool IsExternal { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal bool ReturnValueIsMarshalledExplicitly { get; }
    internal ImmutableArray`1<byte> ReturnValueMarshallingDescriptor { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    internal bool GenerateDebugInfo { get; }
    public RetargetingMethodSymbol(RetargetingModuleSymbol retargetingModule, MethodSymbol underlyingMethod);
    private RetargetingSymbolTranslator get_RetargetingTranslator();
    public MethodSymbol get_UnderlyingMethod();
    public RetargetingModuleSymbol get_RetargetingModule();
    public virtual bool get_IsVararg();
    public virtual bool get_IsGenericMethod();
    public virtual int get_Arity();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual bool get_ReturnsVoid();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    internal virtual int get_ParameterCount();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    private ImmutableArray`1<ParameterSymbol> RetargetParameters();
    public virtual Symbol get_AssociatedSymbol();
    public virtual bool get_IsExtensionMethod();
    public virtual bool get_HidesBaseMethodsByName();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsStatic();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsAsync();
    public virtual bool get_IsOverride();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsExtern();
    public virtual bool get_IsImplicitlyDeclared();
    internal sealed virtual bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_IsMetadataFinal();
    internal sealed virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_RequiresSecurityObject();
    public virtual DllImportData GetDllImportData();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnValueMarshallingInformation();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal virtual IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public virtual ImmutableArray`1<CSharpAttributeData> GetReturnTypeAttributes();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual AssemblySymbol get_ContainingAssembly();
    internal virtual ModuleSymbol get_ContainingModule();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    public virtual MethodKind get_MethodKind();
    internal virtual CallingConvention get_CallingConvention();
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    private ImmutableArray`1<MethodSymbol> RetargetExplicitInterfaceImplementations();
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    internal virtual bool get_IsAccessCheckedOnOverride();
    internal virtual bool get_IsExternal();
    internal virtual bool get_HasRuntimeSpecialName();
    internal virtual bool get_ReturnValueIsMarshalledExplicitly();
    internal virtual ImmutableArray`1<byte> get_ReturnValueMarshallingDescriptor();
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
    internal virtual bool get_GenerateDebugInfo();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol : NonMissingModuleSymbol {
    private RetargetingAssemblySymbol _retargetingAssembly;
    private SourceModuleSymbol _underlyingModule;
    private Dictionary`2<AssemblySymbol, DestinationData> _retargetingAssemblyMap;
    internal RetargetingSymbolTranslator RetargetingTranslator;
    private ImmutableArray`1<CSharpAttributeData> _lazyCustomAttributes;
    private ConcurrentDictionary`2<Symbol, Symbol> _symbolMap;
    private Func`2<Symbol, RetargetingMethodSymbol> _createRetargetingMethod;
    private Func`2<Symbol, RetargetingNamespaceSymbol> _createRetargetingNamespace;
    private Func`2<Symbol, RetargetingTypeParameterSymbol> _createRetargetingTypeParameter;
    private Func`2<Symbol, RetargetingNamedTypeSymbol> _createRetargetingNamedType;
    private Func`2<Symbol, RetargetingFieldSymbol> _createRetargetingField;
    private Func`2<Symbol, RetargetingPropertySymbol> _createRetargetingProperty;
    private Func`2<Symbol, RetargetingEventSymbol> _createRetargetingEvent;
    internal int Ordinal { get; }
    internal Machine Machine { get; }
    internal bool Bit32Required { get; }
    public SourceModuleSymbol UnderlyingModule { get; }
    public NamespaceSymbol GlobalNamespace { get; }
    public bool IsImplicitlyDeclared { get; }
    public string Name { get; }
    public Symbol ContainingSymbol { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public ImmutableArray`1<Location> Locations { get; }
    internal ICollection`1<string> TypeNames { get; }
    internal ICollection`1<string> NamespaceNames { get; }
    internal bool HasAssemblyCompilationRelaxationsAttribute { get; }
    internal bool HasAssemblyRuntimeCompatibilityAttribute { get; }
    internal Nullable`1<CharSet> DefaultMarshallingCharSet { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    public RetargetingModuleSymbol(RetargetingAssemblySymbol retargetingAssembly, SourceModuleSymbol underlyingModule);
    internal virtual int get_Ordinal();
    internal virtual Machine get_Machine();
    internal virtual bool get_Bit32Required();
    public SourceModuleSymbol get_UnderlyingModule();
    public virtual NamespaceSymbol get_GlobalNamespace();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual string get_Name();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    public virtual Symbol get_ContainingSymbol();
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual ImmutableArray`1<Location> get_Locations();
    internal virtual void SetReferences(ModuleReferences`1<AssemblySymbol> moduleReferences, SourceAssemblySymbol originatingSourceAssemblyDebugOnly);
    internal virtual ICollection`1<string> get_TypeNames();
    internal virtual ICollection`1<string> get_NamespaceNames();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal virtual bool get_HasAssemblyCompilationRelaxationsAttribute();
    internal virtual bool get_HasAssemblyRuntimeCompatibilityAttribute();
    internal virtual Nullable`1<CharSet> get_DefaultMarshallingCharSet();
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
    public virtual ModuleMetadata GetMetadata();
    private RetargetingMethodSymbol CreateRetargetingMethod(Symbol symbol);
    private RetargetingNamespaceSymbol CreateRetargetingNamespace(Symbol symbol);
    private RetargetingNamedTypeSymbol CreateRetargetingNamedType(Symbol symbol);
    private RetargetingFieldSymbol CreateRetargetingField(Symbol symbol);
    private RetargetingPropertySymbol CreateRetargetingProperty(Symbol symbol);
    private RetargetingEventSymbol CreateRetargetingEvent(Symbol symbol);
    private RetargetingTypeParameterSymbol CreateRetargetingTypeParameter(Symbol symbol);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingNamedTypeSymbol : NamedTypeSymbol {
    private RetargetingModuleSymbol _retargetingModule;
    private NamedTypeSymbol _underlyingType;
    private ImmutableArray`1<TypeParameterSymbol> _lazyTypeParameters;
    private NamedTypeSymbol _lazyBaseType;
    private ImmutableArray`1<NamedTypeSymbol> _lazyInterfaces;
    private NamedTypeSymbol _lazyDeclaredBaseType;
    private ImmutableArray`1<NamedTypeSymbol> _lazyDeclaredInterfaces;
    private ImmutableArray`1<CSharpAttributeData> _lazyCustomAttributes;
    private DiagnosticInfo _lazyUseSiteDiagnostic;
    private RetargetingSymbolTranslator RetargetingTranslator { get; }
    public NamedTypeSymbol UnderlyingNamedType { get; }
    public bool IsImplicitlyDeclared { get; }
    public int Arity { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    internal ImmutableArray`1<TypeSymbol> TypeArgumentsNoUseSiteDiagnostics { get; }
    internal bool HasTypeArgumentsCustomModifiers { get; }
    internal ImmutableArray`1<ImmutableArray`1<CustomModifier>> TypeArgumentsCustomModifiers { get; }
    public NamedTypeSymbol ConstructedFrom { get; }
    public NamedTypeSymbol EnumUnderlyingType { get; }
    public bool MightContainExtensionMethods { get; }
    public string Name { get; }
    public string MetadataName { get; }
    internal bool HasSpecialName { get; }
    internal bool MangleName { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public Accessibility DeclaredAccessibility { get; }
    public TypeKind TypeKind { get; }
    internal bool IsInterface { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    internal bool IsMetadataAbstract { get; }
    public bool IsSealed { get; }
    internal bool IsMetadataSealed { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal ModuleSymbol ContainingModule { get; }
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    internal NamedTypeSymbol ComImportCoClass { get; }
    internal bool IsComImport { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool ShouldAddWinRTMembers { get; }
    internal bool IsWindowsRuntimeImport { get; }
    internal TypeLayout Layout { get; }
    internal CharSet MarshallingCharSet { get; }
    internal bool IsSerializable { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    public RetargetingNamedTypeSymbol(RetargetingModuleSymbol retargetingModule, NamedTypeSymbol underlyingType);
    private RetargetingSymbolTranslator get_RetargetingTranslator();
    public NamedTypeSymbol get_UnderlyingNamedType();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual int get_Arity();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal virtual ImmutableArray`1<TypeSymbol> get_TypeArgumentsNoUseSiteDiagnostics();
    internal virtual bool get_HasTypeArgumentsCustomModifiers();
    internal virtual ImmutableArray`1<ImmutableArray`1<CustomModifier>> get_TypeArgumentsCustomModifiers();
    public virtual NamedTypeSymbol get_ConstructedFrom();
    public virtual NamedTypeSymbol get_EnumUnderlyingType();
    public virtual bool get_MightContainExtensionMethods();
    public virtual string get_Name();
    public virtual string get_MetadataName();
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_MangleName();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    internal virtual ImmutableArray`1<Symbol> GetMembersUnordered();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingNamedTypeSymbol/<GetFieldsToEmit>d__46")]
internal virtual IEnumerable`1<FieldSymbol> GetFieldsToEmit();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingNamedTypeSymbol/<GetMethodsToEmit>d__47")]
internal virtual IEnumerable`1<MethodSymbol> GetMethodsToEmit();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingNamedTypeSymbol/<GetPropertiesToEmit>d__48")]
internal virtual IEnumerable`1<PropertySymbol> GetPropertiesToEmit();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingNamedTypeSymbol/<GetEventsToEmit>d__49")]
internal virtual IEnumerable`1<EventSymbol> GetEventsToEmit();
    internal virtual ImmutableArray`1<Symbol> GetEarlyAttributeDecodingMembers();
    internal virtual ImmutableArray`1<Symbol> GetEarlyAttributeDecodingMembers(string name);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembersUnordered();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual TypeKind get_TypeKind();
    internal virtual bool get_IsInterface();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool get_IsStatic();
    public virtual bool get_IsAbstract();
    internal virtual bool get_IsMetadataAbstract();
    public virtual bool get_IsSealed();
    internal virtual bool get_IsMetadataSealed();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal virtual IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public virtual AssemblySymbol get_ContainingAssembly();
    internal virtual ModuleSymbol get_ContainingModule();
    internal virtual NamedTypeSymbol LookupMetadataType(MetadataTypeName& typeName);
    private static ExtendedErrorTypeSymbol CyclicInheritanceError(RetargetingNamedTypeSymbol type, TypeSymbol declaredBase);
    internal virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
    internal virtual ImmutableArray`1<NamedTypeSymbol> InterfacesNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetInterfacesToEmit();
    internal virtual NamedTypeSymbol GetDeclaredBaseType(ConsList`1<Symbol> basesBeingResolved);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved);
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    internal virtual NamedTypeSymbol get_ComImportCoClass();
    internal virtual bool get_IsComImport();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual bool get_ShouldAddWinRTMembers();
    internal virtual bool get_IsWindowsRuntimeImport();
    internal virtual TypeLayout get_Layout();
    internal virtual CharSet get_MarshallingCharSet();
    internal virtual bool get_IsSerializable();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual AttributeUsageInfo GetAttributeUsageInfo();
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
    internal virtual bool GetGuidString(String& guidString);
    [CompilerGeneratedAttribute]
private NamedTypeSymbol <InterfacesNoUseSiteDiagnostics>b__88_0(NamedTypeSymbol t);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingNamespaceSymbol : NamespaceSymbol {
    private RetargetingModuleSymbol _retargetingModule;
    private NamespaceSymbol _underlyingNamespace;
    private RetargetingSymbolTranslator RetargetingTranslator { get; }
    public NamespaceSymbol UnderlyingNamespace { get; }
    internal NamespaceExtent Extent { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal ModuleSymbol ContainingModule { get; }
    public bool IsGlobalNamespace { get; }
    public string Name { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    public RetargetingNamespaceSymbol(RetargetingModuleSymbol retargetingModule, NamespaceSymbol underlyingNamespace);
    private RetargetingSymbolTranslator get_RetargetingTranslator();
    public NamespaceSymbol get_UnderlyingNamespace();
    internal virtual NamespaceExtent get_Extent();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    private ImmutableArray`1<Symbol> RetargetMembers(ImmutableArray`1<Symbol> underlyingMembers);
    internal virtual ImmutableArray`1<Symbol> GetMembersUnordered();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembersUnordered();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    private ImmutableArray`1<NamedTypeSymbol> RetargetTypeMembers(ImmutableArray`1<NamedTypeSymbol> underlyingMembers);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual AssemblySymbol get_ContainingAssembly();
    internal virtual ModuleSymbol get_ContainingModule();
    public virtual bool get_IsGlobalNamespace();
    public virtual string get_Name();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual NamedTypeSymbol LookupMetadataType(MetadataTypeName& typeName);
    internal virtual void GetExtensionMethods(ArrayBuilder`1<MethodSymbol> methods, string nameOpt, int arity, LookupOptions options);
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingParameterSymbol : ParameterSymbol {
    private ParameterSymbol _underlyingParameter;
    private ImmutableArray`1<CustomModifier> _lazyCustomModifiers;
    private ImmutableArray`1<CSharpAttributeData> _lazyCustomAttributes;
    internal ParameterSymbol UnderlyingParameter { get; }
    protected RetargetingModuleSymbol RetargetingModule { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public Symbol ContainingSymbol { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal ModuleSymbol ContainingModule { get; }
    internal bool HasMetadataConstantValue { get; }
    internal bool IsMarshalledExplicitly { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal ImmutableArray`1<byte> MarshallingDescriptor { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    public RefKind RefKind { get; }
    internal bool IsMetadataIn { get; }
    internal bool IsMetadataOut { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public int Ordinal { get; }
    public bool IsParams { get; }
    internal bool IsMetadataOptional { get; }
    public bool IsImplicitlyDeclared { get; }
    public string Name { get; }
    public string MetadataName { get; }
    internal UnmanagedType MarshallingType { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerFilePath { get; }
    internal bool IsCallerMemberName { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    protected RetargetingParameterSymbol(ParameterSymbol underlyingParameter);
    internal ParameterSymbol get_UnderlyingParameter();
    protected abstract virtual RetargetingModuleSymbol get_RetargetingModule();
    public sealed virtual TypeSymbol get_Type();
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public sealed virtual Symbol get_ContainingSymbol();
    public sealed virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal sealed virtual IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public sealed virtual AssemblySymbol get_ContainingAssembly();
    internal sealed virtual ModuleSymbol get_ContainingModule();
    internal sealed virtual bool get_HasMetadataConstantValue();
    internal sealed virtual bool get_IsMarshalledExplicitly();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
    internal sealed virtual ConstantValue get_ExplicitDefaultConstantValue();
    public sealed virtual RefKind get_RefKind();
    internal sealed virtual bool get_IsMetadataIn();
    internal sealed virtual bool get_IsMetadataOut();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public sealed virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    public virtual int get_Ordinal();
    public virtual bool get_IsParams();
    internal virtual bool get_IsMetadataOptional();
    public virtual bool get_IsImplicitlyDeclared();
    public sealed virtual string get_Name();
    public sealed virtual string get_MetadataName();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal sealed virtual UnmanagedType get_MarshallingType();
    internal sealed virtual bool get_IsIDispatchConstant();
    internal sealed virtual bool get_IsIUnknownConstant();
    internal sealed virtual bool get_IsCallerLineNumber();
    internal sealed virtual bool get_IsCallerFilePath();
    internal sealed virtual bool get_IsCallerMemberName();
    internal sealed virtual ushort get_CountOfCustomModifiersPrecedingByRef();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingPropertyParameterSymbol : RetargetingParameterSymbol {
    private RetargetingPropertySymbol _retargetingProperty;
    protected RetargetingModuleSymbol RetargetingModule { get; }
    public RetargetingPropertyParameterSymbol(RetargetingPropertySymbol retargetingProperty, ParameterSymbol underlyingParameter);
    protected virtual RetargetingModuleSymbol get_RetargetingModule();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingPropertySymbol : PropertySymbol {
    private RetargetingModuleSymbol _retargetingModule;
    private PropertySymbol _underlyingProperty;
    private ImmutableArray`1<PropertySymbol> _lazyExplicitInterfaceImplementations;
    private ImmutableArray`1<ParameterSymbol> _lazyParameters;
    private ImmutableArray`1<CustomModifier> _lazyTypeCustomModifiers;
    private ImmutableArray`1<CSharpAttributeData> _lazyCustomAttributes;
    private DiagnosticInfo _lazyUseSiteDiagnostic;
    private TypeSymbol _lazyType;
    private RetargetingSymbolTranslator RetargetingTranslator { get; }
    public PropertySymbol UnderlyingProperty { get; }
    public bool IsImplicitlyDeclared { get; }
    public RetargetingModuleSymbol RetargetingModule { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public bool IsIndexer { get; }
    public MethodSymbol GetMethod { get; }
    public MethodSymbol SetMethod { get; }
    internal CallingConvention CallingConvention { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<PropertySymbol> ExplicitInterfaceImplementations { get; }
    public Symbol ContainingSymbol { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal ModuleSymbol ContainingModule { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool MustCallMethodsDirectly { get; }
    public string MetadataName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    public RetargetingPropertySymbol(RetargetingModuleSymbol retargetingModule, PropertySymbol underlyingProperty);
    private RetargetingSymbolTranslator get_RetargetingTranslator();
    public PropertySymbol get_UnderlyingProperty();
    public virtual bool get_IsImplicitlyDeclared();
    public RetargetingModuleSymbol get_RetargetingModule();
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    private ImmutableArray`1<ParameterSymbol> RetargetParameters();
    public virtual bool get_IsIndexer();
    public virtual MethodSymbol get_GetMethod();
    public virtual MethodSymbol get_SetMethod();
    internal virtual CallingConvention get_CallingConvention();
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public virtual ImmutableArray`1<PropertySymbol> get_ExplicitInterfaceImplementations();
    private ImmutableArray`1<PropertySymbol> RetargetExplicitInterfaceImplementations();
    public virtual Symbol get_ContainingSymbol();
    public virtual AssemblySymbol get_ContainingAssembly();
    internal virtual ModuleSymbol get_ContainingModule();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsStatic();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsExtern();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal virtual IEnumerable`1<CSharpAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    internal virtual bool get_MustCallMethodsDirectly();
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    public virtual string get_MetadataName();
    internal virtual bool get_HasRuntimeSpecialName();
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingTypeParameterSymbol : TypeParameterSymbol {
    private RetargetingModuleSymbol _retargetingModule;
    private TypeParameterSymbol _underlyingTypeParameter;
    private ImmutableArray`1<CSharpAttributeData> _lazyCustomAttributes;
    private RetargetingSymbolTranslator RetargetingTranslator { get; }
    public TypeParameterSymbol UnderlyingTypeParameter { get; }
    public bool IsImplicitlyDeclared { get; }
    public TypeParameterKind TypeParameterKind { get; }
    public int Ordinal { get; }
    public bool HasConstructorConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public VarianceKind Variance { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal ModuleSymbol ContainingModule { get; }
    public string Name { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    public RetargetingTypeParameterSymbol(RetargetingModuleSymbol retargetingModule, TypeParameterSymbol underlyingTypeParameter);
    private RetargetingSymbolTranslator get_RetargetingTranslator();
    public TypeParameterSymbol get_UnderlyingTypeParameter();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual TypeParameterKind get_TypeParameterKind();
    public virtual int get_Ordinal();
    public virtual bool get_HasConstructorConstraint();
    public virtual bool get_HasReferenceTypeConstraint();
    public virtual bool get_HasValueTypeConstraint();
    public virtual VarianceKind get_Variance();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    public virtual AssemblySymbol get_ContainingAssembly();
    internal virtual ModuleSymbol get_ContainingModule();
    public virtual string get_Name();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual void EnsureAllConstraintsAreResolved();
    internal virtual ImmutableArray`1<TypeSymbol> GetConstraintTypes(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetInterfaces(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual NamedTypeSymbol GetEffectiveBaseClass(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual TypeSymbol GetDeducedBaseType(ConsList`1<TypeParameterSymbol> inProgress);
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
}
internal enum Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetOptions : Enum {
    public byte value__;
    public static RetargetOptions RetargetPrimitiveTypesByName;
    public static RetargetOptions RetargetPrimitiveTypesByTypeCode;
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SignatureOnlyMethodSymbol : MethodSymbol {
    private string _name;
    private TypeSymbol _containingType;
    private MethodKind _methodKind;
    private CallingConvention _callingConvention;
    private ImmutableArray`1<TypeParameterSymbol> _typeParameters;
    private ImmutableArray`1<ParameterSymbol> _parameters;
    private TypeSymbol _returnType;
    private ImmutableArray`1<CustomModifier> _returnTypeCustomModifiers;
    private ImmutableArray`1<MethodSymbol> _explicitInterfaceImplementations;
    internal CallingConvention CallingConvention { get; }
    public bool IsVararg { get; }
    public bool IsGenericMethod { get; }
    public int Arity { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public bool ReturnsVoid { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public Symbol ContainingSymbol { get; }
    public MethodKind MethodKind { get; }
    public string Name { get; }
    internal bool GenerateDebugInfo { get; }
    internal bool HasSpecialName { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool RequiresSecurityObject { get; }
    internal MarshalPseudoCustomAttributeData ReturnValueMarshallingInformation { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public Symbol AssociatedSymbol { get; }
    public bool IsExtensionMethod { get; }
    public bool HidesBaseMethodsByName { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    public bool IsAsync { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal ModuleSymbol ContainingModule { get; }
    internal bool IsMetadataFinal { get; }
    public SignatureOnlyMethodSymbol(string name, TypeSymbol containingType, MethodKind methodKind, CallingConvention callingConvention, ImmutableArray`1<TypeParameterSymbol> typeParameters, ImmutableArray`1<ParameterSymbol> parameters, TypeSymbol returnType, ImmutableArray`1<CustomModifier> returnTypeCustomModifiers, ImmutableArray`1<MethodSymbol> explicitInterfaceImplementations);
    internal virtual CallingConvention get_CallingConvention();
    public virtual bool get_IsVararg();
    public virtual bool get_IsGenericMethod();
    public virtual int get_Arity();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual bool get_ReturnsVoid();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual Symbol get_ContainingSymbol();
    public virtual MethodKind get_MethodKind();
    public virtual string get_Name();
    internal virtual bool get_GenerateDebugInfo();
    internal virtual bool get_HasSpecialName();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    internal virtual bool get_RequiresSecurityObject();
    public virtual DllImportData GetDllImportData();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnValueMarshallingInformation();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual Symbol get_AssociatedSymbol();
    public virtual bool get_IsExtensionMethod();
    public virtual bool get_HidesBaseMethodsByName();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsStatic();
    public virtual bool get_IsAsync();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsExtern();
    public virtual AssemblySymbol get_ContainingAssembly();
    internal virtual ModuleSymbol get_ContainingModule();
    internal sealed virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal sealed virtual bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_IsMetadataFinal();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SignatureOnlyParameterSymbol : ParameterSymbol {
    private TypeSymbol _type;
    private ImmutableArray`1<CustomModifier> _customModifiers;
    private bool _isParams;
    private RefKind _refKind;
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public bool IsParams { get; }
    public RefKind RefKind { get; }
    public string Name { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool IsMetadataIn { get; }
    internal bool IsMetadataOut { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    public int Ordinal { get; }
    internal bool IsMetadataOptional { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    internal bool IsCallerFilePath { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerMemberName { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal ModuleSymbol ContainingModule { get; }
    public SignatureOnlyParameterSymbol(TypeSymbol type, ImmutableArray`1<CustomModifier> customModifiers, bool isParams, RefKind refKind);
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual bool get_IsParams();
    public virtual RefKind get_RefKind();
    public virtual string get_Name();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual bool get_IsMetadataIn();
    internal virtual bool get_IsMetadataOut();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    public virtual int get_Ordinal();
    internal virtual bool get_IsMetadataOptional();
    internal virtual ConstantValue get_ExplicitDefaultConstantValue();
    internal virtual bool get_IsIDispatchConstant();
    internal virtual bool get_IsIUnknownConstant();
    internal virtual bool get_IsCallerFilePath();
    internal virtual bool get_IsCallerLineNumber();
    internal virtual bool get_IsCallerMemberName();
    internal sealed virtual ushort get_CountOfCustomModifiersPrecedingByRef();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual AssemblySymbol get_ContainingAssembly();
    internal virtual ModuleSymbol get_ContainingModule();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SignatureOnlyPropertySymbol : PropertySymbol {
    private string _name;
    private TypeSymbol _containingType;
    private ImmutableArray`1<ParameterSymbol> _parameters;
    private TypeSymbol _type;
    private ImmutableArray`1<CustomModifier> _typeCustomModifiers;
    private bool _isStatic;
    private ImmutableArray`1<PropertySymbol> _explicitInterfaceImplementations;
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public bool IsStatic { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public ImmutableArray`1<PropertySymbol> ExplicitInterfaceImplementations { get; }
    public Symbol ContainingSymbol { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal CallingConvention CallingConvention { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal ModuleSymbol ContainingModule { get; }
    internal bool MustCallMethodsDirectly { get; }
    public MethodSymbol SetMethod { get; }
    public MethodSymbol GetMethod { get; }
    public bool IsIndexer { get; }
    public SignatureOnlyPropertySymbol(string name, TypeSymbol containingType, ImmutableArray`1<ParameterSymbol> parameters, TypeSymbol type, ImmutableArray`1<CustomModifier> typeCustomModifiers, bool isStatic, ImmutableArray`1<PropertySymbol> explicitInterfaceImplementations);
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
    public virtual bool get_IsStatic();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual ImmutableArray`1<PropertySymbol> get_ExplicitInterfaceImplementations();
    public virtual Symbol get_ContainingSymbol();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    internal virtual CallingConvention get_CallingConvention();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsExtern();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual AssemblySymbol get_ContainingAssembly();
    internal virtual ModuleSymbol get_ContainingModule();
    internal virtual bool get_MustCallMethodsDirectly();
    public virtual MethodSymbol get_SetMethod();
    public virtual MethodSymbol get_GetMethod();
    public virtual bool get_IsIndexer();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol : MetadataOrSourceAssemblySymbol {
    private CSharpCompilation _compilation;
    private SymbolCompletionState _state;
    internal AssemblyIdentity lazyAssemblyIdentity;
    private string _assemblySimpleName;
    private StrongNameKeys _lazyStrongNameKeys;
    private ImmutableArray`1<ModuleSymbol> _modules;
    private CustomAttributesBag`1<CSharpAttributeData> _lazySourceAttributesBag;
    private CustomAttributesBag`1<CSharpAttributeData> _lazyNetModuleAttributesBag;
    private IDictionary`2<string, NamedTypeSymbol> _lazyForwardedTypesFromSource;
    private ConcurrentSet`1<int> _lazyOmittedAttributeIndices;
    private ThreeState _lazyContainsExtensionMethods;
    private ConcurrentDictionary`2<FieldSymbol, bool> _unassignedFieldsMap;
    private ConcurrentSet`1<FieldSymbol> _unreadFields;
    internal ConcurrentSet`1<TypeSymbol> TypesReferencedInExternalMethods;
    private ImmutableArray`1<Diagnostic> _unusedFieldWarnings;
    private ConcurrentDictionary`2<AssemblySymbol, bool> _optimisticallyGrantedInternalsAccess;
    [ThreadStaticAttribute]
private static AssemblySymbol t_assemblyForWhichCurrentThreadIsComputingKeys;
    private ConcurrentDictionary`2<string, ConcurrentDictionary`2<ImmutableArray`1<byte>, Tuple`2<Location, string>>> _lazyInternalsVisibleToMap;
    public string Name { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    public bool IsInteractive { get; }
    public AssemblyIdentity Identity { get; }
    internal bool RuntimeCompatibilityWrapNonExceptionThrows { get; }
    internal string FileVersion { get; }
    internal string Title { get; }
    internal string Description { get; }
    internal string Company { get; }
    internal string Product { get; }
    internal string InformationalVersion { get; }
    internal string Copyright { get; }
    internal string Trademark { get; }
    private ThreeState AssemblyDelaySignAttributeSetting { get; }
    private string AssemblyKeyContainerAttributeSetting { get; }
    private string AssemblyKeyFileAttributeSetting { get; }
    private string AssemblyCultureAttributeSetting { get; }
    internal string SignatureKey { get; }
    private Version AssemblyVersionAttributeSetting { get; }
    public Version AssemblyVersionPattern { get; }
    internal AssemblyHashAlgorithm AssemblyHashAlgorithm { get; }
    internal Nullable`1<AssemblyHashAlgorithm> AssemblyAlgorithmIdAttributeSetting { get; }
    internal AssemblyNameFlags Flags { get; }
    internal StrongNameKeys StrongNameKeys { get; }
    internal ImmutableArray`1<byte> PublicKey { get; }
    public ImmutableArray`1<ModuleSymbol> Modules { get; }
    public ImmutableArray`1<Location> Locations { get; }
    private bool InternalsAreVisible { get; }
    internal bool IsDelaySigned { get; }
    internal SourceModuleSymbol SourceModule { get; }
    internal bool RequiresCompletion { get; }
    internal bool IsLinked { get; }
    internal bool DeclaresTheObjectClass { get; }
    public bool MightContainExtensionMethods { get; }
    private bool HasDebuggableAttribute { get; }
    private IAttributeTargetSymbol Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AttributesOwner { get; }
    private AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.DefaultAttributeLocation { get; }
    private AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AllowedAttributeLocations { get; }
    private Compilation Microsoft.CodeAnalysis.ISourceAssemblySymbol.Compilation { get; }
    internal SourceAssemblySymbol(CSharpCompilation compilation, string assemblySimpleName, string moduleName, ImmutableArray`1<PEModule> netModules);
    public virtual string get_Name();
    internal sealed virtual CSharpCompilation get_DeclaringCompilation();
    public virtual bool get_IsInteractive();
    internal bool MightContainNoPiaLocalTypes();
    public virtual AssemblyIdentity get_Identity();
    internal virtual Symbol GetSpecialTypeMember(SpecialMember member);
    private string GetWellKnownAttributeDataStringField(Func`2<CommonAssemblyWellKnownAttributeData`1<NamedTypeSymbol>, string> fieldGetter, string missingValue);
    internal bool get_RuntimeCompatibilityWrapNonExceptionThrows();
    internal string get_FileVersion();
    internal string get_Title();
    internal string get_Description();
    internal string get_Company();
    internal string get_Product();
    internal string get_InformationalVersion();
    internal string get_Copyright();
    internal string get_Trademark();
    private ThreeState get_AssemblyDelaySignAttributeSetting();
    private string get_AssemblyKeyContainerAttributeSetting();
    private string get_AssemblyKeyFileAttributeSetting();
    private string get_AssemblyCultureAttributeSetting();
    internal string get_SignatureKey();
    private Version get_AssemblyVersionAttributeSetting();
    public virtual Version get_AssemblyVersionPattern();
    internal AssemblyHashAlgorithm get_AssemblyHashAlgorithm();
    internal Nullable`1<AssemblyHashAlgorithm> get_AssemblyAlgorithmIdAttributeSetting();
    internal AssemblyNameFlags get_Flags();
    private StrongNameKeys ComputeStrongNameKeys();
    internal StrongNameKeys get_StrongNameKeys();
    internal virtual ImmutableArray`1<byte> get_PublicKey();
    public virtual ImmutableArray`1<ModuleSymbol> get_Modules();
    public virtual ImmutableArray`1<Location> get_Locations();
    private void ValidateAttributeSemantics(DiagnosticBag diagnostics);
    private static void ReportDiagnosticsForSynthesizedAttributes(CSharpCompilation compilation, DiagnosticBag diagnostics);
    private static void ReportDiagnosticsForUnsafeSynthesizedAttributes(CSharpCompilation compilation, DiagnosticBag diagnostics);
    private void ValidateIVTPublicKeys(DiagnosticBag diagnostics);
    private bool get_InternalsAreVisible();
    private void DetectAttributeAndOptionConflicts(DiagnosticBag diagnostics);
    internal bool get_IsDelaySigned();
    internal SourceModuleSymbol get_SourceModule();
    internal virtual bool get_RequiresCompletion();
    internal virtual bool HasComplete(CompletionPart part);
    internal virtual void ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken);
    private void ReportDiagnosticsForAddedModules();
    private void ReportNameCollisionDiagnosticsForAddedModules(NamespaceSymbol ns, DiagnosticBag diagnostics);
    private bool IsKnownAssemblyAttribute(CSharpAttributeData attribute);
    private void AddOmittedAttributeIndex(int index);
    private HashSet`1<CSharpAttributeData> GetUniqueSourceAssemblyAttributes();
    private static bool AddUniqueAssemblyAttribute(CSharpAttributeData attribute, HashSet`1& uniqueAttributes);
    private bool ValidateAttributeUsageForNetModuleAttribute(CSharpAttributeData attribute, string netModuleName, DiagnosticBag diagnostics, HashSet`1& uniqueAttributes);
    private ImmutableArray`1<CSharpAttributeData> GetNetModuleAttributes(ImmutableArray`1& netModuleNames);
    private WellKnownAttributeData ValidateAttributeUsageAndDecodeWellKnownAttributes(ImmutableArray`1<CSharpAttributeData> attributesFromNetModules, ImmutableArray`1<string> netModuleNames, DiagnosticBag diagnostics);
    private void LoadAndValidateNetModuleAttributes(CustomAttributesBag`1& lazyNetModuleAttributesBag);
    private void EnsureNetModuleAttributesAreBound();
    private CustomAttributesBag`1<CSharpAttributeData> GetNetModuleAttributesBag();
    internal CommonAssemblyWellKnownAttributeData`1<NamedTypeSymbol> GetNetModuleDecodedWellKnownAttributeData();
    internal ImmutableArray`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    private void EnsureAttributesAreBound();
    private CustomAttributesBag`1<CSharpAttributeData> GetSourceAttributesBag();
    public sealed virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal bool IsIndexOfOmittedAssemblyAttribute(int index);
    internal CommonAssemblyWellKnownAttributeData`1<NamedTypeSymbol> GetSourceDecodedWellKnownAttributeData();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol/<GetSecurityAttributes>d__111")]
private static IEnumerable`1<SecurityAttribute> GetSecurityAttributes(CustomAttributesBag`1<CSharpAttributeData> attributesBag);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol/<GetSecurityAttributes>d__112")]
internal IEnumerable`1<SecurityAttribute> GetSecurityAttributes();
    internal virtual ImmutableArray`1<AssemblySymbol> GetNoPiaResolutionAssemblies();
    internal virtual void SetNoPiaResolutionAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal virtual ImmutableArray`1<AssemblySymbol> GetLinkedReferencedAssemblies();
    internal virtual void SetLinkedReferencedAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal virtual bool get_IsLinked();
    internal bool get_DeclaresTheObjectClass();
    public virtual bool get_MightContainExtensionMethods();
    private bool get_HasDebuggableAttribute();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    private bool ContainsExtensionMethods();
    private static bool ContainsExtensionMethods(ImmutableArray`1<ModuleSymbol> modules);
    private static bool ContainsExtensionMethods(NamespaceSymbol ns);
    private void CheckOptimisticIVTAccessGrants(DiagnosticBag bag);
    internal virtual IEnumerable`1<ImmutableArray`1<byte>> GetInternalsVisibleToPublicKeys(string simpleName);
    internal virtual bool AreInternalsVisibleToThisAssembly(AssemblySymbol potentialGiverOfAccess);
    private AssemblyIdentity ComputeIdentity();
    private static Location GetAssemblyAttributeLocationForDiagnostic(AttributeSyntax attributeSyntaxOpt);
    private void DecodeTypeForwardedToAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    private void DecodeOneInternalsVisibleToAttribute(AttributeSyntax nodeOpt, CSharpAttributeData attrData, DiagnosticBag diagnostics, int index, ConcurrentDictionary`2& lazyInternalsVisibleToMap);
    private sealed virtual override IAttributeTargetSymbol Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_AttributesOwner();
    private sealed virtual override AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_DefaultAttributeLocation();
    private sealed virtual override AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_AllowedAttributeLocations();
    internal virtual void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    private void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments, int index, bool isFromNetModule);
    private static void ValidateIntegralAttributeNonNegativeArguments(CSharpAttributeData attribute, AttributeSyntax nodeOpt, DiagnosticBag diagnostics);
    internal void NoteFieldAccess(FieldSymbol field, bool read, bool write);
    internal void NoteFieldDefinition(FieldSymbol field, bool isInternal, bool isUnread);
    internal ImmutableArray`1<Diagnostic> GetUnusedFieldWarnings(CancellationToken cancellationToken);
    private static string DefaultValue(TypeSymbol type);
    internal virtual NamedTypeSymbol TryLookupForwardedMetadataTypeWithCycleDetection(MetadataTypeName& emittedName, ConsList`1<AssemblySymbol> visitedAssemblies);
    public virtual AssemblyMetadata GetMetadata();
    private sealed virtual override Compilation Microsoft.CodeAnalysis.ISourceAssemblySymbol.get_Compilation();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceAttributeData : CSharpAttributeData {
    private NamedTypeSymbol _attributeClass;
    private MethodSymbol _attributeConstructor;
    private ImmutableArray`1<TypedConstant> _constructorArguments;
    private ImmutableArray`1<int> _constructorArgumentsSourceIndices;
    private ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> _namedArguments;
    private bool _isConditionallyOmitted;
    private bool _hasErrors;
    private SyntaxReference _applicationNode;
    public NamedTypeSymbol AttributeClass { get; }
    public MethodSymbol AttributeConstructor { get; }
    public SyntaxReference ApplicationSyntaxReference { get; }
    internal ImmutableArray`1<int> ConstructorArgumentsSourceIndices { get; }
    internal bool IsConditionallyOmitted { get; }
    internal bool HasErrors { get; }
    protected internal ImmutableArray`1<TypedConstant> CommonConstructorArguments { get; }
    protected internal ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> CommonNamedArguments { get; }
    internal SourceAttributeData(SyntaxReference applicationNode, NamedTypeSymbol attributeClass, MethodSymbol attributeConstructor, ImmutableArray`1<TypedConstant> constructorArguments, ImmutableArray`1<int> constructorArgumentsSourceIndices, ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArguments, bool hasErrors, bool isConditionallyOmitted);
    internal SourceAttributeData(SyntaxReference applicationNode, NamedTypeSymbol attributeClass, MethodSymbol attributeConstructor, bool hasErrors);
    public virtual NamedTypeSymbol get_AttributeClass();
    public virtual MethodSymbol get_AttributeConstructor();
    public virtual SyntaxReference get_ApplicationSyntaxReference();
    internal ImmutableArray`1<int> get_ConstructorArgumentsSourceIndices();
    internal CSharpSyntaxNode GetAttributeArgumentSyntax(int parameterIndex, AttributeSyntax attributeSyntax);
    internal virtual bool get_IsConditionallyOmitted();
    internal SourceAttributeData WithOmittedCondition(bool isConditionallyOmitted);
    internal virtual bool get_HasErrors();
    protected internal sealed virtual ImmutableArray`1<TypedConstant> get_CommonConstructorArguments();
    protected internal sealed virtual ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> get_CommonNamedArguments();
    internal virtual int GetTargetAttributeSignatureIndex(Symbol targetSymbol, AttributeDescription description);
    internal virtual TypeSymbol GetSystemType(Symbol targetSymbol);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceClonedParameterSymbol : SourceParameterSymbolBase {
    private bool _suppressOptional;
    private SourceParameterSymbol _originalParam;
    public bool IsImplicitlyDeclared { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsParams { get; }
    internal bool IsMetadataOptional { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    internal ConstantValue DefaultValueFromAttributes { get; }
    public TypeSymbol Type { get; }
    public RefKind RefKind { get; }
    internal bool IsMetadataIn { get; }
    internal bool IsMetadataOut { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public string Name { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    internal bool IsCallerFilePath { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerMemberName { get; }
    internal SourceClonedParameterSymbol(SourceParameterSymbol originalParam, Symbol newOwner, int newOrdinal, bool suppressOptional);
    public virtual bool get_IsImplicitlyDeclared();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool get_IsParams();
    internal virtual bool get_IsMetadataOptional();
    internal virtual ConstantValue get_ExplicitDefaultConstantValue();
    internal virtual ConstantValue get_DefaultValueFromAttributes();
    internal virtual ParameterSymbol WithCustomModifiersAndParams(TypeSymbol newType, ImmutableArray`1<CustomModifier> newCustomModifiers, ushort countOfCustomModifiersPrecedingByRef, bool newIsParams);
    public virtual TypeSymbol get_Type();
    public virtual RefKind get_RefKind();
    internal virtual bool get_IsMetadataIn();
    internal virtual bool get_IsMetadataOut();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    public sealed virtual string get_Name();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual bool get_IsIDispatchConstant();
    internal virtual bool get_IsIUnknownConstant();
    internal virtual bool get_IsCallerFilePath();
    internal virtual bool get_IsCallerLineNumber();
    internal virtual bool get_IsCallerMemberName();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbol : SourceParameterSymbol {
    private SyntaxReference _syntaxRef;
    private ParameterSyntaxKind _parameterSyntaxKind;
    private CustomAttributesBag`1<CSharpAttributeData> _lazyCustomAttributesBag;
    private ThreeState _lazyHasOptionalAttribute;
    private ConstantValue _lazyDefaultSyntaxValue;
    internal SyntaxReference SyntaxReference { get; }
    internal ParameterSyntax CSharpSyntaxNode { get; }
    internal SyntaxTree SyntaxTree { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    internal ConstantValue DefaultValueFromAttributes { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    private bool HasCallerLineNumberAttribute { get; }
    private bool HasCallerFilePathAttribute { get; }
    private bool HasCallerMemberNameAttribute { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerFilePath { get; }
    internal bool IsCallerMemberName { get; }
    private ConstantValue DefaultSyntaxValue { get; }
    public string MetadataName { get; }
    protected IAttributeTargetSymbol AttributeOwner { get; }
    private IAttributeTargetSymbol Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AttributesOwner { get; }
    private AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.DefaultAttributeLocation { get; }
    private AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AllowedAttributeLocations { get; }
    private SourceParameterSymbol BoundAttributesSource { get; }
    internal SyntaxList`1<AttributeListSyntax> AttributeDeclarationList { get; }
    internal bool HasDefaultArgumentSyntax { get; }
    internal bool HasOptionalAttribute { get; }
    internal bool IsMetadataOptional { get; }
    internal bool IsMetadataIn { get; }
    internal bool IsMetadataOut { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    public bool IsParams { get; }
    internal bool IsExtensionMethodThis { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    internal SourceComplexParameterSymbol(Symbol owner, int ordinal, TypeSymbol parameterType, RefKind refKind, string name, ImmutableArray`1<Location> locations, SyntaxReference syntaxRef, ConstantValue defaultSyntaxValue, bool isParams, bool isExtensionMethodThis);
    internal virtual SyntaxReference get_SyntaxReference();
    internal ParameterSyntax get_CSharpSyntaxNode();
    internal SyntaxTree get_SyntaxTree();
    internal virtual ConstantValue get_ExplicitDefaultConstantValue();
    internal virtual ConstantValue get_DefaultValueFromAttributes();
    internal virtual bool get_IsIDispatchConstant();
    internal virtual bool get_IsIUnknownConstant();
    private bool get_HasCallerLineNumberAttribute();
    private bool get_HasCallerFilePathAttribute();
    private bool get_HasCallerMemberNameAttribute();
    internal virtual bool get_IsCallerLineNumber();
    internal virtual bool get_IsCallerFilePath();
    internal virtual bool get_IsCallerMemberName();
    private ConstantValue get_DefaultSyntaxValue();
    private ConstantValue MakeDefaultExpression(DiagnosticBag diagnostics);
    public virtual string get_MetadataName();
    protected virtual IAttributeTargetSymbol get_AttributeOwner();
    private sealed virtual override IAttributeTargetSymbol Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_AttributesOwner();
    private sealed virtual override AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_DefaultAttributeLocation();
    private sealed virtual override AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_AllowedAttributeLocations();
    private SourceParameterSymbol get_BoundAttributesSource();
    internal sealed virtual SyntaxList`1<AttributeListSyntax> get_AttributeDeclarationList();
    internal virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    internal CommonParameterWellKnownAttributeData GetDecodedWellKnownAttributeData();
    internal ParameterEarlyWellKnownAttributeData GetEarlyDecodedWellKnownAttributeData();
    internal sealed virtual CustomAttributesBag`1<CSharpAttributeData> GetAttributesBag();
    internal virtual void EarlyDecodeWellKnownAttributeType(NamedTypeSymbol attributeType, AttributeSyntax attributeSyntax);
    internal virtual void PostEarlyDecodeWellKnownAttributeTypes();
    internal virtual CSharpAttributeData EarlyDecodeWellKnownAttribute(EarlyDecodeWellKnownAttributeArguments`4& arguments);
    private CSharpAttributeData EarlyDecodeAttributeForDefaultParameterValue(AttributeDescription description, EarlyDecodeWellKnownAttributeArguments`4& arguments);
    internal virtual void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    private void DecodeDefaultParameterValueAttribute(AttributeDescription description, DecodeWellKnownAttributeArguments`3& arguments);
    private void VerifyParamDefaultValueMatchesAttributeIfAny(ConstantValue value, CSharpSyntaxNode syntax, DiagnosticBag diagnostics);
    private ConstantValue DecodeDefaultParameterValueAttribute(AttributeDescription description, CSharpAttributeData attribute, AttributeSyntax node, bool diagnose, DiagnosticBag diagnosticsOpt);
    private ConstantValue DecodeDefaultParameterValueAttribute(CSharpAttributeData attribute, AttributeSyntax node, bool diagnose, DiagnosticBag diagnosticsOpt);
    private bool IsValidCallerInfoContext(AttributeSyntax node);
    private bool IsOnPartialImplementation(AttributeSyntax node);
    private void ValidateCallerLineNumberAttribute(AttributeSyntax node, DiagnosticBag diagnostics);
    private void ValidateCallerFilePathAttribute(AttributeSyntax node, DiagnosticBag diagnostics);
    private void ValidateCallerMemberNameAttribute(AttributeSyntax node, DiagnosticBag diagnostics);
    internal virtual void PostDecodeWellKnownAttributes(ImmutableArray`1<CSharpAttributeData> boundAttributes, ImmutableArray`1<AttributeSyntax> allAttributeSyntaxNodes, DiagnosticBag diagnostics, AttributeLocation symbolPart, WellKnownAttributeData decodedData);
    internal virtual bool get_HasDefaultArgumentSyntax();
    internal sealed virtual bool get_HasOptionalAttribute();
    internal virtual bool get_IsMetadataOptional();
    internal sealed virtual bool get_IsMetadataIn();
    internal sealed virtual bool get_IsMetadataOut();
    internal sealed virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    public virtual bool get_IsParams();
    internal virtual bool get_IsExtensionMethodThis();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    internal virtual ushort get_CountOfCustomModifiersPrecedingByRef();
    internal virtual void ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbolWithCustomModifiers : SourceComplexParameterSymbol {
    private ImmutableArray`1<CustomModifier> _customModifiers;
    private ushort _countOfCustomModifiersPrecedingByRef;
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    internal SourceComplexParameterSymbolWithCustomModifiers(Symbol owner, int ordinal, TypeSymbol parameterType, RefKind refKind, ImmutableArray`1<CustomModifier> customModifiers, ushort countOfCustomModifiersPrecedingByRef, string name, ImmutableArray`1<Location> locations, SyntaxReference syntaxRef, ConstantValue defaultSyntaxValue, bool isParams, bool isExtensionMethodThis);
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    internal virtual ushort get_CountOfCustomModifiersPrecedingByRef();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceConstructorSymbol : SourceMethodSymbol {
    private ImmutableArray`1<ParameterSymbol> _lazyParameters;
    private TypeSymbol _lazyReturnType;
    private bool _lazyIsVararg;
    public bool IsVararg { get; }
    public bool IsImplicitlyDeclared { get; }
    internal int ParameterCount { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public TypeSymbol ReturnType { get; }
    public string Name { get; }
    protected IAttributeTargetSymbol AttributeOwner { get; }
    internal bool IsExpressionBodied { get; }
    internal bool GenerateDebugInfo { get; }
    private SourceConstructorSymbol(SourceMemberContainerTypeSymbol containingType, Location location, ConstructorDeclarationSyntax syntax, MethodKind methodKind, DiagnosticBag diagnostics);
    public static SourceConstructorSymbol CreateConstructorSymbol(SourceMemberContainerTypeSymbol containingType, ConstructorDeclarationSyntax syntax, DiagnosticBag diagnostics);
    protected virtual void MethodChecks(DiagnosticBag diagnostics);
    internal ConstructorDeclarationSyntax GetSyntax();
    public virtual bool get_IsVararg();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual int get_ParameterCount();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual TypeSymbol get_ReturnType();
    private DeclarationModifiers MakeModifiers(SyntaxTokenList modifiers, MethodKind methodKind, Location location, DiagnosticBag diagnostics, Boolean& modifierErrors);
    private void CheckModifiers(MethodKind methodKind, Location location, DiagnosticBag diagnostics);
    public virtual string get_Name();
    internal virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    internal virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetReturnTypeAttributeDeclarations();
    protected virtual IAttributeTargetSymbol get_AttributeOwner();
    internal virtual bool get_IsExpressionBodied();
    internal virtual bool get_GenerateDebugInfo();
    internal virtual int CalculateLocalSyntaxOffset(int position, SyntaxTree tree);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceCustomEventAccessorSymbol : SourceEventAccessorSymbol {
    private ImmutableArray`1<MethodSymbol> _explicitInterfaceImplementations;
    private string _name;
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public string Name { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool GenerateDebugInfo { get; }
    internal SourceCustomEventAccessorSymbol(SourceEventSymbol event, AccessorDeclarationSyntax syntax, EventSymbol explicitlyImplementedEventOpt, string aliasQualifierOpt, DiagnosticBag diagnostics);
    internal AccessorDeclarationSyntax GetSyntax();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    internal virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    public virtual string get_Name();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual bool get_GenerateDebugInfo();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceCustomEventSymbol : SourceEventSymbol {
    private TypeSymbol _type;
    private string _name;
    private SourceCustomEventAccessorSymbol _addMethod;
    private SourceCustomEventAccessorSymbol _removeMethod;
    private TypeSymbol _explicitInterfaceType;
    private ImmutableArray`1<EventSymbol> _explicitInterfaceImplementations;
    public TypeSymbol Type { get; }
    public string Name { get; }
    public MethodSymbol AddMethod { get; }
    public MethodSymbol RemoveMethod { get; }
    protected AttributeLocation AllowedAttributeLocations { get; }
    private ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<EventSymbol> ExplicitInterfaceImplementations { get; }
    internal SourceCustomEventSymbol(SourceMemberContainerTypeSymbol containingType, Binder binder, EventDeclarationSyntax syntax, DiagnosticBag diagnostics);
    public virtual TypeSymbol get_Type();
    public virtual string get_Name();
    public virtual MethodSymbol get_AddMethod();
    public virtual MethodSymbol get_RemoveMethod();
    protected virtual AttributeLocation get_AllowedAttributeLocations();
    private ExplicitInterfaceSpecifierSyntax get_ExplicitInterfaceSpecifier();
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public virtual ImmutableArray`1<EventSymbol> get_ExplicitInterfaceImplementations();
    internal virtual void AfterAddingTypeMembersChecks(ConversionsBase conversions, DiagnosticBag diagnostics);
    private SourceCustomEventAccessorSymbol CreateAccessorSymbol(AccessorDeclarationSyntax syntaxOpt, EventSymbol explicitlyImplementedEventOpt, string aliasQualifierOpt, DiagnosticBag diagnostics);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SourceDelegateMethodSymbol : SourceMethodSymbol {
    private ImmutableArray`1<ParameterSymbol> _parameters;
    private TypeSymbol _returnType;
    public bool IsVararg { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public TypeSymbol ReturnType { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool IsExpressionBodied { get; }
    internal bool GenerateDebugInfo { get; }
    protected IAttributeTargetSymbol AttributeOwner { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    protected SourceDelegateMethodSymbol(SourceMemberContainerTypeSymbol delegateType, TypeSymbol returnType, DelegateDeclarationSyntax syntax, MethodKind methodKind, DeclarationModifiers declarationModifiers);
    protected void InitializeParameters(ImmutableArray`1<ParameterSymbol> parameters);
    internal static void AddDelegateMembers(SourceMemberContainerTypeSymbol delegateType, ArrayBuilder`1<Symbol> symbols, DelegateDeclarationSyntax syntax, DiagnosticBag diagnostics);
    protected virtual void MethodChecks(DiagnosticBag diagnostics);
    public sealed virtual bool get_IsVararg();
    public sealed virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public sealed virtual TypeSymbol get_ReturnType();
    public sealed virtual bool get_IsImplicitlyDeclared();
    internal virtual bool get_IsExpressionBodied();
    internal virtual bool get_GenerateDebugInfo();
    protected sealed virtual IAttributeTargetSymbol get_AttributeOwner();
    internal sealed virtual MethodImplAttributes get_ImplementationAttributes();
    internal sealed virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    internal sealed virtual AttributeTargets GetAttributeTarget();
    private static string GetUniqueParameterName(ArrayBuilder`1<ParameterSymbol> currentParameters, string name);
    private static bool IsUnique(ArrayBuilder`1<ParameterSymbol> currentParameters, string name);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceDestructorSymbol : SourceMethodSymbol {
    private TypeSymbol _lazyReturnType;
    public bool IsVararg { get; }
    internal int ParameterCount { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public TypeSymbol ReturnType { get; }
    public string Name { get; }
    internal bool IsExpressionBodied { get; }
    internal bool IsMetadataFinal { get; }
    internal bool GenerateDebugInfo { get; }
    internal SourceDestructorSymbol(SourceMemberContainerTypeSymbol containingType, DestructorDeclarationSyntax syntax, DiagnosticBag diagnostics);
    protected virtual void MethodChecks(DiagnosticBag diagnostics);
    internal DestructorDeclarationSyntax GetSyntax();
    public virtual bool get_IsVararg();
    internal virtual int get_ParameterCount();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual TypeSymbol get_ReturnType();
    private DeclarationModifiers MakeModifiers(SyntaxTokenList modifiers, Location location, DiagnosticBag diagnostics, Boolean& modifierErrors);
    public virtual string get_Name();
    internal virtual bool get_IsExpressionBodied();
    internal virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    internal virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetReturnTypeAttributeDeclarations();
    internal sealed virtual bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_IsMetadataFinal();
    internal sealed virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_GenerateDebugInfo();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SourceEnumConstantSymbol : SourceFieldSymbolWithSyntaxReference {
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public Symbol AssociatedSymbol { get; }
    protected DeclarationModifiers Modifiers { get; }
    public EnumMemberDeclarationSyntax SyntaxNode { get; }
    protected SyntaxList`1<AttributeListSyntax> AttributeDeclarationSyntaxList { get; }
    protected SourceEnumConstantSymbol(SourceMemberContainerTypeSymbol containingEnum, EnumMemberDeclarationSyntax syntax, DiagnosticBag diagnostics);
    public static SourceEnumConstantSymbol CreateExplicitValuedConstant(SourceMemberContainerTypeSymbol containingEnum, EnumMemberDeclarationSyntax syntax, DiagnosticBag diagnostics);
    public static SourceEnumConstantSymbol CreateImplicitValuedConstant(SourceMemberContainerTypeSymbol containingEnum, EnumMemberDeclarationSyntax syntax, SourceEnumConstantSymbol otherConstant, int otherConstantOffset, DiagnosticBag diagnostics);
    internal virtual TypeSymbol GetFieldType(ConsList`1<FieldSymbol> fieldsBeingBound);
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual Symbol get_AssociatedSymbol();
    protected sealed virtual DeclarationModifiers get_Modifiers();
    public EnumMemberDeclarationSyntax get_SyntaxNode();
    protected virtual SyntaxList`1<AttributeListSyntax> get_AttributeDeclarationSyntaxList();
    internal sealed virtual void ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventAccessorSymbol : SourceMethodSymbol {
    private SourceEventSymbol _event;
    private ImmutableArray`1<ParameterSymbol> _lazyParameters;
    private TypeSymbol _lazyReturnType;
    public SourceEventSymbol AssociatedEvent { get; }
    public Symbol AssociatedSymbol { get; }
    public bool ReturnsVoid { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public bool IsVararg { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    internal Location Location { get; }
    internal bool IsExpressionBodied { get; }
    public SourceEventAccessorSymbol(SourceEventSymbol event, SyntaxReference syntaxReference, SyntaxReference blockSyntaxReference, ImmutableArray`1<Location> locations);
    public SourceEventSymbol get_AssociatedEvent();
    public sealed virtual Symbol get_AssociatedSymbol();
    protected sealed virtual void MethodChecks(DiagnosticBag diagnostics);
    public sealed virtual bool get_ReturnsVoid();
    public sealed virtual TypeSymbol get_ReturnType();
    public sealed virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public sealed virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public sealed virtual bool get_IsVararg();
    public sealed virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal Location get_Location();
    protected string GetOverriddenAccessorName(SourceEventSymbol event, bool isAdder);
    internal virtual bool get_IsExpressionBodied();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventFieldSymbol : SourceMemberFieldSymbol {
    private SourceEventSymbol _associatedEvent;
    public bool IsImplicitlyDeclared { get; }
    protected IAttributeTargetSymbol AttributeOwner { get; }
    public Symbol AssociatedSymbol { get; }
    internal SourceEventFieldSymbol(SourceEventSymbol associatedEvent, VariableDeclaratorSyntax declaratorSyntax, DiagnosticBag discardedDiagnostics);
    public virtual bool get_IsImplicitlyDeclared();
    protected virtual IAttributeTargetSymbol get_AttributeOwner();
    public virtual Symbol get_AssociatedSymbol();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol : EventSymbol {
    private Location _location;
    private SyntaxReference _syntaxRef;
    private DeclarationModifiers _modifiers;
    internal SourceMemberContainerTypeSymbol containingType;
    protected SymbolCompletionState state;
    private CustomAttributesBag`1<CSharpAttributeData> _lazyCustomAttributesBag;
    private string _lazyDocComment;
    private OverriddenOrHiddenMembersResult _lazyOverriddenOrHiddenMembers;
    private ThreeState _lazyIsWindowsRuntimeEvent;
    internal bool RequiresCompletion { get; }
    public string Name { get; }
    public MethodSymbol AddMethod { get; }
    public MethodSymbol RemoveMethod { get; }
    public ImmutableArray`1<EventSymbol> ExplicitInterfaceImplementations { get; }
    public TypeSymbol Type { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal SyntaxList`1<AttributeListSyntax> AttributeDeclarationSyntaxList { get; }
    private IAttributeTargetSymbol Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AttributesOwner { get; }
    private AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.DefaultAttributeLocation { get; }
    private AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AllowedAttributeLocations { get; }
    protected AttributeLocation AllowedAttributeLocations { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool HasSpecialName { get; }
    public bool IsAbstract { get; }
    public bool IsExtern { get; }
    public bool IsStatic { get; }
    public bool IsOverride { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public Accessibility DeclaredAccessibility { get; }
    internal bool MustCallMethodsDirectly { get; }
    internal SyntaxReference SyntaxReference { get; }
    internal CSharpSyntaxNode CSharpSyntaxNode { get; }
    internal SyntaxTree SyntaxTree { get; }
    internal bool IsNew { get; }
    internal DeclarationModifiers Modifiers { get; }
    internal OverriddenOrHiddenMembersResult OverriddenOrHiddenMembers { get; }
    public bool IsWindowsRuntimeEvent { get; }
    internal SourceEventSymbol(SourceMemberContainerTypeSymbol containingType, CSharpSyntaxNode syntax, SyntaxTokenList modifiers, ExplicitInterfaceSpecifierSyntax interfaceSpecifierSyntaxOpt, SyntaxToken nameTokenSyntax, DiagnosticBag diagnostics);
    internal sealed virtual bool get_RequiresCompletion();
    internal sealed virtual bool HasComplete(CompletionPart part);
    internal virtual void ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken);
    public abstract virtual string get_Name();
    public abstract virtual MethodSymbol get_AddMethod();
    public abstract virtual MethodSymbol get_RemoveMethod();
    public abstract virtual ImmutableArray`1<EventSymbol> get_ExplicitInterfaceImplementations();
    public abstract virtual TypeSymbol get_Type();
    public sealed virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public sealed virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal SyntaxList`1<AttributeListSyntax> get_AttributeDeclarationSyntaxList();
    private sealed virtual override IAttributeTargetSymbol Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_AttributesOwner();
    private sealed virtual override AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_DefaultAttributeLocation();
    private sealed virtual override AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_AllowedAttributeLocations();
    protected abstract virtual AttributeLocation get_AllowedAttributeLocations();
    private CustomAttributesBag`1<CSharpAttributeData> GetAttributesBag();
    public sealed virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal CommonEventWellKnownAttributeData GetDecodedWellKnownAttributeData();
    internal CommonEventEarlyWellKnownAttributeData GetEarlyDecodedWellKnownAttributeData();
    internal virtual CSharpAttributeData EarlyDecodeWellKnownAttribute(EarlyDecodeWellKnownAttributeArguments`4& arguments);
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal sealed virtual void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal sealed virtual bool get_HasSpecialName();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual Accessibility get_DeclaredAccessibility();
    internal sealed virtual bool get_MustCallMethodsDirectly();
    internal SyntaxReference get_SyntaxReference();
    internal CSharpSyntaxNode get_CSharpSyntaxNode();
    internal SyntaxTree get_SyntaxTree();
    internal bool get_IsNew();
    internal DeclarationModifiers get_Modifiers();
    private void CheckAccessibility(Location location, DiagnosticBag diagnostics);
    private DeclarationModifiers MakeModifiers(SyntaxTokenList modifiers, bool explicitInterfaceImplementation, Location location, DiagnosticBag diagnostics, Boolean& modifierErrors);
    protected void CheckModifiersAndType(DiagnosticBag diagnostics);
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    protected static void CopyEventCustomModifiers(EventSymbol eventWithCustomModifiers, TypeSymbol& type, AssemblySymbol containingAssembly);
    internal virtual OverriddenOrHiddenMembersResult get_OverriddenOrHiddenMembers();
    public sealed virtual bool get_IsWindowsRuntimeEvent();
    private bool ComputeIsWindowsRuntimeEvent();
    internal static string GetAccessorName(string eventName, bool isAdder);
    protected TypeSymbol BindEventType(Binder binder, TypeSyntax typeSyntax, DiagnosticBag diagnostics);
    internal virtual void AfterAddingTypeMembersChecks(ConversionsBase conversions, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldLikeEventSymbol : SourceEventSymbol {
    private string _name;
    private TypeSymbol _type;
    private SourceEventFieldSymbol _associatedField;
    private SynthesizedFieldLikeEventAccessorSymbol _addMethod;
    private SynthesizedFieldLikeEventAccessorSymbol _removeMethod;
    internal FieldSymbol AssociatedField { get; }
    public string Name { get; }
    public TypeSymbol Type { get; }
    public MethodSymbol AddMethod { get; }
    public MethodSymbol RemoveMethod { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    protected AttributeLocation AllowedAttributeLocations { get; }
    public ImmutableArray`1<EventSymbol> ExplicitInterfaceImplementations { get; }
    internal SourceFieldLikeEventSymbol(SourceMemberContainerTypeSymbol containingType, Binder binder, SyntaxTokenList modifiers, VariableDeclaratorSyntax declaratorSyntax, DiagnosticBag diagnostics);
    internal virtual FieldSymbol get_AssociatedField();
    public virtual string get_Name();
    public virtual TypeSymbol get_Type();
    public virtual MethodSymbol get_AddMethod();
    public virtual MethodSymbol get_RemoveMethod();
    internal virtual bool get_IsExplicitInterfaceImplementation();
    protected virtual AttributeLocation get_AllowedAttributeLocations();
    public virtual ImmutableArray`1<EventSymbol> get_ExplicitInterfaceImplementations();
    private SourceEventFieldSymbol MakeAssociatedField(VariableDeclaratorSyntax declaratorSyntax);
    internal virtual void ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbol : FieldSymbol {
    protected SymbolCompletionState state;
    protected SourceMemberContainerTypeSymbol containingType;
    private CustomAttributesBag`1<CSharpAttributeData> _lazyCustomAttributesBag;
    internal bool RequiresCompletion { get; }
    public string Name { get; }
    protected DeclarationModifiers Modifiers { get; }
    public bool IsStatic { get; }
    public bool IsReadOnly { get; }
    public bool IsConst { get; }
    public bool IsVolatile { get; }
    public bool IsFixed { get; }
    internal bool IsNew { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    internal Location ErrorLocation { get; }
    protected SyntaxList`1<AttributeListSyntax> AttributeDeclarationSyntaxList { get; }
    protected IAttributeTargetSymbol AttributeOwner { get; }
    private IAttributeTargetSymbol Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AttributesOwner { get; }
    private AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.DefaultAttributeLocation { get; }
    private AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AllowedAttributeLocations { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool HasSpecialName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal bool IsNotSerialized { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal Nullable`1<int> TypeLayoutOffset { get; }
    protected SourceFieldSymbol(SourceMemberContainerTypeSymbol containingType);
    internal sealed virtual bool get_RequiresCompletion();
    internal sealed virtual bool HasComplete(CompletionPart part);
    public abstract virtual string get_Name();
    protected abstract virtual DeclarationModifiers get_Modifiers();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsConst();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual bool get_IsFixed();
    internal bool get_IsNew();
    public sealed virtual Accessibility get_DeclaredAccessibility();
    protected void CheckAccessibility(DiagnosticBag diagnostics);
    protected void ReportModifiersDiagnostics(DiagnosticBag diagnostics);
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public sealed virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    internal abstract virtual Location get_ErrorLocation();
    protected abstract virtual SyntaxList`1<AttributeListSyntax> get_AttributeDeclarationSyntaxList();
    protected virtual IAttributeTargetSymbol get_AttributeOwner();
    private sealed virtual override IAttributeTargetSymbol Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_AttributesOwner();
    private sealed virtual override AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_DefaultAttributeLocation();
    private sealed virtual override AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_AllowedAttributeLocations();
    private CustomAttributesBag`1<CSharpAttributeData> GetAttributesBag();
    public sealed virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal CommonFieldWellKnownAttributeData GetDecodedWellKnownAttributeData();
    internal CommonFieldEarlyWellKnownAttributeData GetEarlyDecodedWellKnownAttributeData();
    internal sealed virtual CSharpAttributeData EarlyDecodeWellKnownAttribute(EarlyDecodeWellKnownAttributeArguments`4& arguments);
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal sealed virtual void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    private void VerifyConstantValueMatches(ConstantValue attrValue, DecodeWellKnownAttributeArguments`3& arguments);
    internal virtual void PostDecodeWellKnownAttributes(ImmutableArray`1<CSharpAttributeData> boundAttributes, ImmutableArray`1<AttributeSyntax> allAttributeSyntaxNodes, DiagnosticBag diagnostics, AttributeLocation symbolPart, WellKnownAttributeData decodedData);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal sealed virtual bool get_HasSpecialName();
    internal sealed virtual bool get_HasRuntimeSpecialName();
    internal sealed virtual bool get_IsNotSerialized();
    internal sealed virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal sealed virtual Nullable`1<int> get_TypeLayoutOffset();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbolWithSyntaxReference : SourceFieldSymbol {
    private string _name;
    private Location _location;
    private SyntaxReference _syntaxReference;
    private string _lazyDocComment;
    private ConstantValue _lazyConstantEarlyDecodingValue;
    private ConstantValue _lazyConstantValue;
    public SyntaxTree SyntaxTree { get; }
    public CSharpSyntaxNode SyntaxNode { get; }
    public string Name { get; }
    public ImmutableArray`1<Location> Locations { get; }
    internal Location ErrorLocation { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    protected SourceFieldSymbolWithSyntaxReference(SourceMemberContainerTypeSymbol containingType, string name, SyntaxReference syntax, Location location);
    public SyntaxTree get_SyntaxTree();
    public CSharpSyntaxNode get_SyntaxNode();
    public sealed virtual string get_Name();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    internal sealed virtual Location get_ErrorLocation();
    public sealed virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public sealed virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal sealed virtual ConstantValue GetConstantValue(ConstantFieldsInProgress inProgress, bool earlyDecodingWellKnownAttributes);
    internal ImmutableHashSet`1<SourceFieldSymbolWithSyntaxReference> GetConstantValueDependencies(bool earlyDecodingWellKnownAttributes);
    private void BindConstantValueIfNecessary(bool earlyDecodingWellKnownAttributes, bool startsCycle);
    private ConstantValue GetLazyConstantValue(bool earlyDecodingWellKnownAttributes);
    private void SetLazyConstantValue(ConstantValue value, bool earlyDecodingWellKnownAttributes, DiagnosticBag diagnostics, bool startsCycle);
    protected abstract virtual ConstantValue MakeConstantValue(HashSet`1<SourceFieldSymbolWithSyntaxReference> dependencies, bool earlyDecodingWellKnownAttributes, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceFixedFieldSymbol : SourceMemberFieldSymbol {
    private static int FixedSizeNotInitialized;
    private int _fixedSize;
    public int FixedSize { get; }
    internal SourceFixedFieldSymbol(SourceMemberContainerTypeSymbol containingType, VariableDeclaratorSyntax declarator, DeclarationModifiers modifiers, bool modifierErrors, DiagnosticBag diagnostics);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    public sealed virtual int get_FixedSize();
    internal virtual NamedTypeSymbol FixedImplementationType(PEModuleBuilder emitModule);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceLabelSymbol : LabelSymbol {
    private MethodSymbol _containingMethod;
    private SyntaxNodeOrToken _identifierNodeOrToken;
    private ConstantValue _switchCaseLabelConstant;
    private string _lazyName;
    public string Name { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public MethodSymbol ContainingMethod { get; }
    public Symbol ContainingSymbol { get; }
    internal SyntaxNodeOrToken IdentifierNodeOrToken { get; }
    public ConstantValue SwitchCaseLabelConstant { get; }
    public SourceLabelSymbol(MethodSymbol containingMethod, SyntaxNodeOrToken identifierNodeOrToken, ConstantValue switchCaseLabelConstant);
    public SourceLabelSymbol(MethodSymbol containingMethod, ConstantValue switchCaseLabelConstant);
    public virtual string get_Name();
    private string MakeLabelName();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual MethodSymbol get_ContainingMethod();
    public virtual Symbol get_ContainingSymbol();
    internal virtual SyntaxNodeOrToken get_IdentifierNodeOrToken();
    public ConstantValue get_SwitchCaseLabelConstant();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol : LocalSymbol {
    protected Binder binder;
    private Symbol _containingSymbol;
    private SyntaxToken _identifierToken;
    private ImmutableArray`1<Location> _locations;
    private TypeSyntax _typeSyntax;
    private LocalDeclarationKind _declarationKind;
    private TypeSymbol _type;
    private int _isSpecificallyNotPinned;
    internal bool IsImportedFromMetadata { get; }
    internal LocalDeclarationKind DeclarationKind { get; }
    internal SynthesizedLocalKind SynthesizedKind { get; }
    internal bool IsPinned { get; }
    public Symbol ContainingSymbol { get; }
    public string Name { get; }
    internal SyntaxToken IdentifierToken { get; }
    public TypeSymbol Type { get; }
    public bool IsVar { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal bool IsCompilerGenerated { get; }
    internal RefKind RefKind { get; }
    private SourceLocalSymbol(Symbol containingSymbol, Binder binder, TypeSyntax typeSyntax, SyntaxToken identifierToken, LocalDeclarationKind declarationKind);
    public static SourceLocalSymbol MakeForeachLocal(MethodSymbol containingMethod, ForEachLoopBinder binder, TypeSyntax typeSyntax, SyntaxToken identifierToken, ExpressionSyntax collection);
    public static SourceLocalSymbol MakeLocal(Symbol containingSymbol, Binder binder, TypeSyntax typeSyntax, SyntaxToken identifierToken, LocalDeclarationKind declarationKind, EqualsValueClauseSyntax initializer);
    internal virtual bool get_IsImportedFromMetadata();
    internal virtual LocalDeclarationKind get_DeclarationKind();
    internal virtual SynthesizedLocalKind get_SynthesizedKind();
    internal virtual LocalSymbol WithSynthesizedLocalKindAndSyntax(SynthesizedLocalKind kind, SyntaxNode syntax);
    internal virtual bool get_IsPinned();
    internal void SetSpecificallyNotPinned();
    public virtual Symbol get_ContainingSymbol();
    public virtual string get_Name();
    internal virtual SyntaxToken get_IdentifierToken();
    public virtual TypeSymbol get_Type();
    public bool get_IsVar();
    private TypeSymbol GetTypeSymbol();
    protected virtual TypeSymbol InferTypeOfVarVariable(DiagnosticBag diagnostics);
    internal void SetTypeSymbol(TypeSymbol newType);
    public virtual ImmutableArray`1<Location> get_Locations();
    internal sealed virtual SyntaxNode GetDeclaratorSyntax();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual bool get_IsCompilerGenerated();
    internal virtual ConstantValue GetConstantValue(SyntaxNode node, LocalSymbol inProgress, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<Diagnostic> GetConstantValueDiagnostics(BoundExpression boundInitValue);
    internal virtual RefKind get_RefKind();
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol : NamedTypeSymbol {
    protected SymbolCompletionState state;
    private Flags _flags;
    private NamespaceOrTypeSymbol _containingSymbol;
    protected MergedTypeDeclaration declaration;
    private MembersAndInitializers _lazyMembersAndInitializers;
    private Dictionary`2<string, ImmutableArray`1<Symbol>> _lazyMembersDictionary;
    private Dictionary`2<string, ImmutableArray`1<Symbol>> _lazyEarlyAttributeDecodingMembersDictionary;
    private static Dictionary`2<string, ImmutableArray`1<NamedTypeSymbol>> s_emptyTypeMembers;
    private Dictionary`2<string, ImmutableArray`1<NamedTypeSymbol>> _lazyTypeMembers;
    private ImmutableArray`1<Symbol> _lazyMembersFlattened;
    private ImmutableArray`1<SynthesizedExplicitImplementationForwardingMethod> _lazySynthesizedExplicitImplementations;
    private int _lazyKnownCircularStruct;
    private LexicalSortKey _lazyLexicalSortKey;
    private ThreeState _lazyContainsExtensionMethods;
    private ThreeState _lazyAnyMemberHasAttributes;
    internal bool RequiresCompletion { get; }
    public NamedTypeSymbol ContainingType { get; }
    public Symbol ContainingSymbol { get; }
    public SpecialType SpecialType { get; }
    public TypeKind TypeKind { get; }
    internal MergedTypeDeclaration MergedDeclaration { get; }
    internal bool IsInterface { get; }
    internal bool IsManagedType { get; }
    public bool IsStatic { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    internal bool IsPartial { get; }
    internal bool IsNew { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsScriptClass { get; }
    public bool IsImplicitClass { get; }
    public bool IsImplicitlyDeclared { get; }
    public int Arity { get; }
    public string Name { get; }
    internal bool MangleName { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> SyntaxReferences { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal ImmutableArray`1<ImmutableArray`1<FieldOrPropertyInitializer>> StaticInitializers { get; }
    internal ImmutableArray`1<ImmutableArray`1<FieldOrPropertyInitializer>> InstanceInitializers { get; }
    public IEnumerable`1<string> MemberNames { get; }
    internal bool KnownCircularStruct { get; }
    internal bool ContainsExtensionMethods { get; }
    internal bool AnyMemberHasAttributes { get; }
    public bool MightContainExtensionMethods { get; }
    public NamedTypeSymbol ConstructedFrom { get; }
    internal SourceMemberContainerTypeSymbol(NamespaceOrTypeSymbol containingSymbol, MergedTypeDeclaration declaration, DiagnosticBag diagnostics);
    private static SourceMemberContainerTypeSymbol();
    private SpecialType MakeSpecialType();
    private DeclarationModifiers MakeModifiers(TypeKind typeKind, DiagnosticBag diagnostics);
    private DeclarationModifiers MakeAndCheckTypeModifiers(DeclarationModifiers defaultAccess, DeclarationModifiers allowedModifiers, SourceMemberContainerTypeSymbol self, DiagnosticBag diagnostics, Boolean& modifierErrors);
    internal sealed virtual bool get_RequiresCompletion();
    internal sealed virtual bool HasComplete(CompletionPart part);
    protected abstract virtual void CheckBase(DiagnosticBag diagnostics);
    protected abstract virtual void CheckInterfaces(DiagnosticBag diagnostics);
    internal virtual void ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken);
    internal void EnsureFieldDefinitionsNoted();
    private void NoteFieldDefinitions();
    public sealed virtual NamedTypeSymbol get_ContainingType();
    public sealed virtual Symbol get_ContainingSymbol();
    public virtual SpecialType get_SpecialType();
    public virtual TypeKind get_TypeKind();
    internal MergedTypeDeclaration get_MergedDeclaration();
    internal sealed virtual bool get_IsInterface();
    internal virtual bool get_IsManagedType();
    public virtual bool get_IsStatic();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAbstract();
    internal bool get_IsPartial();
    internal bool get_IsNew();
    public virtual Accessibility get_DeclaredAccessibility();
    private Accessibility EffectiveAccessibility();
    public virtual bool get_IsScriptClass();
    public virtual bool get_IsImplicitClass();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual int get_Arity();
    public virtual string get_Name();
    internal virtual bool get_MangleName();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public virtual ImmutableArray`1<Location> get_Locations();
    public ImmutableArray`1<SyntaxReference> get_SyntaxReferences();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal ImmutableArray`1<ImmutableArray`1<FieldOrPropertyInitializer>> get_StaticInitializers();
    internal ImmutableArray`1<ImmutableArray`1<FieldOrPropertyInitializer>> get_InstanceInitializers();
    internal int CalculateSyntaxOffsetInSynthesizedConstructor(int position, SyntaxTree tree, bool isStatic);
    internal bool TryCalculateSyntaxOffsetOfPositionInInitializer(int position, SyntaxTree tree, bool isStatic, int ctorInitializerLength, Int32& syntaxOffset);
    private static ImmutableArray`1<FieldOrPropertyInitializer> GetInitializersInSourceTree(SyntaxTree tree, ImmutableArray`1<ImmutableArray`1<FieldOrPropertyInitializer>> initializers);
    private static int IndexOfInitializerContainingPosition(ImmutableArray`1<FieldOrPropertyInitializer> initializers, int position);
    public virtual IEnumerable`1<string> get_MemberNames();
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembersUnordered();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    private Dictionary`2<string, ImmutableArray`1<NamedTypeSymbol>> GetTypeMembersDictionary();
    private Dictionary`2<string, ImmutableArray`1<NamedTypeSymbol>> MakeTypeMembers(DiagnosticBag diagnostics);
    private void CheckMemberNameDistinctFromType(Symbol member, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<Symbol> GetMembersUnordered();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    public sealed virtual ImmutableArray`1<Symbol> GetMembers(string name);
    internal virtual ImmutableArray`1<Symbol> GetSimpleNonTypeMembers(string name);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol/<GetFieldsToEmit>d__96")]
internal virtual IEnumerable`1<FieldSymbol> GetFieldsToEmit();
    internal virtual ImmutableArray`1<Symbol> GetEarlyAttributeDecodingMembers();
    internal virtual ImmutableArray`1<Symbol> GetEarlyAttributeDecodingMembers(string name);
    private Dictionary`2<string, ImmutableArray`1<Symbol>> GetEarlyAttributeDecodingMembersDictionary();
    private MembersAndInitializers GetMembersAndInitializers();
    protected Dictionary`2<string, ImmutableArray`1<Symbol>> GetMembersByName();
    private Dictionary`2<string, ImmutableArray`1<Symbol>> GetMembersByNameSlow();
    internal virtual IEnumerable`1<Symbol> GetInstanceFieldsAndEvents();
    protected void AfterMembersChecks(DiagnosticBag diagnostics);
    private void CheckMemberNamesDistinctFromType(DiagnosticBag diagnostics);
    private void CheckMemberNameConflicts(DiagnosticBag diagnostics);
    private void ReportMethodSignatureCollision(DiagnosticBag diagnostics, SourceMethodSymbol method1, SourceMethodSymbol method2);
    private void CheckIndexerNameConflicts(DiagnosticBag diagnostics, Dictionary`2<string, ImmutableArray`1<Symbol>> membersByName);
    private void CheckIndexerSignatureCollisions(PropertySymbol indexer, DiagnosticBag diagnostics, Dictionary`2<string, ImmutableArray`1<Symbol>> membersByName, Dictionary`2<PropertySymbol, PropertySymbol> indexersBySignature, String& lastIndexerName);
    private void CheckSpecialMemberErrors(DiagnosticBag diagnostics);
    private void CheckTypeParameterNameConflicts(DiagnosticBag diagnostics);
    private void CheckAccessorNameConflicts(DiagnosticBag diagnostics);
    internal virtual bool get_KnownCircularStruct();
    private bool CheckStructCircularity(DiagnosticBag diagnostics);
    private bool HasStructCircularity(DiagnosticBag diagnostics);
    private void CheckForProtectedInStaticClass(DiagnosticBag diagnostics);
    private void CheckForUnmatchedOperators(DiagnosticBag diagnostics);
    private void CheckForUnmatchedOperator(DiagnosticBag diagnostics, string operatorName1, string operatorName2);
    private static void CheckForUnmatchedOperator(DiagnosticBag diagnostics, ImmutableArray`1<MethodSymbol> ops1, ImmutableArray`1<MethodSymbol> ops2, string operatorName2);
    private static bool DoOperatorsPair(MethodSymbol op1, MethodSymbol op2);
    private void CheckForEqualityAndGetHashCode(DiagnosticBag diagnostics);
    private bool TypeOverridesObjectMethod(string name);
    private void CheckFiniteFlatteningGraph(DiagnosticBag diagnostics);
    private static bool InfiniteFlatteningGraph(SourceMemberContainerTypeSymbol top, NamedTypeSymbol t, Dictionary`2<NamedTypeSymbol, NamedTypeSymbol> instanceMap);
    private void CheckSequentialOnPartialType(DiagnosticBag diagnostics);
    private static bool HasInstanceData(MemberDeclarationSyntax m);
    private static bool All(SyntaxList`1<T> list, Func`2<T, bool> predicate);
    private static bool ContainsModifier(SyntaxTokenList modifiers, SyntaxKind modifier);
    private Dictionary`2<string, ImmutableArray`1<Symbol>> MakeAllMembers(DiagnosticBag diagnostics);
    private Dictionary`2<string, ImmutableArray`1<Symbol>> MergeIndexersAndNonIndexers(ImmutableArray`1<Symbol> nonIndexerMembers, ArrayBuilder`1<Symbol> indexerMembers);
    private static void AddNestedTypesToDictionary(Dictionary`2<string, ImmutableArray`1<Symbol>> membersByName, Dictionary`2<string, ImmutableArray`1<NamedTypeSymbol>> typesByName);
    private MembersAndInitializers BuildMembersAndInitializers(DiagnosticBag diagnostics);
    private void AddDeclaredNontypeMembers(MembersAndInitializersBuilder builder, DiagnosticBag diagnostics);
    internal Binder GetBinder(CSharpSyntaxNode syntaxNode);
    private static void MergePartialMethods(Dictionary`2<string, ImmutableArray`1<Symbol>> membersByName, DiagnosticBag diagnostics);
    private static ImmutableArray`1<Symbol> FixPartialMember(ImmutableArray`1<Symbol> symbols, SourceMemberMethodSymbol part1, SourceMemberMethodSymbol part2);
    private static bool DifferByOutOrRef(SourceMethodSymbol m1, SourceMethodSymbol m2);
    private void CheckForMemberConflictWithPropertyAccessor(PropertySymbol propertySymbol, bool getNotSet, DiagnosticBag diagnostics);
    private void CheckForMemberConflictWithEventAccessor(EventSymbol eventSymbol, bool isAdder, DiagnosticBag diagnostics);
    private static Location GetAccessorOrPropertyLocation(PropertySymbol propertySymbol, bool getNotSet);
    private static Location GetAccessorOrEventLocation(EventSymbol propertySymbol, bool isAdder);
    private static bool ParametersMatchPropertyAccessor(PropertySymbol propertySymbol, bool getNotSet, ImmutableArray`1<ParameterSymbol> methodParams);
    private static bool ParametersMatchEventAccessor(EventSymbol eventSymbol, ImmutableArray`1<ParameterSymbol> methodParams);
    private void AddEnumMembers(MembersAndInitializersBuilder result, EnumDeclarationSyntax syntax, DiagnosticBag diagnostics);
    private static void AddInitializer(ArrayBuilder`1& initializers, Int32& aggregateSyntaxLength, FieldSymbol fieldOpt, CSharpSyntaxNode node);
    private static void AddInitializers(ArrayBuilder`1<ImmutableArray`1<FieldOrPropertyInitializer>> allInitializers, ArrayBuilder`1<FieldOrPropertyInitializer> siblingsOpt);
    private static void CheckInterfaceMembers(ImmutableArray`1<Symbol> nonTypeMembers, DiagnosticBag diagnostics);
    private static void CheckInterfaceMember(Symbol member, DiagnosticBag diagnostics);
    private static void CheckForStructDefaultConstructors(ArrayBuilder`1<Symbol> members, bool isEnum, DiagnosticBag diagnostics);
    private void CheckForStructBadInitializers(MembersAndInitializersBuilder builder, DiagnosticBag diagnostics);
    private void AddSynthesizedConstructorsIfNecessary(ArrayBuilder`1<Symbol> members, ArrayBuilder`1<ImmutableArray`1<FieldOrPropertyInitializer>> staticInitializers, DiagnosticBag diagnostics);
    private static bool HasNonConstantInitializer(ArrayBuilder`1<ImmutableArray`1<FieldOrPropertyInitializer>> initializers);
    private void AddNonTypeMembers(MembersAndInitializersBuilder builder, SyntaxList`1<MemberDeclarationSyntax> members, DiagnosticBag diagnostics);
    private static bool IsGlobalCodeAllowed(CSharpSyntaxNode parent);
    private void AddAccessorIfAvailable(ArrayBuilder`1<Symbol> symbols, MethodSymbol accessorOpt, DiagnosticBag diagnostics, bool checkName);
    internal bool get_ContainsExtensionMethods();
    internal bool get_AnyMemberHasAttributes();
    public virtual bool get_MightContainExtensionMethods();
    public sealed virtual NamedTypeSymbol get_ConstructedFrom();
    internal ImmutableArray`1<SynthesizedExplicitImplementationForwardingMethod> GetSynthesizedExplicitImplementations(CancellationToken cancellationToken);
    private void CheckAbstractClassImplementations(DiagnosticBag diagnostics);
    private ImmutableArray`1<SynthesizedExplicitImplementationForwardingMethod> ComputeInterfaceImplementations(DiagnosticBag diagnostics, CancellationToken cancellationToken);
    protected abstract virtual Location GetCorrespondingBaseListLocation(NamedTypeSymbol base);
    internal Location GetImplementsLocation(NamedTypeSymbol implementedInterface);
    private bool ReportAccessorOfInterfacePropertyOrEvent(Symbol interfacePropertyOrEvent);
    private bool HasImportedBaseTypeDeclaringInterface(NamedTypeSymbol interface);
    private void CheckMembersAgainstBaseType(DiagnosticBag diagnostics, CancellationToken cancellationToken);
    private void CheckNewModifier(Symbol symbol, bool isNew, DiagnosticBag diagnostics);
    private static void CheckOverrideMember(Symbol overridingMember, OverriddenOrHiddenMembersResult overriddenOrHiddenMembers, DiagnosticBag diagnostics, Boolean& suppressAccessors);
    private static void CheckNonOverrideMember(Symbol hidingMember, bool hidingMemberIsNew, OverriddenOrHiddenMembersResult overriddenOrHiddenMembers, DiagnosticBag diagnostics, Boolean& suppressAccessors);
    private static bool AddHidingAbstractDiagnostic(Symbol hidingMember, Location hidingMemberLocation, Symbol hiddenMember, DiagnosticBag diagnostics, Boolean& suppressAccessors);
    private static bool OverrideHasCorrectAccessibility(Symbol overridden, Symbol overriding);
    private void CheckInterfaceUnification(DiagnosticBag diagnostics);
    private SynthesizedExplicitImplementationForwardingMethod SynthesizeInterfaceMemberImplementation(SymbolAndDiagnostics implementingMemberAndDiagnostics, Symbol interfaceMember);
    private static bool IsPossibleImplementationUnderRuntimeRules(MethodSymbol implementingMethod, NamedTypeSymbol interface);
    private static bool IsOverrideOfPossibleImplementationUnderRuntimeRules(MethodSymbol implementingMethod, NamedTypeSymbol interface);
    internal sealed virtual ImmutableArray`1<NamedTypeSymbol> GetInterfacesToEmit();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberFieldSymbol : SourceFieldSymbolWithSyntaxReference {
    private DeclarationModifiers _modifiers;
    private bool _hasInitializer;
    private TypeSymbol _lazyType;
    private int _lazyFieldTypeInferred;
    private ImmutableArray`1<CustomModifier> _lazyCustomModifiers;
    protected DeclarationModifiers Modifiers { get; }
    public bool HasInitializer { get; }
    public VariableDeclaratorSyntax VariableDeclaratorNode { get; }
    protected SyntaxList`1<AttributeListSyntax> AttributeDeclarationSyntaxList { get; }
    internal bool HasPointerType { get; }
    public Symbol AssociatedSymbol { get; }
    public int FixedSize { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    internal SourceMemberFieldSymbol(SourceMemberContainerTypeSymbol containingType, VariableDeclaratorSyntax declarator, DeclarationModifiers modifiers, bool modifierErrors, DiagnosticBag diagnostics);
    protected sealed virtual DeclarationModifiers get_Modifiers();
    private void TypeChecks(TypeSymbol type, BaseFieldDeclarationSyntax fieldSyntax, VariableDeclaratorSyntax declarator, DiagnosticBag diagnostics);
    public bool get_HasInitializer();
    public VariableDeclaratorSyntax get_VariableDeclaratorNode();
    private static BaseFieldDeclarationSyntax GetFieldDeclaration(CSharpSyntaxNode declarator);
    protected virtual SyntaxList`1<AttributeListSyntax> get_AttributeDeclarationSyntaxList();
    internal virtual bool get_HasPointerType();
    private bool IsPointerFieldSyntactically();
    internal sealed virtual TypeSymbol GetFieldType(ConsList`1<FieldSymbol> fieldsBeingBound);
    internal bool FieldTypeInferred(ConsList`1<FieldSymbol> fieldsBeingBound);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    public virtual Symbol get_AssociatedSymbol();
    protected sealed virtual ConstantValue MakeConstantValue(HashSet`1<SourceFieldSymbolWithSyntaxReference> dependencies, bool earlyDecodingWellKnownAttributes, DiagnosticBag diagnostics);
    public virtual int get_FixedSize();
    internal static DeclarationModifiers MakeModifiers(NamedTypeSymbol containingType, SyntaxToken firstIdentifier, SyntaxTokenList modifiers, DiagnosticBag diagnostics, Boolean& modifierErrors);
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    internal sealed virtual void ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken);
    internal virtual NamedTypeSymbol FixedImplementationType(PEModuleBuilder emitModule);
    internal virtual bool IsDefinedInSourceTree(SyntaxTree tree, Nullable`1<TextSpan> definedWithinSpan, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol : SourceMethodSymbol {
    private ImmutableArray`1<TypeParameterSymbol> _typeParameters;
    private TypeSymbol _explicitInterfaceType;
    private string _name;
    private bool _isExpressionBodied;
    private ImmutableArray`1<MethodSymbol> _lazyExplicitInterfaceImplementations;
    private ImmutableArray`1<CustomModifier> _lazyReturnTypeCustomModifiers;
    private ImmutableArray`1<ParameterSymbol> _lazyParameters;
    private TypeSymbol _lazyReturnType;
    private bool _lazyIsVararg;
    private ImmutableArray`1<TypeParameterConstraintClause> _lazyTypeParameterConstraints;
    private SourceMemberMethodSymbol _otherPartOfPartial;
    public bool ReturnsVoid { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public bool IsVararg { get; }
    public ImmutableArray`1<Location> Locations { get; }
    internal int ParameterCount { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public TypeSymbol ReturnType { get; }
    internal SourceMemberMethodSymbol OtherPartOfPartial { get; }
    internal bool IsPartialDefinition { get; }
    internal bool IsPartialImplementation { get; }
    internal bool IsPartialWithoutImplementation { get; }
    internal SourceMemberMethodSymbol SourcePartialDefinition { get; }
    internal SourceMemberMethodSymbol SourcePartialImplementation { get; }
    public MethodSymbol PartialDefinitionPart { get; }
    public MethodSymbol PartialImplementationPart { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public string Name { get; }
    protected SourceMethodSymbol BoundAttributesSource { get; }
    private SyntaxList`1<AttributeListSyntax> AttributeDeclarationSyntaxList { get; }
    internal bool IsExpressionBodied { get; }
    internal bool GenerateDebugInfo { get; }
    private SourceMemberMethodSymbol(NamedTypeSymbol containingType, TypeSymbol explicitInterfaceType, string name, Location location, MethodDeclarationSyntax syntax, MethodKind methodKind, DiagnosticBag diagnostics);
    public static SourceMemberMethodSymbol CreateMethodSymbol(NamedTypeSymbol containingType, Binder bodyBinder, MethodDeclarationSyntax syntax, DiagnosticBag diagnostics);
    public virtual bool get_ReturnsVoid();
    private void MethodChecks(MethodDeclarationSyntax syntax, Binder withTypeParamsBinder, DiagnosticBag diagnostics);
    internal static void ReportAsyncParameterErrors(MethodSymbol method, DiagnosticBag diagnostics, Location location);
    protected sealed virtual void LazyAsyncMethodChecks(CancellationToken cancellationToken);
    protected virtual void MethodChecks(DiagnosticBag diagnostics);
    internal MethodDeclarationSyntax GetSyntax();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal TypeParameterConstraintKind GetTypeParameterConstraints(int ordinal);
    internal ImmutableArray`1<TypeSymbol> GetTypeParameterConstraintTypes(int ordinal);
    private TypeParameterConstraintClause GetTypeParameterConstraintClause(int ordinal);
    private ImmutableArray`1<TypeParameterConstraintClause> MakeTypeParameterConstraints(DiagnosticBag diagnostics);
    public virtual bool get_IsVararg();
    public virtual ImmutableArray`1<Location> get_Locations();
    internal virtual int get_ParameterCount();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual TypeSymbol get_ReturnType();
    internal static void InitializePartialMethodParts(SourceMemberMethodSymbol definition, SourceMemberMethodSymbol implementation);
    internal SourceMemberMethodSymbol get_OtherPartOfPartial();
    internal bool get_IsPartialDefinition();
    internal bool get_IsPartialImplementation();
    internal bool get_IsPartialWithoutImplementation();
    internal SourceMemberMethodSymbol get_SourcePartialDefinition();
    internal SourceMemberMethodSymbol get_SourcePartialImplementation();
    public virtual MethodSymbol get_PartialDefinitionPart();
    public virtual MethodSymbol get_PartialImplementationPart();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual string get_Name();
    protected virtual SourceMethodSymbol get_BoundAttributesSource();
    internal virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    private SyntaxList`1<AttributeListSyntax> get_AttributeDeclarationSyntaxList();
    internal virtual bool get_IsExpressionBodied();
    private DeclarationModifiers MakeModifiers(SyntaxTokenList modifiers, MethodKind methodKind, Location location, DiagnosticBag diagnostics, Boolean& modifierErrors);
    private static DeclarationModifiers AddImpliedModifiers(DeclarationModifiers mods, bool containingTypeIsInterface, MethodKind methodKind);
    private ImmutableArray`1<TypeParameterSymbol> MakeTypeParameters(MethodDeclarationSyntax syntax, DiagnosticBag diagnostics);
    private void CheckModifiers(Location location, DiagnosticBag diagnostics);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal virtual void ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken);
    internal virtual void AfterAddingTypeMembersChecks(ConversionsBase conversions, DiagnosticBag diagnostics);
    private static void PartialMethodChecks(SourceMemberMethodSymbol definition, SourceMemberMethodSymbol implementation, DiagnosticBag diagnostics);
    private static bool HaveSameConstraints(SourceMemberMethodSymbol part1, SourceMemberMethodSymbol part2);
    internal virtual bool CallsAreOmitted(SyntaxTree syntaxTree);
    internal virtual bool get_GenerateDebugInfo();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol : MethodSymbol {
    protected SymbolCompletionState state;
    protected Flags flags;
    private NamedTypeSymbol _containingType;
    private ParameterSymbol _lazyThisParameter;
    private TypeSymbol _iteratorElementType;
    private CustomAttributesBag`1<CSharpAttributeData> _lazyCustomAttributesBag;
    private CustomAttributesBag`1<CSharpAttributeData> _lazyReturnTypeCustomAttributesBag;
    private OverriddenOrHiddenMembersResult _lazyOverriddenOrHiddenMembers;
    protected SyntaxReference syntaxReferenceOpt;
    protected SyntaxReference bodySyntaxReferenceOpt;
    protected ImmutableArray`1<Location> locations;
    protected string lazyDocComment;
    private ImmutableArray`1<Diagnostic> _cachedDiagnostics;
    internal ImmutableArray`1<Diagnostic> Diagnostics { get; }
    protected object MethodChecksLockObject { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public Symbol AssociatedSymbol { get; }
    public bool ReturnsVoid { get; }
    public MethodKind MethodKind { get; }
    public bool IsExtensionMethod { get; }
    private bool IsMetadataVirtualLocked { get; }
    protected DeclarationModifiers DeclarationModifiers { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsExtern { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public bool IsOverride { get; }
    internal bool IsPartial { get; }
    public bool IsVirtual { get; }
    internal bool IsNew { get; }
    public bool IsStatic { get; }
    internal bool IsUnsafe { get; }
    public bool IsAsync { get; }
    internal CallingConvention CallingConvention { get; }
    internal SyntaxNode BodySyntax { get; }
    internal SyntaxReference SyntaxRef { get; }
    internal CSharpSyntaxNode SyntaxNode { get; }
    internal SyntaxTree SyntaxTree { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public int Arity { get; }
    internal TypeSymbol IteratorElementType { get; internal set; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    internal OverriddenOrHiddenMembersResult OverriddenOrHiddenMembers { get; }
    internal bool RequiresCompletion { get; }
    protected SourceMethodSymbol BoundAttributesSource { get; }
    protected IAttributeTargetSymbol AttributeOwner { get; }
    private IAttributeTargetSymbol Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AttributesOwner { get; }
    private AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.DefaultAttributeLocation { get; }
    private AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AllowedAttributeLocations { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public bool HidesBaseMethodsByName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal bool HasSpecialName { get; }
    internal bool RequiresSecurityObject { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal MarshalPseudoCustomAttributeData ReturnValueMarshallingInformation { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool IsExpressionBodied { get; }
    protected SourceMethodSymbol(NamedTypeSymbol containingType, SyntaxReference syntaxReferenceOpt, SyntaxReference bodySyntaxReferenceOpt, Location location);
    protected SourceMethodSymbol(NamedTypeSymbol containingType, SyntaxReference syntaxReferenceOpt, SyntaxReference bodySyntaxReferenceOpt, ImmutableArray`1<Location> locations);
    internal ImmutableArray`1<Diagnostic> get_Diagnostics();
    internal ImmutableArray`1<Diagnostic> SetDiagnostics(ImmutableArray`1<Diagnostic> newSet, Boolean& diagsWritten);
    protected void CheckEffectiveAccessibility(TypeSymbol returnType, ImmutableArray`1<ParameterSymbol> parameters, DiagnosticBag diagnostics);
    protected void MakeFlags(MethodKind methodKind, DeclarationModifiers declarationModifiers, bool returnsVoid, bool isExtensionMethod, bool isMetadataVirtualIgnoringModifiers);
    protected void SetReturnsVoid(bool returnsVoid);
    protected abstract virtual void MethodChecks(DiagnosticBag diagnostics);
    protected virtual object get_MethodChecksLockObject();
    protected void LazyMethodChecks();
    protected virtual void LazyAsyncMethodChecks(CancellationToken cancellationToken);
    public sealed virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual Symbol get_AssociatedSymbol();
    public virtual bool get_ReturnsVoid();
    public sealed virtual MethodKind get_MethodKind();
    public virtual bool get_IsExtensionMethod();
    private bool get_IsMetadataVirtualLocked();
    internal virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal virtual bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges);
    internal void EnsureMetadataVirtual();
    protected DeclarationModifiers get_DeclarationModifiers();
    public virtual Accessibility get_DeclaredAccessibility();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsOverride();
    internal bool get_IsPartial();
    public sealed virtual bool get_IsVirtual();
    internal bool get_IsNew();
    public sealed virtual bool get_IsStatic();
    internal bool get_IsUnsafe();
    public sealed virtual bool get_IsAsync();
    internal sealed virtual CallingConvention get_CallingConvention();
    internal SyntaxNode get_BodySyntax();
    internal SyntaxReference get_SyntaxRef();
    internal CSharpSyntaxNode get_SyntaxNode();
    internal SyntaxTree get_SyntaxTree();
    public virtual ImmutableArray`1<Location> get_Locations();
    public sealed virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public sealed virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public sealed virtual int get_Arity();
    internal sealed virtual bool TryGetThisParameter(ParameterSymbol& thisParameter);
    internal virtual TypeSymbol get_IteratorElementType();
    internal virtual void set_IteratorElementType(TypeSymbol value);
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    internal sealed virtual OverriddenOrHiddenMembersResult get_OverriddenOrHiddenMembers();
    internal sealed virtual bool get_RequiresCompletion();
    internal sealed virtual bool HasComplete(CompletionPart part);
    internal virtual void ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken);
    protected virtual SourceMethodSymbol get_BoundAttributesSource();
    protected virtual IAttributeTargetSymbol get_AttributeOwner();
    private sealed virtual override IAttributeTargetSymbol Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_AttributesOwner();
    private sealed virtual override AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_DefaultAttributeLocation();
    private sealed virtual override AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_AllowedAttributeLocations();
    internal virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    internal virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetReturnTypeAttributeDeclarations();
    internal CommonMethodEarlyWellKnownAttributeData GetEarlyDecodedWellKnownAttributeData();
    internal CommonMethodWellKnownAttributeData GetDecodedWellKnownAttributeData();
    internal CommonReturnTypeWellKnownAttributeData GetDecodedReturnTypeWellKnownAttributeData();
    private CustomAttributesBag`1<CSharpAttributeData> GetAttributesBag();
    private CustomAttributesBag`1<CSharpAttributeData> GetReturnTypeAttributesBag();
    private CustomAttributesBag`1<CSharpAttributeData> GetAttributesBag(CustomAttributesBag`1& lazyCustomAttributesBag, bool forReturnType);
    public sealed virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    public sealed virtual ImmutableArray`1<CSharpAttributeData> GetReturnTypeAttributes();
    internal virtual void AddSynthesizedReturnTypeAttributes(ArrayBuilder`1& attributes);
    internal virtual CSharpAttributeData EarlyDecodeWellKnownAttribute(EarlyDecodeWellKnownAttributeArguments`4& arguments);
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal sealed virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    private void DecodeWellKnownAttributeAppliedToMethod(DecodeWellKnownAttributeArguments`3& arguments);
    private bool VerifyObsoleteAttributeAppliedToMethod(DecodeWellKnownAttributeArguments`3& arguments, AttributeDescription description);
    private void ValidateConditionalAttribute(CSharpAttributeData attribute, AttributeSyntax node, DiagnosticBag diagnostics);
    private bool HasAnyOutParameter();
    private void DecodeWellKnownAttributeAppliedToReturnValue(DecodeWellKnownAttributeArguments`3& arguments);
    private void DecodeDllImportAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    internal virtual void PostDecodeWellKnownAttributes(ImmutableArray`1<CSharpAttributeData> boundAttributes, ImmutableArray`1<AttributeSyntax> allAttributeSyntaxNodes, DiagnosticBag diagnostics, AttributeLocation symbolPart, WellKnownAttributeData decodedData);
    public sealed virtual bool get_HidesBaseMethodsByName();
    internal virtual bool get_HasRuntimeSpecialName();
    private bool IsVtableGapInterfaceMethod();
    internal sealed virtual bool get_HasSpecialName();
    internal sealed virtual bool get_RequiresSecurityObject();
    internal sealed virtual bool get_HasDeclarativeSecurity();
    internal sealed virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    public sealed virtual DllImportData GetDllImportData();
    internal sealed virtual MarshalPseudoCustomAttributeData get_ReturnValueMarshallingInformation();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    protected void CheckModifiersForBody(Location location, DiagnosticBag diagnostics);
    internal abstract virtual bool get_IsExpressionBodied();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodTypeParameterSymbol : SourceTypeParameterSymbolBase {
    private SourceMemberMethodSymbol _owner;
    public TypeParameterKind TypeParameterKind { get; }
    public Symbol ContainingSymbol { get; }
    public bool HasConstructorConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    protected ImmutableArray`1<TypeParameterSymbol> ContainerTypeParameters { get; }
    public SourceMethodTypeParameterSymbol(SourceMemberMethodSymbol owner, string name, int ordinal, ImmutableArray`1<Location> locations, ImmutableArray`1<SyntaxReference> syntaxRefs);
    public virtual TypeParameterKind get_TypeParameterKind();
    public virtual Symbol get_ContainingSymbol();
    public virtual bool get_HasConstructorConstraint();
    public virtual bool get_HasValueTypeConstraint();
    public virtual bool get_HasReferenceTypeConstraint();
    protected virtual ImmutableArray`1<TypeParameterSymbol> get_ContainerTypeParameters();
    protected virtual TypeParameterBounds ResolveBounds(ConsList`1<TypeParameterSymbol> inProgress, DiagnosticBag diagnostics);
    private TypeParameterConstraintKind GetDeclaredConstraints();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol : NonMissingModuleSymbol {
    private SourceAssemblySymbol _assemblySymbol;
    private ImmutableArray`1<AssemblySymbol> _lazyAssembliesToEmbedTypesFrom;
    private ThreeState _lazyContainsExplicitDefinitionOfNoPiaLocalTypes;
    private DeclarationTable _sources;
    private SymbolCompletionState _state;
    private CustomAttributesBag`1<CSharpAttributeData> _lazyCustomAttributesBag;
    private ImmutableArray`1<Location> _locations;
    private NamespaceSymbol _globalNamespace;
    private bool _hasBadAttributes;
    private string _name;
    internal bool HasBadAttributes { get; }
    internal int Ordinal { get; }
    internal Machine Machine { get; }
    internal bool Bit32Required { get; }
    internal bool AnyReferencedAssembliesAreLinked { get; }
    internal bool ContainsExplicitDefinitionOfNoPiaLocalTypes { get; }
    public NamespaceSymbol GlobalNamespace { get; }
    internal bool RequiresCompletion { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public string Name { get; }
    public Symbol ContainingSymbol { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal SourceAssemblySymbol ContainingSourceAssembly { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    internal ICollection`1<string> TypeNames { get; }
    internal ICollection`1<string> NamespaceNames { get; }
    private IAttributeTargetSymbol Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AttributesOwner { get; }
    private AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.DefaultAttributeLocation { get; }
    private AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AllowedAttributeLocations { get; }
    internal bool HasAssemblyCompilationRelaxationsAttribute { get; }
    internal bool HasAssemblyRuntimeCompatibilityAttribute { get; }
    internal Nullable`1<CharSet> DefaultMarshallingCharSet { get; }
    internal SourceModuleSymbol(SourceAssemblySymbol assemblySymbol, DeclarationTable declarations, string moduleName);
    internal void RecordPresenceOfBadAttributes();
    internal bool get_HasBadAttributes();
    internal virtual int get_Ordinal();
    internal virtual Machine get_Machine();
    internal virtual bool get_Bit32Required();
    internal bool get_AnyReferencedAssembliesAreLinked();
    internal bool MightContainNoPiaLocalTypes();
    internal ImmutableArray`1<AssemblySymbol> GetAssembliesToEmbedTypesFrom();
    internal bool get_ContainsExplicitDefinitionOfNoPiaLocalTypes();
    private static bool NamespaceContainsExplicitDefinitionOfNoPiaLocalTypes(NamespaceSymbol ns);
    public virtual NamespaceSymbol get_GlobalNamespace();
    internal sealed virtual bool get_RequiresCompletion();
    internal sealed virtual bool HasComplete(CompletionPart part);
    internal virtual void ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken);
    private void ValidateLinkedAssemblies(DiagnosticBag diagnostics, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual string get_Name();
    public virtual Symbol get_ContainingSymbol();
    public virtual AssemblySymbol get_ContainingAssembly();
    internal SourceAssemblySymbol get_ContainingSourceAssembly();
    internal virtual CSharpCompilation get_DeclaringCompilation();
    internal virtual ICollection`1<string> get_TypeNames();
    internal virtual ICollection`1<string> get_NamespaceNames();
    private sealed virtual override IAttributeTargetSymbol Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_AttributesOwner();
    private sealed virtual override AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_DefaultAttributeLocation();
    private sealed virtual override AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_AllowedAttributeLocations();
    private CustomAttributesBag`1<CSharpAttributeData> GetAttributesBag();
    public sealed virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal CommonModuleWellKnownAttributeData GetDecodedWellKnownAttributeData();
    internal virtual void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal virtual bool get_HasAssemblyCompilationRelaxationsAttribute();
    internal virtual bool get_HasAssemblyRuntimeCompatibilityAttribute();
    internal virtual Nullable`1<CharSet> get_DefaultMarshallingCharSet();
    public virtual ModuleMetadata GetMetadata();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol : SourceMemberContainerTypeSymbol {
    private ImmutableArray`1<TypeParameterSymbol> _lazyTypeParameters;
    private ImmutableArray`1<TypeParameterConstraintClause> _lazyTypeParameterConstraints;
    private CustomAttributesBag`1<CSharpAttributeData> _lazyCustomAttributesBag;
    private string _lazyDocComment;
    private ThreeState _lazyIsExplicitDefinitionOfNoPiaLocalType;
    private Tuple`2<NamedTypeSymbol, ImmutableArray`1<NamedTypeSymbol>> _lazyDeclaredBases;
    private NamedTypeSymbol _lazyBaseType;
    private ImmutableArray`1<NamedTypeSymbol> _lazyInterfaces;
    private SynthesizedEnumValueFieldSymbol _lazyEnumValueField;
    private NamedTypeSymbol _lazyEnumUnderlyingType;
    internal ImmutableArray`1<TypeSymbol> TypeArgumentsNoUseSiteDiagnostics { get; }
    internal bool HasTypeArgumentsCustomModifiers { get; }
    internal ImmutableArray`1<ImmutableArray`1<CustomModifier>> TypeArgumentsCustomModifiers { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    private IAttributeTargetSymbol Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AttributesOwner { get; }
    private AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.DefaultAttributeLocation { get; }
    private AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AllowedAttributeLocations { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool IsExplicitDefinitionOfNoPiaLocalType { get; }
    internal bool IsComImport { get; }
    internal NamedTypeSymbol ComImportCoClass { get; }
    internal bool HasSpecialName { get; }
    internal bool ShouldAddWinRTMembers { get; }
    internal bool IsWindowsRuntimeImport { get; }
    internal bool IsSerializable { get; }
    internal TypeLayout Layout { get; }
    internal bool HasStructLayoutAttribute { get; }
    internal CharSet MarshallingCharSet { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal bool HasSecurityCriticalAttributes { get; }
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    public NamedTypeSymbol EnumUnderlyingType { get; }
    internal FieldSymbol EnumValueField { get; }
    internal SourceNamedTypeSymbol(NamespaceOrTypeSymbol containingSymbol, MergedTypeDeclaration declaration, DiagnosticBag diagnostics);
    protected virtual Location GetCorrespondingBaseListLocation(NamedTypeSymbol base);
    private static SyntaxToken GetName(CSharpSyntaxNode node);
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    private ImmutableArray`1<TypeParameterSymbol> MakeTypeParameters(DiagnosticBag diagnostics);
    internal TypeParameterConstraintKind GetTypeParameterConstraints(int ordinal);
    internal ImmutableArray`1<TypeSymbol> GetTypeParameterConstraintTypes(int ordinal);
    private TypeParameterConstraintClause GetTypeParameterConstraintClause(int ordinal);
    private ImmutableArray`1<TypeParameterConstraintClause> MakeTypeParameterConstraints(DiagnosticBag diagnostics);
    private static SyntaxList`1<TypeParameterConstraintClauseSyntax> GetConstraintClauses(CSharpSyntaxNode node);
    private static bool HaveSameConstraints(TypeParameterConstraintClause clause1, TypeParameterConstraintClause clause2);
    internal virtual ImmutableArray`1<TypeSymbol> get_TypeArgumentsNoUseSiteDiagnostics();
    internal virtual bool get_HasTypeArgumentsCustomModifiers();
    internal virtual ImmutableArray`1<ImmutableArray`1<CustomModifier>> get_TypeArgumentsCustomModifiers();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal ImmutableArray`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    private sealed virtual override IAttributeTargetSymbol Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_AttributesOwner();
    private sealed virtual override AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_DefaultAttributeLocation();
    private sealed virtual override AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_AllowedAttributeLocations();
    private CustomAttributesBag`1<CSharpAttributeData> GetAttributesBag();
    public sealed virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal TypeWellKnownAttributeData GetDecodedWellKnownAttributeData();
    internal CommonTypeEarlyWellKnownAttributeData GetEarlyDecodedWellKnownAttributeData();
    internal virtual CSharpAttributeData EarlyDecodeWellKnownAttribute(EarlyDecodeWellKnownAttributeArguments`4& arguments);
    internal virtual AttributeUsageInfo GetAttributeUsageInfo();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal sealed virtual void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    internal virtual bool get_IsExplicitDefinitionOfNoPiaLocalType();
    private AttributeUsageInfo DecodeAttributeUsageAttribute(CSharpAttributeData attribute, AttributeSyntax node, bool diagnose, DiagnosticBag diagnosticsOpt);
    private void DecodeCoClassAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    internal virtual bool get_IsComImport();
    internal virtual NamedTypeSymbol get_ComImportCoClass();
    private void ValidateConditionalAttribute(CSharpAttributeData attribute, AttributeSyntax node, DiagnosticBag diagnostics);
    internal virtual bool get_HasSpecialName();
    internal sealed virtual bool get_ShouldAddWinRTMembers();
    internal sealed virtual bool get_IsWindowsRuntimeImport();
    internal sealed virtual bool get_IsSerializable();
    private bool HasInstanceFields();
    internal sealed virtual TypeLayout get_Layout();
    internal bool get_HasStructLayoutAttribute();
    internal virtual CharSet get_MarshallingCharSet();
    internal sealed virtual bool get_HasDeclarativeSecurity();
    internal bool get_HasSecurityCriticalAttributes();
    internal sealed virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual void PostDecodeWellKnownAttributes(ImmutableArray`1<CSharpAttributeData> boundAttributes, ImmutableArray`1<AttributeSyntax> allAttributeSyntaxNodes, DiagnosticBag diagnostics, AttributeLocation symbolPart, WellKnownAttributeData decodedData);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal sealed virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
    internal sealed virtual ImmutableArray`1<NamedTypeSymbol> InterfacesNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
    protected virtual void CheckBase(DiagnosticBag diagnostics);
    protected virtual void CheckInterfaces(DiagnosticBag diagnostics);
    private SourceLocation FindBaseRefSyntax(NamedTypeSymbol baseSym);
    private SingleTypeDeclaration FirstDeclarationWithExplicitBases();
    internal Tuple`2<NamedTypeSymbol, ImmutableArray`1<NamedTypeSymbol>> GetDeclaredBases(ConsList`1<Symbol> basesBeingResolved);
    internal virtual NamedTypeSymbol GetDeclaredBaseType(ConsList`1<Symbol> basesBeingResolved);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved);
    private Tuple`2<NamedTypeSymbol, ImmutableArray`1<NamedTypeSymbol>> MakeDeclaredBases(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    private static BaseListSyntax GetBaseListOpt(SingleTypeDeclaration decl);
    private Tuple`2<NamedTypeSymbol, ImmutableArray`1<NamedTypeSymbol>> MakeOneDeclaredBases(ConsList`1<Symbol> newBasesBeingResolved, SingleTypeDeclaration decl, DiagnosticBag diagnostics);
    private static bool IsRestrictedBaseType(SpecialType specialType);
    private ImmutableArray`1<NamedTypeSymbol> MakeAcyclicInterfaces(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    private NamedTypeSymbol MakeAcyclicBaseType(DiagnosticBag diagnostics);
    public virtual NamedTypeSymbol get_EnumUnderlyingType();
    private NamedTypeSymbol GetEnumUnderlyingType(DiagnosticBag diagnostics);
    internal FieldSymbol get_EnumValueField();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamespaceSymbol : NamespaceSymbol {
    private SourceModuleSymbol _module;
    private Symbol _container;
    private MergedNamespaceDeclaration _mergedDeclaration;
    private SymbolCompletionState _state;
    private ImmutableArray`1<Location> _locations;
    private Dictionary`2<string, ImmutableArray`1<NamespaceOrTypeSymbol>> _nameToMembersMap;
    private Dictionary`2<string, ImmutableArray`1<NamedTypeSymbol>> _nameToTypeMembersMap;
    private ImmutableArray`1<Symbol> _lazyAllMembers;
    private ImmutableArray`1<NamedTypeSymbol> _lazyTypeMembersUnordered;
    private static int LazyAllMembersIsSorted;
    private int _flags;
    private LexicalSortKey _lazyLexicalSortKey;
    private static Func`2<SingleNamespaceDeclaration, SyntaxReference> s_declaringSyntaxReferencesSelector;
    internal MergedNamespaceDeclaration MergedDeclaration { get; }
    public Symbol ContainingSymbol { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public string Name { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal ModuleSymbol ContainingModule { get; }
    internal NamespaceExtent Extent { get; }
    internal SourceNamespaceSymbol(SourceModuleSymbol module, Symbol container, MergedNamespaceDeclaration mergedDeclaration);
    private static SourceNamespaceSymbol();
    internal MergedNamespaceDeclaration get_MergedDeclaration();
    public virtual Symbol get_ContainingSymbol();
    public virtual AssemblySymbol get_ContainingAssembly();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamespaceSymbol/<GetBoundImportsMerged>d__19")]
internal IEnumerable`1<Imports> GetBoundImportsMerged();
    public virtual string get_Name();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    private ImmutableArray`1<SyntaxReference> ComputeDeclaringReferencesCore();
    internal virtual ImmutableArray`1<Symbol> GetMembersUnordered();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembersUnordered();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    internal virtual ModuleSymbol get_ContainingModule();
    internal virtual NamespaceExtent get_Extent();
    private Dictionary`2<string, ImmutableArray`1<NamespaceOrTypeSymbol>> GetNameToMembersMap();
    private Dictionary`2<string, ImmutableArray`1<NamedTypeSymbol>> GetNameToTypeMembersMap();
    private Dictionary`2<string, ImmutableArray`1<NamespaceOrTypeSymbol>> MakeNameToMembersMap(DiagnosticBag diagnostics);
    private NamespaceOrTypeSymbol BuildSymbol(MergedNamespaceOrTypeDeclaration declaration, DiagnosticBag diagnostics);
    private void RegisterDeclaredCorTypes();
    internal virtual bool IsDefinedInSourceTree(SyntaxTree tree, Nullable`1<TextSpan> definedWithinSpan, CancellationToken cancellationToken);
    internal virtual void ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken);
    internal virtual bool HasComplete(CompletionPart part);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceOverridingMethodTypeParameterSymbol : SourceTypeParameterSymbolBase {
    private OverriddenMethodTypeParameterMapBase _map;
    public SourceMemberMethodSymbol Owner { get; }
    public TypeParameterKind TypeParameterKind { get; }
    public Symbol ContainingSymbol { get; }
    public bool HasConstructorConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    protected ImmutableArray`1<TypeParameterSymbol> ContainerTypeParameters { get; }
    private TypeParameterSymbol OverriddenTypeParameter { get; }
    public SourceOverridingMethodTypeParameterSymbol(OverriddenMethodTypeParameterMapBase map, string name, int ordinal, ImmutableArray`1<Location> locations, ImmutableArray`1<SyntaxReference> syntaxRefs);
    public SourceMemberMethodSymbol get_Owner();
    public virtual TypeParameterKind get_TypeParameterKind();
    public virtual Symbol get_ContainingSymbol();
    public virtual bool get_HasConstructorConstraint();
    public virtual bool get_HasValueTypeConstraint();
    public virtual bool get_HasReferenceTypeConstraint();
    protected virtual ImmutableArray`1<TypeParameterSymbol> get_ContainerTypeParameters();
    protected virtual TypeParameterBounds ResolveBounds(ConsList`1<TypeParameterSymbol> inProgress, DiagnosticBag diagnostics);
    private TypeParameterSymbol get_OverriddenTypeParameter();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SourceParameterSymbol : SourceParameterSymbolBase {
    protected SymbolCompletionState state;
    protected TypeSymbol parameterType;
    private string _name;
    private ImmutableArray`1<Location> _locations;
    private RefKind _refKind;
    internal bool RequiresCompletion { get; }
    internal bool HasOptionalAttribute { get; }
    internal bool HasDefaultArgumentSyntax { get; }
    internal SyntaxList`1<AttributeListSyntax> AttributeDeclarationList { get; }
    internal SyntaxReference SyntaxReference { get; }
    internal bool IsExtensionMethodThis { get; }
    public RefKind RefKind { get; }
    public string Name { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public TypeSymbol Type { get; }
    public bool IsImplicitlyDeclared { get; }
    protected SourceParameterSymbol(Symbol owner, TypeSymbol parameterType, int ordinal, RefKind refKind, string name, ImmutableArray`1<Location> locations);
    public static SourceParameterSymbol Create(Binder context, Symbol owner, TypeSymbol parameterType, ParameterSyntax syntax, RefKind refKind, SyntaxToken identifier, int ordinal, bool isParams, bool isExtensionMethodThis, DiagnosticBag diagnostics);
    internal virtual ParameterSymbol WithCustomModifiersAndParams(TypeSymbol newType, ImmutableArray`1<CustomModifier> newCustomModifiers, ushort countOfCustomModifiersPrecedingByRef, bool newIsParams);
    internal SourceParameterSymbol WithCustomModifiersAndParamsCore(TypeSymbol newType, ImmutableArray`1<CustomModifier> newCustomModifiers, ushort countOfCustomModifiersPrecedingByRef, bool newIsParams);
    internal sealed virtual bool get_RequiresCompletion();
    internal sealed virtual bool HasComplete(CompletionPart part);
    internal virtual void ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken);
    internal abstract virtual bool get_HasOptionalAttribute();
    internal abstract virtual bool get_HasDefaultArgumentSyntax();
    internal abstract virtual SyntaxList`1<AttributeListSyntax> get_AttributeDeclarationList();
    internal abstract virtual CustomAttributesBag`1<CSharpAttributeData> GetAttributesBag();
    public sealed virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal abstract virtual SyntaxReference get_SyntaxReference();
    internal abstract virtual bool get_IsExtensionMethodThis();
    public sealed virtual RefKind get_RefKind();
    public sealed virtual string get_Name();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public sealed virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public sealed virtual TypeSymbol get_Type();
    public virtual bool get_IsImplicitlyDeclared();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SourceParameterSymbolBase : ParameterSymbol {
    private Symbol _containingSymbol;
    private ushort _ordinal;
    public int Ordinal { get; }
    public Symbol ContainingSymbol { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal ConstantValue DefaultValueFromAttributes { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    public SourceParameterSymbolBase(Symbol containingSymbol, int ordinal);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual int get_Ordinal();
    public sealed virtual Symbol get_ContainingSymbol();
    public sealed virtual AssemblySymbol get_ContainingAssembly();
    internal abstract virtual ConstantValue get_DefaultValueFromAttributes();
    internal sealed virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal virtual ushort get_CountOfCustomModifiersPrecedingByRef();
    internal abstract virtual ParameterSymbol WithCustomModifiersAndParams(TypeSymbol newType, ImmutableArray`1<CustomModifier> newCustomModifiers, ushort countOfCustomModifiersPrecedingByRef, bool newIsParams);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertyAccessorSymbol : SourceMethodSymbol {
    private SourcePropertySymbol _property;
    private ImmutableArray`1<ParameterSymbol> _lazyParameters;
    private TypeSymbol _lazyReturnType;
    private ImmutableArray`1<CustomModifier> _lazyReturnTypeCustomModifiers;
    private ImmutableArray`1<MethodSymbol> _explicitInterfaceImplementations;
    private string _name;
    private bool _isAutoPropertyAccessor;
    internal bool IsExpressionBodied { get; }
    public Accessibility DeclaredAccessibility { get; }
    public Symbol AssociatedSymbol { get; }
    public bool IsVararg { get; }
    public bool ReturnsVoid { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    internal Accessibility LocalAccessibility { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public string Name { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool GenerateDebugInfo { get; }
    private SourcePropertyAccessorSymbol(NamedTypeSymbol containingType, string name, SourcePropertySymbol property, DeclarationModifiers propertyModifiers, ImmutableArray`1<MethodSymbol> explicitInterfaceImplementations, Location location, ArrowExpressionClauseSyntax syntax, DiagnosticBag diagnostics);
    private SourcePropertyAccessorSymbol(NamedTypeSymbol containingType, string name, SourcePropertySymbol property, DeclarationModifiers propertyModifiers, ImmutableArray`1<MethodSymbol> explicitInterfaceImplementations, Location location, AccessorDeclarationSyntax syntax, MethodKind methodKind, bool isAutoPropertyAccessor, DiagnosticBag diagnostics);
    public static SourcePropertyAccessorSymbol CreateAccessorSymbol(NamedTypeSymbol containingType, SourcePropertySymbol property, DeclarationModifiers propertyModifiers, string propertyName, AccessorDeclarationSyntax syntax, PropertySymbol explicitlyImplementedPropertyOpt, string aliasQualifierOpt, bool isAutoPropertyAccessor, DiagnosticBag diagnostics);
    public static SourcePropertyAccessorSymbol CreateAccessorSymbol(NamedTypeSymbol containingType, SourcePropertySymbol property, DeclarationModifiers propertyModifiers, string propertyName, ArrowExpressionClauseSyntax syntax, PropertySymbol explicitlyImplementedPropertyOpt, string aliasQualifierOpt, DiagnosticBag diagnostics);
    internal virtual bool get_IsExpressionBodied();
    private static void GetNameAndExplicitInterfaceImplementations(PropertySymbol explicitlyImplementedPropertyOpt, string propertyName, bool isWinMd, string aliasQualifierOpt, bool isGetMethod, String& name, ImmutableArray`1& explicitInterfaceImplementations);
    protected virtual void MethodChecks(DiagnosticBag diagnostics);
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual Symbol get_AssociatedSymbol();
    public virtual bool get_IsVararg();
    public virtual bool get_ReturnsVoid();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual TypeSymbol get_ReturnType();
    private TypeSymbol ComputeReturnType(DiagnosticBag diagnostics);
    private Binder GetBinder();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    internal Accessibility get_LocalAccessibility();
    private DeclarationModifiers MakeModifiers(AccessorDeclarationSyntax syntax, Location location, DiagnosticBag diagnostics, Boolean& modifierErrors);
    private void CheckModifiers(Location location, bool isAutoPropertyOrExpressionBodied, DiagnosticBag diagnostics);
    internal static string GetAccessorName(string propertyName, bool getNotSet, bool isWinMdOutput);
    internal CSharpSyntaxNode GetSyntax();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    internal virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    public virtual string get_Name();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual bool get_GenerateDebugInfo();
    private ImmutableArray`1<ParameterSymbol> ComputeParameters(DiagnosticBag diagnostics);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbol : PropertySymbol {
    private static string DefaultIndexerName;
    private SourceMemberContainerTypeSymbol _containingType;
    private string _name;
    private SyntaxReference _syntaxRef;
    private Location _location;
    private DeclarationModifiers _modifiers;
    private ImmutableArray`1<CustomModifier> _typeCustomModifiers;
    private SourcePropertyAccessorSymbol _getMethod;
    private SourcePropertyAccessorSymbol _setMethod;
    private SynthesizedBackingFieldSymbol _backingField;
    private TypeSymbol _explicitInterfaceType;
    private ImmutableArray`1<PropertySymbol> _explicitInterfaceImplementations;
    private bool _isExpressionBodied;
    private bool _isAutoProperty;
    private SymbolCompletionState _state;
    private ImmutableArray`1<ParameterSymbol> _lazyParameters;
    private TypeSymbol _lazyType;
    private string _sourceName;
    private string _lazyDocComment;
    private OverriddenOrHiddenMembersResult _lazyOverriddenOrHiddenMembers;
    private SynthesizedSealedPropertyAccessor _lazySynthesizedSealedAccessor;
    private CustomAttributesBag`1<CSharpAttributeData> _lazyCustomAttributesBag;
    internal bool IsExpressionBodied { get; }
    public TypeSymbol Type { get; }
    internal bool HasPointerType { get; }
    public string Name { get; }
    public string MetadataName { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public ImmutableArray`1<Location> Locations { get; }
    internal Location Location { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsAbstract { get; }
    public bool IsExtern { get; }
    public bool IsStatic { get; }
    internal bool IsFixed { get; }
    public bool IsIndexer { get; }
    public bool IsOverride { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    internal bool IsNew { get; }
    public MethodSymbol GetMethod { get; }
    public MethodSymbol SetMethod { get; }
    internal CallingConvention CallingConvention { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<PropertySymbol> ExplicitInterfaceImplementations { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public Accessibility DeclaredAccessibility { get; }
    internal bool IsAutoProperty { get; }
    internal SynthesizedBackingFieldSymbol BackingField { get; }
    internal bool MustCallMethodsDirectly { get; }
    internal SyntaxReference SyntaxReference { get; }
    internal BasePropertyDeclarationSyntax CSharpSyntaxNode { get; }
    internal SyntaxTree SyntaxTree { get; }
    internal OverriddenOrHiddenMembersResult OverriddenOrHiddenMembers { get; }
    internal SynthesizedSealedPropertyAccessor SynthesizedSealedAccessorOpt { get; }
    private IAttributeTargetSymbol Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AttributesOwner { get; }
    private AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.DefaultAttributeLocation { get; }
    private AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AllowedAttributeLocations { get; }
    internal bool HasSpecialName { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool RequiresCompletion { get; }
    private SourcePropertySymbol(SourceMemberContainerTypeSymbol containingType, Binder bodyBinder, BasePropertyDeclarationSyntax syntax, string name, Location location, DiagnosticBag diagnostics);
    internal bool get_IsExpressionBodied();
    private void CheckInitializer(bool hasExpressionBody, bool isAutoProperty, Location location, DiagnosticBag diagnostics);
    internal static SourcePropertySymbol Create(SourceMemberContainerTypeSymbol containingType, Binder bodyBinder, PropertyDeclarationSyntax syntax, DiagnosticBag diagnostics);
    internal static SourcePropertySymbol Create(SourceMemberContainerTypeSymbol containingType, Binder bodyBinder, IndexerDeclarationSyntax syntax, DiagnosticBag diagnostics);
    public virtual TypeSymbol get_Type();
    internal bool get_HasPointerType();
    public virtual string get_Name();
    public virtual string get_MetadataName();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public virtual ImmutableArray`1<Location> get_Locations();
    internal Location get_Location();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsExtern();
    public virtual bool get_IsStatic();
    internal bool get_IsFixed();
    public virtual bool get_IsIndexer();
    public virtual bool get_IsOverride();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    internal bool get_IsNew();
    public virtual MethodSymbol get_GetMethod();
    public virtual MethodSymbol get_SetMethod();
    internal virtual CallingConvention get_CallingConvention();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public virtual ImmutableArray`1<PropertySymbol> get_ExplicitInterfaceImplementations();
    public virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
    public virtual Accessibility get_DeclaredAccessibility();
    internal bool get_IsAutoProperty();
    internal SynthesizedBackingFieldSymbol get_BackingField();
    internal virtual bool get_MustCallMethodsDirectly();
    internal SyntaxReference get_SyntaxReference();
    internal BasePropertyDeclarationSyntax get_CSharpSyntaxNode();
    internal SyntaxTree get_SyntaxTree();
    internal virtual void AfterAddingTypeMembersChecks(ConversionsBase conversions, DiagnosticBag diagnostics);
    private void CheckAccessibility(Location location, DiagnosticBag diagnostics);
    private DeclarationModifiers MakeModifiers(SyntaxTokenList modifiers, bool isExplicitInterfaceImplementation, bool isIndexer, Location location, DiagnosticBag diagnostics, Boolean& modifierErrors);
    private static ImmutableArray`1<ParameterSymbol> MakeParameters(Binder binder, SourcePropertySymbol owner, BaseParameterListSyntax parameterSyntaxOpt, DiagnosticBag diagnostics);
    private void CheckModifiers(Location location, bool isIndexer, DiagnosticBag diagnostics);
    private SourcePropertyAccessorSymbol CreateAccessorSymbol(AccessorDeclarationSyntax syntaxOpt, PropertySymbol explicitlyImplementedPropertyOpt, string aliasQualifierOpt, bool isAutoPropertyAccessor, DiagnosticBag diagnostics);
    private void CheckAccessibilityMoreRestrictive(SourcePropertyAccessorSymbol accessor, DiagnosticBag diagnostics);
    private static bool IsAccessibilityMoreRestrictive(Accessibility property, Accessibility accessor);
    private static void CheckAbstractPropertyAccessorNotPrivate(SourcePropertyAccessorSymbol accessor, DiagnosticBag diagnostics);
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    private void CheckExplicitImplementationAccessor(MethodSymbol thisAccessor, MethodSymbol otherAccessor, PropertySymbol explicitlyImplementedProperty, DiagnosticBag diagnostics);
    internal virtual OverriddenOrHiddenMembersResult get_OverriddenOrHiddenMembers();
    internal SynthesizedSealedPropertyAccessor get_SynthesizedSealedAccessorOpt();
    private SynthesizedSealedPropertyAccessor MakeSynthesizedSealedAccessor();
    private sealed virtual override IAttributeTargetSymbol Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_AttributesOwner();
    private sealed virtual override AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_DefaultAttributeLocation();
    private sealed virtual override AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_AllowedAttributeLocations();
    private CustomAttributesBag`1<CSharpAttributeData> GetAttributesBag();
    public sealed virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    private CommonPropertyWellKnownAttributeData GetDecodedWellKnownAttributeData();
    internal PropertyEarlyWellKnownAttributeData GetEarlyDecodedWellKnownAttributeData();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal virtual bool get_HasSpecialName();
    internal virtual CSharpAttributeData EarlyDecodeWellKnownAttribute(EarlyDecodeWellKnownAttributeArguments`4& arguments);
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    internal virtual void PostDecodeWellKnownAttributes(ImmutableArray`1<CSharpAttributeData> boundAttributes, ImmutableArray`1<AttributeSyntax> allAttributeSyntaxNodes, DiagnosticBag diagnostics, AttributeLocation symbolPart, WellKnownAttributeData decodedData);
    private void ValidateIndexerNameAttribute(CSharpAttributeData attribute, AttributeSyntax node, DiagnosticBag diagnostics);
    internal sealed virtual bool get_RequiresCompletion();
    internal sealed virtual bool HasComplete(CompletionPart part);
    internal virtual void ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken);
    private TypeSymbol ComputeType(Binder binder, BasePropertyDeclarationSyntax syntax, DiagnosticBag diagnostics);
    private ImmutableArray`1<ParameterSymbol> ComputeParameters(Binder binder, BasePropertyDeclarationSyntax syntax, DiagnosticBag diagnostics);
    private Binder CreateBinderForTypeAndParameters();
    private static ExplicitInterfaceSpecifierSyntax GetExplicitInterfaceSpecifier(BasePropertyDeclarationSyntax syntax);
    private static BaseParameterListSyntax GetParameterListSyntax(BasePropertyDeclarationSyntax syntax);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceSimpleParameterSymbol : SourceParameterSymbol {
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    internal bool IsMetadataOptional { get; }
    public bool IsParams { get; }
    internal bool HasDefaultArgumentSyntax { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    internal SyntaxReference SyntaxReference { get; }
    internal bool IsExtensionMethodThis { get; }
    internal bool IsMetadataIn { get; }
    internal bool IsMetadataOut { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    internal bool IsCallerFilePath { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerMemberName { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal bool HasOptionalAttribute { get; }
    internal SyntaxList`1<AttributeListSyntax> AttributeDeclarationList { get; }
    internal ConstantValue DefaultValueFromAttributes { get; }
    public SourceSimpleParameterSymbol(Symbol owner, TypeSymbol parameterType, int ordinal, RefKind refKind, string name, ImmutableArray`1<Location> locations);
    internal virtual ConstantValue get_ExplicitDefaultConstantValue();
    internal virtual bool get_IsMetadataOptional();
    public virtual bool get_IsParams();
    internal virtual bool get_HasDefaultArgumentSyntax();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    internal virtual SyntaxReference get_SyntaxReference();
    internal virtual bool get_IsExtensionMethodThis();
    internal virtual bool get_IsMetadataIn();
    internal virtual bool get_IsMetadataOut();
    internal virtual bool get_IsIDispatchConstant();
    internal virtual bool get_IsIUnknownConstant();
    internal virtual bool get_IsCallerFilePath();
    internal virtual bool get_IsCallerLineNumber();
    internal virtual bool get_IsCallerMemberName();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual bool get_HasOptionalAttribute();
    internal virtual SyntaxList`1<AttributeListSyntax> get_AttributeDeclarationList();
    internal virtual CustomAttributesBag`1<CSharpAttributeData> GetAttributesBag();
    internal virtual ConstantValue get_DefaultValueFromAttributes();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceTypeParameterSymbol : SourceTypeParameterSymbolBase {
    private SourceNamedTypeSymbol _owner;
    private VarianceKind _varianceKind;
    public TypeParameterKind TypeParameterKind { get; }
    public Symbol ContainingSymbol { get; }
    public VarianceKind Variance { get; }
    public bool HasConstructorConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    protected ImmutableArray`1<TypeParameterSymbol> ContainerTypeParameters { get; }
    public SourceTypeParameterSymbol(SourceNamedTypeSymbol owner, string name, int ordinal, VarianceKind varianceKind, ImmutableArray`1<Location> locations, ImmutableArray`1<SyntaxReference> syntaxRefs);
    public virtual TypeParameterKind get_TypeParameterKind();
    public virtual Symbol get_ContainingSymbol();
    public virtual VarianceKind get_Variance();
    public virtual bool get_HasConstructorConstraint();
    public virtual bool get_HasValueTypeConstraint();
    public virtual bool get_HasReferenceTypeConstraint();
    protected virtual ImmutableArray`1<TypeParameterSymbol> get_ContainerTypeParameters();
    protected virtual TypeParameterBounds ResolveBounds(ConsList`1<TypeParameterSymbol> inProgress, DiagnosticBag diagnostics);
    private TypeParameterConstraintKind GetDeclaredConstraints();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SourceTypeParameterSymbolBase : TypeParameterSymbol {
    private ImmutableArray`1<SyntaxReference> _syntaxRefs;
    private ImmutableArray`1<Location> _locations;
    private string _name;
    private short _ordinal;
    private SymbolCompletionState _state;
    private CustomAttributesBag`1<CSharpAttributeData> _lazyCustomAttributesBag;
    private TypeParameterBounds _lazyBounds;
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal ImmutableArray`1<SyntaxReference> SyntaxReferences { get; }
    public int Ordinal { get; }
    public VarianceKind Variance { get; }
    public string Name { get; }
    internal ImmutableArray`1<SyntaxList`1<AttributeListSyntax>> MergedAttributeDeclarationSyntaxLists { get; }
    private IAttributeTargetSymbol Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AttributesOwner { get; }
    private AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.DefaultAttributeLocation { get; }
    private AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AllowedAttributeLocations { get; }
    protected ImmutableArray`1<TypeParameterSymbol> ContainerTypeParameters { get; }
    protected SourceTypeParameterSymbolBase(string name, int ordinal, ImmutableArray`1<Location> locations, ImmutableArray`1<SyntaxReference> syntaxRefs);
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal ImmutableArray`1<SyntaxReference> get_SyntaxReferences();
    public virtual int get_Ordinal();
    public virtual VarianceKind get_Variance();
    public virtual string get_Name();
    internal virtual ImmutableArray`1<TypeSymbol> GetConstraintTypes(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetInterfaces(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual NamedTypeSymbol GetEffectiveBaseClass(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual TypeSymbol GetDeducedBaseType(ConsList`1<TypeParameterSymbol> inProgress);
    internal ImmutableArray`1<SyntaxList`1<AttributeListSyntax>> get_MergedAttributeDeclarationSyntaxLists();
    private sealed virtual override IAttributeTargetSymbol Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_AttributesOwner();
    private sealed virtual override AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_DefaultAttributeLocation();
    private sealed virtual override AttributeLocation Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.get_AllowedAttributeLocations();
    public sealed virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal virtual CustomAttributesBag`1<CSharpAttributeData> GetAttributesBag();
    internal virtual void EnsureAllConstraintsAreResolved();
    protected abstract virtual ImmutableArray`1<TypeParameterSymbol> get_ContainerTypeParameters();
    private TypeParameterBounds GetBounds(ConsList`1<TypeParameterSymbol> inProgress);
    protected abstract virtual TypeParameterBounds ResolveBounds(ConsList`1<TypeParameterSymbol> inProgress, DiagnosticBag diagnostics);
    private void CheckConstraintTypeConstraints(DiagnosticBag diagnostics);
    private NamedTypeSymbol GetDefaultBaseType();
    internal virtual void ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceUserDefinedConversionSymbol : SourceUserDefinedOperatorSymbolBase {
    protected ParameterListSyntax ParameterListSyntax { get; }
    protected TypeSyntax ReturnTypeSyntax { get; }
    internal bool GenerateDebugInfo { get; }
    private SourceUserDefinedConversionSymbol(SourceMemberContainerTypeSymbol containingType, string name, Location location, ConversionOperatorDeclarationSyntax syntax, DiagnosticBag diagnostics, bool isExpressionBodied);
    public static SourceUserDefinedConversionSymbol CreateUserDefinedConversionSymbol(SourceMemberContainerTypeSymbol containingType, ConversionOperatorDeclarationSyntax syntax, DiagnosticBag diagnostics);
    internal ConversionOperatorDeclarationSyntax GetSyntax();
    protected virtual ParameterListSyntax get_ParameterListSyntax();
    protected virtual TypeSyntax get_ReturnTypeSyntax();
    internal virtual bool get_GenerateDebugInfo();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SourceUserDefinedOperatorSymbol : SourceUserDefinedOperatorSymbolBase {
    protected ParameterListSyntax ParameterListSyntax { get; }
    protected TypeSyntax ReturnTypeSyntax { get; }
    internal bool GenerateDebugInfo { get; }
    private SourceUserDefinedOperatorSymbol(SourceMemberContainerTypeSymbol containingType, string name, Location location, OperatorDeclarationSyntax syntax, DiagnosticBag diagnostics, bool isExpressionBodied);
    public static SourceUserDefinedOperatorSymbol CreateUserDefinedOperatorSymbol(SourceMemberContainerTypeSymbol containingType, OperatorDeclarationSyntax syntax, DiagnosticBag diagnostics);
    internal OperatorDeclarationSyntax GetSyntax();
    protected virtual ParameterListSyntax get_ParameterListSyntax();
    protected virtual TypeSyntax get_ReturnTypeSyntax();
    internal virtual bool get_GenerateDebugInfo();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SourceUserDefinedOperatorSymbolBase : SourceMethodSymbol {
    private string _name;
    private bool _isExpressionBodied;
    private ImmutableArray`1<ParameterSymbol> _lazyParameters;
    private TypeSymbol _lazyReturnType;
    protected ParameterListSyntax ParameterListSyntax { get; }
    protected TypeSyntax ReturnTypeSyntax { get; }
    public string Name { get; }
    public bool ReturnsVoid { get; }
    public bool IsVararg { get; }
    public bool IsExtensionMethod { get; }
    public ImmutableArray`1<Location> Locations { get; }
    internal int ParameterCount { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public TypeSymbol ReturnType { get; }
    internal bool IsExpressionBodied { get; }
    protected SourceUserDefinedOperatorSymbolBase(MethodKind methodKind, string name, SourceMemberContainerTypeSymbol containingType, Location location, SyntaxReference syntaxReference, SyntaxReference bodySyntaxReference, SyntaxTokenList modifiersSyntax, DiagnosticBag diagnostics, bool isExpressionBodied);
    internal BaseMethodDeclarationSyntax GetSyntax();
    protected abstract virtual ParameterListSyntax get_ParameterListSyntax();
    protected abstract virtual TypeSyntax get_ReturnTypeSyntax();
    protected virtual void MethodChecks(DiagnosticBag diagnostics);
    private void CheckValueParameters(DiagnosticBag diagnostics);
    private void CheckOperatorSignatures(DiagnosticBag diagnostics);
    private static bool DoesOperatorHaveCorrectArity(string name, int parameterCount);
    private void CheckUserDefinedConversionSignature(DiagnosticBag diagnostics);
    private void CheckUnarySignature(DiagnosticBag diagnostics);
    private void CheckTrueFalseSignature(DiagnosticBag diagnostics);
    private void CheckIncrementDecrementSignature(DiagnosticBag diagnostics);
    private void CheckShiftSignature(DiagnosticBag diagnostics);
    private void CheckBinarySignature(DiagnosticBag diagnostics);
    public sealed virtual string get_Name();
    public sealed virtual bool get_ReturnsVoid();
    public sealed virtual bool get_IsVararg();
    public sealed virtual bool get_IsExtensionMethod();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    internal sealed virtual int get_ParameterCount();
    public sealed virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public sealed virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public sealed virtual TypeSymbol get_ReturnType();
    internal virtual bool get_IsExpressionBodied();
    internal sealed virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    internal sealed virtual void AfterAddingTypeMembersChecks(ConversionsBase conversions, DiagnosticBag diagnostics);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.SpecialTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsIntegralType(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsSignedIntegralType(SpecialType specialType);
    [ExtensionAttribute]
public static bool CanBeConst(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsIntrinsicType(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsValidVolatileFieldType(SpecialType specialType);
    [ExtensionAttribute]
public static int FixedBufferElementSizeInBytes(SpecialType specialType);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedErrorTypeSymbol : ErrorTypeSymbol {
    private ErrorTypeSymbol _originalDefinition;
    private int _hashCode;
    public NamedTypeSymbol OriginalDefinition { get; }
    internal bool MangleName { get; }
    internal DiagnosticInfo ErrorInfo { get; }
    public int Arity { get; }
    public string Name { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<Symbol> CandidateSymbols { get; }
    internal LookupResultKind ResultKind { get; }
    protected SubstitutedErrorTypeSymbol(ErrorTypeSymbol originalDefinition);
    public virtual NamedTypeSymbol get_OriginalDefinition();
    internal virtual bool get_MangleName();
    internal virtual DiagnosticInfo get_ErrorInfo();
    public virtual int get_Arity();
    public virtual string get_Name();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<Symbol> get_CandidateSymbols();
    internal virtual LookupResultKind get_ResultKind();
    internal virtual DiagnosticInfo GetUseSiteDiagnostic();
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedEventSymbol : EventSymbol {
    private EventSymbol _originalDefinition;
    private SubstitutedNamedTypeSymbol _containingType;
    private TypeSymbol _lazyType;
    private ImmutableArray`1<EventSymbol> _lazyExplicitInterfaceImplementations;
    private OverriddenOrHiddenMembersResult _lazyOverriddenOrHiddenMembers;
    public TypeSymbol Type { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    public Symbol ContainingSymbol { get; }
    public EventSymbol OriginalDefinition { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsStatic { get; }
    public bool IsExtern { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public bool IsImplicitlyDeclared { get; }
    public MethodSymbol AddMethod { get; }
    public MethodSymbol RemoveMethod { get; }
    internal FieldSymbol AssociatedField { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<EventSymbol> ExplicitInterfaceImplementations { get; }
    internal bool MustCallMethodsDirectly { get; }
    public Accessibility DeclaredAccessibility { get; }
    internal OverriddenOrHiddenMembersResult OverriddenOrHiddenMembers { get; }
    public bool IsWindowsRuntimeEvent { get; }
    internal SubstitutedEventSymbol(SubstitutedNamedTypeSymbol containingType, EventSymbol originalDefinition);
    public virtual TypeSymbol get_Type();
    public virtual string get_Name();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual bool get_HasSpecialName();
    public virtual Symbol get_ContainingSymbol();
    public virtual EventSymbol get_OriginalDefinition();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    public virtual bool get_IsStatic();
    public virtual bool get_IsExtern();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual MethodSymbol get_AddMethod();
    public virtual MethodSymbol get_RemoveMethod();
    internal virtual FieldSymbol get_AssociatedField();
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public virtual ImmutableArray`1<EventSymbol> get_ExplicitInterfaceImplementations();
    internal virtual bool get_MustCallMethodsDirectly();
    public virtual Accessibility get_DeclaredAccessibility();
    internal virtual OverriddenOrHiddenMembersResult get_OverriddenOrHiddenMembers();
    public virtual bool get_IsWindowsRuntimeEvent();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedFieldSymbol : FieldSymbol {
    private SubstitutedNamedTypeSymbol _containingType;
    private FieldSymbol _originalDefinition;
    private TypeSymbol _lazyType;
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal bool IsNotSerialized { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal Nullable`1<int> TypeLayoutOffset { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public FieldSymbol OriginalDefinition { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Symbol AssociatedSymbol { get; }
    public bool IsStatic { get; }
    public bool IsReadOnly { get; }
    public bool IsConst { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public object ConstantValue { get; }
    public bool IsVolatile { get; }
    public bool IsImplicitlyDeclared { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    internal SubstitutedFieldSymbol(SubstitutedNamedTypeSymbol containingType, FieldSymbol substitutedFrom);
    internal virtual TypeSymbol GetFieldType(ConsList`1<FieldSymbol> fieldsBeingBound);
    public virtual string get_Name();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_HasRuntimeSpecialName();
    internal virtual bool get_IsNotSerialized();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual Nullable`1<int> get_TypeLayoutOffset();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual FieldSymbol get_OriginalDefinition();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    public virtual Symbol get_AssociatedSymbol();
    public virtual bool get_IsStatic();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsConst();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual object get_ConstantValue();
    internal virtual ConstantValue GetConstantValue(ConstantFieldsInProgress inProgress, bool earlyDecodingWellKnownAttributes);
    public virtual bool get_IsVolatile();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    internal virtual NamedTypeSymbol FixedImplementationType(PEModuleBuilder emitModule);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedMethodSymbol : MethodSymbol {
    private NamedTypeSymbol _containingType;
    protected MethodSymbol originalDefinition;
    private TypeMap _inputMap;
    private MethodSymbol _constructedFrom;
    private TypeSymbol _lazyReturnType;
    private ImmutableArray`1<ParameterSymbol> _lazyParameters;
    private TypeMap _lazyMap;
    private ImmutableArray`1<TypeParameterSymbol> _lazyTypeParameters;
    private ImmutableArray`1<MethodSymbol> _lazyExplicitInterfaceImplementations;
    private OverriddenOrHiddenMembersResult _lazyOverriddenOrHiddenMembers;
    private int _hashCode;
    public MethodSymbol ConstructedFrom { get; }
    private TypeMap Map { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    internal CallingConvention CallingConvention { get; }
    public int Arity { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool RequiresSecurityObject { get; }
    internal MarshalPseudoCustomAttributeData ReturnValueMarshallingInformation { get; }
    internal bool HasDeclarativeSecurity { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public MethodSymbol OriginalDefinition { get; }
    public bool IsExtern { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsAsync { get; }
    public bool IsAbstract { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsExtensionMethod { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal MethodSymbol CallsiteReducedFromMethod { get; }
    public TypeSymbol ReceiverType { get; }
    public MethodSymbol ReducedFrom { get; }
    public bool HidesBaseMethodsByName { get; }
    public Accessibility DeclaredAccessibility { get; }
    internal bool IsMetadataFinal { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public Symbol AssociatedSymbol { get; }
    public MethodKind MethodKind { get; }
    public bool ReturnsVoid { get; }
    public bool IsGenericMethod { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool GenerateDebugInfo { get; }
    public bool IsVararg { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    internal int ParameterCount { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    internal OverriddenOrHiddenMembersResult OverriddenOrHiddenMembers { get; }
    internal TypeMap TypeSubstitution { get; }
    internal SubstitutedMethodSymbol(SubstitutedNamedTypeSymbol containingSymbol, MethodSymbol originalDefinition);
    protected SubstitutedMethodSymbol(NamedTypeSymbol containingSymbol, TypeMap map, MethodSymbol originalDefinition, MethodSymbol constructedFrom);
    public virtual MethodSymbol get_ConstructedFrom();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    private TypeMap get_Map();
    public sealed virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    private void EnsureMapAndTypeParameters();
    internal sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual int get_Arity();
    public sealed virtual string get_Name();
    internal sealed virtual bool get_HasSpecialName();
    internal sealed virtual MethodImplAttributes get_ImplementationAttributes();
    internal sealed virtual bool get_RequiresSecurityObject();
    public sealed virtual DllImportData GetDllImportData();
    internal sealed virtual MarshalPseudoCustomAttributeData get_ReturnValueMarshallingInformation();
    internal sealed virtual bool get_HasDeclarativeSecurity();
    internal sealed virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal sealed virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    public sealed virtual AssemblySymbol get_ContainingAssembly();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public sealed virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public sealed virtual MethodSymbol get_OriginalDefinition();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsAsync();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsExtensionMethod();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal sealed virtual MethodSymbol get_CallsiteReducedFromMethod();
    public virtual TypeSymbol get_ReceiverType();
    public virtual TypeSymbol GetTypeInferredDuringReduction(TypeParameterSymbol reducedFromTypeParameter);
    public sealed virtual MethodSymbol get_ReducedFrom();
    public sealed virtual bool get_HidesBaseMethodsByName();
    public sealed virtual Accessibility get_DeclaredAccessibility();
    internal sealed virtual bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_IsMetadataFinal();
    internal sealed virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    public sealed virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public sealed virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    public sealed virtual Symbol get_AssociatedSymbol();
    public sealed virtual MethodKind get_MethodKind();
    public sealed virtual bool get_ReturnsVoid();
    public sealed virtual bool get_IsGenericMethod();
    public sealed virtual bool get_IsImplicitlyDeclared();
    internal sealed virtual bool get_GenerateDebugInfo();
    public sealed virtual bool get_IsVararg();
    public sealed virtual TypeSymbol get_ReturnType();
    public sealed virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    internal sealed virtual int get_ParameterCount();
    public sealed virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal sealed virtual bool get_IsExplicitInterfaceImplementation();
    public sealed virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    internal sealed virtual OverriddenOrHiddenMembersResult get_OverriddenOrHiddenMembers();
    internal sealed virtual bool CallsAreOmitted(SyntaxTree syntaxTree);
    internal sealed virtual TypeMap get_TypeSubstitution();
    internal sealed virtual bool TryGetThisParameter(ParameterSymbol& thisParameter);
    private ImmutableArray`1<ParameterSymbol> SubstituteParameters();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    private int ComputeHashCode();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedNamedTypeSymbol : NamedTypeSymbol {
    private static Func`3<Symbol, NamedTypeSymbol, Symbol> s_symbolAsMemberFunc;
    private bool _unbound;
    private NamedTypeSymbol _originalDefinition;
    private TypeMap _inputMap;
    private Symbol _newContainer;
    private TypeMap _lazyMap;
    private ImmutableArray`1<TypeParameterSymbol> _lazyTypeParameters;
    private int _hashCode;
    private ConcurrentCache`2<string, ImmutableArray`1<Symbol>> _lazyMembersByNameCache;
    public bool IsUnboundGenericType { get; }
    private TypeMap Map { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public string Name { get; }
    internal bool MangleName { get; }
    internal bool HasSpecialName { get; }
    public int Arity { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public SymbolKind Kind { get; }
    public NamedTypeSymbol OriginalDefinition { get; }
    public TypeKind TypeKind { get; }
    internal bool IsInterface { get; }
    public bool IsStatic { get; }
    public bool IsImplicitlyDeclared { get; }
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public bool MightContainExtensionMethods { get; }
    public NamedTypeSymbol EnumUnderlyingType { get; }
    internal TypeMap TypeSubstitution { get; }
    internal bool IsComImport { get; }
    internal NamedTypeSymbol ComImportCoClass { get; }
    internal bool ShouldAddWinRTMembers { get; }
    internal bool IsWindowsRuntimeImport { get; }
    internal TypeLayout Layout { get; }
    internal CharSet MarshallingCharSet { get; }
    internal bool IsSerializable { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    protected SubstitutedNamedTypeSymbol(Symbol newContainer, TypeMap map, NamedTypeSymbol originalDefinition, NamedTypeSymbol constructedFrom, bool unbound);
    private static SubstitutedNamedTypeSymbol();
    public sealed virtual bool get_IsUnboundGenericType();
    private TypeMap get_Map();
    public sealed virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    private void EnsureMapAndTypeParameters();
    public sealed virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public sealed virtual string get_Name();
    internal sealed virtual bool get_MangleName();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal sealed virtual bool get_HasSpecialName();
    public sealed virtual int get_Arity();
    public sealed virtual Accessibility get_DeclaredAccessibility();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public sealed virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public sealed virtual SymbolKind get_Kind();
    public sealed virtual NamedTypeSymbol get_OriginalDefinition();
    public sealed virtual TypeKind get_TypeKind();
    internal sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsImplicitlyDeclared();
    internal sealed virtual NamedTypeSymbol GetDeclaredBaseType(ConsList`1<Symbol> basesBeingResolved);
    internal sealed virtual ImmutableArray`1<NamedTypeSymbol> GetDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved);
    internal sealed virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
    internal sealed virtual ImmutableArray`1<NamedTypeSymbol> InterfacesNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetInterfacesToEmit();
    protected sealed virtual ImmutableArray`1<NamedTypeSymbol> MakeAllInterfaces();
    public sealed virtual IEnumerable`1<string> get_MemberNames();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    public sealed virtual bool get_MightContainExtensionMethods();
    internal sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembersUnordered();
    public sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public sealed virtual ImmutableArray`1<Symbol> GetMembers();
    internal sealed virtual ImmutableArray`1<Symbol> GetMembersUnordered();
    public sealed virtual ImmutableArray`1<Symbol> GetMembers(string name);
    private ImmutableArray`1<Symbol> GetMembersWorker(string name);
    internal virtual IEnumerable`1<FieldSymbol> GetFieldsToEmit();
    internal virtual ImmutableArray`1<Symbol> GetEarlyAttributeDecodingMembers();
    internal virtual ImmutableArray`1<Symbol> GetEarlyAttributeDecodingMembers(string name);
    public sealed virtual NamedTypeSymbol get_EnumUnderlyingType();
    public virtual int GetHashCode();
    internal sealed virtual TypeMap get_TypeSubstitution();
    internal sealed virtual bool get_IsComImport();
    internal sealed virtual NamedTypeSymbol get_ComImportCoClass();
    internal sealed virtual bool get_ShouldAddWinRTMembers();
    internal sealed virtual bool get_IsWindowsRuntimeImport();
    internal sealed virtual TypeLayout get_Layout();
    internal virtual CharSet get_MarshallingCharSet();
    internal sealed virtual bool get_IsSerializable();
    internal sealed virtual bool get_HasDeclarativeSecurity();
    internal sealed virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal sealed virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual AttributeUsageInfo GetAttributeUsageInfo();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedNestedErrorTypeSymbol : SubstitutedErrorTypeSymbol {
    private NamedTypeSymbol _containingSymbol;
    private ImmutableArray`1<TypeParameterSymbol> _typeParameters;
    private TypeMap _map;
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    internal ImmutableArray`1<TypeSymbol> TypeArgumentsNoUseSiteDiagnostics { get; }
    internal bool HasTypeArgumentsCustomModifiers { get; }
    internal ImmutableArray`1<ImmutableArray`1<CustomModifier>> TypeArgumentsCustomModifiers { get; }
    public NamedTypeSymbol ConstructedFrom { get; }
    public Symbol ContainingSymbol { get; }
    internal TypeMap TypeSubstitution { get; }
    public SubstitutedNestedErrorTypeSymbol(NamedTypeSymbol containingSymbol, ErrorTypeSymbol originalDefinition);
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal virtual ImmutableArray`1<TypeSymbol> get_TypeArgumentsNoUseSiteDiagnostics();
    internal virtual bool get_HasTypeArgumentsCustomModifiers();
    internal virtual ImmutableArray`1<ImmutableArray`1<CustomModifier>> get_TypeArgumentsCustomModifiers();
    public virtual NamedTypeSymbol get_ConstructedFrom();
    public virtual Symbol get_ContainingSymbol();
    internal virtual TypeMap get_TypeSubstitution();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedNestedTypeSymbol : SubstitutedNamedTypeSymbol {
    internal ImmutableArray`1<TypeSymbol> TypeArgumentsNoUseSiteDiagnostics { get; }
    internal bool HasTypeArgumentsCustomModifiers { get; }
    internal ImmutableArray`1<ImmutableArray`1<CustomModifier>> TypeArgumentsCustomModifiers { get; }
    public NamedTypeSymbol ConstructedFrom { get; }
    internal SubstitutedNestedTypeSymbol(SubstitutedNamedTypeSymbol newContainer, NamedTypeSymbol originalDefinition);
    internal virtual ImmutableArray`1<TypeSymbol> get_TypeArgumentsNoUseSiteDiagnostics();
    internal virtual bool get_HasTypeArgumentsCustomModifiers();
    internal virtual ImmutableArray`1<ImmutableArray`1<CustomModifier>> get_TypeArgumentsCustomModifiers();
    public virtual NamedTypeSymbol get_ConstructedFrom();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedParameterSymbol : WrappedParameterSymbol {
    private object _mapOrType;
    private Symbol _containingSymbol;
    public ParameterSymbol OriginalDefinition { get; }
    public Symbol ContainingSymbol { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    internal SubstitutedParameterSymbol(MethodSymbol containingSymbol, TypeMap map, ParameterSymbol originalParameter);
    internal SubstitutedParameterSymbol(PropertySymbol containingSymbol, TypeMap map, ParameterSymbol originalParameter);
    private SubstitutedParameterSymbol(Symbol containingSymbol, TypeMap map, ParameterSymbol originalParameter);
    public virtual ParameterSymbol get_OriginalDefinition();
    public virtual Symbol get_ContainingSymbol();
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedPropertySymbol : PropertySymbol {
    private PropertySymbol _originalDefinition;
    private SubstitutedNamedTypeSymbol _containingType;
    private TypeSymbol _lazyType;
    private ImmutableArray`1<ParameterSymbol> _lazyParameters;
    private ImmutableArray`1<PropertySymbol> _lazyExplicitInterfaceImplementations;
    private OverriddenOrHiddenMembersResult _lazyOverriddenOrHiddenMembers;
    public TypeSymbol Type { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public PropertySymbol OriginalDefinition { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsStatic { get; }
    public bool IsExtern { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsImplicitlyDeclared { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public bool IsIndexer { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public MethodSymbol GetMethod { get; }
    public MethodSymbol SetMethod { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<PropertySymbol> ExplicitInterfaceImplementations { get; }
    internal CallingConvention CallingConvention { get; }
    internal bool MustCallMethodsDirectly { get; }
    public Accessibility DeclaredAccessibility { get; }
    internal OverriddenOrHiddenMembersResult OverriddenOrHiddenMembers { get; }
    public string MetadataName { get; }
    internal SubstitutedPropertySymbol(SubstitutedNamedTypeSymbol containingType, PropertySymbol originalDefinition);
    public virtual TypeSymbol get_Type();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual PropertySymbol get_OriginalDefinition();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    public virtual bool get_IsStatic();
    public virtual bool get_IsExtern();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual bool get_IsIndexer();
    public virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual MethodSymbol get_GetMethod();
    public virtual MethodSymbol get_SetMethod();
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public virtual ImmutableArray`1<PropertySymbol> get_ExplicitInterfaceImplementations();
    internal virtual CallingConvention get_CallingConvention();
    internal virtual bool get_MustCallMethodsDirectly();
    public virtual Accessibility get_DeclaredAccessibility();
    internal virtual OverriddenOrHiddenMembersResult get_OverriddenOrHiddenMembers();
    private ImmutableArray`1<ParameterSymbol> SubstituteParameters();
    public virtual string get_MetadataName();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedTypeParameterSymbol : TypeParameterSymbol {
    private Symbol _container;
    private TypeMap _map;
    private TypeParameterSymbol _substitutedFrom;
    private static Func`2<TypeSymbol, bool> s_isNotObjectFunc;
    public TypeParameterKind TypeParameterKind { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public TypeParameterSymbol OriginalDefinition { get; }
    public TypeParameterSymbol ReducedFrom { get; }
    public bool HasConstructorConstraint { get; }
    public int Ordinal { get; }
    public VarianceKind Variance { get; }
    public bool HasValueTypeConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public string Name { get; }
    public bool IsImplicitlyDeclared { get; }
    internal SubstitutedTypeParameterSymbol(Symbol newContainer, TypeMap map, TypeParameterSymbol substitutedFrom);
    private static SubstitutedTypeParameterSymbol();
    public virtual TypeParameterKind get_TypeParameterKind();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual TypeParameterSymbol get_OriginalDefinition();
    public virtual TypeParameterSymbol get_ReducedFrom();
    public virtual bool get_HasConstructorConstraint();
    public virtual int get_Ordinal();
    public virtual VarianceKind get_Variance();
    public virtual bool get_HasValueTypeConstraint();
    public virtual bool get_HasReferenceTypeConstraint();
    public virtual string get_Name();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal virtual void EnsureAllConstraintsAreResolved();
    internal virtual ImmutableArray`1<TypeSymbol> GetConstraintTypes(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetInterfaces(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual NamedTypeSymbol GetEffectiveBaseClass(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual TypeSymbol GetDeducedBaseType(ConsList`1<TypeParameterSymbol> inProgress);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SymbolCompletionState : ValueType {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _completeParts;
    internal int IncompleteParts { get; }
    internal CompletionPart NextIncompletePart { get; }
    internal int get_IncompleteParts();
    internal void DefaultForceComplete(Symbol symbol);
    internal bool HasComplete(CompletionPart part);
    internal bool NotePartComplete(CompletionPart part);
    internal CompletionPart get_NextIncompletePart();
    internal static bool HasAtMostOneBitSet(int bits);
    internal void SpinWaitComplete(CompletionPart part, CancellationToken cancellationToken);
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions : object {
    private static Func`4<TypeSymbol, Symbol, bool, bool> s_hasInvalidTypeParameterFunc;
    private static SymbolExtensions();
    [ExtensionAttribute]
internal static bool HasParamsParameter(Symbol member);
    [ExtensionAttribute]
internal static ImmutableArray`1<ParameterSymbol> GetParameters(Symbol member);
    [ExtensionAttribute]
internal static ImmutableArray`1<TypeSymbol> GetParameterTypes(Symbol member);
    [ExtensionAttribute]
internal static bool GetIsVararg(Symbol member);
    [ExtensionAttribute]
internal static ImmutableArray`1<RefKind> GetParameterRefKinds(Symbol member);
    [ExtensionAttribute]
internal static int GetParameterCount(Symbol member);
    [ExtensionAttribute]
internal static bool HasUnsafeParameter(Symbol member);
    [ExtensionAttribute]
public static bool IsAccessor(MethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsAccessor(Symbol symbol);
    [ExtensionAttribute]
public static bool IsIndexedPropertyAccessor(MethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsOperator(MethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsOperator(Symbol symbol);
    [ExtensionAttribute]
public static bool IsIndexer(Symbol symbol);
    [ExtensionAttribute]
public static bool IsIndexedProperty(Symbol symbol);
    [ExtensionAttribute]
public static bool IsUserDefinedConversion(Symbol symbol);
    [ExtensionAttribute]
public static int CustomModifierCount(MethodSymbol method);
    [ExtensionAttribute]
public static int CustomModifierCount(Symbol m);
    [ExtensionAttribute]
public static int CustomModifierCount(EventSymbol e);
    [ExtensionAttribute]
public static int CustomModifierCount(PropertySymbol property);
    [ExtensionAttribute]
internal static Symbol SymbolAsMember(Symbol s, NamedTypeSymbol newOwner);
    [ExtensionAttribute]
internal static int GetMemberArity(Symbol symbol);
    [ExtensionAttribute]
internal static NamespaceOrTypeSymbol OfMinimalArity(IEnumerable`1<NamespaceOrTypeSymbol> symbols);
    [ExtensionAttribute]
internal static ImmutableArray`1<TypeParameterSymbol> GetMemberTypeParameters(Symbol symbol);
    [ExtensionAttribute]
internal static ImmutableArray`1<TypeSymbol> GetMemberTypeArgumentsNoUseSiteDiagnostics(Symbol symbol);
    [ExtensionAttribute]
internal static bool IsParameterlessConstructor(MethodSymbol method);
    [ExtensionAttribute]
internal static bool IsDefaultValueTypeConstructor(MethodSymbol method);
    [ExtensionAttribute]
internal static MethodSymbol GetOwnOrInheritedAddMethod(EventSymbol event);
    [ExtensionAttribute]
internal static MethodSymbol GetOwnOrInheritedRemoveMethod(EventSymbol event);
    [ExtensionAttribute]
internal static bool IsExplicitInterfaceImplementation(Symbol member);
    [ExtensionAttribute]
internal static bool IsPartialMethod(Symbol member);
    [ExtensionAttribute]
internal static bool IsPartialImplementation(Symbol member);
    [ExtensionAttribute]
internal static bool IsPartialDefinition(Symbol member);
    [ExtensionAttribute]
internal static ImmutableArray`1<Symbol> GetExplicitInterfaceImplementations(Symbol member);
    [ExtensionAttribute]
internal static TypeSymbol GetTypeOrReturnType(Symbol member);
    [ExtensionAttribute]
internal static void GetTypeOrReturnType(Symbol member, TypeSymbol& returnType, ImmutableArray`1& returnTypeCustomModifiers);
    [ExtensionAttribute]
internal static Symbol GetOverriddenMember(Symbol member);
    [ExtensionAttribute]
internal static Symbol GetLeastOverriddenMember(Symbol member, NamedTypeSymbol accessingTypeOpt);
    [ExtensionAttribute]
internal static bool IsFieldOrFieldLikeEvent(Symbol member, FieldSymbol& field);
    [ExtensionAttribute]
internal static string GetMemberCallerName(Symbol member);
    [ExtensionAttribute]
public static bool IsCompilationOutputWinMdObj(Symbol symbol);
    [ExtensionAttribute]
public static NamedTypeSymbol ConstructIfGeneric(NamedTypeSymbol type, ImmutableArray`1<TypeWithModifiers> typeArguments);
    [ExtensionAttribute]
public static bool IsNestedType(Symbol symbol);
    [ExtensionAttribute]
public static bool Any(ImmutableArray`1<T> array, SymbolKind kind);
    [ExtensionAttribute]
public static bool IsAccessibleViaInheritance(TypeSymbol superType, TypeSymbol subType, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
public static bool IsNoMoreVisibleThan(Symbol symbol, TypeSymbol type, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
public static LocalizableErrorArgument GetKindText(Symbol symbol);
    [ExtensionAttribute]
internal static NamespaceOrTypeSymbol ContainingNamespaceOrType(Symbol symbol);
    [ExtensionAttribute]
internal static Symbol ContainingNonLambdaMember(Symbol containingMember);
    [ExtensionAttribute]
internal static ParameterSymbol EnclosingThisSymbol(Symbol containingMember);
    [ExtensionAttribute]
public static Symbol ConstructedFrom(Symbol symbol);
    [ExtensionAttribute]
public static bool IsContainingSymbolOfAllTypeParameters(Symbol containingSymbol, TypeSymbol type);
    [ExtensionAttribute]
public static bool IsContainingSymbolOfAllTypeParameters(Symbol containingSymbol, ImmutableArray`1<TypeSymbol> types);
    private static bool HasInvalidTypeParameter(TypeSymbol type, Symbol containingSymbol);
    [ExtensionAttribute]
public static bool IsTypeOrTypeAlias(Symbol symbol);
    [ExtensionAttribute]
internal static bool CompilationAllowsUnsafe(Symbol symbol);
    [ExtensionAttribute]
internal static void CheckUnsafeModifier(Symbol symbol, DeclarationModifiers modifiers, DiagnosticBag diagnostics);
    [ExtensionAttribute]
internal static void CheckUnsafeModifier(Symbol symbol, DeclarationModifiers modifiers, Location errorLocation, DiagnosticBag diagnostics);
    [ExtensionAttribute]
public static bool MustCallMethodsDirectly(Symbol symbol);
    [ExtensionAttribute]
public static int GetArity(Symbol symbol);
    [ExtensionAttribute]
internal static CSharpSyntaxNode GetNonNullSyntaxNode(Symbol symbol);
    [ExtensionAttribute]
internal static TDestination EnsureCSharpSymbolOrNull(TSource symbol, string paramName);
    [ExtensionAttribute]
internal static ImmutableArray`1<TypeSymbol> ToTypes(ImmutableArray`1<TypeWithModifiers> typesWithModifiers, Boolean& hasModifiers);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAccessorValueParameterSymbol : SourceComplexParameterSymbol {
    private ImmutableArray`1<CustomModifier> _customModifiers;
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    public bool IsImplicitlyDeclared { get; }
    protected IAttributeTargetSymbol AttributeOwner { get; }
    public SynthesizedAccessorValueParameterSymbol(SourceMethodSymbol accessor, TypeSymbol paramType, int ordinal, ImmutableArray`1<CustomModifier> customModifiers);
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    internal virtual ushort get_CountOfCustomModifiersPrecedingByRef();
    public virtual bool get_IsImplicitlyDeclared();
    protected virtual IAttributeTargetSymbol get_AttributeOwner();
    internal virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAttributeData : SourceAttributeData {
    internal SynthesizedAttributeData(MethodSymbol wellKnownMember, ImmutableArray`1<TypedConstant> arguments, ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArguments);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedBackingFieldSymbol : SynthesizedFieldSymbolBase {
    private SourcePropertySymbol _property;
    private bool _hasInitializer;
    public bool HasInitializer { get; }
    public Symbol AssociatedSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    internal bool SuppressDynamicAttribute { get; }
    internal bool HasPointerType { get; }
    public SynthesizedBackingFieldSymbol(SourcePropertySymbol property, string name, bool isReadOnly, bool isStatic, bool hasInitializer);
    public bool get_HasInitializer();
    public virtual Symbol get_AssociatedSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    internal virtual bool get_SuppressDynamicAttribute();
    internal virtual TypeSymbol GetFieldType(ConsList`1<FieldSymbol> fieldsBeingBound);
    internal virtual bool get_HasPointerType();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedContainer : NamedTypeSymbol {
    private string _name;
    private TypeMap _typeMap;
    private ImmutableArray`1<TypeParameterSymbol> _typeParameters;
    internal TypeMap TypeMap { get; }
    internal MethodSymbol Constructor { get; }
    internal bool IsInterface { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public string Name { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public NamedTypeSymbol ConstructedFrom { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    internal ImmutableArray`1<TypeSymbol> TypeArgumentsNoUseSiteDiagnostics { get; }
    internal bool HasTypeArgumentsCustomModifiers { get; }
    internal ImmutableArray`1<ImmutableArray`1<CustomModifier>> TypeArgumentsCustomModifiers { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    public bool MightContainExtensionMethods { get; }
    public int Arity { get; }
    internal bool MangleName { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool ShouldAddWinRTMembers { get; }
    internal bool IsWindowsRuntimeImport { get; }
    internal bool IsComImport { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal CharSet MarshallingCharSet { get; }
    internal bool IsSerializable { get; }
    internal TypeLayout Layout { get; }
    internal bool HasSpecialName { get; }
    protected SynthesizedContainer(string name, int parameterCount, bool returnsVoid);
    protected SynthesizedContainer(string name, MethodSymbol topLevelMethod);
    protected SynthesizedContainer(string name, ImmutableArray`1<TypeParameterSymbol> typeParameters, TypeMap typeMap);
    private ImmutableArray`1<TypeParameterSymbol> CreateTypeParameters(int parameterCount, bool returnsVoid);
    internal TypeMap get_TypeMap();
    internal virtual MethodSymbol get_Constructor();
    internal sealed virtual bool get_IsInterface();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    public sealed virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public sealed virtual string get_Name();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual NamedTypeSymbol get_ConstructedFrom();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAbstract();
    internal virtual ImmutableArray`1<TypeSymbol> get_TypeArgumentsNoUseSiteDiagnostics();
    internal virtual bool get_HasTypeArgumentsCustomModifiers();
    internal virtual ImmutableArray`1<ImmutableArray`1<CustomModifier>> get_TypeArgumentsCustomModifiers();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedContainer/<GetFieldsToEmit>d__38")]
internal virtual IEnumerable`1<FieldSymbol> GetFieldsToEmit();
    internal virtual ImmutableArray`1<Symbol> GetEarlyAttributeDecodingMembers();
    internal virtual ImmutableArray`1<Symbol> GetEarlyAttributeDecodingMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsStatic();
    internal virtual ImmutableArray`1<NamedTypeSymbol> InterfacesNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetInterfacesToEmit();
    internal virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
    internal virtual NamedTypeSymbol GetDeclaredBaseType(ConsList`1<Symbol> basesBeingResolved);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved);
    public virtual bool get_MightContainExtensionMethods();
    public virtual int get_Arity();
    internal virtual bool get_MangleName();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual bool get_ShouldAddWinRTMembers();
    internal virtual bool get_IsWindowsRuntimeImport();
    internal virtual bool get_IsComImport();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal sealed virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual CharSet get_MarshallingCharSet();
    internal virtual bool get_IsSerializable();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual AttributeUsageInfo GetAttributeUsageInfo();
    internal virtual TypeLayout get_Layout();
    internal virtual bool get_HasSpecialName();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedDelegateSymbol : SynthesizedContainer {
    private NamespaceOrTypeSymbol _containingSymbol;
    private MethodSymbol _constructor;
    private MethodSymbol _invoke;
    public Symbol ContainingSymbol { get; }
    public TypeKind TypeKind { get; }
    internal MethodSymbol Constructor { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsSealed { get; }
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    public SynthesizedDelegateSymbol(NamespaceOrTypeSymbol containingSymbol, string name, TypeSymbol objectType, TypeSymbol intPtrType, TypeSymbol voidReturnTypeOpt, int parameterCount, BitVector byRefParameters);
    public virtual Symbol get_ContainingSymbol();
    public virtual TypeKind get_TypeKind();
    internal virtual MethodSymbol get_Constructor();
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsSealed();
    internal virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedEntryPointSymbol : MethodSymbol {
    internal static string MainName;
    internal static string FactoryName;
    private NamedTypeSymbol _containingType;
    private TypeSymbol _returnType;
    internal bool GenerateDebugInfo { get; }
    public Symbol ContainingSymbol { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool RequiresSecurityObject { get; }
    public bool IsVararg { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public Symbol AssociatedSymbol { get; }
    public int Arity { get; }
    public bool ReturnsVoid { get; }
    public MethodKind MethodKind { get; }
    public bool IsExtern { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public bool IsOverride { get; }
    public bool IsVirtual { get; }
    public bool IsStatic { get; }
    public bool IsAsync { get; }
    public bool HidesBaseMethodsByName { get; }
    public bool IsExtensionMethod { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal CallingConvention CallingConvention { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    internal bool IsMetadataFinal { get; }
    public bool IsImplicitlyDeclared { get; }
    internal MarshalPseudoCustomAttributeData ReturnValueMarshallingInformation { get; }
    internal bool HasDeclarativeSecurity { get; }
    private SynthesizedEntryPointSymbol(NamedTypeSymbol containingType, TypeSymbol returnType);
    internal static SynthesizedEntryPointSymbol Create(SynthesizedInteractiveInitializerMethod initializerMethod, DiagnosticBag diagnostics);
    internal virtual bool get_GenerateDebugInfo();
    internal abstract virtual BoundBlock CreateBody();
    public virtual Symbol get_ContainingSymbol();
    public abstract virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    internal virtual bool get_RequiresSecurityObject();
    public virtual bool get_IsVararg();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual Symbol get_AssociatedSymbol();
    public virtual int get_Arity();
    public virtual bool get_ReturnsVoid();
    public virtual MethodKind get_MethodKind();
    public virtual bool get_IsExtern();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsOverride();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsStatic();
    public virtual bool get_IsAsync();
    public virtual bool get_HidesBaseMethodsByName();
    public virtual bool get_IsExtensionMethod();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual CallingConvention get_CallingConvention();
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    internal sealed virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal sealed virtual bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_IsMetadataFinal();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual DllImportData GetDllImportData();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnValueMarshallingInformation();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal sealed virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    private CSharpSyntaxNode GetSyntax();
    private static void ReportUseSiteDiagnostics(Symbol symbol, DiagnosticBag diagnostics);
    private static MethodSymbol GetRequiredMethod(TypeSymbol type, string methodName, DiagnosticBag diagnostics);
    private static BoundCall CreateParameterlessCall(CSharpSyntaxNode syntax, BoundExpression receiver, MethodSymbol method);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedEnumValueFieldSymbol : SynthesizedFieldSymbolBase {
    internal bool SuppressDynamicAttribute { get; }
    public SynthesizedEnumValueFieldSymbol(SourceNamedTypeSymbol containingEnum);
    internal virtual bool get_SuppressDynamicAttribute();
    internal virtual TypeSymbol GetFieldType(ConsList`1<FieldSymbol> fieldsBeingBound);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedExplicitImplementationForwardingMethod : SynthesizedImplementationMethod {
    private MethodSymbol _implementingMethod;
    internal bool SynthesizesLoweredBoundBody { get; }
    public MethodSymbol ImplementingMethod { get; }
    public MethodKind MethodKind { get; }
    public SynthesizedExplicitImplementationForwardingMethod(MethodSymbol interfaceMethod, MethodSymbol implementingMethod, NamedTypeSymbol implementingType);
    internal virtual bool get_SynthesizesLoweredBoundBody();
    internal virtual void GenerateMethodBody(TypeCompilationState compilationState, DiagnosticBag diagnostics);
    public MethodSymbol get_ImplementingMethod();
    public virtual MethodKind get_MethodKind();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedFieldLikeEventAccessorSymbol : SourceEventAccessorSymbol {
    private object _methodChecksLockObject;
    private string _name;
    public string Name { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool GenerateDebugInfo { get; }
    protected SourceMethodSymbol BoundAttributesSource { get; }
    protected IAttributeTargetSymbol AttributeOwner { get; }
    protected object MethodChecksLockObject { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal SynthesizedFieldLikeEventAccessorSymbol(SourceFieldLikeEventSymbol event, bool isAdder);
    public virtual string get_Name();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual bool get_GenerateDebugInfo();
    protected virtual SourceMethodSymbol get_BoundAttributesSource();
    protected virtual IAttributeTargetSymbol get_AttributeOwner();
    internal virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    protected virtual object get_MethodChecksLockObject();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedFieldSymbol : SynthesizedFieldSymbolBase {
    private TypeSymbol _type;
    internal bool SuppressDynamicAttribute { get; }
    public SynthesizedFieldSymbol(NamedTypeSymbol containingType, TypeSymbol type, string name, bool isPublic, bool isReadOnly, bool isStatic);
    internal virtual bool get_SuppressDynamicAttribute();
    internal virtual TypeSymbol GetFieldType(ConsList`1<FieldSymbol> fieldsBeingBound);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedFieldSymbolBase : FieldSymbol {
    private NamedTypeSymbol _containingType;
    private string _name;
    private DeclarationModifiers _modifiers;
    internal bool SuppressDynamicAttribute { get; }
    public string Name { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public Symbol AssociatedSymbol { get; }
    public bool IsReadOnly { get; }
    public bool IsVolatile { get; }
    public bool IsConst { get; }
    internal bool IsNotSerialized { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal Nullable`1<int> TypeLayoutOffset { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    internal bool HasSpecialName { get; }
    internal bool HasRuntimeSpecialName { get; }
    public bool IsImplicitlyDeclared { get; }
    public SynthesizedFieldSymbolBase(NamedTypeSymbol containingType, string name, bool isPublic, bool isReadOnly, bool isStatic);
    internal abstract virtual bool get_SuppressDynamicAttribute();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal abstract virtual TypeSymbol GetFieldType(ConsList`1<FieldSymbol> fieldsBeingBound);
    public virtual string get_Name();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual Symbol get_AssociatedSymbol();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsVolatile();
    public virtual bool get_IsConst();
    internal virtual bool get_IsNotSerialized();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual Nullable`1<int> get_TypeLayoutOffset();
    internal virtual ConstantValue GetConstantValue(ConstantFieldsInProgress inProgress, bool earlyDecodingWellKnownAttributes);
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsStatic();
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_HasRuntimeSpecialName();
    public virtual bool get_IsImplicitlyDeclared();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedGlobalMethodSymbol : MethodSymbol {
    private ModuleSymbol _containingModule;
    private PrivateImplementationDetails _privateImplType;
    private TypeSymbol _returnType;
    private ImmutableArray`1<ParameterSymbol> _parameters;
    private string _name;
    public bool IsImplicitlyDeclared { get; }
    internal bool GenerateDebugInfo { get; }
    internal ModuleSymbol ContainingModule { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    internal PrivateImplementationDetails ContainingPrivateImplementationDetailsType { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool RequiresSecurityObject { get; }
    internal MarshalPseudoCustomAttributeData ReturnValueMarshallingInformation { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public bool IsVararg { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public Symbol AssociatedSymbol { get; }
    public int Arity { get; }
    public bool ReturnsVoid { get; }
    public MethodKind MethodKind { get; }
    public bool IsExtern { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public bool IsOverride { get; }
    public bool IsVirtual { get; }
    public bool IsStatic { get; }
    public bool IsAsync { get; }
    public bool HidesBaseMethodsByName { get; }
    internal bool IsMetadataFinal { get; }
    public bool IsExtensionMethod { get; }
    internal CallingConvention CallingConvention { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    internal bool SynthesizesLoweredBoundBody { get; }
    internal SynthesizedGlobalMethodSymbol(ModuleSymbol containingModule, PrivateImplementationDetails privateImplType, TypeSymbol returnType, string name);
    protected void SetParameters(ImmutableArray`1<ParameterSymbol> parameters);
    public sealed virtual bool get_IsImplicitlyDeclared();
    internal sealed virtual bool get_GenerateDebugInfo();
    internal sealed virtual ModuleSymbol get_ContainingModule();
    public sealed virtual AssemblySymbol get_ContainingAssembly();
    public sealed virtual Symbol get_ContainingSymbol();
    public sealed virtual NamedTypeSymbol get_ContainingType();
    internal PrivateImplementationDetails get_ContainingPrivateImplementationDetailsType();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    internal virtual bool get_RequiresSecurityObject();
    public virtual DllImportData GetDllImportData();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnValueMarshallingInformation();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal sealed virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    public virtual bool get_IsVararg();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual Symbol get_AssociatedSymbol();
    public virtual int get_Arity();
    public virtual bool get_ReturnsVoid();
    public virtual MethodKind get_MethodKind();
    public virtual bool get_IsExtern();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsOverride();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsStatic();
    public virtual bool get_IsAsync();
    public virtual bool get_HidesBaseMethodsByName();
    internal sealed virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal sealed virtual bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_IsMetadataFinal();
    public virtual bool get_IsExtensionMethod();
    internal virtual CallingConvention get_CallingConvention();
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    internal virtual bool get_SynthesizesLoweredBoundBody();
    internal abstract virtual void GenerateMethodBody(TypeCompilationState compilationState, DiagnosticBag diagnostics);
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedImplementationMethod : SynthesizedInstanceMethodSymbol {
    private MethodSymbol _interfaceMethod;
    private NamedTypeSymbol _implementingType;
    private bool _generateDebugInfo;
    private PropertySymbol _associatedProperty;
    private ImmutableArray`1<MethodSymbol> _explicitInterfaceImplementations;
    private ImmutableArray`1<TypeParameterSymbol> _typeParameters;
    private TypeSymbol _returnType;
    private ImmutableArray`1<ParameterSymbol> _parameters;
    private string _name;
    public bool IsVararg { get; }
    public int Arity { get; }
    public bool ReturnsVoid { get; }
    internal CallingConvention CallingConvention { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    internal bool GenerateDebugInfo { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public MethodKind MethodKind { get; }
    public Accessibility DeclaredAccessibility { get; }
    public Symbol AssociatedSymbol { get; }
    public bool HidesBaseMethodsByName { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public bool IsStatic { get; }
    public bool IsAsync { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    public bool IsExtensionMethod { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool RequiresSecurityObject { get; }
    internal bool IsMetadataFinal { get; }
    internal MarshalPseudoCustomAttributeData ReturnValueMarshallingInformation { get; }
    internal bool HasDeclarativeSecurity { get; }
    public SynthesizedImplementationMethod(MethodSymbol interfaceMethod, NamedTypeSymbol implementingType, string name, bool generateDebugInfo, PropertySymbol associatedProperty);
    public sealed virtual bool get_IsVararg();
    public sealed virtual int get_Arity();
    public sealed virtual bool get_ReturnsVoid();
    internal sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal sealed virtual bool get_GenerateDebugInfo();
    public sealed virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public sealed virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public sealed virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual MethodKind get_MethodKind();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual Symbol get_AssociatedSymbol();
    public virtual bool get_HidesBaseMethodsByName();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual bool get_IsStatic();
    public virtual bool get_IsAsync();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsExtern();
    public virtual bool get_IsExtensionMethod();
    public virtual string get_Name();
    internal sealed virtual bool get_HasSpecialName();
    internal sealed virtual MethodImplAttributes get_ImplementationAttributes();
    internal sealed virtual bool get_RequiresSecurityObject();
    internal sealed virtual bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_IsMetadataFinal();
    internal sealed virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    public virtual DllImportData GetDllImportData();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnValueMarshallingInformation();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedInstanceConstructor : SynthesizedInstanceMethodSymbol {
    private NamedTypeSymbol _containingType;
    internal bool GenerateDebugInfo { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public Accessibility DeclaredAccessibility { get; }
    internal bool IsMetadataFinal { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool RequiresSecurityObject { get; }
    internal MarshalPseudoCustomAttributeData ReturnValueMarshallingInformation { get; }
    internal bool HasDeclarativeSecurity { get; }
    public bool IsVararg { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public Symbol AssociatedSymbol { get; }
    public int Arity { get; }
    public bool ReturnsVoid { get; }
    public MethodKind MethodKind { get; }
    public bool IsExtern { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public bool IsOverride { get; }
    public bool IsVirtual { get; }
    public bool IsStatic { get; }
    public bool IsAsync { get; }
    public bool HidesBaseMethodsByName { get; }
    public bool IsExtensionMethod { get; }
    internal CallingConvention CallingConvention { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    internal SynthesizedInstanceConstructor(NamedTypeSymbol containingType);
    internal virtual bool get_GenerateDebugInfo();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual Accessibility get_DeclaredAccessibility();
    internal virtual bool get_IsMetadataFinal();
    public sealed virtual Symbol get_ContainingSymbol();
    public sealed virtual NamedTypeSymbol get_ContainingType();
    public sealed virtual string get_Name();
    internal sealed virtual bool get_HasSpecialName();
    internal sealed virtual MethodImplAttributes get_ImplementationAttributes();
    internal sealed virtual bool get_RequiresSecurityObject();
    public sealed virtual DllImportData GetDllImportData();
    internal sealed virtual MarshalPseudoCustomAttributeData get_ReturnValueMarshallingInformation();
    internal sealed virtual bool get_HasDeclarativeSecurity();
    internal sealed virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal sealed virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    public sealed virtual bool get_IsVararg();
    public sealed virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal sealed virtual LexicalSortKey GetLexicalSortKey();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public sealed virtual TypeSymbol get_ReturnType();
    public sealed virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public sealed virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public sealed virtual Symbol get_AssociatedSymbol();
    public sealed virtual int get_Arity();
    public sealed virtual bool get_ReturnsVoid();
    public sealed virtual MethodKind get_MethodKind();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAsync();
    public sealed virtual bool get_HidesBaseMethodsByName();
    internal sealed virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal sealed virtual bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges);
    public sealed virtual bool get_IsExtensionMethod();
    internal sealed virtual CallingConvention get_CallingConvention();
    internal sealed virtual bool get_IsExplicitInterfaceImplementation();
    public sealed virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    internal sealed virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedInstanceMethodSymbol : MethodSymbol {
    private ParameterSymbol _lazyThisParameter;
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsImplicitlyDeclared { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public sealed virtual bool get_IsImplicitlyDeclared();
    internal virtual bool TryGetThisParameter(ParameterSymbol& thisParameter);
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedInteractiveInitializerMethod : SynthesizedInstanceMethodSymbol {
    internal static string InitializerName;
    private SourceMemberContainerTypeSymbol _containingType;
    private TypeSymbol _resultType;
    private TypeSymbol _returnType;
    public string Name { get; }
    internal bool IsScriptInitializer { get; }
    public int Arity { get; }
    public Symbol AssociatedSymbol { get; }
    public Symbol ContainingSymbol { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public bool HidesBaseMethodsByName { get; }
    public bool IsAbstract { get; }
    public bool IsAsync { get; }
    public bool IsExtensionMethod { get; }
    public bool IsExtern { get; }
    public bool IsOverride { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public bool IsVararg { get; }
    public bool IsVirtual { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public MethodKind MethodKind { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public bool ReturnsVoid { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    internal CallingConvention CallingConvention { get; }
    internal bool GenerateDebugInfo { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal bool HasSpecialName { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool RequiresSecurityObject { get; }
    internal MarshalPseudoCustomAttributeData ReturnValueMarshallingInformation { get; }
    internal TypeSymbol ResultType { get; }
    internal SynthesizedInteractiveInitializerMethod(SourceMemberContainerTypeSymbol containingType, DiagnosticBag diagnostics);
    public virtual string get_Name();
    internal virtual bool get_IsScriptInitializer();
    public virtual int get_Arity();
    public virtual Symbol get_AssociatedSymbol();
    public virtual Symbol get_ContainingSymbol();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual bool get_HidesBaseMethodsByName();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsAsync();
    public virtual bool get_IsExtensionMethod();
    public virtual bool get_IsExtern();
    public virtual bool get_IsOverride();
    public virtual bool get_IsSealed();
    public virtual bool get_IsStatic();
    public virtual bool get_IsVararg();
    public virtual bool get_IsVirtual();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual MethodKind get_MethodKind();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual bool get_ReturnsVoid();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal virtual CallingConvention get_CallingConvention();
    internal virtual bool get_GenerateDebugInfo();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual bool get_HasSpecialName();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    internal virtual bool get_RequiresSecurityObject();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnValueMarshallingInformation();
    public virtual DllImportData GetDllImportData();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal virtual bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges);
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    internal TypeSymbol get_ResultType();
    private static void CalculateReturnType(CSharpCompilation compilation, DiagnosticBag diagnostics, TypeSymbol& resultType, TypeSymbol& returnType);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedIntrinsicOperatorSymbol : MethodSymbol {
    private TypeSymbol _containingType;
    private string _name;
    private ImmutableArray`1<ParameterSymbol> _parameters;
    private TypeSymbol _returnType;
    private bool _isCheckedBuiltin;
    public string Name { get; }
    public bool IsCheckedBuiltin { get; }
    public MethodKind MethodKind { get; }
    public bool IsImplicitlyDeclared { get; }
    internal CSharpCompilation DeclaringCompilation { get; }
    internal bool IsMetadataFinal { get; }
    public int Arity { get; }
    public bool IsExtensionMethod { get; }
    internal bool HasSpecialName { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal MarshalPseudoCustomAttributeData ReturnValueMarshallingInformation { get; }
    internal bool RequiresSecurityObject { get; }
    public bool HidesBaseMethodsByName { get; }
    public bool IsVararg { get; }
    public bool ReturnsVoid { get; }
    public bool IsAsync { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public Symbol AssociatedSymbol { get; }
    internal CallingConvention CallingConvention { get; }
    internal bool GenerateDebugInfo { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public SynthesizedIntrinsicOperatorSymbol(TypeSymbol leftType, string name, TypeSymbol rightType, TypeSymbol returnType, bool isCheckedBuiltin);
    public SynthesizedIntrinsicOperatorSymbol(TypeSymbol container, string name, TypeSymbol returnType, bool isCheckedBuiltin);
    public virtual string get_Name();
    public virtual bool get_IsCheckedBuiltin();
    public virtual MethodKind get_MethodKind();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual CSharpCompilation get_DeclaringCompilation();
    public virtual string GetDocumentationCommentId();
    internal virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal virtual bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_IsMetadataFinal();
    public virtual int get_Arity();
    public virtual bool get_IsExtensionMethod();
    internal virtual bool get_HasSpecialName();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    internal virtual bool get_HasDeclarativeSecurity();
    public virtual DllImportData GetDllImportData();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnValueMarshallingInformation();
    internal virtual bool get_RequiresSecurityObject();
    public virtual bool get_HidesBaseMethodsByName();
    public virtual bool get_IsVararg();
    public virtual bool get_ReturnsVoid();
    public virtual bool get_IsAsync();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual Symbol get_AssociatedSymbol();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual CallingConvention get_CallingConvention();
    internal virtual bool get_GenerateDebugInfo();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsStatic();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsExtern();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedLambdaCacheFieldSymbol : SynthesizedFieldSymbolBase {
    private TypeSymbol _type;
    private MethodSymbol _topLevelMethod;
    internal bool SuppressDynamicAttribute { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.Method { get; }
    private bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.HasMethodBodyDependency { get; }
    public SynthesizedLambdaCacheFieldSymbol(NamedTypeSymbol containingType, TypeSymbol type, string name, MethodSymbol topLevelMethod, bool isReadOnly, bool isStatic);
    internal virtual bool get_SuppressDynamicAttribute();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_Method();
    private sealed virtual override bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_HasMethodBodyDependency();
    internal virtual TypeSymbol GetFieldType(ConsList`1<FieldSymbol> fieldsBeingBound);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedLocal : LocalSymbol {
    private MethodSymbol _containingMethodOpt;
    private TypeSymbol _type;
    private SynthesizedLocalKind _kind;
    private SyntaxNode _syntaxOpt;
    private bool _isPinned;
    private RefKind _refKind;
    public SyntaxNode SyntaxOpt { get; }
    internal RefKind RefKind { get; }
    internal bool IsImportedFromMetadata { get; }
    internal LocalDeclarationKind DeclarationKind { get; }
    internal SynthesizedLocalKind SynthesizedKind { get; }
    internal SyntaxToken IdentifierToken { get; }
    public Symbol ContainingSymbol { get; }
    public string Name { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool IsPinned { get; }
    internal bool IsCompilerGenerated { get; }
    internal SynthesizedLocal(MethodSymbol containingMethodOpt, TypeSymbol type, SynthesizedLocalKind kind, SyntaxNode syntaxOpt, bool isPinned, RefKind refKind);
    public SyntaxNode get_SyntaxOpt();
    internal virtual LocalSymbol WithSynthesizedLocalKindAndSyntax(SynthesizedLocalKind kind, SyntaxNode syntax);
    internal virtual RefKind get_RefKind();
    internal virtual bool get_IsImportedFromMetadata();
    internal virtual LocalDeclarationKind get_DeclarationKind();
    internal virtual SynthesizedLocalKind get_SynthesizedKind();
    internal virtual SyntaxToken get_IdentifierToken();
    public virtual Symbol get_ContainingSymbol();
    public virtual string get_Name();
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual SyntaxNode GetDeclaratorSyntax();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual bool get_IsPinned();
    internal virtual bool get_IsCompilerGenerated();
    internal virtual ConstantValue GetConstantValue(SyntaxNode node, LocalSymbol inProgress, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<Diagnostic> GetConstantValueDiagnostics(BoundExpression boundInitValue);
    private string GetDebuggerDisplay();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedMethodBaseSymbol : SourceMethodSymbol {
    protected MethodSymbol BaseMethod;
    [CompilerGeneratedAttribute]
private TypeMap <TypeMap>k__BackingField;
    private string _name;
    private ImmutableArray`1<TypeParameterSymbol> _typeParameters;
    private ImmutableArray`1<ParameterSymbol> _parameters;
    protected TypeMap TypeMap { get; private set; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    internal int ParameterCount { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    protected ImmutableArray`1<ParameterSymbol> BaseMethodParameters { get; }
    public TypeSymbol ReturnType { get; }
    public bool IsVararg { get; }
    public string Name { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool IsExpressionBodied { get; }
    protected SynthesizedMethodBaseSymbol(NamedTypeSymbol containingType, MethodSymbol baseMethod, SyntaxReference syntaxReference, SyntaxReference blockSyntaxReference, Location location, string name, DeclarationModifiers declarationModifiers);
    [CompilerGeneratedAttribute]
protected TypeMap get_TypeMap();
    [CompilerGeneratedAttribute]
private void set_TypeMap(TypeMap value);
    protected void AssignTypeMapAndTypeParameters(TypeMap typeMap, ImmutableArray`1<TypeParameterSymbol> typeParameters);
    protected virtual void MethodChecks(DiagnosticBag diagnostics);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    public sealed virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal virtual int get_ParameterCount();
    public sealed virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    protected virtual ImmutableArray`1<ParameterSymbol> get_BaseMethodParameters();
    private ImmutableArray`1<ParameterSymbol> MakeParameters();
    public sealed virtual TypeSymbol get_ReturnType();
    public sealed virtual bool get_IsVararg();
    public sealed virtual string get_Name();
    public sealed virtual bool get_IsImplicitlyDeclared();
    internal virtual bool get_IsExpressionBodied();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedParameterSymbol : ParameterSymbol {
    private MethodSymbol _container;
    private TypeSymbol _type;
    private int _ordinal;
    private string _name;
    private ImmutableArray`1<CustomModifier> _customModifiers;
    private ushort _countOfCustomModifiersPrecedingByRef;
    private RefKind _refKind;
    public TypeSymbol Type { get; }
    public RefKind RefKind { get; }
    internal bool IsMetadataIn { get; }
    internal bool IsMetadataOut { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    public string Name { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public int Ordinal { get; }
    public bool IsParams { get; }
    internal bool IsMetadataOptional { get; }
    public bool IsImplicitlyDeclared { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerFilePath { get; }
    internal bool IsCallerMemberName { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public SynthesizedParameterSymbol(MethodSymbol container, TypeSymbol type, int ordinal, RefKind refKind, string name, ImmutableArray`1<CustomModifier> customModifiers, ushort countOfCustomModifiersPrecedingByRef);
    public virtual TypeSymbol get_Type();
    public virtual RefKind get_RefKind();
    internal virtual bool get_IsMetadataIn();
    internal virtual bool get_IsMetadataOut();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    public virtual string get_Name();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual int get_Ordinal();
    public virtual bool get_IsParams();
    internal virtual bool get_IsMetadataOptional();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual ConstantValue get_ExplicitDefaultConstantValue();
    internal virtual bool get_IsIDispatchConstant();
    internal virtual bool get_IsIUnknownConstant();
    internal virtual bool get_IsCallerLineNumber();
    internal virtual bool get_IsCallerFilePath();
    internal virtual bool get_IsCallerMemberName();
    internal sealed virtual ushort get_CountOfCustomModifiersPrecedingByRef();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal static ImmutableArray`1<ParameterSymbol> DeriveParameters(MethodSymbol sourceMethod, MethodSymbol destinationMethod);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedSealedPropertyAccessor : SynthesizedInstanceMethodSymbol {
    private PropertySymbol _property;
    private MethodSymbol _overriddenAccessor;
    private ImmutableArray`1<ParameterSymbol> _parameters;
    internal bool SynthesizesLoweredBoundBody { get; }
    internal bool GenerateDebugInfo { get; }
    internal MethodSymbol OverriddenAccessor { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    public bool IsAsync { get; }
    public bool IsVirtual { get; }
    internal CallingConvention CallingConvention { get; }
    public MethodKind MethodKind { get; }
    public int Arity { get; }
    public bool IsExtensionMethod { get; }
    public bool HidesBaseMethodsByName { get; }
    public bool IsVararg { get; }
    public bool ReturnsVoid { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public Symbol AssociatedSymbol { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool IsMetadataFinal { get; }
    internal bool RequiresSecurityObject { get; }
    internal MarshalPseudoCustomAttributeData ReturnValueMarshallingInformation { get; }
    internal bool HasDeclarativeSecurity { get; }
    public SynthesizedSealedPropertyAccessor(PropertySymbol property, MethodSymbol overriddenAccessor);
    internal virtual bool get_SynthesizesLoweredBoundBody();
    internal virtual bool get_GenerateDebugInfo();
    internal virtual void GenerateMethodBody(TypeCompilationState compilationState, DiagnosticBag diagnostics);
    internal MethodSymbol get_OverriddenAccessor();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsStatic();
    public virtual bool get_IsAsync();
    public virtual bool get_IsVirtual();
    internal virtual CallingConvention get_CallingConvention();
    public virtual MethodKind get_MethodKind();
    public virtual int get_Arity();
    public virtual bool get_IsExtensionMethod();
    public virtual bool get_HidesBaseMethodsByName();
    public virtual bool get_IsVararg();
    public virtual bool get_ReturnsVoid();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual Symbol get_AssociatedSymbol();
    public virtual bool get_IsOverride();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsExtern();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    internal sealed virtual bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_IsMetadataFinal();
    internal sealed virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_RequiresSecurityObject();
    public virtual DllImportData GetDllImportData();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnValueMarshallingInformation();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedStateMachineProperty : PropertySymbol {
    private SynthesizedStateMachineMethod _getter;
    private string _name;
    public string Name { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public bool IsIndexer { get; }
    internal bool HasSpecialName { get; }
    public MethodSymbol GetMethod { get; }
    public MethodSymbol SetMethod { get; }
    internal CallingConvention CallingConvention { get; }
    internal bool MustCallMethodsDirectly { get; }
    private PropertySymbol ImplementedProperty { get; }
    public ImmutableArray`1<PropertySymbol> ExplicitInterfaceImplementations { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    private bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.HasMethodBodyDependency { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.Method { get; }
    internal SynthesizedStateMachineProperty(MethodSymbol interfacePropertyGetter, StateMachineTypeSymbol stateMachineType);
    public virtual string get_Name();
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual bool get_IsIndexer();
    internal virtual bool get_HasSpecialName();
    public virtual MethodSymbol get_GetMethod();
    public virtual MethodSymbol get_SetMethod();
    internal virtual CallingConvention get_CallingConvention();
    internal virtual bool get_MustCallMethodsDirectly();
    private PropertySymbol get_ImplementedProperty();
    public virtual ImmutableArray`1<PropertySymbol> get_ExplicitInterfaceImplementations();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsStatic();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsExtern();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    private sealed virtual override bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_HasMethodBodyDependency();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_Method();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedStaticConstructor : MethodSymbol {
    private NamedTypeSymbol _containingType;
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    public bool IsVararg { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    internal int ParameterCount { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public Symbol AssociatedSymbol { get; }
    public int Arity { get; }
    public bool ReturnsVoid { get; }
    public MethodKind MethodKind { get; }
    public bool IsExtern { get; }
    public bool IsSealed { get; }
    public bool IsAbstract { get; }
    public bool IsOverride { get; }
    public bool IsVirtual { get; }
    public bool IsStatic { get; }
    public bool IsAsync { get; }
    public bool HidesBaseMethodsByName { get; }
    public bool IsExtensionMethod { get; }
    internal CallingConvention CallingConvention { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool GenerateDebugInfo { get; }
    internal bool IsMetadataFinal { get; }
    internal bool RequiresSecurityObject { get; }
    internal MarshalPseudoCustomAttributeData ReturnValueMarshallingInformation { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal SynthesizedStaticConstructor(NamedTypeSymbol containingType);
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    public virtual bool get_IsVararg();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal virtual int get_ParameterCount();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal virtual bool TryGetThisParameter(ParameterSymbol& thisParameter);
    public virtual Accessibility get_DeclaredAccessibility();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual Symbol get_AssociatedSymbol();
    public virtual int get_Arity();
    public virtual bool get_ReturnsVoid();
    public virtual MethodKind get_MethodKind();
    public virtual bool get_IsExtern();
    public virtual bool get_IsSealed();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsOverride();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsStatic();
    public virtual bool get_IsAsync();
    public virtual bool get_HidesBaseMethodsByName();
    public virtual bool get_IsExtensionMethod();
    internal virtual CallingConvention get_CallingConvention();
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public sealed virtual bool get_IsImplicitlyDeclared();
    internal sealed virtual bool get_GenerateDebugInfo();
    internal sealed virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal sealed virtual bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_IsMetadataFinal();
    internal virtual bool get_RequiresSecurityObject();
    public virtual DllImportData GetDllImportData();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnValueMarshallingInformation();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedStringSwitchHashMethod : SynthesizedGlobalMethodSymbol {
    internal SynthesizedStringSwitchHashMethod(SourceModuleSymbol containingModule, PrivateImplementationDetails privateImplType, TypeSymbol returnType, TypeSymbol paramType);
    internal static UInt32 ComputeStringHash(string text);
    internal virtual void GenerateMethodBody(TypeCompilationState compilationState, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedSubmissionConstructor : SynthesizedInstanceConstructor {
    private ImmutableArray`1<ParameterSymbol> _parameters;
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    internal SynthesizedSubmissionConstructor(NamedTypeSymbol containingType, DiagnosticBag diagnostics);
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedSubstitutedTypeParameterSymbol : SubstitutedTypeParameterSymbol {
    public bool IsImplicitlyDeclared { get; }
    public SynthesizedSubstitutedTypeParameterSymbol(Symbol owner, TypeMap map, TypeParameterSymbol substitutedFrom);
    public virtual bool get_IsImplicitlyDeclared();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.ThisParameterSymbol : ParameterSymbol {
    internal static string SymbolName;
    private MethodSymbol _containingMethod;
    private TypeSymbol _containingType;
    public string Name { get; }
    public TypeSymbol Type { get; }
    public RefKind RefKind { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Symbol ContainingSymbol { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    internal bool IsMetadataOptional { get; }
    public bool IsParams { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    internal bool IsCallerFilePath { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerMemberName { get; }
    public int Ordinal { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public bool IsThis { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool IsMetadataIn { get; }
    internal bool IsMetadataOut { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    internal ThisParameterSymbol(MethodSymbol forMethod);
    internal ThisParameterSymbol(MethodSymbol forMethod, TypeSymbol containingType);
    public virtual string get_Name();
    public virtual TypeSymbol get_Type();
    public virtual RefKind get_RefKind();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual Symbol get_ContainingSymbol();
    internal virtual ConstantValue get_ExplicitDefaultConstantValue();
    internal virtual bool get_IsMetadataOptional();
    public virtual bool get_IsParams();
    internal virtual bool get_IsIDispatchConstant();
    internal virtual bool get_IsIUnknownConstant();
    internal virtual bool get_IsCallerFilePath();
    internal virtual bool get_IsCallerLineNumber();
    internal virtual bool get_IsCallerMemberName();
    public virtual int get_Ordinal();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual bool get_IsThis();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual bool get_IsMetadataIn();
    internal virtual bool get_IsMetadataOut();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal sealed virtual ushort get_CountOfCustomModifiersPrecedingByRef();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.TypeMap : AbstractTypeParameterMap {
    public static Func`2<TypeSymbol, TypeWithModifiers> TypeSymbolAsTypeWithModifiers;
    private static SmallDictionary`2<TypeParameterSymbol, TypeWithModifiers> s_emptyDictionary;
    private static TypeMap s_emptyTypeMap;
    public static TypeMap Empty { get; }
    internal TypeMap(ImmutableArray`1<TypeParameterSymbol> from, ImmutableArray`1<TypeWithModifiers> to, bool allowAlpha);
    internal TypeMap(ImmutableArray`1<TypeParameterSymbol> from, ImmutableArray`1<TypeParameterSymbol> to, bool allowAlpha);
    internal TypeMap(SmallDictionary`2<TypeParameterSymbol, TypeWithModifiers> mapping);
    internal TypeMap(NamedTypeSymbol containingType, ImmutableArray`1<TypeParameterSymbol> typeParameters, ImmutableArray`1<TypeWithModifiers> typeArguments);
    private static TypeMap();
    private static SmallDictionary`2<TypeParameterSymbol, TypeWithModifiers> ForType(NamedTypeSymbol containingType);
    public static TypeMap get_Empty();
    private TypeMap WithAlphaRename(ImmutableArray`1<TypeParameterSymbol> oldTypeParameters, Symbol newOwner, ImmutableArray`1& newTypeParameters);
    internal TypeMap WithAlphaRename(NamedTypeSymbol oldOwner, NamedTypeSymbol newOwner, ImmutableArray`1& newTypeParameters);
    internal TypeMap WithAlphaRename(MethodSymbol oldOwner, Symbol newOwner, ImmutableArray`1& newTypeParameters);
    private static SmallDictionary`2<TypeParameterSymbol, TypeWithModifiers> ConstructMapping(ImmutableArray`1<TypeParameterSymbol> from, ImmutableArray`1<TypeWithModifiers> to);
    public ImmutableArray`1<ImmutableArray`1<CustomModifier>> GetTypeArgumentsCustomModifiersFor(NamedTypeSymbol originalDefinition);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterBounds : object {
    public static TypeParameterBounds Unset;
    public ImmutableArray`1<TypeSymbol> ConstraintTypes;
    public ImmutableArray`1<NamedTypeSymbol> Interfaces;
    public NamedTypeSymbol EffectiveBaseClass;
    public TypeSymbol DeducedBaseType;
    public TypeParameterBounds(ImmutableArray`1<TypeSymbol> constraintTypes, ImmutableArray`1<NamedTypeSymbol> interfaces, NamedTypeSymbol effectiveBaseClass, TypeSymbol deducedBaseType);
    private static TypeParameterBounds();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterBuilder : object {
    private SyntaxReference _syntaxRef;
    private SourceNamedTypeSymbol _owner;
    private Location _location;
    internal TypeParameterBuilder(SyntaxReference syntaxRef, SourceNamedTypeSymbol owner, Location location);
    internal TypeParameterSymbol MakeSymbol(int ordinal, IList`1<TypeParameterBuilder> builders, DiagnosticBag diagnostics);
    private static ImmutableArray`1<Location> ToLocations(IList`1<TypeParameterBuilder> builders);
    private static ImmutableArray`1<SyntaxReference> ToSyntaxRefs(IList`1<TypeParameterBuilder> builders);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintClause : object {
    public TypeParameterConstraintKind Constraints;
    public ImmutableArray`1<TypeSymbol> ConstraintTypes;
    public TypeParameterConstraintClause(TypeParameterConstraintKind constraints, ImmutableArray`1<TypeSymbol> constraintTypes);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintKind : Enum {
    public int value__;
    public static TypeParameterConstraintKind None;
    public static TypeParameterConstraintKind ReferenceType;
    public static TypeParameterConstraintKind ValueType;
    public static TypeParameterConstraintKind Constructor;
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterDiagnosticInfo : ValueType {
    public TypeParameterSymbol TypeParameter;
    public DiagnosticInfo DiagnosticInfo;
    public TypeParameterDiagnosticInfo(TypeParameterSymbol typeParameter, DiagnosticInfo diagnosticInfo);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol : TypeSymbol {
    private bool Microsoft.Cci.ITypeReference.IsEnum { get; }
    private bool Microsoft.Cci.ITypeReference.IsValueType { get; }
    private TypeDefinitionHandle Microsoft.Cci.ITypeReference.TypeDef { get; }
    private IGenericMethodParameter Microsoft.Cci.IGenericParameter.AsGenericMethodParameter { get; }
    private IGenericMethodParameterReference Microsoft.Cci.ITypeReference.AsGenericMethodParameterReference { get; }
    private IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.AsGenericTypeInstanceReference { get; }
    private IGenericTypeParameter Microsoft.Cci.IGenericParameter.AsGenericTypeParameter { get; }
    private IGenericTypeParameterReference Microsoft.Cci.ITypeReference.AsGenericTypeParameterReference { get; }
    private INamespaceTypeReference Microsoft.Cci.ITypeReference.AsNamespaceTypeReference { get; }
    private INestedTypeReference Microsoft.Cci.ITypeReference.AsNestedTypeReference { get; }
    private ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.AsSpecializedNestedTypeReference { get; }
    private string Microsoft.Cci.INamedEntity.Name { get; }
    private ushort Microsoft.Cci.IParameterListEntry.Index { get; }
    private IMethodReference Microsoft.Cci.IGenericMethodParameterReference.DefiningMethod { get; }
    private ITypeReference Microsoft.Cci.IGenericTypeParameterReference.DefiningType { get; }
    private bool Microsoft.Cci.IGenericParameter.MustBeReferenceType { get; }
    private bool Microsoft.Cci.IGenericParameter.MustBeValueType { get; }
    private bool Microsoft.Cci.IGenericParameter.MustHaveDefaultConstructor { get; }
    private TypeParameterVariance Microsoft.Cci.IGenericParameter.Variance { get; }
    private IMethodDefinition Microsoft.Cci.IGenericMethodParameter.DefiningMethod { get; }
    private ITypeDefinition Microsoft.Cci.IGenericTypeParameter.DefiningType { get; }
    public TypeParameterSymbol OriginalDefinition { get; }
    protected TypeSymbol OriginalTypeSymbolDefinition { get; }
    public TypeParameterSymbol ReducedFrom { get; }
    public int Ordinal { get; }
    public ImmutableArray`1<TypeSymbol> ConstraintTypes { get; }
    internal ImmutableArray`1<TypeSymbol> ConstraintTypesNoUseSiteDiagnostics { get; }
    public bool HasConstructorConstraint { get; }
    public TypeParameterKind TypeParameterKind { get; }
    public MethodSymbol DeclaringMethod { get; }
    public NamedTypeSymbol DeclaringType { get; }
    public SymbolKind Kind { get; }
    public TypeKind TypeKind { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    internal NamedTypeSymbol EffectiveBaseClassNoUseSiteDiagnostics { get; }
    internal ImmutableArray`1<NamedTypeSymbol> EffectiveInterfacesNoUseSiteDiagnostics { get; }
    internal TypeSymbol DeducedBaseTypeNoUseSiteDiagnostics { get; }
    internal ImmutableArray`1<NamedTypeSymbol> AllEffectiveInterfacesNoUseSiteDiagnostics { get; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    internal bool IsManagedType { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public VarianceKind Variance { get; }
    private TypeParameterKind Microsoft.CodeAnalysis.ITypeParameterSymbol.TypeParameterKind { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.ITypeParameterSymbol.DeclaringMethod { get; }
    private INamedTypeSymbol Microsoft.CodeAnalysis.ITypeParameterSymbol.DeclaringType { get; }
    private ImmutableArray`1<ITypeSymbol> Microsoft.CodeAnalysis.ITypeParameterSymbol.ConstraintTypes { get; }
    private ITypeParameterSymbol Microsoft.CodeAnalysis.ITypeParameterSymbol.OriginalDefinition { get; }
    private ITypeParameterSymbol Microsoft.CodeAnalysis.ITypeParameterSymbol.ReducedFrom { get; }
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsEnum();
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsValueType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.GetResolvedType(EmitContext context);
    private sealed virtual override PrimitiveTypeCode Microsoft.Cci.ITypeReference.TypeCode(EmitContext context);
    private sealed virtual override TypeDefinitionHandle Microsoft.Cci.ITypeReference.get_TypeDef();
    private sealed virtual override IGenericMethodParameter Microsoft.Cci.IGenericParameter.get_AsGenericMethodParameter();
    private sealed virtual override IGenericMethodParameterReference Microsoft.Cci.ITypeReference.get_AsGenericMethodParameterReference();
    private sealed virtual override IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.get_AsGenericTypeInstanceReference();
    private sealed virtual override IGenericTypeParameter Microsoft.Cci.IGenericParameter.get_AsGenericTypeParameter();
    private sealed virtual override IGenericTypeParameterReference Microsoft.Cci.ITypeReference.get_AsGenericTypeParameterReference();
    private sealed virtual override INamespaceTypeDefinition Microsoft.Cci.ITypeReference.AsNamespaceTypeDefinition(EmitContext context);
    private sealed virtual override INamespaceTypeReference Microsoft.Cci.ITypeReference.get_AsNamespaceTypeReference();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.ITypeReference.AsNestedTypeDefinition(EmitContext context);
    private sealed virtual override INestedTypeReference Microsoft.Cci.ITypeReference.get_AsNestedTypeReference();
    private sealed virtual override ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.get_AsSpecializedNestedTypeReference();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.AsTypeDefinition(EmitContext context);
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
    private sealed virtual override string Microsoft.Cci.INamedEntity.get_Name();
    private sealed virtual override ushort Microsoft.Cci.IParameterListEntry.get_Index();
    private sealed virtual override IMethodReference Microsoft.Cci.IGenericMethodParameterReference.get_DefiningMethod();
    private sealed virtual override ITypeReference Microsoft.Cci.IGenericTypeParameterReference.get_DefiningType();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol/<Microsoft-Cci-IGenericParameter-GetConstraints>d__37")]
private sealed virtual override IEnumerable`1<ITypeReference> Microsoft.Cci.IGenericParameter.GetConstraints(EmitContext context);
    private sealed virtual override bool Microsoft.Cci.IGenericParameter.get_MustBeReferenceType();
    private sealed virtual override bool Microsoft.Cci.IGenericParameter.get_MustBeValueType();
    private sealed virtual override bool Microsoft.Cci.IGenericParameter.get_MustHaveDefaultConstructor();
    private sealed virtual override TypeParameterVariance Microsoft.Cci.IGenericParameter.get_Variance();
    private sealed virtual override IMethodDefinition Microsoft.Cci.IGenericMethodParameter.get_DefiningMethod();
    private sealed virtual override ITypeDefinition Microsoft.Cci.IGenericTypeParameter.get_DefiningType();
    public virtual TypeParameterSymbol get_OriginalDefinition();
    protected sealed virtual TypeSymbol get_OriginalTypeSymbolDefinition();
    public virtual TypeParameterSymbol get_ReducedFrom();
    public abstract virtual int get_Ordinal();
    internal virtual DiagnosticInfo GetConstraintsUseSiteErrorInfo();
    public ImmutableArray`1<TypeSymbol> get_ConstraintTypes();
    internal ImmutableArray`1<TypeSymbol> get_ConstraintTypesNoUseSiteDiagnostics();
    internal ImmutableArray`1<TypeSymbol> ConstraintTypesWithDefinitionUseSiteDiagnostics(HashSet`1& useSiteDiagnostics);
    private void AppendConstraintsUseSiteErrorInfo(HashSet`1& useSiteDiagnostics);
    public abstract virtual bool get_HasConstructorConstraint();
    public abstract virtual TypeParameterKind get_TypeParameterKind();
    public MethodSymbol get_DeclaringMethod();
    public NamedTypeSymbol get_DeclaringType();
    public sealed virtual ImmutableArray`1<Symbol> GetMembers();
    public sealed virtual ImmutableArray`1<Symbol> GetMembers(string name);
    public sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    internal virtual TResult Accept(CSharpSymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual void Accept(CSharpSymbolVisitor visitor);
    public virtual TResult Accept(CSharpSymbolVisitor`1<TResult> visitor);
    public sealed virtual SymbolKind get_Kind();
    public sealed virtual TypeKind get_TypeKind();
    public sealed virtual Accessibility get_DeclaredAccessibility();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    internal sealed virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
    internal sealed virtual ImmutableArray`1<NamedTypeSymbol> InterfacesNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
    protected virtual ImmutableArray`1<NamedTypeSymbol> GetAllInterfaces();
    internal NamedTypeSymbol get_EffectiveBaseClassNoUseSiteDiagnostics();
    internal NamedTypeSymbol EffectiveBaseClass(HashSet`1& useSiteDiagnostics);
    internal ImmutableArray`1<NamedTypeSymbol> get_EffectiveInterfacesNoUseSiteDiagnostics();
    internal TypeSymbol get_DeducedBaseTypeNoUseSiteDiagnostics();
    internal TypeSymbol DeducedBaseType(HashSet`1& useSiteDiagnostics);
    internal ImmutableArray`1<NamedTypeSymbol> get_AllEffectiveInterfacesNoUseSiteDiagnostics();
    internal ImmutableArray`1<NamedTypeSymbol> AllEffectiveInterfacesWithDefinitionUseSiteDiagnostics(HashSet`1& useSiteDiagnostics);
    internal abstract virtual void EnsureAllConstraintsAreResolved();
    protected static void EnsureAllConstraintsAreResolved(ImmutableArray`1<TypeParameterSymbol> typeParameters);
    internal abstract virtual ImmutableArray`1<TypeSymbol> GetConstraintTypes(ConsList`1<TypeParameterSymbol> inProgress);
    internal abstract virtual ImmutableArray`1<NamedTypeSymbol> GetInterfaces(ConsList`1<TypeParameterSymbol> inProgress);
    internal abstract virtual NamedTypeSymbol GetEffectiveBaseClass(ConsList`1<TypeParameterSymbol> inProgress);
    internal abstract virtual TypeSymbol GetDeducedBaseType(ConsList`1<TypeParameterSymbol> inProgress);
    private static bool ConstraintImpliesReferenceType(TypeSymbol constraint);
    internal static bool IsReferenceTypeFromConstraintTypes(ImmutableArray`1<TypeSymbol> constraintTypes);
    internal static bool IsValueTypeFromConstraintTypes(ImmutableArray`1<TypeSymbol> constraintTypes);
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsValueType();
    internal sealed virtual bool get_IsManagedType();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public abstract virtual bool get_HasReferenceTypeConstraint();
    public abstract virtual bool get_HasValueTypeConstraint();
    public abstract virtual VarianceKind get_Variance();
    internal sealed virtual bool GetUnificationUseSiteDiagnosticRecursive(DiagnosticInfo& result, Symbol owner, HashSet`1& checkedTypes);
    internal virtual bool Equals(TypeSymbol t2, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
    internal bool Equals(TypeParameterSymbol other);
    private bool Equals(TypeParameterSymbol other, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
    public virtual int GetHashCode();
    internal virtual CustomAttributesBag`1<CSharpAttributeData> GetAttributesBag();
    private sealed virtual override TypeParameterKind Microsoft.CodeAnalysis.ITypeParameterSymbol.get_TypeParameterKind();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.ITypeParameterSymbol.get_DeclaringMethod();
    private sealed virtual override INamedTypeSymbol Microsoft.CodeAnalysis.ITypeParameterSymbol.get_DeclaringType();
    private sealed virtual override ImmutableArray`1<ITypeSymbol> Microsoft.CodeAnalysis.ITypeParameterSymbol.get_ConstraintTypes();
    private sealed virtual override ITypeParameterSymbol Microsoft.CodeAnalysis.ITypeParameterSymbol.get_OriginalDefinition();
    private sealed virtual override ITypeParameterSymbol Microsoft.CodeAnalysis.ITypeParameterSymbol.get_ReducedFrom();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbolExtensions : object {
    [ExtensionAttribute]
public static bool DependsOn(TypeParameterSymbol typeParameter1, TypeParameterSymbol typeParameter2);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.TypeSubstitutedLocalSymbol : LocalSymbol {
    private LocalSymbol _originalVariable;
    private TypeSymbol _type;
    private Symbol _containingSymbol;
    internal bool IsImportedFromMetadata { get; }
    internal LocalDeclarationKind DeclarationKind { get; }
    internal SynthesizedLocalKind SynthesizedKind { get; }
    public string Name { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public TypeSymbol Type { get; }
    internal SyntaxToken IdentifierToken { get; }
    internal bool IsCompilerGenerated { get; }
    internal bool IsPinned { get; }
    internal RefKind RefKind { get; }
    public TypeSubstitutedLocalSymbol(LocalSymbol originalVariable, TypeSymbol type, Symbol containingSymbol);
    internal virtual bool get_IsImportedFromMetadata();
    internal virtual LocalDeclarationKind get_DeclarationKind();
    internal virtual SynthesizedLocalKind get_SynthesizedKind();
    public virtual string get_Name();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual SyntaxNode GetDeclaratorSyntax();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual TypeSymbol get_Type();
    internal virtual SyntaxToken get_IdentifierToken();
    internal virtual bool get_IsCompilerGenerated();
    internal virtual bool get_IsPinned();
    internal virtual RefKind get_RefKind();
    internal virtual ConstantValue GetConstantValue(SyntaxNode node, LocalSymbol inProgress, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<Diagnostic> GetConstantValueDiagnostics(BoundExpression boundInitValue);
    internal virtual LocalSymbol WithSynthesizedLocalKindAndSyntax(SynthesizedLocalKind kind, SyntaxNode syntax);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol : NamespaceOrTypeSymbol {
    internal static string ImplicitTypeName;
    private static InterfaceInfo s_noInterfaces;
    private ImmutableHashSet`1<Symbol> _lazyAbstractMembers;
    private InterfaceInfo _lazyInterfaceInfo;
    internal static EqualityComparer`1<TypeSymbol> EqualsIgnoringDynamicComparer;
    public TypeSymbol OriginalDefinition { get; }
    protected TypeSymbol OriginalTypeSymbolDefinition { get; }
    protected Symbol OriginalSymbolDefinition { get; }
    public NamedTypeSymbol BaseType { get; }
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    public ImmutableArray`1<NamedTypeSymbol> Interfaces { get; }
    public ImmutableArray`1<NamedTypeSymbol> AllInterfaces { get; }
    internal ImmutableArray`1<NamedTypeSymbol> AllInterfacesNoUseSiteDiagnostics { get; }
    internal TypeSymbol EffectiveTypeNoUseSiteDiagnostics { get; }
    internal ImmutableHashSet`1<NamedTypeSymbol> InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics { get; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    public TypeKind TypeKind { get; }
    public SpecialType SpecialType { get; }
    internal PrimitiveTypeCode PrimitiveTypeCode { get; }
    protected int HighestPriorityUseSiteError { get; }
    public bool HasUnsupportedMetadata { get; }
    public bool IsAnonymousType { get; }
    internal bool IsManagedType { get; }
    private INamedTypeSymbol Microsoft.CodeAnalysis.ITypeSymbol.BaseType { get; }
    private ImmutableArray`1<INamedTypeSymbol> Microsoft.CodeAnalysis.ITypeSymbol.Interfaces { get; }
    private ImmutableArray`1<INamedTypeSymbol> Microsoft.CodeAnalysis.ITypeSymbol.AllInterfaces { get; }
    private bool Microsoft.CodeAnalysis.ITypeSymbol.IsReferenceType { get; }
    private bool Microsoft.CodeAnalysis.ITypeSymbol.IsValueType { get; }
    private ITypeSymbol Microsoft.CodeAnalysis.ITypeSymbol.OriginalDefinition { get; }
    private TypeKind Microsoft.CodeAnalysis.ITypeSymbol.TypeKind { get; }
    internal ImmutableHashSet`1<Symbol> AbstractMembers { get; }
    private static TypeSymbol();
    private InterfaceInfo GetInterfaceInfo();
    public TypeSymbol get_OriginalDefinition();
    protected virtual TypeSymbol get_OriginalTypeSymbolDefinition();
    protected sealed virtual Symbol get_OriginalSymbolDefinition();
    public NamedTypeSymbol get_BaseType();
    internal abstract virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
    internal NamedTypeSymbol BaseTypeWithDefinitionUseSiteDiagnostics(HashSet`1& useSiteDiagnostics);
    internal NamedTypeSymbol BaseTypeOriginalDefinition(HashSet`1& useSiteDiagnostics);
    public ImmutableArray`1<NamedTypeSymbol> get_Interfaces();
    internal abstract virtual ImmutableArray`1<NamedTypeSymbol> InterfacesNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
    public ImmutableArray`1<NamedTypeSymbol> get_AllInterfaces();
    internal ImmutableArray`1<NamedTypeSymbol> get_AllInterfacesNoUseSiteDiagnostics();
    internal ImmutableArray`1<NamedTypeSymbol> AllInterfacesWithDefinitionUseSiteDiagnostics(HashSet`1& useSiteDiagnostics);
    internal TypeSymbol get_EffectiveTypeNoUseSiteDiagnostics();
    internal TypeSymbol EffectiveType(HashSet`1& useSiteDiagnostics);
    internal bool IsDerivedFrom(TypeSymbol type, bool ignoreDynamic, HashSet`1& useSiteDiagnostics);
    internal bool IsEqualToOrDerivedFrom(TypeSymbol type, bool ignoreDynamic, HashSet`1& useSiteDiagnostics);
    internal virtual bool Equals(TypeSymbol t2, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
    public sealed virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected virtual ImmutableArray`1<NamedTypeSymbol> GetAllInterfaces();
    protected virtual ImmutableArray`1<NamedTypeSymbol> MakeAllInterfaces();
    private static void AddAllInterfaces(NamedTypeSymbol interface, HashSet`1<NamedTypeSymbol> visited, ArrayBuilder`1<NamedTypeSymbol> result);
    internal ImmutableHashSet`1<NamedTypeSymbol> get_InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics();
    private static ImmutableHashSet`1<NamedTypeSymbol> MakeInterfacesAndTheirBaseInterfaces(ImmutableArray`1<NamedTypeSymbol> declaredInterfaces);
    public Symbol FindImplementationForInterfaceMember(Symbol interfaceMember);
    public abstract virtual bool get_IsReferenceType();
    public abstract virtual bool get_IsValueType();
    public abstract virtual TypeKind get_TypeKind();
    public virtual SpecialType get_SpecialType();
    internal PrimitiveTypeCode get_PrimitiveTypeCode();
    protected virtual int get_HighestPriorityUseSiteError();
    public sealed virtual bool get_HasUnsupportedMetadata();
    internal abstract virtual bool GetUnificationUseSiteDiagnosticRecursive(DiagnosticInfo& result, Symbol owner, HashSet`1& checkedTypes);
    public virtual bool get_IsAnonymousType();
    internal abstract virtual bool get_IsManagedType();
    private sealed virtual override INamedTypeSymbol Microsoft.CodeAnalysis.ITypeSymbol.get_BaseType();
    private sealed virtual override ImmutableArray`1<INamedTypeSymbol> Microsoft.CodeAnalysis.ITypeSymbol.get_Interfaces();
    private sealed virtual override ImmutableArray`1<INamedTypeSymbol> Microsoft.CodeAnalysis.ITypeSymbol.get_AllInterfaces();
    private sealed virtual override bool Microsoft.CodeAnalysis.ITypeSymbol.get_IsReferenceType();
    private sealed virtual override bool Microsoft.CodeAnalysis.ITypeSymbol.get_IsValueType();
    private sealed virtual override ITypeSymbol Microsoft.CodeAnalysis.ITypeSymbol.get_OriginalDefinition();
    private sealed virtual override TypeKind Microsoft.CodeAnalysis.ITypeSymbol.get_TypeKind();
    private sealed virtual override ISymbol Microsoft.CodeAnalysis.ITypeSymbol.FindImplementationForInterfaceMember(ISymbol interfaceMember);
    protected SymbolAndDiagnostics FindImplementationForInterfaceMemberWithDiagnostics(Symbol interfaceMember);
    private SymbolAndDiagnostics ComputeImplementationAndDiagnosticsForInterfaceMember(Symbol interfaceMember);
    private static Symbol ComputeImplementationForInterfaceMember(Symbol interfaceMember, TypeSymbol implementingType, DiagnosticBag diagnostics);
    private static bool IsExplicitlyImplementedViaAccessors(Symbol interfaceMember, TypeSymbol currType, Symbol& implementingMember);
    private static bool TryGetExplicitImplementationAssociatedPropertyOrEvent(MethodSymbol interfaceAccessor, TypeSymbol currType, Symbol& associated);
    private static void CheckForImplementationOfCorrespondingPropertyOrEvent(MethodSymbol interfaceMethod, TypeSymbol implementingType, bool implementingTypeIsFromSomeCompilation, Symbol& implicitImpl);
    private static void ReportImplicitImplementationMatchDiagnostics(Symbol interfaceMember, TypeSymbol implementingType, Symbol implicitImpl, DiagnosticBag diagnostics);
    private static void ReportImplicitImplementationMismatchDiagnostics(Symbol interfaceMember, TypeSymbol implementingType, Symbol closestMismatch, DiagnosticBag diagnostics);
    private static void ReportAnyMismatchedConstraints(MethodSymbol interfaceMethod, TypeSymbol implementingType, MethodSymbol implicitImpl, DiagnosticBag diagnostics);
    private static void FindPotentialImplicitImplementationMemberDeclaredInType(Symbol interfaceMember, bool implementingTypeIsFromSomeCompilation, TypeSymbol currType, Symbol& implicitImpl, Symbol& closeMismatch);
    private static bool IsInterfaceMemberImplementation(Symbol candidateMember, Symbol interfaceMember, bool implementingTypeIsFromSomeCompilation);
    private Symbol GetExplicitImplementationForInterfaceMember(Symbol interfaceMember);
    private Dictionary`2<Symbol, Symbol> MakeExplicitInterfaceImplementationMap();
    internal ImmutableHashSet`1<Symbol> get_AbstractMembers();
    private ImmutableHashSet`1<Symbol> ComputeAbstractMembers();
    [ObsoleteAttribute("Use TypeWithModifiers.Is method.", "True")]
internal bool Equals(TypeWithModifiers other);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions : object {
    private static String[] s_expressionsNamespaceName;
    private static Func`4<TypeSymbol, TypeParameterSymbol, bool, bool> s_containsTypeParameterPredicate;
    private static Func`4<TypeSymbol, Symbol, bool, bool> s_isTypeParameterWithSpecificContainerPredicate;
    private static Func`4<TypeSymbol, object, bool, bool> s_containsDynamicPredicate;
    private static TypeSymbolExtensions();
    [ExtensionAttribute]
public static bool ImplementsInterface(TypeSymbol subType, TypeSymbol superInterface, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
public static bool CanBeAssignedNull(TypeSymbol type);
    [ExtensionAttribute]
public static bool CanBeConst(TypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsNonNullableValueType(TypeSymbol typeArgument);
    [ExtensionAttribute]
public static bool IsNullableTypeOrTypeParameter(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsNullableType(TypeSymbol type);
    [ExtensionAttribute]
public static TypeSymbol GetNullableUnderlyingType(TypeSymbol type);
    [ExtensionAttribute]
public static TypeSymbol StrippedType(TypeSymbol type);
    [ExtensionAttribute]
public static TypeSymbol EnumUnderlyingType(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsObjectType(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsStringType(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsCharType(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsIntegralType(TypeSymbol type);
    [ExtensionAttribute]
public static NamedTypeSymbol GetEnumUnderlyingType(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsEnumType(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsValidEnumType(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsValidAttributeParameterType(TypeSymbol type, CSharpCompilation compilation);
    [ExtensionAttribute]
public static TypedConstantKind GetAttributeParameterTypedConstantKind(TypeSymbol type, CSharpCompilation compilation);
    [ExtensionAttribute]
public static bool IsValidExtensionParameterType(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsInterfaceType(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsClassType(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsStructType(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsErrorType(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsMethodTypeParameter(TypeParameterSymbol p);
    [ExtensionAttribute]
public static bool IsDynamic(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsTypeParameter(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsArray(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsSZArray(TypeSymbol type);
    [ExtensionAttribute]
public static NamedTypeSymbol GetDelegateType(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsExpressionTree(TypeSymbol _type);
    [ExtensionAttribute]
public static bool IsPossibleArrayGenericInterface(TypeSymbol _type);
    private static bool CheckFullName(Symbol symbol, String[] names);
    [ExtensionAttribute]
public static bool IsDelegateType(TypeSymbol type);
    [ExtensionAttribute]
public static ImmutableArray`1<ParameterSymbol> DelegateParameters(TypeSymbol type);
    [ExtensionAttribute]
public static MethodSymbol DelegateInvokeMethod(TypeSymbol type);
    [ExtensionAttribute]
public static ConstantValue GetDefaultValue(TypeSymbol type);
    [ExtensionAttribute]
public static SpecialType GetSpecialTypeSafe(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsAtLeastAsVisibleAs(TypeSymbol type, Symbol sym, HashSet`1& useSiteDiagnostics);
    private static bool IsTypeLessVisibleThan(TypeSymbol type, Symbol sym, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
public static TypeSymbol VisitType(TypeSymbol type, Func`4<TypeSymbol, T, bool, bool> predicate, T arg);
    private static bool IsAsRestrictive(NamedTypeSymbol s1, Symbol sym2, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
public static bool IsUnboundGenericType(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsTopLevelType(NamedTypeSymbol type);
    [ExtensionAttribute]
public static bool ContainsTypeParameter(TypeSymbol type, TypeParameterSymbol parameter);
    [ExtensionAttribute]
public static bool ContainsTypeParameter(TypeSymbol type, MethodSymbol parameterContainer);
    [ExtensionAttribute]
public static bool ContainsDynamic(TypeSymbol type);
    [ExtensionAttribute]
internal static TypeSymbol GetNonErrorGuess(TypeSymbol type);
    [ExtensionAttribute]
internal static TypeKind GetNonErrorTypeKindGuess(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsValidSwitchGoverningType(TypeSymbol type, bool isTargetTypeOfUserDefinedOp);
    [ExtensionAttribute]
internal static bool IsRestrictedType(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsIntrinsicType(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsPartial(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsPointerType(TypeSymbol type);
    [ExtensionAttribute]
internal static int FixedBufferElementSizeInBytes(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsValidVolatileFieldType(TypeSymbol type);
    [ExtensionAttribute]
public static bool MarkCheckedIfNecessary(TypeSymbol type, HashSet`1& checkedTypes);
    [ExtensionAttribute]
internal static bool IsUnsafe(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsVoidPointer(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsPrimitiveRecursiveStruct(TypeSymbol t);
    [ExtensionAttribute]
internal static int ComputeHashCode(NamedTypeSymbol type);
    [ExtensionAttribute]
public static TypeSymbol AsDynamicIfNoPia(TypeSymbol type, NamedTypeSymbol containingType);
    [ExtensionAttribute]
internal static bool IsVerifierReference(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsVerifierValue(TypeSymbol type);
    [ExtensionAttribute]
internal static void AddUseSiteDiagnostics(TypeSymbol type, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
internal static ImmutableArray`1<TypeParameterSymbol> GetAllTypeParameters(NamedTypeSymbol type);
    [ExtensionAttribute]
internal static void GetAllTypeParameters(NamedTypeSymbol type, ArrayBuilder`1<TypeParameterSymbol> result);
    [ExtensionAttribute]
internal static TypeParameterSymbol FindEnclosingTypeParameter(NamedTypeSymbol type, string name);
    [ExtensionAttribute]
internal static bool HasNameQualifier(NamedTypeSymbol type, string qualifiedName);
    private static bool HasNamespaceName(NamespaceSymbol namespace, string namespaceName, StringComparison comparison, int length);
    [ExtensionAttribute]
public static NamedTypeSymbol AsUnboundGenericType(NamedTypeSymbol type);
    [ExtensionAttribute]
public static int CustomModifierCount(TypeSymbol type);
    [ExtensionAttribute]
public static bool HasCustomModifiers(TypeSymbol type, bool flagNonDefaultArraySizesOrLowerBounds);
    [ExtensionAttribute]
public static bool CanUnifyWith(TypeSymbol thisType, TypeSymbol otherType);
    [ExtensionAttribute]
internal static TypeSymbol GetNextBaseTypeNoUseSiteDiagnostics(TypeSymbol type, ConsList`1<Symbol> basesBeingResolved, CSharpCompilation compilation, PooledHashSet`1& visited);
    private static TypeSymbol GetNextDeclaredBase(NamedTypeSymbol type, ConsList`1<Symbol> basesBeingResolved, CSharpCompilation compilation, PooledHashSet`1& visited);
    private static void SetKnownToHaveNoDeclaredBaseCycles(PooledHashSet`1& visited);
    private static NamedTypeSymbol GetDefaultBaseOrNull(NamedTypeSymbol type, CSharpCompilation compilation);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.TypeWellKnownAttributeData : CommonTypeWellKnownAttributeData {
    private NamedTypeSymbol _comImportCoClass;
    public NamedTypeSymbol ComImportCoClass { get; public set; }
    public NamedTypeSymbol get_ComImportCoClass();
    public void set_ComImportCoClass(NamedTypeSymbol value);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.TypeWithModifiers : ValueType {
    public TypeSymbol Type;
    public ImmutableArray`1<CustomModifier> CustomModifiers;
    public TypeWithModifiers(TypeSymbol type, ImmutableArray`1<CustomModifier> customModifiers);
    public TypeWithModifiers(TypeSymbol type);
    [ObsoleteAttribute("Use the strongly typed overload.", "True")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TypeWithModifiers other);
    public bool Equals(TypeWithModifiers other, bool ignoreDynamic);
    public static bool op_Equality(TypeWithModifiers x, TypeWithModifiers y);
    public static bool op_Inequality(TypeWithModifiers x, TypeWithModifiers y);
    public virtual int GetHashCode();
    public bool Is(TypeSymbol other);
    [ObsoleteAttribute("Use Is method.", "True")]
public bool Equals(TypeSymbol other);
    public TypeSymbol AsTypeSymbolOnly();
    public TypeWithModifiers SubstituteType(AbstractTypeMap typeMap);
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.UnboundArgumentErrorTypeSymbol : ErrorTypeSymbol {
    public static ErrorTypeSymbol Instance;
    private string _name;
    private DiagnosticInfo _errorInfo;
    public string Name { get; }
    internal bool MangleName { get; }
    internal DiagnosticInfo ErrorInfo { get; }
    private UnboundArgumentErrorTypeSymbol(string name, DiagnosticInfo errorInfo);
    private static UnboundArgumentErrorTypeSymbol();
    public static ImmutableArray`1<TypeWithModifiers> CreateTypeArguments(ImmutableArray`1<TypeParameterSymbol> typeParameters, int n, DiagnosticInfo errorInfo);
    public virtual string get_Name();
    internal virtual bool get_MangleName();
    internal virtual DiagnosticInfo get_ErrorInfo();
    internal virtual bool Equals(TypeSymbol t2, bool ignoreCustomModifiersAndArraySizesAndLowerBounds, bool ignoreDynamic);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.CSharp.Symbols.UnsupportedMetadataTypeSymbol : ErrorTypeSymbol {
    private BadImageFormatException _mrEx;
    internal DiagnosticInfo ErrorInfo { get; }
    internal bool MangleName { get; }
    internal UnsupportedMetadataTypeSymbol(BadImageFormatException mrEx);
    internal virtual DiagnosticInfo get_ErrorInfo();
    internal virtual bool get_MangleName();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety : object {
    [ExtensionAttribute]
internal static void CheckInterfaceVarianceSafety(NamedTypeSymbol interfaceType, DiagnosticBag diagnostics);
    [ExtensionAttribute]
internal static void CheckDelegateVarianceSafety(SourceDelegateMethodSymbol method, DiagnosticBag diagnostics);
    [ExtensionAttribute]
private static void CheckMethodVarianceSafety(MethodSymbol method, DiagnosticBag diagnostics);
    [ExtensionAttribute]
private static void CheckMethodVarianceSafety(MethodSymbol method, LocationProvider`1<MethodSymbol> returnTypeLocationProvider, DiagnosticBag diagnostics);
    private static void CheckPropertyVarianceSafety(PropertySymbol property, DiagnosticBag diagnostics);
    private static void CheckEventVarianceSafety(EventSymbol event, DiagnosticBag diagnostics);
    private static void CheckParametersVarianceSafety(ImmutableArray`1<ParameterSymbol> parameters, Symbol context, DiagnosticBag diagnostics);
    private static void CheckTypeParametersVarianceSafety(ImmutableArray`1<TypeParameterSymbol> typeParameters, MethodSymbol context, DiagnosticBag diagnostics);
    private static bool IsVarianceUnsafe(TypeSymbol type, bool requireOutputSafety, bool requireInputSafety, Symbol context, LocationProvider`1<T> locationProvider, T locationArg, DiagnosticBag diagnostics);
    private static bool IsVarianceUnsafe(NamedTypeSymbol namedType, bool requireOutputSafety, bool requireInputSafety, Symbol context, LocationProvider`1<T> locationProvider, T locationArg, DiagnosticBag diagnostics);
    [ExtensionAttribute]
private static void AddVarianceError(DiagnosticBag diagnostics, TypeParameterSymbol unsafeTypeParameter, Symbol context, LocationProvider`1<T> locationProvider, T locationArg, MessageID expectedVariance);
    [ExtensionAttribute]
private static T GetDeclaringSyntax(Symbol symbol);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Symbols.WrappedParameterSymbol : ParameterSymbol {
    protected ParameterSymbol underlyingParameter;
    public Symbol ContainingSymbol { get; }
    public ParameterSymbol OriginalDefinition { get; }
    public TypeSymbol Type { get; }
    public RefKind RefKind { get; }
    internal bool IsMetadataIn { get; }
    internal bool IsMetadataOut { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    public int Ordinal { get; }
    public bool IsParams { get; }
    internal bool IsMetadataOptional { get; }
    public bool IsImplicitlyDeclared { get; }
    public string Name { get; }
    public string MetadataName { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal UnmanagedType MarshallingType { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerFilePath { get; }
    internal bool IsCallerMemberName { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    protected WrappedParameterSymbol(ParameterSymbol underlyingParameter);
    public abstract virtual Symbol get_ContainingSymbol();
    public virtual ParameterSymbol get_OriginalDefinition();
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public virtual TypeSymbol get_Type();
    public sealed virtual RefKind get_RefKind();
    internal sealed virtual bool get_IsMetadataIn();
    internal sealed virtual bool get_IsMetadataOut();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public sealed virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal sealed virtual ConstantValue get_ExplicitDefaultConstantValue();
    public virtual int get_Ordinal();
    public virtual bool get_IsParams();
    internal virtual bool get_IsMetadataOptional();
    public virtual bool get_IsImplicitlyDeclared();
    public sealed virtual string get_Name();
    public sealed virtual string get_MetadataName();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual UnmanagedType get_MarshallingType();
    internal virtual bool get_IsIDispatchConstant();
    internal virtual bool get_IsIUnknownConstant();
    internal virtual bool get_IsCallerLineNumber();
    internal virtual bool get_IsCallerFilePath();
    internal virtual bool get_IsCallerMemberName();
    internal sealed virtual ushort get_CountOfCustomModifiersPrecedingByRef();
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax : CSharpSyntaxNode {
    private CSharpSyntaxNode attributeLists;
    private BlockSyntax body;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken Keyword { get; }
    public BlockSyntax Body { get; }
    public SyntaxToken SemicolonToken { get; }
    internal AccessorDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxTokenList get_Modifiers();
    public SyntaxToken get_Keyword();
    public BlockSyntax get_Body();
    public SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AccessorDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken);
    public AccessorDeclarationSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public AccessorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
    public AccessorDeclarationSyntax WithKeyword(SyntaxToken keyword);
    public AccessorDeclarationSyntax WithBody(BlockSyntax body);
    public AccessorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
    public AccessorDeclarationSyntax AddAttributeLists(AttributeListSyntax[] items);
    public AccessorDeclarationSyntax AddModifiers(SyntaxToken[] items);
    public AccessorDeclarationSyntax AddBodyStatements(StatementSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax : CSharpSyntaxNode {
    private CSharpSyntaxNode accessors;
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxList`1<AccessorDeclarationSyntax> Accessors { get; }
    public SyntaxToken CloseBraceToken { get; }
    internal AccessorListSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OpenBraceToken();
    public SyntaxList`1<AccessorDeclarationSyntax> get_Accessors();
    public SyntaxToken get_CloseBraceToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AccessorListSyntax Update(SyntaxToken openBraceToken, SyntaxList`1<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken);
    public AccessorListSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
    public AccessorListSyntax WithAccessors(SyntaxList`1<AccessorDeclarationSyntax> accessors);
    public AccessorListSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
    public AccessorListSyntax AddAccessors(AccessorDeclarationSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax : NameSyntax {
    private IdentifierNameSyntax alias;
    private SimpleNameSyntax name;
    public IdentifierNameSyntax Alias { get; }
    public SyntaxToken ColonColonToken { get; }
    public SimpleNameSyntax Name { get; }
    internal AliasQualifiedNameSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    internal virtual SimpleNameSyntax GetUnqualifiedName();
    internal virtual string ErrorDisplayName();
    public IdentifierNameSyntax get_Alias();
    public SyntaxToken get_ColonColonToken();
    public SimpleNameSyntax get_Name();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AliasQualifiedNameSyntax Update(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name);
    public AliasQualifiedNameSyntax WithAlias(IdentifierNameSyntax alias);
    public AliasQualifiedNameSyntax WithColonColonToken(SyntaxToken colonColonToken);
    public AliasQualifiedNameSyntax WithName(SimpleNameSyntax name);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax : ExpressionSyntax {
    public SyntaxToken AsyncKeyword { get; }
    public CSharpSyntaxNode Body { get; }
    internal AnonymousFunctionExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public abstract virtual SyntaxToken get_AsyncKeyword();
    public abstract virtual CSharpSyntaxNode get_Body();
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax : AnonymousFunctionExpressionSyntax {
    private ParameterListSyntax parameterList;
    private CSharpSyntaxNode body;
    public BlockSyntax Block { get; }
    public SyntaxToken AsyncKeyword { get; }
    public SyntaxToken DelegateKeyword { get; }
    public ParameterListSyntax ParameterList { get; }
    public CSharpSyntaxNode Body { get; }
    internal AnonymousMethodExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public BlockSyntax get_Block();
    public AnonymousMethodExpressionSyntax WithBlock(BlockSyntax block);
    public AnonymousMethodExpressionSyntax AddBlockStatements(StatementSyntax[] items);
    public virtual SyntaxToken get_AsyncKeyword();
    public SyntaxToken get_DelegateKeyword();
    public ParameterListSyntax get_ParameterList();
    public virtual CSharpSyntaxNode get_Body();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AnonymousMethodExpressionSyntax Update(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body);
    public AnonymousMethodExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword);
    public AnonymousMethodExpressionSyntax WithDelegateKeyword(SyntaxToken delegateKeyword);
    public AnonymousMethodExpressionSyntax WithParameterList(ParameterListSyntax parameterList);
    public AnonymousMethodExpressionSyntax WithBody(CSharpSyntaxNode body);
    public AnonymousMethodExpressionSyntax AddParameterListParameters(ParameterSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax : ExpressionSyntax {
    private SyntaxNode initializers;
    public SyntaxToken NewKeyword { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SeparatedSyntaxList`1<AnonymousObjectMemberDeclaratorSyntax> Initializers { get; }
    public SyntaxToken CloseBraceToken { get; }
    internal AnonymousObjectCreationExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_NewKeyword();
    public SyntaxToken get_OpenBraceToken();
    public SeparatedSyntaxList`1<AnonymousObjectMemberDeclaratorSyntax> get_Initializers();
    public SyntaxToken get_CloseBraceToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AnonymousObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList`1<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken);
    public AnonymousObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword);
    public AnonymousObjectCreationExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
    public AnonymousObjectCreationExpressionSyntax WithInitializers(SeparatedSyntaxList`1<AnonymousObjectMemberDeclaratorSyntax> initializers);
    public AnonymousObjectCreationExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
    public AnonymousObjectCreationExpressionSyntax AddInitializers(AnonymousObjectMemberDeclaratorSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax : CSharpSyntaxNode {
    private NameEqualsSyntax nameEquals;
    private ExpressionSyntax expression;
    public NameEqualsSyntax NameEquals { get; }
    public ExpressionSyntax Expression { get; }
    internal AnonymousObjectMemberDeclaratorSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public NameEqualsSyntax get_NameEquals();
    public ExpressionSyntax get_Expression();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AnonymousObjectMemberDeclaratorSyntax Update(NameEqualsSyntax nameEquals, ExpressionSyntax expression);
    public AnonymousObjectMemberDeclaratorSyntax WithNameEquals(NameEqualsSyntax nameEquals);
    public AnonymousObjectMemberDeclaratorSyntax WithExpression(ExpressionSyntax expression);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax : BaseArgumentListSyntax {
    private SyntaxNode arguments;
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxList`1<ArgumentSyntax> Arguments { get; }
    public SyntaxToken CloseParenToken { get; }
    internal ArgumentListSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OpenParenToken();
    public virtual SeparatedSyntaxList`1<ArgumentSyntax> get_Arguments();
    public SyntaxToken get_CloseParenToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList`1<ArgumentSyntax> arguments, SyntaxToken closeParenToken);
    public ArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public ArgumentListSyntax WithArguments(SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    public ArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    public ArgumentListSyntax AddArguments(ArgumentSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax : CSharpSyntaxNode {
    private NameColonSyntax nameColon;
    private ExpressionSyntax expression;
    public NameColonSyntax NameColon { get; }
    public SyntaxToken RefOrOutKeyword { get; }
    public ExpressionSyntax Expression { get; }
    internal ArgumentSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public NameColonSyntax get_NameColon();
    public SyntaxToken get_RefOrOutKeyword();
    public ExpressionSyntax get_Expression();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ArgumentSyntax Update(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression);
    public ArgumentSyntax WithNameColon(NameColonSyntax nameColon);
    public ArgumentSyntax WithRefOrOutKeyword(SyntaxToken refOrOutKeyword);
    public ArgumentSyntax WithExpression(ExpressionSyntax expression);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax : ExpressionSyntax {
    private ArrayTypeSyntax type;
    private InitializerExpressionSyntax initializer;
    public SyntaxToken NewKeyword { get; }
    public ArrayTypeSyntax Type { get; }
    public InitializerExpressionSyntax Initializer { get; }
    internal ArrayCreationExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_NewKeyword();
    public ArrayTypeSyntax get_Type();
    public InitializerExpressionSyntax get_Initializer();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer);
    public ArrayCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword);
    public ArrayCreationExpressionSyntax WithType(ArrayTypeSyntax type);
    public ArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer);
    public ArrayCreationExpressionSyntax AddTypeRankSpecifiers(ArrayRankSpecifierSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax : CSharpSyntaxNode {
    private SyntaxNode sizes;
    public int Rank { get; }
    public SyntaxToken OpenBracketToken { get; }
    public SeparatedSyntaxList`1<ExpressionSyntax> Sizes { get; }
    public SyntaxToken CloseBracketToken { get; }
    internal ArrayRankSpecifierSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public int get_Rank();
    public SyntaxToken get_OpenBracketToken();
    public SeparatedSyntaxList`1<ExpressionSyntax> get_Sizes();
    public SyntaxToken get_CloseBracketToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ArrayRankSpecifierSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList`1<ExpressionSyntax> sizes, SyntaxToken closeBracketToken);
    public ArrayRankSpecifierSyntax WithOpenBracketToken(SyntaxToken openBracketToken);
    public ArrayRankSpecifierSyntax WithSizes(SeparatedSyntaxList`1<ExpressionSyntax> sizes);
    public ArrayRankSpecifierSyntax WithCloseBracketToken(SyntaxToken closeBracketToken);
    public ArrayRankSpecifierSyntax AddSizes(ExpressionSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax : TypeSyntax {
    private TypeSyntax elementType;
    private CSharpSyntaxNode rankSpecifiers;
    public TypeSyntax ElementType { get; }
    public SyntaxList`1<ArrayRankSpecifierSyntax> RankSpecifiers { get; }
    internal ArrayTypeSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public TypeSyntax get_ElementType();
    public SyntaxList`1<ArrayRankSpecifierSyntax> get_RankSpecifiers();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ArrayTypeSyntax Update(TypeSyntax elementType, SyntaxList`1<ArrayRankSpecifierSyntax> rankSpecifiers);
    public ArrayTypeSyntax WithElementType(TypeSyntax elementType);
    public ArrayTypeSyntax WithRankSpecifiers(SyntaxList`1<ArrayRankSpecifierSyntax> rankSpecifiers);
    public ArrayTypeSyntax AddRankSpecifiers(ArrayRankSpecifierSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax : CSharpSyntaxNode {
    private ExpressionSyntax expression;
    public SyntaxToken ArrowToken { get; }
    public ExpressionSyntax Expression { get; }
    internal ArrowExpressionClauseSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_ArrowToken();
    public ExpressionSyntax get_Expression();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ArrowExpressionClauseSyntax Update(SyntaxToken arrowToken, ExpressionSyntax expression);
    public ArrowExpressionClauseSyntax WithArrowToken(SyntaxToken arrowToken);
    public ArrowExpressionClauseSyntax WithExpression(ExpressionSyntax expression);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax : ExpressionSyntax {
    private ExpressionSyntax left;
    private ExpressionSyntax right;
    public ExpressionSyntax Left { get; }
    public SyntaxToken OperatorToken { get; }
    public ExpressionSyntax Right { get; }
    internal AssignmentExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public ExpressionSyntax get_Left();
    public SyntaxToken get_OperatorToken();
    public ExpressionSyntax get_Right();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AssignmentExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public AssignmentExpressionSyntax WithLeft(ExpressionSyntax left);
    public AssignmentExpressionSyntax WithOperatorToken(SyntaxToken operatorToken);
    public AssignmentExpressionSyntax WithRight(ExpressionSyntax right);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax : CSharpSyntaxNode {
    private SyntaxNode arguments;
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxList`1<AttributeArgumentSyntax> Arguments { get; }
    public SyntaxToken CloseParenToken { get; }
    internal AttributeArgumentListSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OpenParenToken();
    public SeparatedSyntaxList`1<AttributeArgumentSyntax> get_Arguments();
    public SyntaxToken get_CloseParenToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AttributeArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList`1<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken);
    public AttributeArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public AttributeArgumentListSyntax WithArguments(SeparatedSyntaxList`1<AttributeArgumentSyntax> arguments);
    public AttributeArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    public AttributeArgumentListSyntax AddArguments(AttributeArgumentSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax : CSharpSyntaxNode {
    private NameEqualsSyntax nameEquals;
    private NameColonSyntax nameColon;
    private ExpressionSyntax expression;
    public NameEqualsSyntax NameEquals { get; }
    public NameColonSyntax NameColon { get; }
    public ExpressionSyntax Expression { get; }
    internal AttributeArgumentSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public NameEqualsSyntax get_NameEquals();
    public NameColonSyntax get_NameColon();
    public ExpressionSyntax get_Expression();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AttributeArgumentSyntax Update(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression);
    public AttributeArgumentSyntax WithNameEquals(NameEqualsSyntax nameEquals);
    public AttributeArgumentSyntax WithNameColon(NameColonSyntax nameColon);
    public AttributeArgumentSyntax WithExpression(ExpressionSyntax expression);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax : CSharpSyntaxNode {
    private AttributeTargetSpecifierSyntax target;
    private SyntaxNode attributes;
    public SyntaxToken OpenBracketToken { get; }
    public AttributeTargetSpecifierSyntax Target { get; }
    public SeparatedSyntaxList`1<AttributeSyntax> Attributes { get; }
    public SyntaxToken CloseBracketToken { get; }
    internal AttributeListSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OpenBracketToken();
    public AttributeTargetSpecifierSyntax get_Target();
    public SeparatedSyntaxList`1<AttributeSyntax> get_Attributes();
    public SyntaxToken get_CloseBracketToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AttributeListSyntax Update(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList`1<AttributeSyntax> attributes, SyntaxToken closeBracketToken);
    public AttributeListSyntax WithOpenBracketToken(SyntaxToken openBracketToken);
    public AttributeListSyntax WithTarget(AttributeTargetSpecifierSyntax target);
    public AttributeListSyntax WithAttributes(SeparatedSyntaxList`1<AttributeSyntax> attributes);
    public AttributeListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken);
    public AttributeListSyntax AddAttributes(AttributeSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax : CSharpSyntaxNode {
    private NameSyntax name;
    private AttributeArgumentListSyntax argumentList;
    public NameSyntax Name { get; }
    public AttributeArgumentListSyntax ArgumentList { get; }
    internal AttributeSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    internal string GetErrorDisplayName();
    internal AttributeArgumentSyntax GetNamedArgumentSyntax(string namedArgName);
    public NameSyntax get_Name();
    public AttributeArgumentListSyntax get_ArgumentList();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AttributeSyntax Update(NameSyntax name, AttributeArgumentListSyntax argumentList);
    public AttributeSyntax WithName(NameSyntax name);
    public AttributeSyntax WithArgumentList(AttributeArgumentListSyntax argumentList);
    public AttributeSyntax AddArgumentListArguments(AttributeArgumentSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax : CSharpSyntaxNode {
    public SyntaxToken Identifier { get; }
    public SyntaxToken ColonToken { get; }
    internal AttributeTargetSpecifierSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    internal AttributeLocation GetAttributeLocation();
    public SyntaxToken get_Identifier();
    public SyntaxToken get_ColonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AttributeTargetSpecifierSyntax Update(SyntaxToken identifier, SyntaxToken colonToken);
    public AttributeTargetSpecifierSyntax WithIdentifier(SyntaxToken identifier);
    public AttributeTargetSpecifierSyntax WithColonToken(SyntaxToken colonToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax : ExpressionSyntax {
    private ExpressionSyntax expression;
    public SyntaxToken AwaitKeyword { get; }
    public ExpressionSyntax Expression { get; }
    internal AwaitExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_AwaitKeyword();
    public ExpressionSyntax get_Expression();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AwaitExpressionSyntax Update(SyntaxToken awaitKeyword, ExpressionSyntax expression);
    public AwaitExpressionSyntax WithAwaitKeyword(SyntaxToken awaitKeyword);
    public AwaitExpressionSyntax WithExpression(ExpressionSyntax expression);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken Identifier { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal BadDirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_Identifier();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public BadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive);
    public BadDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public BadDirectiveTriviaSyntax WithIdentifier(SyntaxToken identifier);
    public BadDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public BadDirectiveTriviaSyntax WithIsActive(bool isActive);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseArgumentListSyntax : CSharpSyntaxNode {
    public SeparatedSyntaxList`1<ArgumentSyntax> Arguments { get; }
    internal BaseArgumentListSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public abstract virtual SeparatedSyntaxList`1<ArgumentSyntax> get_Arguments();
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseCrefParameterListSyntax : CSharpSyntaxNode {
    public SeparatedSyntaxList`1<CrefParameterSyntax> Parameters { get; }
    internal BaseCrefParameterListSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public abstract virtual SeparatedSyntaxList`1<CrefParameterSyntax> get_Parameters();
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax : InstanceExpressionSyntax {
    public SyntaxToken Token { get; }
    internal BaseExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_Token();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public BaseExpressionSyntax Update(SyntaxToken token);
    public BaseExpressionSyntax WithToken(SyntaxToken token);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax : MemberDeclarationSyntax {
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public VariableDeclarationSyntax Declaration { get; }
    public SyntaxToken SemicolonToken { get; }
    internal BaseFieldDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public abstract virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public abstract virtual SyntaxTokenList get_Modifiers();
    public abstract virtual VariableDeclarationSyntax get_Declaration();
    public abstract virtual SyntaxToken get_SemicolonToken();
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax : CSharpSyntaxNode {
    private SyntaxNode types;
    public SyntaxToken ColonToken { get; }
    public SeparatedSyntaxList`1<BaseTypeSyntax> Types { get; }
    internal BaseListSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_ColonToken();
    public SeparatedSyntaxList`1<BaseTypeSyntax> get_Types();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public BaseListSyntax Update(SyntaxToken colonToken, SeparatedSyntaxList`1<BaseTypeSyntax> types);
    public BaseListSyntax WithColonToken(SyntaxToken colonToken);
    public BaseListSyntax WithTypes(SeparatedSyntaxList`1<BaseTypeSyntax> types);
    public BaseListSyntax AddTypes(BaseTypeSyntax[] items);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax : MemberDeclarationSyntax {
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public ParameterListSyntax ParameterList { get; }
    public BlockSyntax Body { get; }
    public SyntaxToken SemicolonToken { get; }
    internal BaseMethodDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public abstract virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public abstract virtual SyntaxTokenList get_Modifiers();
    public abstract virtual ParameterListSyntax get_ParameterList();
    public abstract virtual BlockSyntax get_Body();
    public abstract virtual SyntaxToken get_SemicolonToken();
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterListSyntax : CSharpSyntaxNode {
    public SeparatedSyntaxList`1<ParameterSyntax> Parameters { get; }
    internal BaseParameterListSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public abstract virtual SeparatedSyntaxList`1<ParameterSyntax> get_Parameters();
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax : MemberDeclarationSyntax {
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public TypeSyntax Type { get; }
    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }
    public AccessorListSyntax AccessorList { get; }
    internal BasePropertyDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public abstract virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public abstract virtual SyntaxTokenList get_Modifiers();
    public abstract virtual TypeSyntax get_Type();
    public abstract virtual ExplicitInterfaceSpecifierSyntax get_ExplicitInterfaceSpecifier();
    public abstract virtual AccessorListSyntax get_AccessorList();
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax : MemberDeclarationSyntax {
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken Identifier { get; }
    public BaseListSyntax BaseList { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxToken CloseBraceToken { get; }
    public SyntaxToken SemicolonToken { get; }
    internal BaseTypeDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public abstract virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public abstract virtual SyntaxTokenList get_Modifiers();
    public abstract virtual SyntaxToken get_Identifier();
    public abstract virtual BaseListSyntax get_BaseList();
    public abstract virtual SyntaxToken get_OpenBraceToken();
    public abstract virtual SyntaxToken get_CloseBraceToken();
    public abstract virtual SyntaxToken get_SemicolonToken();
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax : CSharpSyntaxNode {
    public TypeSyntax Type { get; }
    internal BaseTypeSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public abstract virtual TypeSyntax get_Type();
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax : ExpressionSyntax {
    private ExpressionSyntax left;
    private ExpressionSyntax right;
    public ExpressionSyntax Left { get; }
    public SyntaxToken OperatorToken { get; }
    public ExpressionSyntax Right { get; }
    internal BinaryExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public ExpressionSyntax get_Left();
    public SyntaxToken get_OperatorToken();
    public ExpressionSyntax get_Right();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public BinaryExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public BinaryExpressionSyntax WithLeft(ExpressionSyntax left);
    public BinaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken);
    public BinaryExpressionSyntax WithRight(ExpressionSyntax right);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax : StatementSyntax {
    private CSharpSyntaxNode statements;
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    public SyntaxToken CloseBraceToken { get; }
    internal BlockSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OpenBraceToken();
    public SyntaxList`1<StatementSyntax> get_Statements();
    public SyntaxToken get_CloseBraceToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public BlockSyntax Update(SyntaxToken openBraceToken, SyntaxList`1<StatementSyntax> statements, SyntaxToken closeBraceToken);
    public BlockSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
    public BlockSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public BlockSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
    public BlockSyntax AddStatements(StatementSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax : BaseArgumentListSyntax {
    private SyntaxNode arguments;
    public SyntaxToken OpenBracketToken { get; }
    public SeparatedSyntaxList`1<ArgumentSyntax> Arguments { get; }
    public SyntaxToken CloseBracketToken { get; }
    internal BracketedArgumentListSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OpenBracketToken();
    public virtual SeparatedSyntaxList`1<ArgumentSyntax> get_Arguments();
    public SyntaxToken get_CloseBracketToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public BracketedArgumentListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList`1<ArgumentSyntax> arguments, SyntaxToken closeBracketToken);
    public BracketedArgumentListSyntax WithOpenBracketToken(SyntaxToken openBracketToken);
    public BracketedArgumentListSyntax WithArguments(SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    public BracketedArgumentListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken);
    public BracketedArgumentListSyntax AddArguments(ArgumentSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax : BaseParameterListSyntax {
    private SyntaxNode parameters;
    public SyntaxToken OpenBracketToken { get; }
    public SeparatedSyntaxList`1<ParameterSyntax> Parameters { get; }
    public SyntaxToken CloseBracketToken { get; }
    internal BracketedParameterListSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OpenBracketToken();
    public virtual SeparatedSyntaxList`1<ParameterSyntax> get_Parameters();
    public SyntaxToken get_CloseBracketToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public BracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList`1<ParameterSyntax> parameters, SyntaxToken closeBracketToken);
    public BracketedParameterListSyntax WithOpenBracketToken(SyntaxToken openBracketToken);
    public BracketedParameterListSyntax WithParameters(SeparatedSyntaxList`1<ParameterSyntax> parameters);
    public BracketedParameterListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken);
    public BracketedParameterListSyntax AddParameters(ParameterSyntax[] items);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.BranchingDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public bool BranchTaken { get; }
    internal BranchingDirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public abstract virtual bool get_BranchTaken();
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax : StatementSyntax {
    public SyntaxToken BreakKeyword { get; }
    public SyntaxToken SemicolonToken { get; }
    internal BreakStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_BreakKeyword();
    public SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public BreakStatementSyntax Update(SyntaxToken breakKeyword, SyntaxToken semicolonToken);
    public BreakStatementSyntax WithBreakKeyword(SyntaxToken breakKeyword);
    public BreakStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax : SwitchLabelSyntax {
    private ExpressionSyntax value;
    public SyntaxToken Keyword { get; }
    public ExpressionSyntax Value { get; }
    public SyntaxToken ColonToken { get; }
    internal CaseSwitchLabelSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_Keyword();
    public ExpressionSyntax get_Value();
    public virtual SyntaxToken get_ColonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CaseSwitchLabelSyntax Update(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken);
    public CaseSwitchLabelSyntax WithKeyword(SyntaxToken keyword);
    public CaseSwitchLabelSyntax WithValue(ExpressionSyntax value);
    public CaseSwitchLabelSyntax WithColonToken(SyntaxToken colonToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax : ExpressionSyntax {
    private TypeSyntax type;
    private ExpressionSyntax expression;
    public SyntaxToken OpenParenToken { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken CloseParenToken { get; }
    public ExpressionSyntax Expression { get; }
    internal CastExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OpenParenToken();
    public TypeSyntax get_Type();
    public SyntaxToken get_CloseParenToken();
    public ExpressionSyntax get_Expression();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CastExpressionSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression);
    public CastExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public CastExpressionSyntax WithType(TypeSyntax type);
    public CastExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    public CastExpressionSyntax WithExpression(ExpressionSyntax expression);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax : CSharpSyntaxNode {
    private CatchDeclarationSyntax declaration;
    private CatchFilterClauseSyntax filter;
    private BlockSyntax block;
    public SyntaxToken CatchKeyword { get; }
    public CatchDeclarationSyntax Declaration { get; }
    public CatchFilterClauseSyntax Filter { get; }
    public BlockSyntax Block { get; }
    internal CatchClauseSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_CatchKeyword();
    public CatchDeclarationSyntax get_Declaration();
    public CatchFilterClauseSyntax get_Filter();
    public BlockSyntax get_Block();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CatchClauseSyntax Update(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block);
    public CatchClauseSyntax WithCatchKeyword(SyntaxToken catchKeyword);
    public CatchClauseSyntax WithDeclaration(CatchDeclarationSyntax declaration);
    public CatchClauseSyntax WithFilter(CatchFilterClauseSyntax filter);
    public CatchClauseSyntax WithBlock(BlockSyntax block);
    public CatchClauseSyntax AddBlockStatements(StatementSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax : CSharpSyntaxNode {
    private TypeSyntax type;
    public SyntaxToken OpenParenToken { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken Identifier { get; }
    public SyntaxToken CloseParenToken { get; }
    internal CatchDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OpenParenToken();
    public TypeSyntax get_Type();
    public SyntaxToken get_Identifier();
    public SyntaxToken get_CloseParenToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CatchDeclarationSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken);
    public CatchDeclarationSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public CatchDeclarationSyntax WithType(TypeSyntax type);
    public CatchDeclarationSyntax WithIdentifier(SyntaxToken identifier);
    public CatchDeclarationSyntax WithCloseParenToken(SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax : CSharpSyntaxNode {
    private ExpressionSyntax filterExpression;
    public SyntaxToken WhenKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax FilterExpression { get; }
    public SyntaxToken CloseParenToken { get; }
    internal CatchFilterClauseSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_WhenKeyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_FilterExpression();
    public SyntaxToken get_CloseParenToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CatchFilterClauseSyntax Update(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken);
    public CatchFilterClauseSyntax WithWhenKeyword(SyntaxToken whenKeyword);
    public CatchFilterClauseSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public CatchFilterClauseSyntax WithFilterExpression(ExpressionSyntax filterExpression);
    public CatchFilterClauseSyntax WithCloseParenToken(SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax : ExpressionSyntax {
    private ExpressionSyntax expression;
    public SyntaxToken Keyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    internal CheckedExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_Keyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CheckedExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public CheckedExpressionSyntax WithKeyword(SyntaxToken keyword);
    public CheckedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public CheckedExpressionSyntax WithExpression(ExpressionSyntax expression);
    public CheckedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax : StatementSyntax {
    private BlockSyntax block;
    public SyntaxToken Keyword { get; }
    public BlockSyntax Block { get; }
    internal CheckedStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_Keyword();
    public BlockSyntax get_Block();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CheckedStatementSyntax Update(SyntaxToken keyword, BlockSyntax block);
    public CheckedStatementSyntax WithKeyword(SyntaxToken keyword);
    public CheckedStatementSyntax WithBlock(BlockSyntax block);
    public CheckedStatementSyntax AddBlockStatements(StatementSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax : TypeDeclarationSyntax {
    private CSharpSyntaxNode attributeLists;
    private TypeParameterListSyntax typeParameterList;
    private BaseListSyntax baseList;
    private CSharpSyntaxNode constraintClauses;
    private CSharpSyntaxNode members;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken Keyword { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public BaseListSyntax BaseList { get; }
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    public SyntaxToken CloseBraceToken { get; }
    public SyntaxToken SemicolonToken { get; }
    internal ClassDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxTokenList get_Modifiers();
    public virtual SyntaxToken get_Keyword();
    public virtual SyntaxToken get_Identifier();
    public virtual TypeParameterListSyntax get_TypeParameterList();
    public virtual BaseListSyntax get_BaseList();
    public virtual SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public virtual SyntaxToken get_OpenBraceToken();
    public virtual SyntaxList`1<MemberDeclarationSyntax> get_Members();
    public virtual SyntaxToken get_CloseBraceToken();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ClassDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public ClassDeclarationSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public ClassDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
    public ClassDeclarationSyntax WithKeyword(SyntaxToken keyword);
    public ClassDeclarationSyntax WithIdentifier(SyntaxToken identifier);
    public ClassDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList);
    public ClassDeclarationSyntax WithBaseList(BaseListSyntax baseList);
    public ClassDeclarationSyntax WithConstraintClauses(SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses);
    public ClassDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
    public ClassDeclarationSyntax WithMembers(SyntaxList`1<MemberDeclarationSyntax> members);
    public ClassDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
    public ClassDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
    public ClassDeclarationSyntax AddAttributeLists(AttributeListSyntax[] items);
    public ClassDeclarationSyntax AddModifiers(SyntaxToken[] items);
    public ClassDeclarationSyntax AddTypeParameterListParameters(TypeParameterSyntax[] items);
    public ClassDeclarationSyntax AddBaseListTypes(BaseTypeSyntax[] items);
    public ClassDeclarationSyntax AddConstraintClauses(TypeParameterConstraintClauseSyntax[] items);
    public ClassDeclarationSyntax AddMembers(MemberDeclarationSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax : TypeParameterConstraintSyntax {
    public SyntaxToken ClassOrStructKeyword { get; }
    internal ClassOrStructConstraintSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_ClassOrStructKeyword();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ClassOrStructConstraintSyntax Update(SyntaxToken classOrStructKeyword);
    public ClassOrStructConstraintSyntax WithClassOrStructKeyword(SyntaxToken classOrStructKeyword);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax : CSharpSyntaxNode {
    private CSharpSyntaxNode externs;
    private CSharpSyntaxNode usings;
    private CSharpSyntaxNode attributeLists;
    private CSharpSyntaxNode members;
    public SyntaxList`1<ExternAliasDirectiveSyntax> Externs { get; }
    public SyntaxList`1<UsingDirectiveSyntax> Usings { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    public SyntaxToken EndOfFileToken { get; }
    internal CompilationUnitSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public IList`1<ReferenceDirectiveTriviaSyntax> GetReferenceDirectives();
    internal IList`1<ReferenceDirectiveTriviaSyntax> GetReferenceDirectives(Func`2<ReferenceDirectiveTriviaSyntax, bool> filter);
    public IList`1<LoadDirectiveTriviaSyntax> GetLoadDirectives();
    internal DirectiveStack GetConditionalDirectivesStack();
    private static bool IsActiveConditionalDirective(DirectiveTriviaSyntax directive);
    public SyntaxList`1<ExternAliasDirectiveSyntax> get_Externs();
    public SyntaxList`1<UsingDirectiveSyntax> get_Usings();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxList`1<MemberDeclarationSyntax> get_Members();
    public sealed virtual SyntaxToken get_EndOfFileToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CompilationUnitSyntax Update(SyntaxList`1<ExternAliasDirectiveSyntax> externs, SyntaxList`1<UsingDirectiveSyntax> usings, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken);
    public CompilationUnitSyntax WithExterns(SyntaxList`1<ExternAliasDirectiveSyntax> externs);
    public CompilationUnitSyntax WithUsings(SyntaxList`1<UsingDirectiveSyntax> usings);
    public CompilationUnitSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public CompilationUnitSyntax WithMembers(SyntaxList`1<MemberDeclarationSyntax> members);
    public CompilationUnitSyntax WithEndOfFileToken(SyntaxToken endOfFileToken);
    public CompilationUnitSyntax AddExterns(ExternAliasDirectiveSyntax[] items);
    public CompilationUnitSyntax AddUsings(UsingDirectiveSyntax[] items);
    public CompilationUnitSyntax AddAttributeLists(AttributeListSyntax[] items);
    public CompilationUnitSyntax AddMembers(MemberDeclarationSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax : ExpressionSyntax {
    private ExpressionSyntax expression;
    private ExpressionSyntax whenNotNull;
    public ExpressionSyntax Expression { get; }
    public SyntaxToken OperatorToken { get; }
    public ExpressionSyntax WhenNotNull { get; }
    internal ConditionalAccessExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_OperatorToken();
    public ExpressionSyntax get_WhenNotNull();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ConditionalAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull);
    public ConditionalAccessExpressionSyntax WithExpression(ExpressionSyntax expression);
    public ConditionalAccessExpressionSyntax WithOperatorToken(SyntaxToken operatorToken);
    public ConditionalAccessExpressionSyntax WithWhenNotNull(ExpressionSyntax whenNotNull);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax {
    public ExpressionSyntax Condition { get; }
    public bool ConditionValue { get; }
    internal ConditionalDirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public abstract virtual ExpressionSyntax get_Condition();
    public abstract virtual bool get_ConditionValue();
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax : ExpressionSyntax {
    private ExpressionSyntax condition;
    private ExpressionSyntax whenTrue;
    private ExpressionSyntax whenFalse;
    public ExpressionSyntax Condition { get; }
    public SyntaxToken QuestionToken { get; }
    public ExpressionSyntax WhenTrue { get; }
    public SyntaxToken ColonToken { get; }
    public ExpressionSyntax WhenFalse { get; }
    internal ConditionalExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public ExpressionSyntax get_Condition();
    public SyntaxToken get_QuestionToken();
    public ExpressionSyntax get_WhenTrue();
    public SyntaxToken get_ColonToken();
    public ExpressionSyntax get_WhenFalse();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ConditionalExpressionSyntax Update(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse);
    public ConditionalExpressionSyntax WithCondition(ExpressionSyntax condition);
    public ConditionalExpressionSyntax WithQuestionToken(SyntaxToken questionToken);
    public ConditionalExpressionSyntax WithWhenTrue(ExpressionSyntax whenTrue);
    public ConditionalExpressionSyntax WithColonToken(SyntaxToken colonToken);
    public ConditionalExpressionSyntax WithWhenFalse(ExpressionSyntax whenFalse);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax : TypeParameterConstraintSyntax {
    public SyntaxToken NewKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public SyntaxToken CloseParenToken { get; }
    internal ConstructorConstraintSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_NewKeyword();
    public SyntaxToken get_OpenParenToken();
    public SyntaxToken get_CloseParenToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ConstructorConstraintSyntax Update(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken);
    public ConstructorConstraintSyntax WithNewKeyword(SyntaxToken newKeyword);
    public ConstructorConstraintSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public ConstructorConstraintSyntax WithCloseParenToken(SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax : BaseMethodDeclarationSyntax {
    private CSharpSyntaxNode attributeLists;
    private ParameterListSyntax parameterList;
    private ConstructorInitializerSyntax initializer;
    private BlockSyntax body;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken Identifier { get; }
    public ParameterListSyntax ParameterList { get; }
    public ConstructorInitializerSyntax Initializer { get; }
    public BlockSyntax Body { get; }
    public SyntaxToken SemicolonToken { get; }
    internal ConstructorDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxTokenList get_Modifiers();
    public SyntaxToken get_Identifier();
    public virtual ParameterListSyntax get_ParameterList();
    public ConstructorInitializerSyntax get_Initializer();
    public virtual BlockSyntax get_Body();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ConstructorDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken);
    public ConstructorDeclarationSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public ConstructorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
    public ConstructorDeclarationSyntax WithIdentifier(SyntaxToken identifier);
    public ConstructorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList);
    public ConstructorDeclarationSyntax WithInitializer(ConstructorInitializerSyntax initializer);
    public ConstructorDeclarationSyntax WithBody(BlockSyntax body);
    public ConstructorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
    public ConstructorDeclarationSyntax AddAttributeLists(AttributeListSyntax[] items);
    public ConstructorDeclarationSyntax AddModifiers(SyntaxToken[] items);
    public ConstructorDeclarationSyntax AddParameterListParameters(ParameterSyntax[] items);
    public ConstructorDeclarationSyntax AddBodyStatements(StatementSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax : CSharpSyntaxNode {
    private ArgumentListSyntax argumentList;
    public SyntaxToken ColonToken { get; }
    public SyntaxToken ThisOrBaseKeyword { get; }
    public ArgumentListSyntax ArgumentList { get; }
    internal ConstructorInitializerSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_ColonToken();
    public SyntaxToken get_ThisOrBaseKeyword();
    public ArgumentListSyntax get_ArgumentList();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ConstructorInitializerSyntax Update(SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList);
    public ConstructorInitializerSyntax WithColonToken(SyntaxToken colonToken);
    public ConstructorInitializerSyntax WithThisOrBaseKeyword(SyntaxToken thisOrBaseKeyword);
    public ConstructorInitializerSyntax WithArgumentList(ArgumentListSyntax argumentList);
    public ConstructorInitializerSyntax AddArgumentListArguments(ArgumentSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax : StatementSyntax {
    public SyntaxToken ContinueKeyword { get; }
    public SyntaxToken SemicolonToken { get; }
    internal ContinueStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_ContinueKeyword();
    public SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ContinueStatementSyntax Update(SyntaxToken continueKeyword, SyntaxToken semicolonToken);
    public ContinueStatementSyntax WithContinueKeyword(SyntaxToken continueKeyword);
    public ContinueStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax : BaseMethodDeclarationSyntax {
    private CSharpSyntaxNode attributeLists;
    private TypeSyntax type;
    private ParameterListSyntax parameterList;
    private BlockSyntax body;
    private ArrowExpressionClauseSyntax expressionBody;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken ImplicitOrExplicitKeyword { get; }
    public SyntaxToken OperatorKeyword { get; }
    public TypeSyntax Type { get; }
    public ParameterListSyntax ParameterList { get; }
    public BlockSyntax Body { get; }
    public ArrowExpressionClauseSyntax ExpressionBody { get; }
    public SyntaxToken SemicolonToken { get; }
    internal ConversionOperatorDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxTokenList get_Modifiers();
    public SyntaxToken get_ImplicitOrExplicitKeyword();
    public SyntaxToken get_OperatorKeyword();
    public TypeSyntax get_Type();
    public virtual ParameterListSyntax get_ParameterList();
    public virtual BlockSyntax get_Body();
    public ArrowExpressionClauseSyntax get_ExpressionBody();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ConversionOperatorDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public ConversionOperatorDeclarationSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public ConversionOperatorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
    public ConversionOperatorDeclarationSyntax WithImplicitOrExplicitKeyword(SyntaxToken implicitOrExplicitKeyword);
    public ConversionOperatorDeclarationSyntax WithOperatorKeyword(SyntaxToken operatorKeyword);
    public ConversionOperatorDeclarationSyntax WithType(TypeSyntax type);
    public ConversionOperatorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList);
    public ConversionOperatorDeclarationSyntax WithBody(BlockSyntax body);
    public ConversionOperatorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody);
    public ConversionOperatorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
    public ConversionOperatorDeclarationSyntax AddAttributeLists(AttributeListSyntax[] items);
    public ConversionOperatorDeclarationSyntax AddModifiers(SyntaxToken[] items);
    public ConversionOperatorDeclarationSyntax AddParameterListParameters(ParameterSyntax[] items);
    public ConversionOperatorDeclarationSyntax AddBodyStatements(StatementSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax : MemberCrefSyntax {
    private TypeSyntax type;
    private CrefParameterListSyntax parameters;
    public SyntaxToken ImplicitOrExplicitKeyword { get; }
    public SyntaxToken OperatorKeyword { get; }
    public TypeSyntax Type { get; }
    public CrefParameterListSyntax Parameters { get; }
    internal ConversionOperatorMemberCrefSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_ImplicitOrExplicitKeyword();
    public SyntaxToken get_OperatorKeyword();
    public TypeSyntax get_Type();
    public CrefParameterListSyntax get_Parameters();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ConversionOperatorMemberCrefSyntax Update(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters);
    public ConversionOperatorMemberCrefSyntax WithImplicitOrExplicitKeyword(SyntaxToken implicitOrExplicitKeyword);
    public ConversionOperatorMemberCrefSyntax WithOperatorKeyword(SyntaxToken operatorKeyword);
    public ConversionOperatorMemberCrefSyntax WithType(TypeSyntax type);
    public ConversionOperatorMemberCrefSyntax WithParameters(CrefParameterListSyntax parameters);
    public ConversionOperatorMemberCrefSyntax AddParametersParameters(CrefParameterSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax : BaseCrefParameterListSyntax {
    private SyntaxNode parameters;
    public SyntaxToken OpenBracketToken { get; }
    public SeparatedSyntaxList`1<CrefParameterSyntax> Parameters { get; }
    public SyntaxToken CloseBracketToken { get; }
    internal CrefBracketedParameterListSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OpenBracketToken();
    public virtual SeparatedSyntaxList`1<CrefParameterSyntax> get_Parameters();
    public SyntaxToken get_CloseBracketToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CrefBracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList`1<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken);
    public CrefBracketedParameterListSyntax WithOpenBracketToken(SyntaxToken openBracketToken);
    public CrefBracketedParameterListSyntax WithParameters(SeparatedSyntaxList`1<CrefParameterSyntax> parameters);
    public CrefBracketedParameterListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken);
    public CrefBracketedParameterListSyntax AddParameters(CrefParameterSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax : BaseCrefParameterListSyntax {
    private SyntaxNode parameters;
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxList`1<CrefParameterSyntax> Parameters { get; }
    public SyntaxToken CloseParenToken { get; }
    internal CrefParameterListSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OpenParenToken();
    public virtual SeparatedSyntaxList`1<CrefParameterSyntax> get_Parameters();
    public SyntaxToken get_CloseParenToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CrefParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList`1<CrefParameterSyntax> parameters, SyntaxToken closeParenToken);
    public CrefParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public CrefParameterListSyntax WithParameters(SeparatedSyntaxList`1<CrefParameterSyntax> parameters);
    public CrefParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    public CrefParameterListSyntax AddParameters(CrefParameterSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax : CSharpSyntaxNode {
    private TypeSyntax type;
    public SyntaxToken RefOrOutKeyword { get; }
    public TypeSyntax Type { get; }
    internal CrefParameterSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_RefOrOutKeyword();
    public TypeSyntax get_Type();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CrefParameterSyntax Update(SyntaxToken refOrOutKeyword, TypeSyntax type);
    public CrefParameterSyntax WithRefOrOutKeyword(SyntaxToken refOrOutKeyword);
    public CrefParameterSyntax WithType(TypeSyntax type);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax : CSharpSyntaxNode {
    internal CrefSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.CSharpLineDirectiveMap : LineDirectiveMap`1<DirectiveTriviaSyntax> {
    public CSharpLineDirectiveMap(SyntaxTree syntaxTree);
    protected virtual bool ShouldAddDirective(DirectiveTriviaSyntax directive);
    protected virtual LineMappingEntry<DirectiveTriviaSyntax> GetEntry(DirectiveTriviaSyntax directiveNode, SourceText sourceText, LineMappingEntry<DirectiveTriviaSyntax> previous);
    protected virtual LineMappingEntry<DirectiveTriviaSyntax> InitializeFirstEntry();
    public virtual LineVisibility GetLineVisibility(SourceText sourceText, int position);
    internal virtual FileLinePositionSpan TranslateSpanAndVisibility(SourceText sourceText, string treeFilePath, TextSpan span, Boolean& isHiddenPosition);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.CSharpPragmaWarningStateMap : AbstractWarningStateMap {
    public CSharpPragmaWarningStateMap(SyntaxTree syntaxTree);
    protected virtual WarningStateMapEntry[] CreateWarningStateMapEntries(SyntaxTree syntaxTree);
    private static void GetAllPragmaWarningDirectives(SyntaxTree syntaxTree, ArrayBuilder`1<PragmaWarningDirectiveTriviaSyntax> directiveList);
    private static WarningStateMapEntry[] CreatePragmaWarningStateEntries(ImmutableArray`1<PragmaWarningDirectiveTriviaSyntax> directiveList);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax : ExpressionSyntax {
    private TypeSyntax type;
    public SyntaxToken Keyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken CloseParenToken { get; }
    internal DefaultExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_Keyword();
    public SyntaxToken get_OpenParenToken();
    public TypeSyntax get_Type();
    public SyntaxToken get_CloseParenToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public DefaultExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    public DefaultExpressionSyntax WithKeyword(SyntaxToken keyword);
    public DefaultExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public DefaultExpressionSyntax WithType(TypeSyntax type);
    public DefaultExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax : SwitchLabelSyntax {
    public SyntaxToken Keyword { get; }
    public SyntaxToken ColonToken { get; }
    internal DefaultSwitchLabelSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_Keyword();
    public virtual SyntaxToken get_ColonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public DefaultSwitchLabelSyntax Update(SyntaxToken keyword, SyntaxToken colonToken);
    public DefaultSwitchLabelSyntax WithKeyword(SyntaxToken keyword);
    public DefaultSwitchLabelSyntax WithColonToken(SyntaxToken colonToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken DefineKeyword { get; }
    public SyntaxToken Name { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal DefineDirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_DefineKeyword();
    public SyntaxToken get_Name();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public DefineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive);
    public DefineDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public DefineDirectiveTriviaSyntax WithDefineKeyword(SyntaxToken defineKeyword);
    public DefineDirectiveTriviaSyntax WithName(SyntaxToken name);
    public DefineDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public DefineDirectiveTriviaSyntax WithIsActive(bool isActive);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax : MemberDeclarationSyntax {
    private CSharpSyntaxNode attributeLists;
    private TypeSyntax returnType;
    private TypeParameterListSyntax typeParameterList;
    private ParameterListSyntax parameterList;
    private CSharpSyntaxNode constraintClauses;
    public int Arity { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken DelegateKeyword { get; }
    public TypeSyntax ReturnType { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public ParameterListSyntax ParameterList { get; }
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public SyntaxToken SemicolonToken { get; }
    internal DelegateDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public int get_Arity();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxTokenList get_Modifiers();
    public SyntaxToken get_DelegateKeyword();
    public TypeSyntax get_ReturnType();
    public SyntaxToken get_Identifier();
    public TypeParameterListSyntax get_TypeParameterList();
    public ParameterListSyntax get_ParameterList();
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public DelegateDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken);
    public DelegateDeclarationSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public DelegateDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
    public DelegateDeclarationSyntax WithDelegateKeyword(SyntaxToken delegateKeyword);
    public DelegateDeclarationSyntax WithReturnType(TypeSyntax returnType);
    public DelegateDeclarationSyntax WithIdentifier(SyntaxToken identifier);
    public DelegateDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList);
    public DelegateDeclarationSyntax WithParameterList(ParameterListSyntax parameterList);
    public DelegateDeclarationSyntax WithConstraintClauses(SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses);
    public DelegateDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
    public DelegateDeclarationSyntax AddAttributeLists(AttributeListSyntax[] items);
    public DelegateDeclarationSyntax AddModifiers(SyntaxToken[] items);
    public DelegateDeclarationSyntax AddTypeParameterListParameters(TypeParameterSyntax[] items);
    public DelegateDeclarationSyntax AddParameterListParameters(ParameterSyntax[] items);
    public DelegateDeclarationSyntax AddConstraintClauses(TypeParameterConstraintClauseSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax : BaseMethodDeclarationSyntax {
    private CSharpSyntaxNode attributeLists;
    private ParameterListSyntax parameterList;
    private BlockSyntax body;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken TildeToken { get; }
    public SyntaxToken Identifier { get; }
    public ParameterListSyntax ParameterList { get; }
    public BlockSyntax Body { get; }
    public SyntaxToken SemicolonToken { get; }
    internal DestructorDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxTokenList get_Modifiers();
    public SyntaxToken get_TildeToken();
    public SyntaxToken get_Identifier();
    public virtual ParameterListSyntax get_ParameterList();
    public virtual BlockSyntax get_Body();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public DestructorDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken);
    public DestructorDeclarationSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public DestructorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
    public DestructorDeclarationSyntax WithTildeToken(SyntaxToken tildeToken);
    public DestructorDeclarationSyntax WithIdentifier(SyntaxToken identifier);
    public DestructorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList);
    public DestructorDeclarationSyntax WithBody(BlockSyntax body);
    public DestructorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
    public DestructorDeclarationSyntax AddAttributeLists(AttributeListSyntax[] items);
    public DestructorDeclarationSyntax AddModifiers(SyntaxToken[] items);
    public DestructorDeclarationSyntax AddParameterListParameters(ParameterSyntax[] items);
    public DestructorDeclarationSyntax AddBodyStatements(StatementSyntax[] items);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax : StructuredTriviaSyntax {
    private static Func`2<SyntaxToken, bool> s_hasDirectivesFunction;
    public SyntaxToken DirectiveNameToken { get; }
    public SyntaxToken HashToken { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal DirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    private static DirectiveTriviaSyntax();
    public SyntaxToken get_DirectiveNameToken();
    public DirectiveTriviaSyntax GetNextDirective(Func`2<DirectiveTriviaSyntax, bool> predicate);
    public DirectiveTriviaSyntax GetPreviousDirective(Func`2<DirectiveTriviaSyntax, bool> predicate);
    public List`1<DirectiveTriviaSyntax> GetRelatedDirectives();
    private void GetRelatedDirectives(List`1<DirectiveTriviaSyntax> list);
    private DirectiveTriviaSyntax GetNextRelatedDirective();
    private DirectiveTriviaSyntax GetNextPossiblyRelatedDirective();
    private DirectiveTriviaSyntax GetPreviousRelatedDirective();
    private DirectiveTriviaSyntax GetPreviousPossiblyRelatedDirective();
    public abstract virtual SyntaxToken get_HashToken();
    public abstract virtual SyntaxToken get_EndOfDirectiveToken();
    public abstract virtual bool get_IsActive();
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax : StructuredTriviaSyntax {
    private CSharpSyntaxNode content;
    public SyntaxList`1<XmlNodeSyntax> Content { get; }
    public SyntaxToken EndOfComment { get; }
    internal DocumentationCommentTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxList`1<XmlNodeSyntax> get_Content();
    public SyntaxToken get_EndOfComment();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public DocumentationCommentTriviaSyntax Update(SyntaxList`1<XmlNodeSyntax> content, SyntaxToken endOfComment);
    public DocumentationCommentTriviaSyntax WithContent(SyntaxList`1<XmlNodeSyntax> content);
    public DocumentationCommentTriviaSyntax WithEndOfComment(SyntaxToken endOfComment);
    public DocumentationCommentTriviaSyntax AddContent(XmlNodeSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax : StatementSyntax {
    private StatementSyntax statement;
    private ExpressionSyntax condition;
    public SyntaxToken DoKeyword { get; }
    public StatementSyntax Statement { get; }
    public SyntaxToken WhileKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Condition { get; }
    public SyntaxToken CloseParenToken { get; }
    public SyntaxToken SemicolonToken { get; }
    internal DoStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_DoKeyword();
    public StatementSyntax get_Statement();
    public SyntaxToken get_WhileKeyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Condition();
    public SyntaxToken get_CloseParenToken();
    public SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public DoStatementSyntax Update(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken);
    public DoStatementSyntax WithDoKeyword(SyntaxToken doKeyword);
    public DoStatementSyntax WithStatement(StatementSyntax statement);
    public DoStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword);
    public DoStatementSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public DoStatementSyntax WithCondition(ExpressionSyntax condition);
    public DoStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    public DoStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax : ExpressionSyntax {
    private ExpressionSyntax expression;
    private BracketedArgumentListSyntax argumentList;
    public ExpressionSyntax Expression { get; }
    public BracketedArgumentListSyntax ArgumentList { get; }
    internal ElementAccessExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public ExpressionSyntax get_Expression();
    public BracketedArgumentListSyntax get_ArgumentList();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ElementAccessExpressionSyntax Update(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList);
    public ElementAccessExpressionSyntax WithExpression(ExpressionSyntax expression);
    public ElementAccessExpressionSyntax WithArgumentList(BracketedArgumentListSyntax argumentList);
    public ElementAccessExpressionSyntax AddArgumentListArguments(ArgumentSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax : ExpressionSyntax {
    private BracketedArgumentListSyntax argumentList;
    public BracketedArgumentListSyntax ArgumentList { get; }
    internal ElementBindingExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public BracketedArgumentListSyntax get_ArgumentList();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ElementBindingExpressionSyntax Update(BracketedArgumentListSyntax argumentList);
    public ElementBindingExpressionSyntax WithArgumentList(BracketedArgumentListSyntax argumentList);
    public ElementBindingExpressionSyntax AddArgumentListArguments(ArgumentSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax {
    private ExpressionSyntax condition;
    public SyntaxToken HashToken { get; }
    public SyntaxToken ElifKeyword { get; }
    public ExpressionSyntax Condition { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    public bool BranchTaken { get; }
    public bool ConditionValue { get; }
    internal ElifDirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_ElifKeyword();
    public virtual ExpressionSyntax get_Condition();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    public virtual bool get_BranchTaken();
    public virtual bool get_ConditionValue();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ElifDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue);
    public ElifDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public ElifDirectiveTriviaSyntax WithElifKeyword(SyntaxToken elifKeyword);
    public ElifDirectiveTriviaSyntax WithCondition(ExpressionSyntax condition);
    public ElifDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public ElifDirectiveTriviaSyntax WithIsActive(bool isActive);
    public ElifDirectiveTriviaSyntax WithBranchTaken(bool branchTaken);
    public ElifDirectiveTriviaSyntax WithConditionValue(bool conditionValue);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax : CSharpSyntaxNode {
    private StatementSyntax statement;
    public SyntaxToken ElseKeyword { get; }
    public StatementSyntax Statement { get; }
    internal ElseClauseSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_ElseKeyword();
    public StatementSyntax get_Statement();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ElseClauseSyntax Update(SyntaxToken elseKeyword, StatementSyntax statement);
    public ElseClauseSyntax WithElseKeyword(SyntaxToken elseKeyword);
    public ElseClauseSyntax WithStatement(StatementSyntax statement);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken ElseKeyword { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    public bool BranchTaken { get; }
    internal ElseDirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_ElseKeyword();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    public virtual bool get_BranchTaken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ElseDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken);
    public ElseDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public ElseDirectiveTriviaSyntax WithElseKeyword(SyntaxToken elseKeyword);
    public ElseDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public ElseDirectiveTriviaSyntax WithIsActive(bool isActive);
    public ElseDirectiveTriviaSyntax WithBranchTaken(bool branchTaken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax : StatementSyntax {
    public SyntaxToken SemicolonToken { get; }
    internal EmptyStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public EmptyStatementSyntax Update(SyntaxToken semicolonToken);
    public EmptyStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken EndIfKeyword { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal EndIfDirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_EndIfKeyword();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public EndIfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public EndIfDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public EndIfDirectiveTriviaSyntax WithEndIfKeyword(SyntaxToken endIfKeyword);
    public EndIfDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public EndIfDirectiveTriviaSyntax WithIsActive(bool isActive);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken EndRegionKeyword { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal EndRegionDirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_EndRegionKeyword();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public EndRegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public EndRegionDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public EndRegionDirectiveTriviaSyntax WithEndRegionKeyword(SyntaxToken endRegionKeyword);
    public EndRegionDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public EndRegionDirectiveTriviaSyntax WithIsActive(bool isActive);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax : BaseTypeDeclarationSyntax {
    private CSharpSyntaxNode attributeLists;
    private BaseListSyntax baseList;
    private SyntaxNode members;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken EnumKeyword { get; }
    public SyntaxToken Identifier { get; }
    public BaseListSyntax BaseList { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SeparatedSyntaxList`1<EnumMemberDeclarationSyntax> Members { get; }
    public SyntaxToken CloseBraceToken { get; }
    public SyntaxToken SemicolonToken { get; }
    internal EnumDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxTokenList get_Modifiers();
    public SyntaxToken get_EnumKeyword();
    public virtual SyntaxToken get_Identifier();
    public virtual BaseListSyntax get_BaseList();
    public virtual SyntaxToken get_OpenBraceToken();
    public SeparatedSyntaxList`1<EnumMemberDeclarationSyntax> get_Members();
    public virtual SyntaxToken get_CloseBraceToken();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public EnumDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList`1<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public EnumDeclarationSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public EnumDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
    public EnumDeclarationSyntax WithEnumKeyword(SyntaxToken enumKeyword);
    public EnumDeclarationSyntax WithIdentifier(SyntaxToken identifier);
    public EnumDeclarationSyntax WithBaseList(BaseListSyntax baseList);
    public EnumDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
    public EnumDeclarationSyntax WithMembers(SeparatedSyntaxList`1<EnumMemberDeclarationSyntax> members);
    public EnumDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
    public EnumDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
    public EnumDeclarationSyntax AddAttributeLists(AttributeListSyntax[] items);
    public EnumDeclarationSyntax AddModifiers(SyntaxToken[] items);
    public EnumDeclarationSyntax AddBaseListTypes(BaseTypeSyntax[] items);
    public EnumDeclarationSyntax AddMembers(EnumMemberDeclarationSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax : MemberDeclarationSyntax {
    private CSharpSyntaxNode attributeLists;
    private EqualsValueClauseSyntax equalsValue;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxToken Identifier { get; }
    public EqualsValueClauseSyntax EqualsValue { get; }
    internal EnumMemberDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxToken get_Identifier();
    public EqualsValueClauseSyntax get_EqualsValue();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public EnumMemberDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue);
    public EnumMemberDeclarationSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public EnumMemberDeclarationSyntax WithIdentifier(SyntaxToken identifier);
    public EnumMemberDeclarationSyntax WithEqualsValue(EqualsValueClauseSyntax equalsValue);
    public EnumMemberDeclarationSyntax AddAttributeLists(AttributeListSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax : CSharpSyntaxNode {
    private ExpressionSyntax value;
    public SyntaxToken EqualsToken { get; }
    public ExpressionSyntax Value { get; }
    internal EqualsValueClauseSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_EqualsToken();
    public ExpressionSyntax get_Value();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public EqualsValueClauseSyntax Update(SyntaxToken equalsToken, ExpressionSyntax value);
    public EqualsValueClauseSyntax WithEqualsToken(SyntaxToken equalsToken);
    public EqualsValueClauseSyntax WithValue(ExpressionSyntax value);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken ErrorKeyword { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal ErrorDirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_ErrorKeyword();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ErrorDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public ErrorDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public ErrorDirectiveTriviaSyntax WithErrorKeyword(SyntaxToken errorKeyword);
    public ErrorDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public ErrorDirectiveTriviaSyntax WithIsActive(bool isActive);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax : BasePropertyDeclarationSyntax {
    private CSharpSyntaxNode attributeLists;
    private TypeSyntax type;
    private ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private AccessorListSyntax accessorList;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken EventKeyword { get; }
    public TypeSyntax Type { get; }
    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }
    public SyntaxToken Identifier { get; }
    public AccessorListSyntax AccessorList { get; }
    internal EventDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxTokenList get_Modifiers();
    public SyntaxToken get_EventKeyword();
    public virtual TypeSyntax get_Type();
    public virtual ExplicitInterfaceSpecifierSyntax get_ExplicitInterfaceSpecifier();
    public SyntaxToken get_Identifier();
    public virtual AccessorListSyntax get_AccessorList();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public EventDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList);
    public EventDeclarationSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public EventDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
    public EventDeclarationSyntax WithEventKeyword(SyntaxToken eventKeyword);
    public EventDeclarationSyntax WithType(TypeSyntax type);
    public EventDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier);
    public EventDeclarationSyntax WithIdentifier(SyntaxToken identifier);
    public EventDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList);
    public EventDeclarationSyntax AddAttributeLists(AttributeListSyntax[] items);
    public EventDeclarationSyntax AddModifiers(SyntaxToken[] items);
    public EventDeclarationSyntax AddAccessorListAccessors(AccessorDeclarationSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax : BaseFieldDeclarationSyntax {
    private CSharpSyntaxNode attributeLists;
    private VariableDeclarationSyntax declaration;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken EventKeyword { get; }
    public VariableDeclarationSyntax Declaration { get; }
    public SyntaxToken SemicolonToken { get; }
    internal EventFieldDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxTokenList get_Modifiers();
    public SyntaxToken get_EventKeyword();
    public virtual VariableDeclarationSyntax get_Declaration();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public EventFieldDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    public EventFieldDeclarationSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public EventFieldDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
    public EventFieldDeclarationSyntax WithEventKeyword(SyntaxToken eventKeyword);
    public EventFieldDeclarationSyntax WithDeclaration(VariableDeclarationSyntax declaration);
    public EventFieldDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
    public EventFieldDeclarationSyntax AddAttributeLists(AttributeListSyntax[] items);
    public EventFieldDeclarationSyntax AddModifiers(SyntaxToken[] items);
    public EventFieldDeclarationSyntax AddDeclarationVariables(VariableDeclaratorSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax : CSharpSyntaxNode {
    private NameSyntax name;
    public NameSyntax Name { get; }
    public SyntaxToken DotToken { get; }
    internal ExplicitInterfaceSpecifierSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public NameSyntax get_Name();
    public SyntaxToken get_DotToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ExplicitInterfaceSpecifierSyntax Update(NameSyntax name, SyntaxToken dotToken);
    public ExplicitInterfaceSpecifierSyntax WithName(NameSyntax name);
    public ExplicitInterfaceSpecifierSyntax WithDotToken(SyntaxToken dotToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax : StatementSyntax {
    private ExpressionSyntax expression;
    public bool AllowsAnyExpression { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken SemicolonToken { get; }
    internal ExpressionStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public bool get_AllowsAnyExpression();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ExpressionStatementSyntax Update(ExpressionSyntax expression, SyntaxToken semicolonToken);
    public ExpressionStatementSyntax WithExpression(ExpressionSyntax expression);
    public ExpressionStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax : CSharpSyntaxNode {
    internal ExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax : CSharpSyntaxNode {
    public SyntaxToken ExternKeyword { get; }
    public SyntaxToken AliasKeyword { get; }
    public SyntaxToken Identifier { get; }
    public SyntaxToken SemicolonToken { get; }
    internal ExternAliasDirectiveSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_ExternKeyword();
    public SyntaxToken get_AliasKeyword();
    public SyntaxToken get_Identifier();
    public SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ExternAliasDirectiveSyntax Update(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken);
    public ExternAliasDirectiveSyntax WithExternKeyword(SyntaxToken externKeyword);
    public ExternAliasDirectiveSyntax WithAliasKeyword(SyntaxToken aliasKeyword);
    public ExternAliasDirectiveSyntax WithIdentifier(SyntaxToken identifier);
    public ExternAliasDirectiveSyntax WithSemicolonToken(SyntaxToken semicolonToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax : BaseFieldDeclarationSyntax {
    private CSharpSyntaxNode attributeLists;
    private VariableDeclarationSyntax declaration;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public VariableDeclarationSyntax Declaration { get; }
    public SyntaxToken SemicolonToken { get; }
    internal FieldDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxTokenList get_Modifiers();
    public virtual VariableDeclarationSyntax get_Declaration();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public FieldDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    public FieldDeclarationSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public FieldDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
    public FieldDeclarationSyntax WithDeclaration(VariableDeclarationSyntax declaration);
    public FieldDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
    public FieldDeclarationSyntax AddAttributeLists(AttributeListSyntax[] items);
    public FieldDeclarationSyntax AddModifiers(SyntaxToken[] items);
    public FieldDeclarationSyntax AddDeclarationVariables(VariableDeclaratorSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax : CSharpSyntaxNode {
    private BlockSyntax block;
    public SyntaxToken FinallyKeyword { get; }
    public BlockSyntax Block { get; }
    internal FinallyClauseSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_FinallyKeyword();
    public BlockSyntax get_Block();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public FinallyClauseSyntax Update(SyntaxToken finallyKeyword, BlockSyntax block);
    public FinallyClauseSyntax WithFinallyKeyword(SyntaxToken finallyKeyword);
    public FinallyClauseSyntax WithBlock(BlockSyntax block);
    public FinallyClauseSyntax AddBlockStatements(StatementSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax : StatementSyntax {
    private VariableDeclarationSyntax declaration;
    private StatementSyntax statement;
    public SyntaxToken FixedKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public VariableDeclarationSyntax Declaration { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    internal FixedStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_FixedKeyword();
    public SyntaxToken get_OpenParenToken();
    public VariableDeclarationSyntax get_Declaration();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public FixedStatementSyntax Update(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement);
    public FixedStatementSyntax WithFixedKeyword(SyntaxToken fixedKeyword);
    public FixedStatementSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public FixedStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration);
    public FixedStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    public FixedStatementSyntax WithStatement(StatementSyntax statement);
    public FixedStatementSyntax AddDeclarationVariables(VariableDeclaratorSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax : StatementSyntax {
    private TypeSyntax type;
    private ExpressionSyntax expression;
    private StatementSyntax statement;
    public SyntaxToken ForEachKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken Identifier { get; }
    public SyntaxToken InKeyword { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    internal ForEachStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_ForEachKeyword();
    public SyntaxToken get_OpenParenToken();
    public TypeSyntax get_Type();
    public SyntaxToken get_Identifier();
    public SyntaxToken get_InKeyword();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ForEachStatementSyntax Update(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    public ForEachStatementSyntax WithForEachKeyword(SyntaxToken forEachKeyword);
    public ForEachStatementSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public ForEachStatementSyntax WithType(TypeSyntax type);
    public ForEachStatementSyntax WithIdentifier(SyntaxToken identifier);
    public ForEachStatementSyntax WithInKeyword(SyntaxToken inKeyword);
    public ForEachStatementSyntax WithExpression(ExpressionSyntax expression);
    public ForEachStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    public ForEachStatementSyntax WithStatement(StatementSyntax statement);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax : StatementSyntax {
    private VariableDeclarationSyntax declaration;
    private SyntaxNode initializers;
    private ExpressionSyntax condition;
    private SyntaxNode incrementors;
    private StatementSyntax statement;
    public SyntaxToken ForKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public VariableDeclarationSyntax Declaration { get; }
    public SeparatedSyntaxList`1<ExpressionSyntax> Initializers { get; }
    public SyntaxToken FirstSemicolonToken { get; }
    public ExpressionSyntax Condition { get; }
    public SyntaxToken SecondSemicolonToken { get; }
    public SeparatedSyntaxList`1<ExpressionSyntax> Incrementors { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    internal ForStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_ForKeyword();
    public SyntaxToken get_OpenParenToken();
    public VariableDeclarationSyntax get_Declaration();
    public SeparatedSyntaxList`1<ExpressionSyntax> get_Initializers();
    public SyntaxToken get_FirstSemicolonToken();
    public ExpressionSyntax get_Condition();
    public SyntaxToken get_SecondSemicolonToken();
    public SeparatedSyntaxList`1<ExpressionSyntax> get_Incrementors();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ForStatementSyntax Update(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList`1<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList`1<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement);
    public ForStatementSyntax WithForKeyword(SyntaxToken forKeyword);
    public ForStatementSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public ForStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration);
    public ForStatementSyntax WithInitializers(SeparatedSyntaxList`1<ExpressionSyntax> initializers);
    public ForStatementSyntax WithFirstSemicolonToken(SyntaxToken firstSemicolonToken);
    public ForStatementSyntax WithCondition(ExpressionSyntax condition);
    public ForStatementSyntax WithSecondSemicolonToken(SyntaxToken secondSemicolonToken);
    public ForStatementSyntax WithIncrementors(SeparatedSyntaxList`1<ExpressionSyntax> incrementors);
    public ForStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    public ForStatementSyntax WithStatement(StatementSyntax statement);
    public ForStatementSyntax AddInitializers(ExpressionSyntax[] items);
    public ForStatementSyntax AddIncrementors(ExpressionSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax : QueryClauseSyntax {
    private TypeSyntax type;
    private ExpressionSyntax expression;
    public SyntaxToken FromKeyword { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken Identifier { get; }
    public SyntaxToken InKeyword { get; }
    public ExpressionSyntax Expression { get; }
    internal FromClauseSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_FromKeyword();
    public TypeSyntax get_Type();
    public SyntaxToken get_Identifier();
    public SyntaxToken get_InKeyword();
    public ExpressionSyntax get_Expression();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public FromClauseSyntax Update(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression);
    public FromClauseSyntax WithFromKeyword(SyntaxToken fromKeyword);
    public FromClauseSyntax WithType(TypeSyntax type);
    public FromClauseSyntax WithIdentifier(SyntaxToken identifier);
    public FromClauseSyntax WithInKeyword(SyntaxToken inKeyword);
    public FromClauseSyntax WithExpression(ExpressionSyntax expression);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax : SimpleNameSyntax {
    private TypeArgumentListSyntax typeArgumentList;
    public bool IsUnboundGenericName { get; }
    public SyntaxToken Identifier { get; }
    public TypeArgumentListSyntax TypeArgumentList { get; }
    internal GenericNameSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public bool get_IsUnboundGenericName();
    internal virtual string ErrorDisplayName();
    public virtual SyntaxToken get_Identifier();
    public TypeArgumentListSyntax get_TypeArgumentList();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public GenericNameSyntax Update(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList);
    public GenericNameSyntax WithIdentifier(SyntaxToken identifier);
    public GenericNameSyntax WithTypeArgumentList(TypeArgumentListSyntax typeArgumentList);
    public GenericNameSyntax AddTypeArgumentListArguments(TypeSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax : MemberDeclarationSyntax {
    private StatementSyntax statement;
    public StatementSyntax Statement { get; }
    internal GlobalStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public StatementSyntax get_Statement();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public GlobalStatementSyntax Update(StatementSyntax statement);
    public GlobalStatementSyntax WithStatement(StatementSyntax statement);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax : StatementSyntax {
    private ExpressionSyntax expression;
    public SyntaxToken GotoKeyword { get; }
    public SyntaxToken CaseOrDefaultKeyword { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken SemicolonToken { get; }
    internal GotoStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_GotoKeyword();
    public SyntaxToken get_CaseOrDefaultKeyword();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public GotoStatementSyntax Update(SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    public GotoStatementSyntax WithGotoKeyword(SyntaxToken gotoKeyword);
    public GotoStatementSyntax WithCaseOrDefaultKeyword(SyntaxToken caseOrDefaultKeyword);
    public GotoStatementSyntax WithExpression(ExpressionSyntax expression);
    public GotoStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Syntax.GreenNodeExtensions : object {
    [ExtensionAttribute]
internal static SyntaxList`1<T> ToGreenList(SyntaxNode node);
    [ExtensionAttribute]
internal static SeparatedSyntaxList`1<T> ToGreenSeparatedList(SyntaxNode node);
    [ExtensionAttribute]
internal static SyntaxList`1<T> ToGreenList(GreenNode node);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax : SelectOrGroupClauseSyntax {
    private ExpressionSyntax groupExpression;
    private ExpressionSyntax byExpression;
    public SyntaxToken GroupKeyword { get; }
    public ExpressionSyntax GroupExpression { get; }
    public SyntaxToken ByKeyword { get; }
    public ExpressionSyntax ByExpression { get; }
    internal GroupClauseSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_GroupKeyword();
    public ExpressionSyntax get_GroupExpression();
    public SyntaxToken get_ByKeyword();
    public ExpressionSyntax get_ByExpression();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public GroupClauseSyntax Update(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression);
    public GroupClauseSyntax WithGroupKeyword(SyntaxToken groupKeyword);
    public GroupClauseSyntax WithGroupExpression(ExpressionSyntax groupExpression);
    public GroupClauseSyntax WithByKeyword(SyntaxToken byKeyword);
    public GroupClauseSyntax WithByExpression(ExpressionSyntax byExpression);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax : SimpleNameSyntax {
    public SyntaxToken Identifier { get; }
    internal IdentifierNameSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    internal virtual string ErrorDisplayName();
    public virtual SyntaxToken get_Identifier();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public IdentifierNameSyntax Update(SyntaxToken identifier);
    public IdentifierNameSyntax WithIdentifier(SyntaxToken identifier);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax {
    private ExpressionSyntax condition;
    public SyntaxToken HashToken { get; }
    public SyntaxToken IfKeyword { get; }
    public ExpressionSyntax Condition { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    public bool BranchTaken { get; }
    public bool ConditionValue { get; }
    internal IfDirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_IfKeyword();
    public virtual ExpressionSyntax get_Condition();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    public virtual bool get_BranchTaken();
    public virtual bool get_ConditionValue();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public IfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue);
    public IfDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public IfDirectiveTriviaSyntax WithIfKeyword(SyntaxToken ifKeyword);
    public IfDirectiveTriviaSyntax WithCondition(ExpressionSyntax condition);
    public IfDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public IfDirectiveTriviaSyntax WithIsActive(bool isActive);
    public IfDirectiveTriviaSyntax WithBranchTaken(bool branchTaken);
    public IfDirectiveTriviaSyntax WithConditionValue(bool conditionValue);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax : StatementSyntax {
    private ExpressionSyntax condition;
    private StatementSyntax statement;
    private ElseClauseSyntax else;
    public SyntaxToken IfKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Condition { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    public ElseClauseSyntax Else { get; }
    internal IfStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_IfKeyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Condition();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    public ElseClauseSyntax get_Else();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public IfStatementSyntax Update(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax else);
    public IfStatementSyntax WithIfKeyword(SyntaxToken ifKeyword);
    public IfStatementSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public IfStatementSyntax WithCondition(ExpressionSyntax condition);
    public IfStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    public IfStatementSyntax WithStatement(StatementSyntax statement);
    public IfStatementSyntax WithElse(ElseClauseSyntax else);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax : ExpressionSyntax {
    private InitializerExpressionSyntax initializer;
    public SyntaxToken NewKeyword { get; }
    public SyntaxToken OpenBracketToken { get; }
    public SyntaxTokenList Commas { get; }
    public SyntaxToken CloseBracketToken { get; }
    public InitializerExpressionSyntax Initializer { get; }
    internal ImplicitArrayCreationExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_NewKeyword();
    public SyntaxToken get_OpenBracketToken();
    public SyntaxTokenList get_Commas();
    public SyntaxToken get_CloseBracketToken();
    public InitializerExpressionSyntax get_Initializer();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ImplicitArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxTokenList commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer);
    public ImplicitArrayCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword);
    public ImplicitArrayCreationExpressionSyntax WithOpenBracketToken(SyntaxToken openBracketToken);
    public ImplicitArrayCreationExpressionSyntax WithCommas(SyntaxTokenList commas);
    public ImplicitArrayCreationExpressionSyntax WithCloseBracketToken(SyntaxToken closeBracketToken);
    public ImplicitArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer);
    public ImplicitArrayCreationExpressionSyntax AddCommas(SyntaxToken[] items);
    public ImplicitArrayCreationExpressionSyntax AddInitializerExpressions(ExpressionSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax : ExpressionSyntax {
    private BracketedArgumentListSyntax argumentList;
    public BracketedArgumentListSyntax ArgumentList { get; }
    internal ImplicitElementAccessSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public BracketedArgumentListSyntax get_ArgumentList();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ImplicitElementAccessSyntax Update(BracketedArgumentListSyntax argumentList);
    public ImplicitElementAccessSyntax WithArgumentList(BracketedArgumentListSyntax argumentList);
    public ImplicitElementAccessSyntax AddArgumentListArguments(ArgumentSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax : MemberDeclarationSyntax {
    private CSharpSyntaxNode attributeLists;
    private TypeSyntax type;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public TypeSyntax Type { get; }
    internal IncompleteMemberSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxTokenList get_Modifiers();
    public TypeSyntax get_Type();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public IncompleteMemberSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type);
    public IncompleteMemberSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public IncompleteMemberSyntax WithModifiers(SyntaxTokenList modifiers);
    public IncompleteMemberSyntax WithType(TypeSyntax type);
    public IncompleteMemberSyntax AddAttributeLists(AttributeListSyntax[] items);
    public IncompleteMemberSyntax AddModifiers(SyntaxToken[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax : BasePropertyDeclarationSyntax {
    private CSharpSyntaxNode attributeLists;
    private TypeSyntax type;
    private ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private BracketedParameterListSyntax parameterList;
    private AccessorListSyntax accessorList;
    private ArrowExpressionClauseSyntax expressionBody;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public SyntaxToken Semicolon { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public TypeSyntax Type { get; }
    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }
    public SyntaxToken ThisKeyword { get; }
    public BracketedParameterListSyntax ParameterList { get; }
    public AccessorListSyntax AccessorList { get; }
    public ArrowExpressionClauseSyntax ExpressionBody { get; }
    public SyntaxToken SemicolonToken { get; }
    internal IndexerDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_Semicolon();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public IndexerDeclarationSyntax WithSemicolon(SyntaxToken semicolon);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxTokenList get_Modifiers();
    public virtual TypeSyntax get_Type();
    public virtual ExplicitInterfaceSpecifierSyntax get_ExplicitInterfaceSpecifier();
    public SyntaxToken get_ThisKeyword();
    public BracketedParameterListSyntax get_ParameterList();
    public virtual AccessorListSyntax get_AccessorList();
    public ArrowExpressionClauseSyntax get_ExpressionBody();
    public SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public IndexerDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public IndexerDeclarationSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public IndexerDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
    public IndexerDeclarationSyntax WithType(TypeSyntax type);
    public IndexerDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier);
    public IndexerDeclarationSyntax WithThisKeyword(SyntaxToken thisKeyword);
    public IndexerDeclarationSyntax WithParameterList(BracketedParameterListSyntax parameterList);
    public IndexerDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList);
    public IndexerDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody);
    public IndexerDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
    public IndexerDeclarationSyntax AddAttributeLists(AttributeListSyntax[] items);
    public IndexerDeclarationSyntax AddModifiers(SyntaxToken[] items);
    public IndexerDeclarationSyntax AddParameterListParameters(ParameterSyntax[] items);
    public IndexerDeclarationSyntax AddAccessorListAccessors(AccessorDeclarationSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax : MemberCrefSyntax {
    private CrefBracketedParameterListSyntax parameters;
    public SyntaxToken ThisKeyword { get; }
    public CrefBracketedParameterListSyntax Parameters { get; }
    internal IndexerMemberCrefSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_ThisKeyword();
    public CrefBracketedParameterListSyntax get_Parameters();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public IndexerMemberCrefSyntax Update(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters);
    public IndexerMemberCrefSyntax WithThisKeyword(SyntaxToken thisKeyword);
    public IndexerMemberCrefSyntax WithParameters(CrefBracketedParameterListSyntax parameters);
    public IndexerMemberCrefSyntax AddParametersParameters(CrefParameterSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax : ExpressionSyntax {
    private SyntaxNode expressions;
    public SyntaxToken OpenBraceToken { get; }
    public SeparatedSyntaxList`1<ExpressionSyntax> Expressions { get; }
    public SyntaxToken CloseBraceToken { get; }
    internal InitializerExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OpenBraceToken();
    public SeparatedSyntaxList`1<ExpressionSyntax> get_Expressions();
    public SyntaxToken get_CloseBraceToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public InitializerExpressionSyntax Update(SyntaxToken openBraceToken, SeparatedSyntaxList`1<ExpressionSyntax> expressions, SyntaxToken closeBraceToken);
    public InitializerExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
    public InitializerExpressionSyntax WithExpressions(SeparatedSyntaxList`1<ExpressionSyntax> expressions);
    public InitializerExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
    public InitializerExpressionSyntax AddExpressions(ExpressionSyntax[] items);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InstanceExpressionSyntax : ExpressionSyntax {
    internal InstanceExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax : TypeDeclarationSyntax {
    private CSharpSyntaxNode attributeLists;
    private TypeParameterListSyntax typeParameterList;
    private BaseListSyntax baseList;
    private CSharpSyntaxNode constraintClauses;
    private CSharpSyntaxNode members;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken Keyword { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public BaseListSyntax BaseList { get; }
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    public SyntaxToken CloseBraceToken { get; }
    public SyntaxToken SemicolonToken { get; }
    internal InterfaceDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxTokenList get_Modifiers();
    public virtual SyntaxToken get_Keyword();
    public virtual SyntaxToken get_Identifier();
    public virtual TypeParameterListSyntax get_TypeParameterList();
    public virtual BaseListSyntax get_BaseList();
    public virtual SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public virtual SyntaxToken get_OpenBraceToken();
    public virtual SyntaxList`1<MemberDeclarationSyntax> get_Members();
    public virtual SyntaxToken get_CloseBraceToken();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public InterfaceDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public InterfaceDeclarationSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public InterfaceDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
    public InterfaceDeclarationSyntax WithKeyword(SyntaxToken keyword);
    public InterfaceDeclarationSyntax WithIdentifier(SyntaxToken identifier);
    public InterfaceDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList);
    public InterfaceDeclarationSyntax WithBaseList(BaseListSyntax baseList);
    public InterfaceDeclarationSyntax WithConstraintClauses(SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses);
    public InterfaceDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
    public InterfaceDeclarationSyntax WithMembers(SyntaxList`1<MemberDeclarationSyntax> members);
    public InterfaceDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
    public InterfaceDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
    public InterfaceDeclarationSyntax AddAttributeLists(AttributeListSyntax[] items);
    public InterfaceDeclarationSyntax AddModifiers(SyntaxToken[] items);
    public InterfaceDeclarationSyntax AddTypeParameterListParameters(TypeParameterSyntax[] items);
    public InterfaceDeclarationSyntax AddBaseListTypes(BaseTypeSyntax[] items);
    public InterfaceDeclarationSyntax AddConstraintClauses(TypeParameterConstraintClauseSyntax[] items);
    public InterfaceDeclarationSyntax AddMembers(MemberDeclarationSyntax[] items);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AbstractLexer : object {
    internal SlidingTextWindow TextWindow;
    private List`1<SyntaxDiagnosticInfo> _errors;
    protected bool HasErrors { get; }
    protected AbstractLexer(SourceText text);
    public virtual void Dispose();
    protected void Start();
    protected bool get_HasErrors();
    protected SyntaxDiagnosticInfo[] GetErrors(int leadingTriviaWidth);
    protected void AddError(int position, int width, ErrorCode code);
    protected void AddError(int position, int width, ErrorCode code, Object[] args);
    protected void AddError(int position, int width, XmlParseErrorCode code, Object[] args);
    protected void AddError(ErrorCode code);
    protected void AddError(ErrorCode code, Object[] args);
    protected void AddError(XmlParseErrorCode code);
    protected void AddError(XmlParseErrorCode code, Object[] args);
    protected void AddError(SyntaxDiagnosticInfo error);
    protected SyntaxDiagnosticInfo MakeError(int position, int width, ErrorCode code);
    protected SyntaxDiagnosticInfo MakeError(int position, int width, ErrorCode code, Object[] args);
    protected XmlSyntaxDiagnosticInfo MakeError(int position, int width, XmlParseErrorCode code, Object[] args);
    private int GetLexemeOffsetFromPosition(int position);
    protected static SyntaxDiagnosticInfo MakeError(ErrorCode code);
    protected static SyntaxDiagnosticInfo MakeError(ErrorCode code, Object[] args);
    protected static XmlSyntaxDiagnosticInfo MakeError(XmlParseErrorCode code);
    protected static XmlSyntaxDiagnosticInfo MakeError(XmlParseErrorCode code, Object[] args);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorDeclarationSyntax : CSharpSyntaxNode {
    internal CSharpSyntaxNode attributeLists;
    internal CSharpSyntaxNode modifiers;
    internal SyntaxToken keyword;
    internal BlockSyntax body;
    internal SyntaxToken semicolonToken;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public SyntaxToken Keyword { get; }
    public BlockSyntax Body { get; }
    public SyntaxToken SemicolonToken { get; }
    internal AccessorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal AccessorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal AccessorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken);
    internal AccessorDeclarationSyntax(ObjectReader reader);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxList`1<SyntaxToken> get_Modifiers();
    public SyntaxToken get_Keyword();
    public BlockSyntax get_Body();
    public SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AccessorDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorListSyntax : CSharpSyntaxNode {
    internal SyntaxToken openBraceToken;
    internal CSharpSyntaxNode accessors;
    internal SyntaxToken closeBraceToken;
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxList`1<AccessorDeclarationSyntax> Accessors { get; }
    public SyntaxToken CloseBraceToken { get; }
    internal AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, CSharpSyntaxNode accessors, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, CSharpSyntaxNode accessors, SyntaxToken closeBraceToken, SyntaxFactoryContext context);
    internal AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, CSharpSyntaxNode accessors, SyntaxToken closeBraceToken);
    internal AccessorListSyntax(ObjectReader reader);
    public SyntaxToken get_OpenBraceToken();
    public SyntaxList`1<AccessorDeclarationSyntax> get_Accessors();
    public SyntaxToken get_CloseBraceToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AccessorListSyntax Update(SyntaxToken openBraceToken, SyntaxList`1<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AliasQualifiedNameSyntax : NameSyntax {
    internal IdentifierNameSyntax alias;
    internal SyntaxToken colonColonToken;
    internal SimpleNameSyntax name;
    public IdentifierNameSyntax Alias { get; }
    public SyntaxToken ColonColonToken { get; }
    public SimpleNameSyntax Name { get; }
    internal AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name, SyntaxFactoryContext context);
    internal AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name);
    internal AliasQualifiedNameSyntax(ObjectReader reader);
    public IdentifierNameSyntax get_Alias();
    public SyntaxToken get_ColonColonToken();
    public SimpleNameSyntax get_Name();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AliasQualifiedNameSyntax Update(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousFunctionExpressionSyntax : ExpressionSyntax {
    public SyntaxToken AsyncKeyword { get; }
    public CSharpSyntaxNode Body { get; }
    internal AnonymousFunctionExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal AnonymousFunctionExpressionSyntax(SyntaxKind kind);
    protected AnonymousFunctionExpressionSyntax(ObjectReader reader);
    public abstract virtual SyntaxToken get_AsyncKeyword();
    public abstract virtual CSharpSyntaxNode get_Body();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousMethodExpressionSyntax : AnonymousFunctionExpressionSyntax {
    internal SyntaxToken asyncKeyword;
    internal SyntaxToken delegateKeyword;
    internal ParameterListSyntax parameterList;
    internal CSharpSyntaxNode body;
    public SyntaxToken AsyncKeyword { get; }
    public SyntaxToken DelegateKeyword { get; }
    public ParameterListSyntax ParameterList { get; }
    public CSharpSyntaxNode Body { get; }
    internal AnonymousMethodExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal AnonymousMethodExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body, SyntaxFactoryContext context);
    internal AnonymousMethodExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body);
    internal AnonymousMethodExpressionSyntax(ObjectReader reader);
    public virtual SyntaxToken get_AsyncKeyword();
    public SyntaxToken get_DelegateKeyword();
    public ParameterListSyntax get_ParameterList();
    public virtual CSharpSyntaxNode get_Body();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AnonymousMethodExpressionSyntax Update(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken newKeyword;
    internal SyntaxToken openBraceToken;
    internal CSharpSyntaxNode initializers;
    internal SyntaxToken closeBraceToken;
    public SyntaxToken NewKeyword { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SeparatedSyntaxList`1<AnonymousObjectMemberDeclaratorSyntax> Initializers { get; }
    public SyntaxToken CloseBraceToken { get; }
    internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, CSharpSyntaxNode initializers, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, CSharpSyntaxNode initializers, SyntaxToken closeBraceToken, SyntaxFactoryContext context);
    internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, CSharpSyntaxNode initializers, SyntaxToken closeBraceToken);
    internal AnonymousObjectCreationExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_NewKeyword();
    public SyntaxToken get_OpenBraceToken();
    public SeparatedSyntaxList`1<AnonymousObjectMemberDeclaratorSyntax> get_Initializers();
    public SyntaxToken get_CloseBraceToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AnonymousObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList`1<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectMemberDeclaratorSyntax : CSharpSyntaxNode {
    internal NameEqualsSyntax nameEquals;
    internal ExpressionSyntax expression;
    public NameEqualsSyntax NameEquals { get; }
    public ExpressionSyntax Expression { get; }
    internal AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, ExpressionSyntax expression, SyntaxFactoryContext context);
    internal AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, ExpressionSyntax expression);
    internal AnonymousObjectMemberDeclaratorSyntax(ObjectReader reader);
    public NameEqualsSyntax get_NameEquals();
    public ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AnonymousObjectMemberDeclaratorSyntax Update(NameEqualsSyntax nameEquals, ExpressionSyntax expression);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentListSyntax : BaseArgumentListSyntax {
    internal SyntaxToken openParenToken;
    internal CSharpSyntaxNode arguments;
    internal SyntaxToken closeParenToken;
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxList`1<ArgumentSyntax> Arguments { get; }
    public SyntaxToken CloseParenToken { get; }
    internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode arguments, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode arguments, SyntaxToken closeParenToken, SyntaxFactoryContext context);
    internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode arguments, SyntaxToken closeParenToken);
    internal ArgumentListSyntax(ObjectReader reader);
    public SyntaxToken get_OpenParenToken();
    public virtual SeparatedSyntaxList`1<ArgumentSyntax> get_Arguments();
    public SyntaxToken get_CloseParenToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList`1<ArgumentSyntax> arguments, SyntaxToken closeParenToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentSyntax : CSharpSyntaxNode {
    internal NameColonSyntax nameColon;
    internal SyntaxToken refOrOutKeyword;
    internal ExpressionSyntax expression;
    public NameColonSyntax NameColon { get; }
    public SyntaxToken RefOrOutKeyword { get; }
    public ExpressionSyntax Expression { get; }
    internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression, SyntaxFactoryContext context);
    internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression);
    internal ArgumentSyntax(ObjectReader reader);
    public NameColonSyntax get_NameColon();
    public SyntaxToken get_RefOrOutKeyword();
    public ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ArgumentSyntax Update(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayCreationExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken newKeyword;
    internal ArrayTypeSyntax type;
    internal InitializerExpressionSyntax initializer;
    public SyntaxToken NewKeyword { get; }
    public ArrayTypeSyntax Type { get; }
    public InitializerExpressionSyntax Initializer { get; }
    internal ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer, SyntaxFactoryContext context);
    internal ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer);
    internal ArrayCreationExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_NewKeyword();
    public ArrayTypeSyntax get_Type();
    public InitializerExpressionSyntax get_Initializer();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayRankSpecifierSyntax : CSharpSyntaxNode {
    internal SyntaxToken openBracketToken;
    internal CSharpSyntaxNode sizes;
    internal SyntaxToken closeBracketToken;
    public SyntaxToken OpenBracketToken { get; }
    public SeparatedSyntaxList`1<ExpressionSyntax> Sizes { get; }
    public SyntaxToken CloseBracketToken { get; }
    internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode sizes, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode sizes, SyntaxToken closeBracketToken, SyntaxFactoryContext context);
    internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode sizes, SyntaxToken closeBracketToken);
    internal ArrayRankSpecifierSyntax(ObjectReader reader);
    public SyntaxToken get_OpenBracketToken();
    public SeparatedSyntaxList`1<ExpressionSyntax> get_Sizes();
    public SyntaxToken get_CloseBracketToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ArrayRankSpecifierSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList`1<ExpressionSyntax> sizes, SyntaxToken closeBracketToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayTypeSyntax : TypeSyntax {
    internal TypeSyntax elementType;
    internal CSharpSyntaxNode rankSpecifiers;
    public TypeSyntax ElementType { get; }
    public SyntaxList`1<ArrayRankSpecifierSyntax> RankSpecifiers { get; }
    internal ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, CSharpSyntaxNode rankSpecifiers, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, CSharpSyntaxNode rankSpecifiers, SyntaxFactoryContext context);
    internal ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, CSharpSyntaxNode rankSpecifiers);
    internal ArrayTypeSyntax(ObjectReader reader);
    public TypeSyntax get_ElementType();
    public SyntaxList`1<ArrayRankSpecifierSyntax> get_RankSpecifiers();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ArrayTypeSyntax Update(TypeSyntax elementType, SyntaxList`1<ArrayRankSpecifierSyntax> rankSpecifiers);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax : CSharpSyntaxNode {
    internal SyntaxToken arrowToken;
    internal ExpressionSyntax expression;
    public SyntaxToken ArrowToken { get; }
    public ExpressionSyntax Expression { get; }
    internal ArrowExpressionClauseSyntax(SyntaxKind kind, SyntaxToken arrowToken, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ArrowExpressionClauseSyntax(SyntaxKind kind, SyntaxToken arrowToken, ExpressionSyntax expression, SyntaxFactoryContext context);
    internal ArrowExpressionClauseSyntax(SyntaxKind kind, SyntaxToken arrowToken, ExpressionSyntax expression);
    internal ArrowExpressionClauseSyntax(ObjectReader reader);
    public SyntaxToken get_ArrowToken();
    public ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ArrowExpressionClauseSyntax Update(SyntaxToken arrowToken, ExpressionSyntax expression);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AssignmentExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax left;
    internal SyntaxToken operatorToken;
    internal ExpressionSyntax right;
    public ExpressionSyntax Left { get; }
    public SyntaxToken OperatorToken { get; }
    public ExpressionSyntax Right { get; }
    internal AssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal AssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, SyntaxFactoryContext context);
    internal AssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal AssignmentExpressionSyntax(ObjectReader reader);
    public ExpressionSyntax get_Left();
    public SyntaxToken get_OperatorToken();
    public ExpressionSyntax get_Right();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AssignmentExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentListSyntax : CSharpSyntaxNode {
    internal SyntaxToken openParenToken;
    internal CSharpSyntaxNode arguments;
    internal SyntaxToken closeParenToken;
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxList`1<AttributeArgumentSyntax> Arguments { get; }
    public SyntaxToken CloseParenToken { get; }
    internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode arguments, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode arguments, SyntaxToken closeParenToken, SyntaxFactoryContext context);
    internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode arguments, SyntaxToken closeParenToken);
    internal AttributeArgumentListSyntax(ObjectReader reader);
    public SyntaxToken get_OpenParenToken();
    public SeparatedSyntaxList`1<AttributeArgumentSyntax> get_Arguments();
    public SyntaxToken get_CloseParenToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AttributeArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList`1<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentSyntax : CSharpSyntaxNode {
    internal NameEqualsSyntax nameEquals;
    internal NameColonSyntax nameColon;
    internal ExpressionSyntax expression;
    public NameEqualsSyntax NameEquals { get; }
    public NameColonSyntax NameColon { get; }
    public ExpressionSyntax Expression { get; }
    internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression, SyntaxFactoryContext context);
    internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression);
    internal AttributeArgumentSyntax(ObjectReader reader);
    public NameEqualsSyntax get_NameEquals();
    public NameColonSyntax get_NameColon();
    public ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AttributeArgumentSyntax Update(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax : CSharpSyntaxNode {
    internal SyntaxToken openBracketToken;
    internal AttributeTargetSpecifierSyntax target;
    internal CSharpSyntaxNode attributes;
    internal SyntaxToken closeBracketToken;
    public SyntaxToken OpenBracketToken { get; }
    public AttributeTargetSpecifierSyntax Target { get; }
    public SeparatedSyntaxList`1<AttributeSyntax> Attributes { get; }
    public SyntaxToken CloseBracketToken { get; }
    internal AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, CSharpSyntaxNode attributes, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, CSharpSyntaxNode attributes, SyntaxToken closeBracketToken, SyntaxFactoryContext context);
    internal AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, CSharpSyntaxNode attributes, SyntaxToken closeBracketToken);
    internal AttributeListSyntax(ObjectReader reader);
    public SyntaxToken get_OpenBracketToken();
    public AttributeTargetSpecifierSyntax get_Target();
    public SeparatedSyntaxList`1<AttributeSyntax> get_Attributes();
    public SyntaxToken get_CloseBracketToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AttributeListSyntax Update(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList`1<AttributeSyntax> attributes, SyntaxToken closeBracketToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeSyntax : CSharpSyntaxNode {
    internal NameSyntax name;
    internal AttributeArgumentListSyntax argumentList;
    public NameSyntax Name { get; }
    public AttributeArgumentListSyntax ArgumentList { get; }
    internal AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax argumentList, SyntaxFactoryContext context);
    internal AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax argumentList);
    internal AttributeSyntax(ObjectReader reader);
    public NameSyntax get_Name();
    public AttributeArgumentListSyntax get_ArgumentList();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AttributeSyntax Update(NameSyntax name, AttributeArgumentListSyntax argumentList);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeTargetSpecifierSyntax : CSharpSyntaxNode {
    internal SyntaxToken identifier;
    internal SyntaxToken colonToken;
    public SyntaxToken Identifier { get; }
    public SyntaxToken ColonToken { get; }
    internal AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, SyntaxFactoryContext context);
    internal AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken);
    internal AttributeTargetSpecifierSyntax(ObjectReader reader);
    public SyntaxToken get_Identifier();
    public SyntaxToken get_ColonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AttributeTargetSpecifierSyntax Update(SyntaxToken identifier, SyntaxToken colonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AwaitExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken awaitKeyword;
    internal ExpressionSyntax expression;
    public SyntaxToken AwaitKeyword { get; }
    public ExpressionSyntax Expression { get; }
    internal AwaitExpressionSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal AwaitExpressionSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, ExpressionSyntax expression, SyntaxFactoryContext context);
    internal AwaitExpressionSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, ExpressionSyntax expression);
    internal AwaitExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_AwaitKeyword();
    public ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public AwaitExpressionSyntax Update(SyntaxToken awaitKeyword, ExpressionSyntax expression);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BadDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal SyntaxToken hashToken;
    internal SyntaxToken identifier;
    internal SyntaxToken endOfDirectiveToken;
    internal bool isActive;
    public SyntaxToken HashToken { get; }
    public SyntaxToken Identifier { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal BadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal BadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context);
    internal BadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive);
    internal BadDirectiveTriviaSyntax(ObjectReader reader);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_Identifier();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public BadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseArgumentListSyntax : CSharpSyntaxNode {
    public SeparatedSyntaxList`1<ArgumentSyntax> Arguments { get; }
    internal BaseArgumentListSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal BaseArgumentListSyntax(SyntaxKind kind);
    protected BaseArgumentListSyntax(ObjectReader reader);
    public abstract virtual SeparatedSyntaxList`1<ArgumentSyntax> get_Arguments();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseCrefParameterListSyntax : CSharpSyntaxNode {
    public SeparatedSyntaxList`1<CrefParameterSyntax> Parameters { get; }
    internal BaseCrefParameterListSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal BaseCrefParameterListSyntax(SyntaxKind kind);
    protected BaseCrefParameterListSyntax(ObjectReader reader);
    public abstract virtual SeparatedSyntaxList`1<CrefParameterSyntax> get_Parameters();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseExpressionSyntax : InstanceExpressionSyntax {
    internal SyntaxToken token;
    public SyntaxToken Token { get; }
    internal BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context);
    internal BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token);
    internal BaseExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_Token();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public BaseExpressionSyntax Update(SyntaxToken token);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseFieldDeclarationSyntax : MemberDeclarationSyntax {
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public VariableDeclarationSyntax Declaration { get; }
    public SyntaxToken SemicolonToken { get; }
    internal BaseFieldDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal BaseFieldDeclarationSyntax(SyntaxKind kind);
    protected BaseFieldDeclarationSyntax(ObjectReader reader);
    public abstract virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public abstract virtual SyntaxList`1<SyntaxToken> get_Modifiers();
    public abstract virtual VariableDeclarationSyntax get_Declaration();
    public abstract virtual SyntaxToken get_SemicolonToken();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseListSyntax : CSharpSyntaxNode {
    internal SyntaxToken colonToken;
    internal CSharpSyntaxNode types;
    public SyntaxToken ColonToken { get; }
    public SeparatedSyntaxList`1<BaseTypeSyntax> Types { get; }
    internal BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, CSharpSyntaxNode types, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, CSharpSyntaxNode types, SyntaxFactoryContext context);
    internal BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, CSharpSyntaxNode types);
    internal BaseListSyntax(ObjectReader reader);
    public SyntaxToken get_ColonToken();
    public SeparatedSyntaxList`1<BaseTypeSyntax> get_Types();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public BaseListSyntax Update(SyntaxToken colonToken, SeparatedSyntaxList`1<BaseTypeSyntax> types);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseMethodDeclarationSyntax : MemberDeclarationSyntax {
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public ParameterListSyntax ParameterList { get; }
    public BlockSyntax Body { get; }
    public SyntaxToken SemicolonToken { get; }
    internal BaseMethodDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal BaseMethodDeclarationSyntax(SyntaxKind kind);
    protected BaseMethodDeclarationSyntax(ObjectReader reader);
    public abstract virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public abstract virtual SyntaxList`1<SyntaxToken> get_Modifiers();
    public abstract virtual ParameterListSyntax get_ParameterList();
    public abstract virtual BlockSyntax get_Body();
    public abstract virtual SyntaxToken get_SemicolonToken();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseParameterListSyntax : CSharpSyntaxNode {
    public SeparatedSyntaxList`1<ParameterSyntax> Parameters { get; }
    internal BaseParameterListSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal BaseParameterListSyntax(SyntaxKind kind);
    protected BaseParameterListSyntax(ObjectReader reader);
    public abstract virtual SeparatedSyntaxList`1<ParameterSyntax> get_Parameters();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BasePropertyDeclarationSyntax : MemberDeclarationSyntax {
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public TypeSyntax Type { get; }
    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }
    public AccessorListSyntax AccessorList { get; }
    internal BasePropertyDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal BasePropertyDeclarationSyntax(SyntaxKind kind);
    protected BasePropertyDeclarationSyntax(ObjectReader reader);
    public abstract virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public abstract virtual SyntaxList`1<SyntaxToken> get_Modifiers();
    public abstract virtual TypeSyntax get_Type();
    public abstract virtual ExplicitInterfaceSpecifierSyntax get_ExplicitInterfaceSpecifier();
    public abstract virtual AccessorListSyntax get_AccessorList();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeDeclarationSyntax : MemberDeclarationSyntax {
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public SyntaxToken Identifier { get; }
    public BaseListSyntax BaseList { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxToken CloseBraceToken { get; }
    public SyntaxToken SemicolonToken { get; }
    internal BaseTypeDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal BaseTypeDeclarationSyntax(SyntaxKind kind);
    protected BaseTypeDeclarationSyntax(ObjectReader reader);
    public abstract virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public abstract virtual SyntaxList`1<SyntaxToken> get_Modifiers();
    public abstract virtual SyntaxToken get_Identifier();
    public abstract virtual BaseListSyntax get_BaseList();
    public abstract virtual SyntaxToken get_OpenBraceToken();
    public abstract virtual SyntaxToken get_CloseBraceToken();
    public abstract virtual SyntaxToken get_SemicolonToken();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeSyntax : CSharpSyntaxNode {
    public TypeSyntax Type { get; }
    internal BaseTypeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal BaseTypeSyntax(SyntaxKind kind);
    protected BaseTypeSyntax(ObjectReader reader);
    public abstract virtual TypeSyntax get_Type();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BinaryExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax left;
    internal SyntaxToken operatorToken;
    internal ExpressionSyntax right;
    public ExpressionSyntax Left { get; }
    public SyntaxToken OperatorToken { get; }
    public ExpressionSyntax Right { get; }
    internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, SyntaxFactoryContext context);
    internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax(ObjectReader reader);
    protected internal virtual void WriteTo(TextWriter writer, bool leading, bool trailing);
    public ExpressionSyntax get_Left();
    public SyntaxToken get_OperatorToken();
    public ExpressionSyntax get_Right();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public BinaryExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlendedNode : ValueType {
    internal CSharpSyntaxNode Node;
    internal SyntaxToken Token;
    internal Blender Blender;
    internal BlendedNode(CSharpSyntaxNode node, SyntaxToken token, Blender blender);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender : ValueType {
    private Lexer _lexer;
    private Cursor _oldTreeCursor;
    private ImmutableStack`1<TextChangeRange> _changes;
    private int _newPosition;
    private int _changeDelta;
    private DirectiveStack _newDirectives;
    private DirectiveStack _oldDirectives;
    private LexerMode _newLexerDrivenMode;
    public Blender(Lexer lexer, CSharpSyntaxNode oldTree, IEnumerable`1<TextChangeRange> changes);
    private Blender(Lexer lexer, Cursor oldTreeCursor, ImmutableStack`1<TextChangeRange> changes, int newPosition, int changeDelta, DirectiveStack newDirectives, DirectiveStack oldDirectives, LexerMode newLexerDrivenMode);
    private static TextChangeRange ExtendToAffectedRange(CSharpSyntaxNode oldTree, TextChangeRange changeRange);
    private static bool IsInsideInterpolation(CSharpSyntaxNode oldTree, int start);
    public BlendedNode ReadNode(LexerMode mode);
    public BlendedNode ReadToken(LexerMode mode);
    private BlendedNode ReadNodeOrToken(LexerMode mode, bool asToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax : StatementSyntax {
    internal SyntaxToken openBraceToken;
    internal CSharpSyntaxNode statements;
    internal SyntaxToken closeBraceToken;
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    public SyntaxToken CloseBraceToken { get; }
    internal BlockSyntax(SyntaxKind kind, SyntaxToken openBraceToken, CSharpSyntaxNode statements, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal BlockSyntax(SyntaxKind kind, SyntaxToken openBraceToken, CSharpSyntaxNode statements, SyntaxToken closeBraceToken, SyntaxFactoryContext context);
    internal BlockSyntax(SyntaxKind kind, SyntaxToken openBraceToken, CSharpSyntaxNode statements, SyntaxToken closeBraceToken);
    internal BlockSyntax(ObjectReader reader);
    public SyntaxToken get_OpenBraceToken();
    public SyntaxList`1<StatementSyntax> get_Statements();
    public SyntaxToken get_CloseBraceToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public BlockSyntax Update(SyntaxToken openBraceToken, SyntaxList`1<StatementSyntax> statements, SyntaxToken closeBraceToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedArgumentListSyntax : BaseArgumentListSyntax {
    internal SyntaxToken openBracketToken;
    internal CSharpSyntaxNode arguments;
    internal SyntaxToken closeBracketToken;
    public SyntaxToken OpenBracketToken { get; }
    public SeparatedSyntaxList`1<ArgumentSyntax> Arguments { get; }
    public SyntaxToken CloseBracketToken { get; }
    internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode arguments, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode arguments, SyntaxToken closeBracketToken, SyntaxFactoryContext context);
    internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode arguments, SyntaxToken closeBracketToken);
    internal BracketedArgumentListSyntax(ObjectReader reader);
    public SyntaxToken get_OpenBracketToken();
    public virtual SeparatedSyntaxList`1<ArgumentSyntax> get_Arguments();
    public SyntaxToken get_CloseBracketToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public BracketedArgumentListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList`1<ArgumentSyntax> arguments, SyntaxToken closeBracketToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedParameterListSyntax : BaseParameterListSyntax {
    internal SyntaxToken openBracketToken;
    internal CSharpSyntaxNode parameters;
    internal SyntaxToken closeBracketToken;
    public SyntaxToken OpenBracketToken { get; }
    public SeparatedSyntaxList`1<ParameterSyntax> Parameters { get; }
    public SyntaxToken CloseBracketToken { get; }
    internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode parameters, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode parameters, SyntaxToken closeBracketToken, SyntaxFactoryContext context);
    internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode parameters, SyntaxToken closeBracketToken);
    internal BracketedParameterListSyntax(ObjectReader reader);
    public SyntaxToken get_OpenBracketToken();
    public virtual SeparatedSyntaxList`1<ParameterSyntax> get_Parameters();
    public SyntaxToken get_CloseBracketToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public BracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList`1<ParameterSyntax> parameters, SyntaxToken closeBracketToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BranchingDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public bool BranchTaken { get; }
    internal BranchingDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal BranchingDirectiveTriviaSyntax(SyntaxKind kind);
    protected BranchingDirectiveTriviaSyntax(ObjectReader reader);
    public abstract virtual bool get_BranchTaken();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BreakStatementSyntax : StatementSyntax {
    internal SyntaxToken breakKeyword;
    internal SyntaxToken semicolonToken;
    public SyntaxToken BreakKeyword { get; }
    public SyntaxToken SemicolonToken { get; }
    internal BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken);
    internal BreakStatementSyntax(ObjectReader reader);
    public SyntaxToken get_BreakKeyword();
    public SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public BreakStatementSyntax Update(SyntaxToken breakKeyword, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CaseSwitchLabelSyntax : SwitchLabelSyntax {
    internal SyntaxToken keyword;
    internal ExpressionSyntax value;
    internal SyntaxToken colonToken;
    public SyntaxToken Keyword { get; }
    public ExpressionSyntax Value { get; }
    public SyntaxToken ColonToken { get; }
    internal CaseSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal CaseSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken, SyntaxFactoryContext context);
    internal CaseSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken);
    internal CaseSwitchLabelSyntax(ObjectReader reader);
    public virtual SyntaxToken get_Keyword();
    public ExpressionSyntax get_Value();
    public virtual SyntaxToken get_ColonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CaseSwitchLabelSyntax Update(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CastExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken openParenToken;
    internal TypeSyntax type;
    internal SyntaxToken closeParenToken;
    internal ExpressionSyntax expression;
    public SyntaxToken OpenParenToken { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken CloseParenToken { get; }
    public ExpressionSyntax Expression { get; }
    internal CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression, SyntaxFactoryContext context);
    internal CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression);
    internal CastExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_OpenParenToken();
    public TypeSyntax get_Type();
    public SyntaxToken get_CloseParenToken();
    public ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CastExpressionSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CatchClauseSyntax : CSharpSyntaxNode {
    internal SyntaxToken catchKeyword;
    internal CatchDeclarationSyntax declaration;
    internal CatchFilterClauseSyntax filter;
    internal BlockSyntax block;
    public SyntaxToken CatchKeyword { get; }
    public CatchDeclarationSyntax Declaration { get; }
    public CatchFilterClauseSyntax Filter { get; }
    public BlockSyntax Block { get; }
    internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block, SyntaxFactoryContext context);
    internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block);
    internal CatchClauseSyntax(ObjectReader reader);
    public SyntaxToken get_CatchKeyword();
    public CatchDeclarationSyntax get_Declaration();
    public CatchFilterClauseSyntax get_Filter();
    public BlockSyntax get_Block();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CatchClauseSyntax Update(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CatchDeclarationSyntax : CSharpSyntaxNode {
    internal SyntaxToken openParenToken;
    internal TypeSyntax type;
    internal SyntaxToken identifier;
    internal SyntaxToken closeParenToken;
    public SyntaxToken OpenParenToken { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken Identifier { get; }
    public SyntaxToken CloseParenToken { get; }
    internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken, SyntaxFactoryContext context);
    internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken);
    internal CatchDeclarationSyntax(ObjectReader reader);
    public SyntaxToken get_OpenParenToken();
    public TypeSyntax get_Type();
    public SyntaxToken get_Identifier();
    public SyntaxToken get_CloseParenToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CatchDeclarationSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CatchFilterClauseSyntax : CSharpSyntaxNode {
    internal SyntaxToken whenKeyword;
    internal SyntaxToken openParenToken;
    internal ExpressionSyntax filterExpression;
    internal SyntaxToken closeParenToken;
    public SyntaxToken WhenKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax FilterExpression { get; }
    public SyntaxToken CloseParenToken { get; }
    internal CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken, SyntaxFactoryContext context);
    internal CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken);
    internal CatchFilterClauseSyntax(ObjectReader reader);
    public SyntaxToken get_WhenKeyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_FilterExpression();
    public SyntaxToken get_CloseParenToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CatchFilterClauseSyntax Update(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CheckedExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken keyword;
    internal SyntaxToken openParenToken;
    internal ExpressionSyntax expression;
    internal SyntaxToken closeParenToken;
    public SyntaxToken Keyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    internal CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context);
    internal CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    internal CheckedExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_Keyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CheckedExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CheckedStatementSyntax : StatementSyntax {
    internal SyntaxToken keyword;
    internal BlockSyntax block;
    public SyntaxToken Keyword { get; }
    public BlockSyntax Block { get; }
    internal CheckedStatementSyntax(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal CheckedStatementSyntax(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block, SyntaxFactoryContext context);
    internal CheckedStatementSyntax(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block);
    internal CheckedStatementSyntax(ObjectReader reader);
    public SyntaxToken get_Keyword();
    public BlockSyntax get_Block();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CheckedStatementSyntax Update(SyntaxToken keyword, BlockSyntax block);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ChildSyntaxList : ValueType {
    private GreenNode _node;
    private int _count;
    public int Count { get; }
    private GreenNode[] Nodes { get; }
    internal ChildSyntaxList(GreenNode node);
    public int get_Count();
    private int CountNodes();
    private GreenNode[] get_Nodes();
    public Enumerator GetEnumerator();
    public Reversed Reverse();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ClassDeclarationSyntax : TypeDeclarationSyntax {
    internal CSharpSyntaxNode attributeLists;
    internal CSharpSyntaxNode modifiers;
    internal SyntaxToken keyword;
    internal SyntaxToken identifier;
    internal TypeParameterListSyntax typeParameterList;
    internal BaseListSyntax baseList;
    internal CSharpSyntaxNode constraintClauses;
    internal SyntaxToken openBraceToken;
    internal CSharpSyntaxNode members;
    internal SyntaxToken closeBraceToken;
    internal SyntaxToken semicolonToken;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public SyntaxToken Keyword { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public BaseListSyntax BaseList { get; }
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    public SyntaxToken CloseBraceToken { get; }
    public SyntaxToken SemicolonToken { get; }
    internal ClassDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, CSharpSyntaxNode constraintClauses, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ClassDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, CSharpSyntaxNode constraintClauses, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal ClassDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, CSharpSyntaxNode constraintClauses, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    internal ClassDeclarationSyntax(ObjectReader reader);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxList`1<SyntaxToken> get_Modifiers();
    public virtual SyntaxToken get_Keyword();
    public virtual SyntaxToken get_Identifier();
    public virtual TypeParameterListSyntax get_TypeParameterList();
    public virtual BaseListSyntax get_BaseList();
    public virtual SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public virtual SyntaxToken get_OpenBraceToken();
    public virtual SyntaxList`1<MemberDeclarationSyntax> get_Members();
    public virtual SyntaxToken get_CloseBraceToken();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ClassDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ClassOrStructConstraintSyntax : TypeParameterConstraintSyntax {
    internal SyntaxToken classOrStructKeyword;
    public SyntaxToken ClassOrStructKeyword { get; }
    internal ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxFactoryContext context);
    internal ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword);
    internal ClassOrStructConstraintSyntax(ObjectReader reader);
    public SyntaxToken get_ClassOrStructKeyword();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ClassOrStructConstraintSyntax Update(SyntaxToken classOrStructKeyword);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CompilationUnitSyntax : CSharpSyntaxNode {
    internal CSharpSyntaxNode externs;
    internal CSharpSyntaxNode usings;
    internal CSharpSyntaxNode attributeLists;
    internal CSharpSyntaxNode members;
    internal SyntaxToken endOfFileToken;
    public SyntaxList`1<ExternAliasDirectiveSyntax> Externs { get; }
    public SyntaxList`1<UsingDirectiveSyntax> Usings { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    public SyntaxToken EndOfFileToken { get; }
    internal CompilationUnitSyntax(SyntaxKind kind, CSharpSyntaxNode externs, CSharpSyntaxNode usings, CSharpSyntaxNode attributeLists, CSharpSyntaxNode members, SyntaxToken endOfFileToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal CompilationUnitSyntax(SyntaxKind kind, CSharpSyntaxNode externs, CSharpSyntaxNode usings, CSharpSyntaxNode attributeLists, CSharpSyntaxNode members, SyntaxToken endOfFileToken, SyntaxFactoryContext context);
    internal CompilationUnitSyntax(SyntaxKind kind, CSharpSyntaxNode externs, CSharpSyntaxNode usings, CSharpSyntaxNode attributeLists, CSharpSyntaxNode members, SyntaxToken endOfFileToken);
    internal CompilationUnitSyntax(ObjectReader reader);
    public SyntaxList`1<ExternAliasDirectiveSyntax> get_Externs();
    public SyntaxList`1<UsingDirectiveSyntax> get_Usings();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxList`1<MemberDeclarationSyntax> get_Members();
    public SyntaxToken get_EndOfFileToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CompilationUnitSyntax Update(SyntaxList`1<ExternAliasDirectiveSyntax> externs, SyntaxList`1<UsingDirectiveSyntax> usings, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalAccessExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax expression;
    internal SyntaxToken operatorToken;
    internal ExpressionSyntax whenNotNull;
    public ExpressionSyntax Expression { get; }
    public SyntaxToken OperatorToken { get; }
    public ExpressionSyntax WhenNotNull { get; }
    internal ConditionalAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ConditionalAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull, SyntaxFactoryContext context);
    internal ConditionalAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull);
    internal ConditionalAccessExpressionSyntax(ObjectReader reader);
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_OperatorToken();
    public ExpressionSyntax get_WhenNotNull();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ConditionalAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax {
    public ExpressionSyntax Condition { get; }
    public bool ConditionValue { get; }
    internal ConditionalDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ConditionalDirectiveTriviaSyntax(SyntaxKind kind);
    protected ConditionalDirectiveTriviaSyntax(ObjectReader reader);
    public abstract virtual ExpressionSyntax get_Condition();
    public abstract virtual bool get_ConditionValue();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax condition;
    internal SyntaxToken questionToken;
    internal ExpressionSyntax whenTrue;
    internal SyntaxToken colonToken;
    internal ExpressionSyntax whenFalse;
    public ExpressionSyntax Condition { get; }
    public SyntaxToken QuestionToken { get; }
    public ExpressionSyntax WhenTrue { get; }
    public SyntaxToken ColonToken { get; }
    public ExpressionSyntax WhenFalse { get; }
    internal ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse, SyntaxFactoryContext context);
    internal ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse);
    internal ConditionalExpressionSyntax(ObjectReader reader);
    public ExpressionSyntax get_Condition();
    public SyntaxToken get_QuestionToken();
    public ExpressionSyntax get_WhenTrue();
    public SyntaxToken get_ColonToken();
    public ExpressionSyntax get_WhenFalse();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ConditionalExpressionSyntax Update(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorConstraintSyntax : TypeParameterConstraintSyntax {
    internal SyntaxToken newKeyword;
    internal SyntaxToken openParenToken;
    internal SyntaxToken closeParenToken;
    public SyntaxToken NewKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public SyntaxToken CloseParenToken { get; }
    internal ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken, SyntaxFactoryContext context);
    internal ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken);
    internal ConstructorConstraintSyntax(ObjectReader reader);
    public SyntaxToken get_NewKeyword();
    public SyntaxToken get_OpenParenToken();
    public SyntaxToken get_CloseParenToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ConstructorConstraintSyntax Update(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorDeclarationSyntax : BaseMethodDeclarationSyntax {
    internal CSharpSyntaxNode attributeLists;
    internal CSharpSyntaxNode modifiers;
    internal SyntaxToken identifier;
    internal ParameterListSyntax parameterList;
    internal ConstructorInitializerSyntax initializer;
    internal BlockSyntax body;
    internal SyntaxToken semicolonToken;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public SyntaxToken Identifier { get; }
    public ParameterListSyntax ParameterList { get; }
    public ConstructorInitializerSyntax Initializer { get; }
    public BlockSyntax Body { get; }
    public SyntaxToken SemicolonToken { get; }
    internal ConstructorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ConstructorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal ConstructorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken);
    internal ConstructorDeclarationSyntax(ObjectReader reader);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxList`1<SyntaxToken> get_Modifiers();
    public SyntaxToken get_Identifier();
    public virtual ParameterListSyntax get_ParameterList();
    public ConstructorInitializerSyntax get_Initializer();
    public virtual BlockSyntax get_Body();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ConstructorDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorInitializerSyntax : CSharpSyntaxNode {
    internal SyntaxToken colonToken;
    internal SyntaxToken thisOrBaseKeyword;
    internal ArgumentListSyntax argumentList;
    public SyntaxToken ColonToken { get; }
    public SyntaxToken ThisOrBaseKeyword { get; }
    public ArgumentListSyntax ArgumentList { get; }
    internal ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList, SyntaxFactoryContext context);
    internal ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList);
    internal ConstructorInitializerSyntax(ObjectReader reader);
    public SyntaxToken get_ColonToken();
    public SyntaxToken get_ThisOrBaseKeyword();
    public ArgumentListSyntax get_ArgumentList();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ConstructorInitializerSyntax Update(SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ContextAwareSyntax : object {
    private SyntaxFactoryContext context;
    public ContextAwareSyntax(SyntaxFactoryContext context);
    public IdentifierNameSyntax IdentifierName(SyntaxToken identifier);
    public QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right);
    public GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList);
    public TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, SeparatedSyntaxList`1<TypeSyntax> arguments, SyntaxToken greaterThanToken);
    public AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name);
    public PredefinedTypeSyntax PredefinedType(SyntaxToken keyword);
    public ArrayTypeSyntax ArrayType(TypeSyntax elementType, SyntaxList`1<ArrayRankSpecifierSyntax> rankSpecifiers);
    public ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, SeparatedSyntaxList`1<ExpressionSyntax> sizes, SyntaxToken closeBracketToken);
    public PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken);
    public NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken);
    public OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken);
    public ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand);
    public AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, ExpressionSyntax expression);
    public PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken);
    public MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name);
    public ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull);
    public MemberBindingExpressionSyntax MemberBindingExpression(SyntaxToken operatorToken, SimpleNameSyntax name);
    public ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList);
    public ImplicitElementAccessSyntax ImplicitElementAccess(BracketedArgumentListSyntax argumentList);
    public BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse);
    public ThisExpressionSyntax ThisExpression(SyntaxToken token);
    public BaseExpressionSyntax BaseExpression(SyntaxToken token);
    public LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token);
    public MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken);
    public CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    public TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    public SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    public InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList);
    public ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList);
    public ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList`1<ArgumentSyntax> arguments, SyntaxToken closeParenToken);
    public BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, SeparatedSyntaxList`1<ArgumentSyntax> arguments, SyntaxToken closeBracketToken);
    public ArgumentSyntax Argument(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression);
    public NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken);
    public CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression);
    public AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body);
    public SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body);
    public ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body);
    public InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, SeparatedSyntaxList`1<ExpressionSyntax> expressions, SyntaxToken closeBraceToken);
    public ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer);
    public AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax nameEquals, ExpressionSyntax expression);
    public AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList`1<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken);
    public ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer);
    public ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxList`1<SyntaxToken> commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer);
    public StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type);
    public QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body);
    public QueryBodySyntax QueryBody(SyntaxList`1<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation);
    public FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression);
    public LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression);
    public JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into);
    public JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier);
    public WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition);
    public OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, SeparatedSyntaxList`1<OrderingSyntax> orderings);
    public OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword);
    public SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression);
    public GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression);
    public QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body);
    public OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken);
    public InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList`1<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken);
    public InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken);
    public InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken);
    public InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExpressionSyntax value);
    public InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken);
    public GlobalStatementSyntax GlobalStatement(StatementSyntax statement);
    public BlockSyntax Block(SyntaxToken openBraceToken, SyntaxList`1<StatementSyntax> statements, SyntaxToken closeBraceToken);
    public LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxList`1<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    public VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SeparatedSyntaxList`1<VariableDeclaratorSyntax> variables);
    public VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer);
    public EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, ExpressionSyntax value);
    public ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken semicolonToken);
    public EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken);
    public LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement);
    public GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    public BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken);
    public ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken);
    public ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    public ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    public YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    public WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement);
    public DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken);
    public ForStatementSyntax ForStatement(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList`1<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList`1<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement);
    public ForEachStatementSyntax ForEachStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    public UsingStatementSyntax UsingStatement(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    public FixedStatementSyntax FixedStatement(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement);
    public CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block);
    public UnsafeStatementSyntax UnsafeStatement(SyntaxToken unsafeKeyword, BlockSyntax block);
    public LockStatementSyntax LockStatement(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    public IfStatementSyntax IfStatement(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax else);
    public ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement);
    public SwitchStatementSyntax SwitchStatement(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList`1<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken);
    public SwitchSectionSyntax SwitchSection(SyntaxList`1<SwitchLabelSyntax> labels, SyntaxList`1<StatementSyntax> statements);
    public CaseSwitchLabelSyntax CaseSwitchLabel(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken);
    public DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken keyword, SyntaxToken colonToken);
    public TryStatementSyntax TryStatement(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList`1<CatchClauseSyntax> catches, FinallyClauseSyntax finally);
    public CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block);
    public CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken);
    public CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken);
    public FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block);
    public CompilationUnitSyntax CompilationUnit(SyntaxList`1<ExternAliasDirectiveSyntax> externs, SyntaxList`1<UsingDirectiveSyntax> usings, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken);
    public ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken);
    public UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken);
    public NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList`1<ExternAliasDirectiveSyntax> externs, SyntaxList`1<UsingDirectiveSyntax> usings, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public AttributeListSyntax AttributeList(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList`1<AttributeSyntax> attributes, SyntaxToken closeBracketToken);
    public AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken);
    public AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax argumentList);
    public AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList`1<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken);
    public AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression);
    public NameEqualsSyntax NameEquals(IdentifierNameSyntax name, SyntaxToken equalsToken);
    public TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, SeparatedSyntaxList`1<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken);
    public TypeParameterSyntax TypeParameter(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier);
    public ClassDeclarationSyntax ClassDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public StructDeclarationSyntax StructDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public EnumDeclarationSyntax EnumDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList`1<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public DelegateDeclarationSyntax DelegateDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken);
    public EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue);
    public BaseListSyntax BaseList(SyntaxToken colonToken, SeparatedSyntaxList`1<BaseTypeSyntax> types);
    public SimpleBaseTypeSyntax SimpleBaseType(TypeSyntax type);
    public TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList`1<TypeParameterConstraintSyntax> constraints);
    public ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken);
    public ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword);
    public TypeConstraintSyntax TypeConstraint(TypeSyntax type);
    public FieldDeclarationSyntax FieldDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    public EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken);
    public MethodDeclarationSyntax MethodDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public OperatorDeclarationSyntax OperatorDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken);
    public ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList);
    public DestructorDeclarationSyntax DestructorDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken);
    public PropertyDeclarationSyntax PropertyDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken);
    public ArrowExpressionClauseSyntax ArrowExpressionClause(SyntaxToken arrowToken, ExpressionSyntax expression);
    public EventDeclarationSyntax EventDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList);
    public IndexerDeclarationSyntax IndexerDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public AccessorListSyntax AccessorList(SyntaxToken openBraceToken, SyntaxList`1<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken);
    public AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken);
    public ParameterListSyntax ParameterList(SyntaxToken openParenToken, SeparatedSyntaxList`1<ParameterSyntax> parameters, SyntaxToken closeParenToken);
    public BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList`1<ParameterSyntax> parameters, SyntaxToken closeBracketToken);
    public ParameterSyntax Parameter(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax default);
    public IncompleteMemberSyntax IncompleteMember(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, TypeSyntax type);
    public SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxList`1<SyntaxToken> tokens);
    public DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, SyntaxList`1<XmlNodeSyntax> content, SyntaxToken endOfComment);
    public TypeCrefSyntax TypeCref(TypeSyntax type);
    public QualifiedCrefSyntax QualifiedCref(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member);
    public NameMemberCrefSyntax NameMemberCref(TypeSyntax name, CrefParameterListSyntax parameters);
    public IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters);
    public OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters);
    public ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters);
    public CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, SeparatedSyntaxList`1<CrefParameterSyntax> parameters, SyntaxToken closeParenToken);
    public CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList`1<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken);
    public CrefParameterSyntax CrefParameter(SyntaxToken refOrOutKeyword, TypeSyntax type);
    public XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, SyntaxList`1<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag);
    public XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList`1<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken);
    public XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken);
    public XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList`1<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken);
    public XmlNameSyntax XmlName(XmlPrefixSyntax prefix, SyntaxToken localName);
    public XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken);
    public XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxList`1<SyntaxToken> textTokens, SyntaxToken endQuoteToken);
    public XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken);
    public XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken);
    public XmlTextSyntax XmlText(SyntaxList`1<SyntaxToken> textTokens);
    public XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, SyntaxList`1<SyntaxToken> textTokens, SyntaxToken endCDataToken);
    public XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxList`1<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken);
    public XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxList`1<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken);
    public IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue);
    public ElifDirectiveTriviaSyntax ElifDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue);
    public ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken);
    public EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public WarningDirectiveTriviaSyntax WarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive);
    public DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive);
    public UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive);
    public LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    public PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList`1<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive);
    public PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive);
    public ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    public LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    public ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ContinueStatementSyntax : StatementSyntax {
    internal SyntaxToken continueKeyword;
    internal SyntaxToken semicolonToken;
    public SyntaxToken ContinueKeyword { get; }
    public SyntaxToken SemicolonToken { get; }
    internal ContinueStatementSyntax(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ContinueStatementSyntax(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal ContinueStatementSyntax(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken);
    internal ContinueStatementSyntax(ObjectReader reader);
    public SyntaxToken get_ContinueKeyword();
    public SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ContinueStatementSyntax Update(SyntaxToken continueKeyword, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax : BaseMethodDeclarationSyntax {
    internal CSharpSyntaxNode attributeLists;
    internal CSharpSyntaxNode modifiers;
    internal SyntaxToken implicitOrExplicitKeyword;
    internal SyntaxToken operatorKeyword;
    internal TypeSyntax type;
    internal ParameterListSyntax parameterList;
    internal BlockSyntax body;
    internal ArrowExpressionClauseSyntax expressionBody;
    internal SyntaxToken semicolonToken;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public SyntaxToken ImplicitOrExplicitKeyword { get; }
    public SyntaxToken OperatorKeyword { get; }
    public TypeSyntax Type { get; }
    public ParameterListSyntax ParameterList { get; }
    public BlockSyntax Body { get; }
    public ArrowExpressionClauseSyntax ExpressionBody { get; }
    public SyntaxToken SemicolonToken { get; }
    internal ConversionOperatorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ConversionOperatorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal ConversionOperatorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    internal ConversionOperatorDeclarationSyntax(ObjectReader reader);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxList`1<SyntaxToken> get_Modifiers();
    public SyntaxToken get_ImplicitOrExplicitKeyword();
    public SyntaxToken get_OperatorKeyword();
    public TypeSyntax get_Type();
    public virtual ParameterListSyntax get_ParameterList();
    public virtual BlockSyntax get_Body();
    public ArrowExpressionClauseSyntax get_ExpressionBody();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ConversionOperatorDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorMemberCrefSyntax : MemberCrefSyntax {
    internal SyntaxToken implicitOrExplicitKeyword;
    internal SyntaxToken operatorKeyword;
    internal TypeSyntax type;
    internal CrefParameterListSyntax parameters;
    public SyntaxToken ImplicitOrExplicitKeyword { get; }
    public SyntaxToken OperatorKeyword { get; }
    public TypeSyntax Type { get; }
    public CrefParameterListSyntax Parameters { get; }
    internal ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters, SyntaxFactoryContext context);
    internal ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters);
    internal ConversionOperatorMemberCrefSyntax(ObjectReader reader);
    public SyntaxToken get_ImplicitOrExplicitKeyword();
    public SyntaxToken get_OperatorKeyword();
    public TypeSyntax get_Type();
    public CrefParameterListSyntax get_Parameters();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ConversionOperatorMemberCrefSyntax Update(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefBracketedParameterListSyntax : BaseCrefParameterListSyntax {
    internal SyntaxToken openBracketToken;
    internal CSharpSyntaxNode parameters;
    internal SyntaxToken closeBracketToken;
    public SyntaxToken OpenBracketToken { get; }
    public SeparatedSyntaxList`1<CrefParameterSyntax> Parameters { get; }
    public SyntaxToken CloseBracketToken { get; }
    internal CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode parameters, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode parameters, SyntaxToken closeBracketToken, SyntaxFactoryContext context);
    internal CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, CSharpSyntaxNode parameters, SyntaxToken closeBracketToken);
    internal CrefBracketedParameterListSyntax(ObjectReader reader);
    public SyntaxToken get_OpenBracketToken();
    public virtual SeparatedSyntaxList`1<CrefParameterSyntax> get_Parameters();
    public SyntaxToken get_CloseBracketToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CrefBracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList`1<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterListSyntax : BaseCrefParameterListSyntax {
    internal SyntaxToken openParenToken;
    internal CSharpSyntaxNode parameters;
    internal SyntaxToken closeParenToken;
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxList`1<CrefParameterSyntax> Parameters { get; }
    public SyntaxToken CloseParenToken { get; }
    internal CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode parameters, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode parameters, SyntaxToken closeParenToken, SyntaxFactoryContext context);
    internal CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode parameters, SyntaxToken closeParenToken);
    internal CrefParameterListSyntax(ObjectReader reader);
    public SyntaxToken get_OpenParenToken();
    public virtual SeparatedSyntaxList`1<CrefParameterSyntax> get_Parameters();
    public SyntaxToken get_CloseParenToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CrefParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList`1<CrefParameterSyntax> parameters, SyntaxToken closeParenToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterSyntax : CSharpSyntaxNode {
    internal SyntaxToken refOrOutKeyword;
    internal TypeSyntax type;
    public SyntaxToken RefOrOutKeyword { get; }
    public TypeSyntax Type { get; }
    internal CrefParameterSyntax(SyntaxKind kind, SyntaxToken refOrOutKeyword, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal CrefParameterSyntax(SyntaxKind kind, SyntaxToken refOrOutKeyword, TypeSyntax type, SyntaxFactoryContext context);
    internal CrefParameterSyntax(SyntaxKind kind, SyntaxToken refOrOutKeyword, TypeSyntax type);
    internal CrefParameterSyntax(ObjectReader reader);
    public SyntaxToken get_RefOrOutKeyword();
    public TypeSyntax get_Type();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public CrefParameterSyntax Update(SyntaxToken refOrOutKeyword, TypeSyntax type);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefSyntax : CSharpSyntaxNode {
    internal CrefSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal CrefSyntax(SyntaxKind kind);
    protected CrefSyntax(ObjectReader reader);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode : GreenNode {
    private static ConditionalWeakTable`2<SyntaxNode, Dictionary`2<SyntaxTrivia, SyntaxNode>> s_structuresTable;
    public string Language { get; }
    public SyntaxKind Kind { get; }
    public string KindText { get; }
    public int RawContextualKind { get; }
    public bool IsStructuredTrivia { get; }
    public bool IsDirective { get; }
    public AbstractSyntaxNavigator Navigator { get; }
    internal CSharpSyntaxNode(SyntaxKind kind);
    internal CSharpSyntaxNode(SyntaxKind kind, int fullWidth);
    internal CSharpSyntaxNode(SyntaxKind kind, DiagnosticInfo[] diagnostics);
    internal CSharpSyntaxNode(SyntaxKind kind, DiagnosticInfo[] diagnostics, int fullWidth);
    internal CSharpSyntaxNode(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal CSharpSyntaxNode(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations, int fullWidth);
    internal CSharpSyntaxNode(ObjectReader reader);
    private static CSharpSyntaxNode();
    public virtual string get_Language();
    public SyntaxKind get_Kind();
    public virtual string get_KindText();
    public virtual int get_RawContextualKind();
    public virtual bool get_IsStructuredTrivia();
    public virtual bool get_IsDirective();
    public virtual int GetSlotOffset(int index);
    internal ChildSyntaxList ChildNodesAndTokens();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode/<EnumerateNodes>d__21")]
internal IEnumerable`1<GreenNode> EnumerateNodes();
    public SyntaxToken GetFirstToken();
    public SyntaxToken GetLastToken();
    public SyntaxToken GetLastNonmissingToken();
    public virtual CSharpSyntaxNode GetLeadingTrivia();
    public virtual GreenNode GetLeadingTriviaCore();
    public virtual CSharpSyntaxNode GetTrailingTrivia();
    public virtual GreenNode GetTrailingTriviaCore();
    public virtual string ToString();
    public virtual string ToFullString();
    public abstract virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public abstract virtual void Accept(CSharpSyntaxVisitor visitor);
    internal virtual DirectiveStack ApplyDirectives(DirectiveStack stack);
    internal virtual IList`1<DirectiveTriviaSyntax> GetDirectives();
    private static void GetDirectives(GreenNode node, List`1<DirectiveTriviaSyntax> directives);
    protected void SetFactoryContext(SyntaxFactoryContext context);
    internal static NodeFlags SetFactoryContext(NodeFlags flags, SyntaxFactoryContext context);
    public virtual AbstractSyntaxNavigator get_Navigator();
    public virtual GreenNode CreateList(IEnumerable`1<GreenNode> nodes, bool alwaysCreateListNode);
    public virtual SyntaxToken CreateSeparator(SyntaxNode element);
    public virtual bool IsTriviaWithEndOfLine();
    public virtual SyntaxNode GetStructure(SyntaxTrivia trivia);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxRewriter : CSharpSyntaxVisitor`1<CSharpSyntaxNode> {
    protected bool VisitIntoStructuredTrivia;
    public CSharpSyntaxRewriter(bool visitIntoStructuredTrivia);
    public virtual CSharpSyntaxNode VisitToken(SyntaxToken token);
    public SyntaxList`1<TNode> VisitList(SyntaxList`1<TNode> list);
    public SeparatedSyntaxList`1<TNode> VisitList(SeparatedSyntaxList`1<TNode> list);
    public virtual CSharpSyntaxNode VisitIdentifierName(IdentifierNameSyntax node);
    public virtual CSharpSyntaxNode VisitQualifiedName(QualifiedNameSyntax node);
    public virtual CSharpSyntaxNode VisitGenericName(GenericNameSyntax node);
    public virtual CSharpSyntaxNode VisitTypeArgumentList(TypeArgumentListSyntax node);
    public virtual CSharpSyntaxNode VisitAliasQualifiedName(AliasQualifiedNameSyntax node);
    public virtual CSharpSyntaxNode VisitPredefinedType(PredefinedTypeSyntax node);
    public virtual CSharpSyntaxNode VisitArrayType(ArrayTypeSyntax node);
    public virtual CSharpSyntaxNode VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node);
    public virtual CSharpSyntaxNode VisitPointerType(PointerTypeSyntax node);
    public virtual CSharpSyntaxNode VisitNullableType(NullableTypeSyntax node);
    public virtual CSharpSyntaxNode VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node);
    public virtual CSharpSyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitAwaitExpression(AwaitExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitMemberBindingExpression(MemberBindingExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitElementBindingExpression(ElementBindingExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitImplicitElementAccess(ImplicitElementAccessSyntax node);
    public virtual CSharpSyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitAssignmentExpression(AssignmentExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitConditionalExpression(ConditionalExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitThisExpression(ThisExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitBaseExpression(BaseExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitMakeRefExpression(MakeRefExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitRefTypeExpression(RefTypeExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitRefValueExpression(RefValueExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitCheckedExpression(CheckedExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitDefaultExpression(DefaultExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitTypeOfExpression(TypeOfExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitSizeOfExpression(SizeOfExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitElementAccessExpression(ElementAccessExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitArgumentList(ArgumentListSyntax node);
    public virtual CSharpSyntaxNode VisitBracketedArgumentList(BracketedArgumentListSyntax node);
    public virtual CSharpSyntaxNode VisitArgument(ArgumentSyntax node);
    public virtual CSharpSyntaxNode VisitNameColon(NameColonSyntax node);
    public virtual CSharpSyntaxNode VisitCastExpression(CastExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitInitializerExpression(InitializerExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node);
    public virtual CSharpSyntaxNode VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitArrayCreationExpression(ArrayCreationExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitQueryExpression(QueryExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitQueryBody(QueryBodySyntax node);
    public virtual CSharpSyntaxNode VisitFromClause(FromClauseSyntax node);
    public virtual CSharpSyntaxNode VisitLetClause(LetClauseSyntax node);
    public virtual CSharpSyntaxNode VisitJoinClause(JoinClauseSyntax node);
    public virtual CSharpSyntaxNode VisitJoinIntoClause(JoinIntoClauseSyntax node);
    public virtual CSharpSyntaxNode VisitWhereClause(WhereClauseSyntax node);
    public virtual CSharpSyntaxNode VisitOrderByClause(OrderByClauseSyntax node);
    public virtual CSharpSyntaxNode VisitOrdering(OrderingSyntax node);
    public virtual CSharpSyntaxNode VisitSelectClause(SelectClauseSyntax node);
    public virtual CSharpSyntaxNode VisitGroupClause(GroupClauseSyntax node);
    public virtual CSharpSyntaxNode VisitQueryContinuation(QueryContinuationSyntax node);
    public virtual CSharpSyntaxNode VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node);
    public virtual CSharpSyntaxNode VisitInterpolatedStringText(InterpolatedStringTextSyntax node);
    public virtual CSharpSyntaxNode VisitInterpolation(InterpolationSyntax node);
    public virtual CSharpSyntaxNode VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node);
    public virtual CSharpSyntaxNode VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node);
    public virtual CSharpSyntaxNode VisitGlobalStatement(GlobalStatementSyntax node);
    public virtual CSharpSyntaxNode VisitBlock(BlockSyntax node);
    public virtual CSharpSyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node);
    public virtual CSharpSyntaxNode VisitVariableDeclaration(VariableDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitVariableDeclarator(VariableDeclaratorSyntax node);
    public virtual CSharpSyntaxNode VisitEqualsValueClause(EqualsValueClauseSyntax node);
    public virtual CSharpSyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node);
    public virtual CSharpSyntaxNode VisitEmptyStatement(EmptyStatementSyntax node);
    public virtual CSharpSyntaxNode VisitLabeledStatement(LabeledStatementSyntax node);
    public virtual CSharpSyntaxNode VisitGotoStatement(GotoStatementSyntax node);
    public virtual CSharpSyntaxNode VisitBreakStatement(BreakStatementSyntax node);
    public virtual CSharpSyntaxNode VisitContinueStatement(ContinueStatementSyntax node);
    public virtual CSharpSyntaxNode VisitReturnStatement(ReturnStatementSyntax node);
    public virtual CSharpSyntaxNode VisitThrowStatement(ThrowStatementSyntax node);
    public virtual CSharpSyntaxNode VisitYieldStatement(YieldStatementSyntax node);
    public virtual CSharpSyntaxNode VisitWhileStatement(WhileStatementSyntax node);
    public virtual CSharpSyntaxNode VisitDoStatement(DoStatementSyntax node);
    public virtual CSharpSyntaxNode VisitForStatement(ForStatementSyntax node);
    public virtual CSharpSyntaxNode VisitForEachStatement(ForEachStatementSyntax node);
    public virtual CSharpSyntaxNode VisitUsingStatement(UsingStatementSyntax node);
    public virtual CSharpSyntaxNode VisitFixedStatement(FixedStatementSyntax node);
    public virtual CSharpSyntaxNode VisitCheckedStatement(CheckedStatementSyntax node);
    public virtual CSharpSyntaxNode VisitUnsafeStatement(UnsafeStatementSyntax node);
    public virtual CSharpSyntaxNode VisitLockStatement(LockStatementSyntax node);
    public virtual CSharpSyntaxNode VisitIfStatement(IfStatementSyntax node);
    public virtual CSharpSyntaxNode VisitElseClause(ElseClauseSyntax node);
    public virtual CSharpSyntaxNode VisitSwitchStatement(SwitchStatementSyntax node);
    public virtual CSharpSyntaxNode VisitSwitchSection(SwitchSectionSyntax node);
    public virtual CSharpSyntaxNode VisitCaseSwitchLabel(CaseSwitchLabelSyntax node);
    public virtual CSharpSyntaxNode VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node);
    public virtual CSharpSyntaxNode VisitTryStatement(TryStatementSyntax node);
    public virtual CSharpSyntaxNode VisitCatchClause(CatchClauseSyntax node);
    public virtual CSharpSyntaxNode VisitCatchDeclaration(CatchDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitCatchFilterClause(CatchFilterClauseSyntax node);
    public virtual CSharpSyntaxNode VisitFinallyClause(FinallyClauseSyntax node);
    public virtual CSharpSyntaxNode VisitCompilationUnit(CompilationUnitSyntax node);
    public virtual CSharpSyntaxNode VisitExternAliasDirective(ExternAliasDirectiveSyntax node);
    public virtual CSharpSyntaxNode VisitUsingDirective(UsingDirectiveSyntax node);
    public virtual CSharpSyntaxNode VisitNamespaceDeclaration(NamespaceDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitAttributeList(AttributeListSyntax node);
    public virtual CSharpSyntaxNode VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node);
    public virtual CSharpSyntaxNode VisitAttribute(AttributeSyntax node);
    public virtual CSharpSyntaxNode VisitAttributeArgumentList(AttributeArgumentListSyntax node);
    public virtual CSharpSyntaxNode VisitAttributeArgument(AttributeArgumentSyntax node);
    public virtual CSharpSyntaxNode VisitNameEquals(NameEqualsSyntax node);
    public virtual CSharpSyntaxNode VisitTypeParameterList(TypeParameterListSyntax node);
    public virtual CSharpSyntaxNode VisitTypeParameter(TypeParameterSyntax node);
    public virtual CSharpSyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitStructDeclaration(StructDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitInterfaceDeclaration(InterfaceDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitEnumDeclaration(EnumDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitDelegateDeclaration(DelegateDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitBaseList(BaseListSyntax node);
    public virtual CSharpSyntaxNode VisitSimpleBaseType(SimpleBaseTypeSyntax node);
    public virtual CSharpSyntaxNode VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node);
    public virtual CSharpSyntaxNode VisitConstructorConstraint(ConstructorConstraintSyntax node);
    public virtual CSharpSyntaxNode VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node);
    public virtual CSharpSyntaxNode VisitTypeConstraint(TypeConstraintSyntax node);
    public virtual CSharpSyntaxNode VisitFieldDeclaration(FieldDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitEventFieldDeclaration(EventFieldDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node);
    public virtual CSharpSyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitOperatorDeclaration(OperatorDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitConstructorDeclaration(ConstructorDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitConstructorInitializer(ConstructorInitializerSyntax node);
    public virtual CSharpSyntaxNode VisitDestructorDeclaration(DestructorDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitArrowExpressionClause(ArrowExpressionClauseSyntax node);
    public virtual CSharpSyntaxNode VisitEventDeclaration(EventDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitIndexerDeclaration(IndexerDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitAccessorList(AccessorListSyntax node);
    public virtual CSharpSyntaxNode VisitAccessorDeclaration(AccessorDeclarationSyntax node);
    public virtual CSharpSyntaxNode VisitParameterList(ParameterListSyntax node);
    public virtual CSharpSyntaxNode VisitBracketedParameterList(BracketedParameterListSyntax node);
    public virtual CSharpSyntaxNode VisitParameter(ParameterSyntax node);
    public virtual CSharpSyntaxNode VisitIncompleteMember(IncompleteMemberSyntax node);
    public virtual CSharpSyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node);
    public virtual CSharpSyntaxNode VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node);
    public virtual CSharpSyntaxNode VisitTypeCref(TypeCrefSyntax node);
    public virtual CSharpSyntaxNode VisitQualifiedCref(QualifiedCrefSyntax node);
    public virtual CSharpSyntaxNode VisitNameMemberCref(NameMemberCrefSyntax node);
    public virtual CSharpSyntaxNode VisitIndexerMemberCref(IndexerMemberCrefSyntax node);
    public virtual CSharpSyntaxNode VisitOperatorMemberCref(OperatorMemberCrefSyntax node);
    public virtual CSharpSyntaxNode VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node);
    public virtual CSharpSyntaxNode VisitCrefParameterList(CrefParameterListSyntax node);
    public virtual CSharpSyntaxNode VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node);
    public virtual CSharpSyntaxNode VisitCrefParameter(CrefParameterSyntax node);
    public virtual CSharpSyntaxNode VisitXmlElement(XmlElementSyntax node);
    public virtual CSharpSyntaxNode VisitXmlElementStartTag(XmlElementStartTagSyntax node);
    public virtual CSharpSyntaxNode VisitXmlElementEndTag(XmlElementEndTagSyntax node);
    public virtual CSharpSyntaxNode VisitXmlEmptyElement(XmlEmptyElementSyntax node);
    public virtual CSharpSyntaxNode VisitXmlName(XmlNameSyntax node);
    public virtual CSharpSyntaxNode VisitXmlPrefix(XmlPrefixSyntax node);
    public virtual CSharpSyntaxNode VisitXmlTextAttribute(XmlTextAttributeSyntax node);
    public virtual CSharpSyntaxNode VisitXmlCrefAttribute(XmlCrefAttributeSyntax node);
    public virtual CSharpSyntaxNode VisitXmlNameAttribute(XmlNameAttributeSyntax node);
    public virtual CSharpSyntaxNode VisitXmlText(XmlTextSyntax node);
    public virtual CSharpSyntaxNode VisitXmlCDataSection(XmlCDataSectionSyntax node);
    public virtual CSharpSyntaxNode VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node);
    public virtual CSharpSyntaxNode VisitXmlComment(XmlCommentSyntax node);
    public virtual CSharpSyntaxNode VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node);
    public virtual CSharpSyntaxNode VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node);
    public virtual CSharpSyntaxNode VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node);
    public virtual CSharpSyntaxNode VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node);
    public virtual CSharpSyntaxNode VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node);
    public virtual CSharpSyntaxNode VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node);
    public virtual CSharpSyntaxNode VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node);
    public virtual CSharpSyntaxNode VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node);
    public virtual CSharpSyntaxNode VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node);
    public virtual CSharpSyntaxNode VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node);
    public virtual CSharpSyntaxNode VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node);
    public virtual CSharpSyntaxNode VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node);
    public virtual CSharpSyntaxNode VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node);
    public virtual CSharpSyntaxNode VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node);
    public virtual CSharpSyntaxNode VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node);
    public virtual CSharpSyntaxNode VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node);
    public virtual CSharpSyntaxNode VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxVisitor : object {
    public virtual void Visit(CSharpSyntaxNode node);
    public virtual void VisitToken(SyntaxToken token);
    public virtual void VisitTrivia(SyntaxTrivia trivia);
    public virtual void DefaultVisit(CSharpSyntaxNode node);
    public virtual void VisitIdentifierName(IdentifierNameSyntax node);
    public virtual void VisitQualifiedName(QualifiedNameSyntax node);
    public virtual void VisitGenericName(GenericNameSyntax node);
    public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node);
    public virtual void VisitAliasQualifiedName(AliasQualifiedNameSyntax node);
    public virtual void VisitPredefinedType(PredefinedTypeSyntax node);
    public virtual void VisitArrayType(ArrayTypeSyntax node);
    public virtual void VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node);
    public virtual void VisitPointerType(PointerTypeSyntax node);
    public virtual void VisitNullableType(NullableTypeSyntax node);
    public virtual void VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node);
    public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node);
    public virtual void VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node);
    public virtual void VisitAwaitExpression(AwaitExpressionSyntax node);
    public virtual void VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node);
    public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node);
    public virtual void VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node);
    public virtual void VisitMemberBindingExpression(MemberBindingExpressionSyntax node);
    public virtual void VisitElementBindingExpression(ElementBindingExpressionSyntax node);
    public virtual void VisitImplicitElementAccess(ImplicitElementAccessSyntax node);
    public virtual void VisitBinaryExpression(BinaryExpressionSyntax node);
    public virtual void VisitAssignmentExpression(AssignmentExpressionSyntax node);
    public virtual void VisitConditionalExpression(ConditionalExpressionSyntax node);
    public virtual void VisitThisExpression(ThisExpressionSyntax node);
    public virtual void VisitBaseExpression(BaseExpressionSyntax node);
    public virtual void VisitLiteralExpression(LiteralExpressionSyntax node);
    public virtual void VisitMakeRefExpression(MakeRefExpressionSyntax node);
    public virtual void VisitRefTypeExpression(RefTypeExpressionSyntax node);
    public virtual void VisitRefValueExpression(RefValueExpressionSyntax node);
    public virtual void VisitCheckedExpression(CheckedExpressionSyntax node);
    public virtual void VisitDefaultExpression(DefaultExpressionSyntax node);
    public virtual void VisitTypeOfExpression(TypeOfExpressionSyntax node);
    public virtual void VisitSizeOfExpression(SizeOfExpressionSyntax node);
    public virtual void VisitInvocationExpression(InvocationExpressionSyntax node);
    public virtual void VisitElementAccessExpression(ElementAccessExpressionSyntax node);
    public virtual void VisitArgumentList(ArgumentListSyntax node);
    public virtual void VisitBracketedArgumentList(BracketedArgumentListSyntax node);
    public virtual void VisitArgument(ArgumentSyntax node);
    public virtual void VisitNameColon(NameColonSyntax node);
    public virtual void VisitCastExpression(CastExpressionSyntax node);
    public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node);
    public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node);
    public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node);
    public virtual void VisitInitializerExpression(InitializerExpressionSyntax node);
    public virtual void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node);
    public virtual void VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node);
    public virtual void VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node);
    public virtual void VisitArrayCreationExpression(ArrayCreationExpressionSyntax node);
    public virtual void VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node);
    public virtual void VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node);
    public virtual void VisitQueryExpression(QueryExpressionSyntax node);
    public virtual void VisitQueryBody(QueryBodySyntax node);
    public virtual void VisitFromClause(FromClauseSyntax node);
    public virtual void VisitLetClause(LetClauseSyntax node);
    public virtual void VisitJoinClause(JoinClauseSyntax node);
    public virtual void VisitJoinIntoClause(JoinIntoClauseSyntax node);
    public virtual void VisitWhereClause(WhereClauseSyntax node);
    public virtual void VisitOrderByClause(OrderByClauseSyntax node);
    public virtual void VisitOrdering(OrderingSyntax node);
    public virtual void VisitSelectClause(SelectClauseSyntax node);
    public virtual void VisitGroupClause(GroupClauseSyntax node);
    public virtual void VisitQueryContinuation(QueryContinuationSyntax node);
    public virtual void VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node);
    public virtual void VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node);
    public virtual void VisitInterpolatedStringText(InterpolatedStringTextSyntax node);
    public virtual void VisitInterpolation(InterpolationSyntax node);
    public virtual void VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node);
    public virtual void VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node);
    public virtual void VisitGlobalStatement(GlobalStatementSyntax node);
    public virtual void VisitBlock(BlockSyntax node);
    public virtual void VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node);
    public virtual void VisitVariableDeclaration(VariableDeclarationSyntax node);
    public virtual void VisitVariableDeclarator(VariableDeclaratorSyntax node);
    public virtual void VisitEqualsValueClause(EqualsValueClauseSyntax node);
    public virtual void VisitExpressionStatement(ExpressionStatementSyntax node);
    public virtual void VisitEmptyStatement(EmptyStatementSyntax node);
    public virtual void VisitLabeledStatement(LabeledStatementSyntax node);
    public virtual void VisitGotoStatement(GotoStatementSyntax node);
    public virtual void VisitBreakStatement(BreakStatementSyntax node);
    public virtual void VisitContinueStatement(ContinueStatementSyntax node);
    public virtual void VisitReturnStatement(ReturnStatementSyntax node);
    public virtual void VisitThrowStatement(ThrowStatementSyntax node);
    public virtual void VisitYieldStatement(YieldStatementSyntax node);
    public virtual void VisitWhileStatement(WhileStatementSyntax node);
    public virtual void VisitDoStatement(DoStatementSyntax node);
    public virtual void VisitForStatement(ForStatementSyntax node);
    public virtual void VisitForEachStatement(ForEachStatementSyntax node);
    public virtual void VisitUsingStatement(UsingStatementSyntax node);
    public virtual void VisitFixedStatement(FixedStatementSyntax node);
    public virtual void VisitCheckedStatement(CheckedStatementSyntax node);
    public virtual void VisitUnsafeStatement(UnsafeStatementSyntax node);
    public virtual void VisitLockStatement(LockStatementSyntax node);
    public virtual void VisitIfStatement(IfStatementSyntax node);
    public virtual void VisitElseClause(ElseClauseSyntax node);
    public virtual void VisitSwitchStatement(SwitchStatementSyntax node);
    public virtual void VisitSwitchSection(SwitchSectionSyntax node);
    public virtual void VisitCaseSwitchLabel(CaseSwitchLabelSyntax node);
    public virtual void VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node);
    public virtual void VisitTryStatement(TryStatementSyntax node);
    public virtual void VisitCatchClause(CatchClauseSyntax node);
    public virtual void VisitCatchDeclaration(CatchDeclarationSyntax node);
    public virtual void VisitCatchFilterClause(CatchFilterClauseSyntax node);
    public virtual void VisitFinallyClause(FinallyClauseSyntax node);
    public virtual void VisitCompilationUnit(CompilationUnitSyntax node);
    public virtual void VisitExternAliasDirective(ExternAliasDirectiveSyntax node);
    public virtual void VisitUsingDirective(UsingDirectiveSyntax node);
    public virtual void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node);
    public virtual void VisitAttributeList(AttributeListSyntax node);
    public virtual void VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node);
    public virtual void VisitAttribute(AttributeSyntax node);
    public virtual void VisitAttributeArgumentList(AttributeArgumentListSyntax node);
    public virtual void VisitAttributeArgument(AttributeArgumentSyntax node);
    public virtual void VisitNameEquals(NameEqualsSyntax node);
    public virtual void VisitTypeParameterList(TypeParameterListSyntax node);
    public virtual void VisitTypeParameter(TypeParameterSyntax node);
    public virtual void VisitClassDeclaration(ClassDeclarationSyntax node);
    public virtual void VisitStructDeclaration(StructDeclarationSyntax node);
    public virtual void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node);
    public virtual void VisitEnumDeclaration(EnumDeclarationSyntax node);
    public virtual void VisitDelegateDeclaration(DelegateDeclarationSyntax node);
    public virtual void VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node);
    public virtual void VisitBaseList(BaseListSyntax node);
    public virtual void VisitSimpleBaseType(SimpleBaseTypeSyntax node);
    public virtual void VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node);
    public virtual void VisitConstructorConstraint(ConstructorConstraintSyntax node);
    public virtual void VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node);
    public virtual void VisitTypeConstraint(TypeConstraintSyntax node);
    public virtual void VisitFieldDeclaration(FieldDeclarationSyntax node);
    public virtual void VisitEventFieldDeclaration(EventFieldDeclarationSyntax node);
    public virtual void VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node);
    public virtual void VisitMethodDeclaration(MethodDeclarationSyntax node);
    public virtual void VisitOperatorDeclaration(OperatorDeclarationSyntax node);
    public virtual void VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node);
    public virtual void VisitConstructorDeclaration(ConstructorDeclarationSyntax node);
    public virtual void VisitConstructorInitializer(ConstructorInitializerSyntax node);
    public virtual void VisitDestructorDeclaration(DestructorDeclarationSyntax node);
    public virtual void VisitPropertyDeclaration(PropertyDeclarationSyntax node);
    public virtual void VisitArrowExpressionClause(ArrowExpressionClauseSyntax node);
    public virtual void VisitEventDeclaration(EventDeclarationSyntax node);
    public virtual void VisitIndexerDeclaration(IndexerDeclarationSyntax node);
    public virtual void VisitAccessorList(AccessorListSyntax node);
    public virtual void VisitAccessorDeclaration(AccessorDeclarationSyntax node);
    public virtual void VisitParameterList(ParameterListSyntax node);
    public virtual void VisitBracketedParameterList(BracketedParameterListSyntax node);
    public virtual void VisitParameter(ParameterSyntax node);
    public virtual void VisitIncompleteMember(IncompleteMemberSyntax node);
    public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node);
    public virtual void VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node);
    public virtual void VisitTypeCref(TypeCrefSyntax node);
    public virtual void VisitQualifiedCref(QualifiedCrefSyntax node);
    public virtual void VisitNameMemberCref(NameMemberCrefSyntax node);
    public virtual void VisitIndexerMemberCref(IndexerMemberCrefSyntax node);
    public virtual void VisitOperatorMemberCref(OperatorMemberCrefSyntax node);
    public virtual void VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node);
    public virtual void VisitCrefParameterList(CrefParameterListSyntax node);
    public virtual void VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node);
    public virtual void VisitCrefParameter(CrefParameterSyntax node);
    public virtual void VisitXmlElement(XmlElementSyntax node);
    public virtual void VisitXmlElementStartTag(XmlElementStartTagSyntax node);
    public virtual void VisitXmlElementEndTag(XmlElementEndTagSyntax node);
    public virtual void VisitXmlEmptyElement(XmlEmptyElementSyntax node);
    public virtual void VisitXmlName(XmlNameSyntax node);
    public virtual void VisitXmlPrefix(XmlPrefixSyntax node);
    public virtual void VisitXmlTextAttribute(XmlTextAttributeSyntax node);
    public virtual void VisitXmlCrefAttribute(XmlCrefAttributeSyntax node);
    public virtual void VisitXmlNameAttribute(XmlNameAttributeSyntax node);
    public virtual void VisitXmlText(XmlTextSyntax node);
    public virtual void VisitXmlCDataSection(XmlCDataSectionSyntax node);
    public virtual void VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node);
    public virtual void VisitXmlComment(XmlCommentSyntax node);
    public virtual void VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node);
    public virtual void VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node);
    public virtual void VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node);
    public virtual void VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node);
    public virtual void VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node);
    public virtual void VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node);
    public virtual void VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node);
    public virtual void VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node);
    public virtual void VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node);
    public virtual void VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node);
    public virtual void VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node);
    public virtual void VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node);
    public virtual void VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node);
    public virtual void VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node);
    public virtual void VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node);
    public virtual void VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node);
    public virtual void VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxVisitor`1 : object {
    public virtual TResult Visit(CSharpSyntaxNode node);
    public virtual TResult VisitToken(SyntaxToken token);
    public virtual TResult VisitTrivia(SyntaxTrivia trivia);
    protected virtual TResult DefaultVisit(CSharpSyntaxNode node);
    public virtual TResult VisitIdentifierName(IdentifierNameSyntax node);
    public virtual TResult VisitQualifiedName(QualifiedNameSyntax node);
    public virtual TResult VisitGenericName(GenericNameSyntax node);
    public virtual TResult VisitTypeArgumentList(TypeArgumentListSyntax node);
    public virtual TResult VisitAliasQualifiedName(AliasQualifiedNameSyntax node);
    public virtual TResult VisitPredefinedType(PredefinedTypeSyntax node);
    public virtual TResult VisitArrayType(ArrayTypeSyntax node);
    public virtual TResult VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node);
    public virtual TResult VisitPointerType(PointerTypeSyntax node);
    public virtual TResult VisitNullableType(NullableTypeSyntax node);
    public virtual TResult VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node);
    public virtual TResult VisitParenthesizedExpression(ParenthesizedExpressionSyntax node);
    public virtual TResult VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node);
    public virtual TResult VisitAwaitExpression(AwaitExpressionSyntax node);
    public virtual TResult VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node);
    public virtual TResult VisitMemberAccessExpression(MemberAccessExpressionSyntax node);
    public virtual TResult VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node);
    public virtual TResult VisitMemberBindingExpression(MemberBindingExpressionSyntax node);
    public virtual TResult VisitElementBindingExpression(ElementBindingExpressionSyntax node);
    public virtual TResult VisitImplicitElementAccess(ImplicitElementAccessSyntax node);
    public virtual TResult VisitBinaryExpression(BinaryExpressionSyntax node);
    public virtual TResult VisitAssignmentExpression(AssignmentExpressionSyntax node);
    public virtual TResult VisitConditionalExpression(ConditionalExpressionSyntax node);
    public virtual TResult VisitThisExpression(ThisExpressionSyntax node);
    public virtual TResult VisitBaseExpression(BaseExpressionSyntax node);
    public virtual TResult VisitLiteralExpression(LiteralExpressionSyntax node);
    public virtual TResult VisitMakeRefExpression(MakeRefExpressionSyntax node);
    public virtual TResult VisitRefTypeExpression(RefTypeExpressionSyntax node);
    public virtual TResult VisitRefValueExpression(RefValueExpressionSyntax node);
    public virtual TResult VisitCheckedExpression(CheckedExpressionSyntax node);
    public virtual TResult VisitDefaultExpression(DefaultExpressionSyntax node);
    public virtual TResult VisitTypeOfExpression(TypeOfExpressionSyntax node);
    public virtual TResult VisitSizeOfExpression(SizeOfExpressionSyntax node);
    public virtual TResult VisitInvocationExpression(InvocationExpressionSyntax node);
    public virtual TResult VisitElementAccessExpression(ElementAccessExpressionSyntax node);
    public virtual TResult VisitArgumentList(ArgumentListSyntax node);
    public virtual TResult VisitBracketedArgumentList(BracketedArgumentListSyntax node);
    public virtual TResult VisitArgument(ArgumentSyntax node);
    public virtual TResult VisitNameColon(NameColonSyntax node);
    public virtual TResult VisitCastExpression(CastExpressionSyntax node);
    public virtual TResult VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node);
    public virtual TResult VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node);
    public virtual TResult VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node);
    public virtual TResult VisitInitializerExpression(InitializerExpressionSyntax node);
    public virtual TResult VisitObjectCreationExpression(ObjectCreationExpressionSyntax node);
    public virtual TResult VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node);
    public virtual TResult VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node);
    public virtual TResult VisitArrayCreationExpression(ArrayCreationExpressionSyntax node);
    public virtual TResult VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node);
    public virtual TResult VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node);
    public virtual TResult VisitQueryExpression(QueryExpressionSyntax node);
    public virtual TResult VisitQueryBody(QueryBodySyntax node);
    public virtual TResult VisitFromClause(FromClauseSyntax node);
    public virtual TResult VisitLetClause(LetClauseSyntax node);
    public virtual TResult VisitJoinClause(JoinClauseSyntax node);
    public virtual TResult VisitJoinIntoClause(JoinIntoClauseSyntax node);
    public virtual TResult VisitWhereClause(WhereClauseSyntax node);
    public virtual TResult VisitOrderByClause(OrderByClauseSyntax node);
    public virtual TResult VisitOrdering(OrderingSyntax node);
    public virtual TResult VisitSelectClause(SelectClauseSyntax node);
    public virtual TResult VisitGroupClause(GroupClauseSyntax node);
    public virtual TResult VisitQueryContinuation(QueryContinuationSyntax node);
    public virtual TResult VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node);
    public virtual TResult VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node);
    public virtual TResult VisitInterpolatedStringText(InterpolatedStringTextSyntax node);
    public virtual TResult VisitInterpolation(InterpolationSyntax node);
    public virtual TResult VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node);
    public virtual TResult VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node);
    public virtual TResult VisitGlobalStatement(GlobalStatementSyntax node);
    public virtual TResult VisitBlock(BlockSyntax node);
    public virtual TResult VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node);
    public virtual TResult VisitVariableDeclaration(VariableDeclarationSyntax node);
    public virtual TResult VisitVariableDeclarator(VariableDeclaratorSyntax node);
    public virtual TResult VisitEqualsValueClause(EqualsValueClauseSyntax node);
    public virtual TResult VisitExpressionStatement(ExpressionStatementSyntax node);
    public virtual TResult VisitEmptyStatement(EmptyStatementSyntax node);
    public virtual TResult VisitLabeledStatement(LabeledStatementSyntax node);
    public virtual TResult VisitGotoStatement(GotoStatementSyntax node);
    public virtual TResult VisitBreakStatement(BreakStatementSyntax node);
    public virtual TResult VisitContinueStatement(ContinueStatementSyntax node);
    public virtual TResult VisitReturnStatement(ReturnStatementSyntax node);
    public virtual TResult VisitThrowStatement(ThrowStatementSyntax node);
    public virtual TResult VisitYieldStatement(YieldStatementSyntax node);
    public virtual TResult VisitWhileStatement(WhileStatementSyntax node);
    public virtual TResult VisitDoStatement(DoStatementSyntax node);
    public virtual TResult VisitForStatement(ForStatementSyntax node);
    public virtual TResult VisitForEachStatement(ForEachStatementSyntax node);
    public virtual TResult VisitUsingStatement(UsingStatementSyntax node);
    public virtual TResult VisitFixedStatement(FixedStatementSyntax node);
    public virtual TResult VisitCheckedStatement(CheckedStatementSyntax node);
    public virtual TResult VisitUnsafeStatement(UnsafeStatementSyntax node);
    public virtual TResult VisitLockStatement(LockStatementSyntax node);
    public virtual TResult VisitIfStatement(IfStatementSyntax node);
    public virtual TResult VisitElseClause(ElseClauseSyntax node);
    public virtual TResult VisitSwitchStatement(SwitchStatementSyntax node);
    public virtual TResult VisitSwitchSection(SwitchSectionSyntax node);
    public virtual TResult VisitCaseSwitchLabel(CaseSwitchLabelSyntax node);
    public virtual TResult VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node);
    public virtual TResult VisitTryStatement(TryStatementSyntax node);
    public virtual TResult VisitCatchClause(CatchClauseSyntax node);
    public virtual TResult VisitCatchDeclaration(CatchDeclarationSyntax node);
    public virtual TResult VisitCatchFilterClause(CatchFilterClauseSyntax node);
    public virtual TResult VisitFinallyClause(FinallyClauseSyntax node);
    public virtual TResult VisitCompilationUnit(CompilationUnitSyntax node);
    public virtual TResult VisitExternAliasDirective(ExternAliasDirectiveSyntax node);
    public virtual TResult VisitUsingDirective(UsingDirectiveSyntax node);
    public virtual TResult VisitNamespaceDeclaration(NamespaceDeclarationSyntax node);
    public virtual TResult VisitAttributeList(AttributeListSyntax node);
    public virtual TResult VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node);
    public virtual TResult VisitAttribute(AttributeSyntax node);
    public virtual TResult VisitAttributeArgumentList(AttributeArgumentListSyntax node);
    public virtual TResult VisitAttributeArgument(AttributeArgumentSyntax node);
    public virtual TResult VisitNameEquals(NameEqualsSyntax node);
    public virtual TResult VisitTypeParameterList(TypeParameterListSyntax node);
    public virtual TResult VisitTypeParameter(TypeParameterSyntax node);
    public virtual TResult VisitClassDeclaration(ClassDeclarationSyntax node);
    public virtual TResult VisitStructDeclaration(StructDeclarationSyntax node);
    public virtual TResult VisitInterfaceDeclaration(InterfaceDeclarationSyntax node);
    public virtual TResult VisitEnumDeclaration(EnumDeclarationSyntax node);
    public virtual TResult VisitDelegateDeclaration(DelegateDeclarationSyntax node);
    public virtual TResult VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node);
    public virtual TResult VisitBaseList(BaseListSyntax node);
    public virtual TResult VisitSimpleBaseType(SimpleBaseTypeSyntax node);
    public virtual TResult VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node);
    public virtual TResult VisitConstructorConstraint(ConstructorConstraintSyntax node);
    public virtual TResult VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node);
    public virtual TResult VisitTypeConstraint(TypeConstraintSyntax node);
    public virtual TResult VisitFieldDeclaration(FieldDeclarationSyntax node);
    public virtual TResult VisitEventFieldDeclaration(EventFieldDeclarationSyntax node);
    public virtual TResult VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node);
    public virtual TResult VisitMethodDeclaration(MethodDeclarationSyntax node);
    public virtual TResult VisitOperatorDeclaration(OperatorDeclarationSyntax node);
    public virtual TResult VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node);
    public virtual TResult VisitConstructorDeclaration(ConstructorDeclarationSyntax node);
    public virtual TResult VisitConstructorInitializer(ConstructorInitializerSyntax node);
    public virtual TResult VisitDestructorDeclaration(DestructorDeclarationSyntax node);
    public virtual TResult VisitPropertyDeclaration(PropertyDeclarationSyntax node);
    public virtual TResult VisitArrowExpressionClause(ArrowExpressionClauseSyntax node);
    public virtual TResult VisitEventDeclaration(EventDeclarationSyntax node);
    public virtual TResult VisitIndexerDeclaration(IndexerDeclarationSyntax node);
    public virtual TResult VisitAccessorList(AccessorListSyntax node);
    public virtual TResult VisitAccessorDeclaration(AccessorDeclarationSyntax node);
    public virtual TResult VisitParameterList(ParameterListSyntax node);
    public virtual TResult VisitBracketedParameterList(BracketedParameterListSyntax node);
    public virtual TResult VisitParameter(ParameterSyntax node);
    public virtual TResult VisitIncompleteMember(IncompleteMemberSyntax node);
    public virtual TResult VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node);
    public virtual TResult VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node);
    public virtual TResult VisitTypeCref(TypeCrefSyntax node);
    public virtual TResult VisitQualifiedCref(QualifiedCrefSyntax node);
    public virtual TResult VisitNameMemberCref(NameMemberCrefSyntax node);
    public virtual TResult VisitIndexerMemberCref(IndexerMemberCrefSyntax node);
    public virtual TResult VisitOperatorMemberCref(OperatorMemberCrefSyntax node);
    public virtual TResult VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node);
    public virtual TResult VisitCrefParameterList(CrefParameterListSyntax node);
    public virtual TResult VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node);
    public virtual TResult VisitCrefParameter(CrefParameterSyntax node);
    public virtual TResult VisitXmlElement(XmlElementSyntax node);
    public virtual TResult VisitXmlElementStartTag(XmlElementStartTagSyntax node);
    public virtual TResult VisitXmlElementEndTag(XmlElementEndTagSyntax node);
    public virtual TResult VisitXmlEmptyElement(XmlEmptyElementSyntax node);
    public virtual TResult VisitXmlName(XmlNameSyntax node);
    public virtual TResult VisitXmlPrefix(XmlPrefixSyntax node);
    public virtual TResult VisitXmlTextAttribute(XmlTextAttributeSyntax node);
    public virtual TResult VisitXmlCrefAttribute(XmlCrefAttributeSyntax node);
    public virtual TResult VisitXmlNameAttribute(XmlNameAttributeSyntax node);
    public virtual TResult VisitXmlText(XmlTextSyntax node);
    public virtual TResult VisitXmlCDataSection(XmlCDataSectionSyntax node);
    public virtual TResult VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node);
    public virtual TResult VisitXmlComment(XmlCommentSyntax node);
    public virtual TResult VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node);
    public virtual TResult VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node);
    public virtual TResult VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node);
    public virtual TResult VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node);
    public virtual TResult VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node);
    public virtual TResult VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node);
    public virtual TResult VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node);
    public virtual TResult VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node);
    public virtual TResult VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node);
    public virtual TResult VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node);
    public virtual TResult VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node);
    public virtual TResult VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node);
    public virtual TResult VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node);
    public virtual TResult VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node);
    public virtual TResult VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node);
    public virtual TResult VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node);
    public virtual TResult VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken keyword;
    internal SyntaxToken openParenToken;
    internal TypeSyntax type;
    internal SyntaxToken closeParenToken;
    public SyntaxToken Keyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken CloseParenToken { get; }
    internal DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context);
    internal DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    internal DefaultExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_Keyword();
    public SyntaxToken get_OpenParenToken();
    public TypeSyntax get_Type();
    public SyntaxToken get_CloseParenToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public DefaultExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultSwitchLabelSyntax : SwitchLabelSyntax {
    internal SyntaxToken keyword;
    internal SyntaxToken colonToken;
    public SyntaxToken Keyword { get; }
    public SyntaxToken ColonToken { get; }
    internal DefaultSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal DefaultSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken colonToken, SyntaxFactoryContext context);
    internal DefaultSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken colonToken);
    internal DefaultSwitchLabelSyntax(ObjectReader reader);
    public virtual SyntaxToken get_Keyword();
    public virtual SyntaxToken get_ColonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public DefaultSwitchLabelSyntax Update(SyntaxToken keyword, SyntaxToken colonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefineDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal SyntaxToken hashToken;
    internal SyntaxToken defineKeyword;
    internal SyntaxToken name;
    internal SyntaxToken endOfDirectiveToken;
    internal bool isActive;
    public SyntaxToken HashToken { get; }
    public SyntaxToken DefineKeyword { get; }
    public SyntaxToken Name { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal DefineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal DefineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context);
    internal DefineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive);
    internal DefineDirectiveTriviaSyntax(ObjectReader reader);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_DefineKeyword();
    public SyntaxToken get_Name();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public DefineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal enum Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefineState : Enum {
    public int value__;
    public static DefineState Defined;
    public static DefineState Undefined;
    public static DefineState Unspecified;
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax : MemberDeclarationSyntax {
    internal CSharpSyntaxNode attributeLists;
    internal CSharpSyntaxNode modifiers;
    internal SyntaxToken delegateKeyword;
    internal TypeSyntax returnType;
    internal SyntaxToken identifier;
    internal TypeParameterListSyntax typeParameterList;
    internal ParameterListSyntax parameterList;
    internal CSharpSyntaxNode constraintClauses;
    internal SyntaxToken semicolonToken;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public SyntaxToken DelegateKeyword { get; }
    public TypeSyntax ReturnType { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public ParameterListSyntax ParameterList { get; }
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public SyntaxToken SemicolonToken { get; }
    internal DelegateDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, CSharpSyntaxNode constraintClauses, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal DelegateDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, CSharpSyntaxNode constraintClauses, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal DelegateDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, CSharpSyntaxNode constraintClauses, SyntaxToken semicolonToken);
    internal DelegateDeclarationSyntax(ObjectReader reader);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxList`1<SyntaxToken> get_Modifiers();
    public SyntaxToken get_DelegateKeyword();
    public TypeSyntax get_ReturnType();
    public SyntaxToken get_Identifier();
    public TypeParameterListSyntax get_TypeParameterList();
    public ParameterListSyntax get_ParameterList();
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public DelegateDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DestructorDeclarationSyntax : BaseMethodDeclarationSyntax {
    internal CSharpSyntaxNode attributeLists;
    internal CSharpSyntaxNode modifiers;
    internal SyntaxToken tildeToken;
    internal SyntaxToken identifier;
    internal ParameterListSyntax parameterList;
    internal BlockSyntax body;
    internal SyntaxToken semicolonToken;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public SyntaxToken TildeToken { get; }
    public SyntaxToken Identifier { get; }
    public ParameterListSyntax ParameterList { get; }
    public BlockSyntax Body { get; }
    public SyntaxToken SemicolonToken { get; }
    internal DestructorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal DestructorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal DestructorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken);
    internal DestructorDeclarationSyntax(ObjectReader reader);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxList`1<SyntaxToken> get_Modifiers();
    public SyntaxToken get_TildeToken();
    public SyntaxToken get_Identifier();
    public virtual ParameterListSyntax get_ParameterList();
    public virtual BlockSyntax get_Body();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public DestructorDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Directive : ValueType {
    private DirectiveTriviaSyntax _node;
    public SyntaxKind Kind { get; }
    internal bool IsActive { get; }
    internal bool BranchTaken { get; }
    internal Directive(DirectiveTriviaSyntax node);
    public SyntaxKind get_Kind();
    public bool IncrementallyEquivalent(Directive other);
    internal string GetDebuggerDisplay();
    internal string GetIdentifier();
    internal bool get_IsActive();
    internal bool get_BranchTaken();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DirectiveParser : SyntaxParser {
    private static int MAX_DIRECTIVE_IDENTIFIER_WIDTH;
    private DirectiveStack _context;
    internal DirectiveParser(Lexer lexer, DirectiveStack context);
    public CSharpSyntaxNode ParseDirective(bool isActive, bool endIsActive, bool isAfterFirstTokenInFile, bool isAfterNonWhitespaceOnLine);
    private DirectiveTriviaSyntax ParseIfDirective(SyntaxToken hash, SyntaxToken keyword, bool isActive);
    private DirectiveTriviaSyntax ParseElifDirective(SyntaxToken hash, SyntaxToken keyword, bool isActive, bool endIsActive);
    private DirectiveTriviaSyntax ParseElseDirective(SyntaxToken hash, SyntaxToken keyword, bool isActive, bool endIsActive);
    private DirectiveTriviaSyntax ParseEndIfDirective(SyntaxToken hash, SyntaxToken keyword, bool isActive, bool endIsActive);
    private DirectiveTriviaSyntax ParseRegionDirective(SyntaxToken hash, SyntaxToken keyword, bool isActive);
    private DirectiveTriviaSyntax ParseEndRegionDirective(SyntaxToken hash, SyntaxToken keyword, bool isActive);
    private DirectiveTriviaSyntax ParseDefineOrUndefDirective(SyntaxToken hash, SyntaxToken keyword, bool isActive, bool isFollowingToken);
    private DirectiveTriviaSyntax ParseErrorOrWarningDirective(SyntaxToken hash, SyntaxToken keyword, bool isActive);
    private DirectiveTriviaSyntax ParseLineDirective(SyntaxToken hash, SyntaxToken id, bool isActive);
    private DirectiveTriviaSyntax ParseReferenceDirective(SyntaxToken hash, SyntaxToken keyword, bool isActive, bool isFollowingToken);
    private DirectiveTriviaSyntax ParseLoadDirective(SyntaxToken hash, SyntaxToken keyword, bool isActive, bool isFollowingToken);
    private DirectiveTriviaSyntax ParsePragmaDirective(SyntaxToken hash, SyntaxToken pragma, bool isActive);
    private DirectiveTriviaSyntax ParseShebangDirective(SyntaxToken hash, SyntaxToken exclamation, bool isActive);
    private SyntaxToken ParseEndOfDirectiveWithOptionalPreprocessingMessage();
    private SyntaxToken ParseEndOfDirective(bool ignoreErrors, bool afterPragma, bool afterLineNumber);
    private ExpressionSyntax ParseExpression();
    private ExpressionSyntax ParseLogicalOr();
    private ExpressionSyntax ParseLogicalAnd();
    private ExpressionSyntax ParseEquality();
    private ExpressionSyntax ParseLogicalNot();
    private ExpressionSyntax ParsePrimary();
    private static SyntaxToken TruncateIdentifier(SyntaxToken identifier);
    private bool EvaluateBool(ExpressionSyntax expr);
    private object Evaluate(ExpressionSyntax expr);
    private bool IsDefined(string id);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DirectiveStack : ValueType {
    public static DirectiveStack Empty;
    public static DirectiveStack Null;
    private ConsList`1<Directive> _directives;
    public bool IsNull { get; }
    public bool IsEmpty { get; }
    private DirectiveStack(ConsList`1<Directive> directives);
    private static DirectiveStack();
    public bool get_IsNull();
    public bool get_IsEmpty();
    public DefineState IsDefined(string id);
    public bool PreviousBranchTaken();
    public bool HasUnfinishedIf();
    public bool HasPreviousIfOrElif();
    public bool HasUnfinishedRegion();
    public DirectiveStack Add(Directive directive);
    private static ConsList`1<Directive> CompleteIf(ConsList`1<Directive> stack, Boolean& include);
    private static ConsList`1<Directive> CompleteRegion(ConsList`1<Directive> stack);
    private static ConsList`1<Directive> GetPreviousIf(ConsList`1<Directive> directives);
    private static ConsList`1<Directive> GetPreviousIfElifElseOrRegion(ConsList`1<Directive> directives);
    private static ConsList`1<Directive> GetPreviousRegion(ConsList`1<Directive> directives);
    private string GetDebuggerDisplay();
    public bool IncrementallyEquivalent(DirectiveStack other);
    private static ConsList`1<Directive> SkipInsignificantDirectives(ConsList`1<Directive> directives);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DirectiveTriviaSyntax : StructuredTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal DirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal DirectiveTriviaSyntax(SyntaxKind kind);
    protected DirectiveTriviaSyntax(ObjectReader reader);
    internal virtual DirectiveStack ApplyDirectives(DirectiveStack stack);
    public abstract virtual SyntaxToken get_HashToken();
    public abstract virtual SyntaxToken get_EndOfDirectiveToken();
    public abstract virtual bool get_IsActive();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser : SyntaxParser {
    private SyntaxListPool _pool;
    private bool _isDelimited;
    private HashSet`1<string> _attributesSeen;
    private bool IsPossibleCrefParameter { get; }
    private bool IsEndOfCrefAttribute { get; }
    private bool InCref { get; }
    private bool IsEndOfNameAttribute { get; }
    internal DocumentationCommentParser(Lexer lexer, LexerMode modeflags);
    internal void ReInitialize(LexerMode modeflags);
    private LexerMode SetMode(LexerMode mode);
    private void ResetMode(LexerMode mode);
    public DocumentationCommentTriviaSyntax ParseDocumentationComment(Boolean& isTerminated);
    public void ParseRemainder(SyntaxListBuilder`1<XmlNodeSyntax> nodes);
    private void ParseXmlNodes(SyntaxListBuilder`1<XmlNodeSyntax> nodes);
    private XmlNodeSyntax ParseXmlNode();
    private bool IsXmlNodeStartOrStop();
    private XmlNodeSyntax ParseXmlText();
    private XmlNodeSyntax ParseXmlElement();
    private static bool MatchingXmlNames(XmlNameSyntax name, XmlNameSyntax endName);
    private void ParseXmlAttributes(XmlNameSyntax& elementName, SyntaxListBuilder`1<XmlAttributeSyntax> attrs);
    private SkipResult SkipBadTokens(T& startNode, SyntaxListBuilder list, Func`2<DocumentationCommentParser, bool> isNotExpectedFunction, Func`2<DocumentationCommentParser, bool> abortFunction, XmlParseErrorCode error);
    private XmlAttributeSyntax ParseXmlAttribute(XmlNameSyntax elementName);
    private static bool XmlElementSupportsNameAttribute(XmlNameSyntax elementName);
    private bool IsVerbatimCref();
    private void ParseCrefAttribute(SyntaxToken& startQuote, CrefSyntax& cref, SyntaxToken& endQuote);
    private void ParseNameAttribute(SyntaxToken& startQuote, IdentifierNameSyntax& identifier, SyntaxToken& endQuote);
    private void ParseXmlAttributeText(SyntaxToken& startQuote, SyntaxListBuilder`1<SyntaxToken> textTokens, SyntaxToken& endQuote);
    private SyntaxToken ParseXmlAttributeStartQuote();
    private SyntaxToken ParseXmlAttributeEndQuote(SyntaxKind quoteKind);
    private SyntaxToken SkipNonAsciiQuotationMark();
    private static bool IsNonAsciiQuotationMark(SyntaxToken token);
    private XmlNameSyntax ParseXmlName();
    private XmlCommentSyntax ParseXmlComment();
    private XmlCDataSectionSyntax ParseXmlCDataSection();
    private XmlProcessingInstructionSyntax ParseXmlProcessingInstruction();
    protected virtual SyntaxDiagnosticInfo GetExpectedTokenError(SyntaxKind expected, SyntaxKind actual, int offset, int length);
    protected virtual SyntaxDiagnosticInfo GetExpectedTokenError(SyntaxKind expected, SyntaxKind actual);
    private TNode WithXmlParseError(TNode node, XmlParseErrorCode code);
    private TNode WithXmlParseError(TNode node, XmlParseErrorCode code, String[] args);
    private SyntaxToken WithXmlParseError(SyntaxToken node, XmlParseErrorCode code);
    private SyntaxToken WithXmlParseError(SyntaxToken node, XmlParseErrorCode code, String[] args);
    protected virtual TNode WithAdditionalDiagnostics(TNode node, DiagnosticInfo[] diagnostics);
    private CrefSyntax ParseCrefAttributeValue();
    private CSharpSyntaxNode ConsumeBadTokens();
    private MemberCrefSyntax ParseMemberCref();
    private NameMemberCrefSyntax ParseNameMemberCref();
    private IndexerMemberCrefSyntax ParseIndexerMemberCref();
    private OperatorMemberCrefSyntax ParseOperatorMemberCref();
    private ConversionOperatorMemberCrefSyntax ParseConversionOperatorMemberCref();
    private CrefParameterListSyntax ParseCrefParameterList();
    private CrefBracketedParameterListSyntax ParseBracketedCrefParameterList();
    private BaseCrefParameterListSyntax ParseBaseCrefParameterList(bool useSquareBrackets);
    private bool get_IsPossibleCrefParameter();
    private CrefParameterSyntax ParseCrefParameter();
    private SimpleNameSyntax ParseCrefName(bool typeArgumentsMustBeIdentifiers);
    private TypeSyntax ParseCrefType(bool typeArgumentsMustBeIdentifiers, bool checkForMember);
    private TypeSyntax ParseCrefTypeHelper(bool typeArgumentsMustBeIdentifiers, bool checkForMember);
    private TypeSyntax ParseCrefTypeSuffix(TypeSyntax type);
    private bool get_IsEndOfCrefAttribute();
    private bool get_InCref();
    private IdentifierNameSyntax ParseNameAttributeValue();
    private bool get_IsEndOfNameAttribute();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentTriviaSyntax : StructuredTriviaSyntax {
    internal CSharpSyntaxNode content;
    internal SyntaxToken endOfComment;
    public SyntaxList`1<XmlNodeSyntax> Content { get; }
    public SyntaxToken EndOfComment { get; }
    internal DocumentationCommentTriviaSyntax(SyntaxKind kind, CSharpSyntaxNode content, SyntaxToken endOfComment, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal DocumentationCommentTriviaSyntax(SyntaxKind kind, CSharpSyntaxNode content, SyntaxToken endOfComment, SyntaxFactoryContext context);
    internal DocumentationCommentTriviaSyntax(SyntaxKind kind, CSharpSyntaxNode content, SyntaxToken endOfComment);
    internal DocumentationCommentTriviaSyntax(ObjectReader reader);
    public SyntaxList`1<XmlNodeSyntax> get_Content();
    public SyntaxToken get_EndOfComment();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public DocumentationCommentTriviaSyntax Update(SyntaxList`1<XmlNodeSyntax> content, SyntaxToken endOfComment);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal static class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentXmlTokens : object {
    private static SyntaxToken s_seeToken;
    private static SyntaxToken s_codeToken;
    private static SyntaxToken s_listToken;
    private static SyntaxToken s_paramToken;
    private static SyntaxToken s_valueToken;
    private static SyntaxToken s_exampleToken;
    private static SyntaxToken s_includeToken;
    private static SyntaxToken s_remarksToken;
    private static SyntaxToken s_seealsoToken;
    private static SyntaxToken s_summaryToken;
    private static SyntaxToken s_exceptionToken;
    private static SyntaxToken s_typeparamToken;
    private static SyntaxToken s_permissionToken;
    private static SyntaxToken s_typeparamrefToken;
    private static SyntaxToken s_crefToken;
    private static SyntaxToken s_fileToken;
    private static SyntaxToken s_nameToken;
    private static SyntaxToken s_pathToken;
    private static SyntaxToken s_typeToken;
    private static DocumentationCommentXmlTokens();
    private static SyntaxToken Identifier(string text);
    private static SyntaxToken IdentifierWithLeadingSpace(string text);
    private static bool IsSingleSpaceTrivia(SyntaxListBuilder syntax);
    public static SyntaxToken LookupToken(string text, SyntaxListBuilder leading);
    private static SyntaxToken LookupXmlElementTag(string text);
    private static SyntaxToken LookupXmlAttribute(string text);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DoStatementSyntax : StatementSyntax {
    internal SyntaxToken doKeyword;
    internal StatementSyntax statement;
    internal SyntaxToken whileKeyword;
    internal SyntaxToken openParenToken;
    internal ExpressionSyntax condition;
    internal SyntaxToken closeParenToken;
    internal SyntaxToken semicolonToken;
    public SyntaxToken DoKeyword { get; }
    public StatementSyntax Statement { get; }
    public SyntaxToken WhileKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Condition { get; }
    public SyntaxToken CloseParenToken { get; }
    public SyntaxToken SemicolonToken { get; }
    internal DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken);
    internal DoStatementSyntax(ObjectReader reader);
    public SyntaxToken get_DoKeyword();
    public StatementSyntax get_Statement();
    public SyntaxToken get_WhileKeyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Condition();
    public SyntaxToken get_CloseParenToken();
    public SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public DoStatementSyntax Update(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElementAccessExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax expression;
    internal BracketedArgumentListSyntax argumentList;
    public ExpressionSyntax Expression { get; }
    public BracketedArgumentListSyntax ArgumentList { get; }
    internal ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList, SyntaxFactoryContext context);
    internal ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList);
    internal ElementAccessExpressionSyntax(ObjectReader reader);
    public ExpressionSyntax get_Expression();
    public BracketedArgumentListSyntax get_ArgumentList();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ElementAccessExpressionSyntax Update(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElementBindingExpressionSyntax : ExpressionSyntax {
    internal BracketedArgumentListSyntax argumentList;
    public BracketedArgumentListSyntax ArgumentList { get; }
    internal ElementBindingExpressionSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ElementBindingExpressionSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, SyntaxFactoryContext context);
    internal ElementBindingExpressionSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList);
    internal ElementBindingExpressionSyntax(ObjectReader reader);
    public BracketedArgumentListSyntax get_ArgumentList();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ElementBindingExpressionSyntax Update(BracketedArgumentListSyntax argumentList);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElifDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax {
    internal SyntaxToken hashToken;
    internal SyntaxToken elifKeyword;
    internal ExpressionSyntax condition;
    internal SyntaxToken endOfDirectiveToken;
    internal bool isActive;
    internal bool branchTaken;
    internal bool conditionValue;
    public SyntaxToken HashToken { get; }
    public SyntaxToken ElifKeyword { get; }
    public ExpressionSyntax Condition { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    public bool BranchTaken { get; }
    public bool ConditionValue { get; }
    internal ElifDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ElifDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, SyntaxFactoryContext context);
    internal ElifDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue);
    internal ElifDirectiveTriviaSyntax(ObjectReader reader);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_ElifKeyword();
    public virtual ExpressionSyntax get_Condition();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    public virtual bool get_BranchTaken();
    public virtual bool get_ConditionValue();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ElifDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElseClauseSyntax : CSharpSyntaxNode {
    internal SyntaxToken elseKeyword;
    internal StatementSyntax statement;
    public SyntaxToken ElseKeyword { get; }
    public StatementSyntax Statement { get; }
    internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement, SyntaxFactoryContext context);
    internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement);
    internal ElseClauseSyntax(ObjectReader reader);
    public SyntaxToken get_ElseKeyword();
    public StatementSyntax get_Statement();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ElseClauseSyntax Update(SyntaxToken elseKeyword, StatementSyntax statement);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElseDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax {
    internal SyntaxToken hashToken;
    internal SyntaxToken elseKeyword;
    internal SyntaxToken endOfDirectiveToken;
    internal bool isActive;
    internal bool branchTaken;
    public SyntaxToken HashToken { get; }
    public SyntaxToken ElseKeyword { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    public bool BranchTaken { get; }
    internal ElseDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ElseDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, SyntaxFactoryContext context);
    internal ElseDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken);
    internal ElseDirectiveTriviaSyntax(ObjectReader reader);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_ElseKeyword();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    public virtual bool get_BranchTaken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ElseDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EmptyStatementSyntax : StatementSyntax {
    internal SyntaxToken semicolonToken;
    public SyntaxToken SemicolonToken { get; }
    internal EmptyStatementSyntax(SyntaxKind kind, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal EmptyStatementSyntax(SyntaxKind kind, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal EmptyStatementSyntax(SyntaxKind kind, SyntaxToken semicolonToken);
    internal EmptyStatementSyntax(ObjectReader reader);
    public SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public EmptyStatementSyntax Update(SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EndIfDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal SyntaxToken hashToken;
    internal SyntaxToken endIfKeyword;
    internal SyntaxToken endOfDirectiveToken;
    internal bool isActive;
    public SyntaxToken HashToken { get; }
    public SyntaxToken EndIfKeyword { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal EndIfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal EndIfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context);
    internal EndIfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    internal EndIfDirectiveTriviaSyntax(ObjectReader reader);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_EndIfKeyword();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public EndIfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EndRegionDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal SyntaxToken hashToken;
    internal SyntaxToken endRegionKeyword;
    internal SyntaxToken endOfDirectiveToken;
    internal bool isActive;
    public SyntaxToken HashToken { get; }
    public SyntaxToken EndRegionKeyword { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal EndRegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal EndRegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context);
    internal EndRegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    internal EndRegionDirectiveTriviaSyntax(ObjectReader reader);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_EndRegionKeyword();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public EndRegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumDeclarationSyntax : BaseTypeDeclarationSyntax {
    internal CSharpSyntaxNode attributeLists;
    internal CSharpSyntaxNode modifiers;
    internal SyntaxToken enumKeyword;
    internal SyntaxToken identifier;
    internal BaseListSyntax baseList;
    internal SyntaxToken openBraceToken;
    internal CSharpSyntaxNode members;
    internal SyntaxToken closeBraceToken;
    internal SyntaxToken semicolonToken;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public SyntaxToken EnumKeyword { get; }
    public SyntaxToken Identifier { get; }
    public BaseListSyntax BaseList { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SeparatedSyntaxList`1<EnumMemberDeclarationSyntax> Members { get; }
    public SyntaxToken CloseBraceToken { get; }
    public SyntaxToken SemicolonToken { get; }
    internal EnumDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal EnumDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal EnumDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    internal EnumDeclarationSyntax(ObjectReader reader);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxList`1<SyntaxToken> get_Modifiers();
    public SyntaxToken get_EnumKeyword();
    public virtual SyntaxToken get_Identifier();
    public virtual BaseListSyntax get_BaseList();
    public virtual SyntaxToken get_OpenBraceToken();
    public SeparatedSyntaxList`1<EnumMemberDeclarationSyntax> get_Members();
    public virtual SyntaxToken get_CloseBraceToken();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public EnumDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList`1<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumMemberDeclarationSyntax : MemberDeclarationSyntax {
    internal CSharpSyntaxNode attributeLists;
    internal SyntaxToken identifier;
    internal EqualsValueClauseSyntax equalsValue;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxToken Identifier { get; }
    public EqualsValueClauseSyntax EqualsValue { get; }
    internal EnumMemberDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal EnumMemberDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue, SyntaxFactoryContext context);
    internal EnumMemberDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue);
    internal EnumMemberDeclarationSyntax(ObjectReader reader);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxToken get_Identifier();
    public EqualsValueClauseSyntax get_EqualsValue();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public EnumMemberDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EqualsValueClauseSyntax : CSharpSyntaxNode {
    internal SyntaxToken equalsToken;
    internal ExpressionSyntax value;
    public SyntaxToken EqualsToken { get; }
    public ExpressionSyntax Value { get; }
    internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExpressionSyntax value, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExpressionSyntax value, SyntaxFactoryContext context);
    internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExpressionSyntax value);
    internal EqualsValueClauseSyntax(ObjectReader reader);
    public SyntaxToken get_EqualsToken();
    public ExpressionSyntax get_Value();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public EqualsValueClauseSyntax Update(SyntaxToken equalsToken, ExpressionSyntax value);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ErrorDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal SyntaxToken hashToken;
    internal SyntaxToken errorKeyword;
    internal SyntaxToken endOfDirectiveToken;
    internal bool isActive;
    public SyntaxToken HashToken { get; }
    public SyntaxToken ErrorKeyword { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal ErrorDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ErrorDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context);
    internal ErrorDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    internal ErrorDirectiveTriviaSyntax(ObjectReader reader);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_ErrorKeyword();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ErrorDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EventDeclarationSyntax : BasePropertyDeclarationSyntax {
    internal CSharpSyntaxNode attributeLists;
    internal CSharpSyntaxNode modifiers;
    internal SyntaxToken eventKeyword;
    internal TypeSyntax type;
    internal ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    internal SyntaxToken identifier;
    internal AccessorListSyntax accessorList;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public SyntaxToken EventKeyword { get; }
    public TypeSyntax Type { get; }
    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }
    public SyntaxToken Identifier { get; }
    public AccessorListSyntax AccessorList { get; }
    internal EventDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal EventDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, SyntaxFactoryContext context);
    internal EventDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList);
    internal EventDeclarationSyntax(ObjectReader reader);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxList`1<SyntaxToken> get_Modifiers();
    public SyntaxToken get_EventKeyword();
    public virtual TypeSyntax get_Type();
    public virtual ExplicitInterfaceSpecifierSyntax get_ExplicitInterfaceSpecifier();
    public SyntaxToken get_Identifier();
    public virtual AccessorListSyntax get_AccessorList();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public EventDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EventFieldDeclarationSyntax : BaseFieldDeclarationSyntax {
    internal CSharpSyntaxNode attributeLists;
    internal CSharpSyntaxNode modifiers;
    internal SyntaxToken eventKeyword;
    internal VariableDeclarationSyntax declaration;
    internal SyntaxToken semicolonToken;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public SyntaxToken EventKeyword { get; }
    public VariableDeclarationSyntax Declaration { get; }
    public SyntaxToken SemicolonToken { get; }
    internal EventFieldDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal EventFieldDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal EventFieldDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    internal EventFieldDeclarationSyntax(ObjectReader reader);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxList`1<SyntaxToken> get_Modifiers();
    public SyntaxToken get_EventKeyword();
    public virtual VariableDeclarationSyntax get_Declaration();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public EventFieldDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExplicitInterfaceSpecifierSyntax : CSharpSyntaxNode {
    internal NameSyntax name;
    internal SyntaxToken dotToken;
    public NameSyntax Name { get; }
    public SyntaxToken DotToken { get; }
    internal ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken, SyntaxFactoryContext context);
    internal ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken);
    internal ExplicitInterfaceSpecifierSyntax(ObjectReader reader);
    public NameSyntax get_Name();
    public SyntaxToken get_DotToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ExplicitInterfaceSpecifierSyntax Update(NameSyntax name, SyntaxToken dotToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionStatementSyntax : StatementSyntax {
    internal ExpressionSyntax expression;
    internal SyntaxToken semicolonToken;
    public ExpressionSyntax Expression { get; }
    public SyntaxToken SemicolonToken { get; }
    internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken semicolonToken);
    internal ExpressionStatementSyntax(ObjectReader reader);
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ExpressionStatementSyntax Update(ExpressionSyntax expression, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax : CSharpSyntaxNode {
    internal ExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ExpressionSyntax(SyntaxKind kind);
    protected ExpressionSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExternAliasDirectiveSyntax : CSharpSyntaxNode {
    internal SyntaxToken externKeyword;
    internal SyntaxToken aliasKeyword;
    internal SyntaxToken identifier;
    internal SyntaxToken semicolonToken;
    public SyntaxToken ExternKeyword { get; }
    public SyntaxToken AliasKeyword { get; }
    public SyntaxToken Identifier { get; }
    public SyntaxToken SemicolonToken { get; }
    internal ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken);
    internal ExternAliasDirectiveSyntax(ObjectReader reader);
    public SyntaxToken get_ExternKeyword();
    public SyntaxToken get_AliasKeyword();
    public SyntaxToken get_Identifier();
    public SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ExternAliasDirectiveSyntax Update(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FieldDeclarationSyntax : BaseFieldDeclarationSyntax {
    internal CSharpSyntaxNode attributeLists;
    internal CSharpSyntaxNode modifiers;
    internal VariableDeclarationSyntax declaration;
    internal SyntaxToken semicolonToken;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public VariableDeclarationSyntax Declaration { get; }
    public SyntaxToken SemicolonToken { get; }
    internal FieldDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal FieldDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal FieldDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    internal FieldDeclarationSyntax(ObjectReader reader);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxList`1<SyntaxToken> get_Modifiers();
    public virtual VariableDeclarationSyntax get_Declaration();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public FieldDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FinallyClauseSyntax : CSharpSyntaxNode {
    internal SyntaxToken finallyKeyword;
    internal BlockSyntax block;
    public SyntaxToken FinallyKeyword { get; }
    public BlockSyntax Block { get; }
    internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block, SyntaxFactoryContext context);
    internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block);
    internal FinallyClauseSyntax(ObjectReader reader);
    public SyntaxToken get_FinallyKeyword();
    public BlockSyntax get_Block();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public FinallyClauseSyntax Update(SyntaxToken finallyKeyword, BlockSyntax block);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FixedStatementSyntax : StatementSyntax {
    internal SyntaxToken fixedKeyword;
    internal SyntaxToken openParenToken;
    internal VariableDeclarationSyntax declaration;
    internal SyntaxToken closeParenToken;
    internal StatementSyntax statement;
    public SyntaxToken FixedKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public VariableDeclarationSyntax Declaration { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    internal FixedStatementSyntax(SyntaxKind kind, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal FixedStatementSyntax(SyntaxKind kind, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context);
    internal FixedStatementSyntax(SyntaxKind kind, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement);
    internal FixedStatementSyntax(ObjectReader reader);
    public SyntaxToken get_FixedKeyword();
    public SyntaxToken get_OpenParenToken();
    public VariableDeclarationSyntax get_Declaration();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public FixedStatementSyntax Update(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ForEachStatementSyntax : StatementSyntax {
    internal SyntaxToken forEachKeyword;
    internal SyntaxToken openParenToken;
    internal TypeSyntax type;
    internal SyntaxToken identifier;
    internal SyntaxToken inKeyword;
    internal ExpressionSyntax expression;
    internal SyntaxToken closeParenToken;
    internal StatementSyntax statement;
    public SyntaxToken ForEachKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken Identifier { get; }
    public SyntaxToken InKeyword { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    internal ForEachStatementSyntax(SyntaxKind kind, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ForEachStatementSyntax(SyntaxKind kind, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context);
    internal ForEachStatementSyntax(SyntaxKind kind, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    internal ForEachStatementSyntax(ObjectReader reader);
    public SyntaxToken get_ForEachKeyword();
    public SyntaxToken get_OpenParenToken();
    public TypeSyntax get_Type();
    public SyntaxToken get_Identifier();
    public SyntaxToken get_InKeyword();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ForEachStatementSyntax Update(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ForStatementSyntax : StatementSyntax {
    internal SyntaxToken forKeyword;
    internal SyntaxToken openParenToken;
    internal VariableDeclarationSyntax declaration;
    internal CSharpSyntaxNode initializers;
    internal SyntaxToken firstSemicolonToken;
    internal ExpressionSyntax condition;
    internal SyntaxToken secondSemicolonToken;
    internal CSharpSyntaxNode incrementors;
    internal SyntaxToken closeParenToken;
    internal StatementSyntax statement;
    public SyntaxToken ForKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public VariableDeclarationSyntax Declaration { get; }
    public SeparatedSyntaxList`1<ExpressionSyntax> Initializers { get; }
    public SyntaxToken FirstSemicolonToken { get; }
    public ExpressionSyntax Condition { get; }
    public SyntaxToken SecondSemicolonToken { get; }
    public SeparatedSyntaxList`1<ExpressionSyntax> Incrementors { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    internal ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, CSharpSyntaxNode initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, CSharpSyntaxNode incrementors, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, CSharpSyntaxNode initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, CSharpSyntaxNode incrementors, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context);
    internal ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, CSharpSyntaxNode initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, CSharpSyntaxNode incrementors, SyntaxToken closeParenToken, StatementSyntax statement);
    internal ForStatementSyntax(ObjectReader reader);
    public SyntaxToken get_ForKeyword();
    public SyntaxToken get_OpenParenToken();
    public VariableDeclarationSyntax get_Declaration();
    public SeparatedSyntaxList`1<ExpressionSyntax> get_Initializers();
    public SyntaxToken get_FirstSemicolonToken();
    public ExpressionSyntax get_Condition();
    public SyntaxToken get_SecondSemicolonToken();
    public SeparatedSyntaxList`1<ExpressionSyntax> get_Incrementors();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ForStatementSyntax Update(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList`1<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList`1<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FromClauseSyntax : QueryClauseSyntax {
    internal SyntaxToken fromKeyword;
    internal TypeSyntax type;
    internal SyntaxToken identifier;
    internal SyntaxToken inKeyword;
    internal ExpressionSyntax expression;
    public SyntaxToken FromKeyword { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken Identifier { get; }
    public SyntaxToken InKeyword { get; }
    public ExpressionSyntax Expression { get; }
    internal FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxFactoryContext context);
    internal FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression);
    internal FromClauseSyntax(ObjectReader reader);
    public SyntaxToken get_FromKeyword();
    public TypeSyntax get_Type();
    public SyntaxToken get_Identifier();
    public SyntaxToken get_InKeyword();
    public ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public FromClauseSyntax Update(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GenericNameSyntax : SimpleNameSyntax {
    internal SyntaxToken identifier;
    internal TypeArgumentListSyntax typeArgumentList;
    public SyntaxToken Identifier { get; }
    public TypeArgumentListSyntax TypeArgumentList { get; }
    internal GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList, SyntaxFactoryContext context);
    internal GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList);
    internal GenericNameSyntax(ObjectReader reader);
    public virtual SyntaxToken get_Identifier();
    public TypeArgumentListSyntax get_TypeArgumentList();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public GenericNameSyntax Update(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GlobalStatementSyntax : MemberDeclarationSyntax {
    internal StatementSyntax statement;
    public StatementSyntax Statement { get; }
    internal GlobalStatementSyntax(SyntaxKind kind, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal GlobalStatementSyntax(SyntaxKind kind, StatementSyntax statement, SyntaxFactoryContext context);
    internal GlobalStatementSyntax(SyntaxKind kind, StatementSyntax statement);
    internal GlobalStatementSyntax(ObjectReader reader);
    public StatementSyntax get_Statement();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public GlobalStatementSyntax Update(StatementSyntax statement);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GotoStatementSyntax : StatementSyntax {
    internal SyntaxToken gotoKeyword;
    internal SyntaxToken caseOrDefaultKeyword;
    internal ExpressionSyntax expression;
    internal SyntaxToken semicolonToken;
    public SyntaxToken GotoKeyword { get; }
    public SyntaxToken CaseOrDefaultKeyword { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken SemicolonToken { get; }
    internal GotoStatementSyntax(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal GotoStatementSyntax(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal GotoStatementSyntax(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    internal GotoStatementSyntax(ObjectReader reader);
    public SyntaxToken get_GotoKeyword();
    public SyntaxToken get_CaseOrDefaultKeyword();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public GotoStatementSyntax Update(SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GreenStats : object {
    internal static void NoteGreen(GreenNode node);
    [ConditionalAttribute("DEBUG")]
internal static void ItemAdded();
    [ConditionalAttribute("DEBUG")]
internal static void ItemCacheable();
    [ConditionalAttribute("DEBUG")]
internal static void CacheHit();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GroupClauseSyntax : SelectOrGroupClauseSyntax {
    internal SyntaxToken groupKeyword;
    internal ExpressionSyntax groupExpression;
    internal SyntaxToken byKeyword;
    internal ExpressionSyntax byExpression;
    public SyntaxToken GroupKeyword { get; }
    public ExpressionSyntax GroupExpression { get; }
    public SyntaxToken ByKeyword { get; }
    public ExpressionSyntax ByExpression { get; }
    internal GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression, SyntaxFactoryContext context);
    internal GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression);
    internal GroupClauseSyntax(ObjectReader reader);
    public SyntaxToken get_GroupKeyword();
    public ExpressionSyntax get_GroupExpression();
    public SyntaxToken get_ByKeyword();
    public ExpressionSyntax get_ByExpression();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public GroupClauseSyntax Update(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IdentifierNameSyntax : SimpleNameSyntax {
    internal SyntaxToken identifier;
    public SyntaxToken Identifier { get; }
    internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxFactoryContext context);
    internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier);
    internal IdentifierNameSyntax(ObjectReader reader);
    public virtual string ToString();
    public virtual SyntaxToken get_Identifier();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public IdentifierNameSyntax Update(SyntaxToken identifier);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax {
    internal SyntaxToken hashToken;
    internal SyntaxToken ifKeyword;
    internal ExpressionSyntax condition;
    internal SyntaxToken endOfDirectiveToken;
    internal bool isActive;
    internal bool branchTaken;
    internal bool conditionValue;
    public SyntaxToken HashToken { get; }
    public SyntaxToken IfKeyword { get; }
    public ExpressionSyntax Condition { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    public bool BranchTaken { get; }
    public bool ConditionValue { get; }
    internal IfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal IfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, SyntaxFactoryContext context);
    internal IfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue);
    internal IfDirectiveTriviaSyntax(ObjectReader reader);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_IfKeyword();
    public virtual ExpressionSyntax get_Condition();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    public virtual bool get_BranchTaken();
    public virtual bool get_ConditionValue();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public IfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfStatementSyntax : StatementSyntax {
    internal SyntaxToken ifKeyword;
    internal SyntaxToken openParenToken;
    internal ExpressionSyntax condition;
    internal SyntaxToken closeParenToken;
    internal StatementSyntax statement;
    internal ElseClauseSyntax else;
    public SyntaxToken IfKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Condition { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    public ElseClauseSyntax Else { get; }
    internal IfStatementSyntax(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax else, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal IfStatementSyntax(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax else, SyntaxFactoryContext context);
    internal IfStatementSyntax(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax else);
    internal IfStatementSyntax(ObjectReader reader);
    public SyntaxToken get_IfKeyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Condition();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    public ElseClauseSyntax get_Else();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public IfStatementSyntax Update(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax else);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitArrayCreationExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken newKeyword;
    internal SyntaxToken openBracketToken;
    internal CSharpSyntaxNode commas;
    internal SyntaxToken closeBracketToken;
    internal InitializerExpressionSyntax initializer;
    public SyntaxToken NewKeyword { get; }
    public SyntaxToken OpenBracketToken { get; }
    public SyntaxList`1<SyntaxToken> Commas { get; }
    public SyntaxToken CloseBracketToken { get; }
    public InitializerExpressionSyntax Initializer { get; }
    internal ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, CSharpSyntaxNode commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, CSharpSyntaxNode commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer, SyntaxFactoryContext context);
    internal ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, CSharpSyntaxNode commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer);
    internal ImplicitArrayCreationExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_NewKeyword();
    public SyntaxToken get_OpenBracketToken();
    public SyntaxList`1<SyntaxToken> get_Commas();
    public SyntaxToken get_CloseBracketToken();
    public InitializerExpressionSyntax get_Initializer();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ImplicitArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxList`1<SyntaxToken> commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitElementAccessSyntax : ExpressionSyntax {
    internal BracketedArgumentListSyntax argumentList;
    public BracketedArgumentListSyntax ArgumentList { get; }
    internal ImplicitElementAccessSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ImplicitElementAccessSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, SyntaxFactoryContext context);
    internal ImplicitElementAccessSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList);
    internal ImplicitElementAccessSyntax(ObjectReader reader);
    public BracketedArgumentListSyntax get_ArgumentList();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ImplicitElementAccessSyntax Update(BracketedArgumentListSyntax argumentList);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IncompleteMemberSyntax : MemberDeclarationSyntax {
    internal CSharpSyntaxNode attributeLists;
    internal CSharpSyntaxNode modifiers;
    internal TypeSyntax type;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public TypeSyntax Type { get; }
    internal IncompleteMemberSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal IncompleteMemberSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax type, SyntaxFactoryContext context);
    internal IncompleteMemberSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax type);
    internal IncompleteMemberSyntax(ObjectReader reader);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxList`1<SyntaxToken> get_Modifiers();
    public TypeSyntax get_Type();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public IncompleteMemberSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, TypeSyntax type);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IndexerDeclarationSyntax : BasePropertyDeclarationSyntax {
    internal CSharpSyntaxNode attributeLists;
    internal CSharpSyntaxNode modifiers;
    internal TypeSyntax type;
    internal ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    internal SyntaxToken thisKeyword;
    internal BracketedParameterListSyntax parameterList;
    internal AccessorListSyntax accessorList;
    internal ArrowExpressionClauseSyntax expressionBody;
    internal SyntaxToken semicolonToken;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public TypeSyntax Type { get; }
    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }
    public SyntaxToken ThisKeyword { get; }
    public BracketedParameterListSyntax ParameterList { get; }
    public AccessorListSyntax AccessorList { get; }
    public ArrowExpressionClauseSyntax ExpressionBody { get; }
    public SyntaxToken SemicolonToken { get; }
    internal IndexerDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal IndexerDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal IndexerDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    internal IndexerDeclarationSyntax(ObjectReader reader);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxList`1<SyntaxToken> get_Modifiers();
    public virtual TypeSyntax get_Type();
    public virtual ExplicitInterfaceSpecifierSyntax get_ExplicitInterfaceSpecifier();
    public SyntaxToken get_ThisKeyword();
    public BracketedParameterListSyntax get_ParameterList();
    public virtual AccessorListSyntax get_AccessorList();
    public ArrowExpressionClauseSyntax get_ExpressionBody();
    public SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public IndexerDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IndexerMemberCrefSyntax : MemberCrefSyntax {
    internal SyntaxToken thisKeyword;
    internal CrefBracketedParameterListSyntax parameters;
    public SyntaxToken ThisKeyword { get; }
    public CrefBracketedParameterListSyntax Parameters { get; }
    internal IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters, SyntaxFactoryContext context);
    internal IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters);
    internal IndexerMemberCrefSyntax(ObjectReader reader);
    public SyntaxToken get_ThisKeyword();
    public CrefBracketedParameterListSyntax get_Parameters();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public IndexerMemberCrefSyntax Update(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InitializerExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken openBraceToken;
    internal CSharpSyntaxNode expressions;
    internal SyntaxToken closeBraceToken;
    public SyntaxToken OpenBraceToken { get; }
    public SeparatedSyntaxList`1<ExpressionSyntax> Expressions { get; }
    public SyntaxToken CloseBraceToken { get; }
    internal InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, CSharpSyntaxNode expressions, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, CSharpSyntaxNode expressions, SyntaxToken closeBraceToken, SyntaxFactoryContext context);
    internal InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, CSharpSyntaxNode expressions, SyntaxToken closeBraceToken);
    internal InitializerExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_OpenBraceToken();
    public SeparatedSyntaxList`1<ExpressionSyntax> get_Expressions();
    public SyntaxToken get_CloseBraceToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public InitializerExpressionSyntax Update(SyntaxToken openBraceToken, SeparatedSyntaxList`1<ExpressionSyntax> expressions, SyntaxToken closeBraceToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InstanceExpressionSyntax : ExpressionSyntax {
    internal InstanceExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal InstanceExpressionSyntax(SyntaxKind kind);
    protected InstanceExpressionSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterfaceDeclarationSyntax : TypeDeclarationSyntax {
    internal CSharpSyntaxNode attributeLists;
    internal CSharpSyntaxNode modifiers;
    internal SyntaxToken keyword;
    internal SyntaxToken identifier;
    internal TypeParameterListSyntax typeParameterList;
    internal BaseListSyntax baseList;
    internal CSharpSyntaxNode constraintClauses;
    internal SyntaxToken openBraceToken;
    internal CSharpSyntaxNode members;
    internal SyntaxToken closeBraceToken;
    internal SyntaxToken semicolonToken;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public SyntaxToken Keyword { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public BaseListSyntax BaseList { get; }
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    public SyntaxToken CloseBraceToken { get; }
    public SyntaxToken SemicolonToken { get; }
    internal InterfaceDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, CSharpSyntaxNode constraintClauses, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal InterfaceDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, CSharpSyntaxNode constraintClauses, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal InterfaceDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, CSharpSyntaxNode constraintClauses, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    internal InterfaceDeclarationSyntax(ObjectReader reader);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxList`1<SyntaxToken> get_Modifiers();
    public virtual SyntaxToken get_Keyword();
    public virtual SyntaxToken get_Identifier();
    public virtual TypeParameterListSyntax get_TypeParameterList();
    public virtual BaseListSyntax get_BaseList();
    public virtual SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public virtual SyntaxToken get_OpenBraceToken();
    public virtual SyntaxList`1<MemberDeclarationSyntax> get_Members();
    public virtual SyntaxToken get_CloseBraceToken();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public InterfaceDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolatedStringContentSyntax : CSharpSyntaxNode {
    internal InterpolatedStringContentSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal InterpolatedStringContentSyntax(SyntaxKind kind);
    protected InterpolatedStringContentSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolatedStringExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken stringStartToken;
    internal CSharpSyntaxNode contents;
    internal SyntaxToken stringEndToken;
    public SyntaxToken StringStartToken { get; }
    public SyntaxList`1<InterpolatedStringContentSyntax> Contents { get; }
    public SyntaxToken StringEndToken { get; }
    internal InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, CSharpSyntaxNode contents, SyntaxToken stringEndToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, CSharpSyntaxNode contents, SyntaxToken stringEndToken, SyntaxFactoryContext context);
    internal InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, CSharpSyntaxNode contents, SyntaxToken stringEndToken);
    internal InterpolatedStringExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_StringStartToken();
    public SyntaxList`1<InterpolatedStringContentSyntax> get_Contents();
    public SyntaxToken get_StringEndToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public InterpolatedStringExpressionSyntax Update(SyntaxToken stringStartToken, SyntaxList`1<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolatedStringTextSyntax : InterpolatedStringContentSyntax {
    internal SyntaxToken textToken;
    public SyntaxToken TextToken { get; }
    internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken, SyntaxFactoryContext context);
    internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken);
    internal InterpolatedStringTextSyntax(ObjectReader reader);
    public SyntaxToken get_TextToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public InterpolatedStringTextSyntax Update(SyntaxToken textToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolationAlignmentClauseSyntax : CSharpSyntaxNode {
    internal SyntaxToken commaToken;
    internal ExpressionSyntax value;
    public SyntaxToken CommaToken { get; }
    public ExpressionSyntax Value { get; }
    internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExpressionSyntax value, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExpressionSyntax value, SyntaxFactoryContext context);
    internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExpressionSyntax value);
    internal InterpolationAlignmentClauseSyntax(ObjectReader reader);
    public SyntaxToken get_CommaToken();
    public ExpressionSyntax get_Value();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public InterpolationAlignmentClauseSyntax Update(SyntaxToken commaToken, ExpressionSyntax value);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolationFormatClauseSyntax : CSharpSyntaxNode {
    internal SyntaxToken colonToken;
    internal SyntaxToken formatStringToken;
    public SyntaxToken ColonToken { get; }
    public SyntaxToken FormatStringToken { get; }
    internal InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken, SyntaxFactoryContext context);
    internal InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken);
    internal InterpolationFormatClauseSyntax(ObjectReader reader);
    public SyntaxToken get_ColonToken();
    public SyntaxToken get_FormatStringToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public InterpolationFormatClauseSyntax Update(SyntaxToken colonToken, SyntaxToken formatStringToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolationSyntax : InterpolatedStringContentSyntax {
    internal SyntaxToken openBraceToken;
    internal ExpressionSyntax expression;
    internal InterpolationAlignmentClauseSyntax alignmentClause;
    internal InterpolationFormatClauseSyntax formatClause;
    internal SyntaxToken closeBraceToken;
    public SyntaxToken OpenBraceToken { get; }
    public ExpressionSyntax Expression { get; }
    public InterpolationAlignmentClauseSyntax AlignmentClause { get; }
    public InterpolationFormatClauseSyntax FormatClause { get; }
    public SyntaxToken CloseBraceToken { get; }
    internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken, SyntaxFactoryContext context);
    internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken);
    internal InterpolationSyntax(ObjectReader reader);
    public SyntaxToken get_OpenBraceToken();
    public ExpressionSyntax get_Expression();
    public InterpolationAlignmentClauseSyntax get_AlignmentClause();
    public InterpolationFormatClauseSyntax get_FormatClause();
    public SyntaxToken get_CloseBraceToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public InterpolationSyntax Update(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InvocationExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax expression;
    internal ArgumentListSyntax argumentList;
    public ExpressionSyntax Expression { get; }
    public ArgumentListSyntax ArgumentList { get; }
    internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList, SyntaxFactoryContext context);
    internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList);
    internal InvocationExpressionSyntax(ObjectReader reader);
    public ExpressionSyntax get_Expression();
    public ArgumentListSyntax get_ArgumentList();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public InvocationExpressionSyntax Update(ExpressionSyntax expression, ArgumentListSyntax argumentList);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.JoinClauseSyntax : QueryClauseSyntax {
    internal SyntaxToken joinKeyword;
    internal TypeSyntax type;
    internal SyntaxToken identifier;
    internal SyntaxToken inKeyword;
    internal ExpressionSyntax inExpression;
    internal SyntaxToken onKeyword;
    internal ExpressionSyntax leftExpression;
    internal SyntaxToken equalsKeyword;
    internal ExpressionSyntax rightExpression;
    internal JoinIntoClauseSyntax into;
    public SyntaxToken JoinKeyword { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken Identifier { get; }
    public SyntaxToken InKeyword { get; }
    public ExpressionSyntax InExpression { get; }
    public SyntaxToken OnKeyword { get; }
    public ExpressionSyntax LeftExpression { get; }
    public SyntaxToken EqualsKeyword { get; }
    public ExpressionSyntax RightExpression { get; }
    public JoinIntoClauseSyntax Into { get; }
    internal JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into, SyntaxFactoryContext context);
    internal JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into);
    internal JoinClauseSyntax(ObjectReader reader);
    public SyntaxToken get_JoinKeyword();
    public TypeSyntax get_Type();
    public SyntaxToken get_Identifier();
    public SyntaxToken get_InKeyword();
    public ExpressionSyntax get_InExpression();
    public SyntaxToken get_OnKeyword();
    public ExpressionSyntax get_LeftExpression();
    public SyntaxToken get_EqualsKeyword();
    public ExpressionSyntax get_RightExpression();
    public JoinIntoClauseSyntax get_Into();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public JoinClauseSyntax Update(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.JoinIntoClauseSyntax : CSharpSyntaxNode {
    internal SyntaxToken intoKeyword;
    internal SyntaxToken identifier;
    public SyntaxToken IntoKeyword { get; }
    public SyntaxToken Identifier { get; }
    internal JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, SyntaxFactoryContext context);
    internal JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier);
    internal JoinIntoClauseSyntax(ObjectReader reader);
    public SyntaxToken get_IntoKeyword();
    public SyntaxToken get_Identifier();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public JoinIntoClauseSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LabeledStatementSyntax : StatementSyntax {
    internal SyntaxToken identifier;
    internal SyntaxToken colonToken;
    internal StatementSyntax statement;
    public SyntaxToken Identifier { get; }
    public SyntaxToken ColonToken { get; }
    public StatementSyntax Statement { get; }
    internal LabeledStatementSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal LabeledStatementSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement, SyntaxFactoryContext context);
    internal LabeledStatementSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement);
    internal LabeledStatementSyntax(ObjectReader reader);
    public SyntaxToken get_Identifier();
    public SyntaxToken get_ColonToken();
    public StatementSyntax get_Statement();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public LabeledStatementSyntax Update(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LambdaExpressionSyntax : AnonymousFunctionExpressionSyntax {
    public SyntaxToken ArrowToken { get; }
    internal LambdaExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal LambdaExpressionSyntax(SyntaxKind kind);
    protected LambdaExpressionSyntax(ObjectReader reader);
    public abstract virtual SyntaxToken get_ArrowToken();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser : SyntaxParser {
    private SyntaxListPool _pool;
    private SyntaxFactoryContext _syntaxFactoryContext;
    private ContextAwareSyntax _syntaxFactory;
    private int _recursionDepth;
    private TerminatorState _termState;
    private bool _isInTry;
    private static int LastTerminatorState;
    private static SyntaxModifier AccessModifiers;
    private static int LambdaPrecedence;
    private bool IsCurrentTokenQueryContextualKeyword { get; }
    private bool IsStrict { get; }
    [ObsoleteAttribute("Use IsIncrementalAndFactoryContextMatches")]
private bool IsIncremental { get; }
    private bool IsIncrementalAndFactoryContextMatches { get; }
    private bool IsInAsync { get; private set; }
    private bool IsInQuery { get; }
    internal LanguageParser(Lexer lexer, CSharpSyntaxNode oldTree, IEnumerable`1<TextChangeRange> changes, LexerMode lexerMode, CancellationToken cancellationToken);
    private static bool IsName(CSharpSyntaxNode node, SyntaxKind kind);
    private static bool IsNameGlobal(CSharpSyntaxNode node);
    private static bool IsNameAssembly(CSharpSyntaxNode node);
    private static bool IsNameModule(CSharpSyntaxNode node);
    private static bool IsNameType(CSharpSyntaxNode node);
    private static bool IsNameGet(CSharpSyntaxNode node);
    private static bool IsNameSet(CSharpSyntaxNode node);
    private static bool IsNameAdd(CSharpSyntaxNode node);
    private static bool IsNameRemove(CSharpSyntaxNode node);
    private static bool IsSomeWord(SyntaxKind kind);
    private bool IsTerminator();
    private static CSharpSyntaxNode GetOldParent(CSharpSyntaxNode node);
    internal CompilationUnitSyntax ParseCompilationUnit();
    internal CompilationUnitSyntax ParseCompilationUnitCore();
    internal TNode ParseWithStackGuard(Func`1<TNode> parseFunc, Func`1<TNode> createEmptyNodeFunc);
    private TNode CreateForGlobalFailure(int position, TNode node);
    private NamespaceDeclarationSyntax ParseNamespaceDeclaration();
    private static bool ContainsAlias(NameSyntax name);
    private static bool ContainsGeneric(NameSyntax name);
    private static bool IsPossibleStartOfTypeDeclaration(SyntaxKind kind);
    private void AddSkippedNamespaceText(SyntaxToken& openBrace, NamespaceBodyBuilder& body, SyntaxListBuilder& initialBadNodes, CSharpSyntaxNode skippedSyntax);
    private void ParseNamespaceBody(SyntaxToken& openBrace, NamespaceBodyBuilder& body, SyntaxListBuilder& initialBadNodes, SyntaxKind parentKind);
    private static void AddIncompleteMembers(SyntaxListBuilder`1& incompleteMembers, NamespaceBodyBuilder& body);
    private void ReduceIncompleteMembers(SyntaxListBuilder`1& incompleteMembers, SyntaxToken& openBrace, NamespaceBodyBuilder& body, SyntaxListBuilder& initialBadNodes);
    private bool IsPossibleNamespaceMemberDeclaration();
    private bool IsPartialInNamespaceMemberDeclaration();
    public bool IsEndOfNamespace();
    public bool IsGobalAttributesTerminator();
    private bool IsNamespaceMemberStartOrStop();
    private bool ScanExternAliasDirective();
    private ExternAliasDirectiveSyntax ParseExternAliasDirective();
    private NameEqualsSyntax ParseNameEquals(bool warnOnGlobal);
    private UsingDirectiveSyntax ParseUsingDirective();
    private bool IsPossibleGlobalAttributeDeclaration();
    private static bool IsGlobalAttributeTarget(SyntaxToken token);
    private bool IsPossibleAttributeDeclaration();
    private void ParseAttributeDeclarations(SyntaxListBuilder list, bool allowAttributes);
    private bool IsAttributeDeclarationTerminator();
    private AttributeListSyntax ParseAttributeDeclaration();
    private void ParseAttributes(SeparatedSyntaxListBuilder`1<AttributeSyntax> nodes);
    private PostSkipAction SkipBadAttributeListTokens(SeparatedSyntaxListBuilder`1<AttributeSyntax> list, SyntaxKind expected);
    private bool IsPossibleAttribute();
    private AttributeSyntax ParseAttribute();
    internal AttributeArgumentListSyntax ParseAttributeArgumentList();
    private PostSkipAction SkipBadAttributeArgumentTokens(SyntaxToken& openParen, SeparatedSyntaxListBuilder`1<AttributeArgumentSyntax> list, SyntaxKind expected);
    private bool IsPossibleAttributeArgument();
    private AttributeArgumentSyntax ParseAttributeArgument(Boolean& shouldHaveName);
    private static SyntaxModifier GetModifier(SyntaxToken token);
    private static SyntaxModifier GetFieldModifier(SyntaxToken token);
    private bool IsPossibleModifier();
    private bool IsPossibleModifier(SyntaxToken token);
    private void ParseModifiers(SyntaxListBuilder tokens);
    private void ReportDuplicateModifiers(SyntaxToken& modTok, SyntaxModifier newMod, SyntaxModifier mods, Boolean& seenNoDuplicates, Boolean& seenNoAccessibilityDuplicates);
    private bool IsPartialType();
    private bool IsPartialMember();
    private bool IsPossibleMemberName();
    private static bool CanReuseTypeDeclaration(MemberDeclarationSyntax member);
    private MemberDeclarationSyntax ParseTypeDeclaration(SyntaxListBuilder`1<AttributeListSyntax> attributes, SyntaxListBuilder modifiers);
    private static bool IsMissingName(NameSyntax name);
    private TypeDeclarationSyntax ParseClassOrStructOrInterfaceDeclaration(SyntaxListBuilder`1<AttributeListSyntax> attributes, SyntaxListBuilder modifiers);
    private void SkipBadMemberListTokens(SyntaxToken& openBrace, SyntaxListBuilder members);
    private void SkipBadMemberListTokens(CSharpSyntaxNode& previousNode);
    private bool IsPossibleMemberStartOrStop();
    private bool IsPossibleAggregateClauseStartOrStop();
    private BaseListSyntax ParseBaseList();
    private PostSkipAction SkipBadBaseListTokens(SyntaxToken& colon, SeparatedSyntaxListBuilder`1<BaseTypeSyntax> list, SyntaxKind expected);
    private bool IsPossibleTypeParameterConstraintClauseStart();
    private void ParseTypeParameterConstraintClauses(bool isAllowed, SyntaxListBuilder list);
    private TypeParameterConstraintClauseSyntax ParseTypeParameterConstraintClause();
    private bool IsPossibleTypeParameterConstraint();
    private TypeParameterConstraintSyntax ParseTypeParameterConstraint(bool isFirst, Boolean& isStruct);
    private PostSkipAction SkipBadTypeParameterConstraintTokens(SeparatedSyntaxListBuilder`1<TypeParameterConstraintSyntax> list, SyntaxKind expected);
    private TypeSyntax ParseDeclarationType(bool isConstraint, bool parentIsParameter);
    private bool IsPossibleMemberStart();
    private static bool CanStartMember(SyntaxKind kind);
    private static bool CanStartTypeDeclaration(SyntaxKind kind);
    private static bool CanReuseMemberDeclaration(MemberDeclarationSyntax member, string typeName);
    private MemberDeclarationSyntax ParseMemberDeclarationOrStatement(SyntaxKind parentKind, string typeName);
    private bool ReconsiderTypeAsAsyncModifier(SyntaxListBuilder& modifiers, TypeSyntax& type, ExplicitInterfaceSpecifierSyntax& explicitInterfaceOpt, SyntaxToken identifierOrThisOpt, TypeParameterListSyntax typeParameterListOpt);
    private TypeArgumentListSyntax TypeArgumentFromTypeParameters(TypeParameterListSyntax typeParameterList);
    private bool IsFieldDeclaration(bool isEvent);
    private bool IsOperatorKeyword();
    public static bool IsComplete(CSharpSyntaxNode node);
    private ConstructorDeclarationSyntax ParseConstructorDeclaration(string typeName, SyntaxListBuilder`1<AttributeListSyntax> attributes, SyntaxListBuilder modifiers);
    private ConstructorInitializerSyntax ParseConstructorInitializer(string name, bool isStatic);
    private DestructorDeclarationSyntax ParseDestructorDeclaration(string typeName, SyntaxListBuilder`1<AttributeListSyntax> attributes, SyntaxListBuilder modifiers);
    private void ParseBlockAndExpressionBodiesWithSemicolon(BlockSyntax& blockBody, ArrowExpressionClauseSyntax& expressionBody, SyntaxToken& semicolon);
    private T CheckForBlockAndExpressionBody(CSharpSyntaxNode block, CSharpSyntaxNode expression, T syntax);
    private void ParseBodyOrSemicolon(BlockSyntax& body, SyntaxToken& semicolon);
    private bool IsEndOfTypeParameterList();
    private bool IsEndOfMethodSignature();
    private bool IsEndOfNameInExplicitInterface();
    private MethodDeclarationSyntax ParseMethodDeclaration(SyntaxListBuilder`1<AttributeListSyntax> attributes, SyntaxListBuilder modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt, SyntaxToken identifier, TypeParameterListSyntax typeParameterList);
    private TypeSyntax ParseReturnType();
    private bool IsEndOfReturnType();
    private ConversionOperatorDeclarationSyntax ParseConversionOperatorDeclaration(SyntaxListBuilder`1<AttributeListSyntax> attributes, SyntaxListBuilder modifiers);
    private OperatorDeclarationSyntax ParseOperatorDeclaration(SyntaxListBuilder`1<AttributeListSyntax> attributes, SyntaxListBuilder modifiers, TypeSyntax type);
    private MemberDeclarationSyntax ParseIndexerDeclaration(SyntaxListBuilder`1<AttributeListSyntax> attributes, SyntaxListBuilder modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt, SyntaxToken thisKeyword, TypeParameterListSyntax typeParameterList);
    private PropertyDeclarationSyntax ParsePropertyDeclaration(SyntaxListBuilder`1<AttributeListSyntax> attributes, SyntaxListBuilder modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceOpt, SyntaxToken identifier, TypeParameterListSyntax typeParameterList);
    private AccessorListSyntax ParseAccessorList(bool isEvent);
    private ArrowExpressionClauseSyntax ParseArrowExpressionClause();
    private PostSkipAction SkipBadAccessorListTokens(SyntaxToken& openBrace, SyntaxListBuilder`1<AccessorDeclarationSyntax> list, ErrorCode error);
    private bool IsPossibleAccessor();
    private bool IsPossibleAccessorModifier();
    private PostSkipAction SkipBadSeparatedListTokensWithExpectedKind(T& startToken, SeparatedSyntaxListBuilder`1<TNode> list, Func`2<LanguageParser, bool> isNotExpectedFunction, Func`2<LanguageParser, bool> abortFunction, SyntaxKind expected);
    private PostSkipAction SkipBadListTokensWithErrorCode(T& startToken, SyntaxListBuilder`1<TNode> list, Func`2<LanguageParser, bool> isNotExpectedFunction, Func`2<LanguageParser, bool> abortFunction, ErrorCode error);
    private PostSkipAction SkipBadListTokensWithExpectedKindHelper(SyntaxListBuilder list, Func`2<LanguageParser, bool> isNotExpectedFunction, Func`2<LanguageParser, bool> abortFunction, SyntaxKind expected, CSharpSyntaxNode& trailingTrivia);
    private PostSkipAction SkipBadListTokensWithErrorCodeHelper(SyntaxListBuilder`1<TNode> list, Func`2<LanguageParser, bool> isNotExpectedFunction, Func`2<LanguageParser, bool> abortFunction, ErrorCode error, CSharpSyntaxNode& trailingTrivia);
    private PostSkipAction SkipBadTokensWithExpectedKind(Func`2<LanguageParser, bool> isNotExpectedFunction, Func`2<LanguageParser, bool> abortFunction, SyntaxKind expected, CSharpSyntaxNode& trailingTrivia);
    private PostSkipAction SkipBadTokensWithErrorCode(Func`2<LanguageParser, bool> isNotExpectedFunction, Func`2<LanguageParser, bool> abortFunction, ErrorCode errorCode, CSharpSyntaxNode& trailingTrivia);
    private AccessorDeclarationSyntax ParseAccessorDeclaration(bool isEvent, Boolean& hasGetOrAdd, Boolean& hasSetOrRemove);
    private bool CanReuseAccessorDeclaration(bool isEvent);
    internal ParameterListSyntax ParseParenthesizedParameterList(bool allowThisKeyword, bool allowDefaults, bool allowAttributes);
    internal BracketedParameterListSyntax ParseBracketedParameterList(bool allowDefaults);
    private static bool CanReuseParameterList(ParameterListSyntax list);
    private static bool CanReuseBracketedParameterList(BracketedParameterListSyntax list);
    private void ParseParameterList(SyntaxToken& open, SeparatedSyntaxListBuilder`1<ParameterSyntax> nodes, SyntaxToken& close, SyntaxKind openKind, SyntaxKind closeKind, bool allowThisKeyword, bool allowDefaults, bool allowAttributes);
    private bool IsEndOfParameterList();
    private PostSkipAction SkipBadParameterListTokens(SyntaxToken& open, SeparatedSyntaxListBuilder`1<ParameterSyntax> list, SyntaxKind expected, SyntaxKind closeKind, bool allowThisKeyword);
    private bool IsPossibleParameter(bool allowThisKeyword);
    private static bool CanReuseParameter(ParameterSyntax parameter, SyntaxListBuilder`1<AttributeListSyntax> attributes, SyntaxListBuilder modifiers);
    private static bool CanReuseParameter(ParameterSyntax parameter);
    private ParameterSyntax ParseParameter(SyntaxListBuilder`1<AttributeListSyntax> attributes, SyntaxListBuilder modifiers, bool allowThisKeyword, bool allowDefaults, bool allowAttributes);
    private static bool IsParameterModifier(SyntaxKind kind, bool allowThisKeyword);
    private static ParamFlags GetParamFlags(SyntaxKind kind, bool allowThisKeyword);
    private void ParseParameterModifiers(SyntaxListBuilder modifiers, bool allowThisKeyword);
    private MemberDeclarationSyntax ParseFixedSizeBufferDeclaration(SyntaxListBuilder`1<AttributeListSyntax> attributes, SyntaxListBuilder modifiers, SyntaxKind parentKind);
    private MemberDeclarationSyntax ParseEventDeclaration(SyntaxListBuilder`1<AttributeListSyntax> attributes, SyntaxListBuilder modifiers, SyntaxKind parentKind);
    private MemberDeclarationSyntax ParseEventDeclarationWithAccessors(SyntaxListBuilder`1<AttributeListSyntax> attributes, SyntaxListBuilder modifiers, SyntaxToken eventToken, TypeSyntax type);
    private TNode EatUnexpectedTrailingSemicolon(TNode decl);
    private FieldDeclarationSyntax ParseNormalFieldDeclaration(SyntaxListBuilder`1<AttributeListSyntax> attributes, SyntaxListBuilder modifiers, TypeSyntax type, SyntaxKind parentKind);
    private MemberDeclarationSyntax ParseEventFieldDeclaration(SyntaxListBuilder`1<AttributeListSyntax> attributes, SyntaxListBuilder modifiers, SyntaxToken eventToken, TypeSyntax type, SyntaxKind parentKind);
    private bool IsEndOfFieldDeclaration();
    private void ParseVariableDeclarators(TypeSyntax type, VariableFlags flags, SeparatedSyntaxListBuilder`1<VariableDeclaratorSyntax> variables, SyntaxKind parentKind);
    private void ParseVariableDeclarators(TypeSyntax type, VariableFlags flags, SeparatedSyntaxListBuilder`1<VariableDeclaratorSyntax> variables, bool variableDeclarationsExpected);
    private PostSkipAction SkipBadVariableListTokens(SeparatedSyntaxListBuilder`1<VariableDeclaratorSyntax> list, SyntaxKind expected);
    private static SyntaxTokenList GetOriginalModifiers(CSharpSyntaxNode decl);
    private static bool WasFirstVariable(VariableDeclaratorSyntax variable);
    private static VariableFlags GetOriginalVariableFlags(VariableDeclaratorSyntax old);
    private static bool CanReuseVariableDeclarator(VariableDeclaratorSyntax old, VariableFlags flags, bool isFirst);
    private VariableDeclaratorSyntax ParseVariableDeclarator(TypeSyntax parentType, VariableFlags flags, bool isFirst, bool isExpressionContext);
    private bool IsPossibleEndOfVariableDeclaration();
    private ExpressionSyntax ParseVariableInitializer(bool allowStackAlloc);
    private bool IsPossibleVariableInitializer(bool allowStack);
    private FieldDeclarationSyntax ParseConstantFieldDeclaration(SyntaxListBuilder`1<AttributeListSyntax> attributes, SyntaxListBuilder modifiers, SyntaxKind parentKind);
    private DelegateDeclarationSyntax ParseDelegateDeclaration(SyntaxListBuilder`1<AttributeListSyntax> attributes, SyntaxListBuilder modifiers);
    private EnumDeclarationSyntax ParseEnumDeclaration(SyntaxListBuilder`1<AttributeListSyntax> attributes, SyntaxListBuilder modifiers);
    private void ParseEnumMemberDeclarations(SyntaxToken& openBrace, SeparatedSyntaxListBuilder`1<EnumMemberDeclarationSyntax> members);
    private PostSkipAction SkipBadEnumMemberListTokens(SyntaxToken& openBrace, SeparatedSyntaxListBuilder`1<EnumMemberDeclarationSyntax> list, SyntaxKind expected);
    private EnumMemberDeclarationSyntax ParseEnumMemberDeclaration();
    private bool IsPossibleEnumMemberDeclaration();
    private bool IsDotOrColonColon();
    public NameSyntax ParseName();
    private IdentifierNameSyntax CreateMissingIdentifierName();
    private static SyntaxToken CreateMissingIdentifierToken();
    private bool IsTrueIdentifier();
    private IdentifierNameSyntax ParseIdentifierName();
    private SyntaxToken ParseIdentifierToken();
    private bool IsCurrentTokenQueryKeywordInQuery();
    private bool IsCurrentTokenPartialKeywordOfPartialMethodOrType();
    private TypeParameterListSyntax ParseTypeParameterList(bool allowVariance);
    private PostSkipAction SkipBadTypeParameterListTokens(SeparatedSyntaxListBuilder`1<TypeParameterSyntax> list, SyntaxKind expected);
    private TypeParameterSyntax ParseTypeParameter(bool allowVariance);
    private SimpleNameSyntax ParseSimpleName(NameOptions options);
    private ScanTypeArgumentListKind ScanTypeArgumentList(bool inExpression);
    private bool ScanPossibleTypeArgumentList();
    private ScanTypeFlags ScanPossibleTypeArgumentList(SyntaxToken& lastTokenOfList);
    private void ParseTypeArgumentList(SyntaxToken& open, SeparatedSyntaxListBuilder`1<TypeSyntax> types, SyntaxToken& close);
    private PostSkipAction SkipBadTypeArgumentListTokens(SeparatedSyntaxListBuilder`1<TypeSyntax> list, SyntaxKind expected);
    private TypeSyntax ParseTypeArgument();
    private bool IsEndOfTypeArgumentList();
    private bool IsOpenName();
    private void ParseMemberName(ExplicitInterfaceSpecifierSyntax& explicitInterfaceOpt, SyntaxToken& identifierOrThisOpt, TypeParameterListSyntax& typeParameterListOpt, bool isEvent);
    private NameSyntax ParseAliasQualifiedName(NameOptions allowedParts);
    private NameSyntax ParseQualifiedName(NameOptions options);
    private NameSyntax ParseQualifiedNameRight(NameOptions options, NameSyntax left, SyntaxToken separator);
    private SyntaxToken ConvertToMissingWithTrailingTrivia(SyntaxToken token, SyntaxKind expectedKind);
    private bool IsPossibleType();
    private bool IsPossibleName();
    private ScanTypeFlags ScanType();
    private ScanTypeFlags ScanType(SyntaxToken& lastTokenOfType);
    private void ScanNamedTypePart();
    private ScanTypeFlags ScanNamedTypePart(SyntaxToken& lastTokenOfType);
    private ScanTypeFlags ScanNonArrayType();
    private ScanTypeFlags ScanNonArrayType(SyntaxToken& lastTokenOfType);
    private static bool IsPredefinedType(SyntaxKind keyword);
    public TypeSyntax ParseTypeName();
    private TypeSyntax ParseTypeOrVoid();
    private TypeSyntax ParseType(bool parentIsParameter);
    private bool IsTerm();
    private TypeSyntax ParseTypeCore(bool parentIsParameter, bool isOrAs, bool expectSizes, bool isArrayCreation);
    private bool IsPossibleRankAndDimensionSpecifier();
    private ArrayRankSpecifierSyntax ParseArrayRankSpecifier(bool isArrayCreation, bool expectSizes, Boolean& sawNonOmittedSize);
    private PostSkipAction SkipBadArrayRankSpecifierTokens(SyntaxToken& openBracket, SeparatedSyntaxListBuilder`1<ExpressionSyntax> list, SyntaxKind expected);
    private TypeSyntax ParseUnderlyingType(bool parentIsParameter);
    private TypeSyntax ParsePointerTypeMods(TypeSyntax type);
    public StatementSyntax ParseStatement();
    private StatementSyntax ParseStatementCore();
    private StatementSyntax ParsePossibleBadAwaitStatement();
    private StatementSyntax ParsePossibleBadAwaitStatement(ResetPoint& resetPointBeforeStatement);
    private StatementSyntax ParseStatementNoDeclaration(bool allowAnyExpression);
    private bool IsPossibleLabeledStatement();
    private bool IsPossibleYieldStatement();
    private bool IsPossibleLocalDeclarationStatement(bool allowAnyExpression);
    private bool IsPossibleDeclarationStatementFollowingNullableType();
    private bool IsPossibleFieldDeclarationFollowingNullableType();
    private bool IsPossibleMethodDeclarationFollowingNullableType();
    private bool IsPossibleNewExpression();
    private static Nullable`1<bool> IsPossibleTypedIdentifierStart(SyntaxToken current, SyntaxToken next, bool allowThisKeyword);
    private BlockSyntax ParseBlock(bool isMethodBody, bool isAccessorBody);
    private static bool IsLargeEnoughNonEmptyStatementList(SyntaxListBuilder`1<StatementSyntax> statements);
    private void ParseStatements(CSharpSyntaxNode& previousNode, SyntaxListBuilder`1<StatementSyntax> statements, bool stopOnSwitchSections);
    private bool IsPossibleStatementStartOrStop();
    private PostSkipAction SkipBadStatementListTokens(SyntaxListBuilder`1<StatementSyntax> statements, SyntaxKind expected, CSharpSyntaxNode& trailingTrivia);
    private bool IsPossibleStatement();
    private FixedStatementSyntax ParseFixedStatement();
    private bool IsEndOfFixedStatement();
    private StatementSyntax ParseEmbeddedStatement(bool complexCheck);
    private BreakStatementSyntax ParseBreakStatement();
    private ContinueStatementSyntax ParseContinueStatement();
    private TryStatementSyntax ParseTryStatement();
    private bool IsEndOfTryBlock();
    private CatchClauseSyntax ParseCatchClause(bool hasCatchAll);
    private bool IsEndOfCatchClause();
    private bool IsEndOfFilterClause();
    private bool IsEndOfCatchBlock();
    private TypeSyntax ParseClassType();
    private StatementSyntax ParseCheckedStatement();
    private DoStatementSyntax ParseDoStatement();
    private bool IsEndOfDoWhileExpression();
    private StatementSyntax ParseForOrForEachStatement();
    private ForStatementSyntax ParseForStatement();
    private bool IsEndOfForStatementArgument();
    private void ParseForStatementExpressionList(SyntaxToken& startToken, SeparatedSyntaxListBuilder`1<ExpressionSyntax> list);
    private PostSkipAction SkipBadForStatementExpressionListTokens(SyntaxToken& startToken, SeparatedSyntaxListBuilder`1<ExpressionSyntax> list, SyntaxKind expected);
    private ForEachStatementSyntax ParseForEachStatement();
    private GotoStatementSyntax ParseGotoStatement();
    private IfStatementSyntax ParseIfStatement();
    private LockStatementSyntax ParseLockStatement();
    private ReturnStatementSyntax ParseReturnStatement();
    private YieldStatementSyntax ParseYieldStatement();
    private SwitchStatementSyntax ParseSwitchStatement();
    private bool IsPossibleSwitchSection();
    private SwitchSectionSyntax ParseSwitchSection();
    private ThrowStatementSyntax ParseThrowStatement();
    private UnsafeStatementSyntax ParseUnsafeStatement();
    private UsingStatementSyntax ParseUsingStatement();
    private void ParseUsingExpression(VariableDeclarationSyntax& declaration, ExpressionSyntax& expression, ResetPoint& resetPoint);
    private bool IsUsingStatementVariableDeclaration(ScanTypeFlags st);
    private WhileStatementSyntax ParseWhileStatement();
    private LabeledStatementSyntax ParseLabeledStatement();
    private LocalDeclarationStatementSyntax ParseLocalDeclarationStatement();
    private void ParseDeclaration(bool isConst, TypeSyntax& type, SeparatedSyntaxListBuilder`1<VariableDeclaratorSyntax> variables);
    private bool IsEndOfDeclarationClause();
    private void ParseDeclarationModifiers(SyntaxListBuilder list);
    private static bool IsDeclarationModifier(SyntaxKind kind);
    private ExpressionStatementSyntax ParseExpressionStatement();
    private ExpressionStatementSyntax ParseExpressionStatement(ExpressionSyntax expression);
    public ExpressionSyntax ParseExpression();
    private ExpressionSyntax ParseExpressionCore();
    private bool IsPossibleExpression();
    private static bool IsInvalidSubExpression(SyntaxKind kind);
    internal static bool IsRightAssociative(SyntaxKind op);
    private static UInt32 GetPrecedence(SyntaxKind op);
    private static bool IsExpectedPrefixUnaryOperator(SyntaxKind kind);
    private static bool IsExpectedBinaryOperator(SyntaxKind kind);
    private static bool IsExpectedAssignmentOperator(SyntaxKind kind);
    private bool IsPossibleAwaitExpressionStatement();
    private bool IsAwaitExpression();
    private ExpressionSyntax ParseSubExpression(UInt32 precedence);
    private ExpressionSyntax ParseSubExpressionCore(UInt32 precedence);
    private ExpressionSyntax ParseTerm(UInt32 precedence);
    private bool IsPossibleLambdaExpression(UInt32 precedence);
    private ExpressionSyntax ParsePostFixExpression(ExpressionSyntax expr);
    private bool CanStartConsequenceExpression(SyntaxKind kind);
    internal ExpressionSyntax ParseConsequenceSyntax();
    internal ArgumentListSyntax ParseParenthesizedArgumentList();
    internal BracketedArgumentListSyntax ParseBracketedArgumentList();
    private void ParseArgumentList(SyntaxToken& openToken, SeparatedSyntaxList`1& arguments, SyntaxToken& closeToken, SyntaxKind openKind, SyntaxKind closeKind);
    private PostSkipAction SkipBadArgumentListTokens(SyntaxToken& open, SeparatedSyntaxListBuilder`1<ArgumentSyntax> list, SyntaxKind expected, SyntaxKind closeKind);
    private bool IsEndOfArgumentList();
    private bool IsPossibleArgumentExpression();
    private ArgumentSyntax ParseArgumentExpression(bool isIndexer);
    private TypeOfExpressionSyntax ParseTypeOfExpression();
    private DefaultExpressionSyntax ParseDefaultExpression();
    private SizeOfExpressionSyntax ParseSizeOfExpression();
    private MakeRefExpressionSyntax ParseMakeRefExpression();
    private RefTypeExpressionSyntax ParseRefTypeExpression();
    private CheckedExpressionSyntax ParseCheckedOrUncheckedExpression();
    private RefValueExpressionSyntax ParseRefValueExpression();
    private bool ScanParenthesizedImplicitlyTypedLambda(UInt32 precedence);
    private bool ScanExplicitlyTypedLambda(UInt32 precedence);
    private ExpressionSyntax ParseCastOrParenExpressionOrLambda(UInt32 precedence);
    private bool ScanCast();
    private bool ScanAsyncLambda(UInt32 precedence);
    private static bool CanFollowCast(SyntaxKind kind);
    private ExpressionSyntax ParseNewExpression();
    private bool IsAnonymousType();
    private AnonymousObjectCreationExpressionSyntax ParseAnonymousTypeExpression();
    private void ParseAnonymousTypeMemberInitializers(SyntaxToken& openBrace, SeparatedSyntaxListBuilder`1& list);
    private AnonymousObjectMemberDeclaratorSyntax ParseAnonymousTypeMemberInitializer();
    private bool IsAnonymousTypeMemberExpression(ExpressionSyntax expr);
    private bool IsInitializerMember();
    private bool IsComplexElementInitializer();
    private bool IsNamedAssignment();
    private bool IsDictionaryInitializer();
    private ExpressionSyntax ParseArrayOrObjectCreationExpression();
    private static int GetNumberOfNonOmittedArraySizes(ArrayRankSpecifierSyntax rankSpec);
    private bool IsPossibleArrayCreationExpression();
    private InitializerExpressionSyntax ParseObjectOrCollectionInitializer();
    private void ParseObjectOrCollectionInitializerMembers(SyntaxToken& startToken, SeparatedSyntaxListBuilder`1<ExpressionSyntax> list, Boolean& isObjectInitializer);
    private ExpressionSyntax ParseObjectOrCollectionInitializerMember(Boolean& isObjectInitializer);
    private PostSkipAction SkipBadInitializerListTokens(SyntaxToken& startToken, SeparatedSyntaxListBuilder`1<T> list, SyntaxKind expected);
    private ExpressionSyntax ParseObjectInitializerNamedAssignment();
    private ExpressionSyntax ParseDictionaryInitializer();
    private InitializerExpressionSyntax ParseComplexElementInitializer();
    private void ParseExpressionsForComplexElementInitializer(SyntaxToken& openBrace, SeparatedSyntaxListBuilder`1<ExpressionSyntax> list, DiagnosticInfo& closeBraceError);
    private ExpressionSyntax ParseElementInitializer();
    private bool IsImplicitlyTypedArray();
    private ImplicitArrayCreationExpressionSyntax ParseImplicitlyTypedArrayCreation();
    private InitializerExpressionSyntax ParseArrayInitializer();
    private PostSkipAction SkipBadArrayInitializerTokens(SyntaxToken& openBrace, SeparatedSyntaxListBuilder`1<ExpressionSyntax> list, SyntaxKind expected);
    private StackAllocArrayCreationExpressionSyntax ParseStackAllocExpression();
    private AnonymousMethodExpressionSyntax ParseAnonymousMethodExpression();
    private ExpressionSyntax ParseLambdaExpression();
    private ParameterListSyntax ParseLambdaParameterList();
    private bool IsPossibleLambdaParameter();
    private PostSkipAction SkipBadLambdaParameterListTokens(SyntaxToken& openParen, SeparatedSyntaxListBuilder`1<ParameterSyntax> list, SyntaxKind expected, SyntaxKind closeKind);
    private ParameterSyntax ParseLambdaParameter(bool isFirst, Boolean& hasTypes);
    private bool get_IsCurrentTokenQueryContextualKeyword();
    private static bool IsTokenQueryContextualKeyword(SyntaxToken token);
    private static bool IsTokenStartOfNewQueryClause(SyntaxToken token);
    private bool IsQueryExpression(bool mayBeVariableDeclaration, bool mayBeMemberDeclaration);
    private bool IsQueryExpressionAfterFrom(bool mayBeVariableDeclaration, bool mayBeMemberDeclaration);
    private QueryExpressionSyntax ParseQueryExpression(UInt32 precedence);
    private QueryBodySyntax ParseQueryBody();
    private FromClauseSyntax ParseFromClause();
    private JoinClauseSyntax ParseJoinClause();
    private LetClauseSyntax ParseLetClause();
    private WhereClauseSyntax ParseWhereClause();
    private OrderByClauseSyntax ParseOrderByClause();
    private PostSkipAction SkipBadOrderingListTokens(SeparatedSyntaxListBuilder`1<OrderingSyntax> list, SyntaxKind expected);
    private OrderingSyntax ParseOrdering();
    private SelectClauseSyntax ParseSelectClause();
    private GroupClauseSyntax ParseGroupClause();
    private QueryContinuationSyntax ParseQueryContinuation();
    private bool get_IsStrict();
    private bool get_IsIncremental();
    private bool get_IsIncrementalAndFactoryContextMatches();
    internal static bool MatchesFactoryContext(GreenNode green, SyntaxFactoryContext context);
    private bool get_IsInAsync();
    private void set_IsInAsync(bool value);
    private bool get_IsInQuery();
    private void EnterQuery();
    private void LeaveQuery();
    private ResetPoint GetResetPoint();
    private void Reset(ResetPoint& state);
    private void Release(ResetPoint& state);
    internal TNode ConsumeUnexpectedTokens(TNode node);
    private string Substring(string s, int first, int last);
    private ExpressionSyntax ParseInterpolatedStringToken();
    private InterpolationSyntax ParseInterpolation(string text, Interpolation interpolation, bool isVerbatim);
    private SyntaxToken MakeStringToken(string text, string bodyText, bool isVerbatim, SyntaxKind kind);
    private DiagnosticInfo[] MoveDiagnostics(DiagnosticInfo[] infos, int offset);
    private void ParseInterpolationStart(SyntaxToken& openBraceToken, ExpressionSyntax& expr, SyntaxToken& commaToken, ExpressionSyntax& alignmentExpression);
    [CompilerGeneratedAttribute]
private bool <SkipBadTypeParameterConstraintTokens>b__84_0(LanguageParser p);
    [CompilerGeneratedAttribute]
private bool <SkipBadTypeParameterConstraintTokens>b__84_1(LanguageParser p);
    [CompilerGeneratedAttribute]
private bool <SkipBadVariableListTokens>b__150_0(LanguageParser p);
    [CompilerGeneratedAttribute]
private bool <SkipBadVariableListTokens>b__150_1(LanguageParser p);
    [CompilerGeneratedAttribute]
private bool <SkipBadTypeParameterListTokens>b__178_0(LanguageParser p);
    [CompilerGeneratedAttribute]
private bool <SkipBadTypeParameterListTokens>b__178_1(LanguageParser p);
    [CompilerGeneratedAttribute]
private bool <SkipBadTypeArgumentListTokens>b__186_0(LanguageParser p);
    [CompilerGeneratedAttribute]
private bool <SkipBadTypeArgumentListTokens>b__186_1(LanguageParser p);
    [CompilerGeneratedAttribute]
private bool <SkipBadArrayInitializerTokens>b__340_1(LanguageParser p);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LetClauseSyntax : QueryClauseSyntax {
    internal SyntaxToken letKeyword;
    internal SyntaxToken identifier;
    internal SyntaxToken equalsToken;
    internal ExpressionSyntax expression;
    public SyntaxToken LetKeyword { get; }
    public SyntaxToken Identifier { get; }
    public SyntaxToken EqualsToken { get; }
    public ExpressionSyntax Expression { get; }
    internal LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression, SyntaxFactoryContext context);
    internal LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression);
    internal LetClauseSyntax(ObjectReader reader);
    public SyntaxToken get_LetKeyword();
    public SyntaxToken get_Identifier();
    public SyntaxToken get_EqualsToken();
    public ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public LetClauseSyntax Update(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer : AbstractLexer {
    private static int TriviaListInitialCapacity;
    private CSharpParseOptions _options;
    private LexerMode _mode;
    private StringBuilder _builder;
    private Char[] _identBuffer;
    private int _identLen;
    private DirectiveStack _directives;
    private LexerCache _cache;
    private bool _allowPreprocessorDirectives;
    private DocumentationCommentParser _xmlParser;
    private int _badTokenCount;
    private SyntaxListBuilder _leadingTriviaCache;
    private SyntaxListBuilder _trailingTriviaCache;
    private Func`1<SyntaxTrivia> _createWhitespaceTriviaFunction;
    private static int MaxCachedTokenSize;
    private static Byte[0...,0...] s_stateTransitions;
    private Func`1<SyntaxToken> _createQuickTokenFunction;
    private static Byte[] s_charProperties;
    public bool SuppressDocumentationCommentParse { get; }
    public CSharpParseOptions Options { get; }
    public DirectiveStack Directives { get; }
    private bool InDocumentationComment { get; }
    private bool InXmlCrefOrNameAttributeValue { get; }
    private bool InXmlNameAttributeValue { get; }
    public Lexer(SourceText text, CSharpParseOptions options, bool allowPreprocessorDirectives);
    private static Lexer();
    public virtual void Dispose();
    public bool get_SuppressDocumentationCommentParse();
    public CSharpParseOptions get_Options();
    public DirectiveStack get_Directives();
    public void Reset(int position, DirectiveStack directives);
    private static LexerMode ModeOf(LexerMode mode);
    private bool ModeIs(LexerMode mode);
    private static XmlDocCommentLocation LocationOf(LexerMode mode);
    private bool LocationIs(XmlDocCommentLocation location);
    private void MutateLocation(XmlDocCommentLocation location);
    private static XmlDocCommentStyle StyleOf(LexerMode mode);
    private bool StyleIs(XmlDocCommentStyle style);
    private bool get_InDocumentationComment();
    public SyntaxToken Lex(LexerMode& mode);
    public SyntaxToken Lex(LexerMode mode);
    private static int GetFullWidth(SyntaxListBuilder builder);
    private SyntaxToken LexSyntaxToken();
    internal SyntaxTriviaList LexSyntaxLeadingTrivia();
    internal SyntaxTriviaList LexSyntaxTrailingTrivia();
    private SyntaxToken Create(TokenInfo& info, SyntaxListBuilder leading, SyntaxListBuilder trailing, SyntaxDiagnosticInfo[] errors);
    private void ScanSyntaxToken(TokenInfo& info);
    private void CheckFeatureAvailability(MessageID feature);
    private bool ScanInteger();
    private bool ScanNumericLiteral(TokenInfo& info);
    private int GetValueInt32(string text, bool isHex);
    private ulong GetValueUInt64(string text, bool isHex);
    private double GetValueDouble(string text);
    private float GetValueSingle(string text);
    private decimal GetValueDecimal(string text, int start, int end);
    private void ResetIdentBuffer();
    private void AddIdentChar(char ch);
    private void GrowIdentBuffer();
    private bool ScanIdentifier(TokenInfo& info);
    private bool ScanIdentifier_FastPath(TokenInfo& info);
    private bool ScanIdentifier_SlowPath(TokenInfo& info);
    private static bool IsValidHexDigit(char c);
    private bool ScanIdentifier_CrefSlowPath(TokenInfo& info);
    private bool ScanIdentifierOrKeyword(TokenInfo& info);
    private void LexSyntaxTrivia(bool afterFirstToken, bool isTrailing, SyntaxListBuilder& triviaList);
    private void AddTrivia(CSharpSyntaxNode trivia, SyntaxListBuilder& list);
    private bool ScanMultiLineComment(Boolean& isTerminated);
    private void ScanToEndOfLine();
    private CSharpSyntaxNode ScanEndOfLine();
    private SyntaxTrivia ScanWhitespace();
    private SyntaxTrivia CreateWhitespaceTrivia();
    private void LexDirectiveAndExcludedTrivia(bool afterFirstToken, bool afterNonWhitespaceOnLine, SyntaxListBuilder& triviaList);
    private void LexExcludedDirectivesAndTrivia(bool endIsActive, SyntaxListBuilder& triviaList);
    private CSharpSyntaxNode LexSingleDirective(bool isActive, bool endIsActive, bool afterFirstToken, bool afterNonWhitespaceOnLine, SyntaxListBuilder& triviaList);
    private CSharpSyntaxNode LexDisabledText(Boolean& followedByDirective);
    private SyntaxToken LexDirectiveToken();
    private bool ScanDirectiveToken(TokenInfo& info);
    private SyntaxListBuilder LexDirectiveTrailingTrivia(bool includeEndOfLine);
    private CSharpSyntaxNode LexDirectiveTrivia();
    private CSharpSyntaxNode LexXmlDocComment(XmlDocCommentStyle style);
    private SyntaxToken LexXmlToken();
    private bool ScanXmlToken(TokenInfo& info);
    private void ScanXmlTagStart(TokenInfo& info);
    private void ScanXmlEntity(TokenInfo& info);
    private static bool MatchesProductionForXmlChar(UInt32 charValue);
    private void ScanXmlText(TokenInfo& info);
    private SyntaxToken LexXmlElementTagToken();
    private bool ScanXmlElementTagToken(TokenInfo& info);
    private void ScanXmlName(TokenInfo& info);
    private static bool IsXmlNameStartChar(char ch);
    private static bool IsXmlNameChar(char ch);
    private SyntaxToken LexXmlAttributeTextToken();
    private bool ScanXmlAttributeTextToken(TokenInfo& info);
    private void ScanXmlAttributeText(TokenInfo& info);
    private SyntaxToken LexXmlCharacter();
    private bool ScanXmlCharacter(TokenInfo& info);
    private SyntaxToken LexXmlCrefOrNameToken();
    private bool ScanXmlCrefToken(TokenInfo& info);
    private bool AdvanceIfMatches(char ch);
    private bool get_InXmlCrefOrNameAttributeValue();
    private bool get_InXmlNameAttributeValue();
    private void AddCrefError(ErrorCode code, Object[] args);
    private void AddCrefError(DiagnosticInfo info);
    private SyntaxToken LexXmlCDataSectionTextToken();
    private bool ScanXmlCDataSectionTextToken(TokenInfo& info);
    private void ScanXmlCDataSectionText(TokenInfo& info);
    private SyntaxToken LexXmlCommentTextToken();
    private bool ScanXmlCommentTextToken(TokenInfo& info);
    private void ScanXmlCommentText(TokenInfo& info);
    private SyntaxToken LexXmlProcessingInstructionTextToken();
    private bool ScanXmlProcessingInstructionTextToken(TokenInfo& info);
    private void ScanXmlProcessingInstructionText(TokenInfo& info);
    private void LexXmlDocCommentLeadingTrivia(SyntaxListBuilder& trivia);
    private void LexXmlDocCommentLeadingTriviaWithWhitespace(SyntaxListBuilder& trivia);
    private void LexXmlWhitespaceAndNewLineTrivia(SyntaxListBuilder& trivia);
    private void ScanStringLiteral(TokenInfo& info, bool allowEscapes);
    private char ScanEscapeSequence(Char& surrogateCharacter);
    private void ScanVerbatimStringLiteral(TokenInfo& info, bool allowNewlines);
    private void ScanInterpolatedStringLiteral(bool isVerbatim, TokenInfo& info);
    internal void ScanInterpolatedStringLiteralTop(ArrayBuilder`1<Interpolation> interpolations, bool isVerbatim, TokenInfo& info, SyntaxDiagnosticInfo& error, Boolean& closeQuoteMissing);
    internal static SyntaxToken RescanInterpolatedString(InterpolatedStringExpressionSyntax interpolatedString);
    private SyntaxToken QuickScanSyntaxToken();
    private SyntaxToken CreateQuickToken();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LexerCache : object {
    private static ObjectPool`1<CachingIdentityFactory`2<string, SyntaxKind>> s_keywordKindPool;
    private TextKeyedCache`1<SyntaxTrivia> _triviaMap;
    private TextKeyedCache`1<SyntaxToken> _tokenMap;
    private CachingIdentityFactory`2<string, SyntaxKind> _keywordKindMap;
    internal static int MaxKeywordLength;
    private static LexerCache();
    internal void Free();
    internal bool TryGetKeywordKind(string key, SyntaxKind& kind);
    internal SyntaxTrivia LookupTrivia(Char[] textBuffer, int keyStart, int keyLength, int hashCode, Func`1<SyntaxTrivia> createTriviaFunction);
    internal SyntaxToken LookupToken(Char[] textBuffer, int keyStart, int keyLength, int hashCode, Func`1<SyntaxToken> createTokenFunction);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LexerMode : Enum {
    public int value__;
    public static LexerMode Syntax;
    public static LexerMode DebuggerSyntax;
    public static LexerMode Directive;
    public static LexerMode XmlDocComment;
    public static LexerMode XmlElementTag;
    public static LexerMode XmlAttributeTextQuote;
    public static LexerMode XmlAttributeTextDoubleQuote;
    public static LexerMode XmlCrefQuote;
    public static LexerMode XmlCrefDoubleQuote;
    public static LexerMode XmlNameQuote;
    public static LexerMode XmlNameDoubleQuote;
    public static LexerMode XmlCDataSectionText;
    public static LexerMode XmlCommentText;
    public static LexerMode XmlProcessingInstructionText;
    public static LexerMode XmlCharacter;
    public static LexerMode MaskLexMode;
    public static LexerMode XmlDocCommentLocationStart;
    public static LexerMode XmlDocCommentLocationInterior;
    public static LexerMode XmlDocCommentLocationExterior;
    public static LexerMode XmlDocCommentLocationEnd;
    public static LexerMode MaskXmlDocCommentLocation;
    public static LexerMode XmlDocCommentStyleSingleLine;
    public static LexerMode XmlDocCommentStyleDelimited;
    public static LexerMode MaskXmlDocCommentStyle;
    public static LexerMode None;
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LineDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal SyntaxToken hashToken;
    internal SyntaxToken lineKeyword;
    internal SyntaxToken line;
    internal SyntaxToken file;
    internal SyntaxToken endOfDirectiveToken;
    internal bool isActive;
    public SyntaxToken HashToken { get; }
    public SyntaxToken LineKeyword { get; }
    public SyntaxToken Line { get; }
    public SyntaxToken File { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal LineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal LineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context);
    internal LineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    internal LineDirectiveTriviaSyntax(ObjectReader reader);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_LineKeyword();
    public SyntaxToken get_Line();
    public SyntaxToken get_File();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public LineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LiteralExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken token;
    public SyntaxToken Token { get; }
    internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context);
    internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token);
    internal LiteralExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_Token();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public LiteralExpressionSyntax Update(SyntaxToken token);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LoadDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal SyntaxToken hashToken;
    internal SyntaxToken loadKeyword;
    internal SyntaxToken file;
    internal SyntaxToken endOfDirectiveToken;
    internal bool isActive;
    public SyntaxToken HashToken { get; }
    public SyntaxToken LoadKeyword { get; }
    public SyntaxToken File { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal LoadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal LoadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context);
    internal LoadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    internal LoadDirectiveTriviaSyntax(ObjectReader reader);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_LoadKeyword();
    public SyntaxToken get_File();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public LoadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LocalDeclarationStatementSyntax : StatementSyntax {
    internal CSharpSyntaxNode modifiers;
    internal VariableDeclarationSyntax declaration;
    internal SyntaxToken semicolonToken;
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public VariableDeclarationSyntax Declaration { get; }
    public SyntaxToken SemicolonToken { get; }
    internal LocalDeclarationStatementSyntax(SyntaxKind kind, CSharpSyntaxNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal LocalDeclarationStatementSyntax(SyntaxKind kind, CSharpSyntaxNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal LocalDeclarationStatementSyntax(SyntaxKind kind, CSharpSyntaxNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    internal LocalDeclarationStatementSyntax(ObjectReader reader);
    public SyntaxList`1<SyntaxToken> get_Modifiers();
    public VariableDeclarationSyntax get_Declaration();
    public SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public LocalDeclarationStatementSyntax Update(SyntaxList`1<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LockStatementSyntax : StatementSyntax {
    internal SyntaxToken lockKeyword;
    internal SyntaxToken openParenToken;
    internal ExpressionSyntax expression;
    internal SyntaxToken closeParenToken;
    internal StatementSyntax statement;
    public SyntaxToken LockKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    internal LockStatementSyntax(SyntaxKind kind, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal LockStatementSyntax(SyntaxKind kind, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context);
    internal LockStatementSyntax(SyntaxKind kind, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    internal LockStatementSyntax(ObjectReader reader);
    public SyntaxToken get_LockKeyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public LockStatementSyntax Update(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MakeRefExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken keyword;
    internal SyntaxToken openParenToken;
    internal ExpressionSyntax expression;
    internal SyntaxToken closeParenToken;
    public SyntaxToken Keyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    internal MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context);
    internal MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    internal MakeRefExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_Keyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public MakeRefExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberAccessExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax expression;
    internal SyntaxToken operatorToken;
    internal SimpleNameSyntax name;
    public ExpressionSyntax Expression { get; }
    public SyntaxToken OperatorToken { get; }
    public SimpleNameSyntax Name { get; }
    internal MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name, SyntaxFactoryContext context);
    internal MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name);
    internal MemberAccessExpressionSyntax(ObjectReader reader);
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_OperatorToken();
    public SimpleNameSyntax get_Name();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public MemberAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberBindingExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken operatorToken;
    internal SimpleNameSyntax name;
    public SyntaxToken OperatorToken { get; }
    public SimpleNameSyntax Name { get; }
    internal MemberBindingExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, SimpleNameSyntax name, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal MemberBindingExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, SimpleNameSyntax name, SyntaxFactoryContext context);
    internal MemberBindingExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, SimpleNameSyntax name);
    internal MemberBindingExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_OperatorToken();
    public SimpleNameSyntax get_Name();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public MemberBindingExpressionSyntax Update(SyntaxToken operatorToken, SimpleNameSyntax name);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberCrefSyntax : CrefSyntax {
    internal MemberCrefSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal MemberCrefSyntax(SyntaxKind kind);
    protected MemberCrefSyntax(ObjectReader reader);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberDeclarationSyntax : CSharpSyntaxNode {
    internal MemberDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal MemberDeclarationSyntax(SyntaxKind kind);
    protected MemberDeclarationSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MethodDeclarationSyntax : BaseMethodDeclarationSyntax {
    internal CSharpSyntaxNode attributeLists;
    internal CSharpSyntaxNode modifiers;
    internal TypeSyntax returnType;
    internal ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    internal SyntaxToken identifier;
    internal TypeParameterListSyntax typeParameterList;
    internal ParameterListSyntax parameterList;
    internal CSharpSyntaxNode constraintClauses;
    internal BlockSyntax body;
    internal ArrowExpressionClauseSyntax expressionBody;
    internal SyntaxToken semicolonToken;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public TypeSyntax ReturnType { get; }
    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public ParameterListSyntax ParameterList { get; }
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public BlockSyntax Body { get; }
    public ArrowExpressionClauseSyntax ExpressionBody { get; }
    public SyntaxToken SemicolonToken { get; }
    internal MethodDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, CSharpSyntaxNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal MethodDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, CSharpSyntaxNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal MethodDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, CSharpSyntaxNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    internal MethodDeclarationSyntax(ObjectReader reader);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxList`1<SyntaxToken> get_Modifiers();
    public TypeSyntax get_ReturnType();
    public ExplicitInterfaceSpecifierSyntax get_ExplicitInterfaceSpecifier();
    public SyntaxToken get_Identifier();
    public TypeParameterListSyntax get_TypeParameterList();
    public virtual ParameterListSyntax get_ParameterList();
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public virtual BlockSyntax get_Body();
    public ArrowExpressionClauseSyntax get_ExpressionBody();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public MethodDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameColonSyntax : CSharpSyntaxNode {
    internal IdentifierNameSyntax name;
    internal SyntaxToken colonToken;
    public IdentifierNameSyntax Name { get; }
    public SyntaxToken ColonToken { get; }
    internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken, SyntaxFactoryContext context);
    internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken);
    internal NameColonSyntax(ObjectReader reader);
    public IdentifierNameSyntax get_Name();
    public SyntaxToken get_ColonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public NameColonSyntax Update(IdentifierNameSyntax name, SyntaxToken colonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameEqualsSyntax : CSharpSyntaxNode {
    internal IdentifierNameSyntax name;
    internal SyntaxToken equalsToken;
    public IdentifierNameSyntax Name { get; }
    public SyntaxToken EqualsToken { get; }
    internal NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken equalsToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken equalsToken, SyntaxFactoryContext context);
    internal NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken equalsToken);
    internal NameEqualsSyntax(ObjectReader reader);
    public IdentifierNameSyntax get_Name();
    public SyntaxToken get_EqualsToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public NameEqualsSyntax Update(IdentifierNameSyntax name, SyntaxToken equalsToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameMemberCrefSyntax : MemberCrefSyntax {
    internal TypeSyntax name;
    internal CrefParameterListSyntax parameters;
    public TypeSyntax Name { get; }
    public CrefParameterListSyntax Parameters { get; }
    internal NameMemberCrefSyntax(SyntaxKind kind, TypeSyntax name, CrefParameterListSyntax parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal NameMemberCrefSyntax(SyntaxKind kind, TypeSyntax name, CrefParameterListSyntax parameters, SyntaxFactoryContext context);
    internal NameMemberCrefSyntax(SyntaxKind kind, TypeSyntax name, CrefParameterListSyntax parameters);
    internal NameMemberCrefSyntax(ObjectReader reader);
    public TypeSyntax get_Name();
    public CrefParameterListSyntax get_Parameters();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public NameMemberCrefSyntax Update(TypeSyntax name, CrefParameterListSyntax parameters);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NamespaceDeclarationSyntax : MemberDeclarationSyntax {
    internal SyntaxToken namespaceKeyword;
    internal NameSyntax name;
    internal SyntaxToken openBraceToken;
    internal CSharpSyntaxNode externs;
    internal CSharpSyntaxNode usings;
    internal CSharpSyntaxNode members;
    internal SyntaxToken closeBraceToken;
    internal SyntaxToken semicolonToken;
    public SyntaxToken NamespaceKeyword { get; }
    public NameSyntax Name { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxList`1<ExternAliasDirectiveSyntax> Externs { get; }
    public SyntaxList`1<UsingDirectiveSyntax> Usings { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    public SyntaxToken CloseBraceToken { get; }
    public SyntaxToken SemicolonToken { get; }
    internal NamespaceDeclarationSyntax(SyntaxKind kind, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, CSharpSyntaxNode externs, CSharpSyntaxNode usings, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal NamespaceDeclarationSyntax(SyntaxKind kind, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, CSharpSyntaxNode externs, CSharpSyntaxNode usings, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal NamespaceDeclarationSyntax(SyntaxKind kind, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, CSharpSyntaxNode externs, CSharpSyntaxNode usings, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    internal NamespaceDeclarationSyntax(ObjectReader reader);
    public SyntaxToken get_NamespaceKeyword();
    public NameSyntax get_Name();
    public SyntaxToken get_OpenBraceToken();
    public SyntaxList`1<ExternAliasDirectiveSyntax> get_Externs();
    public SyntaxList`1<UsingDirectiveSyntax> get_Usings();
    public SyntaxList`1<MemberDeclarationSyntax> get_Members();
    public SyntaxToken get_CloseBraceToken();
    public SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public NamespaceDeclarationSyntax Update(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList`1<ExternAliasDirectiveSyntax> externs, SyntaxList`1<UsingDirectiveSyntax> usings, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameSyntax : TypeSyntax {
    internal NameSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal NameSyntax(SyntaxKind kind);
    protected NameSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NullableTypeSyntax : TypeSyntax {
    internal TypeSyntax elementType;
    internal SyntaxToken questionToken;
    public TypeSyntax ElementType { get; }
    public SyntaxToken QuestionToken { get; }
    internal NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken, SyntaxFactoryContext context);
    internal NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken);
    internal NullableTypeSyntax(ObjectReader reader);
    public TypeSyntax get_ElementType();
    public SyntaxToken get_QuestionToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public NullableTypeSyntax Update(TypeSyntax elementType, SyntaxToken questionToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ObjectCreationExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken newKeyword;
    internal TypeSyntax type;
    internal ArgumentListSyntax argumentList;
    internal InitializerExpressionSyntax initializer;
    public SyntaxToken NewKeyword { get; }
    public TypeSyntax Type { get; }
    public ArgumentListSyntax ArgumentList { get; }
    public InitializerExpressionSyntax Initializer { get; }
    internal ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer, SyntaxFactoryContext context);
    internal ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer);
    internal ObjectCreationExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_NewKeyword();
    public TypeSyntax get_Type();
    public ArgumentListSyntax get_ArgumentList();
    public InitializerExpressionSyntax get_Initializer();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OmittedArraySizeExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken omittedArraySizeExpressionToken;
    public SyntaxToken OmittedArraySizeExpressionToken { get; }
    internal OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken, SyntaxFactoryContext context);
    internal OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken);
    internal OmittedArraySizeExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_OmittedArraySizeExpressionToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public OmittedArraySizeExpressionSyntax Update(SyntaxToken omittedArraySizeExpressionToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OmittedTypeArgumentSyntax : TypeSyntax {
    internal SyntaxToken omittedTypeArgumentToken;
    public SyntaxToken OmittedTypeArgumentToken { get; }
    internal OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken, SyntaxFactoryContext context);
    internal OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken);
    internal OmittedTypeArgumentSyntax(ObjectReader reader);
    public SyntaxToken get_OmittedTypeArgumentToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public OmittedTypeArgumentSyntax Update(SyntaxToken omittedTypeArgumentToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorDeclarationSyntax : BaseMethodDeclarationSyntax {
    internal CSharpSyntaxNode attributeLists;
    internal CSharpSyntaxNode modifiers;
    internal TypeSyntax returnType;
    internal SyntaxToken operatorKeyword;
    internal SyntaxToken operatorToken;
    internal ParameterListSyntax parameterList;
    internal BlockSyntax body;
    internal ArrowExpressionClauseSyntax expressionBody;
    internal SyntaxToken semicolonToken;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public TypeSyntax ReturnType { get; }
    public SyntaxToken OperatorKeyword { get; }
    public SyntaxToken OperatorToken { get; }
    public ParameterListSyntax ParameterList { get; }
    public BlockSyntax Body { get; }
    public ArrowExpressionClauseSyntax ExpressionBody { get; }
    public SyntaxToken SemicolonToken { get; }
    internal OperatorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal OperatorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal OperatorDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    internal OperatorDeclarationSyntax(ObjectReader reader);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxList`1<SyntaxToken> get_Modifiers();
    public TypeSyntax get_ReturnType();
    public SyntaxToken get_OperatorKeyword();
    public SyntaxToken get_OperatorToken();
    public virtual ParameterListSyntax get_ParameterList();
    public virtual BlockSyntax get_Body();
    public ArrowExpressionClauseSyntax get_ExpressionBody();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public OperatorDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorMemberCrefSyntax : MemberCrefSyntax {
    internal SyntaxToken operatorKeyword;
    internal SyntaxToken operatorToken;
    internal CrefParameterListSyntax parameters;
    public SyntaxToken OperatorKeyword { get; }
    public SyntaxToken OperatorToken { get; }
    public CrefParameterListSyntax Parameters { get; }
    internal OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters, SyntaxFactoryContext context);
    internal OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters);
    internal OperatorMemberCrefSyntax(ObjectReader reader);
    public SyntaxToken get_OperatorKeyword();
    public SyntaxToken get_OperatorToken();
    public CrefParameterListSyntax get_Parameters();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public OperatorMemberCrefSyntax Update(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OrderByClauseSyntax : QueryClauseSyntax {
    internal SyntaxToken orderByKeyword;
    internal CSharpSyntaxNode orderings;
    public SyntaxToken OrderByKeyword { get; }
    public SeparatedSyntaxList`1<OrderingSyntax> Orderings { get; }
    internal OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, CSharpSyntaxNode orderings, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, CSharpSyntaxNode orderings, SyntaxFactoryContext context);
    internal OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, CSharpSyntaxNode orderings);
    internal OrderByClauseSyntax(ObjectReader reader);
    public SyntaxToken get_OrderByKeyword();
    public SeparatedSyntaxList`1<OrderingSyntax> get_Orderings();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public OrderByClauseSyntax Update(SyntaxToken orderByKeyword, SeparatedSyntaxList`1<OrderingSyntax> orderings);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OrderingSyntax : CSharpSyntaxNode {
    internal ExpressionSyntax expression;
    internal SyntaxToken ascendingOrDescendingKeyword;
    public ExpressionSyntax Expression { get; }
    public SyntaxToken AscendingOrDescendingKeyword { get; }
    internal OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword, SyntaxFactoryContext context);
    internal OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword);
    internal OrderingSyntax(ObjectReader reader);
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_AscendingOrDescendingKeyword();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public OrderingSyntax Update(ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax : BaseParameterListSyntax {
    internal SyntaxToken openParenToken;
    internal CSharpSyntaxNode parameters;
    internal SyntaxToken closeParenToken;
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxList`1<ParameterSyntax> Parameters { get; }
    public SyntaxToken CloseParenToken { get; }
    internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode parameters, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode parameters, SyntaxToken closeParenToken, SyntaxFactoryContext context);
    internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, CSharpSyntaxNode parameters, SyntaxToken closeParenToken);
    internal ParameterListSyntax(ObjectReader reader);
    public SyntaxToken get_OpenParenToken();
    public virtual SeparatedSyntaxList`1<ParameterSyntax> get_Parameters();
    public SyntaxToken get_CloseParenToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList`1<ParameterSyntax> parameters, SyntaxToken closeParenToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterSyntax : CSharpSyntaxNode {
    internal CSharpSyntaxNode attributeLists;
    internal CSharpSyntaxNode modifiers;
    internal TypeSyntax type;
    internal SyntaxToken identifier;
    internal EqualsValueClauseSyntax default;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken Identifier { get; }
    public EqualsValueClauseSyntax Default { get; }
    internal ParameterSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax default, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ParameterSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax default, SyntaxFactoryContext context);
    internal ParameterSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax default);
    internal ParameterSyntax(ObjectReader reader);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxList`1<SyntaxToken> get_Modifiers();
    public TypeSyntax get_Type();
    public SyntaxToken get_Identifier();
    public EqualsValueClauseSyntax get_Default();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ParameterSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax default);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken openParenToken;
    internal ExpressionSyntax expression;
    internal SyntaxToken closeParenToken;
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context);
    internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    internal ParenthesizedExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedLambdaExpressionSyntax : LambdaExpressionSyntax {
    internal SyntaxToken asyncKeyword;
    internal ParameterListSyntax parameterList;
    internal SyntaxToken arrowToken;
    internal CSharpSyntaxNode body;
    public SyntaxToken AsyncKeyword { get; }
    public ParameterListSyntax ParameterList { get; }
    public SyntaxToken ArrowToken { get; }
    public CSharpSyntaxNode Body { get; }
    internal ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body, SyntaxFactoryContext context);
    internal ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body);
    internal ParenthesizedLambdaExpressionSyntax(ObjectReader reader);
    public virtual SyntaxToken get_AsyncKeyword();
    public ParameterListSyntax get_ParameterList();
    public virtual SyntaxToken get_ArrowToken();
    public virtual CSharpSyntaxNode get_Body();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ParenthesizedLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PointerTypeSyntax : TypeSyntax {
    internal TypeSyntax elementType;
    internal SyntaxToken asteriskToken;
    public TypeSyntax ElementType { get; }
    public SyntaxToken AsteriskToken { get; }
    internal PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken, SyntaxFactoryContext context);
    internal PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken);
    internal PointerTypeSyntax(ObjectReader reader);
    public TypeSyntax get_ElementType();
    public SyntaxToken get_AsteriskToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public PointerTypeSyntax Update(TypeSyntax elementType, SyntaxToken asteriskToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PostfixUnaryExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax operand;
    internal SyntaxToken operatorToken;
    public ExpressionSyntax Operand { get; }
    public SyntaxToken OperatorToken { get; }
    internal PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken, SyntaxFactoryContext context);
    internal PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken);
    internal PostfixUnaryExpressionSyntax(ObjectReader reader);
    public ExpressionSyntax get_Operand();
    public SyntaxToken get_OperatorToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public PostfixUnaryExpressionSyntax Update(ExpressionSyntax operand, SyntaxToken operatorToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PragmaChecksumDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal SyntaxToken hashToken;
    internal SyntaxToken pragmaKeyword;
    internal SyntaxToken checksumKeyword;
    internal SyntaxToken file;
    internal SyntaxToken guid;
    internal SyntaxToken bytes;
    internal SyntaxToken endOfDirectiveToken;
    internal bool isActive;
    public SyntaxToken HashToken { get; }
    public SyntaxToken PragmaKeyword { get; }
    public SyntaxToken ChecksumKeyword { get; }
    public SyntaxToken File { get; }
    public SyntaxToken Guid { get; }
    public SyntaxToken Bytes { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal PragmaChecksumDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal PragmaChecksumDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context);
    internal PragmaChecksumDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive);
    internal PragmaChecksumDirectiveTriviaSyntax(ObjectReader reader);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_PragmaKeyword();
    public SyntaxToken get_ChecksumKeyword();
    public SyntaxToken get_File();
    public SyntaxToken get_Guid();
    public SyntaxToken get_Bytes();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public PragmaChecksumDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PragmaWarningDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal SyntaxToken hashToken;
    internal SyntaxToken pragmaKeyword;
    internal SyntaxToken warningKeyword;
    internal SyntaxToken disableOrRestoreKeyword;
    internal CSharpSyntaxNode errorCodes;
    internal SyntaxToken endOfDirectiveToken;
    internal bool isActive;
    public SyntaxToken HashToken { get; }
    public SyntaxToken PragmaKeyword { get; }
    public SyntaxToken WarningKeyword { get; }
    public SyntaxToken DisableOrRestoreKeyword { get; }
    public SeparatedSyntaxList`1<ExpressionSyntax> ErrorCodes { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal PragmaWarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, CSharpSyntaxNode errorCodes, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal PragmaWarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, CSharpSyntaxNode errorCodes, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context);
    internal PragmaWarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, CSharpSyntaxNode errorCodes, SyntaxToken endOfDirectiveToken, bool isActive);
    internal PragmaWarningDirectiveTriviaSyntax(ObjectReader reader);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_PragmaKeyword();
    public SyntaxToken get_WarningKeyword();
    public SyntaxToken get_DisableOrRestoreKeyword();
    public SeparatedSyntaxList`1<ExpressionSyntax> get_ErrorCodes();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public PragmaWarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList`1<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PredefinedTypeSyntax : TypeSyntax {
    internal SyntaxToken keyword;
    public SyntaxToken Keyword { get; }
    internal PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxFactoryContext context);
    internal PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword);
    internal PredefinedTypeSyntax(ObjectReader reader);
    public SyntaxToken get_Keyword();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public PredefinedTypeSyntax Update(SyntaxToken keyword);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PrefixUnaryExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken operatorToken;
    internal ExpressionSyntax operand;
    public SyntaxToken OperatorToken { get; }
    public ExpressionSyntax Operand { get; }
    internal PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand, SyntaxFactoryContext context);
    internal PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand);
    internal PrefixUnaryExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_OperatorToken();
    public ExpressionSyntax get_Operand();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public PrefixUnaryExpressionSyntax Update(SyntaxToken operatorToken, ExpressionSyntax operand);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PropertyDeclarationSyntax : BasePropertyDeclarationSyntax {
    internal CSharpSyntaxNode attributeLists;
    internal CSharpSyntaxNode modifiers;
    internal TypeSyntax type;
    internal ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    internal SyntaxToken identifier;
    internal AccessorListSyntax accessorList;
    internal ArrowExpressionClauseSyntax expressionBody;
    internal EqualsValueClauseSyntax initializer;
    internal SyntaxToken semicolonToken;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public TypeSyntax Type { get; }
    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }
    public SyntaxToken Identifier { get; }
    public AccessorListSyntax AccessorList { get; }
    public ArrowExpressionClauseSyntax ExpressionBody { get; }
    public EqualsValueClauseSyntax Initializer { get; }
    public SyntaxToken SemicolonToken { get; }
    internal PropertyDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal PropertyDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal PropertyDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken);
    internal PropertyDeclarationSyntax(ObjectReader reader);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxList`1<SyntaxToken> get_Modifiers();
    public virtual TypeSyntax get_Type();
    public virtual ExplicitInterfaceSpecifierSyntax get_ExplicitInterfaceSpecifier();
    public SyntaxToken get_Identifier();
    public virtual AccessorListSyntax get_AccessorList();
    public ArrowExpressionClauseSyntax get_ExpressionBody();
    public EqualsValueClauseSyntax get_Initializer();
    public SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public PropertyDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QualifiedCrefSyntax : CrefSyntax {
    internal TypeSyntax container;
    internal SyntaxToken dotToken;
    internal MemberCrefSyntax member;
    public TypeSyntax Container { get; }
    public SyntaxToken DotToken { get; }
    public MemberCrefSyntax Member { get; }
    internal QualifiedCrefSyntax(SyntaxKind kind, TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal QualifiedCrefSyntax(SyntaxKind kind, TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member, SyntaxFactoryContext context);
    internal QualifiedCrefSyntax(SyntaxKind kind, TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member);
    internal QualifiedCrefSyntax(ObjectReader reader);
    public TypeSyntax get_Container();
    public SyntaxToken get_DotToken();
    public MemberCrefSyntax get_Member();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public QualifiedCrefSyntax Update(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QualifiedNameSyntax : NameSyntax {
    internal NameSyntax left;
    internal SyntaxToken dotToken;
    internal SimpleNameSyntax right;
    public NameSyntax Left { get; }
    public SyntaxToken DotToken { get; }
    public SimpleNameSyntax Right { get; }
    internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right, SyntaxFactoryContext context);
    internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right);
    internal QualifiedNameSyntax(ObjectReader reader);
    public NameSyntax get_Left();
    public SyntaxToken get_DotToken();
    public SimpleNameSyntax get_Right();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public QualifiedNameSyntax Update(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QueryBodySyntax : CSharpSyntaxNode {
    internal CSharpSyntaxNode clauses;
    internal SelectOrGroupClauseSyntax selectOrGroup;
    internal QueryContinuationSyntax continuation;
    public SyntaxList`1<QueryClauseSyntax> Clauses { get; }
    public SelectOrGroupClauseSyntax SelectOrGroup { get; }
    public QueryContinuationSyntax Continuation { get; }
    internal QueryBodySyntax(SyntaxKind kind, CSharpSyntaxNode clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal QueryBodySyntax(SyntaxKind kind, CSharpSyntaxNode clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation, SyntaxFactoryContext context);
    internal QueryBodySyntax(SyntaxKind kind, CSharpSyntaxNode clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation);
    internal QueryBodySyntax(ObjectReader reader);
    public SyntaxList`1<QueryClauseSyntax> get_Clauses();
    public SelectOrGroupClauseSyntax get_SelectOrGroup();
    public QueryContinuationSyntax get_Continuation();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public QueryBodySyntax Update(SyntaxList`1<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QueryClauseSyntax : CSharpSyntaxNode {
    internal QueryClauseSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal QueryClauseSyntax(SyntaxKind kind);
    protected QueryClauseSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QueryContinuationSyntax : CSharpSyntaxNode {
    internal SyntaxToken intoKeyword;
    internal SyntaxToken identifier;
    internal QueryBodySyntax body;
    public SyntaxToken IntoKeyword { get; }
    public SyntaxToken Identifier { get; }
    public QueryBodySyntax Body { get; }
    internal QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body, SyntaxFactoryContext context);
    internal QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body);
    internal QueryContinuationSyntax(ObjectReader reader);
    public SyntaxToken get_IntoKeyword();
    public SyntaxToken get_Identifier();
    public QueryBodySyntax get_Body();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public QueryContinuationSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QueryExpressionSyntax : ExpressionSyntax {
    internal FromClauseSyntax fromClause;
    internal QueryBodySyntax body;
    public FromClauseSyntax FromClause { get; }
    public QueryBodySyntax Body { get; }
    internal QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body, SyntaxFactoryContext context);
    internal QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body);
    internal QueryExpressionSyntax(ObjectReader reader);
    public FromClauseSyntax get_FromClause();
    public QueryBodySyntax get_Body();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public QueryExpressionSyntax Update(FromClauseSyntax fromClause, QueryBodySyntax body);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ReferenceDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal SyntaxToken hashToken;
    internal SyntaxToken referenceKeyword;
    internal SyntaxToken file;
    internal SyntaxToken endOfDirectiveToken;
    internal bool isActive;
    public SyntaxToken HashToken { get; }
    public SyntaxToken ReferenceKeyword { get; }
    public SyntaxToken File { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal ReferenceDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ReferenceDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context);
    internal ReferenceDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    internal ReferenceDirectiveTriviaSyntax(ObjectReader reader);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_ReferenceKeyword();
    public SyntaxToken get_File();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ReferenceDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefTypeExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken keyword;
    internal SyntaxToken openParenToken;
    internal ExpressionSyntax expression;
    internal SyntaxToken closeParenToken;
    public SyntaxToken Keyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    internal RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context);
    internal RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    internal RefTypeExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_Keyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public RefTypeExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefValueExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken keyword;
    internal SyntaxToken openParenToken;
    internal ExpressionSyntax expression;
    internal SyntaxToken comma;
    internal TypeSyntax type;
    internal SyntaxToken closeParenToken;
    public SyntaxToken Keyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken Comma { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken CloseParenToken { get; }
    internal RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context);
    internal RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken);
    internal RefValueExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_Keyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_Comma();
    public TypeSyntax get_Type();
    public SyntaxToken get_CloseParenToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public RefValueExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RegionDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal SyntaxToken hashToken;
    internal SyntaxToken regionKeyword;
    internal SyntaxToken endOfDirectiveToken;
    internal bool isActive;
    public SyntaxToken HashToken { get; }
    public SyntaxToken RegionKeyword { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal RegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal RegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context);
    internal RegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    internal RegionDirectiveTriviaSyntax(ObjectReader reader);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_RegionKeyword();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public RegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ReturnStatementSyntax : StatementSyntax {
    internal SyntaxToken returnKeyword;
    internal ExpressionSyntax expression;
    internal SyntaxToken semicolonToken;
    public SyntaxToken ReturnKeyword { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken SemicolonToken { get; }
    internal ReturnStatementSyntax(SyntaxKind kind, SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ReturnStatementSyntax(SyntaxKind kind, SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal ReturnStatementSyntax(SyntaxKind kind, SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    internal ReturnStatementSyntax(ObjectReader reader);
    public SyntaxToken get_ReturnKeyword();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ReturnStatementSyntax Update(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SelectClauseSyntax : SelectOrGroupClauseSyntax {
    internal SyntaxToken selectKeyword;
    internal ExpressionSyntax expression;
    public SyntaxToken SelectKeyword { get; }
    public ExpressionSyntax Expression { get; }
    internal SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression, SyntaxFactoryContext context);
    internal SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression);
    internal SelectClauseSyntax(ObjectReader reader);
    public SyntaxToken get_SelectKeyword();
    public ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public SelectClauseSyntax Update(SyntaxToken selectKeyword, ExpressionSyntax expression);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SelectOrGroupClauseSyntax : CSharpSyntaxNode {
    internal SelectOrGroupClauseSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal SelectOrGroupClauseSyntax(SyntaxKind kind);
    protected SelectOrGroupClauseSyntax(ObjectReader reader);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SeparatedSyntaxList`1 : ValueType {
    private SyntaxList`1<CSharpSyntaxNode> _list;
    internal CSharpSyntaxNode Node { get; }
    public int Count { get; }
    public int SeparatorCount { get; }
    public TNode Item { get; }
    internal SeparatedSyntaxList`1(SyntaxList`1<CSharpSyntaxNode> list);
    [ConditionalAttribute("DEBUG")]
private static void Validate(SyntaxList`1<CSharpSyntaxNode> list);
    internal CSharpSyntaxNode get_Node();
    public int get_Count();
    public int get_SeparatorCount();
    public TNode get_Item(int index);
    public SyntaxToken GetSeparator(int index);
    public SyntaxList`1<CSharpSyntaxNode> GetWithSeparators();
    public static bool op_Equality(SeparatedSyntaxList`1<TNode> left, SeparatedSyntaxList`1<TNode> right);
    public static bool op_Inequality(SeparatedSyntaxList`1<TNode> left, SeparatedSyntaxList`1<TNode> right);
    public sealed virtual bool Equals(SeparatedSyntaxList`1<TNode> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SeparatedSyntaxListBuilder`1 : ValueType {
    private SyntaxListBuilder _builder;
    public bool IsNull { get; }
    public int Count { get; }
    public CSharpSyntaxNode Item { get; public set; }
    internal SyntaxListBuilder UnderlyingBuilder { get; }
    public SeparatedSyntaxListBuilder`1(int size);
    internal SeparatedSyntaxListBuilder`1(SyntaxListBuilder builder);
    public static SeparatedSyntaxListBuilder`1<TNode> Create();
    public bool get_IsNull();
    public int get_Count();
    public CSharpSyntaxNode get_Item(int index);
    public void set_Item(int index, CSharpSyntaxNode value);
    public void Clear();
    public SeparatedSyntaxListBuilder`1<TNode> Add(TNode node);
    public void AddSeparator(SyntaxToken separatorToken);
    public void AddRange(TNode[] items, int offset, int length);
    public void AddRange(SeparatedSyntaxList`1<TNode> nodes);
    public bool Any(SyntaxKind kind);
    public SeparatedSyntaxList`1<TNode> ToList();
    internal SyntaxListBuilder get_UnderlyingBuilder();
    public static SeparatedSyntaxList`1<TNode> op_Implicit(SeparatedSyntaxListBuilder`1<TNode> builder);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ShebangDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal SyntaxToken hashToken;
    internal SyntaxToken exclamationToken;
    internal SyntaxToken endOfDirectiveToken;
    internal bool isActive;
    public SyntaxToken HashToken { get; }
    public SyntaxToken ExclamationToken { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal ShebangDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ShebangDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context);
    internal ShebangDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive);
    internal ShebangDirectiveTriviaSyntax(ObjectReader reader);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_ExclamationToken();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ShebangDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleBaseTypeSyntax : BaseTypeSyntax {
    internal TypeSyntax type;
    public TypeSyntax Type { get; }
    internal SimpleBaseTypeSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal SimpleBaseTypeSyntax(SyntaxKind kind, TypeSyntax type, SyntaxFactoryContext context);
    internal SimpleBaseTypeSyntax(SyntaxKind kind, TypeSyntax type);
    internal SimpleBaseTypeSyntax(ObjectReader reader);
    public virtual TypeSyntax get_Type();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public SimpleBaseTypeSyntax Update(TypeSyntax type);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleLambdaExpressionSyntax : LambdaExpressionSyntax {
    internal SyntaxToken asyncKeyword;
    internal ParameterSyntax parameter;
    internal SyntaxToken arrowToken;
    internal CSharpSyntaxNode body;
    public SyntaxToken AsyncKeyword { get; }
    public ParameterSyntax Parameter { get; }
    public SyntaxToken ArrowToken { get; }
    public CSharpSyntaxNode Body { get; }
    internal SimpleLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal SimpleLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body, SyntaxFactoryContext context);
    internal SimpleLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body);
    internal SimpleLambdaExpressionSyntax(ObjectReader reader);
    public virtual SyntaxToken get_AsyncKeyword();
    public ParameterSyntax get_Parameter();
    public virtual SyntaxToken get_ArrowToken();
    public virtual CSharpSyntaxNode get_Body();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public SimpleLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleNameSyntax : NameSyntax {
    public SyntaxToken Identifier { get; }
    internal SimpleNameSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal SimpleNameSyntax(SyntaxKind kind);
    protected SimpleNameSyntax(ObjectReader reader);
    public abstract virtual SyntaxToken get_Identifier();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SizeOfExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken keyword;
    internal SyntaxToken openParenToken;
    internal TypeSyntax type;
    internal SyntaxToken closeParenToken;
    public SyntaxToken Keyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken CloseParenToken { get; }
    internal SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context);
    internal SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    internal SizeOfExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_Keyword();
    public SyntaxToken get_OpenParenToken();
    public TypeSyntax get_Type();
    public SyntaxToken get_CloseParenToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public SizeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SkippedTokensTriviaSyntax : StructuredTriviaSyntax {
    internal CSharpSyntaxNode tokens;
    public SyntaxList`1<SyntaxToken> Tokens { get; }
    internal SkippedTokensTriviaSyntax(SyntaxKind kind, CSharpSyntaxNode tokens, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal SkippedTokensTriviaSyntax(SyntaxKind kind, CSharpSyntaxNode tokens, SyntaxFactoryContext context);
    internal SkippedTokensTriviaSyntax(SyntaxKind kind, CSharpSyntaxNode tokens);
    internal SkippedTokensTriviaSyntax(ObjectReader reader);
    public SyntaxList`1<SyntaxToken> get_Tokens();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public SkippedTokensTriviaSyntax Update(SyntaxList`1<SyntaxToken> tokens);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow : object {
    public static char InvalidCharacter;
    private static int DefaultWindowLength;
    private SourceText _text;
    private int _basis;
    private int _offset;
    private int _textEnd;
    private Char[] _characterWindow;
    private int _characterWindowCount;
    private int _lexemeStart;
    private StringTable _strings;
    private static ObjectPool`1<Char[]> s_windowPool;
    public SourceText Text { get; }
    public int Position { get; }
    public int Offset { get; }
    public Char[] CharacterWindow { get; }
    public int LexemeRelativeStart { get; }
    public int CharacterWindowCount { get; }
    public int LexemeStartPosition { get; }
    public int Width { get; }
    public SlidingTextWindow(SourceText text);
    private static SlidingTextWindow();
    public sealed virtual void Dispose();
    public SourceText get_Text();
    public int get_Position();
    public int get_Offset();
    public Char[] get_CharacterWindow();
    public int get_LexemeRelativeStart();
    public int get_CharacterWindowCount();
    public int get_LexemeStartPosition();
    public int get_Width();
    public void Start();
    public void Reset(int position);
    private bool MoreChars();
    internal bool IsReallyAtEnd();
    public void AdvanceChar();
    public void AdvanceChar(int n);
    public char NextChar();
    public char PeekChar();
    public char PeekChar(int delta);
    public bool IsUnicodeEscape();
    public char PeekCharOrUnicodeEscape(Char& surrogateCharacter);
    public char PeekUnicodeEscape(Char& surrogateCharacter);
    public char NextCharOrUnicodeEscape(Char& surrogateCharacter, SyntaxDiagnosticInfo& info);
    public char NextUnicodeEscape(Char& surrogateCharacter, SyntaxDiagnosticInfo& info);
    private char ScanUnicodeEscape(bool peek, Char& surrogateCharacter, SyntaxDiagnosticInfo& info);
    public bool TryScanXmlEntity(Char& ch, Char& surrogate);
    private bool AdvanceIfMatches(string desired);
    private SyntaxDiagnosticInfo CreateIllegalEscapeDiagnostic(int start);
    public string Intern(StringBuilder text);
    public string Intern(Char[] array, int start, int length);
    public string GetInternedText();
    public string GetText(bool intern);
    public string GetText(int position, int length, bool intern);
    internal static char GetCharsFromUtf32(UInt32 codepoint, Char& lowSurrogate);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StackAllocArrayCreationExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken stackAllocKeyword;
    internal TypeSyntax type;
    public SyntaxToken StackAllocKeyword { get; }
    public TypeSyntax Type { get; }
    internal StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type, SyntaxFactoryContext context);
    internal StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type);
    internal StackAllocArrayCreationExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_StackAllocKeyword();
    public TypeSyntax get_Type();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public StackAllocArrayCreationExpressionSyntax Update(SyntaxToken stackAllocKeyword, TypeSyntax type);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax : CSharpSyntaxNode {
    internal StatementSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal StatementSyntax(SyntaxKind kind);
    protected StatementSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StructDeclarationSyntax : TypeDeclarationSyntax {
    internal CSharpSyntaxNode attributeLists;
    internal CSharpSyntaxNode modifiers;
    internal SyntaxToken keyword;
    internal SyntaxToken identifier;
    internal TypeParameterListSyntax typeParameterList;
    internal BaseListSyntax baseList;
    internal CSharpSyntaxNode constraintClauses;
    internal SyntaxToken openBraceToken;
    internal CSharpSyntaxNode members;
    internal SyntaxToken closeBraceToken;
    internal SyntaxToken semicolonToken;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxList`1<SyntaxToken> Modifiers { get; }
    public SyntaxToken Keyword { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public BaseListSyntax BaseList { get; }
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    public SyntaxToken CloseBraceToken { get; }
    public SyntaxToken SemicolonToken { get; }
    internal StructDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, CSharpSyntaxNode constraintClauses, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal StructDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, CSharpSyntaxNode constraintClauses, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal StructDeclarationSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, CSharpSyntaxNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, CSharpSyntaxNode constraintClauses, SyntaxToken openBraceToken, CSharpSyntaxNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    internal StructDeclarationSyntax(ObjectReader reader);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxList`1<SyntaxToken> get_Modifiers();
    public virtual SyntaxToken get_Keyword();
    public virtual SyntaxToken get_Identifier();
    public virtual TypeParameterListSyntax get_TypeParameterList();
    public virtual BaseListSyntax get_BaseList();
    public virtual SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public virtual SyntaxToken get_OpenBraceToken();
    public virtual SyntaxList`1<MemberDeclarationSyntax> get_Members();
    public virtual SyntaxToken get_CloseBraceToken();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public StructDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StructuredTriviaSyntax : CSharpSyntaxNode {
    internal StructuredTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal StructuredTriviaSyntax(ObjectReader reader);
    private void Initialize();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchLabelSyntax : CSharpSyntaxNode {
    public SyntaxToken Keyword { get; }
    public SyntaxToken ColonToken { get; }
    internal SwitchLabelSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal SwitchLabelSyntax(SyntaxKind kind);
    protected SwitchLabelSyntax(ObjectReader reader);
    public abstract virtual SyntaxToken get_Keyword();
    public abstract virtual SyntaxToken get_ColonToken();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchSectionSyntax : CSharpSyntaxNode {
    internal CSharpSyntaxNode labels;
    internal CSharpSyntaxNode statements;
    public SyntaxList`1<SwitchLabelSyntax> Labels { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    internal SwitchSectionSyntax(SyntaxKind kind, CSharpSyntaxNode labels, CSharpSyntaxNode statements, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal SwitchSectionSyntax(SyntaxKind kind, CSharpSyntaxNode labels, CSharpSyntaxNode statements, SyntaxFactoryContext context);
    internal SwitchSectionSyntax(SyntaxKind kind, CSharpSyntaxNode labels, CSharpSyntaxNode statements);
    internal SwitchSectionSyntax(ObjectReader reader);
    public SyntaxList`1<SwitchLabelSyntax> get_Labels();
    public SyntaxList`1<StatementSyntax> get_Statements();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public SwitchSectionSyntax Update(SyntaxList`1<SwitchLabelSyntax> labels, SyntaxList`1<StatementSyntax> statements);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax : StatementSyntax {
    internal SyntaxToken switchKeyword;
    internal SyntaxToken openParenToken;
    internal ExpressionSyntax expression;
    internal SyntaxToken closeParenToken;
    internal SyntaxToken openBraceToken;
    internal CSharpSyntaxNode sections;
    internal SyntaxToken closeBraceToken;
    public SyntaxToken SwitchKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxList`1<SwitchSectionSyntax> Sections { get; }
    public SyntaxToken CloseBraceToken { get; }
    internal SwitchStatementSyntax(SyntaxKind kind, SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, CSharpSyntaxNode sections, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal SwitchStatementSyntax(SyntaxKind kind, SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, CSharpSyntaxNode sections, SyntaxToken closeBraceToken, SyntaxFactoryContext context);
    internal SwitchStatementSyntax(SyntaxKind kind, SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, CSharpSyntaxNode sections, SyntaxToken closeBraceToken);
    internal SwitchStatementSyntax(ObjectReader reader);
    public SyntaxToken get_SwitchKeyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    public SyntaxToken get_OpenBraceToken();
    public SyntaxList`1<SwitchSectionSyntax> get_Sections();
    public SyntaxToken get_CloseBraceToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public SwitchStatementSyntax Update(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList`1<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxDiagnosticInfoList : ValueType {
    private GreenNode _node;
    internal SyntaxDiagnosticInfoList(GreenNode node);
    public Enumerator GetEnumerator();
    internal bool Any(Func`2<DiagnosticInfo, bool> predicate);
}
internal static class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory : object {
    private static string CrLf;
    internal static SyntaxTrivia CarriageReturnLineFeed;
    internal static SyntaxTrivia LineFeed;
    internal static SyntaxTrivia CarriageReturn;
    internal static SyntaxTrivia Space;
    internal static SyntaxTrivia Tab;
    internal static SyntaxTrivia ElasticCarriageReturnLineFeed;
    internal static SyntaxTrivia ElasticLineFeed;
    internal static SyntaxTrivia ElasticCarriageReturn;
    internal static SyntaxTrivia ElasticSpace;
    internal static SyntaxTrivia ElasticTab;
    internal static SyntaxTrivia ElasticZeroSpace;
    private static SyntaxToken s_xmlCarriageReturnLineFeed;
    private static SyntaxToken XmlCarriageReturnLineFeed { get; }
    private static SyntaxFactory();
    private static SyntaxToken get_XmlCarriageReturnLineFeed();
    internal static SyntaxTrivia EndOfLine(string text, bool elastic);
    internal static SyntaxTrivia Whitespace(string text, bool elastic);
    internal static SyntaxTrivia Comment(string text);
    internal static SyntaxTrivia DisabledText(string text);
    internal static SyntaxTrivia PreprocessingMessage(string text);
    public static SyntaxToken Token(SyntaxKind kind);
    internal static SyntaxToken Token(CSharpSyntaxNode leading, SyntaxKind kind, CSharpSyntaxNode trailing);
    internal static SyntaxToken Token(CSharpSyntaxNode leading, SyntaxKind kind, string text, string valueText, CSharpSyntaxNode trailing);
    internal static SyntaxToken MissingToken(SyntaxKind kind);
    internal static SyntaxToken MissingToken(CSharpSyntaxNode leading, SyntaxKind kind, CSharpSyntaxNode trailing);
    internal static SyntaxToken Identifier(string text);
    internal static SyntaxToken Identifier(CSharpSyntaxNode leading, string text, CSharpSyntaxNode trailing);
    internal static SyntaxToken Identifier(SyntaxKind contextualKind, CSharpSyntaxNode leading, string text, string valueText, CSharpSyntaxNode trailing);
    internal static SyntaxToken Literal(CSharpSyntaxNode leading, string text, int value, CSharpSyntaxNode trailing);
    internal static SyntaxToken Literal(CSharpSyntaxNode leading, string text, UInt32 value, CSharpSyntaxNode trailing);
    internal static SyntaxToken Literal(CSharpSyntaxNode leading, string text, long value, CSharpSyntaxNode trailing);
    internal static SyntaxToken Literal(CSharpSyntaxNode leading, string text, ulong value, CSharpSyntaxNode trailing);
    internal static SyntaxToken Literal(CSharpSyntaxNode leading, string text, float value, CSharpSyntaxNode trailing);
    internal static SyntaxToken Literal(CSharpSyntaxNode leading, string text, double value, CSharpSyntaxNode trailing);
    internal static SyntaxToken Literal(CSharpSyntaxNode leading, string text, decimal value, CSharpSyntaxNode trailing);
    internal static SyntaxToken Literal(CSharpSyntaxNode leading, string text, string value, CSharpSyntaxNode trailing);
    internal static SyntaxToken Literal(CSharpSyntaxNode leading, string text, SyntaxKind kind, string value, CSharpSyntaxNode trailing);
    internal static SyntaxToken Literal(CSharpSyntaxNode leading, string text, char value, CSharpSyntaxNode trailing);
    internal static SyntaxToken BadToken(CSharpSyntaxNode leading, string text, CSharpSyntaxNode trailing);
    internal static SyntaxToken XmlTextLiteral(CSharpSyntaxNode leading, string text, string value, CSharpSyntaxNode trailing);
    internal static SyntaxToken XmlTextNewLine(CSharpSyntaxNode leading, string text, string value, CSharpSyntaxNode trailing);
    internal static SyntaxToken XmlTextNewLine(string text);
    internal static SyntaxToken XmlEntity(CSharpSyntaxNode leading, string text, string value, CSharpSyntaxNode trailing);
    internal static SyntaxTrivia DocumentationCommentExteriorTrivia(string text);
    public static SyntaxList`1<TNode> List();
    public static SyntaxList`1<TNode> List(TNode node);
    public static SyntaxList`1<TNode> List(TNode node0, TNode node1);
    internal static CSharpSyntaxNode ListNode(CSharpSyntaxNode node0, CSharpSyntaxNode node1);
    public static SyntaxList`1<TNode> List(TNode node0, TNode node1, TNode node2);
    internal static CSharpSyntaxNode ListNode(CSharpSyntaxNode node0, CSharpSyntaxNode node1, CSharpSyntaxNode node2);
    public static SyntaxList`1<TNode> List(TNode[] nodes);
    internal static CSharpSyntaxNode ListNode(ArrayElement`1[] nodes);
    public static SeparatedSyntaxList`1<TNode> SeparatedList(TNode node);
    public static SeparatedSyntaxList`1<TNode> SeparatedList(SyntaxToken token);
    public static SeparatedSyntaxList`1<TNode> SeparatedList(TNode node1, SyntaxToken token, TNode node2);
    public static SeparatedSyntaxList`1<TNode> SeparatedList(CSharpSyntaxNode[] nodes);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory/<GetWellKnownTrivia>d__56")]
internal static IEnumerable`1<SyntaxTrivia> GetWellKnownTrivia();
    internal static IEnumerable`1<SyntaxToken> GetWellKnownTokens();
    public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier);
    public static QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right);
    public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList);
    public static TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, SeparatedSyntaxList`1<TypeSyntax> arguments, SyntaxToken greaterThanToken);
    public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name);
    public static PredefinedTypeSyntax PredefinedType(SyntaxToken keyword);
    public static ArrayTypeSyntax ArrayType(TypeSyntax elementType, SyntaxList`1<ArrayRankSpecifierSyntax> rankSpecifiers);
    public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, SeparatedSyntaxList`1<ExpressionSyntax> sizes, SyntaxToken closeBracketToken);
    public static PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken);
    public static NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken);
    public static OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken);
    public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand);
    public static AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, ExpressionSyntax expression);
    public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken);
    public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name);
    public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull);
    public static MemberBindingExpressionSyntax MemberBindingExpression(SyntaxToken operatorToken, SimpleNameSyntax name);
    public static ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList);
    public static ImplicitElementAccessSyntax ImplicitElementAccess(BracketedArgumentListSyntax argumentList);
    public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse);
    public static ThisExpressionSyntax ThisExpression(SyntaxToken token);
    public static BaseExpressionSyntax BaseExpression(SyntaxToken token);
    public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token);
    public static MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public static RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public static RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken);
    public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public static DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    public static TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    public static SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList);
    public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList);
    public static ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList`1<ArgumentSyntax> arguments, SyntaxToken closeParenToken);
    public static BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, SeparatedSyntaxList`1<ArgumentSyntax> arguments, SyntaxToken closeBracketToken);
    public static ArgumentSyntax Argument(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression);
    public static NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken);
    public static CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression);
    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body);
    public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body);
    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body);
    public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, SeparatedSyntaxList`1<ExpressionSyntax> expressions, SyntaxToken closeBraceToken);
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer);
    public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax nameEquals, ExpressionSyntax expression);
    public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList`1<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken);
    public static ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer);
    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxList`1<SyntaxToken> commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer);
    public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type);
    public static QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body);
    public static QueryBodySyntax QueryBody(SyntaxList`1<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation);
    public static FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression);
    public static LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression);
    public static JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into);
    public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier);
    public static WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition);
    public static OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, SeparatedSyntaxList`1<OrderingSyntax> orderings);
    public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword);
    public static SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression);
    public static GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression);
    public static QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body);
    public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken);
    public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList`1<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken);
    public static InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken);
    public static InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken);
    public static InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExpressionSyntax value);
    public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken);
    public static GlobalStatementSyntax GlobalStatement(StatementSyntax statement);
    public static BlockSyntax Block(SyntaxToken openBraceToken, SyntaxList`1<StatementSyntax> statements, SyntaxToken closeBraceToken);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxList`1<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SeparatedSyntaxList`1<VariableDeclaratorSyntax> variables);
    public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer);
    public static EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, ExpressionSyntax value);
    public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken semicolonToken);
    public static EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken);
    public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement);
    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    public static BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken);
    public static ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken);
    public static ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    public static ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    public static YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    public static WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement);
    public static DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken);
    public static ForStatementSyntax ForStatement(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList`1<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList`1<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement);
    public static ForEachStatementSyntax ForEachStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    public static UsingStatementSyntax UsingStatement(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    public static FixedStatementSyntax FixedStatement(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement);
    public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block);
    public static UnsafeStatementSyntax UnsafeStatement(SyntaxToken unsafeKeyword, BlockSyntax block);
    public static LockStatementSyntax LockStatement(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    public static IfStatementSyntax IfStatement(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax else);
    public static ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement);
    public static SwitchStatementSyntax SwitchStatement(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList`1<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken);
    public static SwitchSectionSyntax SwitchSection(SyntaxList`1<SwitchLabelSyntax> labels, SyntaxList`1<StatementSyntax> statements);
    public static CaseSwitchLabelSyntax CaseSwitchLabel(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken);
    public static DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken keyword, SyntaxToken colonToken);
    public static TryStatementSyntax TryStatement(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList`1<CatchClauseSyntax> catches, FinallyClauseSyntax finally);
    public static CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block);
    public static CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken);
    public static CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken);
    public static FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block);
    public static CompilationUnitSyntax CompilationUnit(SyntaxList`1<ExternAliasDirectiveSyntax> externs, SyntaxList`1<UsingDirectiveSyntax> usings, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken);
    public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken);
    public static UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken);
    public static NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList`1<ExternAliasDirectiveSyntax> externs, SyntaxList`1<UsingDirectiveSyntax> usings, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public static AttributeListSyntax AttributeList(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList`1<AttributeSyntax> attributes, SyntaxToken closeBracketToken);
    public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken);
    public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax argumentList);
    public static AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList`1<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken);
    public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression);
    public static NameEqualsSyntax NameEquals(IdentifierNameSyntax name, SyntaxToken equalsToken);
    public static TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, SeparatedSyntaxList`1<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken);
    public static TypeParameterSyntax TypeParameter(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier);
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public static StructDeclarationSyntax StructDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public static EnumDeclarationSyntax EnumDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList`1<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue);
    public static BaseListSyntax BaseList(SyntaxToken colonToken, SeparatedSyntaxList`1<BaseTypeSyntax> types);
    public static SimpleBaseTypeSyntax SimpleBaseType(TypeSyntax type);
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList`1<TypeParameterConstraintSyntax> constraints);
    public static ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken);
    public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword);
    public static TypeConstraintSyntax TypeConstraint(TypeSyntax type);
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken);
    public static MethodDeclarationSyntax MethodDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken);
    public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList);
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken);
    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken);
    public static ArrowExpressionClauseSyntax ArrowExpressionClause(SyntaxToken arrowToken, ExpressionSyntax expression);
    public static EventDeclarationSyntax EventDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList);
    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public static AccessorListSyntax AccessorList(SyntaxToken openBraceToken, SyntaxList`1<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken);
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken);
    public static ParameterListSyntax ParameterList(SyntaxToken openParenToken, SeparatedSyntaxList`1<ParameterSyntax> parameters, SyntaxToken closeParenToken);
    public static BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList`1<ParameterSyntax> parameters, SyntaxToken closeBracketToken);
    public static ParameterSyntax Parameter(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax default);
    public static IncompleteMemberSyntax IncompleteMember(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<SyntaxToken> modifiers, TypeSyntax type);
    public static SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxList`1<SyntaxToken> tokens);
    public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, SyntaxList`1<XmlNodeSyntax> content, SyntaxToken endOfComment);
    public static TypeCrefSyntax TypeCref(TypeSyntax type);
    public static QualifiedCrefSyntax QualifiedCref(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member);
    public static NameMemberCrefSyntax NameMemberCref(TypeSyntax name, CrefParameterListSyntax parameters);
    public static IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters);
    public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters);
    public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters);
    public static CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, SeparatedSyntaxList`1<CrefParameterSyntax> parameters, SyntaxToken closeParenToken);
    public static CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList`1<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken);
    public static CrefParameterSyntax CrefParameter(SyntaxToken refOrOutKeyword, TypeSyntax type);
    public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, SyntaxList`1<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag);
    public static XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList`1<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken);
    public static XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken);
    public static XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList`1<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken);
    public static XmlNameSyntax XmlName(XmlPrefixSyntax prefix, SyntaxToken localName);
    public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken);
    public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxList`1<SyntaxToken> textTokens, SyntaxToken endQuoteToken);
    public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken);
    public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken);
    public static XmlTextSyntax XmlText(SyntaxList`1<SyntaxToken> textTokens);
    public static XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, SyntaxList`1<SyntaxToken> textTokens, SyntaxToken endCDataToken);
    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxList`1<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken);
    public static XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxList`1<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken);
    public static IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue);
    public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue);
    public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken);
    public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public static BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive);
    public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive);
    public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive);
    public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList`1<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive);
    public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive);
    public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive);
    internal static IEnumerable`1<Type> GetNodeTypes();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactoryContext : object {
    internal bool IsInAsync;
    internal int QueryDepth;
    internal bool IsInQuery { get; }
    internal bool get_IsInQuery();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFirstTokenReplacer : CSharpSyntaxRewriter {
    private SyntaxToken _oldToken;
    private SyntaxToken _newToken;
    private int _diagnosticOffsetDelta;
    private bool _foundOldToken;
    private SyntaxFirstTokenReplacer(SyntaxToken oldToken, SyntaxToken newToken, int diagnosticOffsetDelta);
    internal static TRoot Replace(TRoot root, SyntaxToken oldToken, SyntaxToken newToken, int diagnosticOffsetDelta);
    public virtual CSharpSyntaxNode Visit(CSharpSyntaxNode node);
    private static TSyntax UpdateDiagnosticOffset(TSyntax node, int diagnosticOffsetDelta);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxLastTokenReplacer : CSharpSyntaxRewriter {
    private SyntaxToken _oldToken;
    private SyntaxToken _newToken;
    private int _count;
    private bool _found;
    private SyntaxLastTokenReplacer(SyntaxToken oldToken, SyntaxToken newToken);
    internal static TRoot Replace(TRoot root, SyntaxToken newToken);
    private static int CountNonNullSlots(CSharpSyntaxNode node);
    public virtual CSharpSyntaxNode Visit(CSharpSyntaxNode node);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxList : CSharpSyntaxNode {
    internal SyntaxList(ObjectReader reader);
    internal static CSharpSyntaxNode List(CSharpSyntaxNode child);
    internal static WithTwoChildren List(CSharpSyntaxNode child0, CSharpSyntaxNode child1);
    internal static WithThreeChildren List(CSharpSyntaxNode child0, CSharpSyntaxNode child1, CSharpSyntaxNode child2);
    internal static CSharpSyntaxNode List(CSharpSyntaxNode[] nodes);
    internal static CSharpSyntaxNode List(CSharpSyntaxNode[] nodes, int count);
    internal static SyntaxList List(ArrayElement`1[] children);
    internal static CSharpSyntaxNode List(SyntaxListBuilder builder);
    internal abstract virtual void CopyTo(ArrayElement`1[] array, int offset);
    internal static CSharpSyntaxNode Concat(CSharpSyntaxNode left, CSharpSyntaxNode right);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxList`1 : ValueType {
    private CSharpSyntaxNode _node;
    internal CSharpSyntaxNode Node { get; }
    public int Count { get; }
    public TNode Item { get; }
    private TNode[] Nodes { get; }
    internal SyntaxList`1(CSharpSyntaxNode node);
    internal CSharpSyntaxNode get_Node();
    public int get_Count();
    public TNode get_Item(int index);
    public bool Any();
    public bool Any(SyntaxKind kind);
    private TNode[] get_Nodes();
    public Enumerator<TNode> GetEnumerator();
    internal void CopyTo(int offset, ArrayElement`1[] array, int arrayOffset, int count);
    public static bool op_Equality(SyntaxList`1<TNode> left, SyntaxList`1<TNode> right);
    public static bool op_Inequality(SyntaxList`1<TNode> left, SyntaxList`1<TNode> right);
    public sealed virtual bool Equals(SyntaxList`1<TNode> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public SeparatedSyntaxList`1<TOther> AsSeparatedList();
    public static SyntaxList`1<TNode> op_Implicit(TNode node);
    public static SyntaxList`1<TNode> op_Implicit(SyntaxList`1<CSharpSyntaxNode> nodes);
    public static SyntaxList`1<CSharpSyntaxNode> op_Implicit(SyntaxList`1<TNode> nodes);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxListBuilder : object {
    private ArrayElement`1[] _nodes;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; private set; }
    public CSharpSyntaxNode Item { get; public set; }
    public SyntaxListBuilder(int size);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public void Clear();
    public CSharpSyntaxNode get_Item(int index);
    public void set_Item(int index, CSharpSyntaxNode value);
    public void Add(CSharpSyntaxNode item);
    public void AddRange(CSharpSyntaxNode[] items);
    public void AddRange(CSharpSyntaxNode[] items, int offset, int length);
    [ConditionalAttribute("DEBUG")]
private void Validate(int start, int end);
    public void AddRange(SyntaxList`1<CSharpSyntaxNode> list);
    public void AddRange(SyntaxList`1<CSharpSyntaxNode> list, int offset, int length);
    public void AddRange(SyntaxList`1<TNode> list);
    public void AddRange(SyntaxList`1<TNode> list, int offset, int length);
    internal void RemoveLast();
    private void EnsureAdditionalCapacity(int additionalCount);
    public bool Any(SyntaxKind kind);
    public CSharpSyntaxNode[] ToArray();
    internal CSharpSyntaxNode ToListNode();
    public static SyntaxList`1<CSharpSyntaxNode> op_Implicit(SyntaxListBuilder builder);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxListBuilder`1 : ValueType {
    private SyntaxListBuilder _builder;
    public bool IsNull { get; }
    public int Count { get; }
    public TNode Item { get; public set; }
    public SyntaxListBuilder`1(int size);
    internal SyntaxListBuilder`1(SyntaxListBuilder builder);
    public bool get_IsNull();
    public int get_Count();
    public TNode get_Item(int index);
    public void set_Item(int index, TNode value);
    public void Clear();
    public SyntaxListBuilder`1<TNode> Add(TNode node);
    public void AddRange(TNode[] items, int offset, int length);
    public void AddRange(SyntaxList`1<TNode> nodes);
    public void AddRange(SyntaxList`1<TNode> nodes, int offset, int length);
    public bool Any(SyntaxKind kind);
    public SyntaxList`1<TNode> ToList();
    public CSharpSyntaxNode ToListNode();
    public static SyntaxListBuilder op_Implicit(SyntaxListBuilder`1<TNode> builder);
    public static SyntaxList`1<TNode> op_Implicit(SyntaxListBuilder`1<TNode> builder);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxListBuilderExtensions : object {
    [ExtensionAttribute]
public static SyntaxList`1<SyntaxToken> ToTokenList(SyntaxListBuilder builder);
    [ExtensionAttribute]
public static SyntaxList`1<CSharpSyntaxNode> ToList(SyntaxListBuilder builder);
    [ExtensionAttribute]
public static SyntaxList`1<TNode> ToList(SyntaxListBuilder builder);
    [ExtensionAttribute]
public static SeparatedSyntaxList`1<TNode> ToSeparatedList(SyntaxListBuilder builder);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxListPool : object {
    private ArrayElement`1[] _freeList;
    private int _freeIndex;
    internal SyntaxListBuilder Allocate();
    internal SyntaxListBuilder`1<TNode> Allocate();
    internal SeparatedSyntaxListBuilder`1<TNode> AllocateSeparated();
    internal void Free(SeparatedSyntaxListBuilder`1<TNode> item);
    internal void Free(SyntaxListBuilder item);
    private void Grow();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxNodeCache : object {
    private static int CacheSizeBits;
    private static int CacheSize;
    private static int CacheMask;
    private static Entry[] s_cache;
    private static SyntaxNodeCache();
    internal static void AddNode(GreenNode node, int hash);
    private static bool CanBeCached(GreenNode child1);
    private static bool CanBeCached(GreenNode child1, GreenNode child2);
    private static bool CanBeCached(GreenNode child1, GreenNode child2, GreenNode child3);
    private static bool ChildInCache(GreenNode child);
    private static bool AllChildrenInCache(GreenNode node);
    internal static GreenNode TryGetNode(int kind, GreenNode child1, Int32& hash);
    internal static GreenNode TryGetNode(int kind, GreenNode child1, SyntaxFactoryContext context, Int32& hash);
    private static GreenNode TryGetNode(int kind, GreenNode child1, NodeFlags flags, Int32& hash);
    internal static GreenNode TryGetNode(int kind, GreenNode child1, GreenNode child2, Int32& hash);
    internal static GreenNode TryGetNode(int kind, GreenNode child1, GreenNode child2, SyntaxFactoryContext context, Int32& hash);
    private static GreenNode TryGetNode(int kind, GreenNode child1, GreenNode child2, NodeFlags flags, Int32& hash);
    internal static GreenNode TryGetNode(int kind, GreenNode child1, GreenNode child2, GreenNode child3, Int32& hash);
    internal static GreenNode TryGetNode(int kind, GreenNode child1, GreenNode child2, GreenNode child3, SyntaxFactoryContext context, Int32& hash);
    private static GreenNode TryGetNode(int kind, GreenNode child1, GreenNode child2, GreenNode child3, NodeFlags flags, Int32& hash);
    private static NodeFlags GetFlags();
    private static NodeFlags GetFlags(SyntaxFactoryContext context);
    private static int GetCacheHash(int kind, NodeFlags flags, GreenNode child1);
    private static int GetCacheHash(int kind, NodeFlags flags, GreenNode child1, GreenNode child2);
    private static int GetCacheHash(int kind, NodeFlags flags, GreenNode child1, GreenNode child2, GreenNode child3);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser : object {
    protected Lexer lexer;
    private bool _isIncremental;
    private bool _allowModeReset;
    protected CancellationToken cancellationToken;
    private LexerMode _mode;
    private Blender _firstBlender;
    private BlendedNode _currentNode;
    private SyntaxToken _currentToken;
    private ArrayElement`1[] _lexedTokens;
    private CSharpSyntaxNode _prevTokenTrailingTrivia;
    private int _firstToken;
    private int _tokenOffset;
    private int _tokenCount;
    private int _resetCount;
    private int _resetStart;
    private static ObjectPool`1<BlendedNode[]> s_blendedNodesPool;
    private BlendedNode[] _blendedTokens;
    protected bool IsIncremental { get; }
    public CSharpParseOptions Options { get; }
    public bool IsScript { get; }
    protected LexerMode Mode { get; protected set; }
    protected CSharpSyntaxNode CurrentNode { get; }
    protected SyntaxKind CurrentNodeKind { get; }
    protected SyntaxToken CurrentToken { get; }
    internal DirectiveStack Directives { get; }
    protected SyntaxParser(Lexer lexer, LexerMode mode, CSharpSyntaxNode oldTree, IEnumerable`1<TextChangeRange> changes, bool allowModeReset, bool preLexIfNotIncremental, CancellationToken cancellationToken);
    private static SyntaxParser();
    public sealed virtual void Dispose();
    protected void ReInitialize();
    protected bool get_IsIncremental();
    private void PreLex();
    protected ResetPoint GetResetPoint();
    protected void Reset(ResetPoint& point);
    protected void Release(ResetPoint& point);
    public CSharpParseOptions get_Options();
    public bool get_IsScript();
    protected LexerMode get_Mode();
    protected void set_Mode(LexerMode value);
    protected CSharpSyntaxNode get_CurrentNode();
    protected SyntaxKind get_CurrentNodeKind();
    private void ReadCurrentNode();
    protected GreenNode EatNode();
    protected SyntaxToken get_CurrentToken();
    private SyntaxToken FetchCurrentToken();
    private void AddNewToken();
    private void AddToken(BlendedNode tokenResult);
    private void AddLexedToken(SyntaxToken token);
    private void AddTokenSlot();
    private void AddLexedTokenSlot();
    protected SyntaxToken PeekToken(int n);
    protected SyntaxToken EatToken();
    private void MoveToNextToken();
    protected void ForceEndOfFile();
    protected SyntaxToken EatToken(SyntaxKind kind);
    private SyntaxToken CreateMissingToken(SyntaxKind expected, SyntaxKind actual, bool reportError);
    private SyntaxToken CreateMissingToken(SyntaxKind expected, ErrorCode code, bool reportError);
    protected SyntaxToken EatToken(SyntaxKind kind, bool reportError);
    protected SyntaxToken EatToken(SyntaxKind kind, ErrorCode code, bool reportError);
    protected SyntaxToken EatTokenWithPrejudice(SyntaxKind kind);
    protected SyntaxToken EatTokenWithPrejudice(ErrorCode errorCode, Object[] args);
    protected SyntaxToken EatContextualToken(SyntaxKind kind, ErrorCode code, bool reportError);
    protected SyntaxToken EatContextualToken(SyntaxKind kind, bool reportError);
    protected virtual SyntaxDiagnosticInfo GetExpectedTokenError(SyntaxKind expected, SyntaxKind actual, int offset, int width);
    protected virtual SyntaxDiagnosticInfo GetExpectedTokenError(SyntaxKind expected, SyntaxKind actual);
    private static ErrorCode GetExpectedTokenErrorCode(SyntaxKind expected, SyntaxKind actual);
    protected void GetDiagnosticSpanForMissingToken(Int32& offset, Int32& width);
    protected virtual TNode WithAdditionalDiagnostics(TNode node, DiagnosticInfo[] diagnostics);
    protected TNode AddError(TNode node, ErrorCode code);
    protected TNode AddError(TNode node, ErrorCode code, Object[] args);
    protected TNode AddError(TNode node, int offset, int length, ErrorCode code, Object[] args);
    protected TNode AddError(TNode node, CSharpSyntaxNode location, ErrorCode code, Object[] args);
    protected TNode AddErrorToFirstToken(TNode node, ErrorCode code);
    protected TNode AddErrorToFirstToken(TNode node, ErrorCode code, Object[] args);
    protected TNode AddErrorToLastToken(TNode node, ErrorCode code);
    protected TNode AddErrorToLastToken(TNode node, ErrorCode code, Object[] args);
    private static void GetOffsetAndWidthForLastToken(TNode node, Int32& offset, Int32& width);
    protected static SyntaxDiagnosticInfo MakeError(int offset, int width, ErrorCode code);
    protected static SyntaxDiagnosticInfo MakeError(int offset, int width, ErrorCode code, Object[] args);
    protected static SyntaxDiagnosticInfo MakeError(CSharpSyntaxNode node, ErrorCode code, Object[] args);
    protected static SyntaxDiagnosticInfo MakeError(ErrorCode code, Object[] args);
    protected TNode AddLeadingSkippedSyntax(TNode node, CSharpSyntaxNode skippedSyntax);
    protected TNode AddTrailingSkippedSyntax(TNode node, CSharpSyntaxNode skippedSyntax);
    internal SyntaxToken AddSkippedSyntax(SyntaxToken target, CSharpSyntaxNode skippedSyntax, bool trailing);
    private bool FindOffset(GreenNode root, CSharpSyntaxNode location, Int32& offset);
    protected static SyntaxToken ConvertToKeyword(SyntaxToken token);
    internal DirectiveStack get_Directives();
    protected TNode CheckFeatureAvailability(TNode node, MessageID feature, bool forceWarning);
    protected bool IsFeatureEnabled(MessageID feature);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken : CSharpSyntaxNode {
    internal static SyntaxKind FirstTokenWithWellKnownText;
    internal static SyntaxKind LastTokenWithWellKnownText;
    private static ArrayElement`1[] s_tokensWithNoTrivia;
    private static ArrayElement`1[] s_tokensWithElasticTrivia;
    private static ArrayElement`1[] s_tokensWithSingleTrailingSpace;
    private static ArrayElement`1[] s_tokensWithSingleTrailingCRLF;
    public bool IsToken { get; }
    public SyntaxKind ContextualKind { get; }
    public int RawContextualKind { get; }
    public string Text { get; }
    public object Value { get; }
    public string ValueText { get; }
    public int Width { get; }
    internal SyntaxList`1<CSharpSyntaxNode> LeadingTrivia { get; }
    internal SyntaxList`1<CSharpSyntaxNode> TrailingTrivia { get; }
    internal SyntaxToken(SyntaxKind kind);
    internal SyntaxToken(SyntaxKind kind, DiagnosticInfo[] diagnostics);
    internal SyntaxToken(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal SyntaxToken(SyntaxKind kind, int fullWidth);
    internal SyntaxToken(SyntaxKind kind, int fullWidth, DiagnosticInfo[] diagnostics);
    internal SyntaxToken(SyntaxKind kind, int fullWidth, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal SyntaxToken(ObjectReader reader);
    private static SyntaxToken();
    internal virtual Func`2<ObjectReader, object> GetReader();
    public virtual bool get_IsToken();
    internal virtual GreenNode GetSlot(int index);
    internal static SyntaxToken Create(SyntaxKind kind);
    internal static SyntaxToken Create(SyntaxKind kind, CSharpSyntaxNode leading, CSharpSyntaxNode trailing);
    internal static SyntaxToken CreateMissing(SyntaxKind kind, CSharpSyntaxNode leading, CSharpSyntaxNode trailing);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken/<GetWellKnownTokens>d__21")]
internal static IEnumerable`1<SyntaxToken> GetWellKnownTokens();
    internal static SyntaxToken Identifier(string text);
    internal static SyntaxToken Identifier(CSharpSyntaxNode leading, string text, CSharpSyntaxNode trailing);
    internal static SyntaxToken Identifier(SyntaxKind contextualKind, CSharpSyntaxNode leading, string text, string valueText, CSharpSyntaxNode trailing);
    internal static SyntaxToken WithValue(SyntaxKind kind, string text, T value);
    internal static SyntaxToken WithValue(SyntaxKind kind, CSharpSyntaxNode leading, string text, T value, CSharpSyntaxNode trailing);
    internal static SyntaxToken StringLiteral(string text);
    internal static SyntaxToken StringLiteral(CSharpSyntaxNode leading, string text, CSharpSyntaxNode trailing);
    public virtual SyntaxKind get_ContextualKind();
    public virtual int get_RawContextualKind();
    public virtual string get_Text();
    public virtual string ToString();
    public virtual object get_Value();
    public virtual object GetValue();
    public virtual string get_ValueText();
    public virtual string GetValueText();
    public virtual int get_Width();
    public virtual int GetLeadingTriviaWidth();
    public virtual int GetTrailingTriviaWidth();
    internal SyntaxList`1<CSharpSyntaxNode> get_LeadingTrivia();
    internal SyntaxList`1<CSharpSyntaxNode> get_TrailingTrivia();
    public virtual GreenNode WithLeadingTrivia(GreenNode trivia);
    internal virtual SyntaxToken WithLeadingTrivia(CSharpSyntaxNode trivia);
    public virtual GreenNode WithTrailingTrivia(GreenNode trivia);
    internal virtual SyntaxToken WithTrailingTrivia(CSharpSyntaxNode trivia);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual DirectiveStack ApplyDirectives(DirectiveStack stack);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    protected internal virtual void WriteTo(TextWriter writer, bool leading, bool trailing);
    public virtual bool IsEquivalentTo(GreenNode other);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxTrivia : CSharpSyntaxNode {
    public string Text;
    public int Width { get; }
    internal SyntaxTrivia(SyntaxKind kind, string text, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal SyntaxTrivia(ObjectReader reader);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual void WriteTo(ObjectWriter writer);
    internal static SyntaxTrivia Create(SyntaxKind kind, string text);
    public virtual string ToFullString();
    public virtual string ToString();
    internal virtual GreenNode GetSlot(int index);
    public virtual int get_Width();
    public virtual int GetLeadingTriviaWidth();
    public virtual int GetTrailingTriviaWidth();
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    protected internal virtual void WriteTo(TextWriter writer, bool leading, bool trailing);
    public static SyntaxTrivia op_Implicit(SyntaxTrivia trivia);
    public virtual bool IsEquivalentTo(GreenNode other);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ThisExpressionSyntax : InstanceExpressionSyntax {
    internal SyntaxToken token;
    public SyntaxToken Token { get; }
    internal ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context);
    internal ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token);
    internal ThisExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_Token();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ThisExpressionSyntax Update(SyntaxToken token);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ThrowStatementSyntax : StatementSyntax {
    internal SyntaxToken throwKeyword;
    internal ExpressionSyntax expression;
    internal SyntaxToken semicolonToken;
    public SyntaxToken ThrowKeyword { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken SemicolonToken { get; }
    internal ThrowStatementSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal ThrowStatementSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal ThrowStatementSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    internal ThrowStatementSyntax(ObjectReader reader);
    public SyntaxToken get_ThrowKeyword();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ThrowStatementSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TryStatementSyntax : StatementSyntax {
    internal SyntaxToken tryKeyword;
    internal BlockSyntax block;
    internal CSharpSyntaxNode catches;
    internal FinallyClauseSyntax finally;
    public SyntaxToken TryKeyword { get; }
    public BlockSyntax Block { get; }
    public SyntaxList`1<CatchClauseSyntax> Catches { get; }
    public FinallyClauseSyntax Finally { get; }
    internal TryStatementSyntax(SyntaxKind kind, SyntaxToken tryKeyword, BlockSyntax block, CSharpSyntaxNode catches, FinallyClauseSyntax finally, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal TryStatementSyntax(SyntaxKind kind, SyntaxToken tryKeyword, BlockSyntax block, CSharpSyntaxNode catches, FinallyClauseSyntax finally, SyntaxFactoryContext context);
    internal TryStatementSyntax(SyntaxKind kind, SyntaxToken tryKeyword, BlockSyntax block, CSharpSyntaxNode catches, FinallyClauseSyntax finally);
    internal TryStatementSyntax(ObjectReader reader);
    public SyntaxToken get_TryKeyword();
    public BlockSyntax get_Block();
    public SyntaxList`1<CatchClauseSyntax> get_Catches();
    public FinallyClauseSyntax get_Finally();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public TryStatementSyntax Update(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList`1<CatchClauseSyntax> catches, FinallyClauseSyntax finally);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeArgumentListSyntax : CSharpSyntaxNode {
    internal SyntaxToken lessThanToken;
    internal CSharpSyntaxNode arguments;
    internal SyntaxToken greaterThanToken;
    public SyntaxToken LessThanToken { get; }
    public SeparatedSyntaxList`1<TypeSyntax> Arguments { get; }
    public SyntaxToken GreaterThanToken { get; }
    internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, CSharpSyntaxNode arguments, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, CSharpSyntaxNode arguments, SyntaxToken greaterThanToken, SyntaxFactoryContext context);
    internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, CSharpSyntaxNode arguments, SyntaxToken greaterThanToken);
    internal TypeArgumentListSyntax(ObjectReader reader);
    public SyntaxToken get_LessThanToken();
    public SeparatedSyntaxList`1<TypeSyntax> get_Arguments();
    public SyntaxToken get_GreaterThanToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public TypeArgumentListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList`1<TypeSyntax> arguments, SyntaxToken greaterThanToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeConstraintSyntax : TypeParameterConstraintSyntax {
    internal TypeSyntax type;
    public TypeSyntax Type { get; }
    internal TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type, SyntaxFactoryContext context);
    internal TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type);
    internal TypeConstraintSyntax(ObjectReader reader);
    public TypeSyntax get_Type();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public TypeConstraintSyntax Update(TypeSyntax type);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeCrefSyntax : CrefSyntax {
    internal TypeSyntax type;
    public TypeSyntax Type { get; }
    internal TypeCrefSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal TypeCrefSyntax(SyntaxKind kind, TypeSyntax type, SyntaxFactoryContext context);
    internal TypeCrefSyntax(SyntaxKind kind, TypeSyntax type);
    internal TypeCrefSyntax(ObjectReader reader);
    public TypeSyntax get_Type();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public TypeCrefSyntax Update(TypeSyntax type);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeDeclarationSyntax : BaseTypeDeclarationSyntax {
    public SyntaxToken Keyword { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    internal TypeDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal TypeDeclarationSyntax(SyntaxKind kind);
    protected TypeDeclarationSyntax(ObjectReader reader);
    public abstract virtual SyntaxToken get_Keyword();
    public abstract virtual TypeParameterListSyntax get_TypeParameterList();
    public abstract virtual SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public abstract virtual SyntaxList`1<MemberDeclarationSyntax> get_Members();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeOfExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken keyword;
    internal SyntaxToken openParenToken;
    internal TypeSyntax type;
    internal SyntaxToken closeParenToken;
    public SyntaxToken Keyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken CloseParenToken { get; }
    internal TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context);
    internal TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    internal TypeOfExpressionSyntax(ObjectReader reader);
    public SyntaxToken get_Keyword();
    public SyntaxToken get_OpenParenToken();
    public TypeSyntax get_Type();
    public SyntaxToken get_CloseParenToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public TypeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax : CSharpSyntaxNode {
    internal SyntaxToken whereKeyword;
    internal IdentifierNameSyntax name;
    internal SyntaxToken colonToken;
    internal CSharpSyntaxNode constraints;
    public SyntaxToken WhereKeyword { get; }
    public IdentifierNameSyntax Name { get; }
    public SyntaxToken ColonToken { get; }
    public SeparatedSyntaxList`1<TypeParameterConstraintSyntax> Constraints { get; }
    internal TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, CSharpSyntaxNode constraints, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, CSharpSyntaxNode constraints, SyntaxFactoryContext context);
    internal TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, CSharpSyntaxNode constraints);
    internal TypeParameterConstraintClauseSyntax(ObjectReader reader);
    public SyntaxToken get_WhereKeyword();
    public IdentifierNameSyntax get_Name();
    public SyntaxToken get_ColonToken();
    public SeparatedSyntaxList`1<TypeParameterConstraintSyntax> get_Constraints();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public TypeParameterConstraintClauseSyntax Update(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList`1<TypeParameterConstraintSyntax> constraints);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintSyntax : CSharpSyntaxNode {
    internal TypeParameterConstraintSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal TypeParameterConstraintSyntax(SyntaxKind kind);
    protected TypeParameterConstraintSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax : CSharpSyntaxNode {
    internal SyntaxToken lessThanToken;
    internal CSharpSyntaxNode parameters;
    internal SyntaxToken greaterThanToken;
    public SyntaxToken LessThanToken { get; }
    public SeparatedSyntaxList`1<TypeParameterSyntax> Parameters { get; }
    public SyntaxToken GreaterThanToken { get; }
    internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, CSharpSyntaxNode parameters, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, CSharpSyntaxNode parameters, SyntaxToken greaterThanToken, SyntaxFactoryContext context);
    internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, CSharpSyntaxNode parameters, SyntaxToken greaterThanToken);
    internal TypeParameterListSyntax(ObjectReader reader);
    public SyntaxToken get_LessThanToken();
    public SeparatedSyntaxList`1<TypeParameterSyntax> get_Parameters();
    public SyntaxToken get_GreaterThanToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public TypeParameterListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList`1<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterSyntax : CSharpSyntaxNode {
    internal CSharpSyntaxNode attributeLists;
    internal SyntaxToken varianceKeyword;
    internal SyntaxToken identifier;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxToken VarianceKeyword { get; }
    public SyntaxToken Identifier { get; }
    internal TypeParameterSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal TypeParameterSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier, SyntaxFactoryContext context);
    internal TypeParameterSyntax(SyntaxKind kind, CSharpSyntaxNode attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier);
    internal TypeParameterSyntax(ObjectReader reader);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxToken get_VarianceKeyword();
    public SyntaxToken get_Identifier();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public TypeParameterSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax : ExpressionSyntax {
    internal TypeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal TypeSyntax(SyntaxKind kind);
    protected TypeSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UndefDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal SyntaxToken hashToken;
    internal SyntaxToken undefKeyword;
    internal SyntaxToken name;
    internal SyntaxToken endOfDirectiveToken;
    internal bool isActive;
    public SyntaxToken HashToken { get; }
    public SyntaxToken UndefKeyword { get; }
    public SyntaxToken Name { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal UndefDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal UndefDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context);
    internal UndefDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive);
    internal UndefDirectiveTriviaSyntax(ObjectReader reader);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_UndefKeyword();
    public SyntaxToken get_Name();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public UndefDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UnsafeStatementSyntax : StatementSyntax {
    internal SyntaxToken unsafeKeyword;
    internal BlockSyntax block;
    public SyntaxToken UnsafeKeyword { get; }
    public BlockSyntax Block { get; }
    internal UnsafeStatementSyntax(SyntaxKind kind, SyntaxToken unsafeKeyword, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal UnsafeStatementSyntax(SyntaxKind kind, SyntaxToken unsafeKeyword, BlockSyntax block, SyntaxFactoryContext context);
    internal UnsafeStatementSyntax(SyntaxKind kind, SyntaxToken unsafeKeyword, BlockSyntax block);
    internal UnsafeStatementSyntax(ObjectReader reader);
    public SyntaxToken get_UnsafeKeyword();
    public BlockSyntax get_Block();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public UnsafeStatementSyntax Update(SyntaxToken unsafeKeyword, BlockSyntax block);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UsingDirectiveSyntax : CSharpSyntaxNode {
    internal SyntaxToken usingKeyword;
    internal SyntaxToken staticKeyword;
    internal NameEqualsSyntax alias;
    internal NameSyntax name;
    internal SyntaxToken semicolonToken;
    public SyntaxToken UsingKeyword { get; }
    public SyntaxToken StaticKeyword { get; }
    public NameEqualsSyntax Alias { get; }
    public NameSyntax Name { get; }
    public SyntaxToken SemicolonToken { get; }
    internal UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken);
    internal UsingDirectiveSyntax(ObjectReader reader);
    public SyntaxToken get_UsingKeyword();
    public SyntaxToken get_StaticKeyword();
    public NameEqualsSyntax get_Alias();
    public NameSyntax get_Name();
    public SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public UsingDirectiveSyntax Update(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UsingStatementSyntax : StatementSyntax {
    internal SyntaxToken usingKeyword;
    internal SyntaxToken openParenToken;
    internal VariableDeclarationSyntax declaration;
    internal ExpressionSyntax expression;
    internal SyntaxToken closeParenToken;
    internal StatementSyntax statement;
    public SyntaxToken UsingKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public VariableDeclarationSyntax Declaration { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    internal UsingStatementSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal UsingStatementSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context);
    internal UsingStatementSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    internal UsingStatementSyntax(ObjectReader reader);
    public SyntaxToken get_UsingKeyword();
    public SyntaxToken get_OpenParenToken();
    public VariableDeclarationSyntax get_Declaration();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public UsingStatementSyntax Update(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclarationSyntax : CSharpSyntaxNode {
    internal TypeSyntax type;
    internal CSharpSyntaxNode variables;
    public TypeSyntax Type { get; }
    public SeparatedSyntaxList`1<VariableDeclaratorSyntax> Variables { get; }
    internal VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, CSharpSyntaxNode variables, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, CSharpSyntaxNode variables, SyntaxFactoryContext context);
    internal VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, CSharpSyntaxNode variables);
    internal VariableDeclarationSyntax(ObjectReader reader);
    public TypeSyntax get_Type();
    public SeparatedSyntaxList`1<VariableDeclaratorSyntax> get_Variables();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public VariableDeclarationSyntax Update(TypeSyntax type, SeparatedSyntaxList`1<VariableDeclaratorSyntax> variables);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclaratorSyntax : CSharpSyntaxNode {
    internal SyntaxToken identifier;
    internal BracketedArgumentListSyntax argumentList;
    internal EqualsValueClauseSyntax initializer;
    public SyntaxToken Identifier { get; }
    public BracketedArgumentListSyntax ArgumentList { get; }
    public EqualsValueClauseSyntax Initializer { get; }
    internal VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer, SyntaxFactoryContext context);
    internal VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer);
    internal VariableDeclaratorSyntax(ObjectReader reader);
    public SyntaxToken get_Identifier();
    public BracketedArgumentListSyntax get_ArgumentList();
    public EqualsValueClauseSyntax get_Initializer();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public VariableDeclaratorSyntax Update(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.WarningDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal SyntaxToken hashToken;
    internal SyntaxToken warningKeyword;
    internal SyntaxToken endOfDirectiveToken;
    internal bool isActive;
    public SyntaxToken HashToken { get; }
    public SyntaxToken WarningKeyword { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal WarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal WarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context);
    internal WarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    internal WarningDirectiveTriviaSyntax(ObjectReader reader);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_WarningKeyword();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public WarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.WhereClauseSyntax : QueryClauseSyntax {
    internal SyntaxToken whereKeyword;
    internal ExpressionSyntax condition;
    public SyntaxToken WhereKeyword { get; }
    public ExpressionSyntax Condition { get; }
    internal WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition, SyntaxFactoryContext context);
    internal WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition);
    internal WhereClauseSyntax(ObjectReader reader);
    public SyntaxToken get_WhereKeyword();
    public ExpressionSyntax get_Condition();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public WhereClauseSyntax Update(SyntaxToken whereKeyword, ExpressionSyntax condition);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.WhileStatementSyntax : StatementSyntax {
    internal SyntaxToken whileKeyword;
    internal SyntaxToken openParenToken;
    internal ExpressionSyntax condition;
    internal SyntaxToken closeParenToken;
    internal StatementSyntax statement;
    public SyntaxToken WhileKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Condition { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    internal WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context);
    internal WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement);
    internal WhileStatementSyntax(ObjectReader reader);
    public SyntaxToken get_WhileKeyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Condition();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public WhileStatementSyntax Update(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlAttributeSyntax : CSharpSyntaxNode {
    public XmlNameSyntax Name { get; }
    public SyntaxToken EqualsToken { get; }
    public SyntaxToken StartQuoteToken { get; }
    public SyntaxToken EndQuoteToken { get; }
    internal XmlAttributeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal XmlAttributeSyntax(SyntaxKind kind);
    protected XmlAttributeSyntax(ObjectReader reader);
    public abstract virtual XmlNameSyntax get_Name();
    public abstract virtual SyntaxToken get_EqualsToken();
    public abstract virtual SyntaxToken get_StartQuoteToken();
    public abstract virtual SyntaxToken get_EndQuoteToken();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlCDataSectionSyntax : XmlNodeSyntax {
    internal SyntaxToken startCDataToken;
    internal CSharpSyntaxNode textTokens;
    internal SyntaxToken endCDataToken;
    public SyntaxToken StartCDataToken { get; }
    public SyntaxList`1<SyntaxToken> TextTokens { get; }
    public SyntaxToken EndCDataToken { get; }
    internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, CSharpSyntaxNode textTokens, SyntaxToken endCDataToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, CSharpSyntaxNode textTokens, SyntaxToken endCDataToken, SyntaxFactoryContext context);
    internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, CSharpSyntaxNode textTokens, SyntaxToken endCDataToken);
    internal XmlCDataSectionSyntax(ObjectReader reader);
    public SyntaxToken get_StartCDataToken();
    public SyntaxList`1<SyntaxToken> get_TextTokens();
    public SyntaxToken get_EndCDataToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlCDataSectionSyntax Update(SyntaxToken startCDataToken, SyntaxList`1<SyntaxToken> textTokens, SyntaxToken endCDataToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlCommentSyntax : XmlNodeSyntax {
    internal SyntaxToken lessThanExclamationMinusMinusToken;
    internal CSharpSyntaxNode textTokens;
    internal SyntaxToken minusMinusGreaterThanToken;
    public SyntaxToken LessThanExclamationMinusMinusToken { get; }
    public SyntaxList`1<SyntaxToken> TextTokens { get; }
    public SyntaxToken MinusMinusGreaterThanToken { get; }
    internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, CSharpSyntaxNode textTokens, SyntaxToken minusMinusGreaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, CSharpSyntaxNode textTokens, SyntaxToken minusMinusGreaterThanToken, SyntaxFactoryContext context);
    internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, CSharpSyntaxNode textTokens, SyntaxToken minusMinusGreaterThanToken);
    internal XmlCommentSyntax(ObjectReader reader);
    public SyntaxToken get_LessThanExclamationMinusMinusToken();
    public SyntaxList`1<SyntaxToken> get_TextTokens();
    public SyntaxToken get_MinusMinusGreaterThanToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlCommentSyntax Update(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxList`1<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlCrefAttributeSyntax : XmlAttributeSyntax {
    internal XmlNameSyntax name;
    internal SyntaxToken equalsToken;
    internal SyntaxToken startQuoteToken;
    internal CrefSyntax cref;
    internal SyntaxToken endQuoteToken;
    public XmlNameSyntax Name { get; }
    public SyntaxToken EqualsToken { get; }
    public SyntaxToken StartQuoteToken { get; }
    public CrefSyntax Cref { get; }
    public SyntaxToken EndQuoteToken { get; }
    internal XmlCrefAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal XmlCrefAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken, SyntaxFactoryContext context);
    internal XmlCrefAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken);
    internal XmlCrefAttributeSyntax(ObjectReader reader);
    public virtual XmlNameSyntax get_Name();
    public virtual SyntaxToken get_EqualsToken();
    public virtual SyntaxToken get_StartQuoteToken();
    public CrefSyntax get_Cref();
    public virtual SyntaxToken get_EndQuoteToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlCrefAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal enum Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlDocCommentLocation : Enum {
    public int value__;
    public static XmlDocCommentLocation Start;
    public static XmlDocCommentLocation Interior;
    public static XmlDocCommentLocation Exterior;
    public static XmlDocCommentLocation End;
}
internal enum Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlDocCommentStyle : Enum {
    public int value__;
    public static XmlDocCommentStyle SingleLine;
    public static XmlDocCommentStyle Delimited;
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlElementEndTagSyntax : CSharpSyntaxNode {
    internal SyntaxToken lessThanSlashToken;
    internal XmlNameSyntax name;
    internal SyntaxToken greaterThanToken;
    public SyntaxToken LessThanSlashToken { get; }
    public XmlNameSyntax Name { get; }
    public SyntaxToken GreaterThanToken { get; }
    internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken, SyntaxFactoryContext context);
    internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken);
    internal XmlElementEndTagSyntax(ObjectReader reader);
    public SyntaxToken get_LessThanSlashToken();
    public XmlNameSyntax get_Name();
    public SyntaxToken get_GreaterThanToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlElementEndTagSyntax Update(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlElementStartTagSyntax : CSharpSyntaxNode {
    internal SyntaxToken lessThanToken;
    internal XmlNameSyntax name;
    internal CSharpSyntaxNode attributes;
    internal SyntaxToken greaterThanToken;
    public SyntaxToken LessThanToken { get; }
    public XmlNameSyntax Name { get; }
    public SyntaxList`1<XmlAttributeSyntax> Attributes { get; }
    public SyntaxToken GreaterThanToken { get; }
    internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, CSharpSyntaxNode attributes, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, CSharpSyntaxNode attributes, SyntaxToken greaterThanToken, SyntaxFactoryContext context);
    internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, CSharpSyntaxNode attributes, SyntaxToken greaterThanToken);
    internal XmlElementStartTagSyntax(ObjectReader reader);
    public SyntaxToken get_LessThanToken();
    public XmlNameSyntax get_Name();
    public SyntaxList`1<XmlAttributeSyntax> get_Attributes();
    public SyntaxToken get_GreaterThanToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlElementStartTagSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList`1<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlElementSyntax : XmlNodeSyntax {
    internal XmlElementStartTagSyntax startTag;
    internal CSharpSyntaxNode content;
    internal XmlElementEndTagSyntax endTag;
    public XmlElementStartTagSyntax StartTag { get; }
    public SyntaxList`1<XmlNodeSyntax> Content { get; }
    public XmlElementEndTagSyntax EndTag { get; }
    internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, CSharpSyntaxNode content, XmlElementEndTagSyntax endTag, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, CSharpSyntaxNode content, XmlElementEndTagSyntax endTag, SyntaxFactoryContext context);
    internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, CSharpSyntaxNode content, XmlElementEndTagSyntax endTag);
    internal XmlElementSyntax(ObjectReader reader);
    public XmlElementStartTagSyntax get_StartTag();
    public SyntaxList`1<XmlNodeSyntax> get_Content();
    public XmlElementEndTagSyntax get_EndTag();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlElementSyntax Update(XmlElementStartTagSyntax startTag, SyntaxList`1<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlEmptyElementSyntax : XmlNodeSyntax {
    internal SyntaxToken lessThanToken;
    internal XmlNameSyntax name;
    internal CSharpSyntaxNode attributes;
    internal SyntaxToken slashGreaterThanToken;
    public SyntaxToken LessThanToken { get; }
    public XmlNameSyntax Name { get; }
    public SyntaxList`1<XmlAttributeSyntax> Attributes { get; }
    public SyntaxToken SlashGreaterThanToken { get; }
    internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, CSharpSyntaxNode attributes, SyntaxToken slashGreaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, CSharpSyntaxNode attributes, SyntaxToken slashGreaterThanToken, SyntaxFactoryContext context);
    internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, CSharpSyntaxNode attributes, SyntaxToken slashGreaterThanToken);
    internal XmlEmptyElementSyntax(ObjectReader reader);
    public SyntaxToken get_LessThanToken();
    public XmlNameSyntax get_Name();
    public SyntaxList`1<XmlAttributeSyntax> get_Attributes();
    public SyntaxToken get_SlashGreaterThanToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlEmptyElementSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList`1<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameAttributeSyntax : XmlAttributeSyntax {
    internal XmlNameSyntax name;
    internal SyntaxToken equalsToken;
    internal SyntaxToken startQuoteToken;
    internal IdentifierNameSyntax identifier;
    internal SyntaxToken endQuoteToken;
    public XmlNameSyntax Name { get; }
    public SyntaxToken EqualsToken { get; }
    public SyntaxToken StartQuoteToken { get; }
    public IdentifierNameSyntax Identifier { get; }
    public SyntaxToken EndQuoteToken { get; }
    internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken, SyntaxFactoryContext context);
    internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken);
    internal XmlNameAttributeSyntax(ObjectReader reader);
    public virtual XmlNameSyntax get_Name();
    public virtual SyntaxToken get_EqualsToken();
    public virtual SyntaxToken get_StartQuoteToken();
    public IdentifierNameSyntax get_Identifier();
    public virtual SyntaxToken get_EndQuoteToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlNameAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameSyntax : CSharpSyntaxNode {
    internal XmlPrefixSyntax prefix;
    internal SyntaxToken localName;
    public XmlPrefixSyntax Prefix { get; }
    public SyntaxToken LocalName { get; }
    internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax prefix, SyntaxToken localName, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax prefix, SyntaxToken localName, SyntaxFactoryContext context);
    internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax prefix, SyntaxToken localName);
    internal XmlNameSyntax(ObjectReader reader);
    public XmlPrefixSyntax get_Prefix();
    public SyntaxToken get_LocalName();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlNameSyntax Update(XmlPrefixSyntax prefix, SyntaxToken localName);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNodeSyntax : CSharpSyntaxNode {
    internal XmlNodeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal XmlNodeSyntax(SyntaxKind kind);
    protected XmlNodeSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlPrefixSyntax : CSharpSyntaxNode {
    internal SyntaxToken prefix;
    internal SyntaxToken colonToken;
    public SyntaxToken Prefix { get; }
    public SyntaxToken ColonToken { get; }
    internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken, SyntaxFactoryContext context);
    internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken);
    internal XmlPrefixSyntax(ObjectReader reader);
    public SyntaxToken get_Prefix();
    public SyntaxToken get_ColonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlPrefixSyntax Update(SyntaxToken prefix, SyntaxToken colonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlProcessingInstructionSyntax : XmlNodeSyntax {
    internal SyntaxToken startProcessingInstructionToken;
    internal XmlNameSyntax name;
    internal CSharpSyntaxNode textTokens;
    internal SyntaxToken endProcessingInstructionToken;
    public SyntaxToken StartProcessingInstructionToken { get; }
    public XmlNameSyntax Name { get; }
    public SyntaxList`1<SyntaxToken> TextTokens { get; }
    public SyntaxToken EndProcessingInstructionToken { get; }
    internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, CSharpSyntaxNode textTokens, SyntaxToken endProcessingInstructionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, CSharpSyntaxNode textTokens, SyntaxToken endProcessingInstructionToken, SyntaxFactoryContext context);
    internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, CSharpSyntaxNode textTokens, SyntaxToken endProcessingInstructionToken);
    internal XmlProcessingInstructionSyntax(ObjectReader reader);
    public SyntaxToken get_StartProcessingInstructionToken();
    public XmlNameSyntax get_Name();
    public SyntaxList`1<SyntaxToken> get_TextTokens();
    public SyntaxToken get_EndProcessingInstructionToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlProcessingInstructionSyntax Update(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxList`1<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlTextAttributeSyntax : XmlAttributeSyntax {
    internal XmlNameSyntax name;
    internal SyntaxToken equalsToken;
    internal SyntaxToken startQuoteToken;
    internal CSharpSyntaxNode textTokens;
    internal SyntaxToken endQuoteToken;
    public XmlNameSyntax Name { get; }
    public SyntaxToken EqualsToken { get; }
    public SyntaxToken StartQuoteToken { get; }
    public SyntaxList`1<SyntaxToken> TextTokens { get; }
    public SyntaxToken EndQuoteToken { get; }
    internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CSharpSyntaxNode textTokens, SyntaxToken endQuoteToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CSharpSyntaxNode textTokens, SyntaxToken endQuoteToken, SyntaxFactoryContext context);
    internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CSharpSyntaxNode textTokens, SyntaxToken endQuoteToken);
    internal XmlTextAttributeSyntax(ObjectReader reader);
    public virtual XmlNameSyntax get_Name();
    public virtual SyntaxToken get_EqualsToken();
    public virtual SyntaxToken get_StartQuoteToken();
    public SyntaxList`1<SyntaxToken> get_TextTokens();
    public virtual SyntaxToken get_EndQuoteToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlTextAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxList`1<SyntaxToken> textTokens, SyntaxToken endQuoteToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlTextSyntax : XmlNodeSyntax {
    internal CSharpSyntaxNode textTokens;
    public SyntaxList`1<SyntaxToken> TextTokens { get; }
    internal XmlTextSyntax(SyntaxKind kind, CSharpSyntaxNode textTokens, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal XmlTextSyntax(SyntaxKind kind, CSharpSyntaxNode textTokens, SyntaxFactoryContext context);
    internal XmlTextSyntax(SyntaxKind kind, CSharpSyntaxNode textTokens);
    internal XmlTextSyntax(ObjectReader reader);
    public SyntaxList`1<SyntaxToken> get_TextTokens();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlTextSyntax Update(SyntaxList`1<SyntaxToken> textTokens);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.YieldStatementSyntax : StatementSyntax {
    internal SyntaxToken yieldKeyword;
    internal SyntaxToken returnOrBreakKeyword;
    internal ExpressionSyntax expression;
    internal SyntaxToken semicolonToken;
    public SyntaxToken YieldKeyword { get; }
    public SyntaxToken ReturnOrBreakKeyword { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken SemicolonToken { get; }
    internal YieldStatementSyntax(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal YieldStatementSyntax(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context);
    internal YieldStatementSyntax(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    internal YieldStatementSyntax(ObjectReader reader);
    public SyntaxToken get_YieldKeyword();
    public SyntaxToken get_ReturnOrBreakKeyword();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_SemicolonToken();
    internal virtual GreenNode GetSlot(int index);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public YieldStatementSyntax Update(SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax : CSharpSyntaxNode {
    internal InterpolatedStringContentSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax : ExpressionSyntax {
    private CSharpSyntaxNode contents;
    public SyntaxToken StringStartToken { get; }
    public SyntaxList`1<InterpolatedStringContentSyntax> Contents { get; }
    public SyntaxToken StringEndToken { get; }
    internal InterpolatedStringExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_StringStartToken();
    public SyntaxList`1<InterpolatedStringContentSyntax> get_Contents();
    public SyntaxToken get_StringEndToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public InterpolatedStringExpressionSyntax Update(SyntaxToken stringStartToken, SyntaxList`1<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken);
    public InterpolatedStringExpressionSyntax WithStringStartToken(SyntaxToken stringStartToken);
    public InterpolatedStringExpressionSyntax WithContents(SyntaxList`1<InterpolatedStringContentSyntax> contents);
    public InterpolatedStringExpressionSyntax WithStringEndToken(SyntaxToken stringEndToken);
    public InterpolatedStringExpressionSyntax AddContents(InterpolatedStringContentSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax : InterpolatedStringContentSyntax {
    public SyntaxToken TextToken { get; }
    internal InterpolatedStringTextSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_TextToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public InterpolatedStringTextSyntax Update(SyntaxToken textToken);
    public InterpolatedStringTextSyntax WithTextToken(SyntaxToken textToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax : CSharpSyntaxNode {
    private ExpressionSyntax value;
    public SyntaxToken CommaToken { get; }
    public ExpressionSyntax Value { get; }
    internal InterpolationAlignmentClauseSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_CommaToken();
    public ExpressionSyntax get_Value();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public InterpolationAlignmentClauseSyntax Update(SyntaxToken commaToken, ExpressionSyntax value);
    public InterpolationAlignmentClauseSyntax WithCommaToken(SyntaxToken commaToken);
    public InterpolationAlignmentClauseSyntax WithValue(ExpressionSyntax value);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax : CSharpSyntaxNode {
    public SyntaxToken ColonToken { get; }
    public SyntaxToken FormatStringToken { get; }
    internal InterpolationFormatClauseSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_ColonToken();
    public SyntaxToken get_FormatStringToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public InterpolationFormatClauseSyntax Update(SyntaxToken colonToken, SyntaxToken formatStringToken);
    public InterpolationFormatClauseSyntax WithColonToken(SyntaxToken colonToken);
    public InterpolationFormatClauseSyntax WithFormatStringToken(SyntaxToken formatStringToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax : InterpolatedStringContentSyntax {
    private ExpressionSyntax expression;
    private InterpolationAlignmentClauseSyntax alignmentClause;
    private InterpolationFormatClauseSyntax formatClause;
    public SyntaxToken OpenBraceToken { get; }
    public ExpressionSyntax Expression { get; }
    public InterpolationAlignmentClauseSyntax AlignmentClause { get; }
    public InterpolationFormatClauseSyntax FormatClause { get; }
    public SyntaxToken CloseBraceToken { get; }
    internal InterpolationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OpenBraceToken();
    public ExpressionSyntax get_Expression();
    public InterpolationAlignmentClauseSyntax get_AlignmentClause();
    public InterpolationFormatClauseSyntax get_FormatClause();
    public SyntaxToken get_CloseBraceToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public InterpolationSyntax Update(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken);
    public InterpolationSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
    public InterpolationSyntax WithExpression(ExpressionSyntax expression);
    public InterpolationSyntax WithAlignmentClause(InterpolationAlignmentClauseSyntax alignmentClause);
    public InterpolationSyntax WithFormatClause(InterpolationFormatClauseSyntax formatClause);
    public InterpolationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax : ExpressionSyntax {
    private ExpressionSyntax expression;
    private ArgumentListSyntax argumentList;
    public ExpressionSyntax Expression { get; }
    public ArgumentListSyntax ArgumentList { get; }
    internal InvocationExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public ExpressionSyntax get_Expression();
    public ArgumentListSyntax get_ArgumentList();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public InvocationExpressionSyntax Update(ExpressionSyntax expression, ArgumentListSyntax argumentList);
    public InvocationExpressionSyntax WithExpression(ExpressionSyntax expression);
    public InvocationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList);
    public InvocationExpressionSyntax AddArgumentListArguments(ArgumentSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax : QueryClauseSyntax {
    private TypeSyntax type;
    private ExpressionSyntax inExpression;
    private ExpressionSyntax leftExpression;
    private ExpressionSyntax rightExpression;
    private JoinIntoClauseSyntax into;
    public SyntaxToken JoinKeyword { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken Identifier { get; }
    public SyntaxToken InKeyword { get; }
    public ExpressionSyntax InExpression { get; }
    public SyntaxToken OnKeyword { get; }
    public ExpressionSyntax LeftExpression { get; }
    public SyntaxToken EqualsKeyword { get; }
    public ExpressionSyntax RightExpression { get; }
    public JoinIntoClauseSyntax Into { get; }
    internal JoinClauseSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_JoinKeyword();
    public TypeSyntax get_Type();
    public SyntaxToken get_Identifier();
    public SyntaxToken get_InKeyword();
    public ExpressionSyntax get_InExpression();
    public SyntaxToken get_OnKeyword();
    public ExpressionSyntax get_LeftExpression();
    public SyntaxToken get_EqualsKeyword();
    public ExpressionSyntax get_RightExpression();
    public JoinIntoClauseSyntax get_Into();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public JoinClauseSyntax Update(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into);
    public JoinClauseSyntax WithJoinKeyword(SyntaxToken joinKeyword);
    public JoinClauseSyntax WithType(TypeSyntax type);
    public JoinClauseSyntax WithIdentifier(SyntaxToken identifier);
    public JoinClauseSyntax WithInKeyword(SyntaxToken inKeyword);
    public JoinClauseSyntax WithInExpression(ExpressionSyntax inExpression);
    public JoinClauseSyntax WithOnKeyword(SyntaxToken onKeyword);
    public JoinClauseSyntax WithLeftExpression(ExpressionSyntax leftExpression);
    public JoinClauseSyntax WithEqualsKeyword(SyntaxToken equalsKeyword);
    public JoinClauseSyntax WithRightExpression(ExpressionSyntax rightExpression);
    public JoinClauseSyntax WithInto(JoinIntoClauseSyntax into);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax : CSharpSyntaxNode {
    public SyntaxToken IntoKeyword { get; }
    public SyntaxToken Identifier { get; }
    internal JoinIntoClauseSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_IntoKeyword();
    public SyntaxToken get_Identifier();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public JoinIntoClauseSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier);
    public JoinIntoClauseSyntax WithIntoKeyword(SyntaxToken intoKeyword);
    public JoinIntoClauseSyntax WithIdentifier(SyntaxToken identifier);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax : StatementSyntax {
    private StatementSyntax statement;
    public SyntaxToken Identifier { get; }
    public SyntaxToken ColonToken { get; }
    public StatementSyntax Statement { get; }
    internal LabeledStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_Identifier();
    public SyntaxToken get_ColonToken();
    public StatementSyntax get_Statement();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public LabeledStatementSyntax Update(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement);
    public LabeledStatementSyntax WithIdentifier(SyntaxToken identifier);
    public LabeledStatementSyntax WithColonToken(SyntaxToken colonToken);
    public LabeledStatementSyntax WithStatement(StatementSyntax statement);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax : AnonymousFunctionExpressionSyntax {
    public SyntaxToken ArrowToken { get; }
    internal LambdaExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public abstract virtual SyntaxToken get_ArrowToken();
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax : QueryClauseSyntax {
    private ExpressionSyntax expression;
    public SyntaxToken LetKeyword { get; }
    public SyntaxToken Identifier { get; }
    public SyntaxToken EqualsToken { get; }
    public ExpressionSyntax Expression { get; }
    internal LetClauseSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_LetKeyword();
    public SyntaxToken get_Identifier();
    public SyntaxToken get_EqualsToken();
    public ExpressionSyntax get_Expression();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public LetClauseSyntax Update(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression);
    public LetClauseSyntax WithLetKeyword(SyntaxToken letKeyword);
    public LetClauseSyntax WithIdentifier(SyntaxToken identifier);
    public LetClauseSyntax WithEqualsToken(SyntaxToken equalsToken);
    public LetClauseSyntax WithExpression(ExpressionSyntax expression);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken LineKeyword { get; }
    public SyntaxToken Line { get; }
    public SyntaxToken File { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal LineDirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_LineKeyword();
    public SyntaxToken get_Line();
    public SyntaxToken get_File();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public LineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    public LineDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public LineDirectiveTriviaSyntax WithLineKeyword(SyntaxToken lineKeyword);
    public LineDirectiveTriviaSyntax WithLine(SyntaxToken line);
    public LineDirectiveTriviaSyntax WithFile(SyntaxToken file);
    public LineDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public LineDirectiveTriviaSyntax WithIsActive(bool isActive);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax : ExpressionSyntax {
    public SyntaxToken Token { get; }
    internal LiteralExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_Token();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public LiteralExpressionSyntax Update(SyntaxToken token);
    public LiteralExpressionSyntax WithToken(SyntaxToken token);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.LoadDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken LoadKeyword { get; }
    public SyntaxToken File { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal LoadDirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_LoadKeyword();
    public SyntaxToken get_File();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public LoadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    public LoadDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public LoadDirectiveTriviaSyntax WithLoadKeyword(SyntaxToken loadKeyword);
    public LoadDirectiveTriviaSyntax WithFile(SyntaxToken file);
    public LoadDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public LoadDirectiveTriviaSyntax WithIsActive(bool isActive);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax : StatementSyntax {
    private VariableDeclarationSyntax declaration;
    public bool IsConst { get; }
    public SyntaxTokenList Modifiers { get; }
    public VariableDeclarationSyntax Declaration { get; }
    public SyntaxToken SemicolonToken { get; }
    internal LocalDeclarationStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public bool get_IsConst();
    public SyntaxTokenList get_Modifiers();
    public VariableDeclarationSyntax get_Declaration();
    public SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public LocalDeclarationStatementSyntax Update(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    public LocalDeclarationStatementSyntax WithModifiers(SyntaxTokenList modifiers);
    public LocalDeclarationStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration);
    public LocalDeclarationStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);
    public LocalDeclarationStatementSyntax AddModifiers(SyntaxToken[] items);
    public LocalDeclarationStatementSyntax AddDeclarationVariables(VariableDeclaratorSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax : StatementSyntax {
    private ExpressionSyntax expression;
    private StatementSyntax statement;
    public SyntaxToken LockKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    internal LockStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_LockKeyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public LockStatementSyntax Update(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    public LockStatementSyntax WithLockKeyword(SyntaxToken lockKeyword);
    public LockStatementSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public LockStatementSyntax WithExpression(ExpressionSyntax expression);
    public LockStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    public LockStatementSyntax WithStatement(StatementSyntax statement);
}
internal static class Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition : object {
    internal static bool IsInBlock(int position, BlockSyntax blockOpt);
    internal static bool IsInExpressionBody(int position, ArrowExpressionClauseSyntax expressionBodyOpt, SyntaxToken semicolonToken);
    internal static bool IsInBody(int position, PropertyDeclarationSyntax property);
    internal static bool IsInBody(int position, IndexerDeclarationSyntax indexer);
    internal static bool IsInBody(int position, BaseMethodDeclarationSyntax method);
    internal static bool IsBetweenTokens(int position, SyntaxToken firstIncluded, SyntaxToken firstExcluded);
    private static bool IsBeforeToken(int position, CSharpSyntaxNode node, SyntaxToken firstExcluded);
    private static bool IsBeforeToken(int position, SyntaxToken firstExcluded);
    internal static bool IsInAttributeSpecification(int position, SyntaxList`1<AttributeListSyntax> attributesSyntaxList);
    internal static bool IsInTypeParameterList(int position, TypeDeclarationSyntax typeDecl);
    internal static bool IsInParameterList(int position, BaseMethodDeclarationSyntax methodDecl);
    internal static bool IsInMethodDeclaration(int position, BaseMethodDeclarationSyntax methodDecl);
    internal static bool IsInMethodDeclaration(int position, AccessorDeclarationSyntax accessorDecl);
    internal static bool IsInDelegateDeclaration(int position, DelegateDeclarationSyntax delegateDecl);
    internal static bool IsInTypeDeclaration(int position, BaseTypeDeclarationSyntax typeDecl);
    internal static bool IsInNamespaceDeclaration(int position, NamespaceDeclarationSyntax namespaceDecl);
    internal static bool IsInConstructorParameterScope(int position, ConstructorDeclarationSyntax constructorDecl);
    internal static bool IsInMethodTypeParameterScope(int position, MethodDeclarationSyntax methodDecl);
    internal static bool IsInStatementScope(int position, StatementSyntax statement);
    internal static bool IsInCatchBlockScope(int position, CatchClauseSyntax catchClause);
    internal static bool IsInCatchFilterScope(int position, CatchFilterClauseSyntax filterClause);
    private static SyntaxToken GetFirstIncludedToken(StatementSyntax statement, bool inRecursiveCall);
    private static SyntaxToken GetFirstExcludedToken(StatementSyntax statement);
    internal static bool IsInAnonymousFunctionOrQuery(int position, CSharpSyntaxNode lambdaExpressionOrQueryNode);
    internal static bool IsInXmlAttributeValue(int position, XmlAttributeSyntax attribute);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax : ExpressionSyntax {
    private ExpressionSyntax expression;
    public SyntaxToken Keyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    internal MakeRefExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_Keyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public MakeRefExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public MakeRefExpressionSyntax WithKeyword(SyntaxToken keyword);
    public MakeRefExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public MakeRefExpressionSyntax WithExpression(ExpressionSyntax expression);
    public MakeRefExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax : ExpressionSyntax {
    private ExpressionSyntax expression;
    private SimpleNameSyntax name;
    public ExpressionSyntax Expression { get; }
    public SyntaxToken OperatorToken { get; }
    public SimpleNameSyntax Name { get; }
    internal MemberAccessExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_OperatorToken();
    public SimpleNameSyntax get_Name();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public MemberAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name);
    public MemberAccessExpressionSyntax WithExpression(ExpressionSyntax expression);
    public MemberAccessExpressionSyntax WithOperatorToken(SyntaxToken operatorToken);
    public MemberAccessExpressionSyntax WithName(SimpleNameSyntax name);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax : ExpressionSyntax {
    private SimpleNameSyntax name;
    public SyntaxToken OperatorToken { get; }
    public SimpleNameSyntax Name { get; }
    internal MemberBindingExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OperatorToken();
    public SimpleNameSyntax get_Name();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public MemberBindingExpressionSyntax Update(SyntaxToken operatorToken, SimpleNameSyntax name);
    public MemberBindingExpressionSyntax WithOperatorToken(SyntaxToken operatorToken);
    public MemberBindingExpressionSyntax WithName(SimpleNameSyntax name);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax : CrefSyntax {
    internal MemberCrefSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax : CSharpSyntaxNode {
    internal MemberDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax : BaseMethodDeclarationSyntax {
    private CSharpSyntaxNode attributeLists;
    private TypeSyntax returnType;
    private ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private TypeParameterListSyntax typeParameterList;
    private ParameterListSyntax parameterList;
    private CSharpSyntaxNode constraintClauses;
    private BlockSyntax body;
    private ArrowExpressionClauseSyntax expressionBody;
    public int Arity { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public TypeSyntax ReturnType { get; }
    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public ParameterListSyntax ParameterList { get; }
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public BlockSyntax Body { get; }
    public ArrowExpressionClauseSyntax ExpressionBody { get; }
    public SyntaxToken SemicolonToken { get; }
    internal MethodDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public int get_Arity();
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxTokenList get_Modifiers();
    public TypeSyntax get_ReturnType();
    public ExplicitInterfaceSpecifierSyntax get_ExplicitInterfaceSpecifier();
    public SyntaxToken get_Identifier();
    public TypeParameterListSyntax get_TypeParameterList();
    public virtual ParameterListSyntax get_ParameterList();
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public virtual BlockSyntax get_Body();
    public ArrowExpressionClauseSyntax get_ExpressionBody();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public MethodDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public MethodDeclarationSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public MethodDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
    public MethodDeclarationSyntax WithReturnType(TypeSyntax returnType);
    public MethodDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier);
    public MethodDeclarationSyntax WithIdentifier(SyntaxToken identifier);
    public MethodDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList);
    public MethodDeclarationSyntax WithParameterList(ParameterListSyntax parameterList);
    public MethodDeclarationSyntax WithConstraintClauses(SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses);
    public MethodDeclarationSyntax WithBody(BlockSyntax body);
    public MethodDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody);
    public MethodDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
    public MethodDeclarationSyntax AddAttributeLists(AttributeListSyntax[] items);
    public MethodDeclarationSyntax AddModifiers(SyntaxToken[] items);
    public MethodDeclarationSyntax AddTypeParameterListParameters(TypeParameterSyntax[] items);
    public MethodDeclarationSyntax AddParameterListParameters(ParameterSyntax[] items);
    public MethodDeclarationSyntax AddConstraintClauses(TypeParameterConstraintClauseSyntax[] items);
    public MethodDeclarationSyntax AddBodyStatements(StatementSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax : CSharpSyntaxNode {
    private IdentifierNameSyntax name;
    public IdentifierNameSyntax Name { get; }
    public SyntaxToken ColonToken { get; }
    internal NameColonSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public IdentifierNameSyntax get_Name();
    public SyntaxToken get_ColonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public NameColonSyntax Update(IdentifierNameSyntax name, SyntaxToken colonToken);
    public NameColonSyntax WithName(IdentifierNameSyntax name);
    public NameColonSyntax WithColonToken(SyntaxToken colonToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax : CSharpSyntaxNode {
    private IdentifierNameSyntax name;
    public IdentifierNameSyntax Name { get; }
    public SyntaxToken EqualsToken { get; }
    internal NameEqualsSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public IdentifierNameSyntax get_Name();
    public SyntaxToken get_EqualsToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public NameEqualsSyntax Update(IdentifierNameSyntax name, SyntaxToken equalsToken);
    public NameEqualsSyntax WithName(IdentifierNameSyntax name);
    public NameEqualsSyntax WithEqualsToken(SyntaxToken equalsToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax : MemberCrefSyntax {
    private TypeSyntax name;
    private CrefParameterListSyntax parameters;
    public TypeSyntax Name { get; }
    public CrefParameterListSyntax Parameters { get; }
    internal NameMemberCrefSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public TypeSyntax get_Name();
    public CrefParameterListSyntax get_Parameters();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public NameMemberCrefSyntax Update(TypeSyntax name, CrefParameterListSyntax parameters);
    public NameMemberCrefSyntax WithName(TypeSyntax name);
    public NameMemberCrefSyntax WithParameters(CrefParameterListSyntax parameters);
    public NameMemberCrefSyntax AddParametersParameters(CrefParameterSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax : MemberDeclarationSyntax {
    private NameSyntax name;
    private CSharpSyntaxNode externs;
    private CSharpSyntaxNode usings;
    private CSharpSyntaxNode members;
    internal NamespaceDeclarationSyntax Green { get; }
    public SyntaxToken NamespaceKeyword { get; }
    public NameSyntax Name { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxList`1<ExternAliasDirectiveSyntax> Externs { get; }
    public SyntaxList`1<UsingDirectiveSyntax> Usings { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    public SyntaxToken CloseBraceToken { get; }
    public SyntaxToken SemicolonToken { get; }
    internal NamespaceDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    internal NamespaceDeclarationSyntax get_Green();
    public SyntaxToken get_NamespaceKeyword();
    public NameSyntax get_Name();
    public SyntaxToken get_OpenBraceToken();
    public SyntaxList`1<ExternAliasDirectiveSyntax> get_Externs();
    public SyntaxList`1<UsingDirectiveSyntax> get_Usings();
    public SyntaxList`1<MemberDeclarationSyntax> get_Members();
    public SyntaxToken get_CloseBraceToken();
    public SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public NamespaceDeclarationSyntax Update(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList`1<ExternAliasDirectiveSyntax> externs, SyntaxList`1<UsingDirectiveSyntax> usings, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public NamespaceDeclarationSyntax WithNamespaceKeyword(SyntaxToken namespaceKeyword);
    public NamespaceDeclarationSyntax WithName(NameSyntax name);
    public NamespaceDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
    public NamespaceDeclarationSyntax WithExterns(SyntaxList`1<ExternAliasDirectiveSyntax> externs);
    public NamespaceDeclarationSyntax WithUsings(SyntaxList`1<UsingDirectiveSyntax> usings);
    public NamespaceDeclarationSyntax WithMembers(SyntaxList`1<MemberDeclarationSyntax> members);
    public NamespaceDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
    public NamespaceDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
    public NamespaceDeclarationSyntax AddExterns(ExternAliasDirectiveSyntax[] items);
    public NamespaceDeclarationSyntax AddUsings(UsingDirectiveSyntax[] items);
    public NamespaceDeclarationSyntax AddMembers(MemberDeclarationSyntax[] items);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax : TypeSyntax {
    public int Arity { get; }
    internal NameSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public int get_Arity();
    internal abstract virtual SimpleNameSyntax GetUnqualifiedName();
    internal abstract virtual string ErrorDisplayName();
    internal string GetAliasQualifierOpt();
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax : TypeSyntax {
    private TypeSyntax elementType;
    public TypeSyntax ElementType { get; }
    public SyntaxToken QuestionToken { get; }
    internal NullableTypeSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public TypeSyntax get_ElementType();
    public SyntaxToken get_QuestionToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public NullableTypeSyntax Update(TypeSyntax elementType, SyntaxToken questionToken);
    public NullableTypeSyntax WithElementType(TypeSyntax elementType);
    public NullableTypeSyntax WithQuestionToken(SyntaxToken questionToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax : ExpressionSyntax {
    private TypeSyntax type;
    private ArgumentListSyntax argumentList;
    private InitializerExpressionSyntax initializer;
    public SyntaxToken NewKeyword { get; }
    public TypeSyntax Type { get; }
    public ArgumentListSyntax ArgumentList { get; }
    public InitializerExpressionSyntax Initializer { get; }
    internal ObjectCreationExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_NewKeyword();
    public TypeSyntax get_Type();
    public ArgumentListSyntax get_ArgumentList();
    public InitializerExpressionSyntax get_Initializer();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer);
    public ObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword);
    public ObjectCreationExpressionSyntax WithType(TypeSyntax type);
    public ObjectCreationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList);
    public ObjectCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer);
    public ObjectCreationExpressionSyntax AddArgumentListArguments(ArgumentSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax : ExpressionSyntax {
    public SyntaxToken OmittedArraySizeExpressionToken { get; }
    internal OmittedArraySizeExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OmittedArraySizeExpressionToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public OmittedArraySizeExpressionSyntax Update(SyntaxToken omittedArraySizeExpressionToken);
    public OmittedArraySizeExpressionSyntax WithOmittedArraySizeExpressionToken(SyntaxToken omittedArraySizeExpressionToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax : TypeSyntax {
    public SyntaxToken OmittedTypeArgumentToken { get; }
    internal OmittedTypeArgumentSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OmittedTypeArgumentToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public OmittedTypeArgumentSyntax Update(SyntaxToken omittedTypeArgumentToken);
    public OmittedTypeArgumentSyntax WithOmittedTypeArgumentToken(SyntaxToken omittedTypeArgumentToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax : BaseMethodDeclarationSyntax {
    private CSharpSyntaxNode attributeLists;
    private TypeSyntax returnType;
    private ParameterListSyntax parameterList;
    private BlockSyntax body;
    private ArrowExpressionClauseSyntax expressionBody;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public TypeSyntax ReturnType { get; }
    public SyntaxToken OperatorKeyword { get; }
    public SyntaxToken OperatorToken { get; }
    public ParameterListSyntax ParameterList { get; }
    public BlockSyntax Body { get; }
    public ArrowExpressionClauseSyntax ExpressionBody { get; }
    public SyntaxToken SemicolonToken { get; }
    internal OperatorDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxTokenList get_Modifiers();
    public TypeSyntax get_ReturnType();
    public SyntaxToken get_OperatorKeyword();
    public SyntaxToken get_OperatorToken();
    public virtual ParameterListSyntax get_ParameterList();
    public virtual BlockSyntax get_Body();
    public ArrowExpressionClauseSyntax get_ExpressionBody();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public OperatorDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public OperatorDeclarationSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public OperatorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
    public OperatorDeclarationSyntax WithReturnType(TypeSyntax returnType);
    public OperatorDeclarationSyntax WithOperatorKeyword(SyntaxToken operatorKeyword);
    public OperatorDeclarationSyntax WithOperatorToken(SyntaxToken operatorToken);
    public OperatorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList);
    public OperatorDeclarationSyntax WithBody(BlockSyntax body);
    public OperatorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody);
    public OperatorDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
    public OperatorDeclarationSyntax AddAttributeLists(AttributeListSyntax[] items);
    public OperatorDeclarationSyntax AddModifiers(SyntaxToken[] items);
    public OperatorDeclarationSyntax AddParameterListParameters(ParameterSyntax[] items);
    public OperatorDeclarationSyntax AddBodyStatements(StatementSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax : MemberCrefSyntax {
    private CrefParameterListSyntax parameters;
    public SyntaxToken OperatorKeyword { get; }
    public SyntaxToken OperatorToken { get; }
    public CrefParameterListSyntax Parameters { get; }
    internal OperatorMemberCrefSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OperatorKeyword();
    public SyntaxToken get_OperatorToken();
    public CrefParameterListSyntax get_Parameters();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public OperatorMemberCrefSyntax Update(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters);
    public OperatorMemberCrefSyntax WithOperatorKeyword(SyntaxToken operatorKeyword);
    public OperatorMemberCrefSyntax WithOperatorToken(SyntaxToken operatorToken);
    public OperatorMemberCrefSyntax WithParameters(CrefParameterListSyntax parameters);
    public OperatorMemberCrefSyntax AddParametersParameters(CrefParameterSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax : QueryClauseSyntax {
    private SyntaxNode orderings;
    public SyntaxToken OrderByKeyword { get; }
    public SeparatedSyntaxList`1<OrderingSyntax> Orderings { get; }
    internal OrderByClauseSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OrderByKeyword();
    public SeparatedSyntaxList`1<OrderingSyntax> get_Orderings();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public OrderByClauseSyntax Update(SyntaxToken orderByKeyword, SeparatedSyntaxList`1<OrderingSyntax> orderings);
    public OrderByClauseSyntax WithOrderByKeyword(SyntaxToken orderByKeyword);
    public OrderByClauseSyntax WithOrderings(SeparatedSyntaxList`1<OrderingSyntax> orderings);
    public OrderByClauseSyntax AddOrderings(OrderingSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax : CSharpSyntaxNode {
    private ExpressionSyntax expression;
    public ExpressionSyntax Expression { get; }
    public SyntaxToken AscendingOrDescendingKeyword { get; }
    internal OrderingSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_AscendingOrDescendingKeyword();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public OrderingSyntax Update(ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword);
    public OrderingSyntax WithExpression(ExpressionSyntax expression);
    public OrderingSyntax WithAscendingOrDescendingKeyword(SyntaxToken ascendingOrDescendingKeyword);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax : BaseParameterListSyntax {
    private SyntaxNode parameters;
    internal int ParameterCount { get; }
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxList`1<ParameterSyntax> Parameters { get; }
    public SyntaxToken CloseParenToken { get; }
    internal ParameterListSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    internal int get_ParameterCount();
    public SyntaxToken get_OpenParenToken();
    public virtual SeparatedSyntaxList`1<ParameterSyntax> get_Parameters();
    public SyntaxToken get_CloseParenToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList`1<ParameterSyntax> parameters, SyntaxToken closeParenToken);
    public ParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public ParameterListSyntax WithParameters(SeparatedSyntaxList`1<ParameterSyntax> parameters);
    public ParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    public ParameterListSyntax AddParameters(ParameterSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax : CSharpSyntaxNode {
    private CSharpSyntaxNode attributeLists;
    private TypeSyntax type;
    private EqualsValueClauseSyntax default;
    internal bool IsArgList { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken Identifier { get; }
    public EqualsValueClauseSyntax Default { get; }
    internal ParameterSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    internal bool get_IsArgList();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxTokenList get_Modifiers();
    public TypeSyntax get_Type();
    public SyntaxToken get_Identifier();
    public EqualsValueClauseSyntax get_Default();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ParameterSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax default);
    public ParameterSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public ParameterSyntax WithModifiers(SyntaxTokenList modifiers);
    public ParameterSyntax WithType(TypeSyntax type);
    public ParameterSyntax WithIdentifier(SyntaxToken identifier);
    public ParameterSyntax WithDefault(EqualsValueClauseSyntax default);
    public ParameterSyntax AddAttributeLists(AttributeListSyntax[] items);
    public ParameterSyntax AddModifiers(SyntaxToken[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax : ExpressionSyntax {
    private ExpressionSyntax expression;
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    internal ParenthesizedExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public ParenthesizedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public ParenthesizedExpressionSyntax WithExpression(ExpressionSyntax expression);
    public ParenthesizedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax : LambdaExpressionSyntax {
    private ParameterListSyntax parameterList;
    private CSharpSyntaxNode body;
    public SyntaxToken AsyncKeyword { get; }
    public ParameterListSyntax ParameterList { get; }
    public SyntaxToken ArrowToken { get; }
    public CSharpSyntaxNode Body { get; }
    internal ParenthesizedLambdaExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_AsyncKeyword();
    public ParameterListSyntax get_ParameterList();
    public virtual SyntaxToken get_ArrowToken();
    public virtual CSharpSyntaxNode get_Body();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ParenthesizedLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body);
    public ParenthesizedLambdaExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword);
    public ParenthesizedLambdaExpressionSyntax WithParameterList(ParameterListSyntax parameterList);
    public ParenthesizedLambdaExpressionSyntax WithArrowToken(SyntaxToken arrowToken);
    public ParenthesizedLambdaExpressionSyntax WithBody(CSharpSyntaxNode body);
    public ParenthesizedLambdaExpressionSyntax AddParameterListParameters(ParameterSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax : TypeSyntax {
    private TypeSyntax elementType;
    public TypeSyntax ElementType { get; }
    public SyntaxToken AsteriskToken { get; }
    internal PointerTypeSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public TypeSyntax get_ElementType();
    public SyntaxToken get_AsteriskToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public PointerTypeSyntax Update(TypeSyntax elementType, SyntaxToken asteriskToken);
    public PointerTypeSyntax WithElementType(TypeSyntax elementType);
    public PointerTypeSyntax WithAsteriskToken(SyntaxToken asteriskToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax : ExpressionSyntax {
    private ExpressionSyntax operand;
    public ExpressionSyntax Operand { get; }
    public SyntaxToken OperatorToken { get; }
    internal PostfixUnaryExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public ExpressionSyntax get_Operand();
    public SyntaxToken get_OperatorToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public PostfixUnaryExpressionSyntax Update(ExpressionSyntax operand, SyntaxToken operatorToken);
    public PostfixUnaryExpressionSyntax WithOperand(ExpressionSyntax operand);
    public PostfixUnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken PragmaKeyword { get; }
    public SyntaxToken ChecksumKeyword { get; }
    public SyntaxToken File { get; }
    public SyntaxToken Guid { get; }
    public SyntaxToken Bytes { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal PragmaChecksumDirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_PragmaKeyword();
    public SyntaxToken get_ChecksumKeyword();
    public SyntaxToken get_File();
    public SyntaxToken get_Guid();
    public SyntaxToken get_Bytes();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public PragmaChecksumDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive);
    public PragmaChecksumDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public PragmaChecksumDirectiveTriviaSyntax WithPragmaKeyword(SyntaxToken pragmaKeyword);
    public PragmaChecksumDirectiveTriviaSyntax WithChecksumKeyword(SyntaxToken checksumKeyword);
    public PragmaChecksumDirectiveTriviaSyntax WithFile(SyntaxToken file);
    public PragmaChecksumDirectiveTriviaSyntax WithGuid(SyntaxToken guid);
    public PragmaChecksumDirectiveTriviaSyntax WithBytes(SyntaxToken bytes);
    public PragmaChecksumDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public PragmaChecksumDirectiveTriviaSyntax WithIsActive(bool isActive);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    private SyntaxNode errorCodes;
    public SyntaxToken HashToken { get; }
    public SyntaxToken PragmaKeyword { get; }
    public SyntaxToken WarningKeyword { get; }
    public SyntaxToken DisableOrRestoreKeyword { get; }
    public SeparatedSyntaxList`1<ExpressionSyntax> ErrorCodes { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal PragmaWarningDirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_PragmaKeyword();
    public SyntaxToken get_WarningKeyword();
    public SyntaxToken get_DisableOrRestoreKeyword();
    public SeparatedSyntaxList`1<ExpressionSyntax> get_ErrorCodes();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public PragmaWarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList`1<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive);
    public PragmaWarningDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public PragmaWarningDirectiveTriviaSyntax WithPragmaKeyword(SyntaxToken pragmaKeyword);
    public PragmaWarningDirectiveTriviaSyntax WithWarningKeyword(SyntaxToken warningKeyword);
    public PragmaWarningDirectiveTriviaSyntax WithDisableOrRestoreKeyword(SyntaxToken disableOrRestoreKeyword);
    public PragmaWarningDirectiveTriviaSyntax WithErrorCodes(SeparatedSyntaxList`1<ExpressionSyntax> errorCodes);
    public PragmaWarningDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public PragmaWarningDirectiveTriviaSyntax WithIsActive(bool isActive);
    public PragmaWarningDirectiveTriviaSyntax AddErrorCodes(ExpressionSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax : TypeSyntax {
    public SyntaxToken Keyword { get; }
    internal PredefinedTypeSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_Keyword();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public PredefinedTypeSyntax Update(SyntaxToken keyword);
    public PredefinedTypeSyntax WithKeyword(SyntaxToken keyword);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax : ExpressionSyntax {
    private ExpressionSyntax operand;
    public SyntaxToken OperatorToken { get; }
    public ExpressionSyntax Operand { get; }
    internal PrefixUnaryExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_OperatorToken();
    public ExpressionSyntax get_Operand();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public PrefixUnaryExpressionSyntax Update(SyntaxToken operatorToken, ExpressionSyntax operand);
    public PrefixUnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken);
    public PrefixUnaryExpressionSyntax WithOperand(ExpressionSyntax operand);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax : BasePropertyDeclarationSyntax {
    private CSharpSyntaxNode attributeLists;
    private TypeSyntax type;
    private ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private AccessorListSyntax accessorList;
    private ArrowExpressionClauseSyntax expressionBody;
    private EqualsValueClauseSyntax initializer;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public SyntaxToken Semicolon { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public TypeSyntax Type { get; }
    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }
    public SyntaxToken Identifier { get; }
    public AccessorListSyntax AccessorList { get; }
    public ArrowExpressionClauseSyntax ExpressionBody { get; }
    public EqualsValueClauseSyntax Initializer { get; }
    public SyntaxToken SemicolonToken { get; }
    internal PropertyDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_Semicolon();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public PropertyDeclarationSyntax WithSemicolon(SyntaxToken semicolon);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxTokenList get_Modifiers();
    public virtual TypeSyntax get_Type();
    public virtual ExplicitInterfaceSpecifierSyntax get_ExplicitInterfaceSpecifier();
    public SyntaxToken get_Identifier();
    public virtual AccessorListSyntax get_AccessorList();
    public ArrowExpressionClauseSyntax get_ExpressionBody();
    public EqualsValueClauseSyntax get_Initializer();
    public SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public PropertyDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken);
    public PropertyDeclarationSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public PropertyDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
    public PropertyDeclarationSyntax WithType(TypeSyntax type);
    public PropertyDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier);
    public PropertyDeclarationSyntax WithIdentifier(SyntaxToken identifier);
    public PropertyDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList);
    public PropertyDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody);
    public PropertyDeclarationSyntax WithInitializer(EqualsValueClauseSyntax initializer);
    public PropertyDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
    public PropertyDeclarationSyntax AddAttributeLists(AttributeListSyntax[] items);
    public PropertyDeclarationSyntax AddModifiers(SyntaxToken[] items);
    public PropertyDeclarationSyntax AddAccessorListAccessors(AccessorDeclarationSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax : CrefSyntax {
    private TypeSyntax container;
    private MemberCrefSyntax member;
    public TypeSyntax Container { get; }
    public SyntaxToken DotToken { get; }
    public MemberCrefSyntax Member { get; }
    internal QualifiedCrefSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public TypeSyntax get_Container();
    public SyntaxToken get_DotToken();
    public MemberCrefSyntax get_Member();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public QualifiedCrefSyntax Update(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member);
    public QualifiedCrefSyntax WithContainer(TypeSyntax container);
    public QualifiedCrefSyntax WithDotToken(SyntaxToken dotToken);
    public QualifiedCrefSyntax WithMember(MemberCrefSyntax member);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax : NameSyntax {
    private NameSyntax left;
    private SimpleNameSyntax right;
    public NameSyntax Left { get; }
    public SyntaxToken DotToken { get; }
    public SimpleNameSyntax Right { get; }
    internal QualifiedNameSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    internal virtual SimpleNameSyntax GetUnqualifiedName();
    internal virtual string ErrorDisplayName();
    public NameSyntax get_Left();
    public SyntaxToken get_DotToken();
    public SimpleNameSyntax get_Right();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public QualifiedNameSyntax Update(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right);
    public QualifiedNameSyntax WithLeft(NameSyntax left);
    public QualifiedNameSyntax WithDotToken(SyntaxToken dotToken);
    public QualifiedNameSyntax WithRight(SimpleNameSyntax right);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax : CSharpSyntaxNode {
    private CSharpSyntaxNode clauses;
    private SelectOrGroupClauseSyntax selectOrGroup;
    private QueryContinuationSyntax continuation;
    public SyntaxList`1<QueryClauseSyntax> Clauses { get; }
    public SelectOrGroupClauseSyntax SelectOrGroup { get; }
    public QueryContinuationSyntax Continuation { get; }
    internal QueryBodySyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxList`1<QueryClauseSyntax> get_Clauses();
    public SelectOrGroupClauseSyntax get_SelectOrGroup();
    public QueryContinuationSyntax get_Continuation();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public QueryBodySyntax Update(SyntaxList`1<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation);
    public QueryBodySyntax WithClauses(SyntaxList`1<QueryClauseSyntax> clauses);
    public QueryBodySyntax WithSelectOrGroup(SelectOrGroupClauseSyntax selectOrGroup);
    public QueryBodySyntax WithContinuation(QueryContinuationSyntax continuation);
    public QueryBodySyntax AddClauses(QueryClauseSyntax[] items);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax : CSharpSyntaxNode {
    internal QueryClauseSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax : CSharpSyntaxNode {
    private QueryBodySyntax body;
    public SyntaxToken IntoKeyword { get; }
    public SyntaxToken Identifier { get; }
    public QueryBodySyntax Body { get; }
    internal QueryContinuationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_IntoKeyword();
    public SyntaxToken get_Identifier();
    public QueryBodySyntax get_Body();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public QueryContinuationSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body);
    public QueryContinuationSyntax WithIntoKeyword(SyntaxToken intoKeyword);
    public QueryContinuationSyntax WithIdentifier(SyntaxToken identifier);
    public QueryContinuationSyntax WithBody(QueryBodySyntax body);
    public QueryContinuationSyntax AddBodyClauses(QueryClauseSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax : ExpressionSyntax {
    private FromClauseSyntax fromClause;
    private QueryBodySyntax body;
    public FromClauseSyntax FromClause { get; }
    public QueryBodySyntax Body { get; }
    internal QueryExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public FromClauseSyntax get_FromClause();
    public QueryBodySyntax get_Body();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public QueryExpressionSyntax Update(FromClauseSyntax fromClause, QueryBodySyntax body);
    public QueryExpressionSyntax WithFromClause(FromClauseSyntax fromClause);
    public QueryExpressionSyntax WithBody(QueryBodySyntax body);
    public QueryExpressionSyntax AddBodyClauses(QueryClauseSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken ReferenceKeyword { get; }
    public SyntaxToken File { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal ReferenceDirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_ReferenceKeyword();
    public SyntaxToken get_File();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ReferenceDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    public ReferenceDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public ReferenceDirectiveTriviaSyntax WithReferenceKeyword(SyntaxToken referenceKeyword);
    public ReferenceDirectiveTriviaSyntax WithFile(SyntaxToken file);
    public ReferenceDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public ReferenceDirectiveTriviaSyntax WithIsActive(bool isActive);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax : ExpressionSyntax {
    private ExpressionSyntax expression;
    public SyntaxToken Keyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    internal RefTypeExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_Keyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public RefTypeExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public RefTypeExpressionSyntax WithKeyword(SyntaxToken keyword);
    public RefTypeExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public RefTypeExpressionSyntax WithExpression(ExpressionSyntax expression);
    public RefTypeExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax : ExpressionSyntax {
    private ExpressionSyntax expression;
    private TypeSyntax type;
    public SyntaxToken Keyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken Comma { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken CloseParenToken { get; }
    internal RefValueExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_Keyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_Comma();
    public TypeSyntax get_Type();
    public SyntaxToken get_CloseParenToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public RefValueExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken);
    public RefValueExpressionSyntax WithKeyword(SyntaxToken keyword);
    public RefValueExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public RefValueExpressionSyntax WithExpression(ExpressionSyntax expression);
    public RefValueExpressionSyntax WithComma(SyntaxToken comma);
    public RefValueExpressionSyntax WithType(TypeSyntax type);
    public RefValueExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken RegionKeyword { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal RegionDirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_RegionKeyword();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public RegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public RegionDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public RegionDirectiveTriviaSyntax WithRegionKeyword(SyntaxToken regionKeyword);
    public RegionDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public RegionDirectiveTriviaSyntax WithIsActive(bool isActive);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax : StatementSyntax {
    private ExpressionSyntax expression;
    public SyntaxToken ReturnKeyword { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken SemicolonToken { get; }
    internal ReturnStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_ReturnKeyword();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ReturnStatementSyntax Update(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    public ReturnStatementSyntax WithReturnKeyword(SyntaxToken returnKeyword);
    public ReturnStatementSyntax WithExpression(ExpressionSyntax expression);
    public ReturnStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax : SelectOrGroupClauseSyntax {
    private ExpressionSyntax expression;
    public SyntaxToken SelectKeyword { get; }
    public ExpressionSyntax Expression { get; }
    internal SelectClauseSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_SelectKeyword();
    public ExpressionSyntax get_Expression();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public SelectClauseSyntax Update(SyntaxToken selectKeyword, ExpressionSyntax expression);
    public SelectClauseSyntax WithSelectKeyword(SyntaxToken selectKeyword);
    public SelectClauseSyntax WithExpression(ExpressionSyntax expression);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax : CSharpSyntaxNode {
    internal SelectOrGroupClauseSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.SeparatedSyntaxListBuilder`1 : ValueType {
    private SyntaxListBuilder _builder;
    private bool _expectedSeparator;
    public bool IsNull { get; }
    public int Count { get; }
    public SeparatedSyntaxListBuilder`1(int size);
    internal SeparatedSyntaxListBuilder`1(SyntaxListBuilder builder);
    public static SeparatedSyntaxListBuilder`1<TNode> Create();
    public bool get_IsNull();
    public int get_Count();
    public void Clear();
    private void CheckExpectedElement();
    private void CheckExpectedSeparator();
    public SeparatedSyntaxListBuilder`1<TNode> Add(TNode node);
    public SeparatedSyntaxListBuilder`1<TNode> AddSeparator(SyntaxToken separatorToken);
    public SeparatedSyntaxListBuilder`1<TNode> AddRange(SeparatedSyntaxList`1<TNode> nodes);
    public SeparatedSyntaxListBuilder`1<TNode> AddRange(SeparatedSyntaxList`1<TNode> nodes, int count);
    public SeparatedSyntaxList`1<TNode> ToList();
    public SeparatedSyntaxList`1<TDerived> ToList();
    public static SyntaxListBuilder op_Implicit(SeparatedSyntaxListBuilder`1<TNode> builder);
    public static SeparatedSyntaxList`1<TNode> op_Implicit(SeparatedSyntaxListBuilder`1<TNode> builder);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ShebangDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken ExclamationToken { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal ShebangDirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_ExclamationToken();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ShebangDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive);
    public ShebangDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public ShebangDirectiveTriviaSyntax WithExclamationToken(SyntaxToken exclamationToken);
    public ShebangDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public ShebangDirectiveTriviaSyntax WithIsActive(bool isActive);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax : BaseTypeSyntax {
    private TypeSyntax type;
    public TypeSyntax Type { get; }
    internal SimpleBaseTypeSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual TypeSyntax get_Type();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public SimpleBaseTypeSyntax Update(TypeSyntax type);
    public SimpleBaseTypeSyntax WithType(TypeSyntax type);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax : LambdaExpressionSyntax {
    private ParameterSyntax parameter;
    private CSharpSyntaxNode body;
    public SyntaxToken AsyncKeyword { get; }
    public ParameterSyntax Parameter { get; }
    public SyntaxToken ArrowToken { get; }
    public CSharpSyntaxNode Body { get; }
    internal SimpleLambdaExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_AsyncKeyword();
    public ParameterSyntax get_Parameter();
    public virtual SyntaxToken get_ArrowToken();
    public virtual CSharpSyntaxNode get_Body();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public SimpleLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body);
    public SimpleLambdaExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword);
    public SimpleLambdaExpressionSyntax WithParameter(ParameterSyntax parameter);
    public SimpleLambdaExpressionSyntax WithArrowToken(SyntaxToken arrowToken);
    public SimpleLambdaExpressionSyntax WithBody(CSharpSyntaxNode body);
    public SimpleLambdaExpressionSyntax AddParameterAttributeLists(AttributeListSyntax[] items);
    public SimpleLambdaExpressionSyntax AddParameterModifiers(SyntaxToken[] items);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax : NameSyntax {
    public SyntaxToken Identifier { get; }
    internal SimpleNameSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    internal sealed virtual SimpleNameSyntax GetUnqualifiedName();
    public abstract virtual SyntaxToken get_Identifier();
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax : ExpressionSyntax {
    private TypeSyntax type;
    public SyntaxToken Keyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken CloseParenToken { get; }
    internal SizeOfExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_Keyword();
    public SyntaxToken get_OpenParenToken();
    public TypeSyntax get_Type();
    public SyntaxToken get_CloseParenToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public SizeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    public SizeOfExpressionSyntax WithKeyword(SyntaxToken keyword);
    public SizeOfExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public SizeOfExpressionSyntax WithType(TypeSyntax type);
    public SizeOfExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax : StructuredTriviaSyntax {
    public SyntaxTokenList Tokens { get; }
    internal SkippedTokensTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public sealed virtual SyntaxTokenList get_Tokens();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public SkippedTokensTriviaSyntax Update(SyntaxTokenList tokens);
    public SkippedTokensTriviaSyntax WithTokens(SyntaxTokenList tokens);
    public SkippedTokensTriviaSyntax AddTokens(SyntaxToken[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax : ExpressionSyntax {
    private TypeSyntax type;
    public SyntaxToken StackAllocKeyword { get; }
    public TypeSyntax Type { get; }
    internal StackAllocArrayCreationExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_StackAllocKeyword();
    public TypeSyntax get_Type();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public StackAllocArrayCreationExpressionSyntax Update(SyntaxToken stackAllocKeyword, TypeSyntax type);
    public StackAllocArrayCreationExpressionSyntax WithStackAllocKeyword(SyntaxToken stackAllocKeyword);
    public StackAllocArrayCreationExpressionSyntax WithType(TypeSyntax type);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax : CSharpSyntaxNode {
    internal StatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax : TypeDeclarationSyntax {
    private CSharpSyntaxNode attributeLists;
    private TypeParameterListSyntax typeParameterList;
    private BaseListSyntax baseList;
    private CSharpSyntaxNode constraintClauses;
    private CSharpSyntaxNode members;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken Keyword { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public BaseListSyntax BaseList { get; }
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    public SyntaxToken CloseBraceToken { get; }
    public SyntaxToken SemicolonToken { get; }
    internal StructDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public virtual SyntaxTokenList get_Modifiers();
    public virtual SyntaxToken get_Keyword();
    public virtual SyntaxToken get_Identifier();
    public virtual TypeParameterListSyntax get_TypeParameterList();
    public virtual BaseListSyntax get_BaseList();
    public virtual SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public virtual SyntaxToken get_OpenBraceToken();
    public virtual SyntaxList`1<MemberDeclarationSyntax> get_Members();
    public virtual SyntaxToken get_CloseBraceToken();
    public virtual SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public StructDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public StructDeclarationSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public StructDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
    public StructDeclarationSyntax WithKeyword(SyntaxToken keyword);
    public StructDeclarationSyntax WithIdentifier(SyntaxToken identifier);
    public StructDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList);
    public StructDeclarationSyntax WithBaseList(BaseListSyntax baseList);
    public StructDeclarationSyntax WithConstraintClauses(SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses);
    public StructDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
    public StructDeclarationSyntax WithMembers(SyntaxList`1<MemberDeclarationSyntax> members);
    public StructDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
    public StructDeclarationSyntax WithSemicolonToken(SyntaxToken semicolonToken);
    public StructDeclarationSyntax AddAttributeLists(AttributeListSyntax[] items);
    public StructDeclarationSyntax AddModifiers(SyntaxToken[] items);
    public StructDeclarationSyntax AddTypeParameterListParameters(TypeParameterSyntax[] items);
    public StructDeclarationSyntax AddBaseListTypes(BaseTypeSyntax[] items);
    public StructDeclarationSyntax AddConstraintClauses(TypeParameterConstraintClauseSyntax[] items);
    public StructDeclarationSyntax AddMembers(MemberDeclarationSyntax[] items);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.StructuredTriviaSyntax : CSharpSyntaxNode {
    private SyntaxTrivia _parent;
    public SyntaxTrivia ParentTrivia { get; }
    internal StructuredTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    internal static StructuredTriviaSyntax Create(SyntaxTrivia trivia);
    public virtual SyntaxTrivia get_ParentTrivia();
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax : CSharpSyntaxNode {
    public SyntaxToken Keyword { get; }
    public SyntaxToken ColonToken { get; }
    internal SwitchLabelSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public abstract virtual SyntaxToken get_Keyword();
    public abstract virtual SyntaxToken get_ColonToken();
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax : CSharpSyntaxNode {
    private CSharpSyntaxNode labels;
    private CSharpSyntaxNode statements;
    public SyntaxList`1<SwitchLabelSyntax> Labels { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    internal SwitchSectionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxList`1<SwitchLabelSyntax> get_Labels();
    public SyntaxList`1<StatementSyntax> get_Statements();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public SwitchSectionSyntax Update(SyntaxList`1<SwitchLabelSyntax> labels, SyntaxList`1<StatementSyntax> statements);
    public SwitchSectionSyntax WithLabels(SyntaxList`1<SwitchLabelSyntax> labels);
    public SwitchSectionSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public SwitchSectionSyntax AddLabels(SwitchLabelSyntax[] items);
    public SwitchSectionSyntax AddStatements(StatementSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax : StatementSyntax {
    private ExpressionSyntax expression;
    private CSharpSyntaxNode sections;
    public SyntaxToken SwitchKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SyntaxList`1<SwitchSectionSyntax> Sections { get; }
    public SyntaxToken CloseBraceToken { get; }
    internal SwitchStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_SwitchKeyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    public SyntaxToken get_OpenBraceToken();
    public SyntaxList`1<SwitchSectionSyntax> get_Sections();
    public SyntaxToken get_CloseBraceToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public SwitchStatementSyntax Update(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList`1<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken);
    public SwitchStatementSyntax WithSwitchKeyword(SyntaxToken switchKeyword);
    public SwitchStatementSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public SwitchStatementSyntax WithExpression(ExpressionSyntax expression);
    public SwitchStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    public SwitchStatementSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
    public SwitchStatementSyntax WithSections(SyntaxList`1<SwitchSectionSyntax> sections);
    public SwitchStatementSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
    public SwitchStatementSyntax AddSections(SwitchSectionSyntax[] items);
}
internal static class Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxEquivalence : object {
    internal static bool AreEquivalent(SyntaxTree before, SyntaxTree after, Func`2<SyntaxKind, bool> ignoreChildNode, bool topLevel);
    public static bool AreEquivalent(SyntaxNode before, SyntaxNode after, Func`2<SyntaxKind, bool> ignoreChildNode, bool topLevel);
    public static bool AreEquivalent(SyntaxTokenList before, SyntaxTokenList after);
    public static bool AreEquivalent(SyntaxToken before, SyntaxToken after);
    private static bool AreTokensEquivalent(GreenNode before, GreenNode after);
    private static bool AreEquivalentRecursive(GreenNode before, GreenNode after, Func`2<SyntaxKind, bool> ignoreChildNode, bool topLevel);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxList : CSharpSyntaxNode {
    internal SyntaxList(SyntaxList green, SyntaxNode parent, int position);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxListBuilder : object {
    private ArrayElement`1[] _nodes;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; private set; }
    public SyntaxListBuilder(int size);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public void Clear();
    public void Add(SyntaxNode item);
    internal void AddInternal(GreenNode item);
    public void AddRange(SyntaxNode[] items);
    public void AddRange(SyntaxNode[] items, int offset, int length);
    private void Validate(int start, int end);
    public void AddRange(SyntaxList`1<SyntaxNode> list);
    public void AddRange(SyntaxList`1<SyntaxNode> list, int offset, int count);
    public void AddRange(SyntaxList`1<TNode> list);
    public void AddRange(SyntaxList`1<TNode> list, int offset, int count);
    public void AddRange(SyntaxNodeOrTokenList list);
    public void AddRange(SyntaxNodeOrTokenList list, int offset, int count);
    public void AddRange(SyntaxTokenList list);
    public void AddRange(SyntaxTokenList list, int offset, int length);
    private void Grow(int size);
    public bool Any(SyntaxKind kind);
    internal CSharpSyntaxNode ToListNode();
    public static SyntaxList`1<SyntaxNode> op_Implicit(SyntaxListBuilder builder);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxListBuilder`1 : ValueType {
    private SyntaxListBuilder _builder;
    public bool IsNull { get; }
    public int Count { get; }
    public SyntaxListBuilder`1(int size);
    internal SyntaxListBuilder`1(SyntaxListBuilder builder);
    public static SyntaxListBuilder`1<TNode> Create();
    public bool get_IsNull();
    public int get_Count();
    public void Clear();
    public SyntaxListBuilder`1<TNode> Add(TNode node);
    public void AddRange(TNode[] items, int offset, int length);
    public void AddRange(SyntaxList`1<TNode> nodes);
    public void AddRange(SyntaxList`1<TNode> nodes, int offset, int length);
    public bool Any(SyntaxKind kind);
    public SyntaxList`1<TNode> ToList();
    public static SyntaxListBuilder op_Implicit(SyntaxListBuilder`1<TNode> builder);
    public static SyntaxList`1<TNode> op_Implicit(SyntaxListBuilder`1<TNode> builder);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxListBuilderExtensions : object {
    [ExtensionAttribute]
public static SyntaxTokenList ToTokenList(SyntaxListBuilder builder);
    [ExtensionAttribute]
public static SyntaxList`1<SyntaxNode> ToList(SyntaxListBuilder builder);
    [ExtensionAttribute]
public static SeparatedSyntaxList`1<TNode> ToSeparatedList(SyntaxListBuilder builder);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxNavigator : AbstractSyntaxNavigator {
    public static AbstractSyntaxNavigator Instance;
    private static Func`2[] s_stepIntoFunctions;
    private static SyntaxNavigator();
    protected virtual Func`2<SyntaxTrivia, bool> GetStepIntoFunction(bool skipped, bool directives, bool docComments);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxNodeOrTokenListBuilder : object {
    private CSharpSyntaxNode[] _nodes;
    private int _count;
    public int Count { get; }
    public SyntaxNodeOrToken Item { get; public set; }
    public SyntaxNodeOrTokenListBuilder(int size);
    public int get_Count();
    public void Clear();
    public SyntaxNodeOrToken get_Item(int index);
    public void set_Item(int index, SyntaxNodeOrToken value);
    internal void Add(CSharpSyntaxNode item);
    public void Add(SyntaxNodeOrToken item);
    public void Add(SyntaxNodeOrTokenList list);
    public void Add(SyntaxNodeOrTokenList list, int offset, int length);
    public void Add(IEnumerable`1<SyntaxNodeOrToken> nodeOrTokens);
    internal void RemoveLast();
    private void Grow(int size);
    public SyntaxNodeOrTokenList ToList();
}
internal static class Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxNodeRemover : object {
    internal static TRoot RemoveNodes(TRoot root, IEnumerable`1<SyntaxNode> nodes, SyntaxRemoveOptions options);
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxNormalizer : CSharpSyntaxRewriter {
    private TextSpan _consideredSpan;
    private int _initialDepth;
    private string _indentWhitespace;
    private bool _useElasticTrivia;
    private SyntaxTrivia _eolTrivia;
    private bool _isInStructuredTrivia;
    private SyntaxToken _previousToken;
    private bool _afterLineBreak;
    private bool _afterIndentation;
    private ArrayBuilder`1<SyntaxTrivia> _indentations;
    private static SyntaxTrivia s_trimmedDocCommentExterior;
    private SyntaxNormalizer(TextSpan consideredSpan, int initialDepth, string indentWhitespace, string eolWhitespace, bool useElasticTrivia);
    private static SyntaxNormalizer();
    internal static TNode Normalize(TNode node, string indentWhitespace, string eolWhitespace, bool useElasticTrivia);
    internal static SyntaxToken Normalize(SyntaxToken token, string indentWhitespace, string eolWhitespace, bool useElasticTrivia);
    internal static SyntaxTriviaList Normalize(SyntaxTriviaList trivia, string indentWhitespace, string eolWhitespace, bool useElasticTrivia);
    private void Free();
    public virtual SyntaxToken VisitToken(SyntaxToken token);
    private SyntaxToken GetNextRelevantToken(SyntaxToken token);
    private SyntaxTrivia GetIndentation(int count);
    private static bool NeedsIndentAfterLineBreak(SyntaxToken token);
    private int LineBreaksAfter(SyntaxToken currentToken, SyntaxToken nextToken);
    private static int LineBreaksAfterOpenBrace(SyntaxToken currentToken, SyntaxToken nextToken);
    private static int LineBreaksAfterCloseBrace(SyntaxToken currentToken, SyntaxToken nextToken);
    private static int LineBreaksAfterSemicolon(SyntaxToken currentToken, SyntaxToken nextToken);
    private bool NeedsSeparator(SyntaxToken token, SyntaxToken next);
    private static bool IsXmlTextToken(SyntaxKind kind);
    private static bool BinaryTokenNeedsSeparator(SyntaxKind kind);
    private static bool AssignmentTokenNeedsSeparator(SyntaxKind kind);
    private SyntaxTriviaList RewriteTrivia(SyntaxTriviaList triviaList, int depth, bool isTrailing, bool indentAfterLineBreak, bool mustHaveSeparator, int lineBreaksAfter);
    private SyntaxTrivia GetSpace();
    private SyntaxTrivia GetEndOfLine();
    private SyntaxTrivia VisitStructuredTrivia(SyntaxTrivia trivia);
    private static bool NeedsSeparatorBetween(SyntaxTrivia trivia);
    private static bool NeedsLineBreakBetween(SyntaxTrivia trivia, SyntaxTrivia next, bool isTrailingTrivia);
    private static bool NeedsLineBreakBefore(SyntaxTrivia trivia, bool isTrailingTrivia);
    private static bool NeedsLineBreakAfter(SyntaxTrivia trivia, bool isTrailingTrivia);
    private static bool NeedsIndentAfterLineBreak(SyntaxTrivia trivia);
    private static bool IsLineBreak(SyntaxToken token);
    private static bool EndsInLineBreak(SyntaxTrivia trivia);
    private static bool IsWord(SyntaxKind kind);
    private static bool IsKeyword(SyntaxKind kind);
    private static bool TokenCharacterCanBeDoubled(char c);
    private static int GetDeclarationDepth(SyntaxToken token);
    private static int GetDeclarationDepth(SyntaxTrivia trivia);
    private static int GetDeclarationDepth(SyntaxNode node);
}
internal static class Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxReplacer : object {
    internal static SyntaxNode Replace(SyntaxNode root, IEnumerable`1<TNode> nodes, Func`3<TNode, TNode, SyntaxNode> computeReplacementNode, IEnumerable`1<SyntaxToken> tokens, Func`3<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken, IEnumerable`1<SyntaxTrivia> trivia, Func`3<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia);
    internal static SyntaxToken Replace(SyntaxToken root, IEnumerable`1<SyntaxNode> nodes, Func`3<SyntaxNode, SyntaxNode, SyntaxNode> computeReplacementNode, IEnumerable`1<SyntaxToken> tokens, Func`3<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken, IEnumerable`1<SyntaxTrivia> trivia, Func`3<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia);
    internal static SyntaxNode ReplaceNodeInList(SyntaxNode root, SyntaxNode originalNode, IEnumerable`1<SyntaxNode> newNodes);
    internal static SyntaxNode InsertNodeInList(SyntaxNode root, SyntaxNode nodeInList, IEnumerable`1<SyntaxNode> nodesToInsert, bool insertBefore);
    public static SyntaxNode ReplaceTokenInList(SyntaxNode root, SyntaxToken tokenInList, IEnumerable`1<SyntaxToken> newTokens);
    public static SyntaxNode InsertTokenInList(SyntaxNode root, SyntaxToken tokenInList, IEnumerable`1<SyntaxToken> newTokens, bool insertBefore);
    public static SyntaxNode ReplaceTriviaInList(SyntaxNode root, SyntaxTrivia triviaInList, IEnumerable`1<SyntaxTrivia> newTrivia);
    public static SyntaxNode InsertTriviaInList(SyntaxNode root, SyntaxTrivia triviaInList, IEnumerable`1<SyntaxTrivia> newTrivia, bool insertBefore);
    public static SyntaxToken ReplaceTriviaInList(SyntaxToken root, SyntaxTrivia triviaInList, IEnumerable`1<SyntaxTrivia> newTrivia);
    public static SyntaxToken InsertTriviaInList(SyntaxToken root, SyntaxTrivia triviaInList, IEnumerable`1<SyntaxTrivia> newTrivia, bool insertBefore);
    private static InvalidOperationException GetItemNotListElementException();
}
internal class Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxTokenListBuilder : object {
    private CSharpSyntaxNode[] _nodes;
    private int _count;
    public int Count { get; }
    public SyntaxTokenListBuilder(int size);
    public static SyntaxTokenListBuilder Create();
    public int get_Count();
    public void Add(SyntaxToken item);
    internal void Add(SyntaxToken item);
    public void Add(SyntaxTokenList list);
    public void Add(SyntaxTokenList list, int offset, int length);
    public void Add(SyntaxToken[] list);
    public void Add(SyntaxToken[] list, int offset, int length);
    private void CheckSpace(int delta);
    private void Grow(int newSize);
    public SyntaxTokenList ToList();
    public static SyntaxTokenList op_Implicit(SyntaxTokenListBuilder builder);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxTriviaListBuilder : object {
    private SyntaxTrivia[] _nodes;
    private int _count;
    private SyntaxTrivia[] _previous;
    public int Count { get; }
    public SyntaxTrivia Item { get; }
    public SyntaxTriviaListBuilder(int size);
    public static SyntaxTriviaListBuilder Create();
    public int get_Count();
    public void Clear();
    public SyntaxTrivia get_Item(int index);
    public SyntaxTriviaListBuilder Add(SyntaxTrivia item);
    public void Add(SyntaxTrivia[] items);
    public void Add(SyntaxTrivia[] items, int offset, int length);
    public void Add(SyntaxTriviaList list);
    public void Add(SyntaxTriviaList list, int offset, int length);
    private void Grow(int size);
    public static SyntaxTriviaList op_Implicit(SyntaxTriviaListBuilder builder);
    public SyntaxTriviaList ToList();
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax : InstanceExpressionSyntax {
    public SyntaxToken Token { get; }
    internal ThisExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_Token();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ThisExpressionSyntax Update(SyntaxToken token);
    public ThisExpressionSyntax WithToken(SyntaxToken token);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax : StatementSyntax {
    private ExpressionSyntax expression;
    public SyntaxToken ThrowKeyword { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken SemicolonToken { get; }
    internal ThrowStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_ThrowKeyword();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public ThrowStatementSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    public ThrowStatementSyntax WithThrowKeyword(SyntaxToken throwKeyword);
    public ThrowStatementSyntax WithExpression(ExpressionSyntax expression);
    public ThrowStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax : StatementSyntax {
    private BlockSyntax block;
    private CSharpSyntaxNode catches;
    private FinallyClauseSyntax finally;
    public SyntaxToken TryKeyword { get; }
    public BlockSyntax Block { get; }
    public SyntaxList`1<CatchClauseSyntax> Catches { get; }
    public FinallyClauseSyntax Finally { get; }
    internal TryStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_TryKeyword();
    public BlockSyntax get_Block();
    public SyntaxList`1<CatchClauseSyntax> get_Catches();
    public FinallyClauseSyntax get_Finally();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public TryStatementSyntax Update(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList`1<CatchClauseSyntax> catches, FinallyClauseSyntax finally);
    public TryStatementSyntax WithTryKeyword(SyntaxToken tryKeyword);
    public TryStatementSyntax WithBlock(BlockSyntax block);
    public TryStatementSyntax WithCatches(SyntaxList`1<CatchClauseSyntax> catches);
    public TryStatementSyntax WithFinally(FinallyClauseSyntax finally);
    public TryStatementSyntax AddBlockStatements(StatementSyntax[] items);
    public TryStatementSyntax AddCatches(CatchClauseSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax : CSharpSyntaxNode {
    private SyntaxNode arguments;
    public SyntaxToken LessThanToken { get; }
    public SeparatedSyntaxList`1<TypeSyntax> Arguments { get; }
    public SyntaxToken GreaterThanToken { get; }
    internal TypeArgumentListSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_LessThanToken();
    public SeparatedSyntaxList`1<TypeSyntax> get_Arguments();
    public SyntaxToken get_GreaterThanToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public TypeArgumentListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList`1<TypeSyntax> arguments, SyntaxToken greaterThanToken);
    public TypeArgumentListSyntax WithLessThanToken(SyntaxToken lessThanToken);
    public TypeArgumentListSyntax WithArguments(SeparatedSyntaxList`1<TypeSyntax> arguments);
    public TypeArgumentListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken);
    public TypeArgumentListSyntax AddArguments(TypeSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax : TypeParameterConstraintSyntax {
    private TypeSyntax type;
    public TypeSyntax Type { get; }
    internal TypeConstraintSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public TypeSyntax get_Type();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public TypeConstraintSyntax Update(TypeSyntax type);
    public TypeConstraintSyntax WithType(TypeSyntax type);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax : CrefSyntax {
    private TypeSyntax type;
    public TypeSyntax Type { get; }
    internal TypeCrefSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public TypeSyntax get_Type();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public TypeCrefSyntax Update(TypeSyntax type);
    public TypeCrefSyntax WithType(TypeSyntax type);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax : BaseTypeDeclarationSyntax {
    public int Arity { get; }
    public SyntaxToken Keyword { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public SyntaxList`1<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public SyntaxList`1<MemberDeclarationSyntax> Members { get; }
    internal TypeDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public int get_Arity();
    public abstract virtual SyntaxToken get_Keyword();
    public abstract virtual TypeParameterListSyntax get_TypeParameterList();
    public abstract virtual SyntaxList`1<TypeParameterConstraintClauseSyntax> get_ConstraintClauses();
    public abstract virtual SyntaxList`1<MemberDeclarationSyntax> get_Members();
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax : ExpressionSyntax {
    private TypeSyntax type;
    public SyntaxToken Keyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken CloseParenToken { get; }
    internal TypeOfExpressionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_Keyword();
    public SyntaxToken get_OpenParenToken();
    public TypeSyntax get_Type();
    public SyntaxToken get_CloseParenToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public TypeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    public TypeOfExpressionSyntax WithKeyword(SyntaxToken keyword);
    public TypeOfExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public TypeOfExpressionSyntax WithType(TypeSyntax type);
    public TypeOfExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax : CSharpSyntaxNode {
    private IdentifierNameSyntax name;
    private SyntaxNode constraints;
    public SyntaxToken WhereKeyword { get; }
    public IdentifierNameSyntax Name { get; }
    public SyntaxToken ColonToken { get; }
    public SeparatedSyntaxList`1<TypeParameterConstraintSyntax> Constraints { get; }
    internal TypeParameterConstraintClauseSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_WhereKeyword();
    public IdentifierNameSyntax get_Name();
    public SyntaxToken get_ColonToken();
    public SeparatedSyntaxList`1<TypeParameterConstraintSyntax> get_Constraints();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public TypeParameterConstraintClauseSyntax Update(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList`1<TypeParameterConstraintSyntax> constraints);
    public TypeParameterConstraintClauseSyntax WithWhereKeyword(SyntaxToken whereKeyword);
    public TypeParameterConstraintClauseSyntax WithName(IdentifierNameSyntax name);
    public TypeParameterConstraintClauseSyntax WithColonToken(SyntaxToken colonToken);
    public TypeParameterConstraintClauseSyntax WithConstraints(SeparatedSyntaxList`1<TypeParameterConstraintSyntax> constraints);
    public TypeParameterConstraintClauseSyntax AddConstraints(TypeParameterConstraintSyntax[] items);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax : CSharpSyntaxNode {
    internal TypeParameterConstraintSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax : CSharpSyntaxNode {
    private SyntaxNode parameters;
    public SyntaxToken LessThanToken { get; }
    public SeparatedSyntaxList`1<TypeParameterSyntax> Parameters { get; }
    public SyntaxToken GreaterThanToken { get; }
    internal TypeParameterListSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_LessThanToken();
    public SeparatedSyntaxList`1<TypeParameterSyntax> get_Parameters();
    public SyntaxToken get_GreaterThanToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public TypeParameterListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList`1<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken);
    public TypeParameterListSyntax WithLessThanToken(SyntaxToken lessThanToken);
    public TypeParameterListSyntax WithParameters(SeparatedSyntaxList`1<TypeParameterSyntax> parameters);
    public TypeParameterListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken);
    public TypeParameterListSyntax AddParameters(TypeParameterSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax : CSharpSyntaxNode {
    private CSharpSyntaxNode attributeLists;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxToken VarianceKeyword { get; }
    public SyntaxToken Identifier { get; }
    internal TypeParameterSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SyntaxToken get_VarianceKeyword();
    public SyntaxToken get_Identifier();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public TypeParameterSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier);
    public TypeParameterSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public TypeParameterSyntax WithVarianceKeyword(SyntaxToken varianceKeyword);
    public TypeParameterSyntax WithIdentifier(SyntaxToken identifier);
    public TypeParameterSyntax AddAttributeLists(AttributeListSyntax[] items);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax : ExpressionSyntax {
    public bool IsVar { get; }
    internal TypeSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public bool get_IsVar();
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken UndefKeyword { get; }
    public SyntaxToken Name { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal UndefDirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_UndefKeyword();
    public SyntaxToken get_Name();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public UndefDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive);
    public UndefDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public UndefDirectiveTriviaSyntax WithUndefKeyword(SyntaxToken undefKeyword);
    public UndefDirectiveTriviaSyntax WithName(SyntaxToken name);
    public UndefDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public UndefDirectiveTriviaSyntax WithIsActive(bool isActive);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax : StatementSyntax {
    private BlockSyntax block;
    public SyntaxToken UnsafeKeyword { get; }
    public BlockSyntax Block { get; }
    internal UnsafeStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_UnsafeKeyword();
    public BlockSyntax get_Block();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public UnsafeStatementSyntax Update(SyntaxToken unsafeKeyword, BlockSyntax block);
    public UnsafeStatementSyntax WithUnsafeKeyword(SyntaxToken unsafeKeyword);
    public UnsafeStatementSyntax WithBlock(BlockSyntax block);
    public UnsafeStatementSyntax AddBlockStatements(StatementSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax : CSharpSyntaxNode {
    private NameEqualsSyntax alias;
    private NameSyntax name;
    public SyntaxToken UsingKeyword { get; }
    public SyntaxToken StaticKeyword { get; }
    public NameEqualsSyntax Alias { get; }
    public NameSyntax Name { get; }
    public SyntaxToken SemicolonToken { get; }
    internal UsingDirectiveSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_UsingKeyword();
    public SyntaxToken get_StaticKeyword();
    public NameEqualsSyntax get_Alias();
    public NameSyntax get_Name();
    public SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public UsingDirectiveSyntax Update(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken);
    public UsingDirectiveSyntax WithUsingKeyword(SyntaxToken usingKeyword);
    public UsingDirectiveSyntax WithStaticKeyword(SyntaxToken staticKeyword);
    public UsingDirectiveSyntax WithAlias(NameEqualsSyntax alias);
    public UsingDirectiveSyntax WithName(NameSyntax name);
    public UsingDirectiveSyntax WithSemicolonToken(SyntaxToken semicolonToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax : StatementSyntax {
    private VariableDeclarationSyntax declaration;
    private ExpressionSyntax expression;
    private StatementSyntax statement;
    public SyntaxToken UsingKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public VariableDeclarationSyntax Declaration { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    internal UsingStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_UsingKeyword();
    public SyntaxToken get_OpenParenToken();
    public VariableDeclarationSyntax get_Declaration();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public UsingStatementSyntax Update(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    public UsingStatementSyntax WithUsingKeyword(SyntaxToken usingKeyword);
    public UsingStatementSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public UsingStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration);
    public UsingStatementSyntax WithExpression(ExpressionSyntax expression);
    public UsingStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    public UsingStatementSyntax WithStatement(StatementSyntax statement);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax : CSharpSyntaxNode {
    private TypeSyntax type;
    private SyntaxNode variables;
    public TypeSyntax Type { get; }
    public SeparatedSyntaxList`1<VariableDeclaratorSyntax> Variables { get; }
    internal VariableDeclarationSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public TypeSyntax get_Type();
    public SeparatedSyntaxList`1<VariableDeclaratorSyntax> get_Variables();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public VariableDeclarationSyntax Update(TypeSyntax type, SeparatedSyntaxList`1<VariableDeclaratorSyntax> variables);
    public VariableDeclarationSyntax WithType(TypeSyntax type);
    public VariableDeclarationSyntax WithVariables(SeparatedSyntaxList`1<VariableDeclaratorSyntax> variables);
    public VariableDeclarationSyntax AddVariables(VariableDeclaratorSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax : CSharpSyntaxNode {
    private BracketedArgumentListSyntax argumentList;
    private EqualsValueClauseSyntax initializer;
    public SyntaxToken Identifier { get; }
    public BracketedArgumentListSyntax ArgumentList { get; }
    public EqualsValueClauseSyntax Initializer { get; }
    internal VariableDeclaratorSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_Identifier();
    public BracketedArgumentListSyntax get_ArgumentList();
    public EqualsValueClauseSyntax get_Initializer();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public VariableDeclaratorSyntax Update(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer);
    public VariableDeclaratorSyntax WithIdentifier(SyntaxToken identifier);
    public VariableDeclaratorSyntax WithArgumentList(BracketedArgumentListSyntax argumentList);
    public VariableDeclaratorSyntax WithInitializer(EqualsValueClauseSyntax initializer);
    public VariableDeclaratorSyntax AddArgumentListArguments(ArgumentSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken WarningKeyword { get; }
    public SyntaxToken EndOfDirectiveToken { get; }
    public bool IsActive { get; }
    internal WarningDirectiveTriviaSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual SyntaxToken get_HashToken();
    public SyntaxToken get_WarningKeyword();
    public virtual SyntaxToken get_EndOfDirectiveToken();
    public virtual bool get_IsActive();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public WarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public WarningDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public WarningDirectiveTriviaSyntax WithWarningKeyword(SyntaxToken warningKeyword);
    public WarningDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken);
    public WarningDirectiveTriviaSyntax WithIsActive(bool isActive);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax : QueryClauseSyntax {
    private ExpressionSyntax condition;
    public SyntaxToken WhereKeyword { get; }
    public ExpressionSyntax Condition { get; }
    internal WhereClauseSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_WhereKeyword();
    public ExpressionSyntax get_Condition();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public WhereClauseSyntax Update(SyntaxToken whereKeyword, ExpressionSyntax condition);
    public WhereClauseSyntax WithWhereKeyword(SyntaxToken whereKeyword);
    public WhereClauseSyntax WithCondition(ExpressionSyntax condition);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax : StatementSyntax {
    private ExpressionSyntax condition;
    private StatementSyntax statement;
    public SyntaxToken WhileKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Condition { get; }
    public SyntaxToken CloseParenToken { get; }
    public StatementSyntax Statement { get; }
    internal WhileStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_WhileKeyword();
    public SyntaxToken get_OpenParenToken();
    public ExpressionSyntax get_Condition();
    public SyntaxToken get_CloseParenToken();
    public StatementSyntax get_Statement();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public WhileStatementSyntax Update(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement);
    public WhileStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword);
    public WhileStatementSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public WhileStatementSyntax WithCondition(ExpressionSyntax condition);
    public WhileStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    public WhileStatementSyntax WithStatement(StatementSyntax statement);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax : CSharpSyntaxNode {
    public XmlNameSyntax Name { get; }
    public SyntaxToken EqualsToken { get; }
    public SyntaxToken StartQuoteToken { get; }
    public SyntaxToken EndQuoteToken { get; }
    internal XmlAttributeSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public abstract virtual XmlNameSyntax get_Name();
    public abstract virtual SyntaxToken get_EqualsToken();
    public abstract virtual SyntaxToken get_StartQuoteToken();
    public abstract virtual SyntaxToken get_EndQuoteToken();
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax : XmlNodeSyntax {
    public SyntaxToken StartCDataToken { get; }
    public SyntaxTokenList TextTokens { get; }
    public SyntaxToken EndCDataToken { get; }
    internal XmlCDataSectionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_StartCDataToken();
    public SyntaxTokenList get_TextTokens();
    public SyntaxToken get_EndCDataToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlCDataSectionSyntax Update(SyntaxToken startCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken);
    public XmlCDataSectionSyntax WithStartCDataToken(SyntaxToken startCDataToken);
    public XmlCDataSectionSyntax WithTextTokens(SyntaxTokenList textTokens);
    public XmlCDataSectionSyntax WithEndCDataToken(SyntaxToken endCDataToken);
    public XmlCDataSectionSyntax AddTextTokens(SyntaxToken[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax : XmlNodeSyntax {
    public SyntaxToken LessThanExclamationMinusMinusToken { get; }
    public SyntaxTokenList TextTokens { get; }
    public SyntaxToken MinusMinusGreaterThanToken { get; }
    internal XmlCommentSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_LessThanExclamationMinusMinusToken();
    public SyntaxTokenList get_TextTokens();
    public SyntaxToken get_MinusMinusGreaterThanToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlCommentSyntax Update(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken);
    public XmlCommentSyntax WithLessThanExclamationMinusMinusToken(SyntaxToken lessThanExclamationMinusMinusToken);
    public XmlCommentSyntax WithTextTokens(SyntaxTokenList textTokens);
    public XmlCommentSyntax WithMinusMinusGreaterThanToken(SyntaxToken minusMinusGreaterThanToken);
    public XmlCommentSyntax AddTextTokens(SyntaxToken[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax : XmlAttributeSyntax {
    private XmlNameSyntax name;
    private CrefSyntax cref;
    public XmlNameSyntax Name { get; }
    public SyntaxToken EqualsToken { get; }
    public SyntaxToken StartQuoteToken { get; }
    public CrefSyntax Cref { get; }
    public SyntaxToken EndQuoteToken { get; }
    internal XmlCrefAttributeSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual XmlNameSyntax get_Name();
    public virtual SyntaxToken get_EqualsToken();
    public virtual SyntaxToken get_StartQuoteToken();
    public CrefSyntax get_Cref();
    public virtual SyntaxToken get_EndQuoteToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlCrefAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken);
    public XmlCrefAttributeSyntax WithName(XmlNameSyntax name);
    public XmlCrefAttributeSyntax WithEqualsToken(SyntaxToken equalsToken);
    public XmlCrefAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken);
    public XmlCrefAttributeSyntax WithCref(CrefSyntax cref);
    public XmlCrefAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax : CSharpSyntaxNode {
    private XmlNameSyntax name;
    public SyntaxToken LessThanSlashToken { get; }
    public XmlNameSyntax Name { get; }
    public SyntaxToken GreaterThanToken { get; }
    internal XmlElementEndTagSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_LessThanSlashToken();
    public XmlNameSyntax get_Name();
    public SyntaxToken get_GreaterThanToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlElementEndTagSyntax Update(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken);
    public XmlElementEndTagSyntax WithLessThanSlashToken(SyntaxToken lessThanSlashToken);
    public XmlElementEndTagSyntax WithName(XmlNameSyntax name);
    public XmlElementEndTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax : CSharpSyntaxNode {
    private XmlNameSyntax name;
    private CSharpSyntaxNode attributes;
    public SyntaxToken LessThanToken { get; }
    public XmlNameSyntax Name { get; }
    public SyntaxList`1<XmlAttributeSyntax> Attributes { get; }
    public SyntaxToken GreaterThanToken { get; }
    internal XmlElementStartTagSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_LessThanToken();
    public XmlNameSyntax get_Name();
    public SyntaxList`1<XmlAttributeSyntax> get_Attributes();
    public SyntaxToken get_GreaterThanToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlElementStartTagSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList`1<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken);
    public XmlElementStartTagSyntax WithLessThanToken(SyntaxToken lessThanToken);
    public XmlElementStartTagSyntax WithName(XmlNameSyntax name);
    public XmlElementStartTagSyntax WithAttributes(SyntaxList`1<XmlAttributeSyntax> attributes);
    public XmlElementStartTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken);
    public XmlElementStartTagSyntax AddAttributes(XmlAttributeSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax : XmlNodeSyntax {
    private XmlElementStartTagSyntax startTag;
    private CSharpSyntaxNode content;
    private XmlElementEndTagSyntax endTag;
    public XmlElementStartTagSyntax StartTag { get; }
    public SyntaxList`1<XmlNodeSyntax> Content { get; }
    public XmlElementEndTagSyntax EndTag { get; }
    internal XmlElementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public XmlElementStartTagSyntax get_StartTag();
    public SyntaxList`1<XmlNodeSyntax> get_Content();
    public XmlElementEndTagSyntax get_EndTag();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlElementSyntax Update(XmlElementStartTagSyntax startTag, SyntaxList`1<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag);
    public XmlElementSyntax WithStartTag(XmlElementStartTagSyntax startTag);
    public XmlElementSyntax WithContent(SyntaxList`1<XmlNodeSyntax> content);
    public XmlElementSyntax WithEndTag(XmlElementEndTagSyntax endTag);
    public XmlElementSyntax AddStartTagAttributes(XmlAttributeSyntax[] items);
    public XmlElementSyntax AddContent(XmlNodeSyntax[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax : XmlNodeSyntax {
    private XmlNameSyntax name;
    private CSharpSyntaxNode attributes;
    public SyntaxToken LessThanToken { get; }
    public XmlNameSyntax Name { get; }
    public SyntaxList`1<XmlAttributeSyntax> Attributes { get; }
    public SyntaxToken SlashGreaterThanToken { get; }
    internal XmlEmptyElementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_LessThanToken();
    public XmlNameSyntax get_Name();
    public SyntaxList`1<XmlAttributeSyntax> get_Attributes();
    public SyntaxToken get_SlashGreaterThanToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlEmptyElementSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList`1<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken);
    public XmlEmptyElementSyntax WithLessThanToken(SyntaxToken lessThanToken);
    public XmlEmptyElementSyntax WithName(XmlNameSyntax name);
    public XmlEmptyElementSyntax WithAttributes(SyntaxList`1<XmlAttributeSyntax> attributes);
    public XmlEmptyElementSyntax WithSlashGreaterThanToken(SyntaxToken slashGreaterThanToken);
    public XmlEmptyElementSyntax AddAttributes(XmlAttributeSyntax[] items);
}
public enum Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeElementKind : Enum {
    public byte value__;
    public static XmlNameAttributeElementKind Parameter;
    public static XmlNameAttributeElementKind ParameterReference;
    public static XmlNameAttributeElementKind TypeParameter;
    public static XmlNameAttributeElementKind TypeParameterReference;
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax : XmlAttributeSyntax {
    private XmlNameSyntax name;
    private IdentifierNameSyntax identifier;
    public XmlNameSyntax Name { get; }
    public SyntaxToken EqualsToken { get; }
    public SyntaxToken StartQuoteToken { get; }
    public IdentifierNameSyntax Identifier { get; }
    public SyntaxToken EndQuoteToken { get; }
    internal XmlNameAttributeSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual XmlNameSyntax get_Name();
    public virtual SyntaxToken get_EqualsToken();
    public virtual SyntaxToken get_StartQuoteToken();
    public IdentifierNameSyntax get_Identifier();
    public virtual SyntaxToken get_EndQuoteToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlNameAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken);
    public XmlNameAttributeSyntax WithName(XmlNameSyntax name);
    public XmlNameAttributeSyntax WithEqualsToken(SyntaxToken equalsToken);
    public XmlNameAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken);
    public XmlNameAttributeSyntax WithIdentifier(IdentifierNameSyntax identifier);
    public XmlNameAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax : CSharpSyntaxNode {
    private XmlPrefixSyntax prefix;
    public XmlPrefixSyntax Prefix { get; }
    public SyntaxToken LocalName { get; }
    internal XmlNameSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public XmlPrefixSyntax get_Prefix();
    public SyntaxToken get_LocalName();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlNameSyntax Update(XmlPrefixSyntax prefix, SyntaxToken localName);
    public XmlNameSyntax WithPrefix(XmlPrefixSyntax prefix);
    public XmlNameSyntax WithLocalName(SyntaxToken localName);
}
public abstract class Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax : CSharpSyntaxNode {
    internal XmlNodeSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax : CSharpSyntaxNode {
    public SyntaxToken Prefix { get; }
    public SyntaxToken ColonToken { get; }
    internal XmlPrefixSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_Prefix();
    public SyntaxToken get_ColonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlPrefixSyntax Update(SyntaxToken prefix, SyntaxToken colonToken);
    public XmlPrefixSyntax WithPrefix(SyntaxToken prefix);
    public XmlPrefixSyntax WithColonToken(SyntaxToken colonToken);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax : XmlNodeSyntax {
    private XmlNameSyntax name;
    public SyntaxToken StartProcessingInstructionToken { get; }
    public XmlNameSyntax Name { get; }
    public SyntaxTokenList TextTokens { get; }
    public SyntaxToken EndProcessingInstructionToken { get; }
    internal XmlProcessingInstructionSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_StartProcessingInstructionToken();
    public XmlNameSyntax get_Name();
    public SyntaxTokenList get_TextTokens();
    public SyntaxToken get_EndProcessingInstructionToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlProcessingInstructionSyntax Update(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxTokenList textTokens, SyntaxToken endProcessingInstructionToken);
    public XmlProcessingInstructionSyntax WithStartProcessingInstructionToken(SyntaxToken startProcessingInstructionToken);
    public XmlProcessingInstructionSyntax WithName(XmlNameSyntax name);
    public XmlProcessingInstructionSyntax WithTextTokens(SyntaxTokenList textTokens);
    public XmlProcessingInstructionSyntax WithEndProcessingInstructionToken(SyntaxToken endProcessingInstructionToken);
    public XmlProcessingInstructionSyntax AddTextTokens(SyntaxToken[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax : XmlAttributeSyntax {
    private XmlNameSyntax name;
    public XmlNameSyntax Name { get; }
    public SyntaxToken EqualsToken { get; }
    public SyntaxToken StartQuoteToken { get; }
    public SyntaxTokenList TextTokens { get; }
    public SyntaxToken EndQuoteToken { get; }
    internal XmlTextAttributeSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public virtual XmlNameSyntax get_Name();
    public virtual SyntaxToken get_EqualsToken();
    public virtual SyntaxToken get_StartQuoteToken();
    public SyntaxTokenList get_TextTokens();
    public virtual SyntaxToken get_EndQuoteToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlTextAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken);
    public XmlTextAttributeSyntax WithName(XmlNameSyntax name);
    public XmlTextAttributeSyntax WithEqualsToken(SyntaxToken equalsToken);
    public XmlTextAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken);
    public XmlTextAttributeSyntax WithTextTokens(SyntaxTokenList textTokens);
    public XmlTextAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken);
    public XmlTextAttributeSyntax AddTextTokens(SyntaxToken[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax : XmlNodeSyntax {
    public SyntaxTokenList TextTokens { get; }
    internal XmlTextSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxTokenList get_TextTokens();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public XmlTextSyntax Update(SyntaxTokenList textTokens);
    public XmlTextSyntax WithTextTokens(SyntaxTokenList textTokens);
    public XmlTextSyntax AddTextTokens(SyntaxToken[] items);
}
public class Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax : StatementSyntax {
    private ExpressionSyntax expression;
    public SyntaxToken YieldKeyword { get; }
    public SyntaxToken ReturnOrBreakKeyword { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken SemicolonToken { get; }
    internal YieldStatementSyntax(CSharpSyntaxNode green, SyntaxNode parent, int position);
    public SyntaxToken get_YieldKeyword();
    public SyntaxToken get_ReturnOrBreakKeyword();
    public ExpressionSyntax get_Expression();
    public SyntaxToken get_SemicolonToken();
    internal virtual SyntaxNode GetNodeSlot(int index);
    internal virtual SyntaxNode GetCachedSlot(int index);
    public virtual TResult Accept(CSharpSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(CSharpSyntaxVisitor visitor);
    public YieldStatementSyntax Update(SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    public YieldStatementSyntax WithYieldKeyword(SyntaxToken yieldKeyword);
    public YieldStatementSyntax WithReturnOrBreakKeyword(SyntaxToken returnOrBreakKeyword);
    public YieldStatementSyntax WithExpression(ExpressionSyntax expression);
    public YieldStatementSyntax WithSemicolonToken(SyntaxToken semicolonToken);
}
internal class Microsoft.CodeAnalysis.CSharp.SyntaxAndDeclarationManager : CommonSyntaxAndDeclarationManager {
    private State _lazyState;
    internal SyntaxAndDeclarationManager(ImmutableArray`1<SyntaxTree> externalSyntaxTrees, string scriptClassName, SourceReferenceResolver resolver, CommonMessageProvider messageProvider, bool isSubmission, State state);
    internal State GetLazyState();
    private static State CreateState(ImmutableArray`1<SyntaxTree> externalSyntaxTrees, string scriptClassName, SourceReferenceResolver resolver, CommonMessageProvider messageProvider, bool isSubmission);
    public SyntaxAndDeclarationManager AddSyntaxTrees(IEnumerable`1<SyntaxTree> trees);
    private static void AppendAllSyntaxTrees(ArrayBuilder`1<SyntaxTree> treesBuilder, SyntaxTree tree, string scriptClassName, SourceReferenceResolver resolver, CommonMessageProvider messageProvider, bool isSubmission, IDictionary`2<SyntaxTree, int> ordinalMapBuilder, IDictionary`2<SyntaxTree, ImmutableArray`1<LoadDirective>> loadDirectiveMapBuilder, IDictionary`2<string, SyntaxTree> loadedSyntaxTreeMapBuilder, IDictionary`2<SyntaxTree, Lazy`1<RootSingleNamespaceDeclaration>> declMapBuilder, DeclarationTable& declTable);
    private static void AppendAllLoadedSyntaxTrees(ArrayBuilder`1<SyntaxTree> treesBuilder, SyntaxTree tree, string scriptClassName, SourceReferenceResolver resolver, CommonMessageProvider messageProvider, bool isSubmission, IDictionary`2<SyntaxTree, int> ordinalMapBuilder, IDictionary`2<SyntaxTree, ImmutableArray`1<LoadDirective>> loadDirectiveMapBuilder, IDictionary`2<string, SyntaxTree> loadedSyntaxTreeMapBuilder, IDictionary`2<SyntaxTree, Lazy`1<RootSingleNamespaceDeclaration>> declMapBuilder, DeclarationTable& declTable);
    private static void AddSyntaxTreeToDeclarationMapAndTable(SyntaxTree tree, string scriptClassName, bool isSubmission, IDictionary`2<SyntaxTree, Lazy`1<RootSingleNamespaceDeclaration>> declMapBuilder, DeclarationTable& declTable);
    public SyntaxAndDeclarationManager RemoveSyntaxTrees(HashSet`1<SyntaxTree> trees);
    private static void GetRemoveSet(SyntaxTree oldTree, bool includeLoadedTrees, ImmutableArray`1<SyntaxTree> syntaxTrees, ImmutableDictionary`2<SyntaxTree, int> syntaxTreeOrdinalMap, ImmutableDictionary`2<SyntaxTree, ImmutableArray`1<LoadDirective>> loadDirectiveMap, ImmutableDictionary`2<string, SyntaxTree> loadedSyntaxTreeMap, HashSet`1<SyntaxTree> removeSet, Int32& totalReferencedTreeCount, ImmutableArray`1& oldLoadDirectives);
    private static void GetRemoveSetForLoadedTrees(ImmutableArray`1<LoadDirective> loadDirectives, ImmutableDictionary`2<SyntaxTree, ImmutableArray`1<LoadDirective>> loadDirectiveMap, ImmutableDictionary`2<string, SyntaxTree> loadedSyntaxTreeMap, HashSet`1<SyntaxTree> removeSet);
    private static void RemoveSyntaxTreeFromDeclarationMapAndTable(SyntaxTree tree, IDictionary`2<SyntaxTree, Lazy`1<RootSingleNamespaceDeclaration>> declMap, DeclarationTable& declTable);
    public SyntaxAndDeclarationManager ReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree);
    internal SyntaxAndDeclarationManager WithExternalSyntaxTrees(ImmutableArray`1<SyntaxTree> trees);
    internal static bool IsLoadedSyntaxTree(SyntaxTree tree, ImmutableDictionary`2<string, SyntaxTree> loadedSyntaxTreeMap);
    private static void UpdateSyntaxTreesAndOrdinalMapOnly(ArrayBuilder`1<SyntaxTree> treesBuilder, SyntaxTree tree, IDictionary`2<SyntaxTree, int> ordinalMapBuilder, ImmutableDictionary`2<SyntaxTree, ImmutableArray`1<LoadDirective>> loadDirectiveMap, ImmutableDictionary`2<string, SyntaxTree> loadedSyntaxTreeMap);
    internal bool MayHaveReferenceDirectives();
    private static bool TryGetLoadedSyntaxTree(ImmutableDictionary`2<string, SyntaxTree> loadedSyntaxTreeMap, LoadDirective directive, SyntaxTree& loadedTree);
}
internal class Microsoft.CodeAnalysis.CSharp.SyntaxDiagnosticInfo : DiagnosticInfo {
    internal int Offset;
    internal int Width;
    internal SyntaxDiagnosticInfo(int offset, int width, ErrorCode code, Object[] args);
    internal SyntaxDiagnosticInfo(int offset, int width, ErrorCode code);
    internal SyntaxDiagnosticInfo(ErrorCode code, Object[] args);
    internal SyntaxDiagnosticInfo(ErrorCode code);
    protected SyntaxDiagnosticInfo(ObjectReader reader);
    public SyntaxDiagnosticInfo WithOffset(int offset);
    protected virtual void WriteTo(ObjectWriter writer);
    protected virtual Func`2<ObjectReader, object> GetReader();
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.CSharp.SyntaxExtensions : object {
    [ExtensionAttribute]
internal static ArrowExpressionClauseSyntax GetExpressionBodySyntax(CSharpSyntaxNode node);
    [ExtensionAttribute]
public static SyntaxToken NormalizeWhitespace(SyntaxToken token, string indentation, bool elasticTrivia);
    [ExtensionAttribute]
public static SyntaxToken NormalizeWhitespace(SyntaxToken token, string indentation, string eol, bool elasticTrivia);
    [ExtensionAttribute]
public static SyntaxTriviaList NormalizeWhitespace(SyntaxTriviaList list, string indentation, bool elasticTrivia);
    [ExtensionAttribute]
public static SyntaxTriviaList NormalizeWhitespace(SyntaxTriviaList list, string indentation, string eol, bool elasticTrivia);
    [ExtensionAttribute]
public static SyntaxTriviaList ToSyntaxTriviaList(IEnumerable`1<SyntaxTrivia> sequence);
    [ExtensionAttribute]
internal static XmlNameAttributeElementKind GetElementKind(XmlNameAttributeSyntax attributeSyntax);
    [ExtensionAttribute]
internal static bool ReportDocumentationCommentDiagnostics(SyntaxTree tree);
    [ExtensionAttribute]
public static SimpleNameSyntax WithIdentifier(SimpleNameSyntax simpleName, SyntaxToken identifier);
    [ExtensionAttribute]
internal static bool IsTypeInContextWhichNeedsDynamicAttribute(IdentifierNameSyntax typeNode);
    [ExtensionAttribute]
internal static CSharpSyntaxNode SkipParens(CSharpSyntaxNode expression);
    private static bool IsInContextWhichNeedsDynamicAttribute(CSharpSyntaxNode node);
    [ExtensionAttribute]
public static IndexerDeclarationSyntax Update(IndexerDeclarationSyntax syntax, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList);
    [ExtensionAttribute]
public static OperatorDeclarationSyntax Update(OperatorDeclarationSyntax syntax, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax block, SyntaxToken semicolonToken);
    [ExtensionAttribute]
public static MethodDeclarationSyntax Update(MethodDeclarationSyntax syntax, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax block, SyntaxToken semicolonToken);
}
public static class Microsoft.CodeAnalysis.CSharp.SyntaxFactory : object {
    [CompilerGeneratedAttribute]
private static SyntaxTrivia <CarriageReturnLineFeed>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia <LineFeed>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia <CarriageReturn>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia <Space>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia <Tab>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia <ElasticCarriageReturnLineFeed>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia <ElasticLineFeed>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia <ElasticCarriageReturn>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia <ElasticSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia <ElasticTab>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia <ElasticMarker>k__BackingField;
    public static SyntaxTrivia CarriageReturnLineFeed { get; }
    public static SyntaxTrivia LineFeed { get; }
    public static SyntaxTrivia CarriageReturn { get; }
    public static SyntaxTrivia Space { get; }
    public static SyntaxTrivia Tab { get; }
    public static SyntaxTrivia ElasticCarriageReturnLineFeed { get; }
    public static SyntaxTrivia ElasticLineFeed { get; }
    public static SyntaxTrivia ElasticCarriageReturn { get; }
    public static SyntaxTrivia ElasticSpace { get; }
    public static SyntaxTrivia ElasticTab { get; }
    public static SyntaxTrivia ElasticMarker { get; }
    private static SyntaxFactory();
    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_CarriageReturnLineFeed();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_LineFeed();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_CarriageReturn();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_Space();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_Tab();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_ElasticCarriageReturnLineFeed();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_ElasticLineFeed();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_ElasticCarriageReturn();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_ElasticSpace();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_ElasticTab();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_ElasticMarker();
    public static SyntaxTrivia EndOfLine(string text);
    public static SyntaxTrivia ElasticEndOfLine(string text);
    [ObsoleteAttribute("Use SyntaxFactory.EndOfLine or SyntaxFactory.ElasticEndOfLine")]
[EditorBrowsableAttribute("1")]
public static SyntaxTrivia EndOfLine(string text, bool elastic);
    public static SyntaxTrivia Whitespace(string text);
    public static SyntaxTrivia ElasticWhitespace(string text);
    [ObsoleteAttribute("Use SyntaxFactory.Whitespace or SyntaxFactory.ElasticWhitespace")]
[EditorBrowsableAttribute("1")]
public static SyntaxTrivia Whitespace(string text, bool elastic);
    public static SyntaxTrivia Comment(string text);
    public static SyntaxTrivia DisabledText(string text);
    public static SyntaxTrivia PreprocessingMessage(string text);
    public static SyntaxTrivia SyntaxTrivia(SyntaxKind kind, string text);
    public static SyntaxToken Token(SyntaxKind kind);
    public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing);
    public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, string text, string valueText, SyntaxTriviaList trailing);
    public static SyntaxToken MissingToken(SyntaxKind kind);
    public static SyntaxToken MissingToken(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing);
    public static SyntaxToken Identifier(string text);
    public static SyntaxToken Identifier(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing);
    public static SyntaxToken VerbatimIdentifier(SyntaxTriviaList leading, string text, string valueText, SyntaxTriviaList trailing);
    public static SyntaxToken Identifier(SyntaxTriviaList leading, SyntaxKind contextualKind, string text, string valueText, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(int value);
    public static SyntaxToken Literal(string text, int value);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, int value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(UInt32 value);
    public static SyntaxToken Literal(string text, UInt32 value);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, UInt32 value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(long value);
    public static SyntaxToken Literal(string text, long value);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, long value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(ulong value);
    public static SyntaxToken Literal(string text, ulong value);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, ulong value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(float value);
    public static SyntaxToken Literal(string text, float value);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, float value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(double value);
    public static SyntaxToken Literal(string text, double value);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, double value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(decimal value);
    public static SyntaxToken Literal(string text, decimal value);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, decimal value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(string value);
    public static SyntaxToken Literal(string text, string value);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(char value);
    public static SyntaxToken Literal(string text, char value);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, char value, SyntaxTriviaList trailing);
    public static SyntaxToken BadToken(SyntaxTriviaList leading, string text, SyntaxTriviaList trailing);
    public static SyntaxToken XmlTextLiteral(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing);
    public static SyntaxToken XmlEntity(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing);
    public static DocumentationCommentTriviaSyntax DocumentationComment(XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlSummaryElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlSummaryElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlEmptyElementSyntax XmlSeeElement(CrefSyntax cref);
    public static XmlEmptyElementSyntax XmlSeeAlsoElement(CrefSyntax cref);
    public static XmlElementSyntax XmlSeeAlsoElement(Uri linkAddress, SyntaxList`1<XmlNodeSyntax> linkText);
    public static XmlEmptyElementSyntax XmlThreadSafetyElement();
    public static XmlEmptyElementSyntax XmlThreadSafetyElement(bool isStatic, bool isInstance);
    public static XmlNameAttributeSyntax XmlNameAttribute(string parameterName);
    public static XmlEmptyElementSyntax XmlPreliminaryElement();
    public static XmlCrefAttributeSyntax XmlCrefAttribute(CrefSyntax cref);
    public static XmlCrefAttributeSyntax XmlCrefAttribute(CrefSyntax cref, SyntaxKind quoteKind);
    public static XmlElementSyntax XmlRemarksElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlRemarksElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlReturnsElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlReturnsElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlValueElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlValueElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlExceptionElement(CrefSyntax cref, XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlExceptionElement(CrefSyntax cref, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlPermissionElement(CrefSyntax cref, XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlPermissionElement(CrefSyntax cref, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlExampleElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlExampleElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlParaElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlParaElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlParamElement(string parameterName, XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlParamElement(string parameterName, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlEmptyElementSyntax XmlParamRefElement(string parameterName);
    public static XmlEmptyElementSyntax XmlNullKeywordElement();
    private static XmlEmptyElementSyntax XmlKeywordElement(string keyword);
    public static XmlElementSyntax XmlPlaceholderElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlPlaceholderElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlEmptyElementSyntax XmlEmptyElement(string localName);
    public static XmlElementSyntax XmlElement(string localName, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlElement(XmlNameSyntax name, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlTextAttributeSyntax XmlTextAttribute(string name, string value);
    public static XmlTextAttributeSyntax XmlTextAttribute(string name, SyntaxToken[] textTokens);
    public static XmlTextAttributeSyntax XmlTextAttribute(string name, SyntaxKind quoteKind, SyntaxTokenList textTokens);
    public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxKind quoteKind, SyntaxTokenList textTokens);
    public static XmlElementSyntax XmlMultiLineElement(string localName, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlMultiLineElement(XmlNameSyntax name, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlTextSyntax XmlNewLine(string text);
    public static SyntaxToken XmlTextNewLine(string text);
    public static SyntaxToken XmlTextNewLine(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing);
    public static SyntaxToken XmlTextNewLine(string text, bool continueXmlDocumentationComment);
    public static XmlTextSyntax XmlText(string value);
    public static XmlTextSyntax XmlText(SyntaxToken[] textTokens);
    public static SyntaxToken XmlTextLiteral(string value);
    public static SyntaxToken XmlTextLiteral(string text, string value);
    private static SyntaxToken XmlReplaceBracketTokens(SyntaxToken originalToken, SyntaxToken rewrittenToken);
    public static SyntaxTrivia DocumentationCommentExterior(string text);
    public static SyntaxList`1<TNode> List();
    public static SyntaxList`1<TNode> SingletonList(TNode node);
    public static SyntaxList`1<TNode> List(IEnumerable`1<TNode> nodes);
    public static SyntaxTokenList TokenList();
    public static SyntaxTokenList TokenList(SyntaxToken token);
    public static SyntaxTokenList TokenList(SyntaxToken[] tokens);
    public static SyntaxTokenList TokenList(IEnumerable`1<SyntaxToken> tokens);
    public static SyntaxTrivia Trivia(StructuredTriviaSyntax node);
    public static SyntaxTriviaList TriviaList();
    public static SyntaxTriviaList TriviaList(SyntaxTrivia trivia);
    public static SyntaxTriviaList TriviaList(SyntaxTrivia[] trivias);
    public static SyntaxTriviaList TriviaList(IEnumerable`1<SyntaxTrivia> trivias);
    public static SeparatedSyntaxList`1<TNode> SeparatedList();
    public static SeparatedSyntaxList`1<TNode> SingletonSeparatedList(TNode node);
    public static SeparatedSyntaxList`1<TNode> SeparatedList(IEnumerable`1<TNode> nodes);
    public static SeparatedSyntaxList`1<TNode> SeparatedList(IEnumerable`1<TNode> nodes, IEnumerable`1<SyntaxToken> separators);
    public static SeparatedSyntaxList`1<TNode> SeparatedList(IEnumerable`1<SyntaxNodeOrToken> nodesAndTokens);
    public static SeparatedSyntaxList`1<TNode> SeparatedList(SyntaxNodeOrTokenList nodesAndTokens);
    private static bool NodesAreCorrectType(SyntaxNodeOrTokenList list);
    private static bool HasSeparatedNodeTokenPattern(SyntaxNodeOrTokenList list);
    public static SyntaxNodeOrTokenList NodeOrTokenList();
    public static SyntaxNodeOrTokenList NodeOrTokenList(IEnumerable`1<SyntaxNodeOrToken> nodesAndTokens);
    public static SyntaxNodeOrTokenList NodeOrTokenList(SyntaxNodeOrToken[] nodesAndTokens);
    public static IdentifierNameSyntax IdentifierName(string name);
    public static SyntaxTree SyntaxTree(SyntaxNode root, ParseOptions options, string path, Encoding encoding);
    public static SyntaxTree ParseSyntaxTree(string text, ParseOptions options, string path, Encoding encoding, CancellationToken cancellationToken);
    public static SyntaxTree ParseSyntaxTree(SourceText text, ParseOptions options, string path, CancellationToken cancellationToken);
    public static SyntaxTriviaList ParseLeadingTrivia(string text, int offset);
    internal static SyntaxTriviaList ParseLeadingTrivia(string text, CSharpParseOptions options, int offset);
    public static SyntaxTriviaList ParseTrailingTrivia(string text, int offset);
    internal static CrefSyntax ParseCref(string text);
    public static SyntaxToken ParseToken(string text, int offset);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SyntaxFactory/<ParseTokens>d__167")]
public static IEnumerable`1<SyntaxToken> ParseTokens(string text, int offset, int initialTokenPosition, CSharpParseOptions options);
    public static NameSyntax ParseName(string text, int offset, bool consumeFullText);
    public static TypeSyntax ParseTypeName(string text, int offset, bool consumeFullText);
    public static ExpressionSyntax ParseExpression(string text, int offset, ParseOptions options, bool consumeFullText);
    public static StatementSyntax ParseStatement(string text, int offset, ParseOptions options, bool consumeFullText);
    public static CompilationUnitSyntax ParseCompilationUnit(string text, int offset, CSharpParseOptions options);
    public static ParameterListSyntax ParseParameterList(string text, int offset, ParseOptions options, bool consumeFullText);
    public static BracketedParameterListSyntax ParseBracketedParameterList(string text, int offset, ParseOptions options, bool consumeFullText);
    public static ArgumentListSyntax ParseArgumentList(string text, int offset, ParseOptions options, bool consumeFullText);
    public static BracketedArgumentListSyntax ParseBracketedArgumentList(string text, int offset, ParseOptions options, bool consumeFullText);
    public static AttributeArgumentListSyntax ParseAttributeArgumentList(string text, int offset, ParseOptions options, bool consumeFullText);
    private static SourceText MakeSourceText(string text, int offset);
    private static Lexer MakeLexer(string text, int offset, CSharpParseOptions options);
    private static LanguageParser MakeParser(Lexer lexer);
    public static bool AreEquivalent(SyntaxTree oldTree, SyntaxTree newTree, bool topLevel);
    public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, bool topLevel);
    public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, Func`2<SyntaxKind, bool> ignoreChildNode);
    public static bool AreEquivalent(SyntaxToken oldToken, SyntaxToken newToken);
    public static bool AreEquivalent(SyntaxTokenList oldList, SyntaxTokenList newList);
    public static bool AreEquivalent(SyntaxList`1<TNode> oldList, SyntaxList`1<TNode> newList, bool topLevel);
    public static bool AreEquivalent(SyntaxList`1<TNode> oldList, SyntaxList`1<TNode> newList, Func`2<SyntaxKind, bool> ignoreChildNode);
    public static bool AreEquivalent(SeparatedSyntaxList`1<TNode> oldList, SeparatedSyntaxList`1<TNode> newList, bool topLevel);
    public static bool AreEquivalent(SeparatedSyntaxList`1<TNode> oldList, SeparatedSyntaxList`1<TNode> newList, Func`2<SyntaxKind, bool> ignoreChildNode);
    internal static TypeSyntax GetStandaloneType(TypeSyntax node);
    public static ExpressionSyntax GetStandaloneExpression(ExpressionSyntax expression);
    internal static CSharpSyntaxNode GetStandaloneNode(CSharpSyntaxNode node);
    internal static ConditionalAccessExpressionSyntax FindConditionalAccessNodeForBinding(CSharpSyntaxNode node);
    public static ExpressionSyntax GetNonGenericExpression(ExpressionSyntax expression);
    public static bool IsCompleteSubmission(SyntaxTree tree);
    private static bool HasUnterminatedMultiLineComment(SyntaxTriviaList triviaList);
    public static CaseSwitchLabelSyntax CaseSwitchLabel(ExpressionSyntax value);
    public static DefaultSwitchLabelSyntax DefaultSwitchLabel();
    public static BlockSyntax Block(StatementSyntax[] statements);
    public static BlockSyntax Block(IEnumerable`1<StatementSyntax> statements);
    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList);
    public static MethodDeclarationSyntax MethodDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, SyntaxToken semicolonToken);
    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken);
    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken);
    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList);
    public static UsingDirectiveSyntax UsingDirective(NameEqualsSyntax alias, NameSyntax name);
    internal static SyntaxKind GetTypeDeclarationKeywordKind(DeclarationKind kind);
    private static SyntaxKind GetTypeDeclarationKeywordKind(SyntaxKind kind);
    public static TypeDeclarationSyntax TypeDeclaration(SyntaxKind kind, SyntaxToken identifier);
    public static TypeDeclarationSyntax TypeDeclaration(SyntaxKind kind, string identifier);
    public static TypeDeclarationSyntax TypeDeclaration(SyntaxKind kind, SyntaxList`1<AttributeListSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier);
    public static QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right);
    public static QualifiedNameSyntax QualifiedName(NameSyntax left, SimpleNameSyntax right);
    public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList);
    public static GenericNameSyntax GenericName(SyntaxToken identifier);
    public static GenericNameSyntax GenericName(string identifier);
    public static TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, SeparatedSyntaxList`1<TypeSyntax> arguments, SyntaxToken greaterThanToken);
    public static TypeArgumentListSyntax TypeArgumentList(SeparatedSyntaxList`1<TypeSyntax> arguments);
    public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name);
    public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SimpleNameSyntax name);
    public static AliasQualifiedNameSyntax AliasQualifiedName(string alias, SimpleNameSyntax name);
    public static PredefinedTypeSyntax PredefinedType(SyntaxToken keyword);
    public static ArrayTypeSyntax ArrayType(TypeSyntax elementType, SyntaxList`1<ArrayRankSpecifierSyntax> rankSpecifiers);
    public static ArrayTypeSyntax ArrayType(TypeSyntax elementType);
    public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, SeparatedSyntaxList`1<ExpressionSyntax> sizes, SyntaxToken closeBracketToken);
    public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SeparatedSyntaxList`1<ExpressionSyntax> sizes);
    public static PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken);
    public static PointerTypeSyntax PointerType(TypeSyntax elementType);
    public static NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken);
    public static NullableTypeSyntax NullableType(TypeSyntax elementType);
    public static OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken);
    public static OmittedTypeArgumentSyntax OmittedTypeArgument();
    public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public static ParenthesizedExpressionSyntax ParenthesizedExpression(ExpressionSyntax expression);
    public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand);
    public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand);
    private static SyntaxKind GetPrefixUnaryExpressionOperatorTokenKind(SyntaxKind kind);
    public static AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, ExpressionSyntax expression);
    public static AwaitExpressionSyntax AwaitExpression(ExpressionSyntax expression);
    public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken);
    public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand);
    private static SyntaxKind GetPostfixUnaryExpressionOperatorTokenKind(SyntaxKind kind);
    public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name);
    public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SimpleNameSyntax name);
    private static SyntaxKind GetMemberAccessExpressionOperatorTokenKind(SyntaxKind kind);
    public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull);
    public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, ExpressionSyntax whenNotNull);
    public static MemberBindingExpressionSyntax MemberBindingExpression(SyntaxToken operatorToken, SimpleNameSyntax name);
    public static MemberBindingExpressionSyntax MemberBindingExpression(SimpleNameSyntax name);
    public static ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList);
    public static ElementBindingExpressionSyntax ElementBindingExpression();
    public static ImplicitElementAccessSyntax ImplicitElementAccess(BracketedArgumentListSyntax argumentList);
    public static ImplicitElementAccessSyntax ImplicitElementAccess();
    public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, ExpressionSyntax right);
    private static SyntaxKind GetBinaryExpressionOperatorTokenKind(SyntaxKind kind);
    public static AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, ExpressionSyntax right);
    private static SyntaxKind GetAssignmentExpressionOperatorTokenKind(SyntaxKind kind);
    public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse);
    public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, ExpressionSyntax whenTrue, ExpressionSyntax whenFalse);
    public static ThisExpressionSyntax ThisExpression(SyntaxToken token);
    public static ThisExpressionSyntax ThisExpression();
    public static BaseExpressionSyntax BaseExpression(SyntaxToken token);
    public static BaseExpressionSyntax BaseExpression();
    public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token);
    public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind);
    private static SyntaxKind GetLiteralExpressionTokenKind(SyntaxKind kind);
    public static MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public static MakeRefExpressionSyntax MakeRefExpression(ExpressionSyntax expression);
    public static RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public static RefTypeExpressionSyntax RefTypeExpression(ExpressionSyntax expression);
    public static RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken);
    public static RefValueExpressionSyntax RefValueExpression(ExpressionSyntax expression, TypeSyntax type);
    public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, ExpressionSyntax expression);
    private static SyntaxKind GetCheckedExpressionKeywordKind(SyntaxKind kind);
    public static DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    public static DefaultExpressionSyntax DefaultExpression(TypeSyntax type);
    public static TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    public static TypeOfExpressionSyntax TypeOfExpression(TypeSyntax type);
    public static SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    public static SizeOfExpressionSyntax SizeOfExpression(TypeSyntax type);
    public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList);
    public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression);
    public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList);
    public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression);
    public static ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList`1<ArgumentSyntax> arguments, SyntaxToken closeParenToken);
    public static ArgumentListSyntax ArgumentList(SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    public static BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, SeparatedSyntaxList`1<ArgumentSyntax> arguments, SyntaxToken closeBracketToken);
    public static BracketedArgumentListSyntax BracketedArgumentList(SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    public static ArgumentSyntax Argument(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression);
    public static ArgumentSyntax Argument(ExpressionSyntax expression);
    public static NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken);
    public static NameColonSyntax NameColon(IdentifierNameSyntax name);
    public static NameColonSyntax NameColon(string name);
    public static CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression);
    public static CastExpressionSyntax CastExpression(TypeSyntax type, ExpressionSyntax expression);
    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body);
    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(ParameterListSyntax parameterList, CSharpSyntaxNode body);
    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(CSharpSyntaxNode body);
    public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body);
    public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(ParameterSyntax parameter, CSharpSyntaxNode body);
    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body);
    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(ParameterListSyntax parameterList, CSharpSyntaxNode body);
    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(CSharpSyntaxNode body);
    public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, SeparatedSyntaxList`1<ExpressionSyntax> expressions, SyntaxToken closeBraceToken);
    public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SeparatedSyntaxList`1<ExpressionSyntax> expressions);
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer);
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer);
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type);
    public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax nameEquals, ExpressionSyntax expression);
    public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(ExpressionSyntax expression);
    public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList`1<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken);
    public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SeparatedSyntaxList`1<AnonymousObjectMemberDeclaratorSyntax> initializers);
    public static ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer);
    public static ArrayCreationExpressionSyntax ArrayCreationExpression(ArrayTypeSyntax type, InitializerExpressionSyntax initializer);
    public static ArrayCreationExpressionSyntax ArrayCreationExpression(ArrayTypeSyntax type);
    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxTokenList commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer);
    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxTokenList commas, InitializerExpressionSyntax initializer);
    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(InitializerExpressionSyntax initializer);
    public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type);
    public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(TypeSyntax type);
    public static QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body);
    public static QueryBodySyntax QueryBody(SyntaxList`1<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation);
    public static QueryBodySyntax QueryBody(SelectOrGroupClauseSyntax selectOrGroup);
    public static FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression);
    public static FromClauseSyntax FromClause(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax expression);
    public static FromClauseSyntax FromClause(SyntaxToken identifier, ExpressionSyntax expression);
    public static FromClauseSyntax FromClause(string identifier, ExpressionSyntax expression);
    public static LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression);
    public static LetClauseSyntax LetClause(SyntaxToken identifier, ExpressionSyntax expression);
    public static LetClauseSyntax LetClause(string identifier, ExpressionSyntax expression);
    public static JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into);
    public static JoinClauseSyntax JoinClause(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into);
    public static JoinClauseSyntax JoinClause(SyntaxToken identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression);
    public static JoinClauseSyntax JoinClause(string identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression);
    public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier);
    public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken identifier);
    public static JoinIntoClauseSyntax JoinIntoClause(string identifier);
    public static WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition);
    public static WhereClauseSyntax WhereClause(ExpressionSyntax condition);
    public static OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, SeparatedSyntaxList`1<OrderingSyntax> orderings);
    public static OrderByClauseSyntax OrderByClause(SeparatedSyntaxList`1<OrderingSyntax> orderings);
    public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword);
    public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression);
    private static SyntaxKind GetOrderingAscendingOrDescendingKeywordKind(SyntaxKind kind);
    public static SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression);
    public static SelectClauseSyntax SelectClause(ExpressionSyntax expression);
    public static GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression);
    public static GroupClauseSyntax GroupClause(ExpressionSyntax groupExpression, ExpressionSyntax byExpression);
    public static QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body);
    public static QueryContinuationSyntax QueryContinuation(SyntaxToken identifier, QueryBodySyntax body);
    public static QueryContinuationSyntax QueryContinuation(string identifier, QueryBodySyntax body);
    public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken);
    public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression();
    public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList`1<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken);
    public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList`1<InterpolatedStringContentSyntax> contents);
    public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken);
    public static InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken);
    public static InterpolatedStringTextSyntax InterpolatedStringText();
    public static InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken);
    public static InterpolationSyntax Interpolation(ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause);
    public static InterpolationSyntax Interpolation(ExpressionSyntax expression);
    public static InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExpressionSyntax value);
    public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken);
    public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken);
    public static GlobalStatementSyntax GlobalStatement(StatementSyntax statement);
    public static BlockSyntax Block(SyntaxToken openBraceToken, SyntaxList`1<StatementSyntax> statements, SyntaxToken closeBraceToken);
    public static BlockSyntax Block(SyntaxList`1<StatementSyntax> statements);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(VariableDeclarationSyntax declaration);
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SeparatedSyntaxList`1<VariableDeclaratorSyntax> variables);
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type);
    public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer);
    public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier);
    public static VariableDeclaratorSyntax VariableDeclarator(string identifier);
    public static EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, ExpressionSyntax value);
    public static EqualsValueClauseSyntax EqualsValueClause(ExpressionSyntax value);
    public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken semicolonToken);
    public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression);
    public static EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken);
    public static EmptyStatementSyntax EmptyStatement();
    public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement);
    public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, StatementSyntax statement);
    public static LabeledStatementSyntax LabeledStatement(string identifier, StatementSyntax statement);
    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression);
    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, ExpressionSyntax expression);
    public static BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken);
    public static BreakStatementSyntax BreakStatement();
    public static ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken);
    public static ContinueStatementSyntax ContinueStatement();
    public static ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    public static ReturnStatementSyntax ReturnStatement(ExpressionSyntax expression);
    public static ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    public static ThrowStatementSyntax ThrowStatement(ExpressionSyntax expression);
    public static YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken);
    public static YieldStatementSyntax YieldStatement(SyntaxKind kind, ExpressionSyntax expression);
    private static SyntaxKind GetYieldStatementReturnOrBreakKeywordKind(SyntaxKind kind);
    public static WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement);
    public static WhileStatementSyntax WhileStatement(ExpressionSyntax condition, StatementSyntax statement);
    public static DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken);
    public static DoStatementSyntax DoStatement(StatementSyntax statement, ExpressionSyntax condition);
    public static ForStatementSyntax ForStatement(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList`1<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList`1<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement);
    public static ForStatementSyntax ForStatement(VariableDeclarationSyntax declaration, SeparatedSyntaxList`1<ExpressionSyntax> initializers, ExpressionSyntax condition, SeparatedSyntaxList`1<ExpressionSyntax> incrementors, StatementSyntax statement);
    public static ForStatementSyntax ForStatement(StatementSyntax statement);
    public static ForEachStatementSyntax ForEachStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    public static ForEachStatementSyntax ForEachStatement(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax expression, StatementSyntax statement);
    public static ForEachStatementSyntax ForEachStatement(TypeSyntax type, string identifier, ExpressionSyntax expression, StatementSyntax statement);
    public static UsingStatementSyntax UsingStatement(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    public static UsingStatementSyntax UsingStatement(VariableDeclarationSyntax declaration, ExpressionSyntax expression, StatementSyntax statement);
    public static UsingStatementSyntax UsingStatement(StatementSyntax statement);
    public static FixedStatementSyntax FixedStatement(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement);
    public static FixedStatementSyntax FixedStatement(VariableDeclarationSyntax declaration, StatementSyntax statement);
    public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block);
    public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, BlockSyntax block);
    private static SyntaxKind GetCheckedStatementKeywordKind(SyntaxKind kind);
    public static UnsafeStatementSyntax UnsafeStatement(SyntaxToken unsafeKeyword, BlockSyntax block);
    public static UnsafeStatementSyntax UnsafeStatement(BlockSyntax block);
    public static LockStatementSyntax LockStatement(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement);
    public static LockStatementSyntax LockStatement(ExpressionSyntax expression, StatementSyntax statement);
    public static IfStatementSyntax IfStatement(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax else);
    public static IfStatementSyntax IfStatement(ExpressionSyntax condition, StatementSyntax statement, ElseClauseSyntax else);
    public static IfStatementSyntax IfStatement(ExpressionSyntax condition, StatementSyntax statement);
    public static ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement);
    public static ElseClauseSyntax ElseClause(StatementSyntax statement);
    public static SwitchStatementSyntax SwitchStatement(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList`1<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken);
    public static SwitchStatementSyntax SwitchStatement(ExpressionSyntax expression, SyntaxList`1<SwitchSectionSyntax> sections);
    public static SwitchStatementSyntax SwitchStatement(ExpressionSyntax expression);
    public static SwitchSectionSyntax SwitchSection(SyntaxList`1<SwitchLabelSyntax> labels, SyntaxList`1<StatementSyntax> statements);
    public static SwitchSectionSyntax SwitchSection();
    public static CaseSwitchLabelSyntax CaseSwitchLabel(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken);
    public static CaseSwitchLabelSyntax CaseSwitchLabel(ExpressionSyntax value, SyntaxToken colonToken);
    public static DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken keyword, SyntaxToken colonToken);
    public static DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken colonToken);
    public static TryStatementSyntax TryStatement(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList`1<CatchClauseSyntax> catches, FinallyClauseSyntax finally);
    public static TryStatementSyntax TryStatement(BlockSyntax block, SyntaxList`1<CatchClauseSyntax> catches, FinallyClauseSyntax finally);
    public static TryStatementSyntax TryStatement(SyntaxList`1<CatchClauseSyntax> catches);
    public static CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block);
    public static CatchClauseSyntax CatchClause(CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block);
    public static CatchClauseSyntax CatchClause();
    public static CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken);
    public static CatchDeclarationSyntax CatchDeclaration(TypeSyntax type, SyntaxToken identifier);
    public static CatchDeclarationSyntax CatchDeclaration(TypeSyntax type);
    public static CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken);
    public static CatchFilterClauseSyntax CatchFilterClause(ExpressionSyntax filterExpression);
    public static FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block);
    public static FinallyClauseSyntax FinallyClause(BlockSyntax block);
    public static CompilationUnitSyntax CompilationUnit(SyntaxList`1<ExternAliasDirectiveSyntax> externs, SyntaxList`1<UsingDirectiveSyntax> usings, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken);
    public static CompilationUnitSyntax CompilationUnit(SyntaxList`1<ExternAliasDirectiveSyntax> externs, SyntaxList`1<UsingDirectiveSyntax> usings, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxList`1<MemberDeclarationSyntax> members);
    public static CompilationUnitSyntax CompilationUnit();
    public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken);
    public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken identifier);
    public static ExternAliasDirectiveSyntax ExternAliasDirective(string identifier);
    public static UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken);
    public static UsingDirectiveSyntax UsingDirective(SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name);
    public static UsingDirectiveSyntax UsingDirective(NameSyntax name);
    public static NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList`1<ExternAliasDirectiveSyntax> externs, SyntaxList`1<UsingDirectiveSyntax> usings, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name, SyntaxList`1<ExternAliasDirectiveSyntax> externs, SyntaxList`1<UsingDirectiveSyntax> usings, SyntaxList`1<MemberDeclarationSyntax> members);
    public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name);
    public static AttributeListSyntax AttributeList(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList`1<AttributeSyntax> attributes, SyntaxToken closeBracketToken);
    public static AttributeListSyntax AttributeList(AttributeTargetSpecifierSyntax target, SeparatedSyntaxList`1<AttributeSyntax> attributes);
    public static AttributeListSyntax AttributeList(SeparatedSyntaxList`1<AttributeSyntax> attributes);
    public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken);
    public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier);
    public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax argumentList);
    public static AttributeSyntax Attribute(NameSyntax name);
    public static AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList`1<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken);
    public static AttributeArgumentListSyntax AttributeArgumentList(SeparatedSyntaxList`1<AttributeArgumentSyntax> arguments);
    public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression);
    public static AttributeArgumentSyntax AttributeArgument(ExpressionSyntax expression);
    public static NameEqualsSyntax NameEquals(IdentifierNameSyntax name, SyntaxToken equalsToken);
    public static NameEqualsSyntax NameEquals(IdentifierNameSyntax name);
    public static NameEqualsSyntax NameEquals(string name);
    public static TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, SeparatedSyntaxList`1<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken);
    public static TypeParameterListSyntax TypeParameterList(SeparatedSyntaxList`1<TypeParameterSyntax> parameters);
    public static TypeParameterSyntax TypeParameter(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier);
    public static TypeParameterSyntax TypeParameter(SyntaxToken identifier);
    public static TypeParameterSyntax TypeParameter(string identifier);
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList`1<MemberDeclarationSyntax> members);
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxToken identifier);
    public static ClassDeclarationSyntax ClassDeclaration(string identifier);
    public static StructDeclarationSyntax StructDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public static StructDeclarationSyntax StructDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList`1<MemberDeclarationSyntax> members);
    public static StructDeclarationSyntax StructDeclaration(SyntaxToken identifier);
    public static StructDeclarationSyntax StructDeclaration(string identifier);
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList`1<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList`1<MemberDeclarationSyntax> members);
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxToken identifier);
    public static InterfaceDeclarationSyntax InterfaceDeclaration(string identifier);
    public static EnumDeclarationSyntax EnumDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList`1<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken);
    public static EnumDeclarationSyntax EnumDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, BaseListSyntax baseList, SeparatedSyntaxList`1<EnumMemberDeclarationSyntax> members);
    public static EnumDeclarationSyntax EnumDeclaration(SyntaxToken identifier);
    public static EnumDeclarationSyntax EnumDeclaration(string identifier);
    public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken);
    public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses);
    public static DelegateDeclarationSyntax DelegateDeclaration(TypeSyntax returnType, SyntaxToken identifier);
    public static DelegateDeclarationSyntax DelegateDeclaration(TypeSyntax returnType, string identifier);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string identifier);
    public static BaseListSyntax BaseList(SyntaxToken colonToken, SeparatedSyntaxList`1<BaseTypeSyntax> types);
    public static BaseListSyntax BaseList(SeparatedSyntaxList`1<BaseTypeSyntax> types);
    public static SimpleBaseTypeSyntax SimpleBaseType(TypeSyntax type);
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList`1<TypeParameterConstraintSyntax> constraints);
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax name, SeparatedSyntaxList`1<TypeParameterConstraintSyntax> constraints);
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax name);
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(string name);
    public static ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken);
    public static ConstructorConstraintSyntax ConstructorConstraint();
    public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword);
    public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind);
    private static SyntaxKind GetClassOrStructConstraintClassOrStructKeywordKind(SyntaxKind kind);
    public static TypeConstraintSyntax TypeConstraint(TypeSyntax type);
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration);
    public static FieldDeclarationSyntax FieldDeclaration(VariableDeclarationSyntax declaration);
    public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken);
    public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration);
    public static EventFieldDeclarationSyntax EventFieldDeclaration(VariableDeclarationSyntax declaration);
    public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken);
    public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name);
    public static MethodDeclarationSyntax MethodDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public static MethodDeclarationSyntax MethodDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody);
    public static MethodDeclarationSyntax MethodDeclaration(TypeSyntax returnType, SyntaxToken identifier);
    public static MethodDeclarationSyntax MethodDeclaration(TypeSyntax returnType, string identifier);
    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody);
    public static OperatorDeclarationSyntax OperatorDeclaration(TypeSyntax returnType, SyntaxToken operatorToken);
    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody);
    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type);
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, SyntaxToken semicolonToken);
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body);
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxToken identifier);
    public static ConstructorDeclarationSyntax ConstructorDeclaration(string identifier);
    public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList);
    public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, ArgumentListSyntax argumentList);
    private static SyntaxKind GetConstructorInitializerThisOrBaseKeywordKind(SyntaxKind kind);
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, SyntaxToken semicolonToken);
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body);
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxToken identifier);
    public static DestructorDeclarationSyntax DestructorDeclaration(string identifier);
    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken);
    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer);
    public static PropertyDeclarationSyntax PropertyDeclaration(TypeSyntax type, SyntaxToken identifier);
    public static PropertyDeclarationSyntax PropertyDeclaration(TypeSyntax type, string identifier);
    public static ArrowExpressionClauseSyntax ArrowExpressionClause(SyntaxToken arrowToken, ExpressionSyntax expression);
    public static ArrowExpressionClauseSyntax ArrowExpressionClause(ExpressionSyntax expression);
    public static EventDeclarationSyntax EventDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList);
    public static EventDeclarationSyntax EventDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList);
    public static EventDeclarationSyntax EventDeclaration(TypeSyntax type, SyntaxToken identifier);
    public static EventDeclarationSyntax EventDeclaration(TypeSyntax type, string identifier);
    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken);
    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody);
    public static IndexerDeclarationSyntax IndexerDeclaration(TypeSyntax type);
    public static AccessorListSyntax AccessorList(SyntaxToken openBraceToken, SyntaxList`1<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken);
    public static AccessorListSyntax AccessorList(SyntaxList`1<AccessorDeclarationSyntax> accessors);
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, SyntaxToken semicolonToken);
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, BlockSyntax body);
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, BlockSyntax body);
    private static SyntaxKind GetAccessorDeclarationKeywordKind(SyntaxKind kind);
    public static ParameterListSyntax ParameterList(SyntaxToken openParenToken, SeparatedSyntaxList`1<ParameterSyntax> parameters, SyntaxToken closeParenToken);
    public static ParameterListSyntax ParameterList(SeparatedSyntaxList`1<ParameterSyntax> parameters);
    public static BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList`1<ParameterSyntax> parameters, SyntaxToken closeBracketToken);
    public static BracketedParameterListSyntax BracketedParameterList(SeparatedSyntaxList`1<ParameterSyntax> parameters);
    public static ParameterSyntax Parameter(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax default);
    public static ParameterSyntax Parameter(SyntaxToken identifier);
    public static IncompleteMemberSyntax IncompleteMember(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type);
    public static IncompleteMemberSyntax IncompleteMember(TypeSyntax type);
    public static SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxTokenList tokens);
    public static SkippedTokensTriviaSyntax SkippedTokensTrivia();
    public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, SyntaxList`1<XmlNodeSyntax> content, SyntaxToken endOfComment);
    public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, SyntaxList`1<XmlNodeSyntax> content);
    public static TypeCrefSyntax TypeCref(TypeSyntax type);
    public static QualifiedCrefSyntax QualifiedCref(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member);
    public static QualifiedCrefSyntax QualifiedCref(TypeSyntax container, MemberCrefSyntax member);
    public static NameMemberCrefSyntax NameMemberCref(TypeSyntax name, CrefParameterListSyntax parameters);
    public static NameMemberCrefSyntax NameMemberCref(TypeSyntax name);
    public static IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters);
    public static IndexerMemberCrefSyntax IndexerMemberCref(CrefBracketedParameterListSyntax parameters);
    public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters);
    public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorToken, CrefParameterListSyntax parameters);
    public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorToken);
    public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters);
    public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type, CrefParameterListSyntax parameters);
    public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type);
    public static CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, SeparatedSyntaxList`1<CrefParameterSyntax> parameters, SyntaxToken closeParenToken);
    public static CrefParameterListSyntax CrefParameterList(SeparatedSyntaxList`1<CrefParameterSyntax> parameters);
    public static CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList`1<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken);
    public static CrefBracketedParameterListSyntax CrefBracketedParameterList(SeparatedSyntaxList`1<CrefParameterSyntax> parameters);
    public static CrefParameterSyntax CrefParameter(SyntaxToken refOrOutKeyword, TypeSyntax type);
    public static CrefParameterSyntax CrefParameter(TypeSyntax type);
    public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, SyntaxList`1<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag);
    public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, XmlElementEndTagSyntax endTag);
    public static XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList`1<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken);
    public static XmlElementStartTagSyntax XmlElementStartTag(XmlNameSyntax name, SyntaxList`1<XmlAttributeSyntax> attributes);
    public static XmlElementStartTagSyntax XmlElementStartTag(XmlNameSyntax name);
    public static XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken);
    public static XmlElementEndTagSyntax XmlElementEndTag(XmlNameSyntax name);
    public static XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList`1<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken);
    public static XmlEmptyElementSyntax XmlEmptyElement(XmlNameSyntax name, SyntaxList`1<XmlAttributeSyntax> attributes);
    public static XmlEmptyElementSyntax XmlEmptyElement(XmlNameSyntax name);
    public static XmlNameSyntax XmlName(XmlPrefixSyntax prefix, SyntaxToken localName);
    public static XmlNameSyntax XmlName(SyntaxToken localName);
    public static XmlNameSyntax XmlName(string localName);
    public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken);
    public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix);
    public static XmlPrefixSyntax XmlPrefix(string prefix);
    public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken);
    public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken);
    public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, SyntaxToken endQuoteToken);
    public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken);
    public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken);
    public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken);
    public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken);
    public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, string identifier, SyntaxToken endQuoteToken);
    public static XmlTextSyntax XmlText(SyntaxTokenList textTokens);
    public static XmlTextSyntax XmlText();
    public static XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken);
    public static XmlCDataSectionSyntax XmlCDataSection(SyntaxTokenList textTokens);
    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxTokenList textTokens, SyntaxToken endProcessingInstructionToken);
    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(XmlNameSyntax name, SyntaxTokenList textTokens);
    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(XmlNameSyntax name);
    public static XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken);
    public static XmlCommentSyntax XmlComment(SyntaxTokenList textTokens);
    public static IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue);
    public static IfDirectiveTriviaSyntax IfDirectiveTrivia(ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue);
    public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue);
    public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia(ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue);
    public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken);
    public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(bool isActive, bool branchTaken);
    public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(bool isActive);
    public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(bool isActive);
    public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(bool isActive);
    public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(bool isActive);
    public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive);
    public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia(bool isActive);
    public static BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive);
    public static BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken identifier, bool isActive);
    public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive);
    public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken name, bool isActive);
    public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(string name, bool isActive);
    public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive);
    public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken name, bool isActive);
    public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(string name, bool isActive);
    public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken line, SyntaxToken file, bool isActive);
    public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken line, bool isActive);
    public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList`1<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive);
    public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList`1<ExpressionSyntax> errorCodes, bool isActive);
    public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken disableOrRestoreKeyword, bool isActive);
    public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive);
    public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, bool isActive);
    public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken file, bool isActive);
    public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive);
    public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken file, bool isActive);
    public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive);
    public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(bool isActive);
}
public static class Microsoft.CodeAnalysis.CSharp.SyntaxFacts : object {
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<SyntaxKind> <EqualityComparer>k__BackingField;
    public static IEqualityComparer`1<SyntaxKind> EqualityComparer { get; }
    private static SyntaxFacts();
    internal static bool IsHexDigit(char c);
    internal static bool IsDecDigit(char c);
    internal static int HexValue(char c);
    internal static int DecValue(char c);
    public static bool IsWhitespace(char ch);
    public static bool IsNewLine(char ch);
    public static bool IsIdentifierStartCharacter(char ch);
    public static bool IsIdentifierPartCharacter(char ch);
    public static bool IsValidIdentifier(string name);
    internal static bool ContainsDroppedIdentifierCharacters(string name);
    internal static bool IsNonAsciiQuotationMark(char ch);
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<SyntaxKind> get_EqualityComparer();
    public static bool IsKeywordKind(SyntaxKind kind);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SyntaxFacts/<GetReservedKeywordKinds>d__16")]
public static IEnumerable`1<SyntaxKind> GetReservedKeywordKinds();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SyntaxFacts/<GetKeywordKinds>d__17")]
public static IEnumerable`1<SyntaxKind> GetKeywordKinds();
    public static bool IsReservedKeyword(SyntaxKind kind);
    public static bool IsAttributeTargetSpecifier(SyntaxKind kind);
    public static bool IsAccessibilityModifier(SyntaxKind kind);
    public static bool IsPreprocessorKeyword(SyntaxKind kind);
    internal static bool IsPreprocessorContextualKeyword(SyntaxKind kind);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SyntaxFacts/<GetPreprocessorKeywordKinds>d__23")]
public static IEnumerable`1<SyntaxKind> GetPreprocessorKeywordKinds();
    public static bool IsPunctuation(SyntaxKind kind);
    public static bool IsLanguagePunctuation(SyntaxKind kind);
    public static bool IsPreprocessorPunctuation(SyntaxKind kind);
    private static bool IsDebuggerSpecialPunctuation(SyntaxKind kind);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SyntaxFacts/<GetPunctuationKinds>d__28")]
public static IEnumerable`1<SyntaxKind> GetPunctuationKinds();
    public static bool IsPunctuationOrKeyword(SyntaxKind kind);
    internal static bool IsLiteral(SyntaxKind kind);
    public static bool IsAnyToken(SyntaxKind kind);
    public static bool IsTrivia(SyntaxKind kind);
    public static bool IsPreprocessorDirective(SyntaxKind kind);
    public static bool IsName(SyntaxKind kind);
    public static bool IsPredefinedType(SyntaxKind kind);
    public static bool IsTypeSyntax(SyntaxKind kind);
    public static bool IsTypeDeclaration(SyntaxKind kind);
    public static bool IsGlobalMemberDeclaration(SyntaxKind kind);
    public static bool IsNamespaceMemberDeclaration(SyntaxKind kind);
    public static bool IsAnyUnaryExpression(SyntaxKind token);
    public static bool IsPrefixUnaryExpression(SyntaxKind token);
    public static bool IsPrefixUnaryExpressionOperatorToken(SyntaxKind token);
    public static SyntaxKind GetPrefixUnaryExpression(SyntaxKind token);
    public static bool IsPostfixUnaryExpression(SyntaxKind token);
    public static bool IsPostfixUnaryExpressionToken(SyntaxKind token);
    public static SyntaxKind GetPostfixUnaryExpression(SyntaxKind token);
    public static bool IsUnaryOperatorDeclarationToken(SyntaxKind token);
    public static bool IsAnyOverloadableOperator(SyntaxKind kind);
    public static bool IsOverloadableBinaryOperator(SyntaxKind kind);
    public static bool IsOverloadableUnaryOperator(SyntaxKind kind);
    public static bool IsPrimaryFunction(SyntaxKind keyword);
    public static SyntaxKind GetPrimaryFunction(SyntaxKind keyword);
    public static bool IsLiteralExpression(SyntaxKind token);
    public static SyntaxKind GetLiteralExpression(SyntaxKind token);
    public static bool IsInstanceExpression(SyntaxKind token);
    public static SyntaxKind GetInstanceExpression(SyntaxKind token);
    public static bool IsBinaryExpression(SyntaxKind token);
    public static bool IsBinaryExpressionOperatorToken(SyntaxKind token);
    public static SyntaxKind GetBinaryExpression(SyntaxKind token);
    public static bool IsAssignmentExpression(SyntaxKind kind);
    public static bool IsAssignmentExpressionOperatorToken(SyntaxKind token);
    public static SyntaxKind GetAssignmentExpression(SyntaxKind token);
    public static SyntaxKind GetCheckStatement(SyntaxKind keyword);
    public static SyntaxKind GetAccessorDeclarationKind(SyntaxKind keyword);
    public static bool IsAccessorDeclaration(SyntaxKind kind);
    public static bool IsAccessorDeclarationKeyword(SyntaxKind keyword);
    public static SyntaxKind GetSwitchLabelKind(SyntaxKind keyword);
    public static SyntaxKind GetBaseTypeDeclarationKind(SyntaxKind kind);
    public static SyntaxKind GetTypeDeclarationKind(SyntaxKind kind);
    public static SyntaxKind GetKeywordKind(string text);
    public static SyntaxKind GetOperatorKind(string operatorMetadataName);
    public static SyntaxKind GetPreprocessorKeywordKind(string text);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SyntaxFacts/<GetContextualKeywordKinds>d__73")]
public static IEnumerable`1<SyntaxKind> GetContextualKeywordKinds();
    public static bool IsContextualKeyword(SyntaxKind kind);
    public static bool IsQueryContextualKeyword(SyntaxKind kind);
    public static SyntaxKind GetContextualKeywordKind(string text);
    public static string GetText(SyntaxKind kind);
    public static bool IsTypeParameterVarianceKeyword(SyntaxKind kind);
    public static bool IsDocumentationCommentTrivia(SyntaxKind kind);
    public static bool IsAliasQualifier(SyntaxNode node);
    public static bool IsAttributeName(SyntaxNode node);
    public static bool IsInvoked(ExpressionSyntax node);
    public static bool IsIndexed(ExpressionSyntax node);
    public static bool IsNamespaceAliasQualifier(ExpressionSyntax node);
    public static bool IsInTypeOnlyContext(ExpressionSyntax node);
    public static bool IsInNamespaceOrTypeContext(ExpressionSyntax node);
    public static bool IsNamedArgumentName(SyntaxNode node);
    public static bool IsFixedStatementExpression(SyntaxNode node);
    public static string GetText(Accessibility accessibility);
    internal static bool IsStatementExpression(CSharpSyntaxNode syntax);
    [ObsoleteAttribute("IsLambdaBody API is obsolete", "True")]
public static bool IsLambdaBody(SyntaxNode node);
}
public enum Microsoft.CodeAnalysis.CSharp.SyntaxKind : Enum {
    public ushort value__;
    public static SyntaxKind None;
    public static SyntaxKind List;
    public static SyntaxKind TildeToken;
    public static SyntaxKind ExclamationToken;
    public static SyntaxKind DollarToken;
    public static SyntaxKind PercentToken;
    public static SyntaxKind CaretToken;
    public static SyntaxKind AmpersandToken;
    public static SyntaxKind AsteriskToken;
    public static SyntaxKind OpenParenToken;
    public static SyntaxKind CloseParenToken;
    public static SyntaxKind MinusToken;
    public static SyntaxKind PlusToken;
    public static SyntaxKind EqualsToken;
    public static SyntaxKind OpenBraceToken;
    public static SyntaxKind CloseBraceToken;
    public static SyntaxKind OpenBracketToken;
    public static SyntaxKind CloseBracketToken;
    public static SyntaxKind BarToken;
    public static SyntaxKind BackslashToken;
    public static SyntaxKind ColonToken;
    public static SyntaxKind SemicolonToken;
    public static SyntaxKind DoubleQuoteToken;
    public static SyntaxKind SingleQuoteToken;
    public static SyntaxKind LessThanToken;
    public static SyntaxKind CommaToken;
    public static SyntaxKind GreaterThanToken;
    public static SyntaxKind DotToken;
    public static SyntaxKind QuestionToken;
    public static SyntaxKind HashToken;
    public static SyntaxKind SlashToken;
    public static SyntaxKind SlashGreaterThanToken;
    public static SyntaxKind LessThanSlashToken;
    public static SyntaxKind XmlCommentStartToken;
    public static SyntaxKind XmlCommentEndToken;
    public static SyntaxKind XmlCDataStartToken;
    public static SyntaxKind XmlCDataEndToken;
    public static SyntaxKind XmlProcessingInstructionStartToken;
    public static SyntaxKind XmlProcessingInstructionEndToken;
    public static SyntaxKind BarBarToken;
    public static SyntaxKind AmpersandAmpersandToken;
    public static SyntaxKind MinusMinusToken;
    public static SyntaxKind PlusPlusToken;
    public static SyntaxKind ColonColonToken;
    public static SyntaxKind QuestionQuestionToken;
    public static SyntaxKind MinusGreaterThanToken;
    public static SyntaxKind ExclamationEqualsToken;
    public static SyntaxKind EqualsEqualsToken;
    public static SyntaxKind EqualsGreaterThanToken;
    public static SyntaxKind LessThanEqualsToken;
    public static SyntaxKind LessThanLessThanToken;
    public static SyntaxKind LessThanLessThanEqualsToken;
    public static SyntaxKind GreaterThanEqualsToken;
    public static SyntaxKind GreaterThanGreaterThanToken;
    public static SyntaxKind GreaterThanGreaterThanEqualsToken;
    public static SyntaxKind SlashEqualsToken;
    public static SyntaxKind AsteriskEqualsToken;
    public static SyntaxKind BarEqualsToken;
    public static SyntaxKind AmpersandEqualsToken;
    public static SyntaxKind PlusEqualsToken;
    public static SyntaxKind MinusEqualsToken;
    public static SyntaxKind CaretEqualsToken;
    public static SyntaxKind PercentEqualsToken;
    public static SyntaxKind BoolKeyword;
    public static SyntaxKind ByteKeyword;
    public static SyntaxKind SByteKeyword;
    public static SyntaxKind ShortKeyword;
    public static SyntaxKind UShortKeyword;
    public static SyntaxKind IntKeyword;
    public static SyntaxKind UIntKeyword;
    public static SyntaxKind LongKeyword;
    public static SyntaxKind ULongKeyword;
    public static SyntaxKind DoubleKeyword;
    public static SyntaxKind FloatKeyword;
    public static SyntaxKind DecimalKeyword;
    public static SyntaxKind StringKeyword;
    public static SyntaxKind CharKeyword;
    public static SyntaxKind VoidKeyword;
    public static SyntaxKind ObjectKeyword;
    public static SyntaxKind TypeOfKeyword;
    public static SyntaxKind SizeOfKeyword;
    public static SyntaxKind NullKeyword;
    public static SyntaxKind TrueKeyword;
    public static SyntaxKind FalseKeyword;
    public static SyntaxKind IfKeyword;
    public static SyntaxKind ElseKeyword;
    public static SyntaxKind WhileKeyword;
    public static SyntaxKind ForKeyword;
    public static SyntaxKind ForEachKeyword;
    public static SyntaxKind DoKeyword;
    public static SyntaxKind SwitchKeyword;
    public static SyntaxKind CaseKeyword;
    public static SyntaxKind DefaultKeyword;
    public static SyntaxKind TryKeyword;
    public static SyntaxKind CatchKeyword;
    public static SyntaxKind FinallyKeyword;
    public static SyntaxKind LockKeyword;
    public static SyntaxKind GotoKeyword;
    public static SyntaxKind BreakKeyword;
    public static SyntaxKind ContinueKeyword;
    public static SyntaxKind ReturnKeyword;
    public static SyntaxKind ThrowKeyword;
    public static SyntaxKind PublicKeyword;
    public static SyntaxKind PrivateKeyword;
    public static SyntaxKind InternalKeyword;
    public static SyntaxKind ProtectedKeyword;
    public static SyntaxKind StaticKeyword;
    public static SyntaxKind ReadOnlyKeyword;
    public static SyntaxKind SealedKeyword;
    public static SyntaxKind ConstKeyword;
    public static SyntaxKind FixedKeyword;
    public static SyntaxKind StackAllocKeyword;
    public static SyntaxKind VolatileKeyword;
    public static SyntaxKind NewKeyword;
    public static SyntaxKind OverrideKeyword;
    public static SyntaxKind AbstractKeyword;
    public static SyntaxKind VirtualKeyword;
    public static SyntaxKind EventKeyword;
    public static SyntaxKind ExternKeyword;
    public static SyntaxKind RefKeyword;
    public static SyntaxKind OutKeyword;
    public static SyntaxKind InKeyword;
    public static SyntaxKind IsKeyword;
    public static SyntaxKind AsKeyword;
    public static SyntaxKind ParamsKeyword;
    public static SyntaxKind ArgListKeyword;
    public static SyntaxKind MakeRefKeyword;
    public static SyntaxKind RefTypeKeyword;
    public static SyntaxKind RefValueKeyword;
    public static SyntaxKind ThisKeyword;
    public static SyntaxKind BaseKeyword;
    public static SyntaxKind NamespaceKeyword;
    public static SyntaxKind UsingKeyword;
    public static SyntaxKind ClassKeyword;
    public static SyntaxKind StructKeyword;
    public static SyntaxKind InterfaceKeyword;
    public static SyntaxKind EnumKeyword;
    public static SyntaxKind DelegateKeyword;
    public static SyntaxKind CheckedKeyword;
    public static SyntaxKind UncheckedKeyword;
    public static SyntaxKind UnsafeKeyword;
    public static SyntaxKind OperatorKeyword;
    public static SyntaxKind ExplicitKeyword;
    public static SyntaxKind ImplicitKeyword;
    public static SyntaxKind YieldKeyword;
    public static SyntaxKind PartialKeyword;
    public static SyntaxKind AliasKeyword;
    public static SyntaxKind GlobalKeyword;
    public static SyntaxKind AssemblyKeyword;
    public static SyntaxKind ModuleKeyword;
    public static SyntaxKind TypeKeyword;
    public static SyntaxKind FieldKeyword;
    public static SyntaxKind MethodKeyword;
    public static SyntaxKind ParamKeyword;
    public static SyntaxKind PropertyKeyword;
    public static SyntaxKind TypeVarKeyword;
    public static SyntaxKind GetKeyword;
    public static SyntaxKind SetKeyword;
    public static SyntaxKind AddKeyword;
    public static SyntaxKind RemoveKeyword;
    public static SyntaxKind WhereKeyword;
    public static SyntaxKind FromKeyword;
    public static SyntaxKind GroupKeyword;
    public static SyntaxKind JoinKeyword;
    public static SyntaxKind IntoKeyword;
    public static SyntaxKind LetKeyword;
    public static SyntaxKind ByKeyword;
    public static SyntaxKind SelectKeyword;
    public static SyntaxKind OrderByKeyword;
    public static SyntaxKind OnKeyword;
    public static SyntaxKind EqualsKeyword;
    public static SyntaxKind AscendingKeyword;
    public static SyntaxKind DescendingKeyword;
    public static SyntaxKind NameOfKeyword;
    public static SyntaxKind AsyncKeyword;
    public static SyntaxKind AwaitKeyword;
    public static SyntaxKind WhenKeyword;
    public static SyntaxKind ElifKeyword;
    public static SyntaxKind EndIfKeyword;
    public static SyntaxKind RegionKeyword;
    public static SyntaxKind EndRegionKeyword;
    public static SyntaxKind DefineKeyword;
    public static SyntaxKind UndefKeyword;
    public static SyntaxKind WarningKeyword;
    public static SyntaxKind ErrorKeyword;
    public static SyntaxKind LineKeyword;
    public static SyntaxKind PragmaKeyword;
    public static SyntaxKind HiddenKeyword;
    public static SyntaxKind ChecksumKeyword;
    public static SyntaxKind DisableKeyword;
    public static SyntaxKind RestoreKeyword;
    public static SyntaxKind ReferenceKeyword;
    public static SyntaxKind LoadKeyword;
    public static SyntaxKind InterpolatedStringStartToken;
    public static SyntaxKind InterpolatedStringEndToken;
    public static SyntaxKind InterpolatedVerbatimStringStartToken;
    public static SyntaxKind OmittedTypeArgumentToken;
    public static SyntaxKind OmittedArraySizeExpressionToken;
    public static SyntaxKind EndOfDirectiveToken;
    public static SyntaxKind EndOfDocumentationCommentToken;
    public static SyntaxKind EndOfFileToken;
    public static SyntaxKind BadToken;
    public static SyntaxKind IdentifierToken;
    public static SyntaxKind NumericLiteralToken;
    public static SyntaxKind CharacterLiteralToken;
    public static SyntaxKind StringLiteralToken;
    public static SyntaxKind XmlEntityLiteralToken;
    public static SyntaxKind XmlTextLiteralToken;
    public static SyntaxKind XmlTextLiteralNewLineToken;
    public static SyntaxKind InterpolatedStringToken;
    public static SyntaxKind InterpolatedStringTextToken;
    public static SyntaxKind EndOfLineTrivia;
    public static SyntaxKind WhitespaceTrivia;
    public static SyntaxKind SingleLineCommentTrivia;
    public static SyntaxKind MultiLineCommentTrivia;
    public static SyntaxKind DocumentationCommentExteriorTrivia;
    public static SyntaxKind SingleLineDocumentationCommentTrivia;
    public static SyntaxKind MultiLineDocumentationCommentTrivia;
    public static SyntaxKind DisabledTextTrivia;
    public static SyntaxKind PreprocessingMessageTrivia;
    public static SyntaxKind IfDirectiveTrivia;
    public static SyntaxKind ElifDirectiveTrivia;
    public static SyntaxKind ElseDirectiveTrivia;
    public static SyntaxKind EndIfDirectiveTrivia;
    public static SyntaxKind RegionDirectiveTrivia;
    public static SyntaxKind EndRegionDirectiveTrivia;
    public static SyntaxKind DefineDirectiveTrivia;
    public static SyntaxKind UndefDirectiveTrivia;
    public static SyntaxKind ErrorDirectiveTrivia;
    public static SyntaxKind WarningDirectiveTrivia;
    public static SyntaxKind LineDirectiveTrivia;
    public static SyntaxKind PragmaWarningDirectiveTrivia;
    public static SyntaxKind PragmaChecksumDirectiveTrivia;
    public static SyntaxKind ReferenceDirectiveTrivia;
    public static SyntaxKind BadDirectiveTrivia;
    public static SyntaxKind SkippedTokensTrivia;
    public static SyntaxKind XmlElement;
    public static SyntaxKind XmlElementStartTag;
    public static SyntaxKind XmlElementEndTag;
    public static SyntaxKind XmlEmptyElement;
    public static SyntaxKind XmlTextAttribute;
    public static SyntaxKind XmlCrefAttribute;
    public static SyntaxKind XmlNameAttribute;
    public static SyntaxKind XmlName;
    public static SyntaxKind XmlPrefix;
    public static SyntaxKind XmlText;
    public static SyntaxKind XmlCDataSection;
    public static SyntaxKind XmlComment;
    public static SyntaxKind XmlProcessingInstruction;
    public static SyntaxKind TypeCref;
    public static SyntaxKind QualifiedCref;
    public static SyntaxKind NameMemberCref;
    public static SyntaxKind IndexerMemberCref;
    public static SyntaxKind OperatorMemberCref;
    public static SyntaxKind ConversionOperatorMemberCref;
    public static SyntaxKind CrefParameterList;
    public static SyntaxKind CrefBracketedParameterList;
    public static SyntaxKind CrefParameter;
    public static SyntaxKind IdentifierName;
    public static SyntaxKind QualifiedName;
    public static SyntaxKind GenericName;
    public static SyntaxKind TypeArgumentList;
    public static SyntaxKind AliasQualifiedName;
    public static SyntaxKind PredefinedType;
    public static SyntaxKind ArrayType;
    public static SyntaxKind ArrayRankSpecifier;
    public static SyntaxKind PointerType;
    public static SyntaxKind NullableType;
    public static SyntaxKind OmittedTypeArgument;
    public static SyntaxKind ParenthesizedExpression;
    public static SyntaxKind ConditionalExpression;
    public static SyntaxKind InvocationExpression;
    public static SyntaxKind ElementAccessExpression;
    public static SyntaxKind ArgumentList;
    public static SyntaxKind BracketedArgumentList;
    public static SyntaxKind Argument;
    public static SyntaxKind NameColon;
    public static SyntaxKind CastExpression;
    public static SyntaxKind AnonymousMethodExpression;
    public static SyntaxKind SimpleLambdaExpression;
    public static SyntaxKind ParenthesizedLambdaExpression;
    public static SyntaxKind ObjectInitializerExpression;
    public static SyntaxKind CollectionInitializerExpression;
    public static SyntaxKind ArrayInitializerExpression;
    public static SyntaxKind AnonymousObjectMemberDeclarator;
    public static SyntaxKind ComplexElementInitializerExpression;
    public static SyntaxKind ObjectCreationExpression;
    public static SyntaxKind AnonymousObjectCreationExpression;
    public static SyntaxKind ArrayCreationExpression;
    public static SyntaxKind ImplicitArrayCreationExpression;
    public static SyntaxKind StackAllocArrayCreationExpression;
    public static SyntaxKind OmittedArraySizeExpression;
    public static SyntaxKind InterpolatedStringExpression;
    public static SyntaxKind ImplicitElementAccess;
    public static SyntaxKind AddExpression;
    public static SyntaxKind SubtractExpression;
    public static SyntaxKind MultiplyExpression;
    public static SyntaxKind DivideExpression;
    public static SyntaxKind ModuloExpression;
    public static SyntaxKind LeftShiftExpression;
    public static SyntaxKind RightShiftExpression;
    public static SyntaxKind LogicalOrExpression;
    public static SyntaxKind LogicalAndExpression;
    public static SyntaxKind BitwiseOrExpression;
    public static SyntaxKind BitwiseAndExpression;
    public static SyntaxKind ExclusiveOrExpression;
    public static SyntaxKind EqualsExpression;
    public static SyntaxKind NotEqualsExpression;
    public static SyntaxKind LessThanExpression;
    public static SyntaxKind LessThanOrEqualExpression;
    public static SyntaxKind GreaterThanExpression;
    public static SyntaxKind GreaterThanOrEqualExpression;
    public static SyntaxKind IsExpression;
    public static SyntaxKind AsExpression;
    public static SyntaxKind CoalesceExpression;
    public static SyntaxKind SimpleMemberAccessExpression;
    public static SyntaxKind PointerMemberAccessExpression;
    public static SyntaxKind ConditionalAccessExpression;
    public static SyntaxKind MemberBindingExpression;
    public static SyntaxKind ElementBindingExpression;
    public static SyntaxKind SimpleAssignmentExpression;
    public static SyntaxKind AddAssignmentExpression;
    public static SyntaxKind SubtractAssignmentExpression;
    public static SyntaxKind MultiplyAssignmentExpression;
    public static SyntaxKind DivideAssignmentExpression;
    public static SyntaxKind ModuloAssignmentExpression;
    public static SyntaxKind AndAssignmentExpression;
    public static SyntaxKind ExclusiveOrAssignmentExpression;
    public static SyntaxKind OrAssignmentExpression;
    public static SyntaxKind LeftShiftAssignmentExpression;
    public static SyntaxKind RightShiftAssignmentExpression;
    public static SyntaxKind UnaryPlusExpression;
    public static SyntaxKind UnaryMinusExpression;
    public static SyntaxKind BitwiseNotExpression;
    public static SyntaxKind LogicalNotExpression;
    public static SyntaxKind PreIncrementExpression;
    public static SyntaxKind PreDecrementExpression;
    public static SyntaxKind PointerIndirectionExpression;
    public static SyntaxKind AddressOfExpression;
    public static SyntaxKind PostIncrementExpression;
    public static SyntaxKind PostDecrementExpression;
    public static SyntaxKind AwaitExpression;
    public static SyntaxKind ThisExpression;
    public static SyntaxKind BaseExpression;
    public static SyntaxKind ArgListExpression;
    public static SyntaxKind NumericLiteralExpression;
    public static SyntaxKind StringLiteralExpression;
    public static SyntaxKind CharacterLiteralExpression;
    public static SyntaxKind TrueLiteralExpression;
    public static SyntaxKind FalseLiteralExpression;
    public static SyntaxKind NullLiteralExpression;
    public static SyntaxKind TypeOfExpression;
    public static SyntaxKind SizeOfExpression;
    public static SyntaxKind CheckedExpression;
    public static SyntaxKind UncheckedExpression;
    public static SyntaxKind DefaultExpression;
    public static SyntaxKind MakeRefExpression;
    public static SyntaxKind RefValueExpression;
    public static SyntaxKind RefTypeExpression;
    public static SyntaxKind QueryExpression;
    public static SyntaxKind QueryBody;
    public static SyntaxKind FromClause;
    public static SyntaxKind LetClause;
    public static SyntaxKind JoinClause;
    public static SyntaxKind JoinIntoClause;
    public static SyntaxKind WhereClause;
    public static SyntaxKind OrderByClause;
    public static SyntaxKind AscendingOrdering;
    public static SyntaxKind DescendingOrdering;
    public static SyntaxKind SelectClause;
    public static SyntaxKind GroupClause;
    public static SyntaxKind QueryContinuation;
    public static SyntaxKind Block;
    public static SyntaxKind LocalDeclarationStatement;
    public static SyntaxKind VariableDeclaration;
    public static SyntaxKind VariableDeclarator;
    public static SyntaxKind EqualsValueClause;
    public static SyntaxKind ExpressionStatement;
    public static SyntaxKind EmptyStatement;
    public static SyntaxKind LabeledStatement;
    public static SyntaxKind GotoStatement;
    public static SyntaxKind GotoCaseStatement;
    public static SyntaxKind GotoDefaultStatement;
    public static SyntaxKind BreakStatement;
    public static SyntaxKind ContinueStatement;
    public static SyntaxKind ReturnStatement;
    public static SyntaxKind YieldReturnStatement;
    public static SyntaxKind YieldBreakStatement;
    public static SyntaxKind ThrowStatement;
    public static SyntaxKind WhileStatement;
    public static SyntaxKind DoStatement;
    public static SyntaxKind ForStatement;
    public static SyntaxKind ForEachStatement;
    public static SyntaxKind UsingStatement;
    public static SyntaxKind FixedStatement;
    public static SyntaxKind CheckedStatement;
    public static SyntaxKind UncheckedStatement;
    public static SyntaxKind UnsafeStatement;
    public static SyntaxKind LockStatement;
    public static SyntaxKind IfStatement;
    public static SyntaxKind ElseClause;
    public static SyntaxKind SwitchStatement;
    public static SyntaxKind SwitchSection;
    public static SyntaxKind CaseSwitchLabel;
    public static SyntaxKind DefaultSwitchLabel;
    public static SyntaxKind TryStatement;
    public static SyntaxKind CatchClause;
    public static SyntaxKind CatchDeclaration;
    public static SyntaxKind CatchFilterClause;
    public static SyntaxKind FinallyClause;
    public static SyntaxKind CompilationUnit;
    public static SyntaxKind GlobalStatement;
    public static SyntaxKind NamespaceDeclaration;
    public static SyntaxKind UsingDirective;
    public static SyntaxKind ExternAliasDirective;
    public static SyntaxKind AttributeList;
    public static SyntaxKind AttributeTargetSpecifier;
    public static SyntaxKind Attribute;
    public static SyntaxKind AttributeArgumentList;
    public static SyntaxKind AttributeArgument;
    public static SyntaxKind NameEquals;
    public static SyntaxKind ClassDeclaration;
    public static SyntaxKind StructDeclaration;
    public static SyntaxKind InterfaceDeclaration;
    public static SyntaxKind EnumDeclaration;
    public static SyntaxKind DelegateDeclaration;
    public static SyntaxKind BaseList;
    public static SyntaxKind SimpleBaseType;
    public static SyntaxKind TypeParameterConstraintClause;
    public static SyntaxKind ConstructorConstraint;
    public static SyntaxKind ClassConstraint;
    public static SyntaxKind StructConstraint;
    public static SyntaxKind TypeConstraint;
    public static SyntaxKind ExplicitInterfaceSpecifier;
    public static SyntaxKind EnumMemberDeclaration;
    public static SyntaxKind FieldDeclaration;
    public static SyntaxKind EventFieldDeclaration;
    public static SyntaxKind MethodDeclaration;
    public static SyntaxKind OperatorDeclaration;
    public static SyntaxKind ConversionOperatorDeclaration;
    public static SyntaxKind ConstructorDeclaration;
    public static SyntaxKind BaseConstructorInitializer;
    public static SyntaxKind ThisConstructorInitializer;
    public static SyntaxKind DestructorDeclaration;
    public static SyntaxKind PropertyDeclaration;
    public static SyntaxKind EventDeclaration;
    public static SyntaxKind IndexerDeclaration;
    public static SyntaxKind AccessorList;
    public static SyntaxKind GetAccessorDeclaration;
    public static SyntaxKind SetAccessorDeclaration;
    public static SyntaxKind AddAccessorDeclaration;
    public static SyntaxKind RemoveAccessorDeclaration;
    public static SyntaxKind UnknownAccessorDeclaration;
    public static SyntaxKind ParameterList;
    public static SyntaxKind BracketedParameterList;
    public static SyntaxKind Parameter;
    public static SyntaxKind TypeParameterList;
    public static SyntaxKind TypeParameter;
    public static SyntaxKind IncompleteMember;
    public static SyntaxKind ArrowExpressionClause;
    public static SyntaxKind Interpolation;
    public static SyntaxKind InterpolatedStringText;
    public static SyntaxKind InterpolationAlignmentClause;
    public static SyntaxKind InterpolationFormatClause;
    public static SyntaxKind ShebangDirectiveTrivia;
    public static SyntaxKind LoadDirectiveTrivia;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.SyntaxNodeExtensions : object {
    [ExtensionAttribute]
public static TNode WithAnnotations(TNode node, SyntaxAnnotation[] annotations);
    [ExtensionAttribute]
public static bool IsAnonymousFunction(CSharpSyntaxNode syntax);
    [ExtensionAttribute]
public static bool IsQuery(CSharpSyntaxNode syntax);
    [ExtensionAttribute]
internal static bool CanHaveAssociatedLocalBinder(CSharpSyntaxNode syntax);
    [ExtensionAttribute]
internal static SyntaxToken ExtractAnonymousTypeMemberName(ExpressionSyntax input);
}
internal class Microsoft.CodeAnalysis.CSharp.SyntaxTreeDiagnosticEnumerator : ValueType {
    private SyntaxTree _syntaxTree;
    private NodeIterationStack _stack;
    private Diagnostic _current;
    private int _position;
    private static int DefaultStackCapacity;
    public Diagnostic Current { get; }
    internal SyntaxTreeDiagnosticEnumerator(SyntaxTree syntaxTree, GreenNode node, int position);
    public bool MoveNext();
    public Diagnostic get_Current();
}
internal class Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel : CSharpSemanticModel {
    private CSharpCompilation _compilation;
    private SyntaxTree _syntaxTree;
    private ImmutableDictionary`2<CSharpSyntaxNode, MemberSemanticModel> _memberModels;
    private BinderFactory _binderFactory;
    private Func`2<CSharpSyntaxNode, MemberSemanticModel> _createMemberModelFunction;
    private bool _ignoresAccessibility;
    private Labels _globalStatementLabels;
    private static Func`2<CSharpSyntaxNode, bool> s_isMemberDeclarationFunction;
    public CSharpCompilation Compilation { get; }
    internal CSharpSyntaxNode Root { get; }
    public SyntaxTree SyntaxTree { get; }
    public bool IgnoresAccessibility { get; }
    public bool IsSpeculativeSemanticModel { get; }
    public int OriginalPositionForSpeculation { get; }
    public CSharpSemanticModel ParentModel { get; }
    private bool IsRegularCSharp { get; }
    internal SyntaxTreeSemanticModel(CSharpCompilation compilation, SyntaxTree syntaxTree, bool ignoreAccessibility);
    internal SyntaxTreeSemanticModel(CSharpCompilation parentCompilation, SyntaxTree parentSyntaxTree, SyntaxTree speculatedSyntaxTree);
    private static SyntaxTreeSemanticModel();
    public virtual CSharpCompilation get_Compilation();
    internal virtual CSharpSyntaxNode get_Root();
    public virtual SyntaxTree get_SyntaxTree();
    public virtual bool get_IgnoresAccessibility();
    private void VerifySpanForGetDiagnostics(Nullable`1<TextSpan> span);
    public virtual ImmutableArray`1<Diagnostic> GetSyntaxDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetDeclarationDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetMethodBodyDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    internal virtual Binder GetEnclosingBinderInternal(int position);
    internal virtual IOperation GetOperationWorker(CSharpSyntaxNode node, GetOperationOptions options, CancellationToken cancellationToken);
    internal virtual SymbolInfo GetSymbolInfoWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken);
    internal virtual SymbolInfo GetCollectionInitializerSymbolInfoWorker(InitializerExpressionSyntax collectionInitializer, ExpressionSyntax node, CancellationToken cancellationToken);
    internal virtual CSharpTypeInfo GetTypeInfoWorker(CSharpSyntaxNode node, CancellationToken cancellationToken);
    private Symbol GetSemanticInfoSymbolInNonMemberContext(CSharpSyntaxNode node, bool bindVarAsAliasFirst);
    internal virtual ImmutableArray`1<Symbol> GetMemberGroupWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken);
    internal virtual ImmutableArray`1<PropertySymbol> GetIndexerGroupWorker(CSharpSyntaxNode node, SymbolInfoOptions options, CancellationToken cancellationToken);
    internal virtual Optional`1<object> GetConstantValueWorker(CSharpSyntaxNode node, CancellationToken cancellationToken);
    public virtual QueryClauseInfo GetQueryClauseInfo(QueryClauseSyntax node, CancellationToken cancellationToken);
    public virtual SymbolInfo GetSymbolInfo(SelectOrGroupClauseSyntax node, CancellationToken cancellationToken);
    public virtual TypeInfo GetTypeInfo(SelectOrGroupClauseSyntax node, CancellationToken cancellationToken);
    public virtual IPropertySymbol GetDeclaredSymbol(AnonymousObjectMemberDeclaratorSyntax declaratorSyntax, CancellationToken cancellationToken);
    public virtual INamedTypeSymbol GetDeclaredSymbol(AnonymousObjectCreationExpressionSyntax declaratorSyntax, CancellationToken cancellationToken);
    public virtual IRangeVariableSymbol GetDeclaredSymbol(QueryClauseSyntax node, CancellationToken cancellationToken);
    public virtual IRangeVariableSymbol GetDeclaredSymbol(JoinIntoClauseSyntax node, CancellationToken cancellationToken);
    public virtual IRangeVariableSymbol GetDeclaredSymbol(QueryContinuationSyntax node, CancellationToken cancellationToken);
    public virtual SymbolInfo GetSymbolInfo(OrderingSyntax node, CancellationToken cancellationToken);
    private ConsList`1<Symbol> GetBasesBeingResolved(TypeSyntax expression);
    public virtual Conversion ClassifyConversion(ExpressionSyntax expression, ITypeSymbol destination, bool isExplicitInSource);
    internal virtual Conversion ClassifyConversionForCast(ExpressionSyntax expression, TypeSymbol destination);
    public virtual bool get_IsSpeculativeSemanticModel();
    public virtual int get_OriginalPositionForSpeculation();
    public virtual CSharpSemanticModel get_ParentModel();
    internal sealed virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, TypeSyntax type, SpeculativeBindingOption bindingOption, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, CrefSyntax crefSyntax, SemanticModel& speculativeModel);
    internal sealed virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, StatementSyntax statement, SemanticModel& speculativeModel);
    internal sealed virtual bool TryGetSpeculativeSemanticModelForMethodBodyCore(SyntaxTreeSemanticModel parentModel, int position, BaseMethodDeclarationSyntax method, SemanticModel& speculativeModel);
    internal sealed virtual bool TryGetSpeculativeSemanticModelForMethodBodyCore(SyntaxTreeSemanticModel parentModel, int position, AccessorDeclarationSyntax accessor, SemanticModel& speculativeModel);
    internal sealed virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, EqualsValueClauseSyntax initializer, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, ArrowExpressionClauseSyntax expressionBody, SemanticModel& speculativeModel);
    internal sealed virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, ConstructorInitializerSyntax constructorInitializer, SemanticModel& speculativeModel);
    private MemberSemanticModel GetMemberModel(int position);
    internal virtual MemberSemanticModel GetMemberModel(CSharpSyntaxNode node);
    private static bool IsInDocumentationComment(CSharpSyntaxNode node);
    private MemberSemanticModel GetOrAddModelForParameterDefaultValue(SeparatedSyntaxList`1<ParameterSyntax> parameterList, TextSpan span);
    private static CSharpSyntaxNode GetMemberDeclaration(CSharpSyntaxNode node);
    private MemberSemanticModel GetOrAddModelIfContains(CSharpSyntaxNode node, TextSpan span);
    private MemberSemanticModel GetOrAddModel(CSharpSyntaxNode node);
    private MemberSemanticModel CreateMemberModel(CSharpSyntaxNode node);
    private SourceMemberFieldSymbol GetDeclaredFieldSymbol(VariableDeclaratorSyntax variableDecl);
    private Binder GetFieldOrPropertyInitializerBinder(FieldSymbol symbol, Binder outer);
    private static bool IsMemberDeclaration(CSharpSyntaxNode node);
    private bool get_IsRegularCSharp();
    public virtual INamespaceSymbol GetDeclaredSymbol(NamespaceDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    private NamespaceSymbol GetDeclaredNamespace(NamespaceDeclarationSyntax declarationSyntax);
    public virtual INamedTypeSymbol GetDeclaredSymbol(BaseTypeDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual INamedTypeSymbol GetDeclaredSymbol(DelegateDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    private NamedTypeSymbol GetDeclaredType(BaseTypeDeclarationSyntax declarationSyntax);
    private NamedTypeSymbol GetDeclaredType(DelegateDeclarationSyntax declarationSyntax);
    private NamedTypeSymbol GetDeclaredNamedType(CSharpSyntaxNode declarationSyntax, string name);
    private NamespaceOrTypeSymbol GetDeclaredNamespaceOrType(CSharpSyntaxNode declarationSyntax);
    public virtual ISymbol GetDeclaredSymbol(MemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IFieldSymbol GetDeclaredSymbol(EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IMethodSymbol GetDeclaredSymbol(BaseMethodDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual ISymbol GetDeclaredSymbol(BasePropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IPropertySymbol GetDeclaredSymbol(PropertyDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IPropertySymbol GetDeclaredSymbol(IndexerDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IEventSymbol GetDeclaredSymbol(EventDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IMethodSymbol GetDeclaredSymbol(AccessorDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IMethodSymbol GetDeclaredSymbol(ArrowExpressionClauseSyntax declarationSyntax, CancellationToken cancellationToken);
    private string GetDeclarationName(CSharpSyntaxNode declaration);
    private string GetDeclarationName(CSharpSyntaxNode declaration, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifierOpt, string memberName);
    private Symbol GetDeclaredMember(NamespaceOrTypeSymbol container, TextSpan declarationSpan, NameSyntax name);
    private Symbol GetDeclaredMember(NamespaceOrTypeSymbol container, TextSpan declarationSpan, string name);
    public virtual ISymbol GetDeclaredSymbol(VariableDeclaratorSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual ILabelSymbol GetDeclaredSymbol(LabeledStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual ILabelSymbol GetDeclaredSymbol(SwitchLabelSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IAliasSymbol GetDeclaredSymbol(UsingDirectiveSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IAliasSymbol GetDeclaredSymbol(ExternAliasDirectiveSyntax declarationSyntax, CancellationToken cancellationToken);
    internal virtual ImmutableArray`1<ISymbol> GetDeclaredSymbols(BaseFieldDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    private ParameterSymbol GetMethodParameterSymbol(ParameterSyntax parameter, CancellationToken cancellationToken);
    private ParameterSymbol GetIndexerParameterSymbol(ParameterSyntax parameter, CancellationToken cancellationToken);
    private ParameterSymbol GetDelegateParameterSymbol(ParameterSyntax parameter, CancellationToken cancellationToken);
    public virtual IParameterSymbol GetDeclaredSymbol(ParameterSyntax declarationSyntax, CancellationToken cancellationToken);
    private ParameterSymbol GetDeclaredNonLambdaParameterSymbol(ParameterSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual ITypeParameterSymbol GetDeclaredSymbol(TypeParameterSyntax typeParameter, CancellationToken cancellationToken);
    private TypeParameterSymbol GetTypeParameterSymbol(ImmutableArray`1<TypeParameterSymbol> parameters, TypeParameterSyntax parameter);
    public virtual ControlFlowAnalysis AnalyzeControlFlow(StatementSyntax firstStatement, StatementSyntax lastStatement);
    private void ValidateStatementRange(StatementSyntax firstStatement, StatementSyntax lastStatement);
    public virtual DataFlowAnalysis AnalyzeDataFlow(ExpressionSyntax expression);
    public virtual DataFlowAnalysis AnalyzeDataFlow(StatementSyntax firstStatement, StatementSyntax lastStatement);
    private static BoundNode GetBoundRoot(MemberSemanticModel memberModel, Symbol& member);
    private NamespaceOrTypeSymbol GetDeclaredTypeMemberContainer(CSharpSyntaxNode memberDeclaration);
    private Symbol GetDeclaredMemberSymbol(CSharpSyntaxNode declarationSyntax);
    public virtual AwaitExpressionInfo GetAwaitExpressionInfo(AwaitExpressionSyntax node);
    public virtual ForEachStatementInfo GetForEachStatementInfo(ForEachStatementSyntax node);
    private RegionAnalysisContext RegionAnalysisContext(ExpressionSyntax expression);
    private RegionAnalysisContext RegionAnalysisContext(StatementSyntax firstStatement, StatementSyntax lastStatement);
}
internal static class Microsoft.CodeAnalysis.CSharp.SyntaxTriviaFunctions : object {
    internal static Func`2<SyntaxTrivia, bool> Any;
    internal static Func`2<SyntaxTrivia, bool> Skipped;
    private static SyntaxTriviaFunctions();
}
internal class Microsoft.CodeAnalysis.CSharp.SynthesizedLambdaMethod : SynthesizedMethodBaseSymbol {
    private MethodSymbol _topLevelMethod;
    internal int ParameterCount { get; }
    protected ImmutableArray`1<ParameterSymbol> BaseMethodParameters { get; }
    internal bool GenerateDebugInfo { get; }
    internal bool IsExpressionBodied { get; }
    internal MethodSymbol TopLevelMethod { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.Method { get; }
    private bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.HasMethodBodyDependency { get; }
    internal SynthesizedLambdaMethod(NamedTypeSymbol containingType, ClosureKind closureKind, MethodSymbol topLevelMethod, DebugId topLevelMethodId, BoundLambda lambdaNode, DebugId lambdaId);
    private static string MakeName(string topLevelMethodName, DebugId topLevelMethodId, ClosureKind closureKind, DebugId lambdaId);
    internal virtual int get_ParameterCount();
    protected virtual ImmutableArray`1<ParameterSymbol> get_BaseMethodParameters();
    internal virtual bool get_GenerateDebugInfo();
    internal virtual bool get_IsExpressionBodied();
    internal MethodSymbol get_TopLevelMethod();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_Method();
    private sealed virtual override bool Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_HasMethodBodyDependency();
}
internal class Microsoft.CodeAnalysis.CSharp.SynthesizedMetadataCompiler : CSharpSymbolVisitor {
    private PEModuleBuilder _moduleBeingBuilt;
    private CancellationToken _cancellationToken;
    private SynthesizedMetadataCompiler(PEModuleBuilder moduleBeingBuilt, CancellationToken cancellationToken);
    public static void ProcessSynthesizedMembers(CSharpCompilation compilation, PEModuleBuilder moduleBeingBuilt, CancellationToken cancellationToken);
    public virtual void VisitNamespace(NamespaceSymbol symbol);
    public virtual void VisitNamedType(NamedTypeSymbol symbol);
    public virtual void VisitProperty(PropertySymbol symbol);
}
internal class Microsoft.CodeAnalysis.CSharp.SynthesizedStateMachineDebuggerHiddenMethod : SynthesizedStateMachineMethod {
    public SynthesizedStateMachineDebuggerHiddenMethod(string name, MethodSymbol interfaceMethod, StateMachineTypeSymbol stateMachineType, PropertySymbol associatedProperty, bool hasMethodBodyDependency);
    internal sealed virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.SynthesizedStateMachineMethod : SynthesizedImplementationMethod {
    private bool _hasMethodBodyDependency;
    public StateMachineTypeSymbol StateMachineType { get; }
    public bool HasMethodBodyDependency { get; }
    private IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.Method { get; }
    protected SynthesizedStateMachineMethod(string name, MethodSymbol interfaceMethod, StateMachineTypeSymbol stateMachineType, PropertySymbol associatedProperty, bool generateDebugInfo, bool hasMethodBodyDependency);
    public StateMachineTypeSymbol get_StateMachineType();
    public sealed virtual bool get_HasMethodBodyDependency();
    private sealed virtual override IMethodSymbol Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol.get_Method();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal class Microsoft.CodeAnalysis.CSharp.SynthesizedStateMachineMoveNextMethod : SynthesizedStateMachineMethod {
    private ImmutableArray`1<CSharpAttributeData> _attributes;
    public SynthesizedStateMachineMoveNextMethod(MethodSymbol interfaceMethod, StateMachineTypeSymbol stateMachineType);
    public virtual ImmutableArray`1<CSharpAttributeData> GetAttributes();
}
internal class Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields : object {
    private NamedTypeSymbol _declaringSubmissionClass;
    private CSharpCompilation _compilation;
    private FieldSymbol _hostObjectField;
    private Dictionary`2<ImplicitNamedTypeSymbol, FieldSymbol> _previousSubmissionFieldMap;
    internal int Count { get; }
    internal IEnumerable`1<FieldSymbol> FieldSymbols { get; }
    public SynthesizedSubmissionFields(CSharpCompilation compilation, NamedTypeSymbol submissionClass);
    internal int get_Count();
    internal IEnumerable`1<FieldSymbol> get_FieldSymbols();
    internal FieldSymbol GetHostObjectField();
    internal FieldSymbol GetOrMakeField(ImplicitNamedTypeSymbol previousSubmissionType);
    internal void AddToType(NamedTypeSymbol containingType, PEModuleBuilder moduleBeingBuilt);
}
internal class Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory : object {
    [CompilerGeneratedAttribute]
private CSharpSyntaxNode <Syntax>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticBag <Diagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeCompilationState <CompilationState>k__BackingField;
    private NamedTypeSymbol _currentType;
    private MethodSymbol _currentMethod;
    private MethodSymbol _topLevelMethod;
    private Binder _binder;
    public CSharpCompilation Compilation { get; }
    public CSharpSyntaxNode Syntax { get; public set; }
    public PEModuleBuilder ModuleBuilderOpt { get; }
    public DiagnosticBag Diagnostics { get; }
    public TypeCompilationState CompilationState { get; }
    public NamedTypeSymbol CurrentType { get; public set; }
    public MethodSymbol CurrentMethod { get; public set; }
    public MethodSymbol TopLevelMethod { get; private set; }
    public SyntheticBoundNodeFactory(MethodSymbol topLevelMethod, CSharpSyntaxNode node, TypeCompilationState compilationState, DiagnosticBag diagnostics);
    public SyntheticBoundNodeFactory(MethodSymbol topLevelMethodOpt, NamedTypeSymbol currentClassOpt, CSharpSyntaxNode node, TypeCompilationState compilationState, DiagnosticBag diagnostics);
    public CSharpCompilation get_Compilation();
    [CompilerGeneratedAttribute]
public CSharpSyntaxNode get_Syntax();
    [CompilerGeneratedAttribute]
public void set_Syntax(CSharpSyntaxNode value);
    public PEModuleBuilder get_ModuleBuilderOpt();
    [CompilerGeneratedAttribute]
public DiagnosticBag get_Diagnostics();
    [CompilerGeneratedAttribute]
public TypeCompilationState get_CompilationState();
    public NamedTypeSymbol get_CurrentType();
    public void set_CurrentType(NamedTypeSymbol value);
    public MethodSymbol get_CurrentMethod();
    public void set_CurrentMethod(MethodSymbol value);
    public MethodSymbol get_TopLevelMethod();
    private void set_TopLevelMethod(MethodSymbol value);
    internal BoundExpression MakeInvocationExpression(BinderFlags flags, CSharpSyntaxNode node, BoundExpression receiver, string methodName, ImmutableArray`1<BoundExpression> args, DiagnosticBag diagnostics, ImmutableArray`1<TypeSymbol> typeArgs, bool allowUnexpandedForm);
    [ConditionalAttribute("DEBUG")]
private void CheckCurrentType();
    public void AddNestedType(NamedTypeSymbol nestedType);
    public void OpenNestedType(NamedTypeSymbol nestedType);
    public BoundHoistedFieldAccess HoistedField(FieldSymbol field);
    public StateMachineFieldSymbol StateMachineField(TypeSymbol type, string name, bool isPublic);
    public StateMachineFieldSymbol StateMachineField(TypeSymbol type, string name, SynthesizedLocalKind synthesizedKind, int slotIndex);
    public StateMachineFieldSymbol StateMachineField(TypeSymbol type, string name, LocalSlotDebugInfo slotDebugInfo, int slotIndex);
    public void AddField(NamedTypeSymbol containingType, FieldSymbol field);
    public GeneratedLabelSymbol GenerateLabel(string prefix);
    public BoundThisReference This();
    public BoundExpression This(LocalSymbol thisTempOpt);
    public BoundBaseReference Base();
    public BoundParameter Parameter(ParameterSymbol p);
    public BoundFieldAccess Field(BoundExpression receiver, FieldSymbol f);
    public BoundExpression Property(WellKnownMember member);
    public BoundExpression Property(BoundExpression receiver, WellKnownMember member);
    public BoundExpression Property(BoundExpression receiver, string name);
    public BoundExpression Property(NamedTypeSymbol receiver, string name);
    public NamedTypeSymbol SpecialType(SpecialType st);
    public ArrayTypeSymbol WellKnownArrayType(WellKnownType elementType);
    public NamedTypeSymbol WellKnownType(WellKnownType wt);
    public Symbol WellKnownMember(WellKnownMember wm, bool isOptional);
    public MethodSymbol WellKnownMethod(WellKnownMember wm, bool isOptional);
    public Symbol SpecialMember(SpecialMember sm);
    public MethodSymbol SpecialMethod(SpecialMember sm);
    public PropertySymbol SpecialProperty(SpecialMember sm);
    public BoundExpressionStatement Assignment(BoundExpression left, BoundExpression right, RefKind refKind);
    public BoundExpressionStatement ExpressionStatement(BoundExpression expr);
    public BoundAssignmentOperator AssignmentExpression(BoundExpression left, BoundExpression right, RefKind refKind);
    public BoundBlock Block();
    public BoundBlock Block(ImmutableArray`1<BoundStatement> statements);
    public BoundBlock Block(BoundStatement[] statements);
    public BoundBlock Block(ImmutableArray`1<LocalSymbol> locals, BoundStatement[] statements);
    public BoundBlock Block(ImmutableArray`1<LocalSymbol> locals, ImmutableArray`1<BoundStatement> statements);
    public BoundReturnStatement Return(BoundExpression expression);
    public void CloseMethod(BoundStatement body);
    public LocalSymbol SynthesizedLocal(TypeSymbol type, SyntaxNode syntax, bool isPinned, RefKind refKind, SynthesizedLocalKind kind);
    public ParameterSymbol SynthesizedParameter(TypeSymbol type, string name, MethodSymbol container, int ordinal);
    public BoundBinaryOperator Binary(BinaryOperatorKind kind, TypeSymbol type, BoundExpression left, BoundExpression right);
    public BoundAsOperator As(BoundExpression operand, TypeSymbol type);
    public BoundBinaryOperator LogicalAnd(BoundExpression left, BoundExpression right);
    public BoundBinaryOperator LogicalOr(BoundExpression left, BoundExpression right);
    public BoundBinaryOperator IntEqual(BoundExpression left, BoundExpression right);
    public BoundBinaryOperator ObjectEqual(BoundExpression left, BoundExpression right);
    public BoundBinaryOperator ObjectNotEqual(BoundExpression left, BoundExpression right);
    public BoundBinaryOperator IntNotEqual(BoundExpression left, BoundExpression right);
    public BoundBinaryOperator IntLessThan(BoundExpression left, BoundExpression right);
    public BoundLiteral Literal(int value);
    public BoundLiteral Literal(UInt32 value);
    public BoundObjectCreationExpression New(NamedTypeSymbol type, BoundExpression[] args);
    public BoundObjectCreationExpression New(MethodSymbol ctor, BoundExpression[] args);
    public BoundExpression StaticCall(TypeSymbol receiver, string name, BoundExpression[] args);
    public BoundExpression StaticCall(TypeSymbol receiver, string name, ImmutableArray`1<BoundExpression> args, bool allowUnexpandedForm);
    public BoundExpression StaticCall(BinderFlags flags, TypeSymbol receiver, string name, ImmutableArray`1<TypeSymbol> typeArgs, BoundExpression[] args);
    public BoundExpression StaticCall(TypeSymbol receiver, MethodSymbol method, BoundExpression[] args);
    public BoundCall Call(BoundExpression receiver, MethodSymbol method);
    public BoundCall Call(BoundExpression receiver, MethodSymbol method, BoundExpression arg0);
    public BoundCall Call(BoundExpression receiver, MethodSymbol method, BoundExpression arg0, BoundExpression arg1);
    public BoundCall Call(BoundExpression receiver, MethodSymbol method, BoundExpression[] args);
    public BoundCall Call(BoundExpression receiver, MethodSymbol method, ImmutableArray`1<BoundExpression> args);
    public BoundExpression Conditional(BoundExpression condition, BoundExpression consequence, BoundExpression alternative, TypeSymbol type);
    public BoundExpression ComplexConditionalReceiver(BoundExpression valueTypeReceiver, BoundExpression referenceTypeReceiver);
    public BoundExpression Coalesce(BoundExpression left, BoundExpression right);
    public BoundStatement If(BoundExpression condition, BoundStatement thenClause, BoundStatement elseClauseOpt);
    public BoundStatement For(BoundExpression initialization, BoundExpression termination, BoundExpression increment, BoundStatement body);
    public BoundThrowStatement Throw(BoundExpression e);
    public BoundLocal Local(LocalSymbol local);
    public BoundExpression Sequence(LocalSymbol temp, BoundExpression[] parts);
    public BoundExpression Sequence(BoundExpression[] parts);
    public BoundExpression Sequence(ImmutableArray`1<LocalSymbol> locals, BoundExpression[] parts);
    public BoundExpression Sequence(BoundExpression[] sideEffects, BoundExpression result, TypeSymbol type);
    public BoundExpression Sequence(ImmutableArray`1<LocalSymbol> locals, ImmutableArray`1<BoundExpression> sideEffects, BoundExpression result);
    public BoundStatement Switch(BoundExpression ex, BoundSwitchSection[] sections);
    public BoundStatement Switch(BoundExpression ex, IEnumerable`1<BoundSwitchSection> sections);
    [ConditionalAttribute("DEBUG")]
private static void CheckSwitchSections(ImmutableArray`1<BoundSwitchSection> sections);
    public BoundSwitchSection SwitchSection(int value, BoundStatement[] statements);
    public BoundSwitchSection SwitchSection(List`1<int> values, BoundStatement[] statements);
    public BoundGotoStatement Goto(LabelSymbol label);
    public BoundLabelStatement Label(LabelSymbol label);
    public BoundLiteral Literal(bool value);
    public BoundLiteral Literal(string value);
    public BoundLiteral StringLiteral(ConstantValue stringConst);
    public BoundLiteral StringLiteral(string stringValue);
    public BoundArrayLength ArrayLength(BoundExpression array);
    public BoundArrayAccess ArrayAccessFirstElement(BoundExpression array);
    public BoundArrayAccess ArrayAccess(BoundExpression array, BoundExpression[] indices);
    public BoundArrayAccess ArrayAccess(BoundExpression array, ImmutableArray`1<BoundExpression> indices);
    public BoundStatement BaseInitialization();
    public BoundStatement SequencePoint(CSharpSyntaxNode syntax, BoundStatement statement);
    public BoundStatement SequencePointWithSpan(CSharpSyntaxNode syntax, TextSpan span, BoundStatement statement);
    public BoundStatement HiddenSequencePoint();
    public BoundStatement ThrowNull();
    public BoundExpression Null(TypeSymbol type);
    public BoundTypeExpression Type(TypeSymbol type);
    public BoundExpression Typeof(WellKnownType type);
    public BoundExpression Typeof(TypeSymbol type);
    public ImmutableArray`1<BoundExpression> TypeOfs(ImmutableArray`1<TypeSymbol> typeArguments);
    public BoundExpression TypeofDynamicOperationContextType();
    public BoundExpression Sizeof(TypeSymbol type);
    internal BoundExpression ConstructorInfo(MethodSymbol ctor);
    public BoundExpression MethodInfo(MethodSymbol method);
    public BoundExpression FieldInfo(FieldSymbol field);
    private MethodSymbol GetMethodFromHandleMethod(NamedTypeSymbol methodContainer);
    private MethodSymbol GetFieldFromHandleMethod(NamedTypeSymbol fieldContainer);
    public BoundExpression Convert(TypeSymbol type, BoundExpression arg);
    public BoundExpression Convert(TypeSymbol type, BoundExpression arg, Conversion conversion, bool isChecked);
    public BoundExpression Convert(TypeSymbol type, BoundExpression arg, ConversionKind conversionKind, bool isChecked);
    public BoundExpression ArrayOrEmpty(TypeSymbol elementType, BoundExpression[] elements);
    public BoundExpression ArrayOrEmpty(TypeSymbol elementType, ImmutableArray`1<BoundExpression> elements);
    public BoundExpression Array(TypeSymbol elementType, ImmutableArray`1<BoundExpression> elements);
    internal BoundExpression Default(TypeSymbol type);
    internal BoundStatement Try(BoundBlock tryBlock, ImmutableArray`1<BoundCatchBlock> catchBlocks, BoundBlock finallyBlock);
    internal ImmutableArray`1<BoundCatchBlock> CatchBlocks(BoundCatchBlock[] catchBlocks);
    internal BoundCatchBlock Catch(LocalSymbol local, BoundBlock block);
    internal BoundCatchBlock Catch(BoundExpression source, BoundBlock block);
    internal BoundTryStatement Fault(BoundBlock tryBlock, BoundBlock faultBlock);
    internal BoundExpression NullOrDefault(TypeSymbol typeSymbol);
    internal BoundExpression Not(BoundExpression expression);
    public BoundLocal StoreToTemp(BoundExpression argument, BoundAssignmentOperator& store, RefKind refKind, SynthesizedLocalKind kind, CSharpSyntaxNode syntaxOpt);
    internal BoundStatement NoOp(NoOpStatementFlavor noOpStatementFlavor);
}
internal class Microsoft.CodeAnalysis.CSharp.TypeCompilationState : object {
    private ArrayBuilder`1<MethodWithBody> _synthesizedMethods;
    private Dictionary`2<MethodSymbol, MethodSymbol> _wrappers;
    private NamedTypeSymbol _typeOpt;
    public PEModuleBuilder ModuleBuilderOpt;
    public ImportChain CurrentImportChain;
    public CSharpCompilation Compilation;
    public LambdaFrame StaticLambdaFrame;
    private SmallDictionary`2<MethodSymbol, MethodSymbol> _constructorInitializers;
    public NamedTypeSymbol Type { get; }
    public NamedTypeSymbol DynamicOperationContextType { get; }
    public bool Emitting { get; }
    public ArrayBuilder`1<MethodWithBody> SynthesizedMethods { get; }
    public int NextWrapperMethodIndex { get; }
    public TypeCompilationState(NamedTypeSymbol typeOpt, CSharpCompilation compilation, PEModuleBuilder moduleBuilderOpt);
    public NamedTypeSymbol get_Type();
    public NamedTypeSymbol get_DynamicOperationContextType();
    public bool get_Emitting();
    public ArrayBuilder`1<MethodWithBody> get_SynthesizedMethods();
    public void AddSynthesizedMethod(MethodSymbol method, BoundStatement body);
    public void AddMethodWrapper(MethodSymbol method, MethodSymbol wrapper, BoundStatement body);
    public int get_NextWrapperMethodIndex();
    public MethodSymbol GetMethodWrapper(MethodSymbol method);
    public void Free();
    internal void ReportCtorInitializerCycles(MethodSymbol method1, MethodSymbol method2, CSharpSyntaxNode syntax, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.CSharp.TypeConversions : ConversionsBase {
    public TypeConversions(AssemblySymbol corLibrary);
    private TypeConversions(AssemblySymbol corLibrary, int currentRecursionDepth);
    protected virtual ConversionsBase CreateInstance(int currentRecursionDepth);
    public virtual Conversion GetMethodGroupConversion(BoundMethodGroup source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    protected virtual Conversion GetInterpolatedStringConversion(BoundInterpolatedString source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.CSharp.TypedConstantExtensions : object {
    [ExtensionAttribute]
public static string ToCSharpString(TypedConstant constant);
    private static string DisplayEnumConstant(TypedConstant constant);
    private static string DisplayUnsignedEnumConstant(TypedConstant constant, SpecialType specialType, ulong constantToDecode, string typeName);
    private static string DisplaySignedEnumConstant(TypedConstant constant, SpecialType specialType, long constantToDecode, string typeName);
}
internal class Microsoft.CodeAnalysis.CSharp.TypeofBinder : Binder {
    private Dictionary`2<GenericNameSyntax, bool> _allowedMap;
    private bool _isTypeExpressionOpen;
    internal bool IsTypeExpressionOpen { get; }
    internal TypeofBinder(ExpressionSyntax typeExpression, Binder next);
    internal bool get_IsTypeExpressionOpen();
    protected virtual bool IsUnboundTypeAllowed(GenericNameSyntax syntax);
}
internal static class Microsoft.CodeAnalysis.CSharp.TypeUnification : object {
    public static bool CanUnify(TypeSymbol t1, TypeSymbol t2);
    private static bool CanUnifyHelper(TypeWithModifiers t1, TypeWithModifiers t2, MutableTypeMap& substitution);
    private static void AddSubstitution(MutableTypeMap& substitution, TypeParameterSymbol tp1, TypeWithModifiers t2);
    private static bool Contains(TypeSymbol type, TypeParameterSymbol typeParam);
}
internal class Microsoft.CodeAnalysis.CSharp.UnaryOperatorAnalysisResult : ValueType {
    public UnaryOperatorSignature Signature;
    public Conversion Conversion;
    public OperatorAnalysisResultKind Kind;
    public bool IsValid { get; }
    public bool HasValue { get; }
    private UnaryOperatorAnalysisResult(OperatorAnalysisResultKind kind, UnaryOperatorSignature signature, Conversion conversion);
    public bool get_IsValid();
    public bool get_HasValue();
    public static UnaryOperatorAnalysisResult Applicable(UnaryOperatorSignature signature, Conversion conversion);
    public static UnaryOperatorAnalysisResult Inapplicable(UnaryOperatorSignature signature, Conversion conversion);
    public UnaryOperatorAnalysisResult Worse();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.CSharp.UnaryOperatorKind : Enum {
    public int value__;
    public static UnaryOperatorKind TypeMask;
    public static UnaryOperatorKind SByte;
    public static UnaryOperatorKind Byte;
    public static UnaryOperatorKind Short;
    public static UnaryOperatorKind UShort;
    public static UnaryOperatorKind Int;
    public static UnaryOperatorKind UInt;
    public static UnaryOperatorKind Long;
    public static UnaryOperatorKind ULong;
    public static UnaryOperatorKind Char;
    public static UnaryOperatorKind Float;
    public static UnaryOperatorKind Double;
    public static UnaryOperatorKind Decimal;
    public static UnaryOperatorKind Bool;
    public static UnaryOperatorKind _Object;
    public static UnaryOperatorKind _String;
    public static UnaryOperatorKind _StringAndObject;
    public static UnaryOperatorKind _ObjectAndString;
    public static UnaryOperatorKind Enum;
    public static UnaryOperatorKind _EnumAndUnderlying;
    public static UnaryOperatorKind _UnderlyingAndEnum;
    public static UnaryOperatorKind _Delegate;
    public static UnaryOperatorKind Pointer;
    public static UnaryOperatorKind _PointerAndInt;
    public static UnaryOperatorKind _PointerAndUInt;
    public static UnaryOperatorKind _PointerAndLong;
    public static UnaryOperatorKind _PointerAndULong;
    public static UnaryOperatorKind _IntAndPointer;
    public static UnaryOperatorKind _UIntAndPointer;
    public static UnaryOperatorKind _LongAndPointer;
    public static UnaryOperatorKind _ULongAndPointer;
    public static UnaryOperatorKind _NullableNull;
    public static UnaryOperatorKind UserDefined;
    public static UnaryOperatorKind Dynamic;
    public static UnaryOperatorKind OpMask;
    public static UnaryOperatorKind PostfixIncrement;
    public static UnaryOperatorKind PostfixDecrement;
    public static UnaryOperatorKind PrefixIncrement;
    public static UnaryOperatorKind PrefixDecrement;
    public static UnaryOperatorKind UnaryPlus;
    public static UnaryOperatorKind UnaryMinus;
    public static UnaryOperatorKind LogicalNegation;
    public static UnaryOperatorKind BitwiseComplement;
    public static UnaryOperatorKind True;
    public static UnaryOperatorKind False;
    public static UnaryOperatorKind Lifted;
    public static UnaryOperatorKind _Logical;
    public static UnaryOperatorKind Checked;
    public static UnaryOperatorKind Error;
    public static UnaryOperatorKind SBytePostfixIncrement;
    public static UnaryOperatorKind BytePostfixIncrement;
    public static UnaryOperatorKind ShortPostfixIncrement;
    public static UnaryOperatorKind UShortPostfixIncrement;
    public static UnaryOperatorKind IntPostfixIncrement;
    public static UnaryOperatorKind UIntPostfixIncrement;
    public static UnaryOperatorKind LongPostfixIncrement;
    public static UnaryOperatorKind ULongPostfixIncrement;
    public static UnaryOperatorKind CharPostfixIncrement;
    public static UnaryOperatorKind FloatPostfixIncrement;
    public static UnaryOperatorKind DoublePostfixIncrement;
    public static UnaryOperatorKind DecimalPostfixIncrement;
    public static UnaryOperatorKind EnumPostfixIncrement;
    public static UnaryOperatorKind UserDefinedPostfixIncrement;
    public static UnaryOperatorKind LiftedSBytePostfixIncrement;
    public static UnaryOperatorKind LiftedBytePostfixIncrement;
    public static UnaryOperatorKind LiftedShortPostfixIncrement;
    public static UnaryOperatorKind LiftedUShortPostfixIncrement;
    public static UnaryOperatorKind LiftedIntPostfixIncrement;
    public static UnaryOperatorKind LiftedUIntPostfixIncrement;
    public static UnaryOperatorKind LiftedLongPostfixIncrement;
    public static UnaryOperatorKind LiftedULongPostfixIncrement;
    public static UnaryOperatorKind LiftedCharPostfixIncrement;
    public static UnaryOperatorKind LiftedFloatPostfixIncrement;
    public static UnaryOperatorKind LiftedDoublePostfixIncrement;
    public static UnaryOperatorKind LiftedDecimalPostfixIncrement;
    public static UnaryOperatorKind LiftedEnumPostfixIncrement;
    public static UnaryOperatorKind LiftedUserDefinedPostfixIncrement;
    public static UnaryOperatorKind PointerPostfixIncrement;
    public static UnaryOperatorKind DynamicPostfixIncrement;
    public static UnaryOperatorKind SBytePrefixIncrement;
    public static UnaryOperatorKind BytePrefixIncrement;
    public static UnaryOperatorKind ShortPrefixIncrement;
    public static UnaryOperatorKind UShortPrefixIncrement;
    public static UnaryOperatorKind IntPrefixIncrement;
    public static UnaryOperatorKind UIntPrefixIncrement;
    public static UnaryOperatorKind LongPrefixIncrement;
    public static UnaryOperatorKind ULongPrefixIncrement;
    public static UnaryOperatorKind CharPrefixIncrement;
    public static UnaryOperatorKind FloatPrefixIncrement;
    public static UnaryOperatorKind DoublePrefixIncrement;
    public static UnaryOperatorKind DecimalPrefixIncrement;
    public static UnaryOperatorKind EnumPrefixIncrement;
    public static UnaryOperatorKind UserDefinedPrefixIncrement;
    public static UnaryOperatorKind LiftedSBytePrefixIncrement;
    public static UnaryOperatorKind LiftedBytePrefixIncrement;
    public static UnaryOperatorKind LiftedShortPrefixIncrement;
    public static UnaryOperatorKind LiftedUShortPrefixIncrement;
    public static UnaryOperatorKind LiftedIntPrefixIncrement;
    public static UnaryOperatorKind LiftedUIntPrefixIncrement;
    public static UnaryOperatorKind LiftedLongPrefixIncrement;
    public static UnaryOperatorKind LiftedULongPrefixIncrement;
    public static UnaryOperatorKind LiftedCharPrefixIncrement;
    public static UnaryOperatorKind LiftedFloatPrefixIncrement;
    public static UnaryOperatorKind LiftedDoublePrefixIncrement;
    public static UnaryOperatorKind LiftedDecimalPrefixIncrement;
    public static UnaryOperatorKind LiftedEnumPrefixIncrement;
    public static UnaryOperatorKind LiftedUserDefinedPrefixIncrement;
    public static UnaryOperatorKind PointerPrefixIncrement;
    public static UnaryOperatorKind DynamicPrefixIncrement;
    public static UnaryOperatorKind SBytePostfixDecrement;
    public static UnaryOperatorKind BytePostfixDecrement;
    public static UnaryOperatorKind ShortPostfixDecrement;
    public static UnaryOperatorKind UShortPostfixDecrement;
    public static UnaryOperatorKind IntPostfixDecrement;
    public static UnaryOperatorKind UIntPostfixDecrement;
    public static UnaryOperatorKind LongPostfixDecrement;
    public static UnaryOperatorKind ULongPostfixDecrement;
    public static UnaryOperatorKind CharPostfixDecrement;
    public static UnaryOperatorKind FloatPostfixDecrement;
    public static UnaryOperatorKind DoublePostfixDecrement;
    public static UnaryOperatorKind DecimalPostfixDecrement;
    public static UnaryOperatorKind EnumPostfixDecrement;
    public static UnaryOperatorKind UserDefinedPostfixDecrement;
    public static UnaryOperatorKind LiftedSBytePostfixDecrement;
    public static UnaryOperatorKind LiftedBytePostfixDecrement;
    public static UnaryOperatorKind LiftedShortPostfixDecrement;
    public static UnaryOperatorKind LiftedUShortPostfixDecrement;
    public static UnaryOperatorKind LiftedIntPostfixDecrement;
    public static UnaryOperatorKind LiftedUIntPostfixDecrement;
    public static UnaryOperatorKind LiftedLongPostfixDecrement;
    public static UnaryOperatorKind LiftedULongPostfixDecrement;
    public static UnaryOperatorKind LiftedCharPostfixDecrement;
    public static UnaryOperatorKind LiftedFloatPostfixDecrement;
    public static UnaryOperatorKind LiftedDoublePostfixDecrement;
    public static UnaryOperatorKind LiftedDecimalPostfixDecrement;
    public static UnaryOperatorKind LiftedEnumPostfixDecrement;
    public static UnaryOperatorKind LiftedUserDefinedPostfixDecrement;
    public static UnaryOperatorKind PointerPostfixDecrement;
    public static UnaryOperatorKind DynamicPostfixDecrement;
    public static UnaryOperatorKind SBytePrefixDecrement;
    public static UnaryOperatorKind BytePrefixDecrement;
    public static UnaryOperatorKind ShortPrefixDecrement;
    public static UnaryOperatorKind UShortPrefixDecrement;
    public static UnaryOperatorKind IntPrefixDecrement;
    public static UnaryOperatorKind UIntPrefixDecrement;
    public static UnaryOperatorKind LongPrefixDecrement;
    public static UnaryOperatorKind ULongPrefixDecrement;
    public static UnaryOperatorKind CharPrefixDecrement;
    public static UnaryOperatorKind FloatPrefixDecrement;
    public static UnaryOperatorKind DoublePrefixDecrement;
    public static UnaryOperatorKind DecimalPrefixDecrement;
    public static UnaryOperatorKind EnumPrefixDecrement;
    public static UnaryOperatorKind UserDefinedPrefixDecrement;
    public static UnaryOperatorKind LiftedSBytePrefixDecrement;
    public static UnaryOperatorKind LiftedBytePrefixDecrement;
    public static UnaryOperatorKind LiftedShortPrefixDecrement;
    public static UnaryOperatorKind LiftedUShortPrefixDecrement;
    public static UnaryOperatorKind LiftedIntPrefixDecrement;
    public static UnaryOperatorKind LiftedUIntPrefixDecrement;
    public static UnaryOperatorKind LiftedLongPrefixDecrement;
    public static UnaryOperatorKind LiftedULongPrefixDecrement;
    public static UnaryOperatorKind LiftedCharPrefixDecrement;
    public static UnaryOperatorKind LiftedFloatPrefixDecrement;
    public static UnaryOperatorKind LiftedDoublePrefixDecrement;
    public static UnaryOperatorKind LiftedDecimalPrefixDecrement;
    public static UnaryOperatorKind LiftedEnumPrefixDecrement;
    public static UnaryOperatorKind LiftedUserDefinedPrefixDecrement;
    public static UnaryOperatorKind PointerPrefixDecrement;
    public static UnaryOperatorKind DynamicPrefixDecrement;
    public static UnaryOperatorKind IntUnaryPlus;
    public static UnaryOperatorKind UIntUnaryPlus;
    public static UnaryOperatorKind LongUnaryPlus;
    public static UnaryOperatorKind ULongUnaryPlus;
    public static UnaryOperatorKind FloatUnaryPlus;
    public static UnaryOperatorKind DoubleUnaryPlus;
    public static UnaryOperatorKind DecimalUnaryPlus;
    public static UnaryOperatorKind UserDefinedUnaryPlus;
    public static UnaryOperatorKind LiftedIntUnaryPlus;
    public static UnaryOperatorKind LiftedUIntUnaryPlus;
    public static UnaryOperatorKind LiftedLongUnaryPlus;
    public static UnaryOperatorKind LiftedULongUnaryPlus;
    public static UnaryOperatorKind LiftedFloatUnaryPlus;
    public static UnaryOperatorKind LiftedDoubleUnaryPlus;
    public static UnaryOperatorKind LiftedDecimalUnaryPlus;
    public static UnaryOperatorKind LiftedUserDefinedUnaryPlus;
    public static UnaryOperatorKind DynamicUnaryPlus;
    public static UnaryOperatorKind IntUnaryMinus;
    public static UnaryOperatorKind LongUnaryMinus;
    public static UnaryOperatorKind FloatUnaryMinus;
    public static UnaryOperatorKind DoubleUnaryMinus;
    public static UnaryOperatorKind DecimalUnaryMinus;
    public static UnaryOperatorKind UserDefinedUnaryMinus;
    public static UnaryOperatorKind LiftedIntUnaryMinus;
    public static UnaryOperatorKind LiftedLongUnaryMinus;
    public static UnaryOperatorKind LiftedFloatUnaryMinus;
    public static UnaryOperatorKind LiftedDoubleUnaryMinus;
    public static UnaryOperatorKind LiftedDecimalUnaryMinus;
    public static UnaryOperatorKind LiftedUserDefinedUnaryMinus;
    public static UnaryOperatorKind DynamicUnaryMinus;
    public static UnaryOperatorKind BoolLogicalNegation;
    public static UnaryOperatorKind UserDefinedLogicalNegation;
    public static UnaryOperatorKind LiftedBoolLogicalNegation;
    public static UnaryOperatorKind LiftedUserDefinedLogicalNegation;
    public static UnaryOperatorKind DynamicLogicalNegation;
    public static UnaryOperatorKind IntBitwiseComplement;
    public static UnaryOperatorKind UIntBitwiseComplement;
    public static UnaryOperatorKind LongBitwiseComplement;
    public static UnaryOperatorKind ULongBitwiseComplement;
    public static UnaryOperatorKind EnumBitwiseComplement;
    public static UnaryOperatorKind UserDefinedBitwiseComplement;
    public static UnaryOperatorKind LiftedIntBitwiseComplement;
    public static UnaryOperatorKind LiftedUIntBitwiseComplement;
    public static UnaryOperatorKind LiftedLongBitwiseComplement;
    public static UnaryOperatorKind LiftedULongBitwiseComplement;
    public static UnaryOperatorKind LiftedEnumBitwiseComplement;
    public static UnaryOperatorKind LiftedUserDefinedBitwiseComplement;
    public static UnaryOperatorKind DynamicBitwiseComplement;
    public static UnaryOperatorKind UserDefinedTrue;
    public static UnaryOperatorKind UserDefinedFalse;
    public static UnaryOperatorKind DynamicTrue;
    public static UnaryOperatorKind DynamicFalse;
}
internal class Microsoft.CodeAnalysis.CSharp.UnaryOperatorOverloadResolutionResult : object {
    public ArrayBuilder`1<UnaryOperatorAnalysisResult> Results;
    public static ObjectPool`1<UnaryOperatorOverloadResolutionResult> Pool;
    public UnaryOperatorAnalysisResult Best { get; }
    private static UnaryOperatorOverloadResolutionResult();
    public bool AnyValid();
    public int GetValidCount();
    public UnaryOperatorAnalysisResult get_Best();
    public static UnaryOperatorOverloadResolutionResult GetInstance();
    public void Free();
    private static ObjectPool`1<UnaryOperatorOverloadResolutionResult> CreatePool();
}
internal class Microsoft.CodeAnalysis.CSharp.UnaryOperatorSignature : ValueType {
    public static UnaryOperatorSignature Error;
    public MethodSymbol Method;
    public TypeSymbol OperandType;
    public TypeSymbol ReturnType;
    public UnaryOperatorKind Kind;
    public UnaryOperatorSignature(UnaryOperatorKind kind, TypeSymbol operandType, TypeSymbol returnType, MethodSymbol method);
    private static UnaryOperatorSignature();
    public virtual string ToString();
}
internal class Microsoft.CodeAnalysis.CSharp.UnassignedAddressTakenVariablesWalker : DataFlowPass {
    private HashSet`1<PrefixUnaryExpressionSyntax> _result;
    private UnassignedAddressTakenVariablesWalker(CSharpCompilation compilation, Symbol member, BoundNode node);
    internal static HashSet`1<PrefixUnaryExpressionSyntax> Analyze(CSharpCompilation compilation, Symbol member, BoundNode node);
    private HashSet`1<PrefixUnaryExpressionSyntax> Analyze(Boolean& badRegion);
    protected virtual void ReportUnassigned(Symbol symbol, CSharpSyntaxNode node);
    protected virtual void ReportUnassigned(FieldSymbol fieldSymbol, int unassignedSlot, CSharpSyntaxNode node);
    public virtual BoundNode VisitAddressOfOperator(BoundAddressOfOperator node);
}
internal class Microsoft.CodeAnalysis.CSharp.UnassignedVariablesWalker : DataFlowPass {
    private HashSet`1<Symbol> _result;
    private UnassignedVariablesWalker(CSharpCompilation compilation, Symbol member, BoundNode node);
    internal static HashSet`1<Symbol> Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, bool convertInsufficientExecutionStackExceptionToCancelledByStackGuardException);
    private HashSet`1<Symbol> Analyze(Boolean& badRegion);
    protected virtual void ReportUnassigned(Symbol symbol, CSharpSyntaxNode node);
    protected virtual void ReportUnassignedOutParameter(ParameterSymbol parameter, CSharpSyntaxNode node, Location location);
    protected virtual void ReportUnassigned(FieldSymbol fieldSymbol, int unassignedSlot, CSharpSyntaxNode node);
}
internal class Microsoft.CodeAnalysis.CSharp.UnboundLambda : BoundExpression {
    [CompilerGeneratedAttribute]
private UnboundLambdaState <Data>k__BackingField;
    protected OperationKind ExpressionKind { get; }
    public object Display { get; }
    public MessageID MessageID { get; }
    public bool HasSignature { get; }
    public bool HasExplicitlyTypedParameterList { get; }
    public int ParameterCount { get; }
    public bool IsAsync { get; }
    public UnboundLambdaState Data { get; }
    public UnboundLambda(CSharpSyntaxNode syntax, Binder binder, ImmutableArray`1<RefKind> refKinds, ImmutableArray`1<TypeSymbol> types, ImmutableArray`1<string> names, bool isAsync, bool hasErrors);
    public UnboundLambda(CSharpSyntaxNode syntax, UnboundLambdaState data, bool hasErrors);
    public UnboundLambda(CSharpSyntaxNode syntax, UnboundLambdaState data);
    protected virtual OperationKind get_ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual object get_Display();
    public MessageID get_MessageID();
    public BoundLambda Bind(NamedTypeSymbol delegateType);
    public BoundLambda BindForErrorRecovery();
    public BoundLambda BindForReturnTypeInference(NamedTypeSymbol delegateType);
    public bool get_HasSignature();
    public bool get_HasExplicitlyTypedParameterList();
    public int get_ParameterCount();
    public TypeSymbol InferReturnType(NamedTypeSymbol delegateType, HashSet`1& useSiteDiagnostics);
    public RefKind RefKind(int index);
    public void GenerateAnonymousFunctionConversionError(DiagnosticBag diagnostics, TypeSymbol targetType);
    public bool GenerateSummaryErrors(DiagnosticBag diagnostics);
    public bool get_IsAsync();
    public TypeSymbol ParameterType(int index);
    public Location ParameterLocation(int index);
    public string ParameterName(int index);
    [CompilerGeneratedAttribute]
public UnboundLambdaState get_Data();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public UnboundLambda Update(UnboundLambdaState data);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.UnboundLambdaState : object {
    private UnboundLambda _unboundLambda;
    protected Binder binder;
    private ConcurrentDictionary`2<object, BoundLambda> _bindingCache;
    private ConcurrentDictionary`2<MethodSymbol, BoundLambda> _returnInferenceCache;
    private BoundLambda _errorBinding;
    public UnboundLambda UnboundLambda { get; }
    public MessageID MessageID { get; }
    public bool HasSignature { get; }
    public bool HasExplicitlyTypedParameterList { get; }
    public int ParameterCount { get; }
    public bool IsAsync { get; }
    public UnboundLambdaState(Binder binder, UnboundLambda unboundLambdaOpt);
    public void SetUnboundLambda(UnboundLambda unbound);
    public UnboundLambda get_UnboundLambda();
    public abstract virtual MessageID get_MessageID();
    public abstract virtual string ParameterName(int index);
    public abstract virtual bool get_HasSignature();
    public abstract virtual bool get_HasExplicitlyTypedParameterList();
    public abstract virtual int get_ParameterCount();
    public abstract virtual bool get_IsAsync();
    public abstract virtual Location ParameterLocation(int index);
    public abstract virtual TypeSymbol ParameterType(int index);
    public abstract virtual RefKind RefKind(int index);
    protected abstract virtual BoundBlock BindLambdaBody(LambdaSymbol lambdaSymbol, Binder& lambdaBodyBinder, DiagnosticBag diagnostics);
    public virtual void GenerateAnonymousFunctionConversionError(DiagnosticBag diagnostics, TypeSymbol targetType);
    public BoundLambda Bind(NamedTypeSymbol delegateType);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UnboundLambdaState/<InferredReturnTypes>d__26")]
internal IEnumerable`1<TypeSymbol> InferredReturnTypes();
    private static ImmutableArray`1<ParameterSymbol> DelegateParameters(NamedTypeSymbol delegateType);
    private static TypeSymbol DelegateReturnType(NamedTypeSymbol delegateType);
    private bool DelegateNeedsReturn(NamedTypeSymbol delegateType);
    private BoundLambda ReallyBind(NamedTypeSymbol delegateType);
    private void ValidateUnsafeParameters(DiagnosticBag diagnostics, ImmutableArray`1<ParameterSymbol> parameters);
    private BoundLambda ReallyInferReturnType(NamedTypeSymbol delegateType);
    public BoundLambda BindForReturnTypeInference(NamedTypeSymbol delegateType);
    private static MethodSymbol GetCacheKey(NamedTypeSymbol delegateType);
    public TypeSymbol InferReturnType(NamedTypeSymbol delegateType, HashSet`1& useSiteDiagnostics);
    public virtual Binder ParameterBinder(LambdaSymbol lambdaSymbol, Binder binder);
    public BoundLambda BindForErrorRecovery();
    private BoundLambda ReallyBindForErrorRecovery();
    private static BoundLambda GuessBestBoundLambda(ICollection`1<BoundLambda> candidates);
    private static string GetLambdaSortString(LambdaSymbol lambda);
    public bool GenerateSummaryErrors(DiagnosticBag diagnostics);
    private static bool PreventsSuccessfulDelegateConversion(FirstAmongEqualsSet`1<Diagnostic> set);
    private static FirstAmongEqualsSet`1<Diagnostic> CreateFirstAmongEqualsSet(ImmutableArray`1<Diagnostic> bag);
    private static int CanonicallyCompareDiagnostics(Diagnostic x, Diagnostic y);
}
internal class Microsoft.CodeAnalysis.CSharp.UnmatchedGotoFinder : BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator {
    private Dictionary`2<BoundNode, HashSet`1<LabelSymbol>> _unmatchedLabelsCache;
    private HashSet`1<LabelSymbol> _gotos;
    private HashSet`1<LabelSymbol> _targets;
    private UnmatchedGotoFinder(Dictionary`2<BoundNode, HashSet`1<LabelSymbol>> unmatchedLabelsCache, int recursionDepth);
    public static HashSet`1<LabelSymbol> Find(BoundNode node, Dictionary`2<BoundNode, HashSet`1<LabelSymbol>> unmatchedLabelsCache, int recursionDepth);
    public virtual BoundNode Visit(BoundNode node);
    public virtual BoundNode VisitGotoStatement(BoundGotoStatement node);
    public virtual BoundNode VisitConditionalGoto(BoundConditionalGoto node);
    public virtual BoundNode VisitLabelStatement(BoundLabelStatement node);
    public virtual BoundNode VisitLabeledStatement(BoundLabeledStatement node);
    public virtual BoundNode VisitSwitchStatement(BoundSwitchStatement node);
    public virtual BoundNode VisitSwitchLabel(BoundSwitchLabel node);
    private void AddGoto(LabelSymbol label);
    private void AddTarget(LabelSymbol label);
}
internal class Microsoft.CodeAnalysis.CSharp.UnprocessedDocumentationCommentFinder : CSharpSyntaxWalker {
    private DiagnosticBag _diagnostics;
    private CancellationToken _cancellationToken;
    private Nullable`1<TextSpan> _filterSpanWithinTree;
    private bool _isValidLocation;
    private UnprocessedDocumentationCommentFinder(DiagnosticBag diagnostics, Nullable`1<TextSpan> filterSpanWithinTree, CancellationToken cancellationToken);
    public static void ReportUnprocessed(SyntaxTree tree, Nullable`1<TextSpan> filterSpanWithinTree, DiagnosticBag diagnostics, CancellationToken cancellationToken);
    private bool IsSyntacticallyFilteredOut(TextSpan fullSpan);
    public virtual void DefaultVisit(SyntaxNode node);
    public virtual void VisitLeadingTrivia(SyntaxToken token);
    public virtual void VisitTrivia(SyntaxTrivia trivia);
}
internal class Microsoft.CodeAnalysis.CSharp.UserDefinedConversionAnalysis : object {
    public TypeSymbol FromType;
    public TypeSymbol ToType;
    public MethodSymbol Operator;
    public Conversion SourceConversion;
    public Conversion TargetConversion;
    public UserDefinedConversionAnalysisKind Kind;
    private UserDefinedConversionAnalysis(UserDefinedConversionAnalysisKind kind, MethodSymbol op, Conversion sourceConversion, Conversion targetConversion, TypeSymbol fromType, TypeSymbol toType);
    public static UserDefinedConversionAnalysis Normal(MethodSymbol op, Conversion sourceConversion, Conversion targetConversion, TypeSymbol fromType, TypeSymbol toType);
    public static UserDefinedConversionAnalysis Lifted(MethodSymbol op, Conversion sourceConversion, Conversion targetConversion, TypeSymbol fromType, TypeSymbol toType);
}
internal enum Microsoft.CodeAnalysis.CSharp.UserDefinedConversionAnalysisKind : Enum {
    public byte value__;
    public static UserDefinedConversionAnalysisKind ApplicableInNormalForm;
    public static UserDefinedConversionAnalysisKind ApplicableInLiftedForm;
}
internal class Microsoft.CodeAnalysis.CSharp.UserDefinedConversionResult : ValueType {
    public ImmutableArray`1<UserDefinedConversionAnalysis> Results;
    public int Best;
    public UserDefinedConversionResultKind Kind;
    private UserDefinedConversionResult(UserDefinedConversionResultKind kind, ImmutableArray`1<UserDefinedConversionAnalysis> results, int best);
    public static UserDefinedConversionResult NoApplicableOperators(ImmutableArray`1<UserDefinedConversionAnalysis> results);
    public static UserDefinedConversionResult NoBestSourceType(ImmutableArray`1<UserDefinedConversionAnalysis> results);
    public static UserDefinedConversionResult NoBestTargetType(ImmutableArray`1<UserDefinedConversionAnalysis> results);
    public static UserDefinedConversionResult Ambiguous(ImmutableArray`1<UserDefinedConversionAnalysis> results);
    public static UserDefinedConversionResult Valid(ImmutableArray`1<UserDefinedConversionAnalysis> results, int best);
}
internal enum Microsoft.CodeAnalysis.CSharp.UserDefinedConversionResultKind : Enum {
    public byte value__;
    public static UserDefinedConversionResultKind NoApplicableOperators;
    public static UserDefinedConversionResultKind NoBestSourceType;
    public static UserDefinedConversionResultKind NoBestTargetType;
    public static UserDefinedConversionResultKind Ambiguous;
    public static UserDefinedConversionResultKind Valid;
}
internal class Microsoft.CodeAnalysis.CSharp.UsingStatementBinder : LockOrUsingBinder {
    private UsingStatementSyntax _syntax;
    protected ExpressionSyntax TargetExpressionSyntax { get; }
    public UsingStatementBinder(Binder enclosing, UsingStatementSyntax syntax);
    protected virtual ImmutableArray`1<LocalSymbol> BuildLocals();
    protected virtual ExpressionSyntax get_TargetExpressionSyntax();
    internal virtual BoundStatement BindUsingStatementParts(DiagnosticBag diagnostics, Binder originalBinder);
}
internal class Microsoft.CodeAnalysis.CSharp.VariablesDeclaredWalker : AbstractRegionControlFlowPass {
    private HashSet`1<Symbol> _variablesDeclared;
    internal VariablesDeclaredWalker(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion);
    internal static IEnumerable`1<Symbol> Analyze(CSharpCompilation compilation, Symbol member, BoundNode node, BoundNode firstInRegion, BoundNode lastInRegion);
    private void Analyze();
    protected virtual void Free();
    public virtual BoundNode VisitLocalDeclaration(BoundLocalDeclaration node);
    public virtual BoundNode VisitLambda(BoundLambda node);
    public virtual BoundNode VisitForEachStatement(BoundForEachStatement node);
    protected virtual void VisitCatchBlock(BoundCatchBlock catchBlock, LocalState& finallyState);
    public virtual BoundNode VisitQueryClause(BoundQueryClause node);
}
internal class Microsoft.CodeAnalysis.CSharp.WhileBinder : LoopBinder {
    private StatementSyntax _syntax;
    public WhileBinder(Binder enclosing, StatementSyntax syntax);
    internal virtual BoundWhileStatement BindWhileParts(DiagnosticBag diagnostics, Binder originalBinder);
    internal virtual BoundDoStatement BindDoParts(DiagnosticBag diagnostics, Binder originalBinder);
}
internal class Microsoft.CodeAnalysis.CSharp.WithClassTypeParametersBinder : WithTypeParametersBinder {
    private NamedTypeSymbol _namedType;
    private MultiDictionary`2<string, TypeParameterSymbol> _lazyTypeParameterMap;
    protected MultiDictionary`2<string, TypeParameterSymbol> TypeParameterMap { get; }
    internal WithClassTypeParametersBinder(NamedTypeSymbol container, Binder next);
    internal virtual bool IsAccessibleHelper(Symbol symbol, TypeSymbol accessThroughType, Boolean& failedThroughTypeCheck, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    protected virtual MultiDictionary`2<string, TypeParameterSymbol> get_TypeParameterMap();
    protected virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo result, LookupOptions options, Binder originalBinder);
}
internal class Microsoft.CodeAnalysis.CSharp.WithCrefTypeParametersBinder : WithTypeParametersBinder {
    private CrefSyntax _crefSyntax;
    private MultiDictionary`2<string, TypeParameterSymbol> _lazyTypeParameterMap;
    protected MultiDictionary`2<string, TypeParameterSymbol> TypeParameterMap { get; }
    internal WithCrefTypeParametersBinder(CrefSyntax crefSyntax, Binder next);
    protected virtual MultiDictionary`2<string, TypeParameterSymbol> get_TypeParameterMap();
    private MultiDictionary`2<string, TypeParameterSymbol> CreateTypeParameterMap();
    private void AddTypeParameters(TypeSyntax typeSyntax, MultiDictionary`2<string, TypeParameterSymbol> map);
    private void AddTypeParameters(MemberCrefSyntax memberSyntax, MultiDictionary`2<string, TypeParameterSymbol> map);
    private static void AddTypeParameters(GenericNameSyntax genericNameSyntax, MultiDictionary`2<string, TypeParameterSymbol> map);
    protected virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo result, LookupOptions options, Binder originalBinder);
}
internal class Microsoft.CodeAnalysis.CSharp.WithLambdaParametersBinder : LocalScopeBinder {
    protected LambdaSymbol lambdaSymbol;
    protected MultiDictionary`2<string, ParameterSymbol> parameterMap;
    private SmallDictionary`2<string, ParameterSymbol> _definitionMap;
    internal Symbol ContainingMemberOrLambda { get; }
    internal bool IsDirectlyInIterator { get; }
    public WithLambdaParametersBinder(LambdaSymbol lambdaSymbol, Binder enclosing);
    private void RecordDefinitions(ImmutableArray`1<ParameterSymbol> definitions);
    protected virtual TypeSymbol GetCurrentReturnType();
    internal virtual Symbol get_ContainingMemberOrLambda();
    internal virtual bool get_IsDirectlyInIterator();
    internal virtual TypeSymbol GetIteratorElementType(YieldStatementSyntax node, DiagnosticBag diagnostics);
    internal virtual void LookupSymbolsInSingleBinder(LookupResult result, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, HashSet`1& useSiteDiagnostics);
    protected virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo result, LookupOptions options, Binder originalBinder);
    private bool ReportConflictWithParameter(ParameterSymbol parameter, Symbol newSymbol, string name, Location newLocation, DiagnosticBag diagnostics);
    internal virtual bool EnsureSingleDefinition(Symbol symbol, string name, Location location, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.CSharp.WithMethodTypeParametersBinder : WithTypeParametersBinder {
    private MethodSymbol _methodSymbol;
    private MultiDictionary`2<string, TypeParameterSymbol> _lazyTypeParameterMap;
    internal Symbol ContainingMemberOrLambda { get; }
    protected MultiDictionary`2<string, TypeParameterSymbol> TypeParameterMap { get; }
    protected LookupOptions LookupMask { get; }
    internal WithMethodTypeParametersBinder(MethodSymbol methodSymbol, Binder next);
    internal virtual Symbol get_ContainingMemberOrLambda();
    protected virtual MultiDictionary`2<string, TypeParameterSymbol> get_TypeParameterMap();
    protected virtual LookupOptions get_LookupMask();
    protected virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo result, LookupOptions options, Binder originalBinder);
}
internal class Microsoft.CodeAnalysis.CSharp.WithParametersBinder : Binder {
    private ImmutableArray`1<ParameterSymbol> _parameters;
    internal WithParametersBinder(ImmutableArray`1<ParameterSymbol> parameters, Binder next);
    protected virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo result, LookupOptions options, Binder originalBinder);
    internal virtual void LookupSymbolsInSingleBinder(LookupResult result, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, HashSet`1& useSiteDiagnostics);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.WithTypeParametersBinder : Binder {
    protected MultiDictionary`2<string, TypeParameterSymbol> TypeParameterMap { get; }
    protected LookupOptions LookupMask { get; }
    internal WithTypeParametersBinder(Binder next);
    protected abstract virtual MultiDictionary`2<string, TypeParameterSymbol> get_TypeParameterMap();
    protected virtual LookupOptions get_LookupMask();
    protected bool CanConsiderTypeParameters(LookupOptions options);
    internal virtual void LookupSymbolsInSingleBinder(LookupResult result, string name, int arity, ConsList`1<Symbol> basesBeingResolved, LookupOptions options, Binder originalBinder, bool diagnose, HashSet`1& useSiteDiagnostics);
}
internal enum Microsoft.CodeAnalysis.CSharp.XmlParseErrorCode : Enum {
    public int value__;
    public static XmlParseErrorCode XML_RefUndefinedEntity_1;
    public static XmlParseErrorCode XML_InvalidCharEntity;
    public static XmlParseErrorCode XML_InvalidUnicodeChar;
    public static XmlParseErrorCode XML_InvalidWhitespace;
    public static XmlParseErrorCode XML_MissingEqualsAttribute;
    public static XmlParseErrorCode XML_StringLiteralNoStartQuote;
    public static XmlParseErrorCode XML_StringLiteralNoEndQuote;
    public static XmlParseErrorCode XML_StringLiteralNonAsciiQuote;
    public static XmlParseErrorCode XML_LessThanInAttributeValue;
    public static XmlParseErrorCode XML_IncorrectComment;
    public static XmlParseErrorCode XML_ElementTypeMatch;
    public static XmlParseErrorCode XML_DuplicateAttribute;
    public static XmlParseErrorCode XML_WhitespaceMissing;
    public static XmlParseErrorCode XML_EndTagNotExpected;
    public static XmlParseErrorCode XML_CDataEndTagNotAllowed;
    public static XmlParseErrorCode XML_EndTagExpected;
    public static XmlParseErrorCode XML_ExpectedIdentifier;
    public static XmlParseErrorCode XML_ExpectedEndOfTag;
    public static XmlParseErrorCode XML_InvalidToken;
    public static XmlParseErrorCode XML_ExpectedEndOfXml;
}
internal class Microsoft.CodeAnalysis.CSharp.XmlSyntaxDiagnosticInfo : SyntaxDiagnosticInfo {
    private XmlParseErrorCode _xmlErrorCode;
    internal XmlSyntaxDiagnosticInfo(XmlParseErrorCode code, Object[] args);
    internal XmlSyntaxDiagnosticInfo(int offset, int width, XmlParseErrorCode code, Object[] args);
    private XmlSyntaxDiagnosticInfo(ObjectReader reader);
    protected virtual void WriteTo(ObjectWriter writer);
    protected virtual Func`2<ObjectReader, object> GetReader();
    public virtual string GetMessage(IFormatProvider formatProvider);
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.CSharpExtensions : object {
    [ExtensionAttribute]
public static bool IsKind(SyntaxToken token, SyntaxKind kind);
    [ExtensionAttribute]
public static bool IsKind(SyntaxTrivia trivia, SyntaxKind kind);
    [ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind);
    [ExtensionAttribute]
public static bool IsKind(SyntaxNodeOrToken nodeOrToken, SyntaxKind kind);
    [ExtensionAttribute]
internal static SyntaxKind ContextualKind(SyntaxToken token);
    [ExtensionAttribute]
public static int IndexOf(SyntaxList`1<TNode> list, SyntaxKind kind);
    [ExtensionAttribute]
public static bool Any(SyntaxList`1<TNode> list, SyntaxKind kind);
    [ExtensionAttribute]
public static int IndexOf(SeparatedSyntaxList`1<TNode> list, SyntaxKind kind);
    [ExtensionAttribute]
public static bool Any(SeparatedSyntaxList`1<TNode> list, SyntaxKind kind);
    [ExtensionAttribute]
public static int IndexOf(SyntaxTriviaList list, SyntaxKind kind);
    [ExtensionAttribute]
public static bool Any(SyntaxTriviaList list, SyntaxKind kind);
    [ExtensionAttribute]
public static int IndexOf(SyntaxTokenList list, SyntaxKind kind);
    [ExtensionAttribute]
public static bool Any(SyntaxTokenList list, SyntaxKind kind);
    [ExtensionAttribute]
internal static SyntaxToken FirstOrDefault(SyntaxTokenList list, SyntaxKind kind);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.Diagnostics.CSharp.CSharpCompilerDiagnosticAnalyzer : CompilerDiagnosticAnalyzer {
    internal CommonMessageProvider MessageProvider { get; }
    internal virtual CommonMessageProvider get_MessageProvider();
    internal virtual ImmutableArray`1<int> GetSupportedErrorCodes();
}
