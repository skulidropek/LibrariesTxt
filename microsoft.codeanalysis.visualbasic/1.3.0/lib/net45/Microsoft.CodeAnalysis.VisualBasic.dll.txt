[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.Diagnostics.VisualBasic.VisualBasicCompilerDiagnosticAnalyzer : CompilerDiagnosticAnalyzer {
    internal CommonMessageProvider MessageProvider { get; }
    internal virtual CommonMessageProvider get_MessageProvider();
    internal virtual ImmutableArray`1<int> GetSupportedErrorCodes();
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.MissingRuntimeMemberDiagnosticHelper : object {
    internal static string MyVBNamespace;
    private static Dictionary`2<string, string> s_metadataNames;
    private static MissingRuntimeMemberDiagnosticHelper();
    internal static DiagnosticInfo GetDiagnosticForMissingRuntimeHelper(string typename, string membername, bool embedVBCoreRuntime);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.AbstractFlowPass`1 : BoundTreeVisitor {
    protected BoundNode _firstInRegion;
    protected BoundNode _lastInRegion;
    protected TextSpan _region;
    protected RegionPlace<LocalState> _regionPlace;
    private Dictionary`2<BoundLoopStatement, LocalState> _loopHeadState;
    private bool _invalidRegion;
    protected VisualBasicCompilation compilation;
    public Symbol symbol;
    private BoundNode _methodOrInitializerMainNode;
    private Dictionary`2<LabelSymbol, LabelStateAndNesting<LocalState>> _labels;
    private HashSet`1<LabelSymbol> _labelsSeen;
    private Dictionary`2<BoundValuePlaceholderBase, BoundExpression> _placeholderReplacementMap;
    internal bool backwardBranchChanged;
    private ArrayBuilder`1<PendingBranch<LocalState>> _pendingBranches;
    protected LocalState State;
    protected LocalState StateWhenTrue;
    protected LocalState StateWhenFalse;
    protected bool IsConditionalState;
    protected ParameterSymbol MeParameter;
    protected bool TrackUnassignments;
    private ArrayBuilder`1<int> _nesting;
    protected DiagnosticBag diagnostics;
    private bool _suppressConstantExpressions;
    protected int _recursionDepth;
    protected bool IsInside { get; }
    protected bool InvalidRegionDetected { get; }
    protected ImmutableArray`1<PendingBranch<LocalState>> PendingBranches { get; }
    protected ImmutableArray`1<ParameterSymbol> MethodParameters { get; }
    protected bool ShouldAnalyzeByRefParameters { get; }
    protected MethodSymbol MethodSymbol { get; }
    protected TypeSymbol MethodReturnType { get; }
    protected BoundExpression GetPlaceholderSubstitute { get; }
    protected bool SuppressRedimOperandRvalueOnPreserve { get; }
    protected AbstractFlowPass`1(FlowAnalysisInfo _info, bool suppressConstExpressionsSupport);
    protected AbstractFlowPass`1(FlowAnalysisInfo _info, FlowAnalysisRegionInfo _region, bool suppressConstExpressionsSupport, bool trackUnassignments);
    protected abstract virtual bool IntersectWith(LocalState& self, LocalState& other);
    protected abstract virtual void UnionWith(LocalState& self, LocalState& other);
    protected bool get_IsInside();
    protected bool IsInsideRegion(TextSpan span);
    protected virtual void EnterRegion();
    protected virtual void LeaveRegion();
    protected bool get_InvalidRegionDetected();
    protected void SetInvalidRegion();
    protected virtual void InitForScan();
    protected abstract virtual LocalState ReachableState();
    protected abstract virtual LocalState UnreachableState();
    private void SetConditionalState(LocalState _whenTrue, LocalState _whenFalse);
    protected void SetState(LocalState _state);
    protected void Split();
    protected void Unsplit();
    protected ImmutableArray`1<PendingBranch<LocalState>> get_PendingBranches();
    protected virtual bool Scan();
    protected virtual bool Analyze();
    protected virtual void Free();
    protected ImmutableArray`1<ParameterSymbol> get_MethodParameters();
    protected bool get_ShouldAnalyzeByRefParameters();
    protected MethodSymbol get_MethodSymbol();
    protected TypeSymbol get_MethodReturnType();
    private LocalState LabelState(LabelSymbol label);
    protected void SetUnreachable();
    private bool IsConstantTrue(BoundExpression node);
    private bool IsConstantFalse(BoundExpression node);
    private bool IsConstantNull(BoundExpression node);
    protected static bool IsNonPrimitiveValueType(TypeSymbol type);
    private void LoopHead(BoundLoopStatement node);
    private void LoopTail(BoundLoopStatement node);
    private void ResolveBreaks(LocalState breakState, LabelSymbol breakLabel);
    private void ResolveContinues(LabelSymbol continueLabel);
    protected virtual void NoteBranch(PendingBranch<LocalState> pending, BoundStatement stmt, BoundLabelStatement labelStmt);
    private LabelSymbol GetBranchTargetLabel(BoundStatement branch, bool gotoOnly);
    protected virtual void ResolveBranch(PendingBranch<LocalState> pending, LabelSymbol label, BoundLabelStatement target, Boolean& labelStateChanged);
    private bool ResolveBranches(BoundLabelStatement target);
    protected SavedPending<LocalState> SavePending();
    private void ResetPendingBranches(ArrayBuilder`1<PendingBranch<LocalState>> newPendingBranches);
    protected void RestorePending(SavedPending<LocalState> oldPending, bool mergeLabelsSeen);
    private bool ResolveBranches(HashSet`1<LabelSymbol> labelsFilter);
    private bool BothBranchAndLabelArePrefixedByNesting(PendingBranch<LocalState> branch, HashSet`1<LabelSymbol> labelsFilter, bool ignoreLast, LabelSymbol& labelSymbol, LabelStateAndNesting& labelAndNesting);
    protected virtual BoundNode Unimplemented(BoundNode node, string feature);
    protected virtual LocalState AllBitsSet();
    protected void SetPlaceholderSubstitute(BoundValuePlaceholderBase placeholder, BoundExpression newSubstitute);
    protected void RemovePlaceholderSubstitute(BoundValuePlaceholderBase placeholder);
    protected BoundExpression get_GetPlaceholderSubstitute(BoundValuePlaceholderBase placeholder);
    protected abstract virtual string Dump(LocalState state);
    public sealed virtual BoundNode Visit(BoundNode node);
    protected virtual void Visit(BoundNode node, bool dontLeaveRegion);
    protected void VisitAlways(BoundNode node, bool dontLeaveRegion);
    private BoundNode VisitWithStackGuard(BoundNode node);
    protected virtual BoundExpression VisitExpressionWithoutStackGuard(BoundExpression node);
    protected virtual bool ConvertInsufficientExecutionStackExceptionToCancelledByStackGuardException();
    protected virtual void VisitLvalue(BoundExpression node, bool dontLeaveRegion);
    protected void VisitCondition(BoundExpression node);
    private void AdjustConditionalState(BoundExpression node);
    protected void VisitRvalue(BoundExpression node, ReadWriteContext<LocalState> rwContext, bool dontLeaveRegion);
    public virtual BoundNode VisitSequence(BoundSequence node);
    public virtual BoundNode VisitByRefArgumentPlaceholder(BoundByRefArgumentPlaceholder node);
    public virtual BoundNode VisitByRefArgumentWithCopyBack(BoundByRefArgumentWithCopyBack node);
    protected virtual void VisitStatement(BoundStatement statement);
    public virtual BoundNode VisitLValueToRValueWrapper(BoundLValueToRValueWrapper node);
    public virtual BoundNode VisitWithLValueExpressionPlaceholder(BoundWithLValueExpressionPlaceholder node);
    public virtual BoundNode VisitWithStatement(BoundWithStatement node);
    public virtual BoundNode VisitAnonymousTypeCreationExpression(BoundAnonymousTypeCreationExpression node);
    public virtual BoundNode VisitAnonymousTypeFieldInitializer(BoundAnonymousTypeFieldInitializer node);
    public virtual BoundNode DefaultVisit(BoundNode node);
    protected virtual void VisitLocalInReadWriteContext(BoundLocal node, ReadWriteContext<LocalState> rwContext);
    protected virtual void VisitFieldAccessInReadWriteContext(BoundFieldAccess node, ReadWriteContext<LocalState> rwContext);
    public virtual BoundNode VisitLambda(BoundLambda node);
    public virtual BoundNode VisitQueryExpression(BoundQueryExpression node);
    public virtual BoundNode VisitLocal(BoundLocal node);
    public virtual BoundNode VisitRangeVariable(BoundRangeVariable node);
    public virtual BoundNode VisitLocalDeclaration(BoundLocalDeclaration node);
    private int IntroduceBlock();
    private void FinalizeBlock(int level);
    private void InitializeBlockStatement(int level, Int32& index);
    public virtual BoundNode VisitBlock(BoundBlock node);
    public virtual BoundNode VisitExpressionStatement(BoundExpressionStatement node);
    private void VisitExpressionAsStatement(BoundExpression node);
    public virtual BoundNode VisitLateMemberAccess(BoundLateMemberAccess node);
    public virtual BoundNode VisitLateInvocation(BoundLateInvocation node);
    private void VisitLateBoundArguments(ImmutableArray`1<BoundExpression> arguments, bool isByRef);
    protected virtual void VisitLateBoundArgument(BoundExpression arg, bool isByRef);
    public virtual BoundNode VisitCall(BoundCall node);
    private void VisitCallReceiver(BoundExpression receiver, MethodSymbol method);
    private void WriteLValueCallReceiver(BoundExpression receiver, MethodSymbol method);
    private void VisitArguments(ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<ParameterSymbol> parameters);
    protected virtual void WriteArgument(BoundExpression arg, bool isOut);
    protected virtual void VisitArgument(BoundExpression arg, ParameterSymbol p);
    public virtual BoundNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node);
    public virtual BoundNode VisitBadExpression(BoundBadExpression node);
    public virtual BoundNode VisitBadStatement(BoundBadStatement node);
    public virtual BoundNode VisitBadVariable(BoundBadVariable node);
    public virtual BoundNode VisitTypeExpression(BoundTypeExpression node);
    public virtual BoundNode VisitLiteral(BoundLiteral node);
    public virtual BoundNode VisitConversion(BoundConversion node);
    public virtual BoundNode VisitUserDefinedConversion(BoundUserDefinedConversion node);
    public virtual BoundNode VisitIfStatement(BoundIfStatement node);
    public virtual BoundNode VisitTernaryConditionalExpression(BoundTernaryConditionalExpression node);
    public virtual BoundNode VisitBinaryConditionalExpression(BoundBinaryConditionalExpression node);
    public virtual BoundNode VisitConditionalAccess(BoundConditionalAccess node);
    public virtual BoundNode VisitLoweredConditionalAccess(BoundLoweredConditionalAccess node);
    public virtual BoundNode VisitComplexConditionalAccessReceiver(BoundComplexConditionalAccessReceiver node);
    public virtual BoundNode VisitConditionalAccessReceiverPlaceholder(BoundConditionalAccessReceiverPlaceholder node);
    public virtual BoundNode VisitReturnStatement(BoundReturnStatement node);
    public virtual BoundNode VisitYieldStatement(BoundYieldStatement node);
    public virtual BoundNode VisitStopStatement(BoundStopStatement node);
    public virtual BoundNode VisitEndStatement(BoundEndStatement node);
    public virtual BoundNode VisitMeReference(BoundMeReference node);
    public virtual BoundNode VisitParameter(BoundParameter node);
    public virtual BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node);
    public virtual BoundNode VisitNoPiaObjectCreationExpression(BoundNoPiaObjectCreationExpression node);
    protected virtual void VisitObjectCreationExpressionInitializer(BoundObjectInitializerExpressionBase node);
    private BoundNode VisitObjectInitializerExpressionBase(BoundObjectInitializerExpressionBase node);
    public virtual BoundNode VisitCollectionInitializerExpression(BoundCollectionInitializerExpression node);
    public virtual BoundNode VisitObjectInitializerExpression(BoundObjectInitializerExpression node);
    public virtual BoundNode VisitNewT(BoundNewT node);
    public virtual BoundNode VisitRedimStatement(BoundRedimStatement node);
    public virtual BoundNode VisitEraseStatement(BoundEraseStatement node);
    protected virtual bool get_SuppressRedimOperandRvalueOnPreserve();
    public virtual BoundNode VisitRedimClause(BoundRedimClause node);
    public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node);
    public virtual BoundNode VisitMidResult(BoundMidResult node);
    public virtual BoundNode VisitReferenceAssignment(BoundReferenceAssignment node);
    public virtual BoundNode VisitCompoundAssignmentTargetPlaceholder(BoundCompoundAssignmentTargetPlaceholder node);
    public virtual BoundNode VisitFieldAccess(BoundFieldAccess node);
    private BoundNode VisitFieldAccessInternal(BoundFieldAccess node);
    protected bool FieldAccessMayRequireTracking(BoundFieldAccess fieldAccess);
    public virtual BoundNode VisitPropertyAccess(BoundPropertyAccess node);
    private void VisitUnreachableReceiver(BoundExpression receiver);
    public virtual BoundNode VisitAsNewLocalDeclarations(BoundAsNewLocalDeclarations node);
    public virtual BoundNode VisitDimStatement(BoundDimStatement node);
    public virtual BoundNode VisitWhileStatement(BoundWhileStatement node);
    public virtual BoundNode VisitSelectStatement(BoundSelectStatement node);
    private void VisitCaseBlocks(ImmutableArray`1<BoundCaseBlock> caseBlocks);
    public virtual BoundNode VisitCaseBlock(BoundCaseBlock node);
    public virtual BoundNode VisitCaseStatement(BoundCaseStatement node);
    public virtual BoundNode VisitRelationalCaseClause(BoundRelationalCaseClause node);
    public virtual BoundNode VisitSimpleCaseClause(BoundSimpleCaseClause node);
    public virtual BoundNode VisitRangeCaseClause(BoundRangeCaseClause node);
    protected virtual void VisitForControlInitialization(BoundForToStatement node);
    protected virtual void VisitForControlInitialization(BoundForEachStatement node);
    protected virtual void VisitForInitValues(BoundForToStatement node);
    protected virtual void VisitForStatementVariableDeclaration(BoundForStatement node);
    public virtual BoundNode VisitForEachStatement(BoundForEachStatement node);
    public virtual BoundNode VisitUsingStatement(BoundUsingStatement node);
    public virtual BoundNode VisitForToStatement(BoundForToStatement node);
    public virtual BoundNode VisitTryStatement(BoundTryStatement node);
    protected virtual void VisitTryBlock(BoundStatement tryBlock, BoundTryStatement node, LocalState& tryState);
    protected virtual void VisitCatchBlock(BoundCatchBlock catchBlock, LocalState& finallyState);
    protected virtual void VisitFinallyBlock(BoundStatement finallyBlock, LocalState& unsetInFinally);
    public virtual BoundNode VisitArrayAccess(BoundArrayAccess node);
    public sealed virtual BoundNode VisitBinaryOperator(BoundBinaryOperator node);
    public virtual BoundNode VisitUserDefinedBinaryOperator(BoundUserDefinedBinaryOperator node);
    public virtual BoundNode VisitUserDefinedShortCircuitingOperator(BoundUserDefinedShortCircuitingOperator node);
    public virtual BoundNode VisitAddHandlerStatement(BoundAddHandlerStatement node);
    public virtual BoundNode VisitRemoveHandlerStatement(BoundRemoveHandlerStatement node);
    public virtual BoundNode VisitAddressOfOperator(BoundAddressOfOperator node);
    public virtual BoundNode VisitLateAddressOfOperator(BoundLateAddressOfOperator node);
    private BoundNode VisitAddRemoveHandlerStatement(BoundAddRemoveHandlerStatement node);
    public virtual BoundNode VisitEventAccess(BoundEventAccess node);
    public virtual BoundNode VisitRaiseEventStatement(BoundRaiseEventStatement node);
    public virtual BoundNode VisitParenthesized(BoundParenthesized node);
    public virtual BoundNode VisitUnaryOperator(BoundUnaryOperator node);
    public virtual BoundNode VisitUserDefinedUnaryOperator(BoundUserDefinedUnaryOperator node);
    public virtual BoundNode VisitNullableIsTrueOperator(BoundNullableIsTrueOperator node);
    public virtual BoundNode VisitArrayCreation(BoundArrayCreation node);
    public virtual BoundNode VisitArrayInitialization(BoundArrayInitialization node);
    public virtual BoundNode VisitArrayLiteral(BoundArrayLiteral node);
    public virtual BoundNode VisitDirectCast(BoundDirectCast node);
    public virtual BoundNode VisitTryCast(BoundTryCast node);
    public virtual BoundNode VisitTypeOf(BoundTypeOf node);
    public virtual BoundNode VisitMethodGroup(BoundMethodGroup node);
    public virtual BoundNode VisitPropertyGroup(BoundPropertyGroup node);
    public virtual BoundNode VisitGetType(BoundGetType node);
    public virtual BoundNode VisitSequencePoint(BoundSequencePoint node);
    public virtual BoundNode VisitSequencePointWithSpan(BoundSequencePointWithSpan node);
    public virtual BoundNode VisitStatementList(BoundStatementList node);
    public virtual BoundNode VisitSyncLockStatement(BoundSyncLockStatement node);
    public virtual BoundNode VisitUnboundLambda(UnboundLambda node);
    public virtual BoundNode VisitExitStatement(BoundExitStatement node);
    public virtual BoundNode VisitContinueStatement(BoundContinueStatement node);
    public virtual BoundNode VisitMyBaseReference(BoundMyBaseReference node);
    public virtual BoundNode VisitDoLoopStatement(BoundDoLoopStatement node);
    public void VisitDoLoopTopConditionStatement(BoundDoLoopStatement node);
    public void VisitDoLoopBottomConditionStatement(BoundDoLoopStatement node);
    private void VisitUnconditionalDoLoopStatement(BoundDoLoopStatement node);
    public virtual BoundNode VisitGotoStatement(BoundGotoStatement node);
    public virtual BoundNode VisitLabelStatement(BoundLabelStatement node);
    public virtual BoundNode VisitThrowStatement(BoundThrowStatement node);
    public virtual BoundNode VisitNoOpStatement(BoundNoOpStatement node);
    public virtual BoundNode VisitNamespaceExpression(BoundNamespaceExpression node);
    public virtual BoundNode VisitFieldInitializer(BoundFieldInitializer node);
    public virtual BoundNode VisitPropertyInitializer(BoundPropertyInitializer node);
    public virtual BoundNode VisitArrayLength(BoundArrayLength node);
    public virtual BoundNode VisitConditionalGoto(BoundConditionalGoto node);
    public virtual BoundNode VisitXmlDocument(BoundXmlDocument node);
    public virtual BoundNode VisitXmlElement(BoundXmlElement node);
    public virtual BoundNode VisitXmlAttribute(BoundXmlAttribute node);
    public virtual BoundNode VisitXmlName(BoundXmlName node);
    public virtual BoundNode VisitXmlNamespace(BoundXmlNamespace node);
    public virtual BoundNode VisitXmlEmbeddedExpression(BoundXmlEmbeddedExpression node);
    public virtual BoundNode VisitXmlMemberAccess(BoundXmlMemberAccess node);
    public virtual BoundNode VisitUnstructuredExceptionHandlingStatement(BoundUnstructuredExceptionHandlingStatement node);
    public virtual BoundNode VisitAwaitOperator(BoundAwaitOperator node);
    public virtual BoundNode VisitNameOfOperator(BoundNameOfOperator node);
    public virtual BoundNode VisitTypeAsValueExpression(BoundTypeAsValueExpression node);
    public virtual BoundNode VisitInterpolatedStringExpression(BoundInterpolatedStringExpression node);
    public virtual BoundNode VisitInterpolation(BoundInterpolation node);
    public virtual BoundNode VisitParameterEqualsValue(BoundParameterEqualsValue node);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.AbstractRegionControlFlowPass : ControlFlowPass {
    internal AbstractRegionControlFlowPass(FlowAnalysisInfo info, FlowAnalysisRegionInfo region);
    protected virtual void Visit(BoundNode node, bool dontLeaveRegion);
    public virtual BoundNode VisitLambda(BoundLambda node);
    public virtual BoundNode VisitQueryLambda(BoundQueryLambda node);
    public virtual BoundNode VisitQueryExpression(BoundQueryExpression node);
    public virtual BoundNode VisitQuerySource(BoundQuerySource node);
    public virtual BoundNode VisitQueryableSource(BoundQueryableSource node);
    public virtual BoundNode VisitToQueryableCollectionConversion(BoundToQueryableCollectionConversion node);
    public virtual BoundNode VisitQueryClause(BoundQueryClause node);
    public virtual BoundNode VisitAggregateClause(BoundAggregateClause node);
    public virtual BoundNode VisitOrdering(BoundOrdering node);
    public virtual BoundNode VisitRangeVariableAssignment(BoundRangeVariableAssignment node);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.AbstractRegionDataFlowPass : DataFlowPass {
    protected bool SuppressRedimOperandRvalueOnPreserve { get; }
    protected bool IgnoreOutSemantics { get; }
    protected bool EnableBreakingFlowAnalysisFeatures { get; }
    internal AbstractRegionDataFlowPass(FlowAnalysisInfo info, FlowAnalysisRegionInfo region, HashSet`1<Symbol> initiallyAssignedVariables, bool trackUnassignments, bool trackStructsWithIntrinsicTypedFields);
    public virtual BoundNode VisitLambda(BoundLambda node);
    private void MakeSlots(ImmutableArray`1<ParameterSymbol> parameters);
    protected virtual bool get_SuppressRedimOperandRvalueOnPreserve();
    public virtual BoundNode VisitParameter(BoundParameter node);
    protected virtual LocalSymbol CreateLocalSymbolForVariables(ImmutableArray`1<BoundLocalDeclaration> declarations);
    protected virtual bool get_IgnoreOutSemantics();
    protected virtual bool get_EnableBreakingFlowAnalysisFeatures();
}
internal class Microsoft.CodeAnalysis.VisualBasic.AccessCheck : object {
    private static Accessibility[] s_mapAccessToAccessOutsideAssembly;
    private static AccessCheck();
    public static bool IsSymbolAccessible(Symbol symbol, AssemblySymbol within, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    public static AccessCheckResult CheckSymbolAccessibility(Symbol symbol, AssemblySymbol within, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    public static bool IsSymbolAccessible(Symbol symbol, NamedTypeSymbol within, TypeSymbol throughTypeOpt, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    public static AccessCheckResult CheckSymbolAccessibility(Symbol symbol, NamedTypeSymbol within, TypeSymbol throughTypeOpt, HashSet`1& useSiteDiagnostics, ConsList`1<Symbol> basesBeingResolved);
    private static AccessCheckResult CheckSymbolAccessibilityCore(Symbol symbol, Symbol within, TypeSymbol throughTypeOpt, ConsList`1<Symbol> basesBeingResolved, HashSet`1& useSiteDiagnostics);
    private static AccessCheckResult CheckNamedTypeAccessibility(NamedTypeSymbol typeSym, Symbol within, ConsList`1<Symbol> basesBeingResolved, HashSet`1& useSiteDiagnostics);
    private static AccessCheckResult CheckNonNestedTypeAccessibility(AssemblySymbol assembly, Accessibility declaredAccessibility, Symbol within);
    private static AccessCheckResult CheckMemberAccessibility(NamedTypeSymbol containingType, Accessibility declaredAccessibility, Symbol within, TypeSymbol throughTypeOpt, ConsList`1<Symbol> basesBeingResolved, HashSet`1& useSiteDiagnostics);
    private static AccessCheckResult CheckProtectedSymbolAccessibility(Symbol within, TypeSymbol throughTypeOpt, NamedTypeSymbol originalContainingType, ConsList`1<Symbol> basesBeingResolved, HashSet`1& useSiteDiagnostics);
    private static AccessCheckResult CheckPrivateSymbolAccessibility(Symbol within, NamedTypeSymbol originalContainingType);
    private static bool IsNestedWithinOriginalContainingType(NamedTypeSymbol withinType, NamedTypeSymbol originalContainingType);
    private static bool InheritsFromIgnoringConstruction(TypeSymbol derivedType, TypeSymbol baseType, ConsList`1<Symbol> basesBeingResolved, HashSet`1& useSiteDiagnostics);
    public static bool HasFriendAccessTo(AssemblySymbol fromAssembly, AssemblySymbol toAssembly);
    private static bool InternalsAccessibleTo(AssemblySymbol toAssembly, AssemblySymbol assemblyWantingAccess);
    private static bool IsSameAssembly(AssemblySymbol fromAssembly, AssemblySymbol toAssembly);
    public static string GetAccessibilityForErrorMessage(Symbol sym, AssemblySymbol fromAssembly);
    private static bool VerifyAccessExposure(Symbol exposedThrough, TypeSymbol exposedType, ArrayBuilder`1& illegalExposure, HashSet`1& useSiteDiagnostics);
    private static bool VerifyAccessExposure(Symbol exposedThrough, NamedTypeSymbol exposedType, NamespaceOrTypeSymbol& containerWithAccessError, HashSet`1& useSiteDiagnostics);
    private static bool MemberIsOrNestedInType(Symbol member, NamedTypeSymbol type);
    private static bool VerifyAccessExposureWithinAssembly(Symbol exposedThrough, NamedTypeSymbol exposedType, NamespaceOrTypeSymbol& containerWithAccessError, HashSet`1& useSiteDiagnostics);
    private static bool VerifyAccessExposureOutsideAssembly(Symbol exposedThrough, NamedTypeSymbol exposedType, HashSet`1& useSiteDiagnostics);
    private static Accessibility GetEffectiveAccessOutsideAssembly(Symbol symbol);
    private static Accessibility GetAccessInAssemblyContext(Symbol symbol, bool isOutsideAssembly);
    private static bool IsTypeNestedIn(NamedTypeSymbol probablyNestedType, NamedTypeSymbol probablyEnclosingType);
    private static bool VerifyAccessExposureHelper(Symbol exposingMember, NamedTypeSymbol exposedType, NamespaceOrTypeSymbol& containerWithAccessError, Boolean& seenThroughInheritance, bool isOutsideAssembly, HashSet`1& useSiteDiagnostics);
    private static bool CanBeAccessedThroughInheritance(NamedTypeSymbol type, NamedTypeSymbol container, bool isOutsideAssembly, HashSet`1& useSiteDiagnostics);
    private static NamedTypeSymbol FindEnclosingTypeWithGivenAccess(Symbol member, Accessibility stopAtAccess, bool isOutsideAssembly);
    public static bool VerifyAccessExposureOfBaseClassOrInterface(NamedTypeSymbol classOrInterface, TypeSyntax baseClassSyntax, TypeSymbol base, DiagnosticBag diagBag);
    public static void VerifyAccessExposureForParameterType(Symbol member, string paramName, VisualBasicSyntaxNode errorLocation, TypeSymbol TypeBehindParam, DiagnosticBag diagBag);
    public static void VerifyAccessExposureForMemberType(Symbol member, SyntaxNodeOrToken errorLocation, TypeSymbol typeBehindMember, DiagnosticBag diagBag, bool isDelegateFromImplements);
}
internal enum Microsoft.CodeAnalysis.VisualBasic.AccessCheckResult : Enum {
    public int value__;
    public static AccessCheckResult Accessible;
    public static AccessCheckResult Inaccessible;
    public static AccessCheckResult InaccessibleViaThroughType;
}
public class Microsoft.CodeAnalysis.VisualBasic.AggregateClauseSymbolInfo : ValueType {
    [CompilerGeneratedAttribute]
private SymbolInfo _Select1;
    [CompilerGeneratedAttribute]
private SymbolInfo _Select2;
    public SymbolInfo Select1 { get; }
    public SymbolInfo Select2 { get; }
    internal AggregateClauseSymbolInfo(SymbolInfo select1);
    internal AggregateClauseSymbolInfo(SymbolInfo select1, SymbolInfo select2);
    [CompilerGeneratedAttribute]
public SymbolInfo get_Select1();
    [CompilerGeneratedAttribute]
public SymbolInfo get_Select2();
}
internal class Microsoft.CodeAnalysis.VisualBasic.AliasAndImportsClausePosition : ValueType {
    public AliasSymbol Alias;
    public int ImportsClausePosition;
    public AliasAndImportsClausePosition(AliasSymbol alias, int importsClausePosition);
}
internal class Microsoft.CodeAnalysis.VisualBasic.AlwaysAssignedWalker : AbstractRegionDataFlowPass {
    private LocalState _endOfRegionState;
    private HashSet`1<LabelSymbol> _labelsInside;
    private IEnumerable`1<Symbol> AlwaysAssigned { get; }
    private AlwaysAssignedWalker(FlowAnalysisInfo info, FlowAnalysisRegionInfo region);
    internal static IEnumerable`1<Symbol> Analyze(FlowAnalysisInfo info, FlowAnalysisRegionInfo region);
    private IEnumerable`1<Symbol> get_AlwaysAssigned();
    protected virtual void EnterRegion();
    protected virtual void LeaveRegion();
    public virtual BoundNode VisitLabelStatement(BoundLabelStatement node);
    protected virtual void ResolveBranch(PendingBranch<LocalState> pending, LabelSymbol label, BoundLabelStatement target, Boolean& labelStateChanged);
    protected virtual void WriteArgument(BoundExpression arg, bool isOut);
}
internal class Microsoft.CodeAnalysis.VisualBasic.AmbiguousSymbolDiagnostic : DiagnosticInfo {
    private ImmutableArray`1<Symbol> _symbols;
    public ImmutableArray`1<Symbol> AmbiguousSymbols { get; }
    public IReadOnlyList`1<Location> AdditionalLocations { get; }
    internal AmbiguousSymbolDiagnostic(ERRID errid, ImmutableArray`1<Symbol> symbols, Object[] args);
    public ImmutableArray`1<Symbol> get_AmbiguousSymbols();
    private sealed virtual override void GetAssociatedSymbols(ArrayBuilder`1<Symbol> builder);
    public virtual IReadOnlyList`1<Location> get_AdditionalLocations();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Analyzer : object {
    internal static void AnalyzeMethodBody(MethodSymbol method, BoundBlock body, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.VisualBasic.ArrayLiteralTypeSymbol : ArrayTypeSymbol {
    private BoundArrayLiteral _arrayLiteral;
    internal BoundArrayLiteral ArrayLiteral { get; }
    internal bool IsSZArray { get; }
    public int Rank { get; }
    internal bool HasDefaultSizesAndLowerBounds { get; }
    internal ImmutableArray`1<NamedTypeSymbol> InterfacesNoUseSiteDiagnostics { get; }
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public TypeSymbol ElementType { get; }
    internal ArrayLiteralTypeSymbol(BoundArrayLiteral arrayLiteral);
    internal BoundArrayLiteral get_ArrayLiteral();
    internal virtual bool get_IsSZArray();
    public virtual int get_Rank();
    internal virtual bool get_HasDefaultSizesAndLowerBounds();
    internal virtual ImmutableArray`1<NamedTypeSymbol> get_InterfacesNoUseSiteDiagnostics();
    internal virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual TypeSymbol get_ElementType();
    internal virtual TypeWithModifiers InternalSubstituteTypeParameters(TypeSubstitution substitution);
}
internal class Microsoft.CodeAnalysis.VisualBasic.AsyncRewriter : StateMachineRewriter`1<CapturedSymbolOrExpression> {
    private Binder _binder;
    private LookupOptions _lookupOptions;
    private AsyncMethodKind _asyncMethodKind;
    private NamedTypeSymbol _builderType;
    private TypeSymbol _resultType;
    private FieldSymbol _builderField;
    private int _lastExpressionCaptureNumber;
    protected bool PreserveInitialParameterValues { get; }
    internal TypeSubstitution TypeMap { get; }
    public AsyncRewriter(BoundStatement body, MethodSymbol method, AsyncStateMachine stateMachineType, VariableSlotAllocator slotAllocatorOpt, AsyncMethodKind asyncKind, TypeCompilationState compilationState, DiagnosticBag diagnostics);
    internal static BoundBlock Rewrite(BoundBlock body, MethodSymbol method, int methodOrdinal, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics, AsyncStateMachine& stateMachineType);
    private static Binder CreateMethodBinder(MethodSymbol method);
    protected virtual void GenerateControlFields();
    protected virtual void InitializeStateMachine(ArrayBuilder`1<BoundStatement> bodyBuilder, NamedTypeSymbol frameType, LocalSymbol stateMachineLocal);
    protected virtual bool get_PreserveInitialParameterValues();
    internal virtual TypeSubstitution get_TypeMap();
    protected virtual void GenerateMethodImplementations();
    protected virtual BoundStatement GenerateStateMachineCreation(LocalSymbol stateMachineVariable, NamedTypeSymbol frameType);
    private void GenerateMoveNext(MethodSymbol moveNextMethod);
    internal virtual BoundStatement RewriteBodyIfNeeded(BoundStatement body, MethodSymbol topMethod, MethodSymbol currentMethod);
    internal virtual bool EnsureAllSymbolsAndSignature();
    internal static AsyncMethodKind GetAsyncMethodKind(MethodSymbol method);
    protected virtual CapturedSymbolOrExpression CreateByRefLocalCapture(TypeSubstitution typeMap, LocalSymbol local, Dictionary`2<LocalSymbol, BoundExpression> initializers);
    private CapturedSymbolOrExpression CaptureExpression(TypeSubstitution typeMap, BoundExpression expression, Dictionary`2<LocalSymbol, BoundExpression> initializers);
    protected virtual void InitializeParameterWithProxy(ParameterSymbol parameter, CapturedSymbolOrExpression proxy, LocalSymbol stateMachineVariable, ArrayBuilder`1<BoundExpression> initializers);
    protected virtual CapturedSymbolOrExpression CreateByValLocalCapture(FieldSymbol field, LocalSymbol local);
    protected virtual CapturedSymbolOrExpression CreateParameterCapture(FieldSymbol field, ParameterSymbol parameter);
    private BoundExpression GenerateMethodCall(BoundExpression receiver, TypeSymbol type, string methodName, BoundExpression[] arguments);
    private BoundExpression GenerateMethodCall(BoundExpression receiver, TypeSymbol type, string methodName, ImmutableArray`1<TypeSymbol> typeArgs, BoundExpression[] arguments);
    private BoundMethodGroup FindMethodAndReturnMethodGroup(BoundExpression receiver, TypeSymbol type, string methodName, ImmutableArray`1<TypeSymbol> typeArgs);
    private BoundExpression GeneratePropertyGet(BoundExpression receiver, TypeSymbol type, string propertyName);
    private BoundPropertyGroup FindPropertyAndReturnPropertyGroup(BoundExpression receiver, TypeSymbol type, string propertyName);
}
internal class Microsoft.CodeAnalysis.VisualBasic.AsyncStateMachine : StateMachineTypeSymbol {
    private TypeKind _typeKind;
    private SynthesizedSimpleConstructorSymbol _constructor;
    public TypeKind TypeKind { get; }
    protected internal MethodSymbol Constructor { get; }
    protected internal AsyncStateMachine(VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, MethodSymbol asyncMethod, int asyncMethodOrdinal, TypeKind typeKind);
    public virtual TypeKind get_TypeKind();
    protected internal virtual MethodSymbol get_Constructor();
}
internal class Microsoft.CodeAnalysis.VisualBasic.AttributeBinder : Binder {
    private VisualBasicSyntaxNode _root;
    internal VisualBasicSyntaxNode Root { get; }
    internal bool IsDefaultInstancePropertyAllowed { get; }
    public AttributeBinder(Binder containingBinder, SyntaxTree tree, VisualBasicSyntaxNode node);
    internal VisualBasicSyntaxNode get_Root();
    public virtual Binder GetBinder(VisualBasicSyntaxNode node);
    internal virtual bool get_IsDefaultInstancePropertyAllowed();
}
internal class Microsoft.CodeAnalysis.VisualBasic.AttributeSemanticModel : MemberSemanticModel {
    private AttributeSemanticModel(VisualBasicSyntaxNode root, Binder binder, SyntaxTreeSemanticModel parentSemanticModelOpt, int speculatedPosition, bool ignoreAccessibility);
    internal static AttributeSemanticModel Create(AttributeBinder binder, bool ignoreAccessibility);
    internal static AttributeSemanticModel CreateSpeculative(SyntaxTreeSemanticModel parentSemanticModel, VisualBasicSyntaxNode root, Binder binder, int position);
    internal virtual BoundNode Bind(Binder binder, VisualBasicSyntaxNode node, DiagnosticBag diagnostics);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, EqualsValueSyntax initializer, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, ExecutableStatementSyntax statement, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelForMethodBodyCore(SyntaxTreeSemanticModel parentModel, int position, MethodBlockBaseSyntax method, SemanticModel& speculativeModel);
}
public class Microsoft.CodeAnalysis.VisualBasic.AwaitExpressionInfo : ValueType {
    private IMethodSymbol _getAwaiter;
    private IPropertySymbol _isCompleted;
    private IMethodSymbol _getResult;
    public IMethodSymbol GetAwaiterMethod { get; }
    public IMethodSymbol GetResultMethod { get; }
    public IPropertySymbol IsCompletedProperty { get; }
    internal AwaitExpressionInfo(IMethodSymbol getAwaiter, IPropertySymbol isCompleted, IMethodSymbol getResult);
    public IMethodSymbol get_GetAwaiterMethod();
    public IMethodSymbol get_GetResultMethod();
    public IPropertySymbol get_IsCompletedProperty();
}
internal class Microsoft.CodeAnalysis.VisualBasic.BackstopBinder : Binder {
    private static Dictionary`2<string, string> s_defaultXmlNamespaces;
    public ConsList`1<LocalSymbol> ImplicitlyTypedLocalsBeingBound { get; }
    public Symbol ContainingMember { get; }
    public bool IsInQuery { get; }
    public NamespaceOrTypeSymbol ContainingNamespaceOrType { get; }
    public NamedTypeSymbol ContainingType { get; }
    internal SymbolsInProgress`1<FieldSymbol> ConstantFieldsInProgress { get; }
    internal SymbolsInProgress`1<ParameterSymbol> DefaultParametersInProgress { get; }
    public OptionStrict OptionStrict { get; }
    public bool OptionInfer { get; }
    public bool OptionExplicit { get; }
    public bool OptionCompareText { get; }
    public bool CheckOverflow { get; }
    public bool AllImplicitVariableDeclarationsAreHandled { get; }
    public bool ImplicitVariableDeclarationAllowed { get; }
    public ImmutableArray`1<LocalSymbol> ImplicitlyDeclaredVariables { get; }
    protected bool IsInsideChainedConstructorCallArguments { get; }
    public BindingLocation BindingLocation { get; }
    internal bool HasImportedXmlNamespaces { get; }
    public QuickAttributeChecker QuickAttributeChecker { get; }
    internal bool IsDefaultInstancePropertyAllowed { get; }
    internal bool SuppressCallerInfo { get; }
    internal bool SuppressObsoleteDiagnostics { get; }
    public bool IsSemanticModelBinder { get; }
    private static BackstopBinder();
    public virtual AccessCheckResult CheckAccessibility(Symbol sym, HashSet`1& useSiteDiagnostics, TypeSymbol accessThroughType, ConsList`1<Symbol> basesBeingResolved);
    public virtual Binder GetBinder(VisualBasicSyntaxNode node);
    public virtual Binder GetBinder(SyntaxList`1<StatementSyntax> stmtList);
    public virtual ConsList`1<LocalSymbol> get_ImplicitlyTypedLocalsBeingBound();
    public virtual bool IsUnboundTypeAllowed(GenericNameSyntax syntax);
    public virtual Symbol get_ContainingMember();
    public virtual bool get_IsInQuery();
    public virtual NamespaceOrTypeSymbol get_ContainingNamespaceOrType();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual ErrorTypeSymbol GetErrorSymbol(string name, DiagnosticInfo errorInfo, ImmutableArray`1<Symbol> candidateSymbols, LookupResultKind resultKind);
    public virtual SyntaxReference GetSyntaxReference(VisualBasicSyntaxNode node);
    protected virtual BoundStatement CreateBoundWithBlock(WithBlockSyntax node, Binder boundBlockBinder, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<Symbol> BindInsideCrefAttributeValue(TypeSyntax name, bool preserveAliases, DiagnosticBag diagnosticBag, HashSet`1& useSiteDiagnostics);
    internal virtual ImmutableArray`1<Symbol> BindInsideCrefAttributeValue(CrefReferenceSyntax reference, bool preserveAliases, DiagnosticBag diagnosticBag, HashSet`1& useSiteDiagnostics);
    internal virtual ImmutableArray`1<Symbol> BindXmlNameAttributeValue(IdentifierNameSyntax identifier, HashSet`1& useSiteDiagnostics);
    protected internal virtual BoundExpression TryBindOmittedLeftForMemberAccess(MemberAccessExpressionSyntax node, DiagnosticBag diagnostics, Binder accessingBinder, Boolean& wholeMemberAccessExpressionBound);
    protected virtual BoundExpression TryBindOmittedLeftForDictionaryAccess(MemberAccessExpressionSyntax node, Binder accessingBinder, DiagnosticBag diagnostics);
    protected virtual BoundExpression TryBindOmittedLeftForConditionalAccess(ConditionalAccessExpressionSyntax node, Binder accessingBinder, DiagnosticBag diagnostics);
    protected internal virtual BoundExpression TryBindOmittedLeftForXmlMemberAccess(XmlMemberAccessExpressionSyntax node, DiagnosticBag diagnostics, Binder accessingBinder);
    protected virtual BoundExpression TryGetConditionalAccessReceiver(ConditionalAccessExpressionSyntax node);
    internal virtual SymbolsInProgress`1<FieldSymbol> get_ConstantFieldsInProgress();
    internal virtual SymbolsInProgress`1<ParameterSymbol> get_DefaultParametersInProgress();
    public virtual OptionStrict get_OptionStrict();
    public virtual bool get_OptionInfer();
    public virtual bool get_OptionExplicit();
    public virtual bool get_OptionCompareText();
    public virtual bool get_CheckOverflow();
    public virtual bool get_AllImplicitVariableDeclarationsAreHandled();
    public virtual bool get_ImplicitVariableDeclarationAllowed();
    public virtual LocalSymbol DeclareImplicitLocalVariable(IdentifierNameSyntax nameSyntax, DiagnosticBag diagnostics);
    public virtual ImmutableArray`1<LocalSymbol> get_ImplicitlyDeclaredVariables();
    public virtual void DisallowFurtherImplicitVariableDeclaration(DiagnosticBag diagnostics);
    public virtual LabelSymbol GetContinueLabel(SyntaxKind continueSyntaxKind);
    public virtual LabelSymbol GetExitLabel(SyntaxKind exitSyntaxKind);
    public virtual LabelSymbol GetReturnLabel();
    public virtual LocalSymbol GetLocalForFunctionValue();
    protected virtual bool get_IsInsideChainedConstructorCallArguments();
    public virtual BindingLocation get_BindingLocation();
    internal virtual bool LookupXmlNamespace(string prefix, bool ignoreXmlNodes, String& namespace, Boolean& fromImports);
    internal virtual bool get_HasImportedXmlNamespaces();
    internal virtual void GetInScopeXmlNamespaces(ArrayBuilder`1<KeyValuePair`2<string, string>> builder);
    internal virtual LabelSymbol LookupLabelByNameToken(SyntaxToken labelName);
    internal virtual BoundExpression GetWithStatementPlaceholderSubstitute(BoundValuePlaceholderBase placeholder);
    public virtual QuickAttributeChecker get_QuickAttributeChecker();
    internal virtual bool get_IsDefaultInstancePropertyAllowed();
    internal virtual bool get_SuppressCallerInfo();
    internal virtual bool get_SuppressObsoleteDiagnostics();
    public virtual bool get_IsSemanticModelBinder();
    internal virtual LookupOptions BinderSpecificLookupOptions(LookupOptions options);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BadSymbolDiagnostic : DiagnosticInfo {
    private Symbol _badSymbol;
    public Symbol BadSymbol { get; }
    public IReadOnlyList`1<Location> AdditionalLocations { get; }
    internal BadSymbolDiagnostic(Symbol badSymbol, ERRID errid);
    internal BadSymbolDiagnostic(Symbol badSymbol, ERRID errid, Object[] additionalArgs);
    public Symbol get_BadSymbol();
    private sealed virtual override void GetAssociatedSymbols(ArrayBuilder`1<Symbol> builder);
    public virtual IReadOnlyList`1<Location> get_AdditionalLocations();
}
internal class Microsoft.CodeAnalysis.VisualBasic.BasesBeingResolvedBinder : Binder {
    public BasesBeingResolvedBinder(Binder containingBinder, ConsList`1<Symbol> basesBeingResolved);
    public virtual AccessCheckResult CheckAccessibility(Symbol sym, HashSet`1& useSiteDiagnostics, TypeSymbol accessThroughType, ConsList`1<Symbol> basesBeingResolved);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BeginOfBlockSyntaxReference : TranslationSyntaxReference {
    public BeginOfBlockSyntaxReference(SyntaxReference reference);
    protected virtual SyntaxNode Translate(SyntaxReference reference, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.VisualBasic.BinaryOperatorKind : Enum {
    public int value__;
    public static BinaryOperatorKind Add;
    public static BinaryOperatorKind Concatenate;
    public static BinaryOperatorKind Like;
    public static BinaryOperatorKind Equals;
    public static BinaryOperatorKind NotEquals;
    public static BinaryOperatorKind LessThanOrEqual;
    public static BinaryOperatorKind GreaterThanOrEqual;
    public static BinaryOperatorKind LessThan;
    public static BinaryOperatorKind GreaterThan;
    public static BinaryOperatorKind Subtract;
    public static BinaryOperatorKind Multiply;
    public static BinaryOperatorKind Power;
    public static BinaryOperatorKind Divide;
    public static BinaryOperatorKind Modulo;
    public static BinaryOperatorKind IntegerDivide;
    public static BinaryOperatorKind LeftShift;
    public static BinaryOperatorKind RightShift;
    public static BinaryOperatorKind Xor;
    public static BinaryOperatorKind Or;
    public static BinaryOperatorKind OrElse;
    public static BinaryOperatorKind And;
    public static BinaryOperatorKind AndAlso;
    public static BinaryOperatorKind Is;
    public static BinaryOperatorKind IsNot;
    public static BinaryOperatorKind OpMask;
    public static BinaryOperatorKind Lifted;
    public static BinaryOperatorKind CompareText;
    public static BinaryOperatorKind UserDefined;
    public static BinaryOperatorKind Error;
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Binder : object {
    private static ImmutableArray`1<TypeSymbol> s_noTypes;
    private static ImmutableArray`1<BoundExpression> s_noArguments;
    protected Binder m_containingBinder;
    private SyntaxTree _syntaxTree;
    private VisualBasicCompilation _compilation;
    private SourceModuleSymbol _sourceModule;
    private bool _isEarlyAttributeBinder;
    private bool _ignoreBaseClassesInLookup;
    private ConsList`1<Symbol> _basesBeingResolved;
    private static CheckParameterModifierDelegate s_checkDelegateParameterModifierCallback;
    public static int ArrayRankLimit;
    private static Func`2<Symbol, bool> s_isFunctionWithoutArguments;
    private static Func`2<Symbol, bool> s_isReadablePropertyWithoutArguments;
    private static SyntaxKind[] s_friendKeyword;
    private static CheckParameterModifierDelegate s_checkOperatorParameterModifierCallback;
    private static CheckParameterModifierDelegate s_checkPropertyParameterModifierCallback;
    private static SyntaxKind[] s_notInheritableKeyword;
    public Binder ContainingBinder { get; }
    internal bool IgnoresAccessibility { get; }
    public Symbol ContainingMember { get; }
    internal ModuleSymbol ContainingModule { get; }
    public bool IsInQuery { get; }
    internal bool IsInLambda { get; }
    public ConsList`1<LocalSymbol> ImplicitlyTypedLocalsBeingBound { get; }
    public NamedTypeSymbol ContainingType { get; }
    internal bool BindingTopLevelScriptCode { get; }
    public NamespaceOrTypeSymbol ContainingNamespaceOrType { get; }
    public SourceModuleSymbol SourceModule { get; }
    public VisualBasicCompilation Compilation { get; }
    public SyntaxTree SyntaxTree { get; }
    internal SymbolsInProgress`1<FieldSymbol> ConstantFieldsInProgress { get; }
    internal SymbolsInProgress`1<ParameterSymbol> DefaultParametersInProgress { get; }
    public bool IgnoreBaseClassesInLookup { get; }
    public OptionStrict OptionStrict { get; }
    public bool OptionInfer { get; }
    public bool OptionExplicit { get; }
    public bool OptionCompareText { get; }
    public bool CheckOverflow { get; }
    public bool AllImplicitVariableDeclarationsAreHandled { get; }
    public bool ImplicitVariableDeclarationAllowed { get; }
    public ImmutableArray`1<LocalSymbol> ImplicitlyDeclaredVariables { get; }
    internal bool SuppressObsoleteDiagnostics { get; }
    public BindingLocation BindingLocation { get; }
    public bool IsEarlyAttributeBinder { get; }
    internal bool ShouldCheckConstraints { get; }
    internal bool HasImportedXmlNamespaces { get; }
    public bool IsSemanticModelBinder { get; }
    public QuickAttributeChecker QuickAttributeChecker { get; }
    internal bool IsDefaultInstancePropertyAllowed { get; }
    internal bool SuppressCallerInfo { get; }
    protected bool IsInsideChainedConstructorCallArguments { get; }
    private static Binder();
    protected Binder(Binder containingBinder);
    protected Binder(Binder containingBinder, SyntaxTree syntaxTree);
    protected Binder(Binder containingBinder, SourceModuleSymbol sourceModule, VisualBasicCompilation compilation);
    protected Binder(Binder containingBinder, Nullable`1<bool> isEarlyAttributeBinder, Nullable`1<bool> ignoreBaseClassesInLookup);
    protected Binder(Binder containingBinder, ConsList`1<Symbol> basesBeingResolved);
    public Binder get_ContainingBinder();
    internal virtual LookupOptions BinderSpecificLookupOptions(LookupOptions options);
    internal bool get_IgnoresAccessibility();
    public virtual void Lookup(LookupResult lookupResult, string name, int arity, LookupOptions options, HashSet`1& useSiteDiagnostics);
    internal virtual void LookupInSingleBinder(LookupResult lookupResult, string name, int arity, LookupOptions options, Binder originalBinder, HashSet`1& useSiteDiagnostics);
    protected virtual void CollectProbableExtensionMethodsInSingleBinder(string name, ArrayBuilder`1<MethodSymbol> methods, Binder originalBinder);
    protected virtual void AddExtensionMethodLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
    internal virtual LabelSymbol LookupLabelByNameToken(SyntaxToken labelName);
    public virtual void AddLookupSymbolsInfo(LookupSymbolsInfo nameSet, LookupOptions options);
    internal virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
    public virtual AccessCheckResult CheckAccessibility(Symbol sym, HashSet`1& useSiteDiagnostics, TypeSymbol accessThroughType, ConsList`1<Symbol> basesBeingResolved);
    public bool IsAccessible(Symbol sym, HashSet`1& useSiteDiagnostics, TypeSymbol accessThroughType, ConsList`1<Symbol> basesBeingResolved);
    public virtual Binder GetBinder(VisualBasicSyntaxNode node);
    public virtual Binder GetBinder(SyntaxList`1<StatementSyntax> stmtList);
    public virtual Symbol get_ContainingMember();
    internal ModuleSymbol get_ContainingModule();
    public virtual bool get_IsInQuery();
    internal bool get_IsInLambda();
    public virtual ConsList`1<LocalSymbol> get_ImplicitlyTypedLocalsBeingBound();
    public virtual bool IsUnboundTypeAllowed(GenericNameSyntax syntax);
    public virtual NamedTypeSymbol get_ContainingType();
    internal bool get_BindingTopLevelScriptCode();
    public virtual NamespaceOrTypeSymbol get_ContainingNamespaceOrType();
    public NamedTypeSymbol GetSpecialType(SpecialType typeId, SyntaxNodeOrToken node, DiagnosticBag diagBag);
    public static NamedTypeSymbol GetSpecialType(AssemblySymbol assembly, SpecialType typeId, SyntaxNodeOrToken node, DiagnosticBag diagBag);
    public NamedTypeSymbol GetSpecialType(SpecialType typeId, SyntaxNodeOrToken node, DiagnosticBag diagBag, Boolean& reportedAnError, bool suppressUseSiteError);
    public static NamedTypeSymbol GetSpecialType(AssemblySymbol assembly, SpecialType typeId, SyntaxNodeOrToken node, DiagnosticBag diagBag, Boolean& reportedAnError, bool suppressUseSiteError);
    internal static DiagnosticInfo GetUseSiteErrorForSpecialType(TypeSymbol type, bool suppressUseSiteError);
    internal NamedTypeSymbol GetWellKnownType(WellKnownType type, VisualBasicSyntaxNode syntax, DiagnosticBag diagBag);
    internal static NamedTypeSymbol GetWellKnownType(VisualBasicCompilation compilation, WellKnownType type, VisualBasicSyntaxNode syntax, DiagnosticBag diagBag);
    internal static DiagnosticInfo GetUseSiteErrorForWellKnownType(TypeSymbol type);
    private NamedTypeSymbol GetInternalXmlHelperType(VisualBasicSyntaxNode syntax, DiagnosticBag diagBag);
    private NamedTypeSymbol GetInternalXmlHelperType();
    private PropertySymbol GetInternalXmlHelperValueExtensionProperty();
    internal Symbol GetSpecialTypeMember(SpecialMember member, VisualBasicSyntaxNode syntax, DiagnosticBag diagnostics);
    internal static Symbol GetSpecialTypeMember(AssemblySymbol assembly, SpecialMember member, VisualBasicSyntaxNode syntax, DiagnosticBag diagnostics);
    internal static Symbol GetSpecialTypeMember(AssemblySymbol assembly, SpecialMember member, DiagnosticInfo& useSiteError);
    internal Symbol GetWellKnownTypeMember(WellKnownMember member, VisualBasicSyntaxNode syntax, DiagnosticBag diagBag);
    internal static Symbol GetWellKnownTypeMember(VisualBasicCompilation compilation, WellKnownMember member, VisualBasicSyntaxNode syntax, DiagnosticBag diagBag);
    internal static Symbol GetWellKnownTypeMember(VisualBasicCompilation compilation, WellKnownMember member, DiagnosticInfo& useSiteError);
    internal static DiagnosticInfo GetUseSiteErrorForWellKnownTypeMember(Symbol memberSymbol, WellKnownMember member, bool embedVBRuntimeUsed);
    public SourceModuleSymbol get_SourceModule();
    public VisualBasicCompilation get_Compilation();
    public virtual ErrorTypeSymbol GetErrorSymbol(string name, DiagnosticInfo errorInfo, ImmutableArray`1<Symbol> candidateSymbols, LookupResultKind resultKind);
    public ErrorTypeSymbol GetErrorSymbol(string name, DiagnosticInfo errorInfo);
    public Location GetLocation(TextSpan span);
    public virtual SyntaxReference GetSyntaxReference(VisualBasicSyntaxNode node);
    public SyntaxTree get_SyntaxTree();
    public ConsList`1<Symbol> BasesBeingResolved();
    internal virtual SymbolsInProgress`1<FieldSymbol> get_ConstantFieldsInProgress();
    internal virtual SymbolsInProgress`1<ParameterSymbol> get_DefaultParametersInProgress();
    public bool get_IgnoreBaseClassesInLookup();
    public virtual OptionStrict get_OptionStrict();
    public virtual bool get_OptionInfer();
    public virtual bool get_OptionExplicit();
    public virtual bool get_OptionCompareText();
    public virtual bool get_CheckOverflow();
    public virtual bool get_AllImplicitVariableDeclarationsAreHandled();
    public virtual bool get_ImplicitVariableDeclarationAllowed();
    public virtual LocalSymbol DeclareImplicitLocalVariable(IdentifierNameSyntax nameSyntax, DiagnosticBag diagnostics);
    public virtual ImmutableArray`1<LocalSymbol> get_ImplicitlyDeclaredVariables();
    public virtual void DisallowFurtherImplicitVariableDeclaration(DiagnosticBag diagnostics);
    public virtual LabelSymbol GetExitLabel(SyntaxKind exitSyntaxKind);
    public virtual LabelSymbol GetContinueLabel(SyntaxKind continueSyntaxKind);
    public virtual LabelSymbol GetReturnLabel();
    public virtual LocalSymbol GetLocalForFunctionValue();
    public static void ReportDiagnostic(DiagnosticBag diagBag, SyntaxNodeOrToken syntax, ERRID id);
    public static void ReportDiagnostic(DiagnosticBag diagBag, SyntaxNodeOrToken syntax, ERRID id, Object[] args);
    public static void ReportDiagnostic(DiagnosticBag diagBag, SyntaxNodeOrToken syntax, DiagnosticInfo info);
    public static void ReportDiagnostic(DiagnosticBag diagBag, Location location, ERRID id);
    public static void ReportDiagnostic(DiagnosticBag diagBag, Location location, ERRID id, Object[] args);
    public static void ReportDiagnostic(DiagnosticBag diagBag, Location location, DiagnosticInfo info);
    public static void ReportDiagnostic(DiagnosticBag diagBag, Diagnostic diag);
    internal void ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics, Symbol symbol, VisualBasicSyntaxNode node);
    internal static void ReportDiagnosticsIfObsolete(DiagnosticBag diagnostics, Symbol context, Symbol symbol, VisualBasicSyntaxNode node);
    internal virtual bool get_SuppressObsoleteDiagnostics();
    public virtual BindingLocation get_BindingLocation();
    public bool get_IsEarlyAttributeBinder();
    internal bool get_ShouldCheckConstraints();
    internal virtual bool get_HasImportedXmlNamespaces();
    internal virtual void GetInScopeXmlNamespaces(ArrayBuilder`1<KeyValuePair`2<string, string>> builder);
    internal virtual bool LookupXmlNamespace(string prefix, bool ignoreXmlNodes, String& namespace, Boolean& fromImports);
    internal bool ReportUseSiteErrorForSynthesizedAttribute(WellKnownMember attributeCtor, VisualBasicSyntaxNode syntax, DiagnosticBag diagnostics);
    internal static bool ReportUseSiteErrorForSynthesizedAttribute(WellKnownMember attributeCtor, VisualBasicCompilation compilation, Location location, DiagnosticBag diagnostics);
    internal virtual BoundExpression GetWithStatementPlaceholderSubstitute(BoundValuePlaceholderBase placeholder);
    public virtual bool get_IsSemanticModelBinder();
    public virtual QuickAttributeChecker get_QuickAttributeChecker();
    private BoundExpression BindAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindAnonymousObjectCreationExpression(VisualBasicSyntaxNode node, AnonymousTypeDescriptor typeDescr, ImmutableArray`1<BoundExpression> initExpressions, DiagnosticBag diagnostics);
    private BoundExpression CreateAnonymousObjectCreationExpression(VisualBasicSyntaxNode node, AnonymousTypeDescriptor typeDescr, ImmutableArray`1<BoundExpression> initExpressions, bool hasErrors);
    protected virtual BoundAnonymousTypeCreationExpression CreateAnonymousObjectCreationExpression(VisualBasicSyntaxNode node, AnonymousTypePublicSymbol anonymousType, ImmutableArray`1<BoundExpression> initExpressions, bool hasErrors);
    internal static ImmutableArray`1<NamedTypeSymbol> BindAttributeTypes(ImmutableArray`1<Binder> binders, ImmutableArray`1<AttributeSyntax> attributesToBind, Symbol ownerSymbol, DiagnosticBag diagnostics);
    internal static NamedTypeSymbol BindAttributeType(Binder binder, AttributeSyntax attribute, Symbol ownerSymbol, DiagnosticBag diagnostics);
    internal static void GetAttributes(ImmutableArray`1<Binder> binders, ImmutableArray`1<AttributeSyntax> attributesToBind, ImmutableArray`1<NamedTypeSymbol> boundAttributeTypes, VisualBasicAttributeData[] attributeBuilder, Symbol ownerSymbol, DiagnosticBag diagnostics);
    internal SourceAttributeData GetAttribute(AttributeSyntax node, NamedTypeSymbol boundAttributeType, DiagnosticBag diagnostics);
    protected bool IsAttributeConditionallyOmitted(NamedTypeSymbol attributeType, AttributeSyntax node, SyntaxTree syntaxTree);
    internal BoundAttribute BindAttribute(AttributeSyntax node, DiagnosticBag diagnostics);
    internal void LookupAttributeType(LookupResult lookupResult, NamespaceOrTypeSymbol container, string name, LookupOptions options, HashSet`1& useSiteDiagnostics);
    private void Lookup(LookupResult lookupResult, NamespaceOrTypeSymbol container, string name, LookupOptions options, HashSet`1& useSiteDiagnostics);
    private void CheckAttributeTypeViability(LookupResult lookupResult);
    internal BoundAttribute BindAttribute(AttributeSyntax node, NamedTypeSymbol type, DiagnosticBag diagnostics);
    private AnalyzedAttributeArguments BindAttributeArguments(NamedTypeSymbol type, ArgumentListSyntax argumentListOpt, DiagnosticBag diagnostics);
    private BoundExpression BindAttributeNamedArgument(TypeSymbol container, SimpleArgumentSyntax namedArg, DiagnosticBag diagnostics);
    private void MarkEmbeddedTypeReferenceIfNeeded(BoundExpression expression);
    private void MarkEmbeddedTypeReferencedFromGetTypeExpression(BoundGetType expression);
    private Symbol GetBestAttributeFieldOrProperty(LookupResult result);
    private bool IsValidTypeForAttributeArgument(TypeSymbol type);
    private BoundExpression BindConditionalAccessExpression(ConditionalAccessExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindConditionalAccessReceiver(ConditionalAccessExpressionSyntax node, DiagnosticBag diagnostics, BoundRValuePlaceholder& placeholder);
    protected virtual BoundExpression TryBindOmittedLeftForConditionalAccess(ConditionalAccessExpressionSyntax node, Binder accessingBinder, DiagnosticBag diagnostics);
    protected BoundExpression GetConditionalAccessReceiver(ConditionalAccessExpressionSyntax node);
    protected virtual BoundExpression TryGetConditionalAccessReceiver(ConditionalAccessExpressionSyntax node);
    internal ImmutableArray`1<TypeParameterConstraint> BindTypeParameterConstraintClause(Symbol containingSymbol, TypeParameterConstraintClauseSyntax clause, DiagnosticBag diagnostics);
    private void BindTypeParameterConstraint(Symbol containingSymbol, ConstraintSyntax syntax, TypeParameterConstraintKind& constraints, ArrayBuilder`1<TypeParameterConstraint> constraintsBuilder, DiagnosticBag diagnostics);
    private BoundExpression BindCastExpression(CastExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindCTypeExpression(CastExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindDirectCastExpression(CastExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression ApplyDirectCastConversion(VisualBasicSyntaxNode node, BoundExpression argument, TypeSymbol targetType, DiagnosticBag diagnostics);
    private BoundExpression BindTryCastExpression(CastExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression ApplyTryCastConversion(VisualBasicSyntaxNode node, BoundExpression argument, TypeSymbol targetType, DiagnosticBag diagnostics);
    private BoundExpression BindPredefinedCastExpression(PredefinedCastExpressionSyntax node, DiagnosticBag diagnostics);
    internal BoundExpression ApplyImplicitConversion(VisualBasicSyntaxNode node, TypeSymbol targetType, BoundExpression expression, DiagnosticBag diagnostics, bool isOperandOfConditionalBranch);
    private BoundExpression ApplyConversion(VisualBasicSyntaxNode node, TypeSymbol targetType, BoundExpression argument, bool isExplicit, DiagnosticBag diagnostics, bool isOperandOfConditionalBranch, bool explicitSemanticForConcatArgument);
    private BoundNullableIsTrueOperator ApplyNullableIsTrueOperator(BoundExpression argument, TypeSymbol booleanType);
    private BoundExpression CreateConversionAndReportDiagnostic(VisualBasicSyntaxNode tree, BoundExpression argument, KeyValuePair`2<ConversionKind, MethodSymbol> convKind, bool isExplicit, TypeSymbol targetType, DiagnosticBag diagnostics, string copybackConversionParamName, bool explicitSemanticForConcatArgument);
    private bool MakeVarianceConversionSuggestion(ConversionKind convKind, VisualBasicSyntaxNode location, TypeSymbol sourceType, TypeSymbol targetType, DiagnosticBag diagnostics, bool justWarn);
    private BoundConversion CreatePredefinedConversion(VisualBasicSyntaxNode tree, BoundExpression argument, ConversionKind convKind, bool isExplicit, TypeSymbol targetType, DiagnosticBag diagnostics);
    private BoundConversion CreateUserDefinedConversion(VisualBasicSyntaxNode tree, BoundExpression argument, KeyValuePair`2<ConversionKind, MethodSymbol> convKind, bool isExplicit, TypeSymbol targetType, bool reportArrayLiteralElementNarrowingConversion, DiagnosticBag diagnostics);
    private bool ReclassifyExpression(BoundExpression& argument, SyntaxKind conversionSemantics, VisualBasicSyntaxNode tree, ConversionKind convKind, bool isExplicit, TypeSymbol targetType, DiagnosticBag diagnostics);
    private BoundExpression ReclassifyUnboundLambdaExpression(UnboundLambda unboundLambda, SyntaxKind conversionSemantics, VisualBasicSyntaxNode tree, ConversionKind convKind, bool isExplicit, TypeSymbol targetType, DiagnosticBag diagnostics);
    private BoundExpression ReclassifyQueryLambdaExpression(BoundQueryLambda lambda, SyntaxKind conversionSemantics, VisualBasicSyntaxNode tree, ConversionKind convKind, bool isExplicit, TypeSymbol targetType, DiagnosticBag diagnostics);
    private BoundExpression ReclassifyInterpolatedStringExpression(SyntaxKind conversionSemantics, VisualBasicSyntaxNode tree, ConversionKind convKind, bool isExplicit, BoundInterpolatedStringExpression node, TypeSymbol targetType, DiagnosticBag diagnostics);
    private void WarnOnNarrowingConversionBetweenSealedClassAndAnInterface(ConversionKind convKind, VisualBasicSyntaxNode location, TypeSymbol sourceType, TypeSymbol targetType, DiagnosticBag diagnostics);
    private bool IsIEnumerableOfXElement(TypeSymbol type, HashSet`1& useSiteDiagnostics);
    private void ReportNoConversionError(VisualBasicSyntaxNode location, TypeSymbol sourceType, TypeSymbol targetType, DiagnosticBag diagnostics, string copybackConversionParamName);
    private BoundExpression BindAddressOfExpression(VisualBasicSyntaxNode node, DiagnosticBag diagnostics);
    private BoundExpression BindDelegateCreationExpression(TypeSymbol delegateType, ArgumentListSyntax argumentListOpt, VisualBasicSyntaxNode node, DiagnosticBag diagnostics);
    internal static DelegateResolutionResult InterpretDelegateBinding(BoundAddressOfOperator addressOfExpression, TypeSymbol targetType, bool isForHandles);
    internal bool ReportDelegateInvokeUseSiteError(DiagnosticBag diagBag, VisualBasicSyntaxNode syntax, TypeSymbol delegateType, MethodSymbol invoke);
    internal static KeyValuePair`2<MethodSymbol, MethodConversionKind> ResolveMethodForDelegateInvokeFullAndRelaxed(BoundAddressOfOperator addressOfExpression, MethodSymbol toMethod, bool ignoreMethodReturnType, DiagnosticBag diagnostics);
    private static KeyValuePair`2<MethodSymbol, MethodConversionKind> ResolveMethodForDelegateInvokeFullOrRelaxed(BoundAddressOfOperator addressOfExpression, MethodSymbol toMethod, bool ignoreMethodReturnType, DiagnosticBag diagnostics, bool useZeroArgumentRelaxation, Boolean& couldTryZeroArgumentRelaxation);
    private static KeyValuePair`2<MethodSymbol, MethodConversionKind> ValidateMethodForDelegateInvoke(BoundAddressOfOperator addressOfExpression, CandidateAnalysisResult analysisResult, MethodSymbol toMethod, bool ignoreMethodReturnType, bool useZeroArgumentRelaxation, DiagnosticBag diagnostics);
    private void ReportDelegateBindingMismatchStrictOff(VisualBasicSyntaxNode syntax, NamedTypeSymbol delegateType, MethodSymbol targetMethodSymbol, DiagnosticBag diagnostics);
    private void ReportDelegateBindingIncompatible(VisualBasicSyntaxNode syntax, NamedTypeSymbol delegateType, MethodSymbol targetMethodSymbol, DiagnosticBag diagnostics);
    private static MethodConversionKind GetDelegateMethodConversionBasedOnArguments(CandidateAnalysisResult bestResult, MethodSymbol delegateInvoke, HashSet`1& useSiteDiagnostics);
    internal static ConversionKind ClassifyAddressOfConversion(BoundAddressOfOperator source, TypeSymbol destination);
    private static SourceParameterFlags CheckDelegateParameterModifier(Symbol container, SyntaxToken token, SourceParameterFlags flag, DiagnosticBag diagnostics);
    private static string GetDelegateOrEventKeywordText(Symbol sym);
    internal BoundExpression ReclassifyAddressOf(BoundAddressOfOperator addressOfExpression, DelegateResolutionResult& delegateResolutionResult, TypeSymbol targetType, DiagnosticBag diagnostics, bool isForHandles, bool warnIfResultOfAsyncMethodIsDroppedDueToRelaxation);
    private BoundLambda BuildDelegateRelaxationLambda(VisualBasicSyntaxNode syntaxNode, VisualBasicSyntaxNode methodGroupSyntax, BoundExpression receiver, MethodSymbol targetMethod, BoundTypeArguments typeArgumentsOpt, QualificationKind qualificationKind, MethodSymbol delegateInvoke, ConversionKind delegateRelaxation, bool isZeroArgumentKnownToBeUsed, bool warnIfResultOfAsyncMethodIsDroppedDueToRelaxation, DiagnosticBag diagnostics, BoundRValuePlaceholder& relaxationReceiverPlaceholder);
    private BoundLambda BuildDelegateRelaxationLambda(VisualBasicSyntaxNode syntaxNode, MethodSymbol delegateInvoke, BoundMethodGroup methodGroup, ConversionKind delegateRelaxation, bool isZeroArgumentKnownToBeUsed, bool warnIfResultOfAsyncMethodIsDroppedDueToRelaxation, DiagnosticBag diagnostics);
    public BoundExpression ReportDiagnosticAndProduceBadExpression(DiagnosticBag diagBag, VisualBasicSyntaxNode syntax, ERRID id, Object[] args);
    public BoundExpression ReportDiagnosticAndProduceBadExpression(DiagnosticBag diagBag, VisualBasicSyntaxNode syntax, DiagnosticInfo info, BoundNode[] nodes);
    public ErrorTypeSymbol ReportDiagnosticAndProduceErrorTypeSymbol(DiagnosticBag diagBag, VisualBasicSyntaxNode syntax, ERRID id, Object[] args);
    public ErrorTypeSymbol ReportDiagnosticAndProduceErrorTypeSymbol(DiagnosticBag diagBag, VisualBasicSyntaxNode syntax, DiagnosticInfo info);
    internal virtual ImmutableArray`1<Symbol> BindInsideCrefAttributeValue(TypeSyntax name, bool preserveAliases, DiagnosticBag diagnosticBag, HashSet`1& useSiteDiagnostics);
    internal virtual ImmutableArray`1<Symbol> BindInsideCrefAttributeValue(CrefReferenceSyntax reference, bool preserveAliases, DiagnosticBag diagnosticBag, HashSet`1& useSiteDiagnostics);
    internal virtual ImmutableArray`1<Symbol> BindXmlNameAttributeValue(IdentifierNameSyntax identifier, HashSet`1& useSiteDiagnostics);
    public BoundExpression BindExpression(ExpressionSyntax node, DiagnosticBag diagnostics);
    public BoundExpression BindExpression(ExpressionSyntax node, bool isInvocationOrAddressOf, bool isOperandOfConditionalBranch, bool eventContext, DiagnosticBag diagnostics);
    protected static BoundBadExpression BadExpression(VisualBasicSyntaxNode node, TypeSymbol resultType);
    private static BoundBadExpression BadExpression(VisualBasicSyntaxNode node, BoundNode expr, TypeSymbol resultType);
    private static BoundBadExpression BadExpression(VisualBasicSyntaxNode node, BoundNode expr, LookupResultKind resultKind, TypeSymbol resultType);
    private static BoundBadExpression BadExpression(VisualBasicSyntaxNode node, ImmutableArray`1<BoundNode> exprs, TypeSymbol resultType);
    private static BoundBadExpression BadExpression(BoundExpression expr);
    private static BoundBadExpression BadExpression(LookupResultKind resultKind, BoundExpression wrappedExpression);
    public BoundExpression BindNamespaceOrTypeExpression(TypeSyntax node, DiagnosticBag diagnostics);
    public BoundExpression BindNamespaceOrTypeOrExpressionSyntaxForSemanticModel(ExpressionSyntax node, DiagnosticBag diagnostics);
    private static void BindNamespaceOrTypeSyntaxForSemanticModelGetExpressionSymbols(BoundExpression expression, ArrayBuilder`1<Symbol> symbols);
    private BoundExpression BindQualifiedName(QualifiedNameSyntax name, DiagnosticBag diagnostics);
    private BoundExpression BindGetTypeExpression(GetTypeExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindNameOfExpression(NameOfExpressionSyntax node, DiagnosticBag diagnostics);
    private void VerifyNameOfLookupResult(NamespaceOrTypeSymbol container, SimpleNameSyntax member, LookupResult lookupResult, DiagnosticBag diagnostics);
    private BoundExpression BindTypeOfExpression(TypeOfExpressionSyntax node, DiagnosticBag diagnostics);
    internal BoundExpression BindValue(ExpressionSyntax node, DiagnosticBag diagnostics, bool isOperandOfConditionalBranch);
    private BoundExpression AdjustReceiverTypeOrValue(BoundExpression receiver, VisualBasicSyntaxNode node, bool isShared, DiagnosticBag diagnostics, BoundExpression& resolvedTypeOrValueExpression);
    private BoundExpression AdjustReceiverTypeOrValue(BoundExpression receiver, VisualBasicSyntaxNode node, bool isShared, DiagnosticBag diagnostics, QualificationKind& qualKind);
    private BoundExpression AdjustReceiverTypeOrValue(BoundExpression receiver, VisualBasicSyntaxNode node, bool isShared, bool clearIfShared, DiagnosticBag diagnostics, QualificationKind& qualKind, BoundExpression& resolvedTypeOrValueExpression);
    private BoundExpression AdjustReceiverAmbiguousTypeOrValue(BoundExpression receiver, DiagnosticBag diagnostics);
    private BoundExpression AdjustReceiverAmbiguousTypeOrValue(BoundMethodOrPropertyGroup& group, DiagnosticBag diagnostics);
    private BoundExpression AdjustReceiverValue(BoundExpression receiver, VisualBasicSyntaxNode node, DiagnosticBag diagnostics);
    internal BoundExpression ReclassifyAsValue(BoundExpression expr, DiagnosticBag diagnostics);
    internal virtual bool get_IsDefaultInstancePropertyAllowed();
    internal virtual bool get_SuppressCallerInfo();
    internal BoundExpression TryDefaultInstanceProperty(BoundTypeExpression typeExpr, DiagnosticBag diagnosticsBagFor_ERR_CantReferToMyGroupInsideGroupType1);
    private ERRID GetTypeNotExpressionErrorId(TypeSymbol type);
    private BoundExpression MakeValue(BoundExpression expr, DiagnosticBag diagnostics);
    private TypeSymbol GetAccessThroughType(BoundExpression receiverOpt);
    private BoundExpression BindRValue(ExpressionSyntax node, DiagnosticBag diagnostics, bool isOperandOfConditionalBranch);
    internal BoundExpression MakeRValue(BoundExpression expr, DiagnosticBag diagnostics);
    private BoundExpression MakeRValueAndIgnoreDiagnostics(BoundExpression expr);
    internal BoundExpression ReclassifyExpression(BoundExpression expr, DiagnosticBag diagnostics);
    private BoundExpression ReclassifyArrayLiteralExpression(SyntaxKind conversionSemantics, VisualBasicSyntaxNode tree, ConversionKind conv, bool isExplicit, BoundArrayLiteral arrayLiteral, TypeSymbol destination, DiagnosticBag diagnostics);
    private void ReportArrayLiteralDiagnostics(BoundArrayLiteral arrayLiteral, ArrayTypeSymbol targetArrayType, DiagnosticBag diagnostics);
    private void ReportArrayLiteralInferredTypeDiagnostics(BoundArrayLiteral arrayLiteral, DiagnosticBag diagnostics);
    private BoundArrayInitialization ReclassifyArrayInitialization(BoundArrayInitialization arrayInitialization, TypeSymbol elementType, DiagnosticBag diagnostics);
    private BoundArrayInitialization ReclassifyEmptyArrayInitialization(BoundArrayLiteral arrayLiteral, int rank);
    private BoundExpression ReclassifyArrayLiteralExpression(BoundArrayLiteral arrayLiteral, DiagnosticBag diagnostics);
    private BoundExpression ReclassifyUnboundLambdaExpression(UnboundLambda lambda, DiagnosticBag diagnostics);
    private BoundExpression BindAssignmentTarget(ExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindAssignmentTarget(VisualBasicSyntaxNode node, BoundExpression expression, DiagnosticBag diagnostics);
    internal static bool IsValidAssignmentTarget(BoundExpression expression);
    private void ReportAssignmentToRValue(BoundExpression expr, DiagnosticBag diagnostics);
    public static bool ExpressionRefersToReadonlyVariable(BoundExpression node, bool digThroughProperty);
    internal bool IsLValueFieldAccess(FieldSymbol field, BoundExpression receiver);
    private MethodKind KindOfContainingMethodAtRunTime();
    private BoundExpression BindTernaryConditionalExpression(TernaryConditionalExpressionSyntax node, DiagnosticBag diagnostics);
    private bool IsConstantAllowingCompileTimeFolding(BoundExpression candidate);
    private BoundExpression BindBinaryConditionalExpression(BinaryConditionalExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression AnalyzeConversionAndCreateBinaryConditionalExpression(VisualBasicSyntaxNode syntax, BoundExpression testExpression, BoundExpression elseExpression, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors, DiagnosticBag diagnostics, bool explicitConversion);
    private bool GenerateDiagnosticsForDominantTypeInferenceInIfExpression(TypeSymbol dominantType, int numCandidates, ExpressionSyntax node, DiagnosticBag diagnostics);
    protected virtual bool get_IsInsideChainedConstructorCallArguments();
    private bool IsMeOrMyBaseOrMyClassInSharedContext();
    private bool CheckMeOrMyBaseOrMyClassInSharedOrDisallowedContext(bool implicitReference, ERRID& errorId);
    private bool CanAccessMyBase(bool implicitReference, ERRID& errorId);
    private bool CanAccessMeOrMyClass(bool implicitReference, ERRID& errorId);
    internal bool CanAccessMe(bool implicitReference, ERRID& errorId);
    private bool CanAccessMyClass(bool implicitReference, ERRID& errorId);
    private BoundMeReference BindMeExpression(MeExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundMeReference CreateMeReference(VisualBasicSyntaxNode node, bool isSynthetic);
    private BoundMyBaseReference BindMyBaseExpression(MyBaseExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundMyClassReference BindMyClassExpression(MyClassExpressionSyntax node, DiagnosticBag diagnostics);
    private bool CanBeImplicitVariableDeclaration(SimpleNameSyntax nameSyntax);
    private BoundExpression BindSimpleName(SimpleNameSyntax node, bool isInvocationOrAddressOf, DiagnosticBag diagnostics, bool skipLocalsAndParameters);
    private BoundExpression BindSimpleName(LookupResult result, VisualBasicSyntaxNode node, LookupOptions options, TypeArgumentListSyntax typeArguments, DiagnosticBag diagnostics);
    private static bool BindSimpleNameIsMemberOfType(Symbol member, NamedTypeSymbol type);
    private BoundExpression TryBindInteractiveReceiver(VisualBasicSyntaxNode syntax, Symbol currentMember, NamedTypeSymbol currentType, NamedTypeSymbol memberDeclaringType);
    private BoundExpression BindMemberAccess(MemberAccessExpressionSyntax node, bool eventContext, DiagnosticBag diagnostics);
    private BoundExpression BindLeftOfPotentialColorColorMemberAccess(MemberAccessExpressionSyntax parentNode, ExpressionSyntax leftOpt, DiagnosticBag diagnostics);
    protected BoundExpression BindMemberAccess(VisualBasicSyntaxNode node, BoundExpression left, SimpleNameSyntax right, bool eventContext, DiagnosticBag diagnostics);
    protected internal virtual BoundExpression TryBindOmittedLeftForMemberAccess(MemberAccessExpressionSyntax node, DiagnosticBag diagnostics, Binder accessingBinder, Boolean& wholeMemberAccessExpressionBound);
    protected internal virtual BoundExpression TryBindOmittedLeftForXmlMemberAccess(XmlMemberAccessExpressionSyntax node, DiagnosticBag diagnostics, Binder accessingBinder);
    private bool IsBindingImplicitlyTypedLocal(LocalSymbol symbol);
    private TypeSymbol GetLocalSymbolType(LocalSymbol localSymbol, VisualBasicSyntaxNode node, DiagnosticBag diagnostics);
    private BoundExpression BindSymbolAccess(VisualBasicSyntaxNode node, LookupResult lookupResult, LookupOptions lookupOptionsUsed, BoundExpression receiver, TypeArgumentListSyntax typeArgumentsOpt, QualificationKind qualKind, DiagnosticBag diagnostics);
    private BoundExpression AdjustReceiverNamespace(LookupResult lookupResult, BoundExpression receiver);
    private BoundNamespaceExpression AdjustReceiverNamespace(BoundNamespaceExpression namespaceReceiver, ArrayBuilder`1<Symbol> symbols);
    internal static bool AddReceiverNamespaces(SmallDictionary`2<NamespaceSymbol, bool> namespaces, Symbol candidate, VisualBasicCompilation compilation);
    private static bool AddContainingNamespaces(SmallDictionary`2<NamespaceSymbol, bool> namespaces, Symbol candidate, VisualBasicCompilation compilation);
    private BoundNamespaceExpression AdjustReceiverNamespace(BoundNamespaceExpression namespaceReceiver, NamespaceSymbol adjustedNamespace);
    private static bool IsNamespaceGroupIncludesButNotEquivalentTo(NamespaceSymbol namespaceGroup, NamespaceSymbol other);
    private void CheckMemberTypeAccessibility(DiagnosticBag diagnostics, VisualBasicSyntaxNode node, Symbol member);
    public static bool IsTopMostEnclosingLambdaAQueryLambda(Symbol containingMember, Symbol stopAtContainer);
    public BoundExpression BindLabel(LabelSyntax node, DiagnosticBag diagnostics);
    private BoundTypeArguments BindTypeArguments(TypeArgumentListSyntax typeArgumentsOpt, DiagnosticBag diagnostics);
    private bool CheckSharedSymbolAccess(VisualBasicSyntaxNode node, bool isShared, BoundExpression& receiver, QualificationKind qualKind, DiagnosticBag diagnostics);
    private static bool IsReceiverOfNameOfArgument(VisualBasicSyntaxNode syntax);
    private static bool IsNameOfArgument(VisualBasicSyntaxNode syntax);
    protected virtual BoundExpression TryBindOmittedLeftForDictionaryAccess(MemberAccessExpressionSyntax node, Binder accessingBinder, DiagnosticBag diagnostics);
    private BoundExpression BindDictionaryAccess(MemberAccessExpressionSyntax node, DiagnosticBag diagnostics);
    private void ReportNoDefaultProperty(BoundExpression expr, DiagnosticBag diagnostics);
    private void ReportQualNotObjectRecord(BoundExpression expr, DiagnosticBag diagnostics);
    private void ReportDefaultMemberNotProperty(BoundExpression expr, DiagnosticBag diagnostics);
    private BoundExpression GenerateBadExpression(InvocationExpressionSyntax node, BoundExpression target, ImmutableArray`1<BoundExpression> boundArguments);
    private void VerifyTypeCharacterConsistency(SyntaxNodeOrToken nodeOrToken, TypeSymbol type, TypeCharacter typeChar, DiagnosticBag diagnostics);
    private void VerifyTypeCharacterConsistency(SimpleNameSyntax name, TypeSymbol type, DiagnosticBag diagnostics);
    private BoundExpression BindArrayAccess(InvocationExpressionSyntax node, BoundExpression expr, ImmutableArray`1<BoundExpression> boundArguments, ImmutableArray`1<string> argumentNames, DiagnosticBag diagnostics);
    private TypeSymbol GetCommonExpressionType(VisualBasicSyntaxNode symbolReference, ImmutableArray`1<Symbol> symbols, SymbolsInProgress`1<FieldSymbol> constantFieldsInProgress);
    private TypeSymbol GetExpressionType(VisualBasicSyntaxNode symbolReference, Symbol s, SymbolsInProgress`1<FieldSymbol> constantFieldsInProgress, DiagnosticBag diagnostics);
    private static SyntaxToken GetNamedArgumentIdentifier(VisualBasicSyntaxNode argumentExpression);
    private BoundExpression BindArrayCreationExpression(ArrayCreationExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindArrayLiteralExpression(CollectionInitializerSyntax node, DiagnosticBag diagnostics);
    private ImmutableArray`1<BoundExpression> CreateArrayBounds(VisualBasicSyntaxNode node, DimensionSize[] knownSizes, DiagnosticBag diagnostics);
    private int ComputeArrayLiteralRank(CollectionInitializerSyntax node);
    private BoundArrayInitialization BindArrayInitializerList(CollectionInitializerSyntax node, ArrayTypeSymbol type, DimensionSize[] knownSizes, DiagnosticBag diagnostics);
    private BoundArrayInitialization BindArrayInitializerList(CollectionInitializerSyntax node, DimensionSize[] knownSizes, Boolean& hasDominantType, Int32& numberOfCandidates, TypeSymbol& inferredElementType, DiagnosticBag diagnostics);
    private BoundArrayInitialization BindArrayInitializerList(CollectionInitializerSyntax node, ArrayTypeSymbol type, DimensionSize[] knownSizes, int dimension, ArrayBuilder`1<BoundExpression> allInitializers, DiagnosticBag diagnostics);
    private void CheckRangeArgumentLowerBound(RangeArgumentSyntax rangeArgument, DiagnosticBag diagnostics);
    private ImmutableArray`1<BoundExpression> BindArrayBounds(ArgumentListSyntax arrayBoundsOpt, DiagnosticBag diagnostics, DimensionSize[] knownSizes, bool errorOnEmptyBound);
    private BoundLiteral BindLiteralConstant(LiteralExpressionSyntax node, DiagnosticBag diagnostics);
    internal TypeSymbol InferDominantTypeOfExpressions(VisualBasicSyntaxNode syntax, ArrayBuilder`1<BoundExpression> Expressions, DiagnosticBag diagnostics, Int32& numCandidates, InferenceErrorReasons& errorReasons);
    public bool IsInAsyncContext();
    public bool IsInIteratorContext();
    private BoundExpression BindAwait(AwaitExpressionSyntax node, DiagnosticBag diagnostics, bool bindAsStatement);
    private BoundExpression BindAwait(VisualBasicSyntaxNode node, BoundExpression operand, DiagnosticBag diagnostics, bool bindAsStatement);
    private static bool DiagnosticBagHasErrorsOtherThanObsoleteOnes(DiagnosticBag bag);
    private DiagnosticInfo GetAwaitInNonAsyncError();
    public void BindImportClause(ImportsClauseSyntax importClauseSyntax, ImportData data, DiagnosticBag diagBag);
    internal static ImmutableArray`1<BoundInitializer> BindFieldAndPropertyInitializers(SourceMemberContainerTypeSymbol symbol, ImmutableArray`1<ImmutableArray`1<FieldOrPropertyInitializer>> initializers, SynthesizedInteractiveInitializerMethod scriptInitializerOpt, DiagnosticBag diagnostics);
    private BoundInitializer BindGlobalStatement(SynthesizedInteractiveInitializerMethod scriptInitializerOpt, StatementSyntax statementNode, DiagnosticBag diagnostics, bool isLast);
    public void BindArrayFieldImplicitInitializer(SourceFieldSymbol fieldSymbol, ArrayBuilder`1<BoundInitializer> boundInitializers, DiagnosticBag diagnostics);
    internal void BindFieldInitializer(ImmutableArray`1<FieldSymbol> fieldSymbols, VisualBasicSyntaxNode equalsValueOrAsNewSyntax, ArrayBuilder`1<BoundInitializer> boundInitializers, DiagnosticBag diagnostics, bool bindingForSemanticModel);
    internal void BindPropertyInitializer(ImmutableArray`1<PropertySymbol> propertySymbols, VisualBasicSyntaxNode initValueOrAsNewNode, ArrayBuilder`1<BoundInitializer> boundInitializers, DiagnosticBag diagnostics);
    private BoundExpression BindFieldOrPropertyInitializerExpression(VisualBasicSyntaxNode equalsValueOrAsNewSyntax, TypeSymbol targetType, BoundWithLValueExpressionPlaceholder asNewVariablePlaceholderOpt, DiagnosticBag diagnostics);
    private void BindConstFieldInitializer(SourceFieldSymbol fieldSymbol, VisualBasicSyntaxNode equalsValueOrAsNewSyntax, ArrayBuilder`1<BoundInitializer> boundInitializers);
    internal BoundExpression BindFieldAndEnumConstantInitializer(FieldSymbol fieldSymbol, VisualBasicSyntaxNode equalsValueOrAsNewSyntax, bool isEnum, DiagnosticBag diagnostics, ConstantValue& constValue);
    internal BoundExpression BindLocalConstantInitializer(LocalSymbol symbol, TypeSymbol type, ModifiedIdentifierSyntax name, EqualsValueSyntax equalsValueOpt, DiagnosticBag diagnostics, ConstantValue& constValue);
    internal BoundExpression BindParameterDefaultValue(TypeSymbol targetType, EqualsValueSyntax equalsValueSyntax, DiagnosticBag diagnostics, ConstantValue& constValue);
    private BoundExpression BindInterpolatedStringExpression(InterpolatedStringExpressionSyntax syntax, DiagnosticBag diagnostics);
    private BoundLiteral BindInterpolatedStringText(InterpolatedStringTextSyntax syntax, DiagnosticBag diagnostics);
    private BoundInterpolation BindInterpolation(InterpolationSyntax syntax, DiagnosticBag diagnostics);
    private BoundMethodGroup CreateBoundMethodGroup(VisualBasicSyntaxNode node, LookupResult lookupResult, LookupOptions lookupOptionsUsed, BoundExpression receiver, BoundTypeArguments typeArgumentsOpt, QualificationKind qualKind, bool hasError);
    private bool IsConstructorCallAllowed(InvocationExpressionSyntax invocationExpression, BoundMethodOrPropertyGroup boundMemberGroup);
    private BoundExpression BindDirectConstructorCall(InvocationExpressionSyntax node, BoundMethodGroup group, DiagnosticBag diagnostics);
    private BoundExpression BindInvocationExpression(InvocationExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindIndexedInvocationExpression(InvocationExpressionSyntax node, BoundExpression target, ImmutableArray`1<BoundExpression> boundArguments, ImmutableArray`1<string> argumentNames, ImmutableArray`1<Location> argumentNamesLocations, bool allowBindingWithoutArguments, Boolean& hasIndexableTarget, DiagnosticBag diagnostics);
    private BoundExpression BindInvocationExpressionPossiblyWithoutArguments(InvocationExpressionSyntax node, TypeCharacter typeChar, BoundMethodOrPropertyGroup group, ImmutableArray`1<BoundExpression> boundArguments, ImmutableArray`1<string> argumentNames, ImmutableArray`1<Location> argumentNamesLocations, bool allowBindingWithoutArguments, DiagnosticBag diagnostics);
    private BoundExpression BindDefaultPropertyGroup(VisualBasicSyntaxNode node, BoundExpression target, DiagnosticBag diagnostics);
    private bool ShouldBindWithoutArguments(VisualBasicSyntaxNode node, BoundMethodOrPropertyGroup& group, DiagnosticBag diagnostics);
    private bool ShouldBindWithoutArguments(BoundMethodOrPropertyGroup& group, HashSet`1& useSiteDiagnostics);
    private static bool IsGroupOfConstructors(BoundMethodOrPropertyGroup group);
    internal BoundExpression BindInvocationExpression(VisualBasicSyntaxNode node, VisualBasicSyntaxNode target, TypeCharacter typeChar, BoundMethodOrPropertyGroup group, ImmutableArray`1<BoundExpression> boundArguments, ImmutableArray`1<string> argumentNames, DiagnosticBag diagnostics, VisualBasicSyntaxNode callerInfoOpt, bool allowConstructorCall, bool suppressAbstractCallDiagnostics, bool isDefaultMemberAccess, Symbol representCandidateInDiagnosticsOpt, bool forceExpandedForm);
    private BoundExpression CreateBoundCallOrPropertyAccess(VisualBasicSyntaxNode node, VisualBasicSyntaxNode target, TypeCharacter typeChar, BoundMethodOrPropertyGroup group, ImmutableArray`1<BoundExpression> boundArguments, CandidateAnalysisResult bestResult, ImmutableArray`1<BoundExpression> asyncLambdaSubToFunctionMismatch, DiagnosticBag diagnostics, bool suppressAbstractCallDiagnostics);
    internal void WarnOnRecursiveAccess(BoundPropertyAccess propertyAccess, PropertyAccessKind accessKind, DiagnosticBag diagnostics);
    internal void WarnOnRecursiveAccess(BoundExpression node, PropertyAccessKind accessKind, DiagnosticBag diagnostics);
    private BoundExpression UpdateReceiverForExtensionMethodOrPropertyGroup(BoundExpression receiver, TypeSymbol targetType, ParameterSymbol thisParameterDefinition, DiagnosticBag diagnostics);
    private bool IsWellKnownTypeMember(WellKnownMember memberId, MethodSymbol method);
    private ConstantValue OptimizeLibraryCall(MethodSymbol method, ImmutableArray`1<BoundExpression> arguments, VisualBasicSyntaxNode syntax, Boolean& hasErrors, DiagnosticBag diagnostics);
    private BoundExpression ReportOverloadResolutionFailureAndProduceBoundNode(VisualBasicSyntaxNode node, BoundMethodOrPropertyGroup group, ImmutableArray`1<BoundExpression> boundArguments, ImmutableArray`1<string> argumentNames, OverloadResolutionResult& results, DiagnosticBag diagnostics, VisualBasicSyntaxNode callerInfoOpt, TypeSymbol overrideCommonReturnType, bool queryMode, BoundTypeExpression boundTypeExpression, Symbol representCandidateInDiagnosticsOpt, Location diagnosticLocationOpt);
    private BoundExpression ReportOverloadResolutionFailureAndProduceBoundNode(VisualBasicSyntaxNode node, LookupResultKind lookupResult, ImmutableArray`1<BoundExpression> boundArguments, ImmutableArray`1<string> argumentNames, OverloadResolutionResult& results, DiagnosticBag diagnostics, VisualBasicSyntaxNode callerInfoOpt, BoundMethodOrPropertyGroup groupOpt, TypeSymbol overrideCommonReturnType, bool queryMode, BoundTypeExpression boundTypeExpression, Symbol representCandidateInDiagnosticsOpt, Location diagnosticLocationOpt);
    private BoundExpression ReportOverloadResolutionFailureAndProduceBoundNode(VisualBasicSyntaxNode node, BoundMethodOrPropertyGroup group, ArrayBuilder`1<CandidateAnalysisResult> bestCandidates, ImmutableArray`1<Symbol> bestSymbols, TypeSymbol commonReturnType, ImmutableArray`1<BoundExpression> boundArguments, ImmutableArray`1<string> argumentNames, DiagnosticBag diagnostics, VisualBasicSyntaxNode callerInfoOpt, Symbol delegateSymbol, bool queryMode, BoundTypeExpression boundTypeExpression, Symbol representCandidateInDiagnosticsOpt);
    public static Location GetLocationForOverloadResolutionDiagnostic(VisualBasicSyntaxNode node, BoundMethodOrPropertyGroup groupOpt);
    private BoundExpression ReportOverloadResolutionFailureAndProduceBoundNode(VisualBasicSyntaxNode node, LookupResultKind lookupResult, ArrayBuilder`1<CandidateAnalysisResult> bestCandidates, ImmutableArray`1<Symbol> bestSymbols, TypeSymbol commonReturnType, ImmutableArray`1<BoundExpression> boundArguments, ImmutableArray`1<string> argumentNames, DiagnosticBag diagnostics, VisualBasicSyntaxNode callerInfoOpt, BoundMethodOrPropertyGroup groupOpt, Symbol delegateSymbol, bool queryMode, BoundTypeExpression boundTypeExpression, Symbol representCandidateInDiagnosticsOpt, Location diagnosticLocationOpt);
    private static TypeSymbol GetSetOfTheBestCandidates(OverloadResolutionResult& results, ArrayBuilder`1<CandidateAnalysisResult> bestCandidates, ImmutableArray`1& bestSymbols);
    private void ReportUnspecificProcedures(Location diagnosticLocation, ImmutableArray`1<Symbol> bestSymbols, DiagnosticBag diagnostics, bool isDelegateContext);
    private void ReportOverloadResolutionFailureForASetOfCandidates(VisualBasicSyntaxNode node, Location diagnosticLocation, LookupResultKind lookupResult, ERRID errorNo, ArrayBuilder`1<CandidateAnalysisResult> candidates, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNames, DiagnosticBag diagnostics, Symbol delegateSymbol, bool queryMode, VisualBasicSyntaxNode callerInfoOpt);
    private static bool ReportCommonErrorsFromLambdas(ArrayBuilder`1<KeyValuePair`2<Symbol, ImmutableArray`1<Diagnostic>>> diagnosticPerSymbol, ImmutableArray`1<BoundExpression> arguments, DiagnosticBag diagnostics);
    private void ReportOverloadResolutionFailureForASingleCandidate(VisualBasicSyntaxNode node, Location diagnosticLocation, LookupResultKind lookupResult, CandidateAnalysisResult& candidateAnalysisResult, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNames, bool allowUnexpandedParamArrayForm, bool allowExpandedParamArrayForm, bool includeMethodNameInErrorMessages, bool reportNarrowingConversions, DiagnosticBag diagnostics, Symbol delegateSymbol, bool queryMode, VisualBasicSyntaxNode callerInfoOpt, Symbol representCandidateInDiagnosticsOpt);
    private void ReportByRefConversionErrors(Candidate candidate, ParameterSymbol param, BoundExpression argument, TypeSymbol targetType, bool reportNarrowingConversions, DiagnosticBag diagnostics, VisualBasicSyntaxNode diagnosticNode, Symbol delegateSymbol);
    private bool ReportByValConversionErrors(ParameterSymbol param, BoundExpression argument, TypeSymbol targetType, bool reportNarrowingConversions, DiagnosticBag diagnostics, VisualBasicSyntaxNode diagnosticNode, Symbol delegateSymbol);
    private ImmutableArray`1<BoundExpression> PassArguments(VisualBasicSyntaxNode node, CandidateAnalysisResult& candidate, ImmutableArray`1<BoundExpression> arguments, DiagnosticBag diagnostics);
    private BoundExpression PassArgument(BoundExpression argument, KeyValuePair`2<ConversionKind, MethodSymbol> conversionTo, bool forceByValueSemantics, KeyValuePair`2<ConversionKind, MethodSymbol> conversionFrom, TypeSymbol targetType, ParameterSymbol param, DiagnosticBag diagnostics);
    private BoundExpression PassArgumentByRef(bool isOutParameter, BoundExpression argument, KeyValuePair`2<ConversionKind, MethodSymbol> conversionTo, KeyValuePair`2<ConversionKind, MethodSymbol> conversionFrom, TypeSymbol targetType, string parameterName, DiagnosticBag diagnostics);
    private BoundLateInvocation MakeArgsRValues(BoundLateInvocation invocation, DiagnosticBag diagnostics);
    internal BoundExpression PassArgumentByVal(BoundExpression argument, KeyValuePair`2<ConversionKind, MethodSymbol> conversion, TypeSymbol targetType, DiagnosticBag diagnostics);
    private void BindArgumentsAndNames(ArgumentListSyntax argumentListOpt, ImmutableArray`1& boundArguments, ImmutableArray`1& argumentNames, ImmutableArray`1& argumentNamesLocations, DiagnosticBag diagnostics);
    private void BindArgumentsAndNames(ImmutableArray`1<ArgumentSyntax> arguments, ImmutableArray`1& boundArguments, ImmutableArray`1& argumentNames, ImmutableArray`1& argumentNamesLocations, DiagnosticBag diagnostics);
    internal BoundExpression GetArgumentForParameterDefaultValue(ParameterSymbol param, VisualBasicSyntaxNode syntax, DiagnosticBag diagnostics, VisualBasicSyntaxNode callerInfoOpt);
    private static TextSpan GetCallerLocation(VisualBasicSyntaxNode syntax);
    private static bool IsCallStatementContext(InvocationExpressionSyntax node);
    private BoundExpression BindLambdaExpression(LambdaExpressionSyntax node, DiagnosticBag diagnostics);
    internal ImmutableArray`1<BoundLambdaParameterSymbol> BuildBoundLambdaParameters(UnboundLambda source, TargetSignature targetSignature, DiagnosticBag diagnostics);
    internal BoundLambda BindUnboundLambda(UnboundLambda source, TargetSignature target);
    private BoundBlock BindLambdaBody(LambdaSymbol lambdaSymbol, DiagnosticBag diagnostics, LambdaBodyBinder& lambdaBinder);
    public void ReportLambdaParameterInferredToBeObject(UnboundLambdaParameterSymbol unboundParam, DiagnosticBag diagnostics);
    public bool Report_ERRID_ReadOnlyInClosure(BoundExpression argument);
    internal KeyValuePair`2<NamedTypeSymbol, ImmutableArray`1<Diagnostic>> InferAnonymousDelegateForLambda(UnboundLambda source);
    private NamedTypeSymbol ConstructAnonymousDelegateSymbol(UnboundLambda source, ImmutableArray`1<BoundLambdaParameterSymbol> parameters, TypeSymbol returnType, DiagnosticBag diagnostics);
    internal BoundLambda BindLambdaForErrorRecovery(UnboundLambda source);
    private static void BindLambdaForErrorRecoveryInferCommonType(TypeSymbol& result, TypeSymbol candidate);
    internal KeyValuePair`2<TypeSymbol, ImmutableArray`1<Diagnostic>> InferFunctionLambdaReturnType(UnboundLambda source, TargetSignature targetParameters);
    private static VisualBasicSyntaxNode LambdaHeaderErrorNode(UnboundLambda source);
    private BoundExpression BindLateBoundMemberAccess(VisualBasicSyntaxNode node, string name, TypeArgumentListSyntax typeArguments, BoundExpression receiver, TypeSymbol containerType, DiagnosticBag diagnostics);
    private BoundExpression BindLateBoundMemberAccess(VisualBasicSyntaxNode node, string name, BoundTypeArguments boundTypeArguments, BoundExpression receiver, TypeSymbol containerType, DiagnosticBag diagnostics, bool suppressLateBindingResolutionDiagnostics);
    private BoundExpression BindLateBoundInvocation(VisualBasicSyntaxNode node, BoundMethodOrPropertyGroup group, bool isDefaultMemberAccess, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNames, DiagnosticBag diagnostics);
    internal BoundExpression BindLateBoundInvocation(VisualBasicSyntaxNode node, BoundMethodOrPropertyGroup groupOpt, BoundExpression receiver, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNames, DiagnosticBag diagnostics, bool suppressLateBindingResolutionDiagnostics);
    internal void LookupMember(LookupResult lookupResult, NamespaceOrTypeSymbol container, string name, int arity, LookupOptions options, HashSet`1& useSiteDiagnostics);
    internal void LookupMember(LookupResult lookupResult, TypeSymbol container, string name, int arity, LookupOptions options, HashSet`1& useSiteDiagnostics);
    internal void LookupMember(LookupResult lookupResult, NamespaceSymbol container, string name, int arity, LookupOptions options, HashSet`1& useSiteDiagnostics);
    internal void LookupMemberImmediate(LookupResult lookupResult, NamespaceSymbol container, string name, int arity, LookupOptions options, HashSet`1& useSiteDiagnostics);
    internal void LookupExtensionMethods(LookupResult lookupResult, TypeSymbol container, string name, int arity, LookupOptions options, HashSet`1& useSiteDiagnostics);
    internal void LookupMemberInModules(LookupResult lookupResult, NamespaceSymbol container, string name, int arity, LookupOptions options, HashSet`1& useSiteDiagnostics);
    internal void AddMemberLookupSymbolsInfo(LookupSymbolsInfo nameSet, NamespaceOrTypeSymbol container, LookupOptions options);
    internal SingleLookupResult CheckViability(Symbol sym, int arity, LookupOptions options, TypeSymbol accessThroughType, HashSet`1& useSiteDiagnostics);
    internal DiagnosticInfo GetInaccessibleErrorInfo(Symbol sym, HashSet`1& useSiteDiagnostics);
    internal DiagnosticInfo GetInaccessibleErrorInfo(Symbol sym);
    internal bool CanAddLookupSymbolInfo(Symbol sym, LookupOptions options, TypeSymbol accessThroughType);
    private static ERRID WrongArityErrid(int actualArity, int arity);
    private static bool HasSpeakableName(Symbol sym);
    private BoundExpression BindObjectCreationExpression(ObjectCreationExpressionSyntax node, DiagnosticBag diagnostics);
    internal BoundExpression BindObjectCreationExpression(TypeSyntax typeNode, ArgumentListSyntax argumentListOpt, TypeSymbol type0, ObjectCreationExpressionSyntax node, DiagnosticBag diagnostics, BoundWithLValueExpressionPlaceholder asNewVariablePlaceholderOpt);
    internal BoundExpression BindObjectCreationExpression(VisualBasicSyntaxNode syntax, TypeSymbol type, ImmutableArray`1<BoundExpression> arguments, DiagnosticBag diagnostics);
    private ImmutableArray`1<BoundNode> MergeBoundChildNodesWithObjectInitializerForBadNode(ImmutableArray`1<BoundExpression> boundArguments, BoundObjectInitializerExpressionBase objectInitializerExpression);
    private BoundExpression BindObjectCreationExpression(VisualBasicSyntaxNode typeNode, ArgumentListSyntax argumentListOpt, TypeSymbol type0, VisualBasicSyntaxNode node, ImmutableArray`1<BoundExpression> boundArguments, ImmutableArray`1<string> argumentNames, BoundObjectInitializerExpressionBase objectInitializerExpressionOpt, DiagnosticBag diagnostics, VisualBasicSyntaxNode callerInfoOpt);
    private BoundExpression BindNoPiaObjectCreationExpression(VisualBasicSyntaxNode node, TypeSymbol interface, NamedTypeSymbol coClass, ImmutableArray`1<BoundExpression> boundArguments, BoundObjectInitializerExpressionBase initializerOpt, DiagnosticBag diagnostics);
    private BoundObjectInitializerExpressionBase BindObjectCollectionOrMemberInitializer(ObjectCreationExpressionSyntax syntaxNode, TypeSymbol initializedObjectType, BoundWithLValueExpressionPlaceholder asNewVariablePlaceholderOpt, DiagnosticBag diagnostics);
    private BoundObjectInitializerExpression BindObjectInitializer(ObjectCreationExpressionSyntax objectCreationSyntax, TypeSymbol initializedObjectType, BoundWithLValueExpressionPlaceholder asNewVariablePlaceholderOpt, DiagnosticBag diagnostics);
    private BoundCollectionInitializerExpression BindCollectionInitializer(ObjectCreationExpressionSyntax objectCreationSyntax, TypeSymbol initializedObjectType, DiagnosticBag diagnostics);
    private BoundExpression BindCollectionInitializerElement(ExpressionSyntax topLevelInitializer, BoundWithLValueExpressionPlaceholder placeholder, LookupResult result, DiagnosticBag diagnostics);
    private BoundExpression BindIsExpression(BinaryExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindIsExpression(BoundExpression left, BoundExpression right, VisualBasicSyntaxNode node, bool isNot, DiagnosticBag diagnostics);
    private BoundExpression ValidateAndConvertIsExpressionArgument(BoundExpression targetArgument, BoundExpression otherArgument, bool isNot, DiagnosticBag diagnostics);
    private BoundExpression BindBinaryOperator(BinaryExpressionSyntax node, bool isOperandOfConditionalBranch, DiagnosticBag diagnostics);
    private BoundExpression BindBinaryOperator(VisualBasicSyntaxNode node, BoundExpression left, BoundExpression right, SyntaxKind operatorTokenKind, BinaryOperatorKind preliminaryOperatorKind, bool isOperandOfConditionalBranch, DiagnosticBag diagnostics, bool isSelectCase, Int32& compoundStringLength);
    private BoundExpression ForceLiftToEmptyString(BoundExpression left, TypeSymbol stringType, DiagnosticBag diagnostics);
    private BoundUserDefinedBinaryOperator BindUserDefinedNonShortCircuitingBinaryOperator(VisualBasicSyntaxNode node, BinaryOperatorKind opKind, BoundExpression left, BoundExpression right, OverloadResolutionResult& userDefinedOperator, DiagnosticBag diagnostics);
    private BoundUserDefinedShortCircuitingOperator BindUserDefinedShortCircuitingOperator(VisualBasicSyntaxNode node, BinaryOperatorKind opKind, BoundExpression left, BoundExpression right, OverloadResolutionResult& bitwiseOperator, DiagnosticBag diagnostics);
    private void ReportBinaryOperatorOnObject(SyntaxKind operatorTokenKind, BoundExpression operand, BinaryOperatorKind preliminaryOperatorKind, DiagnosticBag diagnostics);
    private TypeSymbol SubstituteDBNullWithNothingString(BoundExpression& dbNullOperand, TypeSymbol otherOperandType, DiagnosticBag diagnostics);
    private TypeSymbol GetSpecialTypeForBinaryOperator(VisualBasicSyntaxNode node, TypeSymbol leftType, TypeSymbol rightType, SpecialType specialType, bool makeNullable, DiagnosticBag diagnostics);
    private TypeSymbol GetNullableTypeForBinaryOperator(TypeSymbol leftType, TypeSymbol rightType, TypeSymbol ofType);
    private static bool IsKnownToBeNullableNothing(BoundExpression expr);
    private void ReportUndefinedOperatorError(VisualBasicSyntaxNode syntax, BoundExpression left, BoundExpression right, SyntaxKind operatorTokenKind, BinaryOperatorKind operatorKind, DiagnosticBag diagnostics);
    private void ConvertNothingLiterals(BinaryOperatorKind operatorKind, BoundExpression& left, BoundExpression& right, DiagnosticBag diagnostics);
    private BoundExpression BindUnaryOperator(UnaryExpressionSyntax node, DiagnosticBag diagnostics);
    private BoundUserDefinedUnaryOperator BindUserDefinedUnaryOperator(VisualBasicSyntaxNode node, UnaryOperatorKind opKind, BoundExpression operand, OverloadResolutionResult& userDefinedOperator, DiagnosticBag diagnostics);
    private void ReportUndefinedOperatorError(UnaryExpressionSyntax syntax, BoundExpression operand, DiagnosticBag diagnostics);
    private SynthesizedLambdaSymbol CreateQueryLambdaSymbol(VisualBasicSyntaxNode syntaxNode, SynthesizedLambdaKind kind, ImmutableArray`1<BoundLambdaParameterSymbol> parameters);
    private static BoundQueryLambda CreateBoundQueryLambda(SynthesizedLambdaSymbol queryLambdaSymbol, ImmutableArray`1<RangeVariableSymbol> rangeVariables, BoundExpression expression, bool exprIsOperandOfConditionalBranch);
    internal virtual BoundExpression BindGroupAggregationExpression(GroupAggregationSyntax group, DiagnosticBag diagnostics);
    internal virtual BoundExpression BindFunctionAggregationExpression(FunctionAggregationSyntax function, DiagnosticBag diagnostics);
    private BoundExpression BindQueryExpression(QueryExpressionSyntax query, DiagnosticBag diagnostics);
    private BoundQueryClauseBase BindSubsequentQueryOperators(BoundQueryClauseBase source, Enumerator<QueryClauseSyntax> operators, DiagnosticBag diagnostics);
    private BoundQueryExpression BindFromQueryExpression(QueryExpressionSyntax query, Enumerator<QueryClauseSyntax> operators, DiagnosticBag diagnostics);
    private BoundQueryExpression BindAggregateQueryExpression(QueryExpressionSyntax query, Enumerator<QueryClauseSyntax> operators, DiagnosticBag diagnostics);
    private BoundAggregateClause BindAggregateClause(BoundQueryClauseBase source, AggregateClauseSyntax aggregate, Enumerator<QueryClauseSyntax> operatorsEnumerator, DiagnosticBag diagnostics);
    private BoundAggregateClause CompleteAggregateClauseBinding(AggregateClauseSyntax aggregate, Enumerator<QueryClauseSyntax> operatorsEnumerator, ImmutableArray`1<RangeVariableSymbol> sourceRangeVariablesPart1, ImmutableArray`1<RangeVariableSymbol> sourceRangeVariablesPart2, BoundExpression firstSelectExpression, QueryLambdaBinder firstSelectSelectorBinder, ImmutableArray`1<RangeVariableSymbol> firstSelectDeclaredRangeVariables, TypeSymbol firstSelectCompoundVariableType, BoundQueryClauseBase group, IntoClauseDisallowGroupReferenceBinder intoBinder, DiagnosticBag diagnostics);
    private BoundQueryClause BindFinalImplicitSelectClause(BoundQueryClauseBase source, DiagnosticBag diagnostics);
    private BoundQueryClause BindSelectClause(BoundQueryClauseBase source, SelectClauseSyntax clauseSyntax, Enumerator<QueryClauseSyntax> operatorsEnumerator, DiagnosticBag diagnostics);
    private static bool ShouldSuppressDiagnostics(BoundQueryLambda lambda);
    private static bool ShadowsRangeVariableInTheChildScope(Binder childScopeBinder, RangeVariableSymbol rangeVar);
    private BoundQueryClause BindLetClause(BoundQueryClauseBase source, LetClauseSyntax clauseSyntax, Enumerator<QueryClauseSyntax> operatorsEnumerator, DiagnosticBag diagnostics, bool skipFirstVariable);
    private static bool MustProduceFlatCompoundVariable(Enumerator<QueryClauseSyntax> operatorsEnumerator);
    private static bool MustProduceFlatCompoundVariable(JoinClauseSyntax groupOrInnerJoin, Enumerator<QueryClauseSyntax> operatorsEnumerator);
    private BoundQueryClauseBase BindFromClause(BoundQueryClauseBase sourceOpt, FromClauseSyntax from, Enumerator& operatorsEnumerator, DiagnosticBag diagnostics);
    private BoundQueryClauseBase BindCollectionRangeVariables(QueryClauseSyntax clauseSyntax, BoundQueryClauseBase sourceOpt, SeparatedSyntaxList`1<CollectionRangeVariableSyntax> variables, Enumerator& operatorsEnumerator, DiagnosticBag diagnostics);
    private static void GetAbsorbingJoinSelectorLambdaKindAndSyntax(QueryClauseSyntax clauseSyntax, QueryClauseSyntax absorbNextOperator, SynthesizedLambdaKind& lambdaKind, VisualBasicSyntaxNode& lambdaSyntax);
    private static QueryClauseSyntax JoinShouldAbsorbNextOperator(Enumerator& operatorsEnumerator);
    private BoundQueryClauseBase AbsorbOperatorFollowingJoin(BoundQueryClause absorbingJoin, QueryClauseSyntax absorbNextOperator, Enumerator<QueryClauseSyntax> operatorsEnumerator, ImmutableArray`1<RangeVariableSymbol> joinSelectorDeclaredRangeVariables, QueryLambdaBinder joinSelectorBinder, ImmutableArray`1<RangeVariableSymbol> leftRangeVariables, ImmutableArray`1<RangeVariableSymbol> rightRangeVariables, BoundQueryClauseBase group, IntoClauseDisallowGroupReferenceBinder intoBinder, DiagnosticBag diagnostics);
    private BoundQueryClauseBase BindInnerJoinClause(BoundQueryClauseBase outer, SimpleJoinClauseSyntax join, HashSet`1<string> declaredNames, Enumerator& operatorsEnumerator, DiagnosticBag diagnostics);
    private static HashSet`1<string> CreateSetOfDeclaredNames();
    private static HashSet`1<string> CreateSetOfDeclaredNames(ImmutableArray`1<RangeVariableSymbol> rangeVariables);
    [ConditionalAttribute("DEBUG")]
private static void AssertDeclaredNames(HashSet`1<string> declaredNames, ImmutableArray`1<RangeVariableSymbol> rangeVariables);
    private BoundQueryClause BindGroupJoinClause(BoundQueryClauseBase outer, GroupJoinClauseSyntax groupJoin, HashSet`1<string> declaredNames, Enumerator<QueryClauseSyntax> operatorsEnumerator, DiagnosticBag diagnostics);
    private BoundQueryClause BindGroupByClause(BoundQueryClauseBase source, GroupByClauseSyntax groupBy, DiagnosticBag diagnostics);
    private static TextSpan GetGroupByOperatorNameSpan(GroupByClauseSyntax groupBy);
    private BoundQueryLambda BindGroupByItems(BoundQueryClauseBase source, GroupByClauseSyntax groupBy, QueryLambdaBinder& itemsLambdaBinder, ImmutableArray`1& itemsRangeVariables, DiagnosticBag diagnostics);
    private BoundQueryLambda BindGroupByKeys(BoundQueryClauseBase source, GroupByClauseSyntax groupBy, QueryLambdaBinder& keysLambdaBinder, ImmutableArray`1& keysRangeVariables, DiagnosticBag diagnostics);
    private TypeSymbol InferGroupType(BoundQueryClauseBase source, GroupByClauseSyntax groupBy, BoundQueryLambda itemsLambda, BoundQueryLambda keysLambda, ImmutableArray`1<RangeVariableSymbol> keysRangeVariables, BoundMethodGroup& methodGroup, DiagnosticBag diagnostics);
    private TypeSymbol InferGroupType(BoundQueryClauseBase outer, BoundQueryClauseBase inner, GroupJoinClauseSyntax groupJoin, BoundQueryLambda outerKeyLambda, BoundQueryLambda innerKeyLambda, BoundMethodGroup& methodGroup, DiagnosticBag diagnostics);
    private BoundQueryLambda BindIntoSelectorLambda(QueryClauseSyntax clauseSyntax, ImmutableArray`1<RangeVariableSymbol> keysRangeVariables, TypeSymbol keysCompoundVariableType, bool addKeysInScope, HashSet`1<string> declaredNames, TypeSymbol groupType, ImmutableArray`1<RangeVariableSymbol> groupRangeVariables, TypeSymbol groupCompoundVariableType, SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables, bool mustProduceFlatCompoundVariable, DiagnosticBag diagnostics, IntoClauseBinder& intoBinder, ImmutableArray`1& intoRangeVariables);
    private void VerifyRangeVariableName(RangeVariableSymbol rangeVar, SyntaxToken identifier, DiagnosticBag diagnostics);
    private VisualBasicSyntaxNode GetQueryLambdaParameterSyntax(VisualBasicSyntaxNode syntaxNode, ImmutableArray`1<RangeVariableSymbol> rangeVariables);
    private BoundLambdaParameterSymbol CreateQueryLambdaParameterSymbol(string name, int ordinal, TypeSymbol type, VisualBasicSyntaxNode syntaxNode, ImmutableArray`1<RangeVariableSymbol> rangeVariables);
    private BoundLambdaParameterSymbol CreateQueryLambdaParameterSymbol(string name, int ordinal, TypeSymbol type, VisualBasicSyntaxNode syntaxNode);
    private static string GetQueryLambdaParameterName(ImmutableArray`1<RangeVariableSymbol> rangeVariables);
    private static string GetQueryLambdaParameterNameLeft(ImmutableArray`1<RangeVariableSymbol> rangeVariables);
    private static string GetQueryLambdaParameterNameRight(ImmutableArray`1<RangeVariableSymbol> rangeVariables);
    private BoundQueryClause BindWhereClause(BoundQueryClauseBase source, WhereClauseSyntax where, DiagnosticBag diagnostics);
    private BoundQueryClause BindSkipWhileClause(BoundQueryClauseBase source, PartitionWhileClauseSyntax skipWhile, DiagnosticBag diagnostics);
    private static TextSpan GetQueryOperatorNameSpan(SyntaxToken& left, SyntaxToken& right);
    private BoundQueryClause BindTakeWhileClause(BoundQueryClauseBase source, PartitionWhileClauseSyntax takeWhile, DiagnosticBag diagnostics);
    private BoundQueryClause BindFilterQueryOperator(BoundQueryClauseBase source, QueryClauseSyntax operatorSyntax, string operatorName, TextSpan operatorNameLocation, ExpressionSyntax condition, DiagnosticBag diagnostics);
    private BoundQueryClause BindDistinctClause(BoundQueryClauseBase source, DistinctClauseSyntax distinct, DiagnosticBag diagnostics);
    private BoundQueryClause BindSkipClause(BoundQueryClauseBase source, PartitionClauseSyntax skip, DiagnosticBag diagnostics);
    private BoundQueryClause BindTakeClause(BoundQueryClauseBase source, PartitionClauseSyntax take, DiagnosticBag diagnostics);
    private BoundQueryClause BindPartitionClause(BoundQueryClauseBase source, PartitionClauseSyntax partition, string operatorName, DiagnosticBag diagnostics);
    private BoundQueryClause BindOrderByClause(BoundQueryClauseBase source, OrderByClauseSyntax orderBy, DiagnosticBag diagnostics);
    private BoundQueryableSource BindCollectionRangeVariable(CollectionRangeVariableSyntax syntax, bool beginsTheQuery, HashSet`1<string> declaredNames, DiagnosticBag diagnostics);
    private BoundQueryPart ApplyImplicitCollectionConversion(CollectionRangeVariableSyntax syntax, BoundQueryPart source, TypeSymbol variableType, TypeSymbol targetVariableType, DiagnosticBag diagnostics);
    private BoundExpression ConvertToQueryableType(BoundExpression source, DiagnosticBag diagnostics, TypeSymbol& controlVariableType);
    private TypeSymbol InferControlVariableType(BoundExpression source, DiagnosticBag diagnostics);
    private TypeSymbol InferControlVariableType(ArrayBuilder`1<Symbol> methods, Boolean& failedDueToAnAmbiguity);
    private TypeSymbol InferControlVariableType(MethodSymbol method);
    private BoundMethodGroup LookupQueryOperator(VisualBasicSyntaxNode node, BoundExpression source, string operatorName, BoundTypeArguments typeArgumentsOpt, DiagnosticBag diagnostics);
    private BoundExpression BindQueryOperatorCall(VisualBasicSyntaxNode node, BoundExpression source, string operatorName, ImmutableArray`1<BoundExpression> arguments, TextSpan operatorNameLocation, DiagnosticBag diagnostics);
    private BoundExpression BindQueryOperatorCall(VisualBasicSyntaxNode node, BoundExpression source, string operatorName, BoundTypeArguments typeArgumentsOpt, ImmutableArray`1<BoundExpression> arguments, TextSpan operatorNameLocation, DiagnosticBag diagnostics);
    private BoundExpression BindQueryOperatorCall(VisualBasicSyntaxNode node, BoundExpression source, string operatorName, BoundMethodGroup methodGroup, ImmutableArray`1<BoundExpression> arguments, TextSpan operatorNameLocation, DiagnosticBag diagnostics);
    private BoundStatement BindSelectBlock(SelectBlockSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindSelectExpression(ExpressionSyntax node, DiagnosticBag diagnostics, BoundRValuePlaceholder& exprPlaceHolderOpt);
    private ImmutableArray`1<BoundCaseBlock> BindCaseBlocks(SyntaxList`1<CaseBlockSyntax> caseBlocks, BoundExpression selectExpression, bool convertCaseElements, Boolean& recommendSwitchTable, DiagnosticBag diagnostics);
    private BoundCaseBlock BindCaseBlock(CaseBlockSyntax node, BoundExpression selectExpression, bool convertCaseElements, DiagnosticBag diagnostics);
    private BoundCaseStatement BindCaseStatement(CaseStatementSyntax node, BoundExpression selectExpression, bool convertCaseElements, DiagnosticBag diagnostics);
    private BoundCaseClause BindCaseClause(CaseClauseSyntax node, BoundExpression selectExpression, bool convertCaseElements, DiagnosticBag diagnostics);
    private BoundCaseClause BindRelationalCaseClause(RelationalCaseClauseSyntax node, BoundExpression selectExpression, bool convertCaseElements, DiagnosticBag diagnostics);
    private BoundCaseClause BindSimpleCaseClause(SimpleCaseClauseSyntax node, BoundExpression selectExpression, bool convertCaseElements, DiagnosticBag diagnostics);
    private BoundCaseClause BindRangeCaseClause(RangeCaseClauseSyntax node, BoundExpression selectExpression, bool convertCaseElements, DiagnosticBag diagnostics);
    private BoundExpression BindCaseClauseExpression(ExpressionSyntax expressionSyntax, CaseClauseSyntax caseClauseSyntax, BoundExpression selectExpression, SyntaxKind operatorTokenKind, BinaryOperatorKind operatorKind, bool convertCaseElements, BoundExpression& conditionOpt, DiagnosticBag diagnostics);
    private ImmutableArray`1<BoundCaseBlock> OptimizeSelectStatement(BoundExpression selectExpression, ArrayBuilder`1<BoundCaseBlock> caseBlockBuilder, Boolean& generateSwitchTable, DiagnosticBag diagnostics);
    private BoundCaseClause ComputeCaseClauseCondition(BoundCaseClause caseClause, BoundExpression& conditionOpt, BoundExpression selectExpression, DiagnosticBag diagnostics);
    private BoundCaseClause ComputeRelationalCaseClauseCondition(BoundRelationalCaseClause boundClause, BoundExpression& conditionOpt, BoundExpression selectExpression, DiagnosticBag diagnostics);
    private BoundCaseClause ComputeSimpleCaseClauseCondition(BoundSimpleCaseClause boundClause, BoundExpression& conditionOpt, BoundExpression selectExpression, DiagnosticBag diagnostics);
    private BoundCaseClause ComputeRangeCaseClauseCondition(BoundRangeCaseClause boundClause, BoundExpression& conditionOpt, BoundExpression selectExpression, DiagnosticBag diagnostics);
    private bool RecommendSwitchTable(BoundExpression selectExpr, ArrayBuilder`1<BoundCaseBlock> caseBlocks, DiagnosticBag diagnostics);
    private bool ReportInvalidSelectCaseRange(ArrayBuilder`1<BoundCaseBlock> caseBlocks, DiagnosticBag diagnostics);
    private bool IsInvalidSelectCaseRange(ConstantValue lbConstantValue, ConstantValue ubConstantValue);
    public virtual BoundStatement BindStatement(StatementSyntax node, DiagnosticBag diagnostics);
    private BoundBlock BindMethodBlock(MethodBlockBaseSyntax methodBlock, DiagnosticBag diagnostics);
    private static void ReportNameConfictsBetweenStaticLocals(Binder methodBlockBinder, DiagnosticBag diagnostics);
    private BoundStatement BindRedimStatement(ReDimStatementSyntax node, DiagnosticBag diagnostics);
    private BoundStatement BindEraseStatement(EraseStatementSyntax node, DiagnosticBag diagnostics);
    private BoundStatement BindGoToStatement(GoToStatementSyntax node, DiagnosticBag diagnostics);
    private bool IsValidLabelForGoto(LabelSymbol label, LabelSyntax labelSyntax, DiagnosticBag diagnostics);
    private bool IsValidBranchTarget(VisualBasicSyntaxNode block, LabelSyntax labelSyntax);
    private BoundStatement BindLabelStatement(LabelStatementSyntax node, DiagnosticBag diagnostics);
    private void DecodeLocalModifiersAndReportErrors(SyntaxTokenList syntax, DiagnosticBag diagBag);
    private BoundStatement BindLocalDeclaration(LocalDeclarationStatementSyntax node, DiagnosticBag diagnostics);
    private ImmutableArray`1<BoundLocalDeclarationBase> BindVariableDeclarators(SeparatedSyntaxList`1<VariableDeclaratorSyntax> declarators, DiagnosticBag diagnostics);
    private LocalSymbol GetLocalForDeclaration(SyntaxToken identifier);
    internal virtual BoundLocalDeclaration BindVariableDeclaration(VisualBasicSyntaxNode tree, ModifiedIdentifierSyntax name, AsClauseSyntax asClauseOpt, EqualsValueSyntax equalsValueOpt, DiagnosticBag diagnostics, bool skipAsNewInitializer);
    internal TypeSymbol ComputeVariableType(LocalSymbol symbol, ModifiedIdentifierSyntax modifiedIdentifierOpt, AsClauseSyntax asClauseOpt, EqualsValueSyntax equalsValueOpt, BoundExpression& valueExpression, TypeSymbol& asClauseType, DiagnosticBag diagnostics);
    internal TypeSymbol InferForFromToVariableType(LocalSymbol symbol, ExpressionSyntax fromValueSyntax, ExpressionSyntax toValueSyntax, ForStepClauseSyntax stepClauseSyntaxOpt, BoundExpression& fromValueExpression, BoundExpression& toValueExpression, BoundExpression& stepValueExpression, DiagnosticBag diagnostics);
    internal TypeSymbol InferForEachVariableType(LocalSymbol symbol, ExpressionSyntax collectionSyntax, BoundExpression& collectionExpression, TypeSymbol& currentType, Boolean& isEnumerable, BoundExpression& boundGetEnumeratorCall, BoundLValuePlaceholder& boundEnumeratorPlaceholder, BoundExpression& boundMoveNextCall, BoundExpression& boundCurrentAccess, BoundRValuePlaceholder& collectionPlaceholder, Boolean& needToDispose, Boolean& isOrInheritsFromOrImplementsIDisposable, DiagnosticBag diagnostics);
    private TypeSymbol InferVariableType(TypeSymbol defaultType, ModifiedIdentifierSyntax name, ExpressionSyntax valueSyntax, TypeSymbol valueType, BoundExpression valueExpression, Func`1<DiagnosticInfo> getRequireTypeDiagnosticInfoFunc, DiagnosticBag diagnostics);
    internal virtual BoundLocal BindCatchVariableDeclaration(IdentifierNameSyntax name, AsClauseSyntax asClause, DiagnosticBag diagnostics);
    private void VerifyLocalSymbolNameAndSetType(LocalSymbol local, TypeSymbol type, VisualBasicSyntaxNode nameSyntax, SyntaxToken identifier, DiagnosticBag diagnostics);
    private void VerifyNameShadowingInMethodBody(Symbol symbol, SyntaxNodeOrToken nameSyntax, SyntaxNodeOrToken identifier, DiagnosticBag diagnostics);
    internal BoundExpression AdjustAssignmentTarget(VisualBasicSyntaxNode node, BoundExpression op1, DiagnosticBag diagnostics, Boolean& isError);
    private BoundAssignmentOperator BindAssignment(VisualBasicSyntaxNode node, BoundExpression op1, BoundExpression op2, DiagnosticBag diagnostics);
    private BoundAssignmentOperator BindCompoundAssignment(VisualBasicSyntaxNode node, BoundExpression left, BoundExpression right, SyntaxKind operatorTokenKind, BinaryOperatorKind operatorKind, DiagnosticBag diagnostics);
    internal BoundBlock BindBlock(VisualBasicSyntaxNode syntax, SyntaxList`1<StatementSyntax> stmtList, DiagnosticBag diagnostics);
    internal BoundBlock BindBlock(VisualBasicSyntaxNode syntax, SyntaxList`1<StatementSyntax> stmtList, DiagnosticBag diagnostics, Binder stmtListBinder);
    private static void DeclareLocal(ArrayBuilder`1& locals, BoundLocalDeclarationBase localDecl);
    private BoundExpressionStatement BindAssignmentStatement(AssignmentStatementSyntax node, DiagnosticBag diagnostics);
    private BoundExpressionStatement BindMidAssignmentStatement(AssignmentStatementSyntax node, DiagnosticBag diagnostics);
    private BoundAddRemoveHandlerStatement BindAddRemoveHandlerStatement(AddRemoveHandlerStatementSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindEventAccess(ExpressionSyntax node, DiagnosticBag diagnostics, BoundEventAccess& actualEventAccess, EventSymbol& eventSymbol);
    private BoundStatement BindRaiseEventStatement(RaiseEventStatementSyntax node, DiagnosticBag diagnostics);
    private BoundStatement BindExpressionStatement(ExpressionStatementSyntax statement, DiagnosticBag diagnostics);
    private void WarnOnUnobservedCallThatReturnsAnAwaitable(ExpressionStatementSyntax statement, BoundExpression boundExpression, DiagnosticBag diagnostics);
    private bool IsOrInheritsFromOrImplementsInterface(TypeSymbol derivedType, WellKnownType interfaceType, HashSet`1& useSiteDiagnostics);
    private BoundStatement BindPrintStatement(PrintStatementSyntax printStmt, DiagnosticBag diagnostics);
    private BoundStatement BindCallStatement(CallStatementSyntax callStmt, DiagnosticBag diagnostics);
    private BoundExpression BindInvocationExpressionAsStatement(ExpressionSyntax expression, DiagnosticBag diagnostics);
    internal BoundExpression ReclassifyInvocationExpressionAsStatement(BoundExpression boundInvocation, DiagnosticBag diagnostics);
    private BoundStatement BindSingleLineIfStatement(SingleLineIfStatementSyntax node, DiagnosticBag diagnostics);
    private BoundStatement BindMultiLineIfBlock(MultiLineIfBlockSyntax node, DiagnosticBag diagnostics);
    private BoundStatement BindDoLoop(DoLoopBlockSyntax node, DiagnosticBag diagnostics);
    private BoundStatement BindWhileBlock(WhileBlockSyntax node, DiagnosticBag diagnostics);
    public BoundStatement BindForToBlock(ForOrForEachBlockSyntax node, DiagnosticBag diagnostics);
    public BoundStatement BindForEachBlock(ForOrForEachBlockSyntax node, DiagnosticBag diagnostics);
    private bool BindForBlockParts(ForOrForEachBlockSyntax node, VisualBasicSyntaxNode controlVariableSyntax, LocalSymbol& declaredOrInferredLocalOpt, BoundExpression& controlVariable, Boolean& isInferredLocal, DiagnosticBag diagnostics);
    private void BindForLoopBodyAndNextControlVariables(ForOrForEachBlockSyntax node, ImmutableArray`1& nextVariables, BoundBlock& loopBody, DiagnosticBag diagnostics);
    private BoundForStatement BindForToBlockParts(ForOrForEachBlockSyntax node, LocalSymbol declaredOrInferredLocalOpt, BoundExpression controlVariableOpt, bool isInferredLocal, bool hasErrors, DiagnosticBag diagnostics);
    private BoundUserDefinedBinaryOperator BindForLoopUserDefinedOperator(VisualBasicSyntaxNode syntax, BinaryOperatorKind opCode, BoundExpression left, BoundExpression right, DiagnosticBag diagnostics);
    private bool IsValidForControlVariableType(ForOrForEachBlockSyntax node, TypeSymbol targetType, DiagnosticBag diagnostics);
    private BoundForEachStatement BindForEachBlockParts(ForOrForEachBlockSyntax node, LocalSymbol declaredOrInferredLocalOpt, BoundExpression controlVariableOpt, bool isInferredLocal, DiagnosticBag diagnostics);
    private bool VerifyForControlVariableDeclaration(VariableDeclaratorSyntax variableDeclarator, DiagnosticBag diagnostics);
    private bool TryBindLoopControlVariable(VisualBasicSyntaxNode controlVariableSyntax, BoundExpression& controlVariable, DiagnosticBag diagnostics);
    private bool VerifyForLoopControlReference(BoundExpression controlVariable, DiagnosticBag diagnostics);
    private BoundExpression InterpretForEachStatementCollection(BoundExpression collection, TypeSymbol& currentType, Boolean& isEnumerable, BoundExpression& boundGetEnumeratorCall, BoundLValuePlaceholder& boundEnumeratorPlaceholder, BoundExpression& boundMoveNextCall, BoundExpression& boundCurrentAccess, BoundRValuePlaceholder& collectionPlaceholder, Boolean& needToDispose, Boolean& isOrInheritsFromOrImplementsIDisposable, DiagnosticBag diagnostics);
    private bool MatchesForEachCollectionDesignPattern(TypeSymbol collectionType, BoundExpression collection, TypeSymbol& currentType, BoundExpression& boundGetEnumeratorCall, BoundLValuePlaceholder& boundEnumeratorPlaceholder, BoundExpression& boundMoveNextCall, BoundExpression& boundCurrentAccess, BoundRValuePlaceholder& collectionPlaceholder, DiagnosticBag temporaryDiagnostics);
    private BoundExpression CreateBoundInvocationExpressionFromMethodOrPropertyGroup(VisualBasicSyntaxNode syntax, BoundMethodOrPropertyGroup methodOrPropertyGroup, DiagnosticBag diagnostics);
    private bool GetMemberIfMatchesRequirements(string name, TypeSymbol container, Func`2<Symbol, bool> symbolChecker, LookupResult result, VisualBasicSyntaxNode syntax, DiagnosticBag diagnostics);
    internal static bool IsOrInheritsFromOrImplementsInterface(TypeSymbol derivedType, NamedTypeSymbol interfaceType, HashSet`1& useSiteDiagnostics, HashSet`1<NamedTypeSymbol> matchingInterfaces);
    public BoundStatement BindWithBlock(WithBlockSyntax node, DiagnosticBag diagnostics);
    protected virtual BoundStatement CreateBoundWithBlock(WithBlockSyntax node, Binder boundBlockBinder, DiagnosticBag diagnostics);
    public BoundStatement BindUsingBlock(UsingBlockSyntax node, DiagnosticBag diagnostics);
    private void VerifyUsingVariableDeclarationAndBuildUsingInfo(VisualBasicSyntaxNode syntaxNode, LocalSymbol localSymbol, TypeSymbol iDisposable, Dictionary`2<TypeSymbol, ValueTuple`3<BoundRValuePlaceholder, BoundExpression, BoundExpression>> placeholderInfo, DiagnosticBag diagnostics);
    private void BuildAndVerifyUsingInfo(VisualBasicSyntaxNode syntaxNode, TypeSymbol resourceType, Dictionary`2<TypeSymbol, ValueTuple`3<BoundRValuePlaceholder, BoundExpression, BoundExpression>> placeholderInfo, TypeSymbol iDisposable, DiagnosticBag diagnostics);
    private void ReportMutableStructureConstraintsInUsing(TypeSymbol type, string symbolName, VisualBasicSyntaxNode syntaxNode, DiagnosticBag diagnostics);
    private bool ShouldReportMutableStructureInUsing(TypeSymbol structureType);
    public BoundSyncLockStatement BindSyncLockBlock(SyncLockBlockSyntax node, DiagnosticBag diagnostics);
    public BoundTryStatement BindTryBlock(TryBlockSyntax node, DiagnosticBag diagnostics);
    public ImmutableArray`1<BoundCatchBlock> BindCatchBlocks(SyntaxList`1<CatchBlockSyntax> catchClauses, DiagnosticBag diagnostics);
    private BoundCatchBlock BindCatchBlock(CatchBlockSyntax node, ArrayBuilder`1<BoundCatchBlock> previousBlocks, DiagnosticBag diagnostics);
    private BoundStatement BindExitStatement(ExitStatementSyntax node, DiagnosticBag diagnostics);
    private BoundStatement BindContinueStatement(ContinueStatementSyntax node, DiagnosticBag diagnostics);
    private BoundExpression BindBooleanExpression(ExpressionSyntax node, DiagnosticBag diagnostics);
    private TypeSymbol GetCurrentReturnType(Boolean& isAsync, Boolean& isIterator, TypeSymbol& methodReturnType);
    private BoundStatement BindReturn(ReturnStatementSyntax originalSyntax, DiagnosticBag diagnostics);
    private TypeSymbol GetCurrentYieldType(YieldStatementSyntax node, DiagnosticBag diagnostics);
    private BoundStatement BindYield(YieldStatementSyntax originalSyntax, DiagnosticBag diagnostics);
    private BoundStatement BindThrow(ThrowStatementSyntax node, DiagnosticBag diagnostics);
    private BoundStatement BindError(ErrorStatementSyntax node, DiagnosticBag diagnostics);
    private BoundResumeStatement BindResumeStatement(ResumeStatementSyntax node, DiagnosticBag diagnostics);
    private BoundOnErrorStatement BindOnErrorStatement(StatementSyntax node, DiagnosticBag diagnostics);
    private BoundStatement BindStopStatement(StopOrEndStatementSyntax stopStatementSyntax);
    private BoundStatement BindEndStatement(StopOrEndStatementSyntax endStatementSyntax, DiagnosticBag diagnostics);
    public TypeSymbol BindTypeSyntax(TypeSyntax typeSyntax, DiagnosticBag diagBag, bool suppressUseSiteError, bool inGetTypeContext, bool resolvingBaseType);
    internal Symbol BindTypeOrAliasSyntax(TypeSyntax typeSyntax, DiagnosticBag diagBag, bool suppressUseSiteError);
    private void ReportUseOfModuleOrVoidType(TypeSyntax typeSyntax, TypeSymbol type, DiagnosticBag diagBag);
    public NamespaceOrTypeSymbol BindNamespaceOrTypeSyntax(TypeSyntax typeSyntax, DiagnosticBag diagBag, bool suppressUseSiteError);
    public Symbol BindNamespaceOrTypeOrAliasSyntax(TypeSyntax typeSyntax, DiagnosticBag diagBag, bool suppressUseSiteError);
    public NamedTypeSymbol ConstructAndValidateConstraints(NamedTypeSymbol genericType, ImmutableArray`1<TypeSymbol> typeArguments, VisualBasicSyntaxNode syntaxWhole, SeparatedSyntaxList`1<TypeSyntax> syntaxArguments, DiagnosticBag diagnostics);
    internal OverloadResolutionResult`1<TMember> ResolveOverloadedMembers(ImmutableArray`1<TMember> members, ImmutableArray`1<TypeSymbol> typeArguments, ImmutableArray`1<ArgumentSyntax> arguments);
    internal bool ReportUseSiteError(DiagnosticBag diagBag, SyntaxNodeOrToken syntax, Symbol symbol);
    internal ImmutableArray`1<MethodSymbol> GetAccessibleConstructors(NamedTypeSymbol type, HashSet`1& useSiteDiagnostics);
    public void DisallowTypeCharacter(SyntaxToken identifier, DiagnosticBag diagBag, ERRID errid);
    public VarianceKind DecodeVariance(SyntaxToken varianceKeywordOpt);
    public static SyntaxToken FindFirstKeyword(SyntaxTokenList syntax, SyntaxKind[] keywordKinds);
    public void ReportModifierError(SyntaxTokenList modifiers, ERRID errid, DiagnosticBag diagBag, SyntaxKind[] keywordKinds);
    internal static SourceMemberFlags MapKeywordToFlag(SyntaxToken syntax);
    public MemberModifiers DecodeModifiers(SyntaxTokenList syntax, SourceMemberFlags allowableModifiers, ERRID errIdBadModifier, Accessibility defaultAccessibility, DiagnosticBag diagBag);
    private static SourceParameterFlags DecodeParameterModifiers(Symbol container, SyntaxTokenList modifiers, CheckParameterModifierDelegate checkModifier, DiagnosticBag diagBag);
    public NamedTypeSymbol CreateNullableOf(TypeSymbol typeArgument, VisualBasicSyntaxNode syntax, VisualBasicSyntaxNode syntaxTypeArgument, DiagnosticBag diagBag);
    public TypeSymbol ApplyArrayRankSpecifiersToType(TypeSymbol elementType, SyntaxList`1<ArrayRankSpecifierSyntax> arrayModifierSyntax, DiagnosticBag diagnostics);
    public TypeSymbol ApplyArrayRankSpecifiersAndBoundsToType(TypeSymbol elementType, SyntaxList`1<ArrayRankSpecifierSyntax> arrayModifierSyntax, ArgumentListSyntax arrayBoundsOpt, DiagnosticBag diagnostics);
    public ArrayTypeSymbol CreateArrayOf(TypeSymbol elementType, SyntaxList`1<ArrayRankSpecifierSyntax> arrayModifierSyntax, ArgumentListSyntax arrayBoundsOpt, DiagnosticBag diagnostics);
    private bool HasDefaultType(SyntaxToken identifierSyntax, AsClauseSyntax asClauseOptSyntax);
    private bool HasDefaultType(ModifiedIdentifierSyntax identifierSyntax, AsClauseSyntax asClauseOptSyntax);
    public bool IsArrayType(ModifiedIdentifierSyntax identifierSyntax);
    public TypeSymbol DecodeModifiedIdentifierType(ModifiedIdentifierSyntax modifiedIdentifier, TypeSymbol asClauseOrValueType, AsClauseSyntax asClauseSyntaxOpt, VisualBasicSyntaxNode initializerSyntaxOpt, Func`1<DiagnosticInfo> getRequireTypeDiagnosticInfoFunc, DiagnosticBag diagBag, ModifiedIdentifierTypeDecoderContext decoderContext);
    public TypeSymbol DecodeModifiedIdentifierType(ModifiedIdentifierSyntax modifiedIdentifier, AsClauseSyntax asClauseOpt, EqualsValueSyntax initializerSyntaxOpt, Func`1<DiagnosticInfo> getRequireTypeDiagnosticInfoFunc, TypeSymbol& asClauseType, DiagnosticBag diagBag, ModifiedIdentifierTypeDecoderContext decoderContext);
    public TypeSymbol DecodeModifiedIdentifierType(ModifiedIdentifierSyntax modifiedIdentifier, AsClauseSyntax asClauseOpt, EqualsValueSyntax initializerSyntaxOpt, Func`1<DiagnosticInfo> getRequireTypeDiagnosticInfoFunc, DiagnosticBag diagBag, ModifiedIdentifierTypeDecoderContext decoderContext);
    public TypeSymbol DecodeIdentifierType(SyntaxToken identifier, AsClauseSyntax asClauseOpt, Func`1<DiagnosticInfo> getRequireTypeDiagnosticInfoFunc, TypeSymbol& asClauseType, DiagnosticBag diagBag);
    public TypeSymbol DecodeIdentifierType(SyntaxToken identifier, AsClauseSyntax asClauseOpt, Func`1<DiagnosticInfo> getRequireTypeDiagnosticInfoFunc, DiagnosticBag diagBag);
    public TypeSymbol DecodeIdentifierType(SyntaxToken identifier, TypeSymbol asClauseType, Func`1<DiagnosticInfo> getRequireTypeDiagnosticInfoFunc, DiagnosticBag diagBag, ModifiedIdentifierTypeDecoderContext decoderContext);
    public static SpecialType GetSpecialTypeForTypeCharacter(TypeCharacter typeChar, String& typeCharacterString);
    public static TypeCharacter ExtractTypeCharacter(VisualBasicSyntaxNode node);
    public bool DecodeOnOff(SyntaxToken keywordSyntax);
    public Nullable`1<bool> DecodeTextBinary(SyntaxToken keywordSyntax);
    public ImmutableArray`1<ParameterSymbol> DecodeParameterListOfDelegateDeclaration(Symbol container, ParameterListSyntax syntaxOpt, DiagnosticBag diagBag);
    public ImmutableArray`1<ParameterSymbol> DecodeParameterList(Symbol container, bool isFromLambda, SourceMemberFlags modifiers, ParameterListSyntax syntaxOpt, DiagnosticBag diagBag);
    private static SourceParameterFlags CheckOperatorParameterModifier(Symbol container, SyntaxToken token, SourceParameterFlags flag, DiagnosticBag diagnostics);
    public ImmutableArray`1<ParameterSymbol> DecodePropertyParameterList(PropertySymbol container, ParameterListSyntax syntaxOpt, DiagnosticBag diagBag);
    private static SourceParameterFlags CheckPropertyParameterModifier(Symbol container, SyntaxToken token, SourceParameterFlags flag, DiagnosticBag diagnostics);
    private static bool CheckReservedParameterName(string reservedName, ParameterSyntax syntax, ERRID errorId, DiagnosticBag diagnostics);
    internal void CheckParameterNameNotDuplicate(ArrayBuilder`1<ParameterSymbol> params, int nParams, ParameterSyntax syntax, ParameterSymbol parameter, DiagnosticBag diagnostics);
    public void DecodeParameterList(Symbol container, bool isFromLambda, SourceMemberFlags modifiers, SeparatedSyntaxList`1<ParameterSyntax> syntax, ArrayBuilder`1<ParameterSymbol> params, CheckParameterModifierDelegate checkModifier, DiagnosticBag diagBag);
    public MemberModifiers ValidateSharedPropertyAndMethodModifiers(SyntaxTokenList modifierList, MemberModifiers memberModifiers, bool isProperty, SourceMemberContainerTypeSymbol container, DiagnosticBag diagBag);
    public MemberModifiers ValidateEventModifiers(SyntaxTokenList modifierList, MemberModifiers memberModifiers, SourceMemberContainerTypeSymbol container, DiagnosticBag diagBag);
    private static TypeBlockSyntax GetContainingTypeBlock(SyntaxToken modifierToken);
    public ConstantValue GetExpressionConstantValueIfAny(BoundExpression boundExpression, DiagnosticBag diagnostics, ConstantContext context);
    private static bool IsNothingLiteralAllowedForAType(TypeSymbol type);
    private ConstantValue CheckConversionForConstantExpression(BoundExpression conv, BoundExpression operand, DiagnosticBag diagnostics, ConstantContext context);
    internal static string GetAccessorName(string name, MethodKind kind, bool isWinMd);
    private BoundExpression BindXmlComment(XmlCommentSyntax syntax, XmlElementRootInfo rootInfoOpt, DiagnosticBag diagnostics);
    private BoundExpression BindXmlDocument(XmlDocumentSyntax syntax, DiagnosticBag diagnostics);
    private BoundExpression BindXmlDeclaration(XmlDeclarationSyntax syntax, DiagnosticBag diagnostics);
    private BoundLiteral BindXmlDeclarationOption(XmlDeclarationSyntax syntax, XmlDeclarationOptionSyntax optionSyntax, DiagnosticBag diagnostics);
    private BoundExpression BindXmlProcessingInstruction(XmlProcessingInstructionSyntax syntax, DiagnosticBag diagnostics);
    private BoundExpression BindXmlEmptyElement(XmlEmptyElementSyntax syntax, XmlElementRootInfo rootInfoOpt, DiagnosticBag diagnostics);
    private BoundExpression BindXmlElement(XmlElementSyntax syntax, XmlElementRootInfo rootInfoOpt, DiagnosticBag diagnostics);
    private BoundExpression BindXmlElement(XmlNodeSyntax syntax, XmlNodeSyntax nameSyntax, SyntaxList`1<XmlNodeSyntax> attributes, SyntaxList`1<XmlNodeSyntax> content, XmlElementRootInfo rootInfoOpt, DiagnosticBag diagnostics);
    private BoundExpression BindXmlElementWithoutAddingNamespaces(XmlNodeSyntax syntax, XmlNodeSyntax nameSyntax, Dictionary`2& allAttributes, ArrayBuilder`1<BoundXmlAttribute> xmlnsAttributes, ArrayBuilder`1<XmlNodeSyntax> otherAttributes, SyntaxList`1<XmlNodeSyntax> content, XmlElementRootInfo rootInfo, DiagnosticBag diagnostics);
    private BoundXmlContainerRewriterInfo BindXmlContainerRewriterInfo(XmlNodeSyntax syntax, BoundExpression objectCreation, ImmutableArray`1<BoundExpression> childNodes, XmlElementRootInfo rootInfoOpt, DiagnosticBag diagnostics);
    private BoundExpression BindRemoveNamespaceAttributesInvocation(VisualBasicSyntaxNode syntax, BoundExpression expr, BoundRValuePlaceholder prefixesPlaceholder, BoundRValuePlaceholder namespacesPlaceholder, BoundRValuePlaceholder& xmlnsAttributesPlaceholder, BoundMethodOrPropertyGroup& removeNamespacesGroup, DiagnosticBag diagnostics);
    private ArrayTypeSymbol CreateArrayType(TypeSymbol elementType);
    private static XmlName GetXmlnsXmlName(string prefix);
    private BoundXmlAttribute BindXmlnsAttribute(XmlNodeSyntax syntax, string prefix, string namespaceName, DiagnosticBag diagnostics);
    private BoundExpression BindXmlnsName(XmlNodeSyntax syntax, string prefix, bool compilerGenerated, DiagnosticBag diagnostics);
    private BoundXmlAttribute BindXmlnsAttribute(XmlNodeSyntax syntax, BoundExpression prefix, BoundExpression namespace, bool useConstructor, bool matchesImport, bool compilerGenerated, bool hasErrors, DiagnosticBag diagnostics);
    private BoundXmlAttribute BindXmlAttribute(XmlAttributeSyntax syntax, XmlElementRootInfo rootInfo, XmlName& xmlName, DiagnosticBag diagnostics);
    private bool MatchesXmlnsImport(string prefix, string namespace);
    private bool MatchesXmlnsImport(XmlNameSyntax name, string value);
    private BoundExpression BindXmlEmbeddedExpression(XmlEmbeddedExpressionSyntax syntax, DiagnosticBag diagnostics);
    private void BindXmlAttributes(Dictionary`2& allAttributes, ArrayBuilder`1<XmlNodeSyntax> attributes, ArrayBuilder`1<BoundExpression> childNodeBuilder, XmlElementRootInfo rootInfo, DiagnosticBag diagnostics);
    private void BindXmlContent(SyntaxList`1<XmlNodeSyntax> content, ArrayBuilder`1<BoundExpression> childNodeBuilder, XmlElementRootInfo rootInfoOpt, DiagnosticBag diagnostics);
    private BoundExpression BindXmlContent(XmlNodeSyntax syntax, XmlElementRootInfo rootInfoOpt, DiagnosticBag diagnostics);
    private BoundExpression BindXmlAttributeAccess(XmlMemberAccessExpressionSyntax syntax, DiagnosticBag diagnostics);
    private BoundExpression BindXmlElementAccess(XmlMemberAccessExpressionSyntax syntax, DiagnosticBag diagnostics);
    private BoundExpression BindXmlDescendantAccess(XmlMemberAccessExpressionSyntax syntax, DiagnosticBag diagnostics);
    private BoundExpression BindXmlElementAccess(XmlMemberAccessExpressionSyntax syntax, string memberName, ERRID typeDisallowsError, DiagnosticBag diagnostics);
    private BoundExpression BindXmlMemberAccessReceiver(XmlMemberAccessExpressionSyntax syntax, DiagnosticBag diagnostics);
    private BoundExpression BindXmlName(XmlNameSyntax syntax, bool forElement, DiagnosticBag diagnostics);
    private BoundExpression BindXmlName(XmlNameSyntax syntax, bool forElement, XmlElementRootInfo rootInfoOpt, Boolean& fromImports, String& prefix, String& localName, String& namespace, DiagnosticBag diagnostics);
    private static void AddImportedNamespaceIfNecessary(ArrayBuilder`1<KeyValuePair`2<string, string>> importedNamespaces, string prefix, string namespace, bool forElement);
    private BoundExpression BindXmlName(VisualBasicSyntaxNode syntax, BoundExpression localName, BoundExpression namespace, DiagnosticBag diagnostics);
    private BoundExpression BindGetXmlNamespace(GetXmlNamespaceExpressionSyntax syntax, DiagnosticBag diagnostics);
    private BoundExpression BindXmlNamespace(VisualBasicSyntaxNode syntax, BoundExpression namespace, DiagnosticBag diagnostics);
    private BoundBadExpression ReportXmlNamespacePrefixNotDefined(VisualBasicSyntaxNode syntax, SyntaxToken prefixToken, string prefix, bool compilerGenerated, DiagnosticBag diagnostics);
    private BoundExpression BindXmlCData(XmlCDataSectionSyntax syntax, XmlElementRootInfo rootInfoOpt, DiagnosticBag diagnostics);
    private BoundLiteral BindXmlText(XmlTextSyntax syntax, DiagnosticBag diagnostics);
    internal static string GetXmlString(SyntaxTokenList tokens);
    private static string GetXmlString(SyntaxToken token);
    private BoundMethodOrPropertyGroup GetXmlMethodOrPropertyGroup(VisualBasicSyntaxNode syntax, NamedTypeSymbol type, string memberName, BoundExpression receiverOpt, DiagnosticBag diagnostics);
    private BoundExpression BindInvocationExpressionIfGroupNotNothing(VisualBasicSyntaxNode syntax, BoundMethodOrPropertyGroup groupOpt, ImmutableArray`1<BoundExpression> arguments, DiagnosticBag diagnostics);
    private DiagnosticBag CheckXmlFeaturesAllowed(VisualBasicSyntaxNode syntax, DiagnosticBag diagnostics);
    private BoundLiteral CreateStringLiteral(VisualBasicSyntaxNode syntax, string str, bool compilerGenerated, DiagnosticBag diagnostics, bool hasErrors);
    private Dictionary`2<string, string> BindXmlnsAttributes(SyntaxList`1<XmlNodeSyntax> attributes, Dictionary`2& allAttributes, ArrayBuilder`1<BoundXmlAttribute> xmlnsAttributes, ArrayBuilder`1<XmlNodeSyntax> otherAttributes, ArrayBuilder`1<KeyValuePair`2<string, string>> importedNamespaces, DiagnosticBag diagnostics);
    private bool AddXmlAttributeIfNotDuplicate(XmlNodeSyntax syntax, XmlName name, BoundXmlAttribute attribute, Dictionary`2& allAttributes, DiagnosticBag diagnostics);
    private bool TryGetXmlnsAttribute(XmlAttributeSyntax syntax, String& prefix, String& namespaceName, BoundExpression& namespace, Boolean& hasErrors, bool fromImport, DiagnosticBag diagnostics);
    private static bool RedefinesReservedXmlNamespace(VisualBasicSyntaxNode syntax, string prefix, string reservedPrefix, string namespace, string reservedNamespace, DiagnosticBag diagnostics);
    private bool TryGetXmlnsPrefix(XmlNameSyntax syntax, String& prefix, DiagnosticBag diagnostics);
    private static string GetXmlName(SyntaxToken token);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BinderBuilder : object {
    public static Binder CreateBinderForSourceFileImports(SourceModuleSymbol moduleSymbol, SyntaxTree tree);
    public static Binder CreateBinderForProjectImports(SourceModuleSymbol moduleSymbol, SyntaxTree tree);
    private static Binder CreateBinderForSourceFile(SourceModuleSymbol moduleSymbol, SyntaxTree tree);
    public static Binder CreateBinderForProjectLevelNamespace(SourceModuleSymbol moduleSymbol, SyntaxTree tree);
    public static NamespaceBinder CreateBinderForNamespace(SourceModuleSymbol moduleSymbol, SyntaxTree tree, NamespaceSymbol nsSymbol);
    public static Binder CreateBinderForType(SourceModuleSymbol moduleSymbol, SyntaxTree tree, NamedTypeSymbol typeSymbol);
    public static AttributeBinder CreateBinderForAttribute(SourceModuleSymbol moduleSymbol, SyntaxTree tree, Symbol target);
    public static AttributeBinder CreateBinderForAttribute(SyntaxTree tree, Binder containingBinder, VisualBasicSyntaxNode node);
    public static Binder CreateBinderForParameterDefaultValue(SourceModuleSymbol moduleSymbol, SyntaxTree tree, ParameterSymbol parameterSymbol, VisualBasicSyntaxNode node);
    public static Binder CreateBinderForParameterDefaultValue(ParameterSymbol parameterSymbol, Binder containingBinder, VisualBasicSyntaxNode node);
    public static Binder CreateBinderForDocumentationComment(Binder containingBinder, Symbol commentedSymbol, BinderType binderType);
    public static Binder CreateBinderForMethodDeclaration(MethodSymbol methodSymbol, Binder containingBinder);
    public static Binder CreateBinderForGenericMethodDeclaration(SourceMethodSymbol methodSymbol, Binder containingBinder);
    public static Binder CreateBinderForMethodDeclaration(SourceModuleSymbol moduleSymbol, SyntaxTree tree, SourceMethodSymbol methodSymbol);
    public static Binder CreateBinderForMethodBody(MethodSymbol methodSymbol, VisualBasicSyntaxNode root, Binder containingBinder);
    public static Binder CreateBinderForMethodBody(SourceModuleSymbol moduleSymbol, SyntaxTree tree, SourceMethodSymbol methodSymbol);
    public static Binder CreateBinderForInitializer(Binder containingBinder, Symbol fieldOrProperty);
    public static Binder CreateSourceModuleBinder(SourceModuleSymbol moduleSymbol);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BinderFactory : object {
    private SourceModuleSymbol _sourceModule;
    private SyntaxTree _tree;
    private ConcurrentDictionary`2<ValueTuple`2<VisualBasicSyntaxNode, byte>, Binder> _cache;
    private ObjectPool`1<BinderFactoryVisitor> _binderFactoryVisitorPool;
    private bool InScript { get; }
    public BinderFactory(SourceModuleSymbol sourceModule, SyntaxTree tree);
    private bool get_InScript();
    private Binder MakeBinder(VisualBasicSyntaxNode node, int position);
    public Binder GetNamespaceBinder(NamespaceBlockSyntax node);
    public Binder GetNamedTypeBinder(TypeStatementSyntax node);
    public Binder GetNamedTypeBinder(EnumStatementSyntax node);
    public Binder GetNamedTypeBinder(DelegateStatementSyntax node);
    public Binder GetBinderForPosition(VisualBasicSyntaxNode node, int position);
    private Binder GetBinderAtOrAbove(VisualBasicSyntaxNode node, int position);
    private Binder GetBinderForNodeAndUsage(VisualBasicSyntaxNode node, NodeUsage usage, VisualBasicSyntaxNode parentNode, int position, Binder containingBinder);
    private Binder CreateBinderForNodeAndUsage(VisualBasicSyntaxNode node, NodeUsage usage, Binder containingBinder);
    private Binder CreateDocumentationCommentBinder(DocumentationCommentTriviaSyntax node, BinderType binderType);
    private NamedTypeBinder GetContainingNamedTypeBinderForMemberNode(VisualBasicSyntaxNode node, Binder containingBinder);
    private static NamedTypeSymbol GetParameterDeclarationContainingType(Binder containingBinder);
    private NamespaceBinder BuildNamespaceBinder(NamespaceBinder containingBinder, NameSyntax childName, bool globalNamespaceAllowed);
    private Binder BuildMethodBinder(NamedTypeBinder containingBinder, MethodBaseSyntax methodSyntax, bool forBody);
    private Binder BuildInitializerBinder(Binder containingBinder, Symbol fieldOrProperty);
    private Binder BuildAttributeBinder(Binder containingBinder, VisualBasicSyntaxNode node);
    [CompilerGeneratedAttribute]
private BinderFactoryVisitor _Lambda$__8-0();
}
internal enum Microsoft.CodeAnalysis.VisualBasic.BindingLocation : Enum {
    public int value__;
    public static BindingLocation None;
    public static BindingLocation BaseTypes;
    public static BindingLocation MethodSignature;
    public static BindingLocation GenericConstraintsClause;
    public static BindingLocation ProjectImportsDeclaration;
    public static BindingLocation SourceFileImportsDeclaration;
    public static BindingLocation Attribute;
    public static BindingLocation EventSignature;
    public static BindingLocation FieldType;
    public static BindingLocation HandlesClause;
    public static BindingLocation PropertySignature;
    public static BindingLocation PropertyAccessorSignature;
    public static BindingLocation EventAccessorSignature;
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BlockBaseBinder : BlockBaseBinder`1<LocalSymbol> {
    public BlockBaseBinder(Binder enclosing);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BlockBaseBinder`1 : Binder {
    private Dictionary`2<string, T> _lazyLocalsMap;
    internal ImmutableArray`1<T> Locals { get; }
    private Dictionary`2<string, T> LocalsMap { get; }
    public BlockBaseBinder`1(Binder enclosing);
    internal abstract virtual ImmutableArray`1<T> get_Locals();
    private Dictionary`2<string, T> get_LocalsMap();
    private Dictionary`2<string, T> BuildMap(ImmutableArray`1<T> locals);
    internal virtual void LookupInSingleBinder(LookupResult lookupResult, string name, int arity, LookupOptions options, Binder originalBinder, HashSet`1& useSiteDiagnostics);
    internal virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundAddHandlerStatement : BoundAddRemoveHandlerStatement {
    protected IOperation IExpressionStatement_Expression { get; }
    public BoundAddHandlerStatement(VisualBasicSyntaxNode syntax, BoundExpression eventAccess, BoundExpression handler, bool hasErrors);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundAddHandlerStatement Update(BoundExpression eventAccess, BoundExpression handler);
    protected virtual IOperation get_IExpressionStatement_Expression();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundAddRemoveHandlerStatement : BoundStatement {
    private BoundExpression _EventAccess;
    private BoundExpression _Handler;
    protected static ConditionalWeakTable`2<BoundAddRemoveHandlerStatement, IEventAssignmentExpression> s_expressionsMappings;
    public BoundExpression EventAccess { get; }
    public BoundExpression Handler { get; }
    protected IOperation IExpressionStatement_Expression { get; }
    private static BoundAddRemoveHandlerStatement();
    protected BoundAddRemoveHandlerStatement(BoundKind kind, VisualBasicSyntaxNode syntax, BoundExpression eventAccess, BoundExpression handler, bool hasErrors);
    public BoundExpression get_EventAccess();
    public BoundExpression get_Handler();
    protected virtual OperationKind StatementKind();
    protected abstract virtual override IOperation get_IExpressionStatement_Expression();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundAddressOfOperator : BoundExpression {
    private Binder _Binder;
    private BoundMethodGroup _MethodGroup;
    private ConcurrentDictionary`2<TypeSymbol, DelegateResolutionResult> _delegateResolutionResultCache;
    public Binder Binder { get; }
    public BoundMethodGroup MethodGroup { get; }
    public BoundAddressOfOperator(VisualBasicSyntaxNode syntax, Binder binder, BoundMethodGroup methodGroup, bool hasErrors);
    public Binder get_Binder();
    public BoundMethodGroup get_MethodGroup();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundAddressOfOperator Update(Binder binder, BoundMethodGroup methodGroup);
    internal bool GetDelegateResolutionResult(TypeSymbol targetType, DelegateResolutionResult& delegateResolutionResult);
    internal ConversionKind GetConversionClassification(TypeSymbol targetType);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundAggregateClause : BoundQueryClauseBase {
    private BoundQueryClauseBase _CapturedGroupOpt;
    private BoundRValuePlaceholder _GroupPlaceholderOpt;
    private BoundExpression _UnderlyingExpression;
    public BoundQueryClauseBase CapturedGroupOpt { get; }
    public BoundRValuePlaceholder GroupPlaceholderOpt { get; }
    public BoundExpression UnderlyingExpression { get; }
    public Symbol ExpressionSymbol { get; }
    public LookupResultKind ResultKind { get; }
    public BoundAggregateClause(VisualBasicSyntaxNode syntax, BoundQueryClauseBase capturedGroupOpt, BoundRValuePlaceholder groupPlaceholderOpt, BoundExpression underlyingExpression, ImmutableArray`1<RangeVariableSymbol> rangeVariables, TypeSymbol compoundVariableType, ImmutableArray`1<Binder> binders, TypeSymbol type, bool hasErrors);
    public BoundQueryClauseBase get_CapturedGroupOpt();
    public BoundRValuePlaceholder get_GroupPlaceholderOpt();
    public BoundExpression get_UnderlyingExpression();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundAggregateClause Update(BoundQueryClauseBase capturedGroupOpt, BoundRValuePlaceholder groupPlaceholderOpt, BoundExpression underlyingExpression, ImmutableArray`1<RangeVariableSymbol> rangeVariables, TypeSymbol compoundVariableType, ImmutableArray`1<Binder> binders, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    public virtual LookupResultKind get_ResultKind();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundAnonymousTypeCreationExpression : BoundExpression {
    private AnonymousTypeCreationBinder _BinderOpt;
    private ImmutableArray`1<BoundAnonymousTypePropertyAccess> _Declarations;
    private ImmutableArray`1<BoundExpression> _Arguments;
    public AnonymousTypeCreationBinder BinderOpt { get; }
    public ImmutableArray`1<BoundAnonymousTypePropertyAccess> Declarations { get; }
    public ImmutableArray`1<BoundExpression> Arguments { get; }
    public Symbol ExpressionSymbol { get; }
    public BoundAnonymousTypeCreationExpression(VisualBasicSyntaxNode syntax, AnonymousTypeCreationBinder binderOpt, ImmutableArray`1<BoundAnonymousTypePropertyAccess> declarations, ImmutableArray`1<BoundExpression> arguments, TypeSymbol type, bool hasErrors);
    public AnonymousTypeCreationBinder get_BinderOpt();
    public ImmutableArray`1<BoundAnonymousTypePropertyAccess> get_Declarations();
    public ImmutableArray`1<BoundExpression> get_Arguments();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundAnonymousTypeCreationExpression Update(AnonymousTypeCreationBinder binderOpt, ImmutableArray`1<BoundAnonymousTypePropertyAccess> declarations, ImmutableArray`1<BoundExpression> arguments, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundAnonymousTypeFieldInitializer : BoundExpression {
    private AnonymousTypeFieldInitializerBinder _Binder;
    private BoundExpression _Value;
    public AnonymousTypeFieldInitializerBinder Binder { get; }
    public BoundExpression Value { get; }
    public BoundAnonymousTypeFieldInitializer(VisualBasicSyntaxNode syntax, AnonymousTypeFieldInitializerBinder binder, BoundExpression value, TypeSymbol type, bool hasErrors);
    public AnonymousTypeFieldInitializerBinder get_Binder();
    public BoundExpression get_Value();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundAnonymousTypeFieldInitializer Update(AnonymousTypeFieldInitializerBinder binder, BoundExpression value, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundAnonymousTypePropertyAccess : BoundExpression {
    private AnonymousTypeCreationBinder _Binder;
    private int _PropertyIndex;
    private Lazy`1<PropertySymbol> _lazyPropertySymbol;
    public AnonymousTypeCreationBinder Binder { get; }
    public int PropertyIndex { get; }
    public Symbol ExpressionSymbol { get; }
    public BoundAnonymousTypePropertyAccess(VisualBasicSyntaxNode syntax, AnonymousTypeCreationBinder binder, int propertyIndex, TypeSymbol type, bool hasErrors);
    public BoundAnonymousTypePropertyAccess(VisualBasicSyntaxNode syntax, AnonymousTypeCreationBinder binder, int propertyIndex, TypeSymbol type);
    public AnonymousTypeCreationBinder get_Binder();
    public int get_PropertyIndex();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundAnonymousTypePropertyAccess Update(AnonymousTypeCreationBinder binder, int propertyIndex, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    private PropertySymbol LazyGetProperty();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundArrayAccess : BoundExpression {
    private BoundExpression _Expression;
    private ImmutableArray`1<BoundExpression> _Indices;
    private bool _IsLValue;
    public BoundExpression Expression { get; }
    public ImmutableArray`1<BoundExpression> Indices { get; }
    public bool IsLValue { get; }
    private IOperation IArrayElementReferenceExpression_ArrayReference { get; }
    private ImmutableArray`1<IOperation> IArrayElementReferenceExpression_Indices { get; }
    public BoundArrayAccess(VisualBasicSyntaxNode syntax, BoundExpression expression, ImmutableArray`1<BoundExpression> indices, bool isLValue, TypeSymbol type, bool hasErrors);
    public BoundArrayAccess(VisualBasicSyntaxNode syntax, BoundExpression expression, ImmutableArray`1<BoundExpression> indices, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Expression();
    public ImmutableArray`1<BoundExpression> get_Indices();
    public virtual bool get_IsLValue();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundArrayAccess Update(BoundExpression expression, ImmutableArray`1<BoundExpression> indices, bool isLValue, TypeSymbol type);
    protected virtual BoundExpression MakeRValueImpl();
    public BoundArrayAccess MakeRValue();
    private sealed virtual override IOperation get_IArrayElementReferenceExpression_ArrayReference();
    private sealed virtual override ImmutableArray`1<IOperation> get_IArrayElementReferenceExpression_Indices();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundArrayCreation : BoundExpression {
    private bool _IsParamArrayArgument;
    private ImmutableArray`1<BoundExpression> _Bounds;
    private BoundArrayInitialization _InitializerOpt;
    private BoundArrayLiteral _ArrayLiteralOpt;
    private ConversionKind _ArrayLiteralConversion;
    public bool IsParamArrayArgument { get; }
    public ImmutableArray`1<BoundExpression> Bounds { get; }
    public BoundArrayInitialization InitializerOpt { get; }
    public BoundArrayLiteral ArrayLiteralOpt { get; }
    public ConversionKind ArrayLiteralConversion { get; }
    private ImmutableArray`1<IOperation> IArrayCreationExpression_DimensionSizes { get; }
    private ITypeSymbol IArrayCreationExpression_ElementType { get; }
    private IArrayInitializer IArrayCreationExpression_Initializer { get; }
    public BoundArrayCreation(VisualBasicSyntaxNode syntax, bool isParamArrayArgument, ImmutableArray`1<BoundExpression> bounds, BoundArrayInitialization initializerOpt, BoundArrayLiteral arrayLiteralOpt, ConversionKind arrayLiteralConversion, TypeSymbol type, bool hasErrors);
    public BoundArrayCreation(VisualBasicSyntaxNode syntax, ImmutableArray`1<BoundExpression> bounds, BoundArrayInitialization initializerOpt, TypeSymbol type, bool hasErrors);
    public BoundArrayCreation(VisualBasicSyntaxNode syntax, ImmutableArray`1<BoundExpression> bounds, BoundArrayInitialization initializerOpt, BoundArrayLiteral arrayLiteralOpt, ConversionKind arrayLiteralConversion, TypeSymbol type, bool hasErrors);
    public bool get_IsParamArrayArgument();
    public ImmutableArray`1<BoundExpression> get_Bounds();
    public BoundArrayInitialization get_InitializerOpt();
    public BoundArrayLiteral get_ArrayLiteralOpt();
    public ConversionKind get_ArrayLiteralConversion();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundArrayCreation Update(bool isParamArrayArgument, ImmutableArray`1<BoundExpression> bounds, BoundArrayInitialization initializerOpt, BoundArrayLiteral arrayLiteralOpt, ConversionKind arrayLiteralConversion, TypeSymbol type);
    private sealed virtual override ImmutableArray`1<IOperation> get_IArrayCreationExpression_DimensionSizes();
    private sealed virtual override ITypeSymbol get_IArrayCreationExpression_ElementType();
    private sealed virtual override IArrayInitializer get_IArrayCreationExpression_Initializer();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundArrayInitialization : BoundExpression {
    private ImmutableArray`1<BoundExpression> _Initializers;
    public ImmutableArray`1<BoundExpression> Initializers { get; }
    private ImmutableArray`1<IOperation> IArrayInitializer_ElementValues { get; }
    public BoundArrayInitialization(VisualBasicSyntaxNode syntax, ImmutableArray`1<BoundExpression> initializers, TypeSymbol type, bool hasErrors);
    public ImmutableArray`1<BoundExpression> get_Initializers();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundArrayInitialization Update(ImmutableArray`1<BoundExpression> initializers, TypeSymbol type);
    private sealed virtual override ImmutableArray`1<IOperation> get_IArrayInitializer_ElementValues();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundArrayLength : BoundExpression {
    private BoundExpression _Expression;
    public BoundExpression Expression { get; }
    public BoundArrayLength(VisualBasicSyntaxNode syntax, BoundExpression expression, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Expression();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundArrayLength Update(BoundExpression expression, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundArrayLiteral : BoundExpression {
    private bool _HasDominantType;
    private int _NumberOfCandidates;
    private ArrayTypeSymbol _InferredType;
    private ImmutableArray`1<BoundExpression> _Bounds;
    private BoundArrayInitialization _Initializer;
    private Binder _Binder;
    public bool HasDominantType { get; }
    public int NumberOfCandidates { get; }
    public ArrayTypeSymbol InferredType { get; }
    public ImmutableArray`1<BoundExpression> Bounds { get; }
    public BoundArrayInitialization Initializer { get; }
    public Binder Binder { get; }
    public bool IsEmptyArrayLiteral { get; }
    public BoundArrayLiteral(VisualBasicSyntaxNode syntax, bool hasDominantType, int numberOfCandidates, ArrayTypeSymbol inferredType, ImmutableArray`1<BoundExpression> bounds, BoundArrayInitialization initializer, Binder binder, bool hasErrors);
    public bool get_HasDominantType();
    public int get_NumberOfCandidates();
    public ArrayTypeSymbol get_InferredType();
    public ImmutableArray`1<BoundExpression> get_Bounds();
    public BoundArrayInitialization get_Initializer();
    public Binder get_Binder();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundArrayLiteral Update(bool hasDominantType, int numberOfCandidates, ArrayTypeSymbol inferredType, ImmutableArray`1<BoundExpression> bounds, BoundArrayInitialization initializer, Binder binder);
    public bool get_IsEmptyArrayLiteral();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundAsNewLocalDeclarations : BoundLocalDeclarationBase {
    private ImmutableArray`1<BoundLocalDeclaration> _LocalDeclarations;
    private BoundExpression _Initializer;
    public ImmutableArray`1<BoundLocalDeclaration> LocalDeclarations { get; }
    public BoundExpression Initializer { get; }
    public BoundAsNewLocalDeclarations(VisualBasicSyntaxNode syntax, ImmutableArray`1<BoundLocalDeclaration> localDeclarations, BoundExpression initializer, bool hasErrors);
    public ImmutableArray`1<BoundLocalDeclaration> get_LocalDeclarations();
    public BoundExpression get_Initializer();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundAsNewLocalDeclarations Update(ImmutableArray`1<BoundLocalDeclaration> localDeclarations, BoundExpression initializer);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundAssignmentOperator : BoundExpression {
    private BoundExpression _Left;
    private BoundCompoundAssignmentTargetPlaceholder _LeftOnTheRightOpt;
    private BoundExpression _Right;
    private bool _SuppressObjectClone;
    public BoundExpression Left { get; }
    public BoundCompoundAssignmentTargetPlaceholder LeftOnTheRightOpt { get; }
    public BoundExpression Right { get; }
    public bool SuppressObjectClone { get; }
    private IOperation IAssignmentExpression_Target { get; }
    private IOperation IAssignmentExpression_Value { get; }
    private BinaryOperationKind ICompoundAssignmentExpression_BinaryOperationKind { get; }
    private IMethodSymbol IHasOperatorMethodExpression_OperatorMethod { get; }
    private bool IHasOperatorMethodExpression_UsesOperatorMethod { get; }
    public BoundAssignmentOperator(VisualBasicSyntaxNode syntax, BoundExpression left, BoundCompoundAssignmentTargetPlaceholder leftOnTheRightOpt, BoundExpression right, bool suppressObjectClone, TypeSymbol type, bool hasErrors);
    public BoundAssignmentOperator(VisualBasicSyntaxNode syntax, BoundExpression left, BoundExpression right, bool suppressObjectClone, TypeSymbol type, bool hasErrors);
    public BoundAssignmentOperator(VisualBasicSyntaxNode syntax, BoundExpression left, BoundExpression right, bool suppressObjectClone, bool hasErrors);
    public BoundAssignmentOperator(VisualBasicSyntaxNode syntax, BoundExpression left, BoundCompoundAssignmentTargetPlaceholder leftOnTheRightOpt, BoundExpression right, bool suppressObjectClone, bool hasErrors);
    public BoundExpression get_Left();
    public BoundCompoundAssignmentTargetPlaceholder get_LeftOnTheRightOpt();
    public BoundExpression get_Right();
    public bool get_SuppressObjectClone();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundAssignmentOperator Update(BoundExpression left, BoundCompoundAssignmentTargetPlaceholder leftOnTheRightOpt, BoundExpression right, bool suppressObjectClone, TypeSymbol type);
    private sealed virtual override IOperation get_IAssignmentExpression_Target();
    private sealed virtual override IOperation get_IAssignmentExpression_Value();
    private sealed virtual override BinaryOperationKind get_ICompoundAssignmentExpression_BinaryOperationKind();
    private sealed virtual override IMethodSymbol get_IHasOperatorMethodExpression_OperatorMethod();
    private sealed virtual override bool get_IHasOperatorMethodExpression_UsesOperatorMethod();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundAttribute : BoundExpression {
    private MethodSymbol _Constructor;
    private ImmutableArray`1<BoundExpression> _ConstructorArguments;
    private ImmutableArray`1<BoundExpression> _NamedArguments;
    private LookupResultKind _ResultKind;
    public MethodSymbol Constructor { get; }
    public ImmutableArray`1<BoundExpression> ConstructorArguments { get; }
    public ImmutableArray`1<BoundExpression> NamedArguments { get; }
    public LookupResultKind ResultKind { get; }
    public Symbol ExpressionSymbol { get; }
    public BoundAttribute(VisualBasicSyntaxNode syntax, MethodSymbol constructor, ImmutableArray`1<BoundExpression> constructorArguments, ImmutableArray`1<BoundExpression> namedArguments, LookupResultKind resultKind, TypeSymbol type, bool hasErrors);
    public MethodSymbol get_Constructor();
    public ImmutableArray`1<BoundExpression> get_ConstructorArguments();
    public ImmutableArray`1<BoundExpression> get_NamedArguments();
    public virtual LookupResultKind get_ResultKind();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundAttribute Update(MethodSymbol constructor, ImmutableArray`1<BoundExpression> constructorArguments, ImmutableArray`1<BoundExpression> namedArguments, LookupResultKind resultKind, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundAwaitOperator : BoundExpression {
    private BoundExpression _Operand;
    private BoundRValuePlaceholder _AwaitableInstancePlaceholder;
    private BoundExpression _GetAwaiter;
    private BoundLValuePlaceholder _AwaiterInstancePlaceholder;
    private BoundExpression _IsCompleted;
    private BoundExpression _GetResult;
    public BoundExpression Operand { get; }
    public BoundRValuePlaceholder AwaitableInstancePlaceholder { get; }
    public BoundExpression GetAwaiter { get; }
    public BoundLValuePlaceholder AwaiterInstancePlaceholder { get; }
    public BoundExpression IsCompleted { get; }
    public BoundExpression GetResult { get; }
    private IOperation IAwaitExpression_AwaitedValue { get; }
    public BoundAwaitOperator(VisualBasicSyntaxNode syntax, BoundExpression operand, BoundRValuePlaceholder awaitableInstancePlaceholder, BoundExpression getAwaiter, BoundLValuePlaceholder awaiterInstancePlaceholder, BoundExpression isCompleted, BoundExpression getResult, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Operand();
    public BoundRValuePlaceholder get_AwaitableInstancePlaceholder();
    public BoundExpression get_GetAwaiter();
    public BoundLValuePlaceholder get_AwaiterInstancePlaceholder();
    public BoundExpression get_IsCompleted();
    public BoundExpression get_GetResult();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundAwaitOperator Update(BoundExpression operand, BoundRValuePlaceholder awaitableInstancePlaceholder, BoundExpression getAwaiter, BoundLValuePlaceholder awaiterInstancePlaceholder, BoundExpression isCompleted, BoundExpression getResult, TypeSymbol type);
    private sealed virtual override IOperation get_IAwaitExpression_AwaitedValue();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundBadExpression : BoundExpression {
    private LookupResultKind _ResultKind;
    private ImmutableArray`1<Symbol> _Symbols;
    private ImmutableArray`1<BoundNode> _ChildBoundNodes;
    public LookupResultKind ResultKind { get; }
    public ImmutableArray`1<Symbol> Symbols { get; }
    public ImmutableArray`1<BoundNode> ChildBoundNodes { get; }
    public BoundBadExpression(VisualBasicSyntaxNode syntax, LookupResultKind resultKind, ImmutableArray`1<Symbol> symbols, ImmutableArray`1<BoundNode> childBoundNodes, TypeSymbol type, bool hasErrors);
    public virtual LookupResultKind get_ResultKind();
    public ImmutableArray`1<Symbol> get_Symbols();
    public ImmutableArray`1<BoundNode> get_ChildBoundNodes();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundBadExpression Update(LookupResultKind resultKind, ImmutableArray`1<Symbol> symbols, ImmutableArray`1<BoundNode> childBoundNodes, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundBadStatement : BoundStatement {
    private ImmutableArray`1<BoundNode> _ChildBoundNodes;
    public ImmutableArray`1<BoundNode> ChildBoundNodes { get; }
    public BoundBadStatement(VisualBasicSyntaxNode syntax, ImmutableArray`1<BoundNode> childBoundNodes, bool hasErrors);
    public ImmutableArray`1<BoundNode> get_ChildBoundNodes();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundBadStatement Update(ImmutableArray`1<BoundNode> childBoundNodes);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundBadVariable : BoundExpression {
    private BoundExpression _Expression;
    private bool _IsLValue;
    public BoundExpression Expression { get; }
    public bool IsLValue { get; }
    public LookupResultKind ResultKind { get; }
    public BoundBadVariable(VisualBasicSyntaxNode syntax, BoundExpression expression, bool isLValue, TypeSymbol type, bool hasErrors);
    public BoundBadVariable(VisualBasicSyntaxNode syntax, BoundExpression expression, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Expression();
    public virtual bool get_IsLValue();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundBadVariable Update(BoundExpression expression, bool isLValue, TypeSymbol type);
    protected virtual BoundExpression MakeRValueImpl();
    public BoundBadVariable MakeRValue();
    public virtual LookupResultKind get_ResultKind();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundBinaryConditionalExpression : BoundExpression {
    private BoundExpression _TestExpression;
    private BoundExpression _ConvertedTestExpression;
    private BoundRValuePlaceholder _TestExpressionPlaceholder;
    private BoundExpression _ElseExpression;
    private ConstantValue _ConstantValueOpt;
    public BoundExpression TestExpression { get; }
    public BoundExpression ConvertedTestExpression { get; }
    public BoundRValuePlaceholder TestExpressionPlaceholder { get; }
    public BoundExpression ElseExpression { get; }
    public ConstantValue ConstantValueOpt { get; }
    private IOperation INullCoalescingExpression_PrimaryOperand { get; }
    private IOperation INullCoalescingExpression_SecondaryOperand { get; }
    public BoundBinaryConditionalExpression(VisualBasicSyntaxNode syntax, BoundExpression testExpression, BoundExpression convertedTestExpression, BoundRValuePlaceholder testExpressionPlaceholder, BoundExpression elseExpression, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors);
    public BoundExpression get_TestExpression();
    public BoundExpression get_ConvertedTestExpression();
    public BoundRValuePlaceholder get_TestExpressionPlaceholder();
    public BoundExpression get_ElseExpression();
    public virtual ConstantValue get_ConstantValueOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundBinaryConditionalExpression Update(BoundExpression testExpression, BoundExpression convertedTestExpression, BoundRValuePlaceholder testExpressionPlaceholder, BoundExpression elseExpression, ConstantValue constantValueOpt, TypeSymbol type);
    private sealed virtual override IOperation get_INullCoalescingExpression_PrimaryOperand();
    private sealed virtual override IOperation get_INullCoalescingExpression_SecondaryOperand();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundBinaryOperator : BoundExpression {
    private BinaryOperatorKind _OperatorKind;
    private BoundExpression _Left;
    private BoundExpression _Right;
    private bool _Checked;
    private ConstantValue _ConstantValueOpt;
    public BinaryOperatorKind OperatorKind { get; }
    public BoundExpression Left { get; }
    public BoundExpression Right { get; }
    public bool Checked { get; }
    public ConstantValue ConstantValueOpt { get; }
    public Symbol ExpressionSymbol { get; }
    private IOperation IBinaryOperatorExpression_LeftOperand { get; }
    private BinaryOperationKind IBinaryOperatorExpression_BinaryOperationKind { get; }
    private IOperation IBinaryOperatorExpression_RightOperand { get; }
    private IMethodSymbol IHasOperatorMethodExpression_OperatorMethod { get; }
    private bool IHasOperatorMethodExpression_UsesOperatorMethod { get; }
    public BoundBinaryOperator(VisualBasicSyntaxNode syntax, BinaryOperatorKind operatorKind, BoundExpression left, BoundExpression right, bool checked, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors);
    public BoundBinaryOperator(VisualBasicSyntaxNode syntax, BinaryOperatorKind operatorKind, BoundExpression left, BoundExpression right, bool checked, TypeSymbol type, bool hasErrors);
    public BinaryOperatorKind get_OperatorKind();
    public BoundExpression get_Left();
    public BoundExpression get_Right();
    public bool get_Checked();
    public virtual ConstantValue get_ConstantValueOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundBinaryOperator Update(BinaryOperatorKind operatorKind, BoundExpression left, BoundExpression right, bool checked, ConstantValue constantValueOpt, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    private sealed virtual override IOperation get_IBinaryOperatorExpression_LeftOperand();
    private sealed virtual override BinaryOperationKind get_IBinaryOperatorExpression_BinaryOperationKind();
    private sealed virtual override IOperation get_IBinaryOperatorExpression_RightOperand();
    private sealed virtual override IMethodSymbol get_IHasOperatorMethodExpression_OperatorMethod();
    private sealed virtual override bool get_IHasOperatorMethodExpression_UsesOperatorMethod();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundBlock : BoundStatement {
    private SyntaxList`1<StatementSyntax> _StatementListSyntax;
    private ImmutableArray`1<LocalSymbol> _Locals;
    private ImmutableArray`1<BoundStatement> _Statements;
    private static ConditionalWeakTable`2<BoundBlock, object> s_blockStatementsMappings;
    public SyntaxList`1<StatementSyntax> StatementListSyntax { get; }
    public ImmutableArray`1<LocalSymbol> Locals { get; }
    public ImmutableArray`1<BoundStatement> Statements { get; }
    private ImmutableArray`1<ILocalSymbol> IBlockStatement_Locals { get; }
    private ImmutableArray`1<IOperation> IBlockStatement_Statements { get; }
    private static BoundBlock();
    public BoundBlock(VisualBasicSyntaxNode syntax, SyntaxList`1<StatementSyntax> statementListSyntax, ImmutableArray`1<LocalSymbol> locals, ImmutableArray`1<BoundStatement> statements, bool hasErrors);
    public SyntaxList`1<StatementSyntax> get_StatementListSyntax();
    public ImmutableArray`1<LocalSymbol> get_Locals();
    public ImmutableArray`1<BoundStatement> get_Statements();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundBlock Update(SyntaxList`1<StatementSyntax> statementListSyntax, ImmutableArray`1<LocalSymbol> locals, ImmutableArray`1<BoundStatement> statements);
    private sealed virtual override ImmutableArray`1<ILocalSymbol> get_IBlockStatement_Locals();
    private sealed virtual override ImmutableArray`1<IOperation> get_IBlockStatement_Statements();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundByRefArgumentPlaceholder : BoundValuePlaceholderBase {
    private bool _IsOut;
    public bool IsOut { get; }
    public BoundByRefArgumentPlaceholder(VisualBasicSyntaxNode syntax, bool isOut, TypeSymbol type, bool hasErrors);
    public BoundByRefArgumentPlaceholder(VisualBasicSyntaxNode syntax, bool isOut, TypeSymbol type);
    public bool get_IsOut();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundByRefArgumentPlaceholder Update(bool isOut, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundByRefArgumentWithCopyBack : BoundExpression {
    private BoundExpression _OriginalArgument;
    private BoundExpression _InConversion;
    private BoundByRefArgumentPlaceholder _InPlaceholder;
    private BoundExpression _OutConversion;
    private BoundRValuePlaceholder _OutPlaceholder;
    public BoundExpression OriginalArgument { get; }
    public BoundExpression InConversion { get; }
    public BoundByRefArgumentPlaceholder InPlaceholder { get; }
    public BoundExpression OutConversion { get; }
    public BoundRValuePlaceholder OutPlaceholder { get; }
    public BoundByRefArgumentWithCopyBack(VisualBasicSyntaxNode syntax, BoundExpression originalArgument, BoundExpression inConversion, BoundByRefArgumentPlaceholder inPlaceholder, BoundExpression outConversion, BoundRValuePlaceholder outPlaceholder, TypeSymbol type, bool hasErrors);
    public BoundExpression get_OriginalArgument();
    public BoundExpression get_InConversion();
    public BoundByRefArgumentPlaceholder get_InPlaceholder();
    public BoundExpression get_OutConversion();
    public BoundRValuePlaceholder get_OutPlaceholder();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundByRefArgumentWithCopyBack Update(BoundExpression originalArgument, BoundExpression inConversion, BoundByRefArgumentPlaceholder inPlaceholder, BoundExpression outConversion, BoundRValuePlaceholder outPlaceholder, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundCall : BoundExpression {
    private MethodSymbol _Method;
    private BoundMethodGroup _MethodGroupOpt;
    private BoundExpression _ReceiverOpt;
    private ImmutableArray`1<BoundExpression> _Arguments;
    private ConstantValue _ConstantValueOpt;
    private bool _SuppressObjectClone;
    private static ConditionalWeakTable`2<BoundExpression, IArgument> s_argumentMappings;
    public MethodSymbol Method { get; }
    public BoundMethodGroup MethodGroupOpt { get; }
    public BoundExpression ReceiverOpt { get; }
    public ImmutableArray`1<BoundExpression> Arguments { get; }
    public ConstantValue ConstantValueOpt { get; }
    public bool SuppressObjectClone { get; }
    public Symbol ExpressionSymbol { get; }
    public LookupResultKind ResultKind { get; }
    private ImmutableArray`1<IArgument> IInvocationExpression_ArgumentsInSourceOrder { get; }
    private ImmutableArray`1<IArgument> IHasArgumentsExpression_ArgumentsInParameterOrder { get; }
    private bool IInvocationExpression_IsVirtual { get; }
    private IMethodSymbol IInvocationExpression_TargetMethod { get; }
    private IOperation IInvocationExpression_Instance { get; }
    private static BoundCall();
    public BoundCall(VisualBasicSyntaxNode syntax, MethodSymbol method, BoundMethodGroup methodGroupOpt, BoundExpression receiverOpt, ImmutableArray`1<BoundExpression> arguments, ConstantValue constantValueOpt, bool suppressObjectClone, TypeSymbol type, bool hasErrors);
    public BoundCall(VisualBasicSyntaxNode syntax, MethodSymbol method, BoundMethodGroup methodGroup, BoundExpression receiver, ImmutableArray`1<BoundExpression> arguments, ConstantValue constantValueOpt, TypeSymbol type, bool suppressObjectClone, bool hasErrors);
    public MethodSymbol get_Method();
    public BoundMethodGroup get_MethodGroupOpt();
    public BoundExpression get_ReceiverOpt();
    public ImmutableArray`1<BoundExpression> get_Arguments();
    public virtual ConstantValue get_ConstantValueOpt();
    public bool get_SuppressObjectClone();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundCall Update(MethodSymbol method, BoundMethodGroup methodGroupOpt, BoundExpression receiverOpt, ImmutableArray`1<BoundExpression> arguments, ConstantValue constantValueOpt, bool suppressObjectClone, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    public virtual LookupResultKind get_ResultKind();
    private sealed virtual override IArgument IHasArgumentsExpression_GetArgumentMatchingParameter(IParameterSymbol parameter);
    private sealed virtual override ImmutableArray`1<IArgument> get_IInvocationExpression_ArgumentsInSourceOrder();
    private sealed virtual override ImmutableArray`1<IArgument> get_IHasArgumentsExpression_ArgumentsInParameterOrder();
    private sealed virtual override bool get_IInvocationExpression_IsVirtual();
    private sealed virtual override IMethodSymbol get_IInvocationExpression_TargetMethod();
    private sealed virtual override IOperation get_IInvocationExpression_Instance();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    internal static IArgument ArgumentMatchingParameter(ImmutableArray`1<BoundExpression> arguments, IParameterSymbol parameter, ImmutableArray`1<ParameterSymbol> parameters);
    internal static ImmutableArray`1<IArgument> DeriveArguments(ImmutableArray`1<BoundExpression> boundArguments, ImmutableArray`1<ParameterSymbol> parameters);
    private static IArgument DeriveArgument(int index, BoundExpression argument, ImmutableArray`1<ParameterSymbol> parameters);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundCaseBlock : BoundStatement {
    private BoundCaseStatement _CaseStatement;
    private BoundBlock _Body;
    public BoundCaseStatement CaseStatement { get; }
    public BoundBlock Body { get; }
    public BoundCaseBlock(VisualBasicSyntaxNode syntax, BoundCaseStatement caseStatement, BoundBlock body, bool hasErrors);
    public BoundCaseStatement get_CaseStatement();
    public BoundBlock get_Body();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundCaseBlock Update(BoundCaseStatement caseStatement, BoundBlock body);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundCaseClause : BoundNode {
    private bool IOperation_IsInvalid { get; }
    private SyntaxNode IOperation_Syntax { get; }
    protected OperationKind IOperation_Kind { get; }
    protected CaseKind ICaseClause_CaseKind { get; }
    private ITypeSymbol IType { get; }
    private Optional`1<object> IOperation_ConstantValue { get; }
    protected BoundCaseClause(BoundKind kind, VisualBasicSyntaxNode syntax, bool hasErrors);
    protected BoundCaseClause(BoundKind kind, VisualBasicSyntaxNode syntax);
    private sealed virtual override bool get_IOperation_IsInvalid();
    private sealed virtual override SyntaxNode get_IOperation_Syntax();
    protected abstract virtual override OperationKind get_IOperation_Kind();
    protected abstract virtual override CaseKind get_ICaseClause_CaseKind();
    public abstract virtual override void Accept(OperationVisitor visitor);
    public abstract virtual override TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    private sealed virtual override ITypeSymbol get_IType();
    private sealed virtual override Optional`1<object> get_IOperation_ConstantValue();
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundCaseStatement : BoundStatement {
    private ImmutableArray`1<BoundCaseClause> _CaseClauses;
    private BoundExpression _ConditionOpt;
    public ImmutableArray`1<BoundCaseClause> CaseClauses { get; }
    public BoundExpression ConditionOpt { get; }
    public BoundCaseStatement(VisualBasicSyntaxNode syntax, ImmutableArray`1<BoundCaseClause> caseClauses, BoundExpression conditionOpt, bool hasErrors);
    public ImmutableArray`1<BoundCaseClause> get_CaseClauses();
    public BoundExpression get_ConditionOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundCaseStatement Update(ImmutableArray`1<BoundCaseClause> caseClauses, BoundExpression conditionOpt);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundCatchBlock : BoundNode {
    private LocalSymbol _LocalOpt;
    private BoundExpression _ExceptionSourceOpt;
    private BoundExpression _ErrorLineNumberOpt;
    private BoundExpression _ExceptionFilterOpt;
    private BoundBlock _Body;
    private bool _IsSynthesizedAsyncCatchAll;
    public LocalSymbol LocalOpt { get; }
    public BoundExpression ExceptionSourceOpt { get; }
    public BoundExpression ErrorLineNumberOpt { get; }
    public BoundExpression ExceptionFilterOpt { get; }
    public BoundBlock Body { get; }
    public bool IsSynthesizedAsyncCatchAll { get; }
    private ITypeSymbol ICatchClause_CaughtType { get; }
    private IOperation ICatchClause_Filter { get; }
    private IBlockStatement ICatchClause_Handler { get; }
    private ILocalSymbol ICatchClause_ExceptionLocal { get; }
    private OperationKind IOperation_Kind { get; }
    private bool IOperation_IsInvalid { get; }
    private SyntaxNode IOperation_Syntax { get; }
    private ITypeSymbol IOperation_Type { get; }
    private Optional`1<object> IOperation_ConstantValue { get; }
    public BoundCatchBlock(VisualBasicSyntaxNode syntax, LocalSymbol localOpt, BoundExpression exceptionSourceOpt, BoundExpression errorLineNumberOpt, BoundExpression exceptionFilterOpt, BoundBlock body, bool isSynthesizedAsyncCatchAll, bool hasErrors);
    public LocalSymbol get_LocalOpt();
    public BoundExpression get_ExceptionSourceOpt();
    public BoundExpression get_ErrorLineNumberOpt();
    public BoundExpression get_ExceptionFilterOpt();
    public BoundBlock get_Body();
    public bool get_IsSynthesizedAsyncCatchAll();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundCatchBlock Update(LocalSymbol localOpt, BoundExpression exceptionSourceOpt, BoundExpression errorLineNumberOpt, BoundExpression exceptionFilterOpt, BoundBlock body, bool isSynthesizedAsyncCatchAll);
    private sealed virtual override ITypeSymbol get_ICatchClause_CaughtType();
    private sealed virtual override IOperation get_ICatchClause_Filter();
    private sealed virtual override IBlockStatement get_ICatchClause_Handler();
    private sealed virtual override ILocalSymbol get_ICatchClause_ExceptionLocal();
    private sealed virtual override OperationKind get_IOperation_Kind();
    private sealed virtual override bool get_IOperation_IsInvalid();
    private sealed virtual override SyntaxNode get_IOperation_Syntax();
    private sealed virtual override ITypeSymbol get_IOperation_Type();
    private sealed virtual override Optional`1<object> get_IOperation_ConstantValue();
    public sealed virtual override void Accept(OperationVisitor visitor);
    public sealed virtual override TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundCollectionInitializerExpression : BoundObjectInitializerExpressionBase {
    public BoundCollectionInitializerExpression(VisualBasicSyntaxNode syntax, BoundWithLValueExpressionPlaceholder placeholderOpt, ImmutableArray`1<BoundExpression> initializers, TypeSymbol type, bool hasErrors);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundCollectionInitializerExpression Update(BoundWithLValueExpressionPlaceholder placeholderOpt, ImmutableArray`1<BoundExpression> initializers, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundComplexConditionalAccessReceiver : BoundExpression {
    private BoundExpression _ValueTypeReceiver;
    private BoundExpression _ReferenceTypeReceiver;
    public BoundExpression ValueTypeReceiver { get; }
    public BoundExpression ReferenceTypeReceiver { get; }
    public BoundComplexConditionalAccessReceiver(VisualBasicSyntaxNode syntax, BoundExpression valueTypeReceiver, BoundExpression referenceTypeReceiver, TypeSymbol type, bool hasErrors);
    public BoundExpression get_ValueTypeReceiver();
    public BoundExpression get_ReferenceTypeReceiver();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundComplexConditionalAccessReceiver Update(BoundExpression valueTypeReceiver, BoundExpression referenceTypeReceiver, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundCompoundAssignmentTargetPlaceholder : BoundValuePlaceholderBase {
    public BoundCompoundAssignmentTargetPlaceholder(VisualBasicSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    public BoundCompoundAssignmentTargetPlaceholder(VisualBasicSyntaxNode syntax, TypeSymbol type);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundCompoundAssignmentTargetPlaceholder Update(TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundConditionalAccess : BoundExpression {
    private BoundExpression _Receiver;
    private BoundRValuePlaceholder _Placeholder;
    private BoundExpression _AccessExpression;
    public BoundExpression Receiver { get; }
    public BoundRValuePlaceholder Placeholder { get; }
    public BoundExpression AccessExpression { get; }
    private IOperation IConditionalAccessExpression_ConditionalValue { get; }
    private IOperation IConditionalAccessExpression_ConditionalInstance { get; }
    public BoundConditionalAccess(VisualBasicSyntaxNode syntax, BoundExpression receiver, BoundRValuePlaceholder placeholder, BoundExpression accessExpression, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Receiver();
    public BoundRValuePlaceholder get_Placeholder();
    public BoundExpression get_AccessExpression();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundConditionalAccess Update(BoundExpression receiver, BoundRValuePlaceholder placeholder, BoundExpression accessExpression, TypeSymbol type);
    private sealed virtual override IOperation get_IConditionalAccessExpression_ConditionalValue();
    private sealed virtual override IOperation get_IConditionalAccessExpression_ConditionalInstance();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundConditionalAccessReceiverPlaceholder : BoundRValuePlaceholderBase {
    private int _PlaceholderId;
    public int PlaceholderId { get; }
    public BoundConditionalAccessReceiverPlaceholder(VisualBasicSyntaxNode syntax, int placeholderId, TypeSymbol type, bool hasErrors);
    public BoundConditionalAccessReceiverPlaceholder(VisualBasicSyntaxNode syntax, int placeholderId, TypeSymbol type);
    public int get_PlaceholderId();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundConditionalAccessReceiverPlaceholder Update(int placeholderId, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundConditionalGoto : BoundStatement {
    private BoundExpression _Condition;
    private bool _JumpIfTrue;
    private LabelSymbol _Label;
    public BoundExpression Condition { get; }
    public bool JumpIfTrue { get; }
    public LabelSymbol Label { get; }
    public BoundConditionalGoto(VisualBasicSyntaxNode syntax, BoundExpression condition, bool jumpIfTrue, LabelSymbol label, bool hasErrors);
    public BoundExpression get_Condition();
    public bool get_JumpIfTrue();
    public LabelSymbol get_Label();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundConditionalGoto Update(BoundExpression condition, bool jumpIfTrue, LabelSymbol label);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundContinueStatement : BoundStatement {
    private LabelSymbol _Label;
    public LabelSymbol Label { get; }
    private ILabelSymbol IBranchStatement_Target { get; }
    private BranchKind IBranchStatement_BranchKind { get; }
    public BoundContinueStatement(VisualBasicSyntaxNode syntax, LabelSymbol label, bool hasErrors);
    public BoundContinueStatement(VisualBasicSyntaxNode syntax, LabelSymbol label);
    public LabelSymbol get_Label();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundContinueStatement Update(LabelSymbol label);
    private sealed virtual override ILabelSymbol get_IBranchStatement_Target();
    private sealed virtual override BranchKind get_IBranchStatement_BranchKind();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundConversion : BoundExpression {
    private BoundExpression _Operand;
    private ConversionKind _ConversionKind;
    private bool _Checked;
    private bool _ExplicitCastInCode;
    private ConstantValue _ConstantValueOpt;
    private MethodSymbol _ConstructorOpt;
    private BoundLambda _RelaxationLambdaOpt;
    private BoundRValuePlaceholder _RelaxationReceiverPlaceholderOpt;
    public BoundExpression Operand { get; }
    public ConversionKind ConversionKind { get; }
    public bool Checked { get; }
    public bool ExplicitCastInCode { get; }
    public ConstantValue ConstantValueOpt { get; }
    public MethodSymbol ConstructorOpt { get; }
    public BoundLambda RelaxationLambdaOpt { get; }
    public BoundRValuePlaceholder RelaxationReceiverPlaceholderOpt { get; }
    public Symbol ExpressionSymbol { get; }
    private ConversionKind IConversionExpression_ConversionKind { get; }
    private bool IConversionExpression_IsExplicit { get; }
    private IOperation IConversinExpression_Operand { get; }
    private IMethodSymbol IHasOperatorMethodExpression_OperatorMethod { get; }
    private bool IHasOperatorMethodExpression_UsesOperatorMethod { get; }
    public BoundConversion(VisualBasicSyntaxNode syntax, BoundExpression operand, ConversionKind conversionKind, bool checked, bool explicitCastInCode, ConstantValue constantValueOpt, MethodSymbol constructorOpt, BoundLambda relaxationLambdaOpt, BoundRValuePlaceholder relaxationReceiverPlaceholderOpt, TypeSymbol type, bool hasErrors);
    public BoundConversion(VisualBasicSyntaxNode syntax, BoundExpression operand, ConversionKind conversionKind, bool checked, bool explicitCastInCode, TypeSymbol type, bool hasErrors);
    public BoundConversion(VisualBasicSyntaxNode syntax, BoundExpression operand, ConversionKind conversionKind, bool checked, bool explicitCastInCode, BoundLambda relaxationLambdaOpt, TypeSymbol type, bool hasErrors);
    public BoundConversion(VisualBasicSyntaxNode syntax, BoundExpression operand, ConversionKind conversionKind, bool checked, bool explicitCastInCode, BoundLambda relaxationLambdaOpt, BoundRValuePlaceholder RelaxationReceiverPlaceholderOpt, TypeSymbol type, bool hasErrors);
    public BoundConversion(VisualBasicSyntaxNode syntax, BoundExpression operand, ConversionKind conversionKind, bool checked, bool explicitCastInCode, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors);
    public BoundConversion(VisualBasicSyntaxNode syntax, BoundExpression operand, ConversionKind conversionKind, bool checked, bool explicitCastInCode, ConstantValue constantValueOpt, MethodSymbol constructorOpt, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Operand();
    public ConversionKind get_ConversionKind();
    public bool get_Checked();
    public bool get_ExplicitCastInCode();
    public virtual ConstantValue get_ConstantValueOpt();
    public MethodSymbol get_ConstructorOpt();
    public BoundLambda get_RelaxationLambdaOpt();
    public BoundRValuePlaceholder get_RelaxationReceiverPlaceholderOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundConversion Update(BoundExpression operand, ConversionKind conversionKind, bool checked, bool explicitCastInCode, ConstantValue constantValueOpt, MethodSymbol constructorOpt, BoundLambda relaxationLambdaOpt, BoundRValuePlaceholder relaxationReceiverPlaceholderOpt, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    private sealed virtual override ConversionKind get_IConversionExpression_ConversionKind();
    private sealed virtual override bool get_IConversionExpression_IsExplicit();
    private sealed virtual override IOperation get_IConversinExpression_Operand();
    private sealed virtual override IMethodSymbol get_IHasOperatorMethodExpression_OperatorMethod();
    private sealed virtual override bool get_IHasOperatorMethodExpression_UsesOperatorMethod();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundDelegateCreationExpression : BoundExpression {
    private BoundExpression _ReceiverOpt;
    private MethodSymbol _Method;
    private BoundLambda _RelaxationLambdaOpt;
    private BoundRValuePlaceholder _RelaxationReceiverPlaceholderOpt;
    private BoundMethodGroup _MethodGroupOpt;
    public BoundExpression ReceiverOpt { get; }
    public MethodSymbol Method { get; }
    public BoundLambda RelaxationLambdaOpt { get; }
    public BoundRValuePlaceholder RelaxationReceiverPlaceholderOpt { get; }
    public BoundMethodGroup MethodGroupOpt { get; }
    private IOperation IMemberReferenceExpression_Instance { get; }
    private bool IMethodBindingExpression_IsVirtual { get; }
    private ISymbol IMemberReferenceExpression_Member { get; }
    private IMethodSymbol IMethodBindingExpression_Method { get; }
    public BoundDelegateCreationExpression(VisualBasicSyntaxNode syntax, BoundExpression receiverOpt, MethodSymbol method, BoundLambda relaxationLambdaOpt, BoundRValuePlaceholder relaxationReceiverPlaceholderOpt, BoundMethodGroup methodGroupOpt, TypeSymbol type, bool hasErrors);
    public BoundExpression get_ReceiverOpt();
    public MethodSymbol get_Method();
    public BoundLambda get_RelaxationLambdaOpt();
    public BoundRValuePlaceholder get_RelaxationReceiverPlaceholderOpt();
    public BoundMethodGroup get_MethodGroupOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundDelegateCreationExpression Update(BoundExpression receiverOpt, MethodSymbol method, BoundLambda relaxationLambdaOpt, BoundRValuePlaceholder relaxationReceiverPlaceholderOpt, BoundMethodGroup methodGroupOpt, TypeSymbol type);
    private sealed virtual override IOperation get_IMemberReferenceExpression_Instance();
    private sealed virtual override bool get_IMethodBindingExpression_IsVirtual();
    private sealed virtual override ISymbol get_IMemberReferenceExpression_Member();
    private sealed virtual override IMethodSymbol get_IMethodBindingExpression_Method();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundDimStatement : BoundStatement {
    private ImmutableArray`1<BoundLocalDeclarationBase> _LocalDeclarations;
    private BoundExpression _InitializerOpt;
    private static ConditionalWeakTable`2<BoundDimStatement, object> s_variablesMappings;
    public ImmutableArray`1<BoundLocalDeclarationBase> LocalDeclarations { get; }
    public BoundExpression InitializerOpt { get; }
    private ImmutableArray`1<IVariableDeclaration> IVariableDeclarationStatement_Variables { get; }
    private static BoundDimStatement();
    public BoundDimStatement(VisualBasicSyntaxNode syntax, ImmutableArray`1<BoundLocalDeclarationBase> localDeclarations, BoundExpression initializerOpt, bool hasErrors);
    public ImmutableArray`1<BoundLocalDeclarationBase> get_LocalDeclarations();
    public BoundExpression get_InitializerOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundDimStatement Update(ImmutableArray`1<BoundLocalDeclarationBase> localDeclarations, BoundExpression initializerOpt);
    private sealed virtual override ImmutableArray`1<IVariableDeclaration> get_IVariableDeclarationStatement_Variables();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundDirectCast : BoundExpression {
    private BoundExpression _Operand;
    private ConversionKind _ConversionKind;
    private bool _SuppressVirtualCalls;
    private ConstantValue _ConstantValueOpt;
    private BoundLambda _RelaxationLambdaOpt;
    public BoundExpression Operand { get; }
    public ConversionKind ConversionKind { get; }
    public bool SuppressVirtualCalls { get; }
    public ConstantValue ConstantValueOpt { get; }
    public BoundLambda RelaxationLambdaOpt { get; }
    private ConversionKind IConversionExpression_ConversionKind { get; }
    private bool IConversionExpression_IsExplicit { get; }
    private IOperation IConversionExpression_Operand { get; }
    private IMethodSymbol IHasOperatorMethodExpression_OperatorMethod { get; }
    private bool IHasOperatorMethodExpression_UsesOperatorMethod { get; }
    public BoundDirectCast(VisualBasicSyntaxNode syntax, BoundExpression operand, ConversionKind conversionKind, bool suppressVirtualCalls, ConstantValue constantValueOpt, BoundLambda relaxationLambdaOpt, TypeSymbol type, bool hasErrors);
    public BoundDirectCast(VisualBasicSyntaxNode syntax, BoundExpression operand, ConversionKind conversionKind, TypeSymbol type, bool hasErrors);
    public BoundDirectCast(VisualBasicSyntaxNode syntax, BoundExpression operand, ConversionKind conversionKind, BoundLambda relaxationLambdaOpt, TypeSymbol type, bool hasErrors);
    public BoundDirectCast(VisualBasicSyntaxNode syntax, BoundExpression operand, ConversionKind conversionKind, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Operand();
    public ConversionKind get_ConversionKind();
    public virtual bool get_SuppressVirtualCalls();
    public virtual ConstantValue get_ConstantValueOpt();
    public BoundLambda get_RelaxationLambdaOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundDirectCast Update(BoundExpression operand, ConversionKind conversionKind, bool suppressVirtualCalls, ConstantValue constantValueOpt, BoundLambda relaxationLambdaOpt, TypeSymbol type);
    private sealed virtual override ConversionKind get_IConversionExpression_ConversionKind();
    private sealed virtual override bool get_IConversionExpression_IsExplicit();
    private sealed virtual override IOperation get_IConversionExpression_Operand();
    private sealed virtual override IMethodSymbol get_IHasOperatorMethodExpression_OperatorMethod();
    private sealed virtual override bool get_IHasOperatorMethodExpression_UsesOperatorMethod();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundDoLoopStatement : BoundLoopStatement {
    private BoundExpression _TopConditionOpt;
    private BoundExpression _BottomConditionOpt;
    private bool _TopConditionIsUntil;
    private bool _BottomConditionIsUntil;
    private BoundStatement _Body;
    public BoundExpression TopConditionOpt { get; }
    public BoundExpression BottomConditionOpt { get; }
    public bool TopConditionIsUntil { get; }
    public bool BottomConditionIsUntil { get; }
    public BoundStatement Body { get; }
    public bool ConditionIsTop { get; }
    public bool ConditionIsUntil { get; }
    public BoundExpression ConditionOpt { get; }
    private IOperation IForWhileUntilLoopStatement_Condition { get; }
    private IOperation ILoopStatement_Body { get; }
    private LoopKind ILoopStatement_LoopKind { get; }
    private bool IWhileUntilLoopStatement_IsTopTest { get; }
    private bool IWhileUntilLoopStatement_IsWhile { get; }
    public BoundDoLoopStatement(VisualBasicSyntaxNode syntax, BoundExpression topConditionOpt, BoundExpression bottomConditionOpt, bool topConditionIsUntil, bool bottomConditionIsUntil, BoundStatement body, LabelSymbol continueLabel, LabelSymbol exitLabel, bool hasErrors);
    public BoundExpression get_TopConditionOpt();
    public BoundExpression get_BottomConditionOpt();
    public bool get_TopConditionIsUntil();
    public bool get_BottomConditionIsUntil();
    public BoundStatement get_Body();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundDoLoopStatement Update(BoundExpression topConditionOpt, BoundExpression bottomConditionOpt, bool topConditionIsUntil, bool bottomConditionIsUntil, BoundStatement body, LabelSymbol continueLabel, LabelSymbol exitLabel);
    public bool get_ConditionIsTop();
    public bool get_ConditionIsUntil();
    public BoundExpression get_ConditionOpt();
    private sealed virtual override IOperation get_IForWhileUntilLoopStatement_Condition();
    private sealed virtual override IOperation get_ILoopStatement_Body();
    private sealed virtual override LoopKind get_ILoopStatement_LoopKind();
    private sealed virtual override bool get_IWhileUntilLoopStatement_IsTopTest();
    private sealed virtual override bool get_IWhileUntilLoopStatement_IsWhile();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundDup : BoundExpression {
    private bool _IsReference;
    public bool IsReference { get; }
    public BoundDup(VisualBasicSyntaxNode syntax, bool isReference, TypeSymbol type, bool hasErrors);
    public BoundDup(VisualBasicSyntaxNode syntax, bool isReference, TypeSymbol type);
    public bool get_IsReference();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundDup Update(bool isReference, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundEndStatement : BoundStatement {
    public BoundEndStatement(VisualBasicSyntaxNode syntax, bool hasErrors);
    public BoundEndStatement(VisualBasicSyntaxNode syntax);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundEraseStatement : BoundStatement {
    private ImmutableArray`1<BoundAssignmentOperator> _Clauses;
    public ImmutableArray`1<BoundAssignmentOperator> Clauses { get; }
    public BoundEraseStatement(VisualBasicSyntaxNode syntax, ImmutableArray`1<BoundAssignmentOperator> clauses, bool hasErrors);
    public ImmutableArray`1<BoundAssignmentOperator> get_Clauses();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundEraseStatement Update(ImmutableArray`1<BoundAssignmentOperator> clauses);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundEventAccess : BoundExpression {
    private BoundExpression _ReceiverOpt;
    private EventSymbol _EventSymbol;
    public BoundExpression ReceiverOpt { get; }
    public EventSymbol EventSymbol { get; }
    public Symbol ExpressionSymbol { get; }
    private IOperation IMemberReferenceExpression_Instance { get; }
    private ISymbol IMemberReferenceExpression_Member { get; }
    private IEventSymbol IEventReferenceExpression_Event { get; }
    public BoundEventAccess(VisualBasicSyntaxNode syntax, BoundExpression receiverOpt, EventSymbol eventSymbol, TypeSymbol type, bool hasErrors);
    public BoundExpression get_ReceiverOpt();
    public EventSymbol get_EventSymbol();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundEventAccess Update(BoundExpression receiverOpt, EventSymbol eventSymbol, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    private sealed virtual override IOperation get_IMemberReferenceExpression_Instance();
    private sealed virtual override ISymbol get_IMemberReferenceExpression_Member();
    private sealed virtual override IEventSymbol get_IEventReferenceExpression_Event();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundExitStatement : BoundStatement {
    private LabelSymbol _Label;
    public LabelSymbol Label { get; }
    private ILabelSymbol IBranchStatement_Target { get; }
    private BranchKind IBranchStatement_BranchKind { get; }
    public BoundExitStatement(VisualBasicSyntaxNode syntax, LabelSymbol label, bool hasErrors);
    public BoundExitStatement(VisualBasicSyntaxNode syntax, LabelSymbol label);
    public LabelSymbol get_Label();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundExitStatement Update(LabelSymbol label);
    private sealed virtual override ILabelSymbol get_IBranchStatement_Target();
    private sealed virtual override BranchKind get_IBranchStatement_BranchKind();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundExpression : BoundNode {
    private TypeSymbol _Type;
    public TypeSymbol Type { get; }
    public bool IsConstant { get; }
    public ConstantValue ConstantValueOpt { get; }
    public Symbol ExpressionSymbol { get; }
    public LookupResultKind ResultKind { get; }
    public bool SuppressVirtualCalls { get; }
    public bool IsLValue { get; }
    private Optional`1<object> IOperation_ConstantValue { get; }
    private OperationKind IOperation_Kind { get; }
    private bool IOperation_IsInvalid { get; }
    private ITypeSymbol IOperation_Type { get; }
    private SyntaxNode IOperation_Syntax { get; }
    protected BoundExpression(BoundKind kind, VisualBasicSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    protected BoundExpression(BoundKind kind, VisualBasicSyntaxNode syntax, TypeSymbol type);
    public TypeSymbol get_Type();
    public bool get_IsConstant();
    public virtual ConstantValue get_ConstantValueOpt();
    public virtual Symbol get_ExpressionSymbol();
    public virtual LookupResultKind get_ResultKind();
    public virtual bool get_SuppressVirtualCalls();
    public virtual bool get_IsLValue();
    public BoundExpression MakeRValue();
    protected virtual BoundExpression MakeRValueImpl();
    private sealed virtual override Optional`1<object> get_IOperation_ConstantValue();
    private sealed virtual override OperationKind get_IOperation_Kind();
    private sealed virtual override bool get_IOperation_IsInvalid();
    private sealed virtual override ITypeSymbol get_IOperation_Type();
    private sealed virtual override SyntaxNode get_IOperation_Syntax();
    protected abstract virtual OperationKind ExpressionKind();
    public abstract virtual override void Accept(OperationVisitor visitor);
    public abstract virtual override TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    protected static IOperation GetChildOfBadExpression(BoundNode parent, int index);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.BoundExpressionExtensions : object {
    [ExtensionAttribute]
public static bool IsDefaultValue(BoundExpression node);
    [ExtensionAttribute]
public static bool IsValue(BoundExpression node);
    [ExtensionAttribute]
public static bool IsMeReference(BoundExpression node);
    [ExtensionAttribute]
public static bool IsMyBaseReference(BoundExpression node);
    [ExtensionAttribute]
public static bool IsMyClassReference(BoundExpression node);
    [ExtensionAttribute]
public static bool IsInstanceReference(BoundExpression node);
    [ExtensionAttribute]
public static bool IsPropertyOrXmlPropertyAccess(BoundExpression node);
    [ExtensionAttribute]
public static bool IsLateBound(BoundExpression node);
    [ExtensionAttribute]
public static TypeSymbol GetTypeOfAssignmentTarget(BoundExpression node);
    [ExtensionAttribute]
public static PropertySymbol GetPropertyOrXmlProperty(BoundExpression node);
    [ExtensionAttribute]
public static bool IsPropertySupportingAssignment(BoundExpression node);
    [ExtensionAttribute]
public static bool IsSupportingAssignment(BoundExpression node);
    [ExtensionAttribute]
public static PropertyAccessKind GetAccessKind(BoundExpression node);
    [ExtensionAttribute]
public static LateBoundAccessKind GetLateBoundAccessKind(BoundExpression node);
    [ExtensionAttribute]
public static BoundExpression SetAccessKind(BoundExpression node, PropertyAccessKind newAccessKind);
    [ExtensionAttribute]
public static BoundExpression SetLateBoundAccessKind(BoundExpression node, LateBoundAccessKind newAccessKind);
    [ExtensionAttribute]
public static BoundXmlMemberAccess Update(BoundXmlMemberAccess node, BoundExpression memberAccess);
    [ExtensionAttribute]
public static bool IsIntegerZeroLiteral(BoundExpression node);
    [ExtensionAttribute]
public static bool IsIntegerZeroLiteral(BoundLiteral node);
    [ExtensionAttribute]
public static bool IsDefaultValueConstant(BoundExpression expr);
    [ExtensionAttribute]
public static bool IsTrueConstant(BoundExpression expr);
    [ExtensionAttribute]
public static bool IsFalseConstant(BoundExpression expr);
    [ExtensionAttribute]
public static bool IsNegativeIntegerConstant(BoundExpression expression);
    [ExtensionAttribute]
public static Nullable`1<int> GetIntegerConstantValue(BoundExpression expression);
    [ExtensionAttribute]
public static bool IsNothingLiteral(BoundExpression node);
    [ExtensionAttribute]
public static bool IsNothingLiteral(BoundLiteral node);
    [ExtensionAttribute]
public static bool IsStrictNothingLiteral(BoundExpression node);
    [ExtensionAttribute]
public static BoundExpression GetMostEnclosedParenthesizedExpression(BoundExpression expression);
    [ExtensionAttribute]
public static bool HasExpressionSymbols(BoundExpression node);
    [ExtensionAttribute]
public static void GetExpressionSymbols(BoundMethodGroup methodGroup, ArrayBuilder`1<Symbol> symbols);
    [ExtensionAttribute]
public static void GetExpressionSymbols(BoundExpression node, ArrayBuilder`1<Symbol> symbols);
    [ExtensionAttribute]
public static BoundExpressionStatement ToStatement(BoundExpression node);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void AssertRValue(BoundExpression node);
    [ExtensionAttribute]
internal static BoundTypeArguments TypeArguments(BoundMethodOrPropertyGroup this);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundExpressionStatement : BoundStatement {
    private BoundExpression _Expression;
    public BoundExpression Expression { get; }
    private IOperation IExpressionStatement_Expression { get; }
    public BoundExpressionStatement(VisualBasicSyntaxNode syntax, BoundExpression expression, bool hasErrors);
    public BoundExpression get_Expression();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundExpressionStatement Update(BoundExpression expression);
    private sealed virtual override IOperation get_IExpressionStatement_Expression();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundFieldAccess : BoundExpression {
    private BoundExpression _ReceiverOpt;
    private FieldSymbol _FieldSymbol;
    private bool _IsLValue;
    private bool _SuppressVirtualCalls;
    private SymbolsInProgress`1<FieldSymbol> _ConstantsInProgressOpt;
    public BoundExpression ReceiverOpt { get; }
    public FieldSymbol FieldSymbol { get; }
    public bool IsLValue { get; }
    public bool SuppressVirtualCalls { get; }
    public SymbolsInProgress`1<FieldSymbol> ConstantsInProgressOpt { get; }
    public Symbol ExpressionSymbol { get; }
    public ConstantValue ConstantValueOpt { get; }
    private IFieldSymbol IFieldReferenceExpression_Field { get; }
    private IOperation IMemberReferenceExpression_Instance { get; }
    private ISymbol IMemberReferenceExpression_Member { get; }
    public BoundFieldAccess(VisualBasicSyntaxNode syntax, BoundExpression receiverOpt, FieldSymbol fieldSymbol, bool isLValue, bool suppressVirtualCalls, SymbolsInProgress`1<FieldSymbol> constantsInProgressOpt, TypeSymbol type, bool hasErrors);
    public BoundFieldAccess(VisualBasicSyntaxNode syntax, BoundExpression receiverOpt, FieldSymbol fieldSymbol, bool isLValue, TypeSymbol type, bool hasErrors);
    public BoundExpression get_ReceiverOpt();
    public FieldSymbol get_FieldSymbol();
    public virtual bool get_IsLValue();
    public virtual bool get_SuppressVirtualCalls();
    public SymbolsInProgress`1<FieldSymbol> get_ConstantsInProgressOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundFieldAccess Update(BoundExpression receiverOpt, FieldSymbol fieldSymbol, bool isLValue, bool suppressVirtualCalls, SymbolsInProgress`1<FieldSymbol> constantsInProgressOpt, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    protected virtual BoundExpression MakeRValueImpl();
    public BoundFieldAccess MakeRValue();
    public virtual ConstantValue get_ConstantValueOpt();
    private sealed virtual override IFieldSymbol get_IFieldReferenceExpression_Field();
    private sealed virtual override IOperation get_IMemberReferenceExpression_Instance();
    private sealed virtual override ISymbol get_IMemberReferenceExpression_Member();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundFieldInfo : BoundExpression {
    private FieldSymbol _Field;
    public FieldSymbol Field { get; }
    public BoundFieldInfo(VisualBasicSyntaxNode syntax, FieldSymbol field, TypeSymbol type, bool hasErrors);
    public BoundFieldInfo(VisualBasicSyntaxNode syntax, FieldSymbol field, TypeSymbol type);
    public FieldSymbol get_Field();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundFieldInfo Update(FieldSymbol field, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundFieldInitializer : BoundFieldOrPropertyInitializer {
    private ImmutableArray`1<FieldSymbol> _InitializedFields;
    public ImmutableArray`1<FieldSymbol> InitializedFields { get; }
    private ImmutableArray`1<IFieldSymbol> IFieldInitializer_InitializedFields { get; }
    private IOperation ISymbolInitializer_Value { get; }
    public BoundFieldInitializer(VisualBasicSyntaxNode syntax, ImmutableArray`1<FieldSymbol> initializedFields, BoundExpression memberAccessExpressionOpt, BoundExpression initialValue, bool hasErrors);
    public ImmutableArray`1<FieldSymbol> get_InitializedFields();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundFieldInitializer Update(ImmutableArray`1<FieldSymbol> initializedFields, BoundExpression memberAccessExpressionOpt, BoundExpression initialValue);
    private sealed virtual override ImmutableArray`1<IFieldSymbol> get_IFieldInitializer_InitializedFields();
    private sealed virtual override IOperation get_ISymbolInitializer_Value();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundFieldOrPropertyInitializer : BoundInitializer {
    private BoundExpression _MemberAccessExpressionOpt;
    private BoundExpression _InitialValue;
    public BoundExpression MemberAccessExpressionOpt { get; }
    public BoundExpression InitialValue { get; }
    protected BoundFieldOrPropertyInitializer(BoundKind kind, VisualBasicSyntaxNode syntax, BoundExpression memberAccessExpressionOpt, BoundExpression initialValue, bool hasErrors);
    public BoundExpression get_MemberAccessExpressionOpt();
    public BoundExpression get_InitialValue();
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundForEachStatement : BoundForStatement {
    private BoundExpression _Collection;
    private ForEachEnumeratorInfo _EnumeratorInfo;
    public BoundExpression Collection { get; }
    public ForEachEnumeratorInfo EnumeratorInfo { get; }
    private ILocalSymbol IForEachLoopStatement_IterationVariable { get; }
    private LoopKind ILoopStatement_LoopKind { get; }
    private IOperation IForEachLoopStatement_Collection { get; }
    private IOperation ILoopStatement_Body { get; }
    public BoundForEachStatement(VisualBasicSyntaxNode syntax, BoundExpression collection, ForEachEnumeratorInfo enumeratorInfo, LocalSymbol declaredOrInferredLocalOpt, BoundExpression controlVariable, BoundStatement body, ImmutableArray`1<BoundExpression> nextVariablesOpt, LabelSymbol continueLabel, LabelSymbol exitLabel, bool hasErrors);
    public BoundExpression get_Collection();
    public ForEachEnumeratorInfo get_EnumeratorInfo();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundForEachStatement Update(BoundExpression collection, ForEachEnumeratorInfo enumeratorInfo, LocalSymbol declaredOrInferredLocalOpt, BoundExpression controlVariable, BoundStatement body, ImmutableArray`1<BoundExpression> nextVariablesOpt, LabelSymbol continueLabel, LabelSymbol exitLabel);
    private sealed virtual override ILocalSymbol get_IForEachLoopStatement_IterationVariable();
    private sealed virtual override LoopKind get_ILoopStatement_LoopKind();
    private sealed virtual override IOperation get_IForEachLoopStatement_Collection();
    private sealed virtual override IOperation get_ILoopStatement_Body();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundForStatement : BoundLoopStatement {
    private LocalSymbol _DeclaredOrInferredLocalOpt;
    private BoundExpression _ControlVariable;
    private BoundStatement _Body;
    private ImmutableArray`1<BoundExpression> _NextVariablesOpt;
    public LocalSymbol DeclaredOrInferredLocalOpt { get; }
    public BoundExpression ControlVariable { get; }
    public BoundStatement Body { get; }
    public ImmutableArray`1<BoundExpression> NextVariablesOpt { get; }
    protected BoundForStatement(BoundKind kind, VisualBasicSyntaxNode syntax, LocalSymbol declaredOrInferredLocalOpt, BoundExpression controlVariable, BoundStatement body, ImmutableArray`1<BoundExpression> nextVariablesOpt, LabelSymbol continueLabel, LabelSymbol exitLabel, bool hasErrors);
    public LocalSymbol get_DeclaredOrInferredLocalOpt();
    public BoundExpression get_ControlVariable();
    public BoundStatement get_Body();
    public ImmutableArray`1<BoundExpression> get_NextVariablesOpt();
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundForToStatement : BoundForStatement {
    private BoundExpression _InitialValue;
    private BoundExpression _LimitValue;
    private BoundExpression _StepValue;
    private bool _Checked;
    private BoundForToUserDefinedOperators _OperatorsOpt;
    private static ConditionalWeakTable`2<BoundForToStatement, object> s_loopBottomMappings;
    private static ConditionalWeakTable`2<BoundForToStatement, object> s_loopTopMappings;
    private static ConditionalWeakTable`2<BoundForToStatement, IOperation> s_loopConditionMappings;
    public BoundExpression InitialValue { get; }
    public BoundExpression LimitValue { get; }
    public BoundExpression StepValue { get; }
    public bool Checked { get; }
    public BoundForToUserDefinedOperators OperatorsOpt { get; }
    private ImmutableArray`1<IOperation> IForLoopStatement_AtLoopBottom { get; }
    private ImmutableArray`1<IOperation> IForLoopStatement_Before { get; }
    private ImmutableArray`1<ILocalSymbol> IForLoopStatement_Locals { get; }
    private IOperation IForWhileUntilLoopStatment_Condition { get; }
    private IOperation ILoopStatement_Body { get; }
    private LoopKind ILoopStatement_LoopKind { get; }
    private static BoundForToStatement();
    public BoundForToStatement(VisualBasicSyntaxNode syntax, BoundExpression initialValue, BoundExpression limitValue, BoundExpression stepValue, bool checked, BoundForToUserDefinedOperators operatorsOpt, LocalSymbol declaredOrInferredLocalOpt, BoundExpression controlVariable, BoundStatement body, ImmutableArray`1<BoundExpression> nextVariablesOpt, LabelSymbol continueLabel, LabelSymbol exitLabel, bool hasErrors);
    public BoundExpression get_InitialValue();
    public BoundExpression get_LimitValue();
    public BoundExpression get_StepValue();
    public bool get_Checked();
    public BoundForToUserDefinedOperators get_OperatorsOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundForToStatement Update(BoundExpression initialValue, BoundExpression limitValue, BoundExpression stepValue, bool checked, BoundForToUserDefinedOperators operatorsOpt, LocalSymbol declaredOrInferredLocalOpt, BoundExpression controlVariable, BoundStatement body, ImmutableArray`1<BoundExpression> nextVariablesOpt, LabelSymbol continueLabel, LabelSymbol exitLabel);
    private sealed virtual override ImmutableArray`1<IOperation> get_IForLoopStatement_AtLoopBottom();
    private sealed virtual override ImmutableArray`1<IOperation> get_IForLoopStatement_Before();
    private sealed virtual override ImmutableArray`1<ILocalSymbol> get_IForLoopStatement_Locals();
    private sealed virtual override IOperation get_IForWhileUntilLoopStatment_Condition();
    private sealed virtual override IOperation get_ILoopStatement_Body();
    private sealed virtual override LoopKind get_ILoopStatement_LoopKind();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
private object _Lambda$__24-0(BoundForToStatement BoundFor);
    [CompilerGeneratedAttribute]
private IOperation _Lambda$__29-0(BoundForToStatement BoundFor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundForToUserDefinedOperators : BoundNode {
    private BoundRValuePlaceholder _LeftOperandPlaceholder;
    private BoundRValuePlaceholder _RightOperandPlaceholder;
    private BoundUserDefinedBinaryOperator _Addition;
    private BoundUserDefinedBinaryOperator _Subtraction;
    private BoundExpression _LessThanOrEqual;
    private BoundExpression _GreaterThanOrEqual;
    public BoundRValuePlaceholder LeftOperandPlaceholder { get; }
    public BoundRValuePlaceholder RightOperandPlaceholder { get; }
    public BoundUserDefinedBinaryOperator Addition { get; }
    public BoundUserDefinedBinaryOperator Subtraction { get; }
    public BoundExpression LessThanOrEqual { get; }
    public BoundExpression GreaterThanOrEqual { get; }
    public BoundForToUserDefinedOperators(VisualBasicSyntaxNode syntax, BoundRValuePlaceholder leftOperandPlaceholder, BoundRValuePlaceholder rightOperandPlaceholder, BoundUserDefinedBinaryOperator addition, BoundUserDefinedBinaryOperator subtraction, BoundExpression lessThanOrEqual, BoundExpression greaterThanOrEqual, bool hasErrors);
    public BoundRValuePlaceholder get_LeftOperandPlaceholder();
    public BoundRValuePlaceholder get_RightOperandPlaceholder();
    public BoundUserDefinedBinaryOperator get_Addition();
    public BoundUserDefinedBinaryOperator get_Subtraction();
    public BoundExpression get_LessThanOrEqual();
    public BoundExpression get_GreaterThanOrEqual();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundForToUserDefinedOperators Update(BoundRValuePlaceholder leftOperandPlaceholder, BoundRValuePlaceholder rightOperandPlaceholder, BoundUserDefinedBinaryOperator addition, BoundUserDefinedBinaryOperator subtraction, BoundExpression lessThanOrEqual, BoundExpression greaterThanOrEqual);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundGetType : BoundExpression {
    private BoundTypeExpression _SourceType;
    public BoundTypeExpression SourceType { get; }
    public BoundGetType(VisualBasicSyntaxNode syntax, BoundTypeExpression sourceType, TypeSymbol type, bool hasErrors);
    public BoundTypeExpression get_SourceType();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundGetType Update(BoundTypeExpression sourceType, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundGlobalStatementInitializer : BoundInitializer {
    private BoundStatement _Statement;
    public BoundStatement Statement { get; }
    public BoundGlobalStatementInitializer(VisualBasicSyntaxNode syntax, BoundStatement statement, bool hasErrors);
    public BoundStatement get_Statement();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundGlobalStatementInitializer Update(BoundStatement statement);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundGotoStatement : BoundStatement {
    private LabelSymbol _Label;
    private BoundLabel _LabelExpressionOpt;
    public LabelSymbol Label { get; }
    public BoundLabel LabelExpressionOpt { get; }
    private ILabelSymbol IBranchStatement_Target { get; }
    private BranchKind IBranchStatement_BranchKind { get; }
    public BoundGotoStatement(VisualBasicSyntaxNode syntax, LabelSymbol label, BoundLabel labelExpressionOpt, bool hasErrors);
    public LabelSymbol get_Label();
    public BoundLabel get_LabelExpressionOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundGotoStatement Update(LabelSymbol label, BoundLabel labelExpressionOpt);
    private sealed virtual override ILabelSymbol get_IBranchStatement_Target();
    private sealed virtual override BranchKind get_IBranchStatement_BranchKind();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundGroupAggregation : BoundQueryPart {
    private BoundExpression _Group;
    public BoundExpression Group { get; }
    public BoundGroupAggregation(VisualBasicSyntaxNode syntax, BoundExpression group, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Group();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundGroupAggregation Update(BoundExpression group, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundHostObjectMemberReference : BoundExpression {
    public BoundHostObjectMemberReference(VisualBasicSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    public BoundHostObjectMemberReference(VisualBasicSyntaxNode syntax, TypeSymbol type);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundHostObjectMemberReference Update(TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundIfStatement : BoundStatement {
    private BoundExpression _Condition;
    private BoundStatement _Consequence;
    private BoundStatement _AlternativeOpt;
    public BoundExpression Condition { get; }
    public BoundStatement Consequence { get; }
    public BoundStatement AlternativeOpt { get; }
    private IOperation IOperation_Condition { get; }
    private IOperation IIfStatement_IfTrueStatement { get; }
    private IOperation IIfStatement_IfFalseStatement { get; }
    public BoundIfStatement(VisualBasicSyntaxNode syntax, BoundExpression condition, BoundStatement consequence, BoundStatement alternativeOpt, bool hasErrors);
    public BoundExpression get_Condition();
    public BoundStatement get_Consequence();
    public BoundStatement get_AlternativeOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundIfStatement Update(BoundExpression condition, BoundStatement consequence, BoundStatement alternativeOpt);
    private sealed virtual override IOperation get_IOperation_Condition();
    private sealed virtual override IOperation get_IIfStatement_IfTrueStatement();
    private sealed virtual override IOperation get_IIfStatement_IfFalseStatement();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundInitializer : BoundStatement {
    protected BoundInitializer(BoundKind kind, VisualBasicSyntaxNode syntax, bool hasErrors);
    protected BoundInitializer(BoundKind kind, VisualBasicSyntaxNode syntax);
    public BoundInitializer(VisualBasicSyntaxNode syntax, bool hasErrors);
    public BoundInitializer(VisualBasicSyntaxNode syntax);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundInterpolatedStringExpression : BoundExpression {
    private ImmutableArray`1<BoundNode> _Contents;
    private Binder _Binder;
    public ImmutableArray`1<BoundNode> Contents { get; }
    public Binder Binder { get; }
    public bool HasInterpolations { get; }
    public bool IsEmpty { get; }
    public BoundInterpolatedStringExpression(VisualBasicSyntaxNode syntax, ImmutableArray`1<BoundNode> contents, Binder binder, TypeSymbol type, bool hasErrors);
    public ImmutableArray`1<BoundNode> get_Contents();
    public Binder get_Binder();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundInterpolatedStringExpression Update(ImmutableArray`1<BoundNode> contents, Binder binder, TypeSymbol type);
    public bool get_HasInterpolations();
    public bool get_IsEmpty();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundInterpolation : BoundNode {
    private BoundExpression _Expression;
    private BoundExpression _AlignmentOpt;
    private BoundLiteral _FormatStringOpt;
    public BoundExpression Expression { get; }
    public BoundExpression AlignmentOpt { get; }
    public BoundLiteral FormatStringOpt { get; }
    public BoundInterpolation(VisualBasicSyntaxNode syntax, BoundExpression expression, BoundExpression alignmentOpt, BoundLiteral formatStringOpt, bool hasErrors);
    public BoundExpression get_Expression();
    public BoundExpression get_AlignmentOpt();
    public BoundLiteral get_FormatStringOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundInterpolation Update(BoundExpression expression, BoundExpression alignmentOpt, BoundLiteral formatStringOpt);
}
internal enum Microsoft.CodeAnalysis.VisualBasic.BoundKind : Enum {
    public byte value__;
    public static BoundKind TypeArguments;
    public static BoundKind OmittedArgument;
    public static BoundKind LValueToRValueWrapper;
    public static BoundKind WithLValueExpressionPlaceholder;
    public static BoundKind WithRValueExpressionPlaceholder;
    public static BoundKind RValuePlaceholder;
    public static BoundKind LValuePlaceholder;
    public static BoundKind Dup;
    public static BoundKind BadExpression;
    public static BoundKind BadStatement;
    public static BoundKind Parenthesized;
    public static BoundKind BadVariable;
    public static BoundKind ArrayAccess;
    public static BoundKind ArrayLength;
    public static BoundKind GetType;
    public static BoundKind FieldInfo;
    public static BoundKind MethodInfo;
    public static BoundKind TypeExpression;
    public static BoundKind TypeOrValueExpression;
    public static BoundKind NamespaceExpression;
    public static BoundKind UnaryOperator;
    public static BoundKind UserDefinedUnaryOperator;
    public static BoundKind NullableIsTrueOperator;
    public static BoundKind BinaryOperator;
    public static BoundKind UserDefinedBinaryOperator;
    public static BoundKind UserDefinedShortCircuitingOperator;
    public static BoundKind CompoundAssignmentTargetPlaceholder;
    public static BoundKind AssignmentOperator;
    public static BoundKind ReferenceAssignment;
    public static BoundKind AddressOfOperator;
    public static BoundKind TernaryConditionalExpression;
    public static BoundKind BinaryConditionalExpression;
    public static BoundKind Conversion;
    public static BoundKind UserDefinedConversion;
    public static BoundKind DirectCast;
    public static BoundKind TryCast;
    public static BoundKind TypeOf;
    public static BoundKind SequencePoint;
    public static BoundKind SequencePointExpression;
    public static BoundKind SequencePointWithSpan;
    public static BoundKind NoOpStatement;
    public static BoundKind MethodGroup;
    public static BoundKind PropertyGroup;
    public static BoundKind ReturnStatement;
    public static BoundKind YieldStatement;
    public static BoundKind ThrowStatement;
    public static BoundKind RedimStatement;
    public static BoundKind RedimClause;
    public static BoundKind EraseStatement;
    public static BoundKind Call;
    public static BoundKind Attribute;
    public static BoundKind LateMemberAccess;
    public static BoundKind LateInvocation;
    public static BoundKind LateAddressOfOperator;
    public static BoundKind ObjectCreationExpression;
    public static BoundKind NoPiaObjectCreationExpression;
    public static BoundKind AnonymousTypeCreationExpression;
    public static BoundKind AnonymousTypePropertyAccess;
    public static BoundKind AnonymousTypeFieldInitializer;
    public static BoundKind ObjectInitializerExpression;
    public static BoundKind CollectionInitializerExpression;
    public static BoundKind NewT;
    public static BoundKind DelegateCreationExpression;
    public static BoundKind ArrayCreation;
    public static BoundKind ArrayLiteral;
    public static BoundKind ArrayInitialization;
    public static BoundKind FieldAccess;
    public static BoundKind PropertyAccess;
    public static BoundKind EventAccess;
    public static BoundKind Block;
    public static BoundKind StateMachineScope;
    public static BoundKind LocalDeclaration;
    public static BoundKind AsNewLocalDeclarations;
    public static BoundKind DimStatement;
    public static BoundKind Initializer;
    public static BoundKind FieldInitializer;
    public static BoundKind PropertyInitializer;
    public static BoundKind ParameterEqualsValue;
    public static BoundKind GlobalStatementInitializer;
    public static BoundKind Sequence;
    public static BoundKind ExpressionStatement;
    public static BoundKind IfStatement;
    public static BoundKind SelectStatement;
    public static BoundKind CaseBlock;
    public static BoundKind CaseStatement;
    public static BoundKind SimpleCaseClause;
    public static BoundKind RangeCaseClause;
    public static BoundKind RelationalCaseClause;
    public static BoundKind DoLoopStatement;
    public static BoundKind WhileStatement;
    public static BoundKind ForToUserDefinedOperators;
    public static BoundKind ForToStatement;
    public static BoundKind ForEachStatement;
    public static BoundKind ExitStatement;
    public static BoundKind ContinueStatement;
    public static BoundKind TryStatement;
    public static BoundKind CatchBlock;
    public static BoundKind Literal;
    public static BoundKind MeReference;
    public static BoundKind ValueTypeMeReference;
    public static BoundKind MyBaseReference;
    public static BoundKind MyClassReference;
    public static BoundKind PreviousSubmissionReference;
    public static BoundKind HostObjectMemberReference;
    public static BoundKind Local;
    public static BoundKind PseudoVariable;
    public static BoundKind Parameter;
    public static BoundKind ByRefArgumentPlaceholder;
    public static BoundKind ByRefArgumentWithCopyBack;
    public static BoundKind LateBoundArgumentSupportingAssignmentWithCapture;
    public static BoundKind LabelStatement;
    public static BoundKind Label;
    public static BoundKind GotoStatement;
    public static BoundKind StatementList;
    public static BoundKind ConditionalGoto;
    public static BoundKind WithStatement;
    public static BoundKind UnboundLambda;
    public static BoundKind Lambda;
    public static BoundKind QueryExpression;
    public static BoundKind QuerySource;
    public static BoundKind ToQueryableCollectionConversion;
    public static BoundKind QueryableSource;
    public static BoundKind QueryClause;
    public static BoundKind Ordering;
    public static BoundKind QueryLambda;
    public static BoundKind RangeVariableAssignment;
    public static BoundKind GroupTypeInferenceLambda;
    public static BoundKind AggregateClause;
    public static BoundKind GroupAggregation;
    public static BoundKind RangeVariable;
    public static BoundKind AddHandlerStatement;
    public static BoundKind RemoveHandlerStatement;
    public static BoundKind RaiseEventStatement;
    public static BoundKind UsingStatement;
    public static BoundKind SyncLockStatement;
    public static BoundKind XmlName;
    public static BoundKind XmlNamespace;
    public static BoundKind XmlDocument;
    public static BoundKind XmlDeclaration;
    public static BoundKind XmlProcessingInstruction;
    public static BoundKind XmlComment;
    public static BoundKind XmlAttribute;
    public static BoundKind XmlElement;
    public static BoundKind XmlMemberAccess;
    public static BoundKind XmlEmbeddedExpression;
    public static BoundKind XmlCData;
    public static BoundKind ResumeStatement;
    public static BoundKind OnErrorStatement;
    public static BoundKind UnstructuredExceptionHandlingStatement;
    public static BoundKind UnstructuredExceptionHandlingCatchFilter;
    public static BoundKind UnstructuredExceptionOnErrorSwitch;
    public static BoundKind UnstructuredExceptionResumeSwitch;
    public static BoundKind AwaitOperator;
    public static BoundKind SpillSequence;
    public static BoundKind StopStatement;
    public static BoundKind EndStatement;
    public static BoundKind MidResult;
    public static BoundKind ConditionalAccess;
    public static BoundKind ConditionalAccessReceiverPlaceholder;
    public static BoundKind LoweredConditionalAccess;
    public static BoundKind ComplexConditionalAccessReceiver;
    public static BoundKind NameOfOperator;
    public static BoundKind TypeAsValueExpression;
    public static BoundKind InterpolatedStringExpression;
    public static BoundKind Interpolation;
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundLabel : BoundExpression {
    private LabelSymbol _Label;
    public LabelSymbol Label { get; }
    public Symbol ExpressionSymbol { get; }
    public BoundLabel(VisualBasicSyntaxNode syntax, LabelSymbol label, TypeSymbol type, bool hasErrors);
    public BoundLabel(VisualBasicSyntaxNode syntax, LabelSymbol label, TypeSymbol type);
    public LabelSymbol get_Label();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLabel Update(LabelSymbol label, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundLabelStatement : BoundStatement {
    private LabelSymbol _Label;
    public LabelSymbol Label { get; }
    private ILabelSymbol ILabelStatement_Label { get; }
    private IOperation ILabelStatement_LabeledStatement { get; }
    public BoundLabelStatement(VisualBasicSyntaxNode syntax, LabelSymbol label, bool hasErrors);
    public BoundLabelStatement(VisualBasicSyntaxNode syntax, LabelSymbol label);
    public LabelSymbol get_Label();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLabelStatement Update(LabelSymbol label);
    private sealed virtual override ILabelSymbol get_ILabelStatement_Label();
    private sealed virtual override IOperation get_ILabelStatement_LabeledStatement();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundLambda : BoundExpression {
    private LambdaSymbol _LambdaSymbol;
    private BoundBlock _Body;
    private ImmutableArray`1<Diagnostic> _Diagnostics;
    private LambdaBodyBinder _LambdaBinderOpt;
    private ConversionKind _DelegateRelaxation;
    private MethodConversionKind _MethodConversionKind;
    public LambdaSymbol LambdaSymbol { get; }
    public BoundBlock Body { get; }
    public ImmutableArray`1<Diagnostic> Diagnostics { get; }
    public LambdaBodyBinder LambdaBinderOpt { get; }
    public ConversionKind DelegateRelaxation { get; }
    public MethodConversionKind MethodConversionKind { get; }
    public bool IsSingleLine { get; }
    public Symbol ExpressionSymbol { get; }
    private IBlockStatement ILambdaExpression_Body { get; }
    private IMethodSymbol ILambdaExpression_Signature { get; }
    public BoundLambda(VisualBasicSyntaxNode syntax, LambdaSymbol lambdaSymbol, BoundBlock body, ImmutableArray`1<Diagnostic> diagnostics, LambdaBodyBinder lambdaBinderOpt, ConversionKind delegateRelaxation, MethodConversionKind methodConversionKind, bool hasErrors);
    public LambdaSymbol get_LambdaSymbol();
    public BoundBlock get_Body();
    public ImmutableArray`1<Diagnostic> get_Diagnostics();
    public LambdaBodyBinder get_LambdaBinderOpt();
    public ConversionKind get_DelegateRelaxation();
    public MethodConversionKind get_MethodConversionKind();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLambda Update(LambdaSymbol lambdaSymbol, BoundBlock body, ImmutableArray`1<Diagnostic> diagnostics, LambdaBodyBinder lambdaBinderOpt, ConversionKind delegateRelaxation, MethodConversionKind methodConversionKind);
    public bool get_IsSingleLine();
    public virtual Symbol get_ExpressionSymbol();
    private sealed virtual override IBlockStatement get_ILambdaExpression_Body();
    private sealed virtual override IMethodSymbol get_ILambdaExpression_Signature();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundLateAddressOfOperator : BoundExpression {
    private Binder _Binder;
    private BoundLateMemberAccess _MemberAccess;
    public Binder Binder { get; }
    public BoundLateMemberAccess MemberAccess { get; }
    public BoundLateAddressOfOperator(VisualBasicSyntaxNode syntax, Binder binder, BoundLateMemberAccess memberAccess, TypeSymbol type, bool hasErrors);
    public Binder get_Binder();
    public BoundLateMemberAccess get_MemberAccess();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLateAddressOfOperator Update(Binder binder, BoundLateMemberAccess memberAccess, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundLateBoundArgumentSupportingAssignmentWithCapture : BoundExpression {
    private BoundExpression _OriginalArgument;
    private SynthesizedLocal _LocalSymbol;
    public BoundExpression OriginalArgument { get; }
    public SynthesizedLocal LocalSymbol { get; }
    public BoundLateBoundArgumentSupportingAssignmentWithCapture(VisualBasicSyntaxNode syntax, BoundExpression originalArgument, SynthesizedLocal localSymbol, TypeSymbol type, bool hasErrors);
    public BoundExpression get_OriginalArgument();
    public SynthesizedLocal get_LocalSymbol();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLateBoundArgumentSupportingAssignmentWithCapture Update(BoundExpression originalArgument, SynthesizedLocal localSymbol, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundLateInvocation : BoundExpression {
    private BoundExpression _Member;
    private ImmutableArray`1<BoundExpression> _ArgumentsOpt;
    private ImmutableArray`1<string> _ArgumentNamesOpt;
    private LateBoundAccessKind _AccessKind;
    private BoundMethodOrPropertyGroup _MethodOrPropertyGroupOpt;
    public BoundExpression Member { get; }
    public ImmutableArray`1<BoundExpression> ArgumentsOpt { get; }
    public ImmutableArray`1<string> ArgumentNamesOpt { get; }
    public LateBoundAccessKind AccessKind { get; }
    public BoundMethodOrPropertyGroup MethodOrPropertyGroupOpt { get; }
    public BoundLateInvocation(VisualBasicSyntaxNode syntax, BoundExpression member, ImmutableArray`1<BoundExpression> argumentsOpt, ImmutableArray`1<string> argumentNamesOpt, LateBoundAccessKind accessKind, BoundMethodOrPropertyGroup methodOrPropertyGroupOpt, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Member();
    public ImmutableArray`1<BoundExpression> get_ArgumentsOpt();
    public ImmutableArray`1<string> get_ArgumentNamesOpt();
    public LateBoundAccessKind get_AccessKind();
    public BoundMethodOrPropertyGroup get_MethodOrPropertyGroupOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLateInvocation Update(BoundExpression member, ImmutableArray`1<BoundExpression> argumentsOpt, ImmutableArray`1<string> argumentNamesOpt, LateBoundAccessKind accessKind, BoundMethodOrPropertyGroup methodOrPropertyGroupOpt, TypeSymbol type);
    public BoundLateInvocation SetAccessKind(LateBoundAccessKind newAccessKind);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundLateMemberAccess : BoundExpression {
    private string _NameOpt;
    private TypeSymbol _ContainerTypeOpt;
    private BoundExpression _ReceiverOpt;
    private BoundTypeArguments _TypeArgumentsOpt;
    private LateBoundAccessKind _AccessKind;
    public string NameOpt { get; }
    public TypeSymbol ContainerTypeOpt { get; }
    public BoundExpression ReceiverOpt { get; }
    public BoundTypeArguments TypeArgumentsOpt { get; }
    public LateBoundAccessKind AccessKind { get; }
    private IOperation ILateBoundMemberReferenceExpression_Instance { get; }
    private string ILateBoundMemberReferenceExpression_MemberName { get; }
    public BoundLateMemberAccess(VisualBasicSyntaxNode syntax, string nameOpt, TypeSymbol containerTypeOpt, BoundExpression receiverOpt, BoundTypeArguments typeArgumentsOpt, LateBoundAccessKind accessKind, TypeSymbol type, bool hasErrors);
    public string get_NameOpt();
    public TypeSymbol get_ContainerTypeOpt();
    public BoundExpression get_ReceiverOpt();
    public BoundTypeArguments get_TypeArgumentsOpt();
    public LateBoundAccessKind get_AccessKind();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLateMemberAccess Update(string nameOpt, TypeSymbol containerTypeOpt, BoundExpression receiverOpt, BoundTypeArguments typeArgumentsOpt, LateBoundAccessKind accessKind, TypeSymbol type);
    public BoundLateMemberAccess SetAccessKind(LateBoundAccessKind newAccessKind);
    private sealed virtual override IOperation get_ILateBoundMemberReferenceExpression_Instance();
    private sealed virtual override string get_ILateBoundMemberReferenceExpression_MemberName();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundLiteral : BoundExpression {
    private ConstantValue _Value;
    public ConstantValue Value { get; }
    public ConstantValue ConstantValueOpt { get; }
    private string ILiteralExpression_Text { get; }
    public BoundLiteral(VisualBasicSyntaxNode syntax, ConstantValue value, TypeSymbol type, bool hasErrors);
    public BoundLiteral(VisualBasicSyntaxNode syntax, ConstantValue value, TypeSymbol type);
    public ConstantValue get_Value();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLiteral Update(ConstantValue value, TypeSymbol type);
    public virtual ConstantValue get_ConstantValueOpt();
    private sealed virtual override string get_ILiteralExpression_Text();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundLocal : BoundExpression {
    private LocalSymbol _LocalSymbol;
    private bool _IsLValue;
    public LocalSymbol LocalSymbol { get; }
    public bool IsLValue { get; }
    public Symbol ExpressionSymbol { get; }
    public ConstantValue ConstantValueOpt { get; }
    private ILocalSymbol ILocalReferenceExpression_Local { get; }
    public BoundLocal(VisualBasicSyntaxNode syntax, LocalSymbol localSymbol, bool isLValue, TypeSymbol type, bool hasErrors);
    public BoundLocal(VisualBasicSyntaxNode syntax, LocalSymbol localSymbol, bool isLValue, TypeSymbol type);
    public BoundLocal(VisualBasicSyntaxNode syntax, LocalSymbol localSymbol, TypeSymbol type, bool hasErrors);
    public BoundLocal(VisualBasicSyntaxNode syntax, LocalSymbol localSymbol, TypeSymbol type);
    public LocalSymbol get_LocalSymbol();
    public virtual bool get_IsLValue();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLocal Update(LocalSymbol localSymbol, bool isLValue, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    protected virtual BoundExpression MakeRValueImpl();
    public BoundLocal MakeRValue();
    public virtual ConstantValue get_ConstantValueOpt();
    private sealed virtual override ILocalSymbol get_ILocalReferenceExpression_Local();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundLocalDeclaration : BoundLocalDeclarationBase {
    private LocalSymbol _LocalSymbol;
    private BoundExpression _InitializerOpt;
    private bool _InitializedByAsNew;
    public LocalSymbol LocalSymbol { get; }
    public BoundExpression InitializerOpt { get; }
    public bool InitializedByAsNew { get; }
    public BoundLocalDeclaration(VisualBasicSyntaxNode syntax, LocalSymbol localSymbol, BoundExpression initializerOpt, bool initializedByAsNew, bool hasErrors);
    public BoundLocalDeclaration(VisualBasicSyntaxNode syntax, LocalSymbol localSymbol, BoundExpression initializerOpt);
    public LocalSymbol get_LocalSymbol();
    public BoundExpression get_InitializerOpt();
    public bool get_InitializedByAsNew();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLocalDeclaration Update(LocalSymbol localSymbol, BoundExpression initializerOpt, bool initializedByAsNew);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundLocalDeclarationBase : BoundStatement {
    protected BoundLocalDeclarationBase(BoundKind kind, VisualBasicSyntaxNode syntax, bool hasErrors);
    protected BoundLocalDeclarationBase(BoundKind kind, VisualBasicSyntaxNode syntax);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundLoopStatement : BoundStatement {
    private LabelSymbol _ContinueLabel;
    private LabelSymbol _ExitLabel;
    public LabelSymbol ContinueLabel { get; }
    public LabelSymbol ExitLabel { get; }
    protected BoundLoopStatement(BoundKind kind, VisualBasicSyntaxNode syntax, LabelSymbol continueLabel, LabelSymbol exitLabel, bool hasErrors);
    protected BoundLoopStatement(BoundKind kind, VisualBasicSyntaxNode syntax, LabelSymbol continueLabel, LabelSymbol exitLabel);
    public LabelSymbol get_ContinueLabel();
    public LabelSymbol get_ExitLabel();
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundLoweredConditionalAccess : BoundExpression {
    private BoundExpression _ReceiverOrCondition;
    private bool _CaptureReceiver;
    private int _PlaceholderId;
    private BoundExpression _WhenNotNull;
    private BoundExpression _WhenNullOpt;
    public BoundExpression ReceiverOrCondition { get; }
    public bool CaptureReceiver { get; }
    public int PlaceholderId { get; }
    public BoundExpression WhenNotNull { get; }
    public BoundExpression WhenNullOpt { get; }
    public BoundLoweredConditionalAccess(VisualBasicSyntaxNode syntax, BoundExpression receiverOrCondition, bool captureReceiver, int placeholderId, BoundExpression whenNotNull, BoundExpression whenNullOpt, TypeSymbol type, bool hasErrors);
    public BoundExpression get_ReceiverOrCondition();
    public bool get_CaptureReceiver();
    public int get_PlaceholderId();
    public BoundExpression get_WhenNotNull();
    public BoundExpression get_WhenNullOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLoweredConditionalAccess Update(BoundExpression receiverOrCondition, bool captureReceiver, int placeholderId, BoundExpression whenNotNull, BoundExpression whenNullOpt, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundLValuePlaceholder : BoundLValuePlaceholderBase {
    public BoundLValuePlaceholder(VisualBasicSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    public BoundLValuePlaceholder(VisualBasicSyntaxNode syntax, TypeSymbol type);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLValuePlaceholder Update(TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundLValuePlaceholderBase : BoundValuePlaceholderBase {
    public bool IsLValue { get; }
    protected BoundLValuePlaceholderBase(BoundKind kind, VisualBasicSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    protected BoundLValuePlaceholderBase(BoundKind kind, VisualBasicSyntaxNode syntax, TypeSymbol type);
    public sealed virtual bool get_IsLValue();
    protected sealed virtual BoundExpression MakeRValueImpl();
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundLValueToRValueWrapper : BoundExpression {
    private BoundExpression _UnderlyingLValue;
    public BoundExpression UnderlyingLValue { get; }
    public BoundLValueToRValueWrapper(VisualBasicSyntaxNode syntax, BoundExpression underlyingLValue, TypeSymbol type, bool hasErrors);
    public BoundExpression get_UnderlyingLValue();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundLValueToRValueWrapper Update(BoundExpression underlyingLValue, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundMeReference : BoundExpression {
    private InstanceReferenceKind IInstanceReferenceExpression_InstanceReferenceKind { get; }
    public BoundMeReference(VisualBasicSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    public BoundMeReference(VisualBasicSyntaxNode syntax, TypeSymbol type);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundMeReference Update(TypeSymbol type);
    private sealed virtual override InstanceReferenceKind get_IInstanceReferenceExpression_InstanceReferenceKind();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundMethodGroup : BoundMethodOrPropertyGroup {
    private BoundTypeArguments _TypeArgumentsOpt;
    private ImmutableArray`1<MethodSymbol> _Methods;
    private ExtensionMethodGroup _PendingExtensionMethodsOpt;
    private LookupResultKind _ResultKind;
    public BoundTypeArguments TypeArgumentsOpt { get; }
    public ImmutableArray`1<MethodSymbol> Methods { get; }
    public ExtensionMethodGroup PendingExtensionMethodsOpt { get; }
    public LookupResultKind ResultKind { get; }
    public BoundMethodGroup(VisualBasicSyntaxNode syntax, BoundTypeArguments typeArgumentsOpt, ImmutableArray`1<MethodSymbol> methods, ExtensionMethodGroup pendingExtensionMethodsOpt, LookupResultKind resultKind, BoundExpression receiverOpt, QualificationKind qualificationKind, bool hasErrors);
    public BoundMethodGroup(VisualBasicSyntaxNode syntax, BoundTypeArguments typeArgumentsOpt, ImmutableArray`1<MethodSymbol> methods, LookupResultKind resultKind, BoundExpression receiverOpt, QualificationKind qualificationKind, bool hasErrors);
    public BoundTypeArguments get_TypeArgumentsOpt();
    public ImmutableArray`1<MethodSymbol> get_Methods();
    public ExtensionMethodGroup get_PendingExtensionMethodsOpt();
    public virtual LookupResultKind get_ResultKind();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundMethodGroup Update(BoundTypeArguments typeArgumentsOpt, ImmutableArray`1<MethodSymbol> methods, ExtensionMethodGroup pendingExtensionMethodsOpt, LookupResultKind resultKind, BoundExpression receiverOpt, QualificationKind qualificationKind);
    public ImmutableArray`1<MethodSymbol> AdditionalExtensionMethods(HashSet`1& useSiteDiagnostics);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundMethodInfo : BoundExpression {
    private MethodSymbol _Method;
    public MethodSymbol Method { get; }
    public BoundMethodInfo(VisualBasicSyntaxNode syntax, MethodSymbol method, TypeSymbol type, bool hasErrors);
    public BoundMethodInfo(VisualBasicSyntaxNode syntax, MethodSymbol method, TypeSymbol type);
    public MethodSymbol get_Method();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundMethodInfo Update(MethodSymbol method, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundMethodOrPropertyGroup : BoundExpression {
    private BoundExpression _ReceiverOpt;
    private QualificationKind _QualificationKind;
    public BoundExpression ReceiverOpt { get; }
    public QualificationKind QualificationKind { get; }
    internal string MemberName { get; }
    internal TypeSymbol ContainerOfFirstInGroup { get; }
    protected BoundMethodOrPropertyGroup(BoundKind kind, VisualBasicSyntaxNode syntax, BoundExpression receiverOpt, QualificationKind qualificationKind, bool hasErrors);
    public BoundExpression get_ReceiverOpt();
    public QualificationKind get_QualificationKind();
    internal string get_MemberName();
    internal TypeSymbol get_ContainerOfFirstInGroup();
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundMidResult : BoundExpression {
    private BoundExpression _Original;
    private BoundExpression _Start;
    private BoundExpression _LengthOpt;
    private BoundExpression _Source;
    public BoundExpression Original { get; }
    public BoundExpression Start { get; }
    public BoundExpression LengthOpt { get; }
    public BoundExpression Source { get; }
    public BoundMidResult(VisualBasicSyntaxNode syntax, BoundExpression original, BoundExpression start, BoundExpression lengthOpt, BoundExpression source, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Original();
    public BoundExpression get_Start();
    public BoundExpression get_LengthOpt();
    public BoundExpression get_Source();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundMidResult Update(BoundExpression original, BoundExpression start, BoundExpression lengthOpt, BoundExpression source, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundMyBaseReference : BoundExpression {
    public bool SuppressVirtualCalls { get; }
    private InstanceReferenceKind IInstanceReferenceExpression_InstanceReferenceKind { get; }
    public BoundMyBaseReference(VisualBasicSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    public BoundMyBaseReference(VisualBasicSyntaxNode syntax, TypeSymbol type);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundMyBaseReference Update(TypeSymbol type);
    public sealed virtual bool get_SuppressVirtualCalls();
    private sealed virtual override InstanceReferenceKind get_IInstanceReferenceExpression_InstanceReferenceKind();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundMyClassReference : BoundExpression {
    public bool SuppressVirtualCalls { get; }
    private InstanceReferenceKind IInstanceReferenceExpression_InstanceReferenceKind { get; }
    public BoundMyClassReference(VisualBasicSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    public BoundMyClassReference(VisualBasicSyntaxNode syntax, TypeSymbol type);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundMyClassReference Update(TypeSymbol type);
    public sealed virtual bool get_SuppressVirtualCalls();
    private sealed virtual override InstanceReferenceKind get_IInstanceReferenceExpression_InstanceReferenceKind();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundNameOfOperator : BoundExpression {
    private BoundExpression _Argument;
    private ConstantValue _ConstantValueOpt;
    public BoundExpression Argument { get; }
    public ConstantValue ConstantValueOpt { get; }
    public BoundNameOfOperator(VisualBasicSyntaxNode syntax, BoundExpression argument, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Argument();
    public virtual ConstantValue get_ConstantValueOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundNameOfOperator Update(BoundExpression argument, ConstantValue constantValueOpt, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundNamespaceExpression : BoundExpression {
    private BoundExpression _UnevaluatedReceiverOpt;
    private AliasSymbol _AliasOpt;
    private NamespaceSymbol _NamespaceSymbol;
    public BoundExpression UnevaluatedReceiverOpt { get; }
    public AliasSymbol AliasOpt { get; }
    public NamespaceSymbol NamespaceSymbol { get; }
    public Symbol ExpressionSymbol { get; }
    public LookupResultKind ResultKind { get; }
    public BoundNamespaceExpression(VisualBasicSyntaxNode syntax, BoundExpression unevaluatedReceiverOpt, AliasSymbol aliasOpt, NamespaceSymbol namespaceSymbol, bool hasErrors);
    public BoundNamespaceExpression(VisualBasicSyntaxNode syntax, BoundExpression unevaluatedReceiverOpt, NamespaceSymbol namespaceSymbol, bool hasErrors);
    public BoundNamespaceExpression(VisualBasicSyntaxNode syntax, BoundExpression unevaluatedReceiverOpt, NamespaceSymbol namespaceSymbol);
    public BoundExpression get_UnevaluatedReceiverOpt();
    public AliasSymbol get_AliasOpt();
    public NamespaceSymbol get_NamespaceSymbol();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundNamespaceExpression Update(BoundExpression unevaluatedReceiverOpt, AliasSymbol aliasOpt, NamespaceSymbol namespaceSymbol);
    public virtual Symbol get_ExpressionSymbol();
    public virtual LookupResultKind get_ResultKind();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundNewT : BoundObjectCreationExpressionBase {
    public BoundNewT(VisualBasicSyntaxNode syntax, BoundObjectInitializerExpressionBase initializerOpt, TypeSymbol type, bool hasErrors);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundNewT Update(BoundObjectInitializerExpressionBase initializerOpt, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundNode : object {
    private BoundKind _kind;
    private BoundNodeAttributes _attributes;
    private VisualBasicSyntaxNode _syntax;
    public bool HasErrors { get; }
    public bool WasCompilerGenerated { get; }
    public BoundKind Kind { get; }
    public VisualBasicSyntaxNode Syntax { get; }
    public SyntaxTree SyntaxTree { get; }
    public BoundNode(BoundKind kind, VisualBasicSyntaxNode syntax);
    public BoundNode(BoundKind kind, VisualBasicSyntaxNode syntax, bool hasErrors);
    [ConditionalAttribute("DEBUG")]
private static void ValidateLocationInformation(BoundKind kind, SyntaxNode syntax);
    public bool get_HasErrors();
    public bool get_WasCompilerGenerated();
    public void SetWasCompilerGenerated();
    public BoundKind get_Kind();
    public VisualBasicSyntaxNode get_Syntax();
    public SyntaxTree get_SyntaxTree();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.BoundNodeExtensions : object {
    [ExtensionAttribute]
public static bool NonNullAndHasErrors(ImmutableArray`1<T> nodeArray);
    [ExtensionAttribute]
public static bool NonNullAndHasErrors(BoundNode node);
    [ExtensionAttribute]
public static T MakeCompilerGenerated(T this);
    [ExtensionAttribute]
public static Binder GetBinderFromLambda(BoundNode boundNode);
    [ExtensionAttribute]
public static bool IsAnyLambda(BoundNode boundNode);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundNodeFinder : BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator {
    private bool _convertInsufficientExecutionStackExceptionToCancelledByStackGuardException;
    private BoundNode _nodeToFind;
    private BoundNodeFinder(BoundNode _nodeToFind, int recursionDepth, bool convertInsufficientExecutionStackExceptionToCancelledByStackGuardException);
    public static bool ContainsNode(BoundNode findWhere, BoundNode findWhat, int recursionDepth, bool convertInsufficientExecutionStackExceptionToCancelledByStackGuardException);
    public virtual BoundNode Visit(BoundNode node);
    protected virtual bool ConvertInsufficientExecutionStackExceptionToCancelledByStackGuardException();
    public virtual BoundNode VisitUnboundLambda(UnboundLambda node);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundNodeSummary : ValueType {
    public BoundNode LowestBoundNode;
    public BoundNode HighestBoundNode;
    public BoundNode LowestBoundNodeOfSyntacticParent;
    public BoundNodeSummary(BoundNode lowestBound, BoundNode highestBound, BoundNode lowestBoundOfSyntacticParent);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundNoOpStatement : BoundStatement {
    private NoOpStatementFlavor _Flavor;
    public NoOpStatementFlavor Flavor { get; }
    public BoundNoOpStatement(VisualBasicSyntaxNode syntax, NoOpStatementFlavor flavor, bool hasErrors);
    public BoundNoOpStatement(VisualBasicSyntaxNode syntax, NoOpStatementFlavor flavor);
    public BoundNoOpStatement(VisualBasicSyntaxNode syntax);
    public BoundNoOpStatement(VisualBasicSyntaxNode syntax, bool hasErrors);
    public NoOpStatementFlavor get_Flavor();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundNoOpStatement Update(NoOpStatementFlavor flavor);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundNoPiaObjectCreationExpression : BoundObjectCreationExpressionBase {
    private string _GuidString;
    public string GuidString { get; }
    public BoundNoPiaObjectCreationExpression(VisualBasicSyntaxNode syntax, string guidString, BoundObjectInitializerExpressionBase initializerOpt, TypeSymbol type, bool hasErrors);
    public string get_GuidString();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundNoPiaObjectCreationExpression Update(string guidString, BoundObjectInitializerExpressionBase initializerOpt, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundNullableIsTrueOperator : BoundExpression {
    private BoundExpression _Operand;
    public BoundExpression Operand { get; }
    public BoundNullableIsTrueOperator(VisualBasicSyntaxNode syntax, BoundExpression operand, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Operand();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundNullableIsTrueOperator Update(BoundExpression operand, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundObjectCreationExpression : BoundObjectCreationExpressionBase {
    private MethodSymbol _ConstructorOpt;
    private BoundMethodGroup _MethodGroupOpt;
    private ImmutableArray`1<BoundExpression> _Arguments;
    private static ConditionalWeakTable`2<BoundObjectCreationExpression, object> s_memberInitializersMappings;
    public MethodSymbol ConstructorOpt { get; }
    public BoundMethodGroup MethodGroupOpt { get; }
    public ImmutableArray`1<BoundExpression> Arguments { get; }
    public Symbol ExpressionSymbol { get; }
    private IMethodSymbol IObjectCreationExpression_Constructor { get; }
    private ImmutableArray`1<IArgument> IHasArgumentsExpression_ArgumentsInParameterOrder { get; }
    private ImmutableArray`1<ISymbolInitializer> IObjectCreationExpression_MemberInitializers { get; }
    private static BoundObjectCreationExpression();
    public BoundObjectCreationExpression(VisualBasicSyntaxNode syntax, MethodSymbol constructorOpt, BoundMethodGroup methodGroupOpt, ImmutableArray`1<BoundExpression> arguments, BoundObjectInitializerExpressionBase initializerOpt, TypeSymbol type, bool hasErrors);
    public BoundObjectCreationExpression(VisualBasicSyntaxNode syntax, MethodSymbol constructorOpt, ImmutableArray`1<BoundExpression> arguments, BoundObjectInitializerExpressionBase initializerOpt, TypeSymbol type, bool hasErrors);
    public MethodSymbol get_ConstructorOpt();
    public BoundMethodGroup get_MethodGroupOpt();
    public ImmutableArray`1<BoundExpression> get_Arguments();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundObjectCreationExpression Update(MethodSymbol constructorOpt, BoundMethodGroup methodGroupOpt, ImmutableArray`1<BoundExpression> arguments, BoundObjectInitializerExpressionBase initializerOpt, TypeSymbol type);
    public BoundObjectCreationExpression Update(MethodSymbol constructorOpt, ImmutableArray`1<BoundExpression> arguments, BoundObjectInitializerExpressionBase initializerOpt, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    private sealed virtual override IArgument IHasArgumentExpression_GetArgumentMatchingParameter(IParameterSymbol parameter);
    private sealed virtual override IMethodSymbol get_IObjectCreationExpression_Constructor();
    private sealed virtual override ImmutableArray`1<IArgument> get_IHasArgumentsExpression_ArgumentsInParameterOrder();
    private sealed virtual override ImmutableArray`1<ISymbolInitializer> get_IObjectCreationExpression_MemberInitializers();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
private object _Lambda$__24-0(BoundObjectCreationExpression objectCreationStatement);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundObjectCreationExpressionBase : BoundExpression {
    private BoundObjectInitializerExpressionBase _InitializerOpt;
    public BoundObjectInitializerExpressionBase InitializerOpt { get; }
    protected BoundObjectCreationExpressionBase(BoundKind kind, VisualBasicSyntaxNode syntax, BoundObjectInitializerExpressionBase initializerOpt, TypeSymbol type, bool hasErrors);
    public BoundObjectInitializerExpressionBase get_InitializerOpt();
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundObjectInitializerExpression : BoundObjectInitializerExpressionBase {
    private bool _CreateTemporaryLocalForInitialization;
    private Binder _Binder;
    public bool CreateTemporaryLocalForInitialization { get; }
    public Binder Binder { get; }
    public BoundObjectInitializerExpression(VisualBasicSyntaxNode syntax, bool createTemporaryLocalForInitialization, Binder binder, BoundWithLValueExpressionPlaceholder placeholderOpt, ImmutableArray`1<BoundExpression> initializers, TypeSymbol type, bool hasErrors);
    public bool get_CreateTemporaryLocalForInitialization();
    public Binder get_Binder();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundObjectInitializerExpression Update(bool createTemporaryLocalForInitialization, Binder binder, BoundWithLValueExpressionPlaceholder placeholderOpt, ImmutableArray`1<BoundExpression> initializers, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundObjectInitializerExpressionBase : BoundExpression {
    private BoundWithLValueExpressionPlaceholder _PlaceholderOpt;
    private ImmutableArray`1<BoundExpression> _Initializers;
    public BoundWithLValueExpressionPlaceholder PlaceholderOpt { get; }
    public ImmutableArray`1<BoundExpression> Initializers { get; }
    protected BoundObjectInitializerExpressionBase(BoundKind kind, VisualBasicSyntaxNode syntax, BoundWithLValueExpressionPlaceholder placeholderOpt, ImmutableArray`1<BoundExpression> initializers, TypeSymbol type, bool hasErrors);
    public BoundWithLValueExpressionPlaceholder get_PlaceholderOpt();
    public ImmutableArray`1<BoundExpression> get_Initializers();
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundOmittedArgument : BoundExpression {
    public BoundOmittedArgument(VisualBasicSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    public BoundOmittedArgument(VisualBasicSyntaxNode syntax, TypeSymbol type);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundOmittedArgument Update(TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundOnErrorStatement : BoundStatement {
    private OnErrorStatementKind _OnErrorKind;
    private LabelSymbol _LabelOpt;
    private BoundExpression _LabelExpressionOpt;
    public OnErrorStatementKind OnErrorKind { get; }
    public LabelSymbol LabelOpt { get; }
    public BoundExpression LabelExpressionOpt { get; }
    public BoundOnErrorStatement(VisualBasicSyntaxNode syntax, OnErrorStatementKind onErrorKind, LabelSymbol labelOpt, BoundExpression labelExpressionOpt, bool hasErrors);
    public BoundOnErrorStatement(VisualBasicSyntaxNode syntax, LabelSymbol label, BoundExpression labelExpressionOpt, bool hasErrors);
    public OnErrorStatementKind get_OnErrorKind();
    public LabelSymbol get_LabelOpt();
    public BoundExpression get_LabelExpressionOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundOnErrorStatement Update(OnErrorStatementKind onErrorKind, LabelSymbol labelOpt, BoundExpression labelExpressionOpt);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundOrdering : BoundQueryPart {
    private BoundExpression _UnderlyingExpression;
    public BoundExpression UnderlyingExpression { get; }
    public Symbol ExpressionSymbol { get; }
    public LookupResultKind ResultKind { get; }
    public BoundOrdering(VisualBasicSyntaxNode syntax, BoundExpression underlyingExpression, TypeSymbol type, bool hasErrors);
    public BoundExpression get_UnderlyingExpression();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundOrdering Update(BoundExpression underlyingExpression, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    public virtual LookupResultKind get_ResultKind();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundParameter : BoundExpression {
    private ParameterSymbol _ParameterSymbol;
    private bool _IsLValue;
    private bool _SuppressVirtualCalls;
    public ParameterSymbol ParameterSymbol { get; }
    public bool IsLValue { get; }
    public bool SuppressVirtualCalls { get; }
    public Symbol ExpressionSymbol { get; }
    private IParameterSymbol IParameterReferenceExpression_Parameter { get; }
    public BoundParameter(VisualBasicSyntaxNode syntax, ParameterSymbol parameterSymbol, bool isLValue, bool suppressVirtualCalls, TypeSymbol type, bool hasErrors);
    public BoundParameter(VisualBasicSyntaxNode syntax, ParameterSymbol parameterSymbol, bool isLValue, bool suppressVirtualCalls, TypeSymbol type);
    public BoundParameter(VisualBasicSyntaxNode syntax, ParameterSymbol parameterSymbol, bool isLValue, TypeSymbol type, bool hasErrors);
    public BoundParameter(VisualBasicSyntaxNode syntax, ParameterSymbol parameterSymbol, bool isLValue, TypeSymbol type);
    public BoundParameter(VisualBasicSyntaxNode syntax, ParameterSymbol parameterSymbol, TypeSymbol type, bool hasErrors);
    public BoundParameter(VisualBasicSyntaxNode syntax, ParameterSymbol parameterSymbol, TypeSymbol type);
    public ParameterSymbol get_ParameterSymbol();
    public virtual bool get_IsLValue();
    public virtual bool get_SuppressVirtualCalls();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundParameter Update(ParameterSymbol parameterSymbol, bool isLValue, bool suppressVirtualCalls, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    protected virtual BoundExpression MakeRValueImpl();
    public BoundParameter MakeRValue();
    private sealed virtual override IParameterSymbol get_IParameterReferenceExpression_Parameter();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundParameterEqualsValue : BoundNode {
    private ParameterSymbol _Parameter;
    private BoundExpression _Value;
    public ParameterSymbol Parameter { get; }
    public BoundExpression Value { get; }
    private bool IOperation_IsInvalid { get; }
    private OperationKind IOperation_Kind { get; }
    private SyntaxNode IOperation_Syntax { get; }
    private IOperation ISymbolInitializer_Value { get; }
    private IParameterSymbol IParameterInitializer_Parameter { get; }
    private ITypeSymbol IOperation_Type { get; }
    private Optional`1<object> IOperation_ConstantValue { get; }
    public BoundParameterEqualsValue(VisualBasicSyntaxNode syntax, ParameterSymbol parameter, BoundExpression value, bool hasErrors);
    public ParameterSymbol get_Parameter();
    public BoundExpression get_Value();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundParameterEqualsValue Update(ParameterSymbol parameter, BoundExpression value);
    private sealed virtual override bool get_IOperation_IsInvalid();
    private sealed virtual override OperationKind get_IOperation_Kind();
    private sealed virtual override SyntaxNode get_IOperation_Syntax();
    private sealed virtual override IOperation get_ISymbolInitializer_Value();
    private sealed virtual override IParameterSymbol get_IParameterInitializer_Parameter();
    private sealed virtual override ITypeSymbol get_IOperation_Type();
    private sealed virtual override Optional`1<object> get_IOperation_ConstantValue();
    public sealed virtual override void Accept(OperationVisitor visitor);
    public sealed virtual override TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundParenthesized : BoundExpression {
    private BoundExpression _Expression;
    public BoundExpression Expression { get; }
    public ConstantValue ConstantValueOpt { get; }
    private IOperation IParenthesizedExpression_Operand { get; }
    public BoundParenthesized(VisualBasicSyntaxNode syntax, BoundExpression expression, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Expression();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundParenthesized Update(BoundExpression expression, TypeSymbol type);
    public virtual ConstantValue get_ConstantValueOpt();
    private sealed virtual override IOperation get_IParenthesizedExpression_Operand();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundPreviousSubmissionReference : BoundExpression {
    private NamedTypeSymbol _SourceType;
    public NamedTypeSymbol SourceType { get; }
    public BoundPreviousSubmissionReference(VisualBasicSyntaxNode syntax, NamedTypeSymbol sourceType, TypeSymbol type, bool hasErrors);
    public BoundPreviousSubmissionReference(VisualBasicSyntaxNode syntax, NamedTypeSymbol sourceType, TypeSymbol type);
    public NamedTypeSymbol get_SourceType();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundPreviousSubmissionReference Update(NamedTypeSymbol sourceType, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundPropertyAccess : BoundExpression {
    private PropertySymbol _PropertySymbol;
    private BoundPropertyGroup _PropertyGroupOpt;
    private PropertyAccessKind _AccessKind;
    private bool _IsWriteable;
    private BoundExpression _ReceiverOpt;
    private ImmutableArray`1<BoundExpression> _Arguments;
    public PropertySymbol PropertySymbol { get; }
    public BoundPropertyGroup PropertyGroupOpt { get; }
    public PropertyAccessKind AccessKind { get; }
    public bool IsWriteable { get; }
    public BoundExpression ReceiverOpt { get; }
    public ImmutableArray`1<BoundExpression> Arguments { get; }
    public Symbol ExpressionSymbol { get; }
    public LookupResultKind ResultKind { get; }
    private IOperation IMemberReferenceExpression_Instance { get; }
    private ISymbol IMemberReferenceExpression_Member { get; }
    private IPropertySymbol IPropertyReferenceExpression_Property { get; }
    private ImmutableArray`1<IArgument> IHasArgumentsExpression_ArgumentsInParameterOrder { get; }
    public BoundPropertyAccess(VisualBasicSyntaxNode syntax, PropertySymbol propertySymbol, BoundPropertyGroup propertyGroupOpt, PropertyAccessKind accessKind, bool isWriteable, BoundExpression receiverOpt, ImmutableArray`1<BoundExpression> arguments, TypeSymbol type, bool hasErrors);
    public BoundPropertyAccess(VisualBasicSyntaxNode syntax, PropertySymbol propertySymbol, BoundPropertyGroup propertyGroupOpt, PropertyAccessKind accessKind, bool isWriteable, BoundExpression receiverOpt, ImmutableArray`1<BoundExpression> arguments, bool hasErrors);
    public PropertySymbol get_PropertySymbol();
    public BoundPropertyGroup get_PropertyGroupOpt();
    public PropertyAccessKind get_AccessKind();
    public bool get_IsWriteable();
    public BoundExpression get_ReceiverOpt();
    public ImmutableArray`1<BoundExpression> get_Arguments();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundPropertyAccess Update(PropertySymbol propertySymbol, BoundPropertyGroup propertyGroupOpt, PropertyAccessKind accessKind, bool isWriteable, BoundExpression receiverOpt, ImmutableArray`1<BoundExpression> arguments, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    public BoundPropertyAccess SetAccessKind(PropertyAccessKind newAccessKind);
    public virtual LookupResultKind get_ResultKind();
    private static TypeSymbol GetTypeFromAccessKind(PropertySymbol property, PropertyAccessKind accessKind);
    private sealed virtual override IOperation get_IMemberReferenceExpression_Instance();
    private sealed virtual override ISymbol get_IMemberReferenceExpression_Member();
    private sealed virtual override IPropertySymbol get_IPropertyReferenceExpression_Property();
    private sealed virtual override ImmutableArray`1<IArgument> get_IHasArgumentsExpression_ArgumentsInParameterOrder();
    private sealed virtual override IArgument IHasArgumentsExpression_GetArgumentMatchingParameter(IParameterSymbol parameter);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundPropertyGroup : BoundMethodOrPropertyGroup {
    private ImmutableArray`1<PropertySymbol> _Properties;
    private LookupResultKind _ResultKind;
    public ImmutableArray`1<PropertySymbol> Properties { get; }
    public LookupResultKind ResultKind { get; }
    public BoundPropertyGroup(VisualBasicSyntaxNode syntax, ImmutableArray`1<PropertySymbol> properties, LookupResultKind resultKind, BoundExpression receiverOpt, QualificationKind qualificationKind, bool hasErrors);
    public ImmutableArray`1<PropertySymbol> get_Properties();
    public virtual LookupResultKind get_ResultKind();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundPropertyGroup Update(ImmutableArray`1<PropertySymbol> properties, LookupResultKind resultKind, BoundExpression receiverOpt, QualificationKind qualificationKind);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundPropertyInitializer : BoundFieldOrPropertyInitializer {
    private ImmutableArray`1<PropertySymbol> _InitializedProperties;
    public ImmutableArray`1<PropertySymbol> InitializedProperties { get; }
    private IPropertySymbol IPropertyInitializer_InitializedProperty { get; }
    private IOperation ISymbolInitializer_Value { get; }
    public BoundPropertyInitializer(VisualBasicSyntaxNode syntax, ImmutableArray`1<PropertySymbol> initializedProperties, BoundExpression memberAccessExpressionOpt, BoundExpression initialValue, bool hasErrors);
    public ImmutableArray`1<PropertySymbol> get_InitializedProperties();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundPropertyInitializer Update(ImmutableArray`1<PropertySymbol> initializedProperties, BoundExpression memberAccessExpressionOpt, BoundExpression initialValue);
    private sealed virtual override IPropertySymbol get_IPropertyInitializer_InitializedProperty();
    private sealed virtual override IOperation get_ISymbolInitializer_Value();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundPseudoVariable : BoundExpression {
    private LocalSymbol _LocalSymbol;
    private bool _IsLValue;
    private PseudoVariableExpressions _EmitExpressions;
    public LocalSymbol LocalSymbol { get; }
    public bool IsLValue { get; }
    public PseudoVariableExpressions EmitExpressions { get; }
    public BoundPseudoVariable(VisualBasicSyntaxNode syntax, LocalSymbol localSymbol, bool isLValue, PseudoVariableExpressions emitExpressions, TypeSymbol type, bool hasErrors);
    public BoundPseudoVariable(VisualBasicSyntaxNode syntax, LocalSymbol localSymbol, bool isLValue, PseudoVariableExpressions emitExpressions, TypeSymbol type);
    public LocalSymbol get_LocalSymbol();
    public virtual bool get_IsLValue();
    public PseudoVariableExpressions get_EmitExpressions();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundPseudoVariable Update(LocalSymbol localSymbol, bool isLValue, PseudoVariableExpressions emitExpressions, TypeSymbol type);
    protected virtual BoundExpression MakeRValueImpl();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundQueryableSource : BoundQueryClauseBase {
    private BoundQueryPart _Source;
    private RangeVariableSymbol _RangeVariableOpt;
    public BoundQueryPart Source { get; }
    public RangeVariableSymbol RangeVariableOpt { get; }
    public Symbol ExpressionSymbol { get; }
    public LookupResultKind ResultKind { get; }
    public BoundQueryableSource(VisualBasicSyntaxNode syntax, BoundQueryPart source, RangeVariableSymbol rangeVariableOpt, ImmutableArray`1<RangeVariableSymbol> rangeVariables, TypeSymbol compoundVariableType, ImmutableArray`1<Binder> binders, TypeSymbol type, bool hasErrors);
    public BoundQueryPart get_Source();
    public RangeVariableSymbol get_RangeVariableOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundQueryableSource Update(BoundQueryPart source, RangeVariableSymbol rangeVariableOpt, ImmutableArray`1<RangeVariableSymbol> rangeVariables, TypeSymbol compoundVariableType, ImmutableArray`1<Binder> binders, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    public virtual LookupResultKind get_ResultKind();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundQueryClause : BoundQueryClauseBase {
    private BoundExpression _UnderlyingExpression;
    public BoundExpression UnderlyingExpression { get; }
    public Symbol ExpressionSymbol { get; }
    public LookupResultKind ResultKind { get; }
    public BoundQueryClause(VisualBasicSyntaxNode syntax, BoundExpression underlyingExpression, ImmutableArray`1<RangeVariableSymbol> rangeVariables, TypeSymbol compoundVariableType, ImmutableArray`1<Binder> binders, TypeSymbol type, bool hasErrors);
    public BoundExpression get_UnderlyingExpression();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundQueryClause Update(BoundExpression underlyingExpression, ImmutableArray`1<RangeVariableSymbol> rangeVariables, TypeSymbol compoundVariableType, ImmutableArray`1<Binder> binders, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    public virtual LookupResultKind get_ResultKind();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundQueryClauseBase : BoundQueryPart {
    private ImmutableArray`1<RangeVariableSymbol> _RangeVariables;
    private TypeSymbol _CompoundVariableType;
    private ImmutableArray`1<Binder> _Binders;
    public ImmutableArray`1<RangeVariableSymbol> RangeVariables { get; }
    public TypeSymbol CompoundVariableType { get; }
    public ImmutableArray`1<Binder> Binders { get; }
    protected BoundQueryClauseBase(BoundKind kind, VisualBasicSyntaxNode syntax, ImmutableArray`1<RangeVariableSymbol> rangeVariables, TypeSymbol compoundVariableType, ImmutableArray`1<Binder> binders, TypeSymbol type, bool hasErrors);
    protected BoundQueryClauseBase(BoundKind kind, VisualBasicSyntaxNode syntax, ImmutableArray`1<RangeVariableSymbol> rangeVariables, TypeSymbol compoundVariableType, ImmutableArray`1<Binder> binders, TypeSymbol type);
    public ImmutableArray`1<RangeVariableSymbol> get_RangeVariables();
    public TypeSymbol get_CompoundVariableType();
    public ImmutableArray`1<Binder> get_Binders();
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundQueryExpression : BoundExpression {
    private BoundQueryClauseBase _LastOperator;
    public BoundQueryClauseBase LastOperator { get; }
    public BoundQueryExpression(VisualBasicSyntaxNode syntax, BoundQueryClauseBase lastOperator, TypeSymbol type, bool hasErrors);
    public BoundQueryClauseBase get_LastOperator();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundQueryExpression Update(BoundQueryClauseBase lastOperator, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundQueryLambda : BoundExpression {
    private SynthesizedLambdaSymbol _LambdaSymbol;
    private ImmutableArray`1<RangeVariableSymbol> _RangeVariables;
    private BoundExpression _Expression;
    private bool _ExprIsOperandOfConditionalBranch;
    public SynthesizedLambdaSymbol LambdaSymbol { get; }
    public ImmutableArray`1<RangeVariableSymbol> RangeVariables { get; }
    public BoundExpression Expression { get; }
    public bool ExprIsOperandOfConditionalBranch { get; }
    public BoundQueryLambda(VisualBasicSyntaxNode syntax, SynthesizedLambdaSymbol lambdaSymbol, ImmutableArray`1<RangeVariableSymbol> rangeVariables, BoundExpression expression, bool exprIsOperandOfConditionalBranch, bool hasErrors);
    public SynthesizedLambdaSymbol get_LambdaSymbol();
    public ImmutableArray`1<RangeVariableSymbol> get_RangeVariables();
    public BoundExpression get_Expression();
    public bool get_ExprIsOperandOfConditionalBranch();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundQueryLambda Update(SynthesizedLambdaSymbol lambdaSymbol, ImmutableArray`1<RangeVariableSymbol> rangeVariables, BoundExpression expression, bool exprIsOperandOfConditionalBranch);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundQueryPart : BoundExpression {
    protected BoundQueryPart(BoundKind kind, VisualBasicSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    protected BoundQueryPart(BoundKind kind, VisualBasicSyntaxNode syntax, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundQuerySource : BoundQueryPart {
    private BoundExpression _Expression;
    public BoundExpression Expression { get; }
    public Symbol ExpressionSymbol { get; }
    public LookupResultKind ResultKind { get; }
    public BoundQuerySource(VisualBasicSyntaxNode syntax, BoundExpression expression, TypeSymbol type, bool hasErrors);
    public BoundQuerySource(BoundExpression source);
    public BoundExpression get_Expression();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundQuerySource Update(BoundExpression expression, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    public virtual LookupResultKind get_ResultKind();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundRaiseEventStatement : BoundStatement {
    private EventSymbol _EventSymbol;
    private BoundExpression _EventInvocation;
    public EventSymbol EventSymbol { get; }
    public BoundExpression EventInvocation { get; }
    public IOperation Expression { get; }
    public BoundRaiseEventStatement(VisualBasicSyntaxNode syntax, EventSymbol eventSymbol, BoundExpression eventInvocation, bool hasErrors);
    public EventSymbol get_EventSymbol();
    public BoundExpression get_EventInvocation();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundRaiseEventStatement Update(EventSymbol eventSymbol, BoundExpression eventInvocation);
    public sealed virtual override IOperation get_Expression();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundRangeCaseClause : BoundCaseClause {
    private BoundExpression _LowerBoundOpt;
    private BoundExpression _UpperBoundOpt;
    private BoundExpression _LowerBoundConditionOpt;
    private BoundExpression _UpperBoundConditionOpt;
    public BoundExpression LowerBoundOpt { get; }
    public BoundExpression UpperBoundOpt { get; }
    public BoundExpression LowerBoundConditionOpt { get; }
    public BoundExpression UpperBoundConditionOpt { get; }
    private IOperation IRangeCaseClause_MaximumValue { get; }
    private IOperation IRangeCaseClause_MinimumValue { get; }
    protected OperationKind IOperation_Kind { get; }
    protected CaseKind ICaseClause_CaseKind { get; }
    public BoundRangeCaseClause(VisualBasicSyntaxNode syntax, BoundExpression lowerBoundOpt, BoundExpression upperBoundOpt, BoundExpression lowerBoundConditionOpt, BoundExpression upperBoundConditionOpt, bool hasErrors);
    public BoundExpression get_LowerBoundOpt();
    public BoundExpression get_UpperBoundOpt();
    public BoundExpression get_LowerBoundConditionOpt();
    public BoundExpression get_UpperBoundConditionOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundRangeCaseClause Update(BoundExpression lowerBoundOpt, BoundExpression upperBoundOpt, BoundExpression lowerBoundConditionOpt, BoundExpression upperBoundConditionOpt);
    private sealed virtual override IOperation get_IRangeCaseClause_MaximumValue();
    private sealed virtual override IOperation get_IRangeCaseClause_MinimumValue();
    protected virtual OperationKind get_IOperation_Kind();
    protected virtual CaseKind get_ICaseClause_CaseKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundRangeVariable : BoundExpression {
    private RangeVariableSymbol _RangeVariable;
    public RangeVariableSymbol RangeVariable { get; }
    public Symbol ExpressionSymbol { get; }
    public BoundRangeVariable(VisualBasicSyntaxNode syntax, RangeVariableSymbol rangeVariable, TypeSymbol type, bool hasErrors);
    public BoundRangeVariable(VisualBasicSyntaxNode syntax, RangeVariableSymbol rangeVariable, TypeSymbol type);
    public RangeVariableSymbol get_RangeVariable();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundRangeVariable Update(RangeVariableSymbol rangeVariable, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundRangeVariableAssignment : BoundQueryPart {
    private RangeVariableSymbol _RangeVariable;
    private BoundExpression _Value;
    public RangeVariableSymbol RangeVariable { get; }
    public BoundExpression Value { get; }
    public BoundRangeVariableAssignment(VisualBasicSyntaxNode syntax, RangeVariableSymbol rangeVariable, BoundExpression value, TypeSymbol type, bool hasErrors);
    public RangeVariableSymbol get_RangeVariable();
    public BoundExpression get_Value();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundRangeVariableAssignment Update(RangeVariableSymbol rangeVariable, BoundExpression value, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundRedimClause : BoundStatement {
    private BoundExpression _Operand;
    private ImmutableArray`1<BoundExpression> _Indices;
    private ArrayTypeSymbol _ArrayTypeOpt;
    private bool _Preserve;
    public BoundExpression Operand { get; }
    public ImmutableArray`1<BoundExpression> Indices { get; }
    public ArrayTypeSymbol ArrayTypeOpt { get; }
    public bool Preserve { get; }
    public BoundRedimClause(VisualBasicSyntaxNode syntax, BoundExpression operand, ImmutableArray`1<BoundExpression> indices, ArrayTypeSymbol arrayTypeOpt, bool preserve, bool hasErrors);
    public BoundExpression get_Operand();
    public ImmutableArray`1<BoundExpression> get_Indices();
    public ArrayTypeSymbol get_ArrayTypeOpt();
    public bool get_Preserve();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundRedimClause Update(BoundExpression operand, ImmutableArray`1<BoundExpression> indices, ArrayTypeSymbol arrayTypeOpt, bool preserve);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundRedimStatement : BoundStatement {
    private ImmutableArray`1<BoundRedimClause> _Clauses;
    public ImmutableArray`1<BoundRedimClause> Clauses { get; }
    public BoundRedimStatement(VisualBasicSyntaxNode syntax, ImmutableArray`1<BoundRedimClause> clauses, bool hasErrors);
    public ImmutableArray`1<BoundRedimClause> get_Clauses();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundRedimStatement Update(ImmutableArray`1<BoundRedimClause> clauses);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundReferenceAssignment : BoundExpression {
    private BoundLocal _ByRefLocal;
    private BoundExpression _LValue;
    private bool _IsLValue;
    public BoundLocal ByRefLocal { get; }
    public BoundExpression LValue { get; }
    public bool IsLValue { get; }
    public BoundReferenceAssignment(VisualBasicSyntaxNode syntax, BoundLocal byRefLocal, BoundExpression lValue, bool isLValue, TypeSymbol type, bool hasErrors);
    public BoundLocal get_ByRefLocal();
    public BoundExpression get_LValue();
    public virtual bool get_IsLValue();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundReferenceAssignment Update(BoundLocal byRefLocal, BoundExpression lValue, bool isLValue, TypeSymbol type);
    protected virtual BoundExpression MakeRValueImpl();
    public BoundReferenceAssignment MakeRValue();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundRelationalCaseClause : BoundCaseClause {
    private BinaryOperatorKind _OperatorKind;
    private BoundExpression _OperandOpt;
    private BoundExpression _ConditionOpt;
    public BinaryOperatorKind OperatorKind { get; }
    public BoundExpression OperandOpt { get; }
    public BoundExpression ConditionOpt { get; }
    private BinaryOperationKind IRelationalCaseClause_Relation { get; }
    private IOperation IRelationalCaseClause_Value { get; }
    protected OperationKind IOperation_Kind { get; }
    protected CaseKind ICaseClause_CaseKind { get; }
    public BoundRelationalCaseClause(VisualBasicSyntaxNode syntax, BinaryOperatorKind operatorKind, BoundExpression operandOpt, BoundExpression conditionOpt, bool hasErrors);
    public BinaryOperatorKind get_OperatorKind();
    public BoundExpression get_OperandOpt();
    public BoundExpression get_ConditionOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundRelationalCaseClause Update(BinaryOperatorKind operatorKind, BoundExpression operandOpt, BoundExpression conditionOpt);
    private sealed virtual override BinaryOperationKind get_IRelationalCaseClause_Relation();
    private sealed virtual override IOperation get_IRelationalCaseClause_Value();
    protected virtual OperationKind get_IOperation_Kind();
    protected virtual CaseKind get_ICaseClause_CaseKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundRemoveHandlerStatement : BoundAddRemoveHandlerStatement {
    protected IOperation IExpressionStatement_Expression { get; }
    public BoundRemoveHandlerStatement(VisualBasicSyntaxNode syntax, BoundExpression eventAccess, BoundExpression handler, bool hasErrors);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundRemoveHandlerStatement Update(BoundExpression eventAccess, BoundExpression handler);
    protected virtual IOperation get_IExpressionStatement_Expression();
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundResumeStatement : BoundStatement {
    private ResumeStatementKind _ResumeKind;
    private LabelSymbol _LabelOpt;
    private BoundExpression _LabelExpressionOpt;
    public ResumeStatementKind ResumeKind { get; }
    public LabelSymbol LabelOpt { get; }
    public BoundExpression LabelExpressionOpt { get; }
    public BoundResumeStatement(VisualBasicSyntaxNode syntax, ResumeStatementKind resumeKind, LabelSymbol labelOpt, BoundExpression labelExpressionOpt, bool hasErrors);
    public BoundResumeStatement(VisualBasicSyntaxNode syntax, bool isNext);
    public BoundResumeStatement(VisualBasicSyntaxNode syntax, LabelSymbol label, BoundExpression labelExpressionOpt, bool hasErrors);
    public ResumeStatementKind get_ResumeKind();
    public LabelSymbol get_LabelOpt();
    public BoundExpression get_LabelExpressionOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundResumeStatement Update(ResumeStatementKind resumeKind, LabelSymbol labelOpt, BoundExpression labelExpressionOpt);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundReturnStatement : BoundStatement {
    private BoundExpression _ExpressionOpt;
    private LocalSymbol _FunctionLocalOpt;
    private LabelSymbol _ExitLabelOpt;
    public BoundExpression ExpressionOpt { get; }
    public LocalSymbol FunctionLocalOpt { get; }
    public LabelSymbol ExitLabelOpt { get; }
    private IOperation IReturnStatement_ReturnedValue { get; }
    public BoundReturnStatement(VisualBasicSyntaxNode syntax, BoundExpression expressionOpt, LocalSymbol functionLocalOpt, LabelSymbol exitLabelOpt, bool hasErrors);
    public BoundExpression get_ExpressionOpt();
    public LocalSymbol get_FunctionLocalOpt();
    public LabelSymbol get_ExitLabelOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundReturnStatement Update(BoundExpression expressionOpt, LocalSymbol functionLocalOpt, LabelSymbol exitLabelOpt);
    internal bool IsEndOfMethodReturn();
    private sealed virtual override IOperation get_IReturnStatement_ReturnedValue();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholder : BoundRValuePlaceholderBase {
    public BoundRValuePlaceholder(VisualBasicSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    public BoundRValuePlaceholder(VisualBasicSyntaxNode syntax, TypeSymbol type);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundRValuePlaceholder Update(TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundRValuePlaceholderBase : BoundValuePlaceholderBase {
    protected BoundRValuePlaceholderBase(BoundKind kind, VisualBasicSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    protected BoundRValuePlaceholderBase(BoundKind kind, VisualBasicSyntaxNode syntax, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundSelectStatement : BoundStatement {
    private BoundExpressionStatement _ExpressionStatement;
    private BoundRValuePlaceholder _ExprPlaceholderOpt;
    private ImmutableArray`1<BoundCaseBlock> _CaseBlocks;
    private bool _RecommendSwitchTable;
    private LabelSymbol _ExitLabel;
    private static ConditionalWeakTable`2<BoundSelectStatement, object> s_caseBlocksMappings;
    public BoundExpressionStatement ExpressionStatement { get; }
    public BoundRValuePlaceholder ExprPlaceholderOpt { get; }
    public ImmutableArray`1<BoundCaseBlock> CaseBlocks { get; }
    public bool RecommendSwitchTable { get; }
    public LabelSymbol ExitLabel { get; }
    private ImmutableArray`1<ISwitchCase> ISwitchStatement_Cases { get; }
    private IOperation ISwitchStatement_Value { get; }
    private static BoundSelectStatement();
    public BoundSelectStatement(VisualBasicSyntaxNode syntax, BoundExpressionStatement expressionStatement, BoundRValuePlaceholder exprPlaceholderOpt, ImmutableArray`1<BoundCaseBlock> caseBlocks, bool recommendSwitchTable, LabelSymbol exitLabel, bool hasErrors);
    public BoundExpressionStatement get_ExpressionStatement();
    public BoundRValuePlaceholder get_ExprPlaceholderOpt();
    public ImmutableArray`1<BoundCaseBlock> get_CaseBlocks();
    public bool get_RecommendSwitchTable();
    public LabelSymbol get_ExitLabel();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundSelectStatement Update(BoundExpressionStatement expressionStatement, BoundRValuePlaceholder exprPlaceholderOpt, ImmutableArray`1<BoundCaseBlock> caseBlocks, bool recommendSwitchTable, LabelSymbol exitLabel);
    private sealed virtual override ImmutableArray`1<ISwitchCase> get_ISwitchStatement_Cases();
    private sealed virtual override IOperation get_ISwitchStatement_Value();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundSequence : BoundExpression {
    private ImmutableArray`1<LocalSymbol> _Locals;
    private ImmutableArray`1<BoundExpression> _SideEffects;
    private BoundExpression _ValueOpt;
    public ImmutableArray`1<LocalSymbol> Locals { get; }
    public ImmutableArray`1<BoundExpression> SideEffects { get; }
    public BoundExpression ValueOpt { get; }
    public bool IsLValue { get; }
    public BoundSequence(VisualBasicSyntaxNode syntax, ImmutableArray`1<LocalSymbol> locals, ImmutableArray`1<BoundExpression> sideEffects, BoundExpression valueOpt, TypeSymbol type, bool hasErrors);
    public ImmutableArray`1<LocalSymbol> get_Locals();
    public ImmutableArray`1<BoundExpression> get_SideEffects();
    public BoundExpression get_ValueOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundSequence Update(ImmutableArray`1<LocalSymbol> locals, ImmutableArray`1<BoundExpression> sideEffects, BoundExpression valueOpt, TypeSymbol type);
    public virtual bool get_IsLValue();
    protected virtual BoundExpression MakeRValueImpl();
    public BoundSequence MakeRValue();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundSequencePoint : BoundStatement {
    private BoundStatement _StatementOpt;
    public BoundStatement StatementOpt { get; }
    public BoundSequencePoint(VisualBasicSyntaxNode syntax, BoundStatement statementOpt, bool hasErrors);
    public BoundStatement get_StatementOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundSequencePoint Update(BoundStatement statementOpt);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundSequencePointExpression : BoundExpression {
    private BoundExpression _Expression;
    public BoundExpression Expression { get; }
    public bool IsLValue { get; }
    public BoundSequencePointExpression(VisualBasicSyntaxNode syntax, BoundExpression expression, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Expression();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundSequencePointExpression Update(BoundExpression expression, TypeSymbol type);
    public virtual bool get_IsLValue();
    protected virtual BoundExpression MakeRValueImpl();
    public BoundSequencePointExpression MakeRValue();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundSequencePointWithSpan : BoundStatement {
    private BoundStatement _StatementOpt;
    private TextSpan _Span;
    public BoundStatement StatementOpt { get; }
    public TextSpan Span { get; }
    public BoundSequencePointWithSpan(VisualBasicSyntaxNode syntax, BoundStatement statementOpt, TextSpan span, bool hasErrors);
    public BoundStatement get_StatementOpt();
    public TextSpan get_Span();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundSequencePointWithSpan Update(BoundStatement statementOpt, TextSpan span);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundSimpleCaseClause : BoundCaseClause {
    private BoundExpression _ValueOpt;
    private BoundExpression _ConditionOpt;
    public BoundExpression ValueOpt { get; }
    public BoundExpression ConditionOpt { get; }
    private BinaryOperationKind ISingleValueCaseClause_Equality { get; }
    private IOperation ISingleValueCaseClause_Value { get; }
    protected OperationKind IOperation_Kind { get; }
    protected CaseKind ICaseClause_CaseKind { get; }
    public BoundSimpleCaseClause(VisualBasicSyntaxNode syntax, BoundExpression valueOpt, BoundExpression conditionOpt, bool hasErrors);
    public BoundExpression get_ValueOpt();
    public BoundExpression get_ConditionOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundSimpleCaseClause Update(BoundExpression valueOpt, BoundExpression conditionOpt);
    private sealed virtual override BinaryOperationKind get_ISingleValueCaseClause_Equality();
    private sealed virtual override IOperation get_ISingleValueCaseClause_Value();
    protected virtual OperationKind get_IOperation_Kind();
    protected virtual CaseKind get_ICaseClause_CaseKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundSpillSequence : BoundExpression {
    private ImmutableArray`1<LocalSymbol> _Locals;
    private ImmutableArray`1<FieldSymbol> _SpillFields;
    private ImmutableArray`1<BoundStatement> _Statements;
    private BoundExpression _ValueOpt;
    public ImmutableArray`1<LocalSymbol> Locals { get; }
    public ImmutableArray`1<FieldSymbol> SpillFields { get; }
    public ImmutableArray`1<BoundStatement> Statements { get; }
    public BoundExpression ValueOpt { get; }
    public bool IsLValue { get; }
    public BoundSpillSequence(VisualBasicSyntaxNode syntax, ImmutableArray`1<LocalSymbol> locals, ImmutableArray`1<FieldSymbol> spillFields, ImmutableArray`1<BoundStatement> statements, BoundExpression valueOpt, TypeSymbol type, bool hasErrors);
    public ImmutableArray`1<LocalSymbol> get_Locals();
    public ImmutableArray`1<FieldSymbol> get_SpillFields();
    public ImmutableArray`1<BoundStatement> get_Statements();
    public BoundExpression get_ValueOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundSpillSequence Update(ImmutableArray`1<LocalSymbol> locals, ImmutableArray`1<FieldSymbol> spillFields, ImmutableArray`1<BoundStatement> statements, BoundExpression valueOpt, TypeSymbol type);
    public virtual bool get_IsLValue();
    protected virtual BoundExpression MakeRValueImpl();
    public BoundSpillSequence MakeRValue();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundStateMachineScope : BoundStatement {
    private ImmutableArray`1<FieldSymbol> _Fields;
    private BoundStatement _Statement;
    public ImmutableArray`1<FieldSymbol> Fields { get; }
    public BoundStatement Statement { get; }
    public BoundStateMachineScope(VisualBasicSyntaxNode syntax, ImmutableArray`1<FieldSymbol> fields, BoundStatement statement, bool hasErrors);
    public ImmutableArray`1<FieldSymbol> get_Fields();
    public BoundStatement get_Statement();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundStateMachineScope Update(ImmutableArray`1<FieldSymbol> fields, BoundStatement statement);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundStatement : BoundNode {
    private OperationKind IOperation_Kind { get; }
    private bool IOperation_IsInvalid { get; }
    private SyntaxNode IOperation_Syntax { get; }
    private ITypeSymbol IOperation_Type { get; }
    private Optional`1<object> IOperation_ConstantValue { get; }
    protected BoundStatement(BoundKind kind, VisualBasicSyntaxNode syntax, bool hasErrors);
    protected BoundStatement(BoundKind kind, VisualBasicSyntaxNode syntax);
    private sealed virtual override OperationKind get_IOperation_Kind();
    private sealed virtual override bool get_IOperation_IsInvalid();
    private sealed virtual override SyntaxNode get_IOperation_Syntax();
    private sealed virtual override ITypeSymbol get_IOperation_Type();
    private sealed virtual override Optional`1<object> get_IOperation_ConstantValue();
    protected abstract virtual OperationKind StatementKind();
    public abstract virtual override void Accept(OperationVisitor visitor);
    public abstract virtual override TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundStatementList : BoundStatement {
    private ImmutableArray`1<BoundStatement> _Statements;
    public ImmutableArray`1<BoundStatement> Statements { get; }
    public BoundStatementList(VisualBasicSyntaxNode syntax, ImmutableArray`1<BoundStatement> statements, bool hasErrors);
    public ImmutableArray`1<BoundStatement> get_Statements();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundStatementList Update(ImmutableArray`1<BoundStatement> statements);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundStopStatement : BoundStatement {
    public BoundStopStatement(VisualBasicSyntaxNode syntax, bool hasErrors);
    public BoundStopStatement(VisualBasicSyntaxNode syntax);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundSyncLockStatement : BoundStatement {
    private BoundExpression _LockExpression;
    private BoundBlock _Body;
    public BoundExpression LockExpression { get; }
    public BoundBlock Body { get; }
    private IOperation ILockStatement_LockedObject { get; }
    private IOperation ILockStatement_Body { get; }
    public BoundSyncLockStatement(VisualBasicSyntaxNode syntax, BoundExpression lockExpression, BoundBlock body, bool hasErrors);
    public BoundExpression get_LockExpression();
    public BoundBlock get_Body();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundSyncLockStatement Update(BoundExpression lockExpression, BoundBlock body);
    private sealed virtual override IOperation get_ILockStatement_LockedObject();
    private sealed virtual override IOperation get_ILockStatement_Body();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundTernaryConditionalExpression : BoundExpression {
    private BoundExpression _Condition;
    private BoundExpression _WhenTrue;
    private BoundExpression _WhenFalse;
    private ConstantValue _ConstantValueOpt;
    public BoundExpression Condition { get; }
    public BoundExpression WhenTrue { get; }
    public BoundExpression WhenFalse { get; }
    public ConstantValue ConstantValueOpt { get; }
    private IOperation IConditionalChoiceExpression_Condition { get; }
    private IOperation IConditionalChoiceExpression_IfFalseValue { get; }
    private IOperation IConditionalChoiceExpression_IfTrueValue { get; }
    public BoundTernaryConditionalExpression(VisualBasicSyntaxNode syntax, BoundExpression condition, BoundExpression whenTrue, BoundExpression whenFalse, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Condition();
    public BoundExpression get_WhenTrue();
    public BoundExpression get_WhenFalse();
    public virtual ConstantValue get_ConstantValueOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundTernaryConditionalExpression Update(BoundExpression condition, BoundExpression whenTrue, BoundExpression whenFalse, ConstantValue constantValueOpt, TypeSymbol type);
    private sealed virtual override IOperation get_IConditionalChoiceExpression_Condition();
    private sealed virtual override IOperation get_IConditionalChoiceExpression_IfFalseValue();
    private sealed virtual override IOperation get_IConditionalChoiceExpression_IfTrueValue();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundThrowStatement : BoundStatement {
    private BoundExpression _ExpressionOpt;
    public BoundExpression ExpressionOpt { get; }
    private IOperation IThrowStatement_ThrownObject { get; }
    public BoundThrowStatement(VisualBasicSyntaxNode syntax, BoundExpression expressionOpt, bool hasErrors);
    public BoundExpression get_ExpressionOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundThrowStatement Update(BoundExpression expressionOpt);
    private sealed virtual override IOperation get_IThrowStatement_ThrownObject();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundToQueryableCollectionConversion : BoundQueryPart {
    private BoundCall _ConversionCall;
    public BoundCall ConversionCall { get; }
    public Symbol ExpressionSymbol { get; }
    public LookupResultKind ResultKind { get; }
    public BoundToQueryableCollectionConversion(VisualBasicSyntaxNode syntax, BoundCall conversionCall, TypeSymbol type, bool hasErrors);
    public BoundToQueryableCollectionConversion(BoundCall call);
    public BoundCall get_ConversionCall();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundToQueryableCollectionConversion Update(BoundCall conversionCall, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    public virtual LookupResultKind get_ResultKind();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundTreeDumperNodeProducer : BoundTreeVisitor`2<object, TreeDumperNode> {
    public static TreeDumperNode MakeTree(BoundNode node);
    public virtual TreeDumperNode VisitTypeArguments(BoundTypeArguments node, object arg);
    public virtual TreeDumperNode VisitOmittedArgument(BoundOmittedArgument node, object arg);
    public virtual TreeDumperNode VisitLValueToRValueWrapper(BoundLValueToRValueWrapper node, object arg);
    public virtual TreeDumperNode VisitWithLValueExpressionPlaceholder(BoundWithLValueExpressionPlaceholder node, object arg);
    public virtual TreeDumperNode VisitWithRValueExpressionPlaceholder(BoundWithRValueExpressionPlaceholder node, object arg);
    public virtual TreeDumperNode VisitRValuePlaceholder(BoundRValuePlaceholder node, object arg);
    public virtual TreeDumperNode VisitLValuePlaceholder(BoundLValuePlaceholder node, object arg);
    public virtual TreeDumperNode VisitDup(BoundDup node, object arg);
    public virtual TreeDumperNode VisitBadExpression(BoundBadExpression node, object arg);
    public virtual TreeDumperNode VisitBadStatement(BoundBadStatement node, object arg);
    public virtual TreeDumperNode VisitParenthesized(BoundParenthesized node, object arg);
    public virtual TreeDumperNode VisitBadVariable(BoundBadVariable node, object arg);
    public virtual TreeDumperNode VisitArrayAccess(BoundArrayAccess node, object arg);
    public virtual TreeDumperNode VisitArrayLength(BoundArrayLength node, object arg);
    public virtual TreeDumperNode VisitGetType(BoundGetType node, object arg);
    public virtual TreeDumperNode VisitFieldInfo(BoundFieldInfo node, object arg);
    public virtual TreeDumperNode VisitMethodInfo(BoundMethodInfo node, object arg);
    public virtual TreeDumperNode VisitTypeExpression(BoundTypeExpression node, object arg);
    public virtual TreeDumperNode VisitTypeOrValueExpression(BoundTypeOrValueExpression node, object arg);
    public virtual TreeDumperNode VisitNamespaceExpression(BoundNamespaceExpression node, object arg);
    public virtual TreeDumperNode VisitUnaryOperator(BoundUnaryOperator node, object arg);
    public virtual TreeDumperNode VisitUserDefinedUnaryOperator(BoundUserDefinedUnaryOperator node, object arg);
    public virtual TreeDumperNode VisitNullableIsTrueOperator(BoundNullableIsTrueOperator node, object arg);
    public virtual TreeDumperNode VisitBinaryOperator(BoundBinaryOperator node, object arg);
    public virtual TreeDumperNode VisitUserDefinedBinaryOperator(BoundUserDefinedBinaryOperator node, object arg);
    public virtual TreeDumperNode VisitUserDefinedShortCircuitingOperator(BoundUserDefinedShortCircuitingOperator node, object arg);
    public virtual TreeDumperNode VisitCompoundAssignmentTargetPlaceholder(BoundCompoundAssignmentTargetPlaceholder node, object arg);
    public virtual TreeDumperNode VisitAssignmentOperator(BoundAssignmentOperator node, object arg);
    public virtual TreeDumperNode VisitReferenceAssignment(BoundReferenceAssignment node, object arg);
    public virtual TreeDumperNode VisitAddressOfOperator(BoundAddressOfOperator node, object arg);
    public virtual TreeDumperNode VisitTernaryConditionalExpression(BoundTernaryConditionalExpression node, object arg);
    public virtual TreeDumperNode VisitBinaryConditionalExpression(BoundBinaryConditionalExpression node, object arg);
    public virtual TreeDumperNode VisitConversion(BoundConversion node, object arg);
    public virtual TreeDumperNode VisitUserDefinedConversion(BoundUserDefinedConversion node, object arg);
    public virtual TreeDumperNode VisitDirectCast(BoundDirectCast node, object arg);
    public virtual TreeDumperNode VisitTryCast(BoundTryCast node, object arg);
    public virtual TreeDumperNode VisitTypeOf(BoundTypeOf node, object arg);
    public virtual TreeDumperNode VisitSequencePoint(BoundSequencePoint node, object arg);
    public virtual TreeDumperNode VisitSequencePointExpression(BoundSequencePointExpression node, object arg);
    public virtual TreeDumperNode VisitSequencePointWithSpan(BoundSequencePointWithSpan node, object arg);
    public virtual TreeDumperNode VisitNoOpStatement(BoundNoOpStatement node, object arg);
    public virtual TreeDumperNode VisitMethodGroup(BoundMethodGroup node, object arg);
    public virtual TreeDumperNode VisitPropertyGroup(BoundPropertyGroup node, object arg);
    public virtual TreeDumperNode VisitReturnStatement(BoundReturnStatement node, object arg);
    public virtual TreeDumperNode VisitYieldStatement(BoundYieldStatement node, object arg);
    public virtual TreeDumperNode VisitThrowStatement(BoundThrowStatement node, object arg);
    public virtual TreeDumperNode VisitRedimStatement(BoundRedimStatement node, object arg);
    public virtual TreeDumperNode VisitRedimClause(BoundRedimClause node, object arg);
    public virtual TreeDumperNode VisitEraseStatement(BoundEraseStatement node, object arg);
    public virtual TreeDumperNode VisitCall(BoundCall node, object arg);
    public virtual TreeDumperNode VisitAttribute(BoundAttribute node, object arg);
    public virtual TreeDumperNode VisitLateMemberAccess(BoundLateMemberAccess node, object arg);
    public virtual TreeDumperNode VisitLateInvocation(BoundLateInvocation node, object arg);
    public virtual TreeDumperNode VisitLateAddressOfOperator(BoundLateAddressOfOperator node, object arg);
    public virtual TreeDumperNode VisitObjectCreationExpression(BoundObjectCreationExpression node, object arg);
    public virtual TreeDumperNode VisitNoPiaObjectCreationExpression(BoundNoPiaObjectCreationExpression node, object arg);
    public virtual TreeDumperNode VisitAnonymousTypeCreationExpression(BoundAnonymousTypeCreationExpression node, object arg);
    public virtual TreeDumperNode VisitAnonymousTypePropertyAccess(BoundAnonymousTypePropertyAccess node, object arg);
    public virtual TreeDumperNode VisitAnonymousTypeFieldInitializer(BoundAnonymousTypeFieldInitializer node, object arg);
    public virtual TreeDumperNode VisitObjectInitializerExpression(BoundObjectInitializerExpression node, object arg);
    public virtual TreeDumperNode VisitCollectionInitializerExpression(BoundCollectionInitializerExpression node, object arg);
    public virtual TreeDumperNode VisitNewT(BoundNewT node, object arg);
    public virtual TreeDumperNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node, object arg);
    public virtual TreeDumperNode VisitArrayCreation(BoundArrayCreation node, object arg);
    public virtual TreeDumperNode VisitArrayLiteral(BoundArrayLiteral node, object arg);
    public virtual TreeDumperNode VisitArrayInitialization(BoundArrayInitialization node, object arg);
    public virtual TreeDumperNode VisitFieldAccess(BoundFieldAccess node, object arg);
    public virtual TreeDumperNode VisitPropertyAccess(BoundPropertyAccess node, object arg);
    public virtual TreeDumperNode VisitEventAccess(BoundEventAccess node, object arg);
    public virtual TreeDumperNode VisitBlock(BoundBlock node, object arg);
    public virtual TreeDumperNode VisitStateMachineScope(BoundStateMachineScope node, object arg);
    public virtual TreeDumperNode VisitLocalDeclaration(BoundLocalDeclaration node, object arg);
    public virtual TreeDumperNode VisitAsNewLocalDeclarations(BoundAsNewLocalDeclarations node, object arg);
    public virtual TreeDumperNode VisitDimStatement(BoundDimStatement node, object arg);
    public virtual TreeDumperNode VisitInitializer(BoundInitializer node, object arg);
    public virtual TreeDumperNode VisitFieldInitializer(BoundFieldInitializer node, object arg);
    public virtual TreeDumperNode VisitPropertyInitializer(BoundPropertyInitializer node, object arg);
    public virtual TreeDumperNode VisitParameterEqualsValue(BoundParameterEqualsValue node, object arg);
    public virtual TreeDumperNode VisitGlobalStatementInitializer(BoundGlobalStatementInitializer node, object arg);
    public virtual TreeDumperNode VisitSequence(BoundSequence node, object arg);
    public virtual TreeDumperNode VisitExpressionStatement(BoundExpressionStatement node, object arg);
    public virtual TreeDumperNode VisitIfStatement(BoundIfStatement node, object arg);
    public virtual TreeDumperNode VisitSelectStatement(BoundSelectStatement node, object arg);
    public virtual TreeDumperNode VisitCaseBlock(BoundCaseBlock node, object arg);
    public virtual TreeDumperNode VisitCaseStatement(BoundCaseStatement node, object arg);
    public virtual TreeDumperNode VisitSimpleCaseClause(BoundSimpleCaseClause node, object arg);
    public virtual TreeDumperNode VisitRangeCaseClause(BoundRangeCaseClause node, object arg);
    public virtual TreeDumperNode VisitRelationalCaseClause(BoundRelationalCaseClause node, object arg);
    public virtual TreeDumperNode VisitDoLoopStatement(BoundDoLoopStatement node, object arg);
    public virtual TreeDumperNode VisitWhileStatement(BoundWhileStatement node, object arg);
    public virtual TreeDumperNode VisitForToUserDefinedOperators(BoundForToUserDefinedOperators node, object arg);
    public virtual TreeDumperNode VisitForToStatement(BoundForToStatement node, object arg);
    public virtual TreeDumperNode VisitForEachStatement(BoundForEachStatement node, object arg);
    public virtual TreeDumperNode VisitExitStatement(BoundExitStatement node, object arg);
    public virtual TreeDumperNode VisitContinueStatement(BoundContinueStatement node, object arg);
    public virtual TreeDumperNode VisitTryStatement(BoundTryStatement node, object arg);
    public virtual TreeDumperNode VisitCatchBlock(BoundCatchBlock node, object arg);
    public virtual TreeDumperNode VisitLiteral(BoundLiteral node, object arg);
    public virtual TreeDumperNode VisitMeReference(BoundMeReference node, object arg);
    public virtual TreeDumperNode VisitValueTypeMeReference(BoundValueTypeMeReference node, object arg);
    public virtual TreeDumperNode VisitMyBaseReference(BoundMyBaseReference node, object arg);
    public virtual TreeDumperNode VisitMyClassReference(BoundMyClassReference node, object arg);
    public virtual TreeDumperNode VisitPreviousSubmissionReference(BoundPreviousSubmissionReference node, object arg);
    public virtual TreeDumperNode VisitHostObjectMemberReference(BoundHostObjectMemberReference node, object arg);
    public virtual TreeDumperNode VisitLocal(BoundLocal node, object arg);
    public virtual TreeDumperNode VisitPseudoVariable(BoundPseudoVariable node, object arg);
    public virtual TreeDumperNode VisitParameter(BoundParameter node, object arg);
    public virtual TreeDumperNode VisitByRefArgumentPlaceholder(BoundByRefArgumentPlaceholder node, object arg);
    public virtual TreeDumperNode VisitByRefArgumentWithCopyBack(BoundByRefArgumentWithCopyBack node, object arg);
    public virtual TreeDumperNode VisitLateBoundArgumentSupportingAssignmentWithCapture(BoundLateBoundArgumentSupportingAssignmentWithCapture node, object arg);
    public virtual TreeDumperNode VisitLabelStatement(BoundLabelStatement node, object arg);
    public virtual TreeDumperNode VisitLabel(BoundLabel node, object arg);
    public virtual TreeDumperNode VisitGotoStatement(BoundGotoStatement node, object arg);
    public virtual TreeDumperNode VisitStatementList(BoundStatementList node, object arg);
    public virtual TreeDumperNode VisitConditionalGoto(BoundConditionalGoto node, object arg);
    public virtual TreeDumperNode VisitWithStatement(BoundWithStatement node, object arg);
    public virtual TreeDumperNode VisitUnboundLambda(UnboundLambda node, object arg);
    public virtual TreeDumperNode VisitLambda(BoundLambda node, object arg);
    public virtual TreeDumperNode VisitQueryExpression(BoundQueryExpression node, object arg);
    public virtual TreeDumperNode VisitQuerySource(BoundQuerySource node, object arg);
    public virtual TreeDumperNode VisitToQueryableCollectionConversion(BoundToQueryableCollectionConversion node, object arg);
    public virtual TreeDumperNode VisitQueryableSource(BoundQueryableSource node, object arg);
    public virtual TreeDumperNode VisitQueryClause(BoundQueryClause node, object arg);
    public virtual TreeDumperNode VisitOrdering(BoundOrdering node, object arg);
    public virtual TreeDumperNode VisitQueryLambda(BoundQueryLambda node, object arg);
    public virtual TreeDumperNode VisitRangeVariableAssignment(BoundRangeVariableAssignment node, object arg);
    public virtual TreeDumperNode VisitGroupTypeInferenceLambda(GroupTypeInferenceLambda node, object arg);
    public virtual TreeDumperNode VisitAggregateClause(BoundAggregateClause node, object arg);
    public virtual TreeDumperNode VisitGroupAggregation(BoundGroupAggregation node, object arg);
    public virtual TreeDumperNode VisitRangeVariable(BoundRangeVariable node, object arg);
    public virtual TreeDumperNode VisitAddHandlerStatement(BoundAddHandlerStatement node, object arg);
    public virtual TreeDumperNode VisitRemoveHandlerStatement(BoundRemoveHandlerStatement node, object arg);
    public virtual TreeDumperNode VisitRaiseEventStatement(BoundRaiseEventStatement node, object arg);
    public virtual TreeDumperNode VisitUsingStatement(BoundUsingStatement node, object arg);
    public virtual TreeDumperNode VisitSyncLockStatement(BoundSyncLockStatement node, object arg);
    public virtual TreeDumperNode VisitXmlName(BoundXmlName node, object arg);
    public virtual TreeDumperNode VisitXmlNamespace(BoundXmlNamespace node, object arg);
    public virtual TreeDumperNode VisitXmlDocument(BoundXmlDocument node, object arg);
    public virtual TreeDumperNode VisitXmlDeclaration(BoundXmlDeclaration node, object arg);
    public virtual TreeDumperNode VisitXmlProcessingInstruction(BoundXmlProcessingInstruction node, object arg);
    public virtual TreeDumperNode VisitXmlComment(BoundXmlComment node, object arg);
    public virtual TreeDumperNode VisitXmlAttribute(BoundXmlAttribute node, object arg);
    public virtual TreeDumperNode VisitXmlElement(BoundXmlElement node, object arg);
    public virtual TreeDumperNode VisitXmlMemberAccess(BoundXmlMemberAccess node, object arg);
    public virtual TreeDumperNode VisitXmlEmbeddedExpression(BoundXmlEmbeddedExpression node, object arg);
    public virtual TreeDumperNode VisitXmlCData(BoundXmlCData node, object arg);
    public virtual TreeDumperNode VisitResumeStatement(BoundResumeStatement node, object arg);
    public virtual TreeDumperNode VisitOnErrorStatement(BoundOnErrorStatement node, object arg);
    public virtual TreeDumperNode VisitUnstructuredExceptionHandlingStatement(BoundUnstructuredExceptionHandlingStatement node, object arg);
    public virtual TreeDumperNode VisitUnstructuredExceptionHandlingCatchFilter(BoundUnstructuredExceptionHandlingCatchFilter node, object arg);
    public virtual TreeDumperNode VisitUnstructuredExceptionOnErrorSwitch(BoundUnstructuredExceptionOnErrorSwitch node, object arg);
    public virtual TreeDumperNode VisitUnstructuredExceptionResumeSwitch(BoundUnstructuredExceptionResumeSwitch node, object arg);
    public virtual TreeDumperNode VisitAwaitOperator(BoundAwaitOperator node, object arg);
    public virtual TreeDumperNode VisitSpillSequence(BoundSpillSequence node, object arg);
    public virtual TreeDumperNode VisitStopStatement(BoundStopStatement node, object arg);
    public virtual TreeDumperNode VisitEndStatement(BoundEndStatement node, object arg);
    public virtual TreeDumperNode VisitMidResult(BoundMidResult node, object arg);
    public virtual TreeDumperNode VisitConditionalAccess(BoundConditionalAccess node, object arg);
    public virtual TreeDumperNode VisitConditionalAccessReceiverPlaceholder(BoundConditionalAccessReceiverPlaceholder node, object arg);
    public virtual TreeDumperNode VisitLoweredConditionalAccess(BoundLoweredConditionalAccess node, object arg);
    public virtual TreeDumperNode VisitComplexConditionalAccessReceiver(BoundComplexConditionalAccessReceiver node, object arg);
    public virtual TreeDumperNode VisitNameOfOperator(BoundNameOfOperator node, object arg);
    public virtual TreeDumperNode VisitTypeAsValueExpression(BoundTypeAsValueExpression node, object arg);
    public virtual TreeDumperNode VisitInterpolatedStringExpression(BoundInterpolatedStringExpression node, object arg);
    public virtual TreeDumperNode VisitInterpolation(BoundInterpolation node, object arg);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__10-0(BoundNode x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__11-0(BoundNode x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__14-0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__48-0(BoundRedimClause x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__49-0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__50-0(BoundAssignmentOperator x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__51-0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__52-0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__52-1(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__54-0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__56-0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__58-0(BoundAnonymousTypePropertyAccess x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__58-1(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__61-0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__62-0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__65-0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__66-0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__67-0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__69-0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__71-0(BoundStatement x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__74-0(BoundLocalDeclaration x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__75-0(BoundLocalDeclarationBase x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__81-0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__84-0(BoundCaseBlock x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__86-0(BoundCaseClause x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__93-0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__94-0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__97-0(BoundCatchBlock x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__115-0(BoundStatement x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__135-0(BoundLocalDeclarationBase x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__139-0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__144-0(BoundExpression x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__152-0(BoundGotoStatement x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__153-0(BoundGotoStatement x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__155-0(BoundStatement x);
    [CompilerGeneratedAttribute]
private TreeDumperNode _Lambda$__165-0(BoundNode x);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundTreeRewriter : BoundTreeVisitor {
    public virtual BoundNode VisitTypeArguments(BoundTypeArguments node);
    public virtual BoundNode VisitOmittedArgument(BoundOmittedArgument node);
    public virtual BoundNode VisitLValueToRValueWrapper(BoundLValueToRValueWrapper node);
    public virtual BoundNode VisitWithLValueExpressionPlaceholder(BoundWithLValueExpressionPlaceholder node);
    public virtual BoundNode VisitWithRValueExpressionPlaceholder(BoundWithRValueExpressionPlaceholder node);
    public virtual BoundNode VisitRValuePlaceholder(BoundRValuePlaceholder node);
    public virtual BoundNode VisitLValuePlaceholder(BoundLValuePlaceholder node);
    public virtual BoundNode VisitDup(BoundDup node);
    public virtual BoundNode VisitBadExpression(BoundBadExpression node);
    public virtual BoundNode VisitBadStatement(BoundBadStatement node);
    public virtual BoundNode VisitParenthesized(BoundParenthesized node);
    public virtual BoundNode VisitBadVariable(BoundBadVariable node);
    public virtual BoundNode VisitArrayAccess(BoundArrayAccess node);
    public virtual BoundNode VisitArrayLength(BoundArrayLength node);
    public virtual BoundNode VisitGetType(BoundGetType node);
    public virtual BoundNode VisitFieldInfo(BoundFieldInfo node);
    public virtual BoundNode VisitMethodInfo(BoundMethodInfo node);
    public virtual BoundNode VisitTypeExpression(BoundTypeExpression node);
    public virtual BoundNode VisitTypeOrValueExpression(BoundTypeOrValueExpression node);
    public virtual BoundNode VisitNamespaceExpression(BoundNamespaceExpression node);
    public virtual BoundNode VisitUnaryOperator(BoundUnaryOperator node);
    public virtual BoundNode VisitUserDefinedUnaryOperator(BoundUserDefinedUnaryOperator node);
    public virtual BoundNode VisitNullableIsTrueOperator(BoundNullableIsTrueOperator node);
    public virtual BoundNode VisitBinaryOperator(BoundBinaryOperator node);
    public virtual BoundNode VisitUserDefinedBinaryOperator(BoundUserDefinedBinaryOperator node);
    public virtual BoundNode VisitUserDefinedShortCircuitingOperator(BoundUserDefinedShortCircuitingOperator node);
    public virtual BoundNode VisitCompoundAssignmentTargetPlaceholder(BoundCompoundAssignmentTargetPlaceholder node);
    public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node);
    public virtual BoundNode VisitReferenceAssignment(BoundReferenceAssignment node);
    public virtual BoundNode VisitAddressOfOperator(BoundAddressOfOperator node);
    public virtual BoundNode VisitTernaryConditionalExpression(BoundTernaryConditionalExpression node);
    public virtual BoundNode VisitBinaryConditionalExpression(BoundBinaryConditionalExpression node);
    public virtual BoundNode VisitConversion(BoundConversion node);
    public virtual BoundNode VisitUserDefinedConversion(BoundUserDefinedConversion node);
    public virtual BoundNode VisitDirectCast(BoundDirectCast node);
    public virtual BoundNode VisitTryCast(BoundTryCast node);
    public virtual BoundNode VisitTypeOf(BoundTypeOf node);
    public virtual BoundNode VisitSequencePoint(BoundSequencePoint node);
    public virtual BoundNode VisitSequencePointExpression(BoundSequencePointExpression node);
    public virtual BoundNode VisitSequencePointWithSpan(BoundSequencePointWithSpan node);
    public virtual BoundNode VisitNoOpStatement(BoundNoOpStatement node);
    public virtual BoundNode VisitMethodGroup(BoundMethodGroup node);
    public virtual BoundNode VisitPropertyGroup(BoundPropertyGroup node);
    public virtual BoundNode VisitReturnStatement(BoundReturnStatement node);
    public virtual BoundNode VisitYieldStatement(BoundYieldStatement node);
    public virtual BoundNode VisitThrowStatement(BoundThrowStatement node);
    public virtual BoundNode VisitRedimStatement(BoundRedimStatement node);
    public virtual BoundNode VisitRedimClause(BoundRedimClause node);
    public virtual BoundNode VisitEraseStatement(BoundEraseStatement node);
    public virtual BoundNode VisitCall(BoundCall node);
    public virtual BoundNode VisitAttribute(BoundAttribute node);
    public virtual BoundNode VisitLateMemberAccess(BoundLateMemberAccess node);
    public virtual BoundNode VisitLateInvocation(BoundLateInvocation node);
    public virtual BoundNode VisitLateAddressOfOperator(BoundLateAddressOfOperator node);
    public virtual BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node);
    public virtual BoundNode VisitNoPiaObjectCreationExpression(BoundNoPiaObjectCreationExpression node);
    public virtual BoundNode VisitAnonymousTypeCreationExpression(BoundAnonymousTypeCreationExpression node);
    public virtual BoundNode VisitAnonymousTypePropertyAccess(BoundAnonymousTypePropertyAccess node);
    public virtual BoundNode VisitAnonymousTypeFieldInitializer(BoundAnonymousTypeFieldInitializer node);
    public virtual BoundNode VisitObjectInitializerExpression(BoundObjectInitializerExpression node);
    public virtual BoundNode VisitCollectionInitializerExpression(BoundCollectionInitializerExpression node);
    public virtual BoundNode VisitNewT(BoundNewT node);
    public virtual BoundNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node);
    public virtual BoundNode VisitArrayCreation(BoundArrayCreation node);
    public virtual BoundNode VisitArrayLiteral(BoundArrayLiteral node);
    public virtual BoundNode VisitArrayInitialization(BoundArrayInitialization node);
    public virtual BoundNode VisitFieldAccess(BoundFieldAccess node);
    public virtual BoundNode VisitPropertyAccess(BoundPropertyAccess node);
    public virtual BoundNode VisitEventAccess(BoundEventAccess node);
    public virtual BoundNode VisitBlock(BoundBlock node);
    public virtual BoundNode VisitStateMachineScope(BoundStateMachineScope node);
    public virtual BoundNode VisitLocalDeclaration(BoundLocalDeclaration node);
    public virtual BoundNode VisitAsNewLocalDeclarations(BoundAsNewLocalDeclarations node);
    public virtual BoundNode VisitDimStatement(BoundDimStatement node);
    public virtual BoundNode VisitInitializer(BoundInitializer node);
    public virtual BoundNode VisitFieldInitializer(BoundFieldInitializer node);
    public virtual BoundNode VisitPropertyInitializer(BoundPropertyInitializer node);
    public virtual BoundNode VisitParameterEqualsValue(BoundParameterEqualsValue node);
    public virtual BoundNode VisitGlobalStatementInitializer(BoundGlobalStatementInitializer node);
    public virtual BoundNode VisitSequence(BoundSequence node);
    public virtual BoundNode VisitExpressionStatement(BoundExpressionStatement node);
    public virtual BoundNode VisitIfStatement(BoundIfStatement node);
    public virtual BoundNode VisitSelectStatement(BoundSelectStatement node);
    public virtual BoundNode VisitCaseBlock(BoundCaseBlock node);
    public virtual BoundNode VisitCaseStatement(BoundCaseStatement node);
    public virtual BoundNode VisitSimpleCaseClause(BoundSimpleCaseClause node);
    public virtual BoundNode VisitRangeCaseClause(BoundRangeCaseClause node);
    public virtual BoundNode VisitRelationalCaseClause(BoundRelationalCaseClause node);
    public virtual BoundNode VisitDoLoopStatement(BoundDoLoopStatement node);
    public virtual BoundNode VisitWhileStatement(BoundWhileStatement node);
    public virtual BoundNode VisitForToUserDefinedOperators(BoundForToUserDefinedOperators node);
    public virtual BoundNode VisitForToStatement(BoundForToStatement node);
    public virtual BoundNode VisitForEachStatement(BoundForEachStatement node);
    public virtual BoundNode VisitExitStatement(BoundExitStatement node);
    public virtual BoundNode VisitContinueStatement(BoundContinueStatement node);
    public virtual BoundNode VisitTryStatement(BoundTryStatement node);
    public virtual BoundNode VisitCatchBlock(BoundCatchBlock node);
    public virtual BoundNode VisitLiteral(BoundLiteral node);
    public virtual BoundNode VisitMeReference(BoundMeReference node);
    public virtual BoundNode VisitValueTypeMeReference(BoundValueTypeMeReference node);
    public virtual BoundNode VisitMyBaseReference(BoundMyBaseReference node);
    public virtual BoundNode VisitMyClassReference(BoundMyClassReference node);
    public virtual BoundNode VisitPreviousSubmissionReference(BoundPreviousSubmissionReference node);
    public virtual BoundNode VisitHostObjectMemberReference(BoundHostObjectMemberReference node);
    public virtual BoundNode VisitLocal(BoundLocal node);
    public virtual BoundNode VisitPseudoVariable(BoundPseudoVariable node);
    public virtual BoundNode VisitParameter(BoundParameter node);
    public virtual BoundNode VisitByRefArgumentPlaceholder(BoundByRefArgumentPlaceholder node);
    public virtual BoundNode VisitByRefArgumentWithCopyBack(BoundByRefArgumentWithCopyBack node);
    public virtual BoundNode VisitLateBoundArgumentSupportingAssignmentWithCapture(BoundLateBoundArgumentSupportingAssignmentWithCapture node);
    public virtual BoundNode VisitLabelStatement(BoundLabelStatement node);
    public virtual BoundNode VisitLabel(BoundLabel node);
    public virtual BoundNode VisitGotoStatement(BoundGotoStatement node);
    public virtual BoundNode VisitStatementList(BoundStatementList node);
    public virtual BoundNode VisitConditionalGoto(BoundConditionalGoto node);
    public virtual BoundNode VisitWithStatement(BoundWithStatement node);
    public virtual BoundNode VisitUnboundLambda(UnboundLambda node);
    public virtual BoundNode VisitLambda(BoundLambda node);
    public virtual BoundNode VisitQueryExpression(BoundQueryExpression node);
    public virtual BoundNode VisitQuerySource(BoundQuerySource node);
    public virtual BoundNode VisitToQueryableCollectionConversion(BoundToQueryableCollectionConversion node);
    public virtual BoundNode VisitQueryableSource(BoundQueryableSource node);
    public virtual BoundNode VisitQueryClause(BoundQueryClause node);
    public virtual BoundNode VisitOrdering(BoundOrdering node);
    public virtual BoundNode VisitQueryLambda(BoundQueryLambda node);
    public virtual BoundNode VisitRangeVariableAssignment(BoundRangeVariableAssignment node);
    public virtual BoundNode VisitGroupTypeInferenceLambda(GroupTypeInferenceLambda node);
    public virtual BoundNode VisitAggregateClause(BoundAggregateClause node);
    public virtual BoundNode VisitGroupAggregation(BoundGroupAggregation node);
    public virtual BoundNode VisitRangeVariable(BoundRangeVariable node);
    public virtual BoundNode VisitAddHandlerStatement(BoundAddHandlerStatement node);
    public virtual BoundNode VisitRemoveHandlerStatement(BoundRemoveHandlerStatement node);
    public virtual BoundNode VisitRaiseEventStatement(BoundRaiseEventStatement node);
    public virtual BoundNode VisitUsingStatement(BoundUsingStatement node);
    public virtual BoundNode VisitSyncLockStatement(BoundSyncLockStatement node);
    public virtual BoundNode VisitXmlName(BoundXmlName node);
    public virtual BoundNode VisitXmlNamespace(BoundXmlNamespace node);
    public virtual BoundNode VisitXmlDocument(BoundXmlDocument node);
    public virtual BoundNode VisitXmlDeclaration(BoundXmlDeclaration node);
    public virtual BoundNode VisitXmlProcessingInstruction(BoundXmlProcessingInstruction node);
    public virtual BoundNode VisitXmlComment(BoundXmlComment node);
    public virtual BoundNode VisitXmlAttribute(BoundXmlAttribute node);
    public virtual BoundNode VisitXmlElement(BoundXmlElement node);
    public virtual BoundNode VisitXmlMemberAccess(BoundXmlMemberAccess node);
    public virtual BoundNode VisitXmlEmbeddedExpression(BoundXmlEmbeddedExpression node);
    public virtual BoundNode VisitXmlCData(BoundXmlCData node);
    public virtual BoundNode VisitResumeStatement(BoundResumeStatement node);
    public virtual BoundNode VisitOnErrorStatement(BoundOnErrorStatement node);
    public virtual BoundNode VisitUnstructuredExceptionHandlingStatement(BoundUnstructuredExceptionHandlingStatement node);
    public virtual BoundNode VisitUnstructuredExceptionHandlingCatchFilter(BoundUnstructuredExceptionHandlingCatchFilter node);
    public virtual BoundNode VisitUnstructuredExceptionOnErrorSwitch(BoundUnstructuredExceptionOnErrorSwitch node);
    public virtual BoundNode VisitUnstructuredExceptionResumeSwitch(BoundUnstructuredExceptionResumeSwitch node);
    public virtual BoundNode VisitAwaitOperator(BoundAwaitOperator node);
    public virtual BoundNode VisitSpillSequence(BoundSpillSequence node);
    public virtual BoundNode VisitStopStatement(BoundStopStatement node);
    public virtual BoundNode VisitEndStatement(BoundEndStatement node);
    public virtual BoundNode VisitMidResult(BoundMidResult node);
    public virtual BoundNode VisitConditionalAccess(BoundConditionalAccess node);
    public virtual BoundNode VisitConditionalAccessReceiverPlaceholder(BoundConditionalAccessReceiverPlaceholder node);
    public virtual BoundNode VisitLoweredConditionalAccess(BoundLoweredConditionalAccess node);
    public virtual BoundNode VisitComplexConditionalAccessReceiver(BoundComplexConditionalAccessReceiver node);
    public virtual BoundNode VisitNameOfOperator(BoundNameOfOperator node);
    public virtual BoundNode VisitTypeAsValueExpression(BoundTypeAsValueExpression node);
    public virtual BoundNode VisitInterpolatedStringExpression(BoundInterpolatedStringExpression node);
    public virtual BoundNode VisitInterpolation(BoundInterpolation node);
    public virtual TypeSymbol VisitType(TypeSymbol type);
    public virtual ImmutableArray`1<T> VisitList(ImmutableArray`1<T> list);
    public void VisitList(ImmutableArray`1<T> list, ArrayBuilder`1<T> results);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundTreeRewriterWithStackGuard : BoundTreeRewriter {
    private int _recursionDepth;
    protected int RecursionDepth { get; }
    protected BoundTreeRewriterWithStackGuard(int recursionDepth);
    protected int get_RecursionDepth();
    public virtual BoundNode Visit(BoundNode node);
    protected BoundExpression VisitExpressionWithStackGuard(BoundExpression expression);
    protected sealed virtual BoundExpression VisitExpressionWithoutStackGuard(BoundExpression node);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundTreeRewriterWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator : BoundTreeRewriterWithStackGuard {
    protected BoundTreeRewriterWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator(int recursionDepth);
    public sealed virtual BoundNode VisitBinaryOperator(BoundBinaryOperator node);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundTreeVisitor : object {
    public virtual BoundNode VisitTypeArguments(BoundTypeArguments node);
    public virtual BoundNode VisitOmittedArgument(BoundOmittedArgument node);
    public virtual BoundNode VisitLValueToRValueWrapper(BoundLValueToRValueWrapper node);
    public virtual BoundNode VisitWithLValueExpressionPlaceholder(BoundWithLValueExpressionPlaceholder node);
    public virtual BoundNode VisitWithRValueExpressionPlaceholder(BoundWithRValueExpressionPlaceholder node);
    public virtual BoundNode VisitRValuePlaceholder(BoundRValuePlaceholder node);
    public virtual BoundNode VisitLValuePlaceholder(BoundLValuePlaceholder node);
    public virtual BoundNode VisitDup(BoundDup node);
    public virtual BoundNode VisitBadExpression(BoundBadExpression node);
    public virtual BoundNode VisitBadStatement(BoundBadStatement node);
    public virtual BoundNode VisitParenthesized(BoundParenthesized node);
    public virtual BoundNode VisitBadVariable(BoundBadVariable node);
    public virtual BoundNode VisitArrayAccess(BoundArrayAccess node);
    public virtual BoundNode VisitArrayLength(BoundArrayLength node);
    public virtual BoundNode VisitGetType(BoundGetType node);
    public virtual BoundNode VisitFieldInfo(BoundFieldInfo node);
    public virtual BoundNode VisitMethodInfo(BoundMethodInfo node);
    public virtual BoundNode VisitTypeExpression(BoundTypeExpression node);
    public virtual BoundNode VisitTypeOrValueExpression(BoundTypeOrValueExpression node);
    public virtual BoundNode VisitNamespaceExpression(BoundNamespaceExpression node);
    public virtual BoundNode VisitUnaryOperator(BoundUnaryOperator node);
    public virtual BoundNode VisitUserDefinedUnaryOperator(BoundUserDefinedUnaryOperator node);
    public virtual BoundNode VisitNullableIsTrueOperator(BoundNullableIsTrueOperator node);
    public virtual BoundNode VisitBinaryOperator(BoundBinaryOperator node);
    public virtual BoundNode VisitUserDefinedBinaryOperator(BoundUserDefinedBinaryOperator node);
    public virtual BoundNode VisitUserDefinedShortCircuitingOperator(BoundUserDefinedShortCircuitingOperator node);
    public virtual BoundNode VisitCompoundAssignmentTargetPlaceholder(BoundCompoundAssignmentTargetPlaceholder node);
    public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node);
    public virtual BoundNode VisitReferenceAssignment(BoundReferenceAssignment node);
    public virtual BoundNode VisitAddressOfOperator(BoundAddressOfOperator node);
    public virtual BoundNode VisitTernaryConditionalExpression(BoundTernaryConditionalExpression node);
    public virtual BoundNode VisitBinaryConditionalExpression(BoundBinaryConditionalExpression node);
    public virtual BoundNode VisitConversion(BoundConversion node);
    public virtual BoundNode VisitUserDefinedConversion(BoundUserDefinedConversion node);
    public virtual BoundNode VisitDirectCast(BoundDirectCast node);
    public virtual BoundNode VisitTryCast(BoundTryCast node);
    public virtual BoundNode VisitTypeOf(BoundTypeOf node);
    public virtual BoundNode VisitSequencePoint(BoundSequencePoint node);
    public virtual BoundNode VisitSequencePointExpression(BoundSequencePointExpression node);
    public virtual BoundNode VisitSequencePointWithSpan(BoundSequencePointWithSpan node);
    public virtual BoundNode VisitNoOpStatement(BoundNoOpStatement node);
    public virtual BoundNode VisitMethodGroup(BoundMethodGroup node);
    public virtual BoundNode VisitPropertyGroup(BoundPropertyGroup node);
    public virtual BoundNode VisitReturnStatement(BoundReturnStatement node);
    public virtual BoundNode VisitYieldStatement(BoundYieldStatement node);
    public virtual BoundNode VisitThrowStatement(BoundThrowStatement node);
    public virtual BoundNode VisitRedimStatement(BoundRedimStatement node);
    public virtual BoundNode VisitRedimClause(BoundRedimClause node);
    public virtual BoundNode VisitEraseStatement(BoundEraseStatement node);
    public virtual BoundNode VisitCall(BoundCall node);
    public virtual BoundNode VisitAttribute(BoundAttribute node);
    public virtual BoundNode VisitLateMemberAccess(BoundLateMemberAccess node);
    public virtual BoundNode VisitLateInvocation(BoundLateInvocation node);
    public virtual BoundNode VisitLateAddressOfOperator(BoundLateAddressOfOperator node);
    public virtual BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node);
    public virtual BoundNode VisitNoPiaObjectCreationExpression(BoundNoPiaObjectCreationExpression node);
    public virtual BoundNode VisitAnonymousTypeCreationExpression(BoundAnonymousTypeCreationExpression node);
    public virtual BoundNode VisitAnonymousTypePropertyAccess(BoundAnonymousTypePropertyAccess node);
    public virtual BoundNode VisitAnonymousTypeFieldInitializer(BoundAnonymousTypeFieldInitializer node);
    public virtual BoundNode VisitObjectInitializerExpression(BoundObjectInitializerExpression node);
    public virtual BoundNode VisitCollectionInitializerExpression(BoundCollectionInitializerExpression node);
    public virtual BoundNode VisitNewT(BoundNewT node);
    public virtual BoundNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node);
    public virtual BoundNode VisitArrayCreation(BoundArrayCreation node);
    public virtual BoundNode VisitArrayLiteral(BoundArrayLiteral node);
    public virtual BoundNode VisitArrayInitialization(BoundArrayInitialization node);
    public virtual BoundNode VisitFieldAccess(BoundFieldAccess node);
    public virtual BoundNode VisitPropertyAccess(BoundPropertyAccess node);
    public virtual BoundNode VisitEventAccess(BoundEventAccess node);
    public virtual BoundNode VisitBlock(BoundBlock node);
    public virtual BoundNode VisitStateMachineScope(BoundStateMachineScope node);
    public virtual BoundNode VisitLocalDeclaration(BoundLocalDeclaration node);
    public virtual BoundNode VisitAsNewLocalDeclarations(BoundAsNewLocalDeclarations node);
    public virtual BoundNode VisitDimStatement(BoundDimStatement node);
    public virtual BoundNode VisitInitializer(BoundInitializer node);
    public virtual BoundNode VisitFieldInitializer(BoundFieldInitializer node);
    public virtual BoundNode VisitPropertyInitializer(BoundPropertyInitializer node);
    public virtual BoundNode VisitParameterEqualsValue(BoundParameterEqualsValue node);
    public virtual BoundNode VisitGlobalStatementInitializer(BoundGlobalStatementInitializer node);
    public virtual BoundNode VisitSequence(BoundSequence node);
    public virtual BoundNode VisitExpressionStatement(BoundExpressionStatement node);
    public virtual BoundNode VisitIfStatement(BoundIfStatement node);
    public virtual BoundNode VisitSelectStatement(BoundSelectStatement node);
    public virtual BoundNode VisitCaseBlock(BoundCaseBlock node);
    public virtual BoundNode VisitCaseStatement(BoundCaseStatement node);
    public virtual BoundNode VisitSimpleCaseClause(BoundSimpleCaseClause node);
    public virtual BoundNode VisitRangeCaseClause(BoundRangeCaseClause node);
    public virtual BoundNode VisitRelationalCaseClause(BoundRelationalCaseClause node);
    public virtual BoundNode VisitDoLoopStatement(BoundDoLoopStatement node);
    public virtual BoundNode VisitWhileStatement(BoundWhileStatement node);
    public virtual BoundNode VisitForToUserDefinedOperators(BoundForToUserDefinedOperators node);
    public virtual BoundNode VisitForToStatement(BoundForToStatement node);
    public virtual BoundNode VisitForEachStatement(BoundForEachStatement node);
    public virtual BoundNode VisitExitStatement(BoundExitStatement node);
    public virtual BoundNode VisitContinueStatement(BoundContinueStatement node);
    public virtual BoundNode VisitTryStatement(BoundTryStatement node);
    public virtual BoundNode VisitCatchBlock(BoundCatchBlock node);
    public virtual BoundNode VisitLiteral(BoundLiteral node);
    public virtual BoundNode VisitMeReference(BoundMeReference node);
    public virtual BoundNode VisitValueTypeMeReference(BoundValueTypeMeReference node);
    public virtual BoundNode VisitMyBaseReference(BoundMyBaseReference node);
    public virtual BoundNode VisitMyClassReference(BoundMyClassReference node);
    public virtual BoundNode VisitPreviousSubmissionReference(BoundPreviousSubmissionReference node);
    public virtual BoundNode VisitHostObjectMemberReference(BoundHostObjectMemberReference node);
    public virtual BoundNode VisitLocal(BoundLocal node);
    public virtual BoundNode VisitPseudoVariable(BoundPseudoVariable node);
    public virtual BoundNode VisitParameter(BoundParameter node);
    public virtual BoundNode VisitByRefArgumentPlaceholder(BoundByRefArgumentPlaceholder node);
    public virtual BoundNode VisitByRefArgumentWithCopyBack(BoundByRefArgumentWithCopyBack node);
    public virtual BoundNode VisitLateBoundArgumentSupportingAssignmentWithCapture(BoundLateBoundArgumentSupportingAssignmentWithCapture node);
    public virtual BoundNode VisitLabelStatement(BoundLabelStatement node);
    public virtual BoundNode VisitLabel(BoundLabel node);
    public virtual BoundNode VisitGotoStatement(BoundGotoStatement node);
    public virtual BoundNode VisitStatementList(BoundStatementList node);
    public virtual BoundNode VisitConditionalGoto(BoundConditionalGoto node);
    public virtual BoundNode VisitWithStatement(BoundWithStatement node);
    public virtual BoundNode VisitUnboundLambda(UnboundLambda node);
    public virtual BoundNode VisitLambda(BoundLambda node);
    public virtual BoundNode VisitQueryExpression(BoundQueryExpression node);
    public virtual BoundNode VisitQuerySource(BoundQuerySource node);
    public virtual BoundNode VisitToQueryableCollectionConversion(BoundToQueryableCollectionConversion node);
    public virtual BoundNode VisitQueryableSource(BoundQueryableSource node);
    public virtual BoundNode VisitQueryClause(BoundQueryClause node);
    public virtual BoundNode VisitOrdering(BoundOrdering node);
    public virtual BoundNode VisitQueryLambda(BoundQueryLambda node);
    public virtual BoundNode VisitRangeVariableAssignment(BoundRangeVariableAssignment node);
    public virtual BoundNode VisitGroupTypeInferenceLambda(GroupTypeInferenceLambda node);
    public virtual BoundNode VisitAggregateClause(BoundAggregateClause node);
    public virtual BoundNode VisitGroupAggregation(BoundGroupAggregation node);
    public virtual BoundNode VisitRangeVariable(BoundRangeVariable node);
    public virtual BoundNode VisitAddHandlerStatement(BoundAddHandlerStatement node);
    public virtual BoundNode VisitRemoveHandlerStatement(BoundRemoveHandlerStatement node);
    public virtual BoundNode VisitRaiseEventStatement(BoundRaiseEventStatement node);
    public virtual BoundNode VisitUsingStatement(BoundUsingStatement node);
    public virtual BoundNode VisitSyncLockStatement(BoundSyncLockStatement node);
    public virtual BoundNode VisitXmlName(BoundXmlName node);
    public virtual BoundNode VisitXmlNamespace(BoundXmlNamespace node);
    public virtual BoundNode VisitXmlDocument(BoundXmlDocument node);
    public virtual BoundNode VisitXmlDeclaration(BoundXmlDeclaration node);
    public virtual BoundNode VisitXmlProcessingInstruction(BoundXmlProcessingInstruction node);
    public virtual BoundNode VisitXmlComment(BoundXmlComment node);
    public virtual BoundNode VisitXmlAttribute(BoundXmlAttribute node);
    public virtual BoundNode VisitXmlElement(BoundXmlElement node);
    public virtual BoundNode VisitXmlMemberAccess(BoundXmlMemberAccess node);
    public virtual BoundNode VisitXmlEmbeddedExpression(BoundXmlEmbeddedExpression node);
    public virtual BoundNode VisitXmlCData(BoundXmlCData node);
    public virtual BoundNode VisitResumeStatement(BoundResumeStatement node);
    public virtual BoundNode VisitOnErrorStatement(BoundOnErrorStatement node);
    public virtual BoundNode VisitUnstructuredExceptionHandlingStatement(BoundUnstructuredExceptionHandlingStatement node);
    public virtual BoundNode VisitUnstructuredExceptionHandlingCatchFilter(BoundUnstructuredExceptionHandlingCatchFilter node);
    public virtual BoundNode VisitUnstructuredExceptionOnErrorSwitch(BoundUnstructuredExceptionOnErrorSwitch node);
    public virtual BoundNode VisitUnstructuredExceptionResumeSwitch(BoundUnstructuredExceptionResumeSwitch node);
    public virtual BoundNode VisitAwaitOperator(BoundAwaitOperator node);
    public virtual BoundNode VisitSpillSequence(BoundSpillSequence node);
    public virtual BoundNode VisitStopStatement(BoundStopStatement node);
    public virtual BoundNode VisitEndStatement(BoundEndStatement node);
    public virtual BoundNode VisitMidResult(BoundMidResult node);
    public virtual BoundNode VisitConditionalAccess(BoundConditionalAccess node);
    public virtual BoundNode VisitConditionalAccessReceiverPlaceholder(BoundConditionalAccessReceiverPlaceholder node);
    public virtual BoundNode VisitLoweredConditionalAccess(BoundLoweredConditionalAccess node);
    public virtual BoundNode VisitComplexConditionalAccessReceiver(BoundComplexConditionalAccessReceiver node);
    public virtual BoundNode VisitNameOfOperator(BoundNameOfOperator node);
    public virtual BoundNode VisitTypeAsValueExpression(BoundTypeAsValueExpression node);
    public virtual BoundNode VisitInterpolatedStringExpression(BoundInterpolatedStringExpression node);
    public virtual BoundNode VisitInterpolation(BoundInterpolation node);
    public virtual BoundNode Visit(BoundNode node);
    public virtual BoundNode DefaultVisit(BoundNode node);
    protected BoundExpression VisitExpressionWithStackGuard(Int32& recursionDepth, BoundExpression node);
    protected virtual bool ConvertInsufficientExecutionStackExceptionToCancelledByStackGuardException();
    private BoundExpression VisitExpressionWithStackGuard(BoundExpression node);
    protected abstract virtual BoundExpression VisitExpressionWithoutStackGuard(BoundExpression node);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundTreeVisitor`2 : object {
    internal R VisitInternal(BoundNode node, A arg);
    public virtual R VisitTypeArguments(BoundTypeArguments node, A arg);
    public virtual R VisitOmittedArgument(BoundOmittedArgument node, A arg);
    public virtual R VisitLValueToRValueWrapper(BoundLValueToRValueWrapper node, A arg);
    public virtual R VisitWithLValueExpressionPlaceholder(BoundWithLValueExpressionPlaceholder node, A arg);
    public virtual R VisitWithRValueExpressionPlaceholder(BoundWithRValueExpressionPlaceholder node, A arg);
    public virtual R VisitRValuePlaceholder(BoundRValuePlaceholder node, A arg);
    public virtual R VisitLValuePlaceholder(BoundLValuePlaceholder node, A arg);
    public virtual R VisitDup(BoundDup node, A arg);
    public virtual R VisitBadExpression(BoundBadExpression node, A arg);
    public virtual R VisitBadStatement(BoundBadStatement node, A arg);
    public virtual R VisitParenthesized(BoundParenthesized node, A arg);
    public virtual R VisitBadVariable(BoundBadVariable node, A arg);
    public virtual R VisitArrayAccess(BoundArrayAccess node, A arg);
    public virtual R VisitArrayLength(BoundArrayLength node, A arg);
    public virtual R VisitGetType(BoundGetType node, A arg);
    public virtual R VisitFieldInfo(BoundFieldInfo node, A arg);
    public virtual R VisitMethodInfo(BoundMethodInfo node, A arg);
    public virtual R VisitTypeExpression(BoundTypeExpression node, A arg);
    public virtual R VisitTypeOrValueExpression(BoundTypeOrValueExpression node, A arg);
    public virtual R VisitNamespaceExpression(BoundNamespaceExpression node, A arg);
    public virtual R VisitUnaryOperator(BoundUnaryOperator node, A arg);
    public virtual R VisitUserDefinedUnaryOperator(BoundUserDefinedUnaryOperator node, A arg);
    public virtual R VisitNullableIsTrueOperator(BoundNullableIsTrueOperator node, A arg);
    public virtual R VisitBinaryOperator(BoundBinaryOperator node, A arg);
    public virtual R VisitUserDefinedBinaryOperator(BoundUserDefinedBinaryOperator node, A arg);
    public virtual R VisitUserDefinedShortCircuitingOperator(BoundUserDefinedShortCircuitingOperator node, A arg);
    public virtual R VisitCompoundAssignmentTargetPlaceholder(BoundCompoundAssignmentTargetPlaceholder node, A arg);
    public virtual R VisitAssignmentOperator(BoundAssignmentOperator node, A arg);
    public virtual R VisitReferenceAssignment(BoundReferenceAssignment node, A arg);
    public virtual R VisitAddressOfOperator(BoundAddressOfOperator node, A arg);
    public virtual R VisitTernaryConditionalExpression(BoundTernaryConditionalExpression node, A arg);
    public virtual R VisitBinaryConditionalExpression(BoundBinaryConditionalExpression node, A arg);
    public virtual R VisitConversion(BoundConversion node, A arg);
    public virtual R VisitUserDefinedConversion(BoundUserDefinedConversion node, A arg);
    public virtual R VisitDirectCast(BoundDirectCast node, A arg);
    public virtual R VisitTryCast(BoundTryCast node, A arg);
    public virtual R VisitTypeOf(BoundTypeOf node, A arg);
    public virtual R VisitSequencePoint(BoundSequencePoint node, A arg);
    public virtual R VisitSequencePointExpression(BoundSequencePointExpression node, A arg);
    public virtual R VisitSequencePointWithSpan(BoundSequencePointWithSpan node, A arg);
    public virtual R VisitNoOpStatement(BoundNoOpStatement node, A arg);
    public virtual R VisitMethodGroup(BoundMethodGroup node, A arg);
    public virtual R VisitPropertyGroup(BoundPropertyGroup node, A arg);
    public virtual R VisitReturnStatement(BoundReturnStatement node, A arg);
    public virtual R VisitYieldStatement(BoundYieldStatement node, A arg);
    public virtual R VisitThrowStatement(BoundThrowStatement node, A arg);
    public virtual R VisitRedimStatement(BoundRedimStatement node, A arg);
    public virtual R VisitRedimClause(BoundRedimClause node, A arg);
    public virtual R VisitEraseStatement(BoundEraseStatement node, A arg);
    public virtual R VisitCall(BoundCall node, A arg);
    public virtual R VisitAttribute(BoundAttribute node, A arg);
    public virtual R VisitLateMemberAccess(BoundLateMemberAccess node, A arg);
    public virtual R VisitLateInvocation(BoundLateInvocation node, A arg);
    public virtual R VisitLateAddressOfOperator(BoundLateAddressOfOperator node, A arg);
    public virtual R VisitObjectCreationExpression(BoundObjectCreationExpression node, A arg);
    public virtual R VisitNoPiaObjectCreationExpression(BoundNoPiaObjectCreationExpression node, A arg);
    public virtual R VisitAnonymousTypeCreationExpression(BoundAnonymousTypeCreationExpression node, A arg);
    public virtual R VisitAnonymousTypePropertyAccess(BoundAnonymousTypePropertyAccess node, A arg);
    public virtual R VisitAnonymousTypeFieldInitializer(BoundAnonymousTypeFieldInitializer node, A arg);
    public virtual R VisitObjectInitializerExpression(BoundObjectInitializerExpression node, A arg);
    public virtual R VisitCollectionInitializerExpression(BoundCollectionInitializerExpression node, A arg);
    public virtual R VisitNewT(BoundNewT node, A arg);
    public virtual R VisitDelegateCreationExpression(BoundDelegateCreationExpression node, A arg);
    public virtual R VisitArrayCreation(BoundArrayCreation node, A arg);
    public virtual R VisitArrayLiteral(BoundArrayLiteral node, A arg);
    public virtual R VisitArrayInitialization(BoundArrayInitialization node, A arg);
    public virtual R VisitFieldAccess(BoundFieldAccess node, A arg);
    public virtual R VisitPropertyAccess(BoundPropertyAccess node, A arg);
    public virtual R VisitEventAccess(BoundEventAccess node, A arg);
    public virtual R VisitBlock(BoundBlock node, A arg);
    public virtual R VisitStateMachineScope(BoundStateMachineScope node, A arg);
    public virtual R VisitLocalDeclaration(BoundLocalDeclaration node, A arg);
    public virtual R VisitAsNewLocalDeclarations(BoundAsNewLocalDeclarations node, A arg);
    public virtual R VisitDimStatement(BoundDimStatement node, A arg);
    public virtual R VisitInitializer(BoundInitializer node, A arg);
    public virtual R VisitFieldInitializer(BoundFieldInitializer node, A arg);
    public virtual R VisitPropertyInitializer(BoundPropertyInitializer node, A arg);
    public virtual R VisitParameterEqualsValue(BoundParameterEqualsValue node, A arg);
    public virtual R VisitGlobalStatementInitializer(BoundGlobalStatementInitializer node, A arg);
    public virtual R VisitSequence(BoundSequence node, A arg);
    public virtual R VisitExpressionStatement(BoundExpressionStatement node, A arg);
    public virtual R VisitIfStatement(BoundIfStatement node, A arg);
    public virtual R VisitSelectStatement(BoundSelectStatement node, A arg);
    public virtual R VisitCaseBlock(BoundCaseBlock node, A arg);
    public virtual R VisitCaseStatement(BoundCaseStatement node, A arg);
    public virtual R VisitSimpleCaseClause(BoundSimpleCaseClause node, A arg);
    public virtual R VisitRangeCaseClause(BoundRangeCaseClause node, A arg);
    public virtual R VisitRelationalCaseClause(BoundRelationalCaseClause node, A arg);
    public virtual R VisitDoLoopStatement(BoundDoLoopStatement node, A arg);
    public virtual R VisitWhileStatement(BoundWhileStatement node, A arg);
    public virtual R VisitForToUserDefinedOperators(BoundForToUserDefinedOperators node, A arg);
    public virtual R VisitForToStatement(BoundForToStatement node, A arg);
    public virtual R VisitForEachStatement(BoundForEachStatement node, A arg);
    public virtual R VisitExitStatement(BoundExitStatement node, A arg);
    public virtual R VisitContinueStatement(BoundContinueStatement node, A arg);
    public virtual R VisitTryStatement(BoundTryStatement node, A arg);
    public virtual R VisitCatchBlock(BoundCatchBlock node, A arg);
    public virtual R VisitLiteral(BoundLiteral node, A arg);
    public virtual R VisitMeReference(BoundMeReference node, A arg);
    public virtual R VisitValueTypeMeReference(BoundValueTypeMeReference node, A arg);
    public virtual R VisitMyBaseReference(BoundMyBaseReference node, A arg);
    public virtual R VisitMyClassReference(BoundMyClassReference node, A arg);
    public virtual R VisitPreviousSubmissionReference(BoundPreviousSubmissionReference node, A arg);
    public virtual R VisitHostObjectMemberReference(BoundHostObjectMemberReference node, A arg);
    public virtual R VisitLocal(BoundLocal node, A arg);
    public virtual R VisitPseudoVariable(BoundPseudoVariable node, A arg);
    public virtual R VisitParameter(BoundParameter node, A arg);
    public virtual R VisitByRefArgumentPlaceholder(BoundByRefArgumentPlaceholder node, A arg);
    public virtual R VisitByRefArgumentWithCopyBack(BoundByRefArgumentWithCopyBack node, A arg);
    public virtual R VisitLateBoundArgumentSupportingAssignmentWithCapture(BoundLateBoundArgumentSupportingAssignmentWithCapture node, A arg);
    public virtual R VisitLabelStatement(BoundLabelStatement node, A arg);
    public virtual R VisitLabel(BoundLabel node, A arg);
    public virtual R VisitGotoStatement(BoundGotoStatement node, A arg);
    public virtual R VisitStatementList(BoundStatementList node, A arg);
    public virtual R VisitConditionalGoto(BoundConditionalGoto node, A arg);
    public virtual R VisitWithStatement(BoundWithStatement node, A arg);
    public virtual R VisitUnboundLambda(UnboundLambda node, A arg);
    public virtual R VisitLambda(BoundLambda node, A arg);
    public virtual R VisitQueryExpression(BoundQueryExpression node, A arg);
    public virtual R VisitQuerySource(BoundQuerySource node, A arg);
    public virtual R VisitToQueryableCollectionConversion(BoundToQueryableCollectionConversion node, A arg);
    public virtual R VisitQueryableSource(BoundQueryableSource node, A arg);
    public virtual R VisitQueryClause(BoundQueryClause node, A arg);
    public virtual R VisitOrdering(BoundOrdering node, A arg);
    public virtual R VisitQueryLambda(BoundQueryLambda node, A arg);
    public virtual R VisitRangeVariableAssignment(BoundRangeVariableAssignment node, A arg);
    public virtual R VisitGroupTypeInferenceLambda(GroupTypeInferenceLambda node, A arg);
    public virtual R VisitAggregateClause(BoundAggregateClause node, A arg);
    public virtual R VisitGroupAggregation(BoundGroupAggregation node, A arg);
    public virtual R VisitRangeVariable(BoundRangeVariable node, A arg);
    public virtual R VisitAddHandlerStatement(BoundAddHandlerStatement node, A arg);
    public virtual R VisitRemoveHandlerStatement(BoundRemoveHandlerStatement node, A arg);
    public virtual R VisitRaiseEventStatement(BoundRaiseEventStatement node, A arg);
    public virtual R VisitUsingStatement(BoundUsingStatement node, A arg);
    public virtual R VisitSyncLockStatement(BoundSyncLockStatement node, A arg);
    public virtual R VisitXmlName(BoundXmlName node, A arg);
    public virtual R VisitXmlNamespace(BoundXmlNamespace node, A arg);
    public virtual R VisitXmlDocument(BoundXmlDocument node, A arg);
    public virtual R VisitXmlDeclaration(BoundXmlDeclaration node, A arg);
    public virtual R VisitXmlProcessingInstruction(BoundXmlProcessingInstruction node, A arg);
    public virtual R VisitXmlComment(BoundXmlComment node, A arg);
    public virtual R VisitXmlAttribute(BoundXmlAttribute node, A arg);
    public virtual R VisitXmlElement(BoundXmlElement node, A arg);
    public virtual R VisitXmlMemberAccess(BoundXmlMemberAccess node, A arg);
    public virtual R VisitXmlEmbeddedExpression(BoundXmlEmbeddedExpression node, A arg);
    public virtual R VisitXmlCData(BoundXmlCData node, A arg);
    public virtual R VisitResumeStatement(BoundResumeStatement node, A arg);
    public virtual R VisitOnErrorStatement(BoundOnErrorStatement node, A arg);
    public virtual R VisitUnstructuredExceptionHandlingStatement(BoundUnstructuredExceptionHandlingStatement node, A arg);
    public virtual R VisitUnstructuredExceptionHandlingCatchFilter(BoundUnstructuredExceptionHandlingCatchFilter node, A arg);
    public virtual R VisitUnstructuredExceptionOnErrorSwitch(BoundUnstructuredExceptionOnErrorSwitch node, A arg);
    public virtual R VisitUnstructuredExceptionResumeSwitch(BoundUnstructuredExceptionResumeSwitch node, A arg);
    public virtual R VisitAwaitOperator(BoundAwaitOperator node, A arg);
    public virtual R VisitSpillSequence(BoundSpillSequence node, A arg);
    public virtual R VisitStopStatement(BoundStopStatement node, A arg);
    public virtual R VisitEndStatement(BoundEndStatement node, A arg);
    public virtual R VisitMidResult(BoundMidResult node, A arg);
    public virtual R VisitConditionalAccess(BoundConditionalAccess node, A arg);
    public virtual R VisitConditionalAccessReceiverPlaceholder(BoundConditionalAccessReceiverPlaceholder node, A arg);
    public virtual R VisitLoweredConditionalAccess(BoundLoweredConditionalAccess node, A arg);
    public virtual R VisitComplexConditionalAccessReceiver(BoundComplexConditionalAccessReceiver node, A arg);
    public virtual R VisitNameOfOperator(BoundNameOfOperator node, A arg);
    public virtual R VisitTypeAsValueExpression(BoundTypeAsValueExpression node, A arg);
    public virtual R VisitInterpolatedStringExpression(BoundInterpolatedStringExpression node, A arg);
    public virtual R VisitInterpolation(BoundInterpolation node, A arg);
    public virtual R Visit(BoundNode node, A arg);
    public virtual R DefaultVisit(BoundNode node, A arg);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundTreeWalker : BoundTreeVisitor {
    public virtual BoundNode VisitTypeArguments(BoundTypeArguments node);
    public virtual BoundNode VisitOmittedArgument(BoundOmittedArgument node);
    public virtual BoundNode VisitLValueToRValueWrapper(BoundLValueToRValueWrapper node);
    public virtual BoundNode VisitWithLValueExpressionPlaceholder(BoundWithLValueExpressionPlaceholder node);
    public virtual BoundNode VisitWithRValueExpressionPlaceholder(BoundWithRValueExpressionPlaceholder node);
    public virtual BoundNode VisitRValuePlaceholder(BoundRValuePlaceholder node);
    public virtual BoundNode VisitLValuePlaceholder(BoundLValuePlaceholder node);
    public virtual BoundNode VisitDup(BoundDup node);
    public virtual BoundNode VisitBadExpression(BoundBadExpression node);
    public virtual BoundNode VisitBadStatement(BoundBadStatement node);
    public virtual BoundNode VisitParenthesized(BoundParenthesized node);
    public virtual BoundNode VisitBadVariable(BoundBadVariable node);
    public virtual BoundNode VisitArrayAccess(BoundArrayAccess node);
    public virtual BoundNode VisitArrayLength(BoundArrayLength node);
    public virtual BoundNode VisitGetType(BoundGetType node);
    public virtual BoundNode VisitFieldInfo(BoundFieldInfo node);
    public virtual BoundNode VisitMethodInfo(BoundMethodInfo node);
    public virtual BoundNode VisitTypeExpression(BoundTypeExpression node);
    public virtual BoundNode VisitTypeOrValueExpression(BoundTypeOrValueExpression node);
    public virtual BoundNode VisitNamespaceExpression(BoundNamespaceExpression node);
    public virtual BoundNode VisitUnaryOperator(BoundUnaryOperator node);
    public virtual BoundNode VisitUserDefinedUnaryOperator(BoundUserDefinedUnaryOperator node);
    public virtual BoundNode VisitNullableIsTrueOperator(BoundNullableIsTrueOperator node);
    public virtual BoundNode VisitBinaryOperator(BoundBinaryOperator node);
    public virtual BoundNode VisitUserDefinedBinaryOperator(BoundUserDefinedBinaryOperator node);
    public virtual BoundNode VisitUserDefinedShortCircuitingOperator(BoundUserDefinedShortCircuitingOperator node);
    public virtual BoundNode VisitCompoundAssignmentTargetPlaceholder(BoundCompoundAssignmentTargetPlaceholder node);
    public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node);
    public virtual BoundNode VisitReferenceAssignment(BoundReferenceAssignment node);
    public virtual BoundNode VisitAddressOfOperator(BoundAddressOfOperator node);
    public virtual BoundNode VisitTernaryConditionalExpression(BoundTernaryConditionalExpression node);
    public virtual BoundNode VisitBinaryConditionalExpression(BoundBinaryConditionalExpression node);
    public virtual BoundNode VisitConversion(BoundConversion node);
    public virtual BoundNode VisitUserDefinedConversion(BoundUserDefinedConversion node);
    public virtual BoundNode VisitDirectCast(BoundDirectCast node);
    public virtual BoundNode VisitTryCast(BoundTryCast node);
    public virtual BoundNode VisitTypeOf(BoundTypeOf node);
    public virtual BoundNode VisitSequencePoint(BoundSequencePoint node);
    public virtual BoundNode VisitSequencePointExpression(BoundSequencePointExpression node);
    public virtual BoundNode VisitSequencePointWithSpan(BoundSequencePointWithSpan node);
    public virtual BoundNode VisitNoOpStatement(BoundNoOpStatement node);
    public virtual BoundNode VisitMethodGroup(BoundMethodGroup node);
    public virtual BoundNode VisitPropertyGroup(BoundPropertyGroup node);
    public virtual BoundNode VisitReturnStatement(BoundReturnStatement node);
    public virtual BoundNode VisitYieldStatement(BoundYieldStatement node);
    public virtual BoundNode VisitThrowStatement(BoundThrowStatement node);
    public virtual BoundNode VisitRedimStatement(BoundRedimStatement node);
    public virtual BoundNode VisitRedimClause(BoundRedimClause node);
    public virtual BoundNode VisitEraseStatement(BoundEraseStatement node);
    public virtual BoundNode VisitCall(BoundCall node);
    public virtual BoundNode VisitAttribute(BoundAttribute node);
    public virtual BoundNode VisitLateMemberAccess(BoundLateMemberAccess node);
    public virtual BoundNode VisitLateInvocation(BoundLateInvocation node);
    public virtual BoundNode VisitLateAddressOfOperator(BoundLateAddressOfOperator node);
    public virtual BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node);
    public virtual BoundNode VisitNoPiaObjectCreationExpression(BoundNoPiaObjectCreationExpression node);
    public virtual BoundNode VisitAnonymousTypeCreationExpression(BoundAnonymousTypeCreationExpression node);
    public virtual BoundNode VisitAnonymousTypePropertyAccess(BoundAnonymousTypePropertyAccess node);
    public virtual BoundNode VisitAnonymousTypeFieldInitializer(BoundAnonymousTypeFieldInitializer node);
    public virtual BoundNode VisitObjectInitializerExpression(BoundObjectInitializerExpression node);
    public virtual BoundNode VisitCollectionInitializerExpression(BoundCollectionInitializerExpression node);
    public virtual BoundNode VisitNewT(BoundNewT node);
    public virtual BoundNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node);
    public virtual BoundNode VisitArrayCreation(BoundArrayCreation node);
    public virtual BoundNode VisitArrayLiteral(BoundArrayLiteral node);
    public virtual BoundNode VisitArrayInitialization(BoundArrayInitialization node);
    public virtual BoundNode VisitFieldAccess(BoundFieldAccess node);
    public virtual BoundNode VisitPropertyAccess(BoundPropertyAccess node);
    public virtual BoundNode VisitEventAccess(BoundEventAccess node);
    public virtual BoundNode VisitBlock(BoundBlock node);
    public virtual BoundNode VisitStateMachineScope(BoundStateMachineScope node);
    public virtual BoundNode VisitLocalDeclaration(BoundLocalDeclaration node);
    public virtual BoundNode VisitAsNewLocalDeclarations(BoundAsNewLocalDeclarations node);
    public virtual BoundNode VisitDimStatement(BoundDimStatement node);
    public virtual BoundNode VisitInitializer(BoundInitializer node);
    public virtual BoundNode VisitFieldInitializer(BoundFieldInitializer node);
    public virtual BoundNode VisitPropertyInitializer(BoundPropertyInitializer node);
    public virtual BoundNode VisitParameterEqualsValue(BoundParameterEqualsValue node);
    public virtual BoundNode VisitGlobalStatementInitializer(BoundGlobalStatementInitializer node);
    public virtual BoundNode VisitSequence(BoundSequence node);
    public virtual BoundNode VisitExpressionStatement(BoundExpressionStatement node);
    public virtual BoundNode VisitIfStatement(BoundIfStatement node);
    public virtual BoundNode VisitSelectStatement(BoundSelectStatement node);
    public virtual BoundNode VisitCaseBlock(BoundCaseBlock node);
    public virtual BoundNode VisitCaseStatement(BoundCaseStatement node);
    public virtual BoundNode VisitSimpleCaseClause(BoundSimpleCaseClause node);
    public virtual BoundNode VisitRangeCaseClause(BoundRangeCaseClause node);
    public virtual BoundNode VisitRelationalCaseClause(BoundRelationalCaseClause node);
    public virtual BoundNode VisitDoLoopStatement(BoundDoLoopStatement node);
    public virtual BoundNode VisitWhileStatement(BoundWhileStatement node);
    public virtual BoundNode VisitForToUserDefinedOperators(BoundForToUserDefinedOperators node);
    public virtual BoundNode VisitForToStatement(BoundForToStatement node);
    public virtual BoundNode VisitForEachStatement(BoundForEachStatement node);
    public virtual BoundNode VisitExitStatement(BoundExitStatement node);
    public virtual BoundNode VisitContinueStatement(BoundContinueStatement node);
    public virtual BoundNode VisitTryStatement(BoundTryStatement node);
    public virtual BoundNode VisitCatchBlock(BoundCatchBlock node);
    public virtual BoundNode VisitLiteral(BoundLiteral node);
    public virtual BoundNode VisitMeReference(BoundMeReference node);
    public virtual BoundNode VisitValueTypeMeReference(BoundValueTypeMeReference node);
    public virtual BoundNode VisitMyBaseReference(BoundMyBaseReference node);
    public virtual BoundNode VisitMyClassReference(BoundMyClassReference node);
    public virtual BoundNode VisitPreviousSubmissionReference(BoundPreviousSubmissionReference node);
    public virtual BoundNode VisitHostObjectMemberReference(BoundHostObjectMemberReference node);
    public virtual BoundNode VisitLocal(BoundLocal node);
    public virtual BoundNode VisitPseudoVariable(BoundPseudoVariable node);
    public virtual BoundNode VisitParameter(BoundParameter node);
    public virtual BoundNode VisitByRefArgumentPlaceholder(BoundByRefArgumentPlaceholder node);
    public virtual BoundNode VisitByRefArgumentWithCopyBack(BoundByRefArgumentWithCopyBack node);
    public virtual BoundNode VisitLateBoundArgumentSupportingAssignmentWithCapture(BoundLateBoundArgumentSupportingAssignmentWithCapture node);
    public virtual BoundNode VisitLabelStatement(BoundLabelStatement node);
    public virtual BoundNode VisitLabel(BoundLabel node);
    public virtual BoundNode VisitGotoStatement(BoundGotoStatement node);
    public virtual BoundNode VisitStatementList(BoundStatementList node);
    public virtual BoundNode VisitConditionalGoto(BoundConditionalGoto node);
    public virtual BoundNode VisitWithStatement(BoundWithStatement node);
    public virtual BoundNode VisitUnboundLambda(UnboundLambda node);
    public virtual BoundNode VisitLambda(BoundLambda node);
    public virtual BoundNode VisitQueryExpression(BoundQueryExpression node);
    public virtual BoundNode VisitQuerySource(BoundQuerySource node);
    public virtual BoundNode VisitToQueryableCollectionConversion(BoundToQueryableCollectionConversion node);
    public virtual BoundNode VisitQueryableSource(BoundQueryableSource node);
    public virtual BoundNode VisitQueryClause(BoundQueryClause node);
    public virtual BoundNode VisitOrdering(BoundOrdering node);
    public virtual BoundNode VisitQueryLambda(BoundQueryLambda node);
    public virtual BoundNode VisitRangeVariableAssignment(BoundRangeVariableAssignment node);
    public virtual BoundNode VisitGroupTypeInferenceLambda(GroupTypeInferenceLambda node);
    public virtual BoundNode VisitAggregateClause(BoundAggregateClause node);
    public virtual BoundNode VisitGroupAggregation(BoundGroupAggregation node);
    public virtual BoundNode VisitRangeVariable(BoundRangeVariable node);
    public virtual BoundNode VisitAddHandlerStatement(BoundAddHandlerStatement node);
    public virtual BoundNode VisitRemoveHandlerStatement(BoundRemoveHandlerStatement node);
    public virtual BoundNode VisitRaiseEventStatement(BoundRaiseEventStatement node);
    public virtual BoundNode VisitUsingStatement(BoundUsingStatement node);
    public virtual BoundNode VisitSyncLockStatement(BoundSyncLockStatement node);
    public virtual BoundNode VisitXmlName(BoundXmlName node);
    public virtual BoundNode VisitXmlNamespace(BoundXmlNamespace node);
    public virtual BoundNode VisitXmlDocument(BoundXmlDocument node);
    public virtual BoundNode VisitXmlDeclaration(BoundXmlDeclaration node);
    public virtual BoundNode VisitXmlProcessingInstruction(BoundXmlProcessingInstruction node);
    public virtual BoundNode VisitXmlComment(BoundXmlComment node);
    public virtual BoundNode VisitXmlAttribute(BoundXmlAttribute node);
    public virtual BoundNode VisitXmlElement(BoundXmlElement node);
    public virtual BoundNode VisitXmlMemberAccess(BoundXmlMemberAccess node);
    public virtual BoundNode VisitXmlEmbeddedExpression(BoundXmlEmbeddedExpression node);
    public virtual BoundNode VisitXmlCData(BoundXmlCData node);
    public virtual BoundNode VisitResumeStatement(BoundResumeStatement node);
    public virtual BoundNode VisitOnErrorStatement(BoundOnErrorStatement node);
    public virtual BoundNode VisitUnstructuredExceptionHandlingStatement(BoundUnstructuredExceptionHandlingStatement node);
    public virtual BoundNode VisitUnstructuredExceptionHandlingCatchFilter(BoundUnstructuredExceptionHandlingCatchFilter node);
    public virtual BoundNode VisitUnstructuredExceptionOnErrorSwitch(BoundUnstructuredExceptionOnErrorSwitch node);
    public virtual BoundNode VisitUnstructuredExceptionResumeSwitch(BoundUnstructuredExceptionResumeSwitch node);
    public virtual BoundNode VisitAwaitOperator(BoundAwaitOperator node);
    public virtual BoundNode VisitSpillSequence(BoundSpillSequence node);
    public virtual BoundNode VisitStopStatement(BoundStopStatement node);
    public virtual BoundNode VisitEndStatement(BoundEndStatement node);
    public virtual BoundNode VisitMidResult(BoundMidResult node);
    public virtual BoundNode VisitConditionalAccess(BoundConditionalAccess node);
    public virtual BoundNode VisitConditionalAccessReceiverPlaceholder(BoundConditionalAccessReceiverPlaceholder node);
    public virtual BoundNode VisitLoweredConditionalAccess(BoundLoweredConditionalAccess node);
    public virtual BoundNode VisitComplexConditionalAccessReceiver(BoundComplexConditionalAccessReceiver node);
    public virtual BoundNode VisitNameOfOperator(BoundNameOfOperator node);
    public virtual BoundNode VisitTypeAsValueExpression(BoundTypeAsValueExpression node);
    public virtual BoundNode VisitInterpolatedStringExpression(BoundInterpolatedStringExpression node);
    public virtual BoundNode VisitInterpolation(BoundInterpolation node);
    public virtual void VisitList(ImmutableArray`1<T> list);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundTreeWalkerWithStackGuard : BoundTreeWalker {
    private int _recursionDepth;
    protected int RecursionDepth { get; }
    protected BoundTreeWalkerWithStackGuard(int recursionDepth);
    protected int get_RecursionDepth();
    public virtual BoundNode Visit(BoundNode node);
    protected BoundExpression VisitExpressionWithStackGuard(BoundExpression expression);
    protected sealed virtual BoundExpression VisitExpressionWithoutStackGuard(BoundExpression node);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator : BoundTreeWalkerWithStackGuard {
    protected BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator(int recursionDepth);
    public sealed virtual BoundNode VisitBinaryOperator(BoundBinaryOperator node);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundTryCast : BoundExpression {
    private BoundExpression _Operand;
    private ConversionKind _ConversionKind;
    private ConstantValue _ConstantValueOpt;
    private BoundLambda _RelaxationLambdaOpt;
    public BoundExpression Operand { get; }
    public ConversionKind ConversionKind { get; }
    public ConstantValue ConstantValueOpt { get; }
    public BoundLambda RelaxationLambdaOpt { get; }
    private ConversionKind IConversionExpression_ConversionKind { get; }
    private bool IConversionExpresson_IsExplicit { get; }
    private IOperation IConversionExpression_Operand { get; }
    private IMethodSymbol IHasOperatorMethodExpression_OperatorMethod { get; }
    private bool IHasOperatorMethodExpression_UsesOperatorMethod { get; }
    public BoundTryCast(VisualBasicSyntaxNode syntax, BoundExpression operand, ConversionKind conversionKind, ConstantValue constantValueOpt, BoundLambda relaxationLambdaOpt, TypeSymbol type, bool hasErrors);
    public BoundTryCast(VisualBasicSyntaxNode syntax, BoundExpression operand, ConversionKind conversionKind, TypeSymbol type, bool hasErrors);
    public BoundTryCast(VisualBasicSyntaxNode syntax, BoundExpression operand, ConversionKind conversionKind, BoundLambda relaxationLambdaOpt, TypeSymbol type, bool hasErrors);
    public BoundTryCast(VisualBasicSyntaxNode syntax, BoundExpression operand, ConversionKind conversionKind, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Operand();
    public ConversionKind get_ConversionKind();
    public virtual ConstantValue get_ConstantValueOpt();
    public BoundLambda get_RelaxationLambdaOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundTryCast Update(BoundExpression operand, ConversionKind conversionKind, ConstantValue constantValueOpt, BoundLambda relaxationLambdaOpt, TypeSymbol type);
    private sealed virtual override ConversionKind get_IConversionExpression_ConversionKind();
    private sealed virtual override bool get_IConversionExpresson_IsExplicit();
    private sealed virtual override IOperation get_IConversionExpression_Operand();
    private sealed virtual override IMethodSymbol get_IHasOperatorMethodExpression_OperatorMethod();
    private sealed virtual override bool get_IHasOperatorMethodExpression_UsesOperatorMethod();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundTryStatement : BoundStatement {
    private BoundBlock _TryBlock;
    private ImmutableArray`1<BoundCatchBlock> _CatchBlocks;
    private BoundBlock _FinallyBlockOpt;
    private LabelSymbol _ExitLabelOpt;
    public BoundBlock TryBlock { get; }
    public ImmutableArray`1<BoundCatchBlock> CatchBlocks { get; }
    public BoundBlock FinallyBlockOpt { get; }
    public LabelSymbol ExitLabelOpt { get; }
    private IBlockStatement ITryStatement_Body { get; }
    private ImmutableArray`1<ICatchClause> ITryStatement_Catches { get; }
    private IBlockStatement ITryStatement_FinallyHandler { get; }
    public BoundTryStatement(VisualBasicSyntaxNode syntax, BoundBlock tryBlock, ImmutableArray`1<BoundCatchBlock> catchBlocks, BoundBlock finallyBlockOpt, LabelSymbol exitLabelOpt, bool hasErrors);
    public BoundBlock get_TryBlock();
    public ImmutableArray`1<BoundCatchBlock> get_CatchBlocks();
    public BoundBlock get_FinallyBlockOpt();
    public LabelSymbol get_ExitLabelOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundTryStatement Update(BoundBlock tryBlock, ImmutableArray`1<BoundCatchBlock> catchBlocks, BoundBlock finallyBlockOpt, LabelSymbol exitLabelOpt);
    private sealed virtual override IBlockStatement get_ITryStatement_Body();
    private sealed virtual override ImmutableArray`1<ICatchClause> get_ITryStatement_Catches();
    private sealed virtual override IBlockStatement get_ITryStatement_FinallyHandler();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundTypeArguments : BoundExpression {
    private ImmutableArray`1<TypeSymbol> _Arguments;
    public ImmutableArray`1<TypeSymbol> Arguments { get; }
    public BoundTypeArguments(VisualBasicSyntaxNode syntax, ImmutableArray`1<TypeSymbol> arguments, bool hasErrors);
    public BoundTypeArguments(VisualBasicSyntaxNode syntax, ImmutableArray`1<TypeSymbol> arguments);
    public ImmutableArray`1<TypeSymbol> get_Arguments();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundTypeArguments Update(ImmutableArray`1<TypeSymbol> arguments);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundTypeAsValueExpression : BoundExpression {
    private BoundTypeExpression _Expression;
    public BoundTypeExpression Expression { get; }
    public BoundTypeAsValueExpression(VisualBasicSyntaxNode syntax, BoundTypeExpression expression, TypeSymbol type, bool hasErrors);
    public BoundTypeExpression get_Expression();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundTypeAsValueExpression Update(BoundTypeExpression expression, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundTypeExpression : BoundExpression {
    private BoundExpression _UnevaluatedReceiverOpt;
    private AliasSymbol _AliasOpt;
    public BoundExpression UnevaluatedReceiverOpt { get; }
    public AliasSymbol AliasOpt { get; }
    public Symbol ExpressionSymbol { get; }
    public BoundTypeExpression(VisualBasicSyntaxNode syntax, BoundExpression unevaluatedReceiverOpt, AliasSymbol aliasOpt, TypeSymbol type, bool hasErrors);
    public BoundTypeExpression(VisualBasicSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    public BoundExpression get_UnevaluatedReceiverOpt();
    public AliasSymbol get_AliasOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundTypeExpression Update(BoundExpression unevaluatedReceiverOpt, AliasSymbol aliasOpt, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundTypeOf : BoundExpression {
    private BoundExpression _Operand;
    private bool _IsTypeOfIsNotExpression;
    private TypeSymbol _TargetType;
    public BoundExpression Operand { get; }
    public bool IsTypeOfIsNotExpression { get; }
    public TypeSymbol TargetType { get; }
    private ITypeSymbol IIsTypeExpression_IsType { get; }
    private IOperation IIsTypeExpression_Operand { get; }
    public BoundTypeOf(VisualBasicSyntaxNode syntax, BoundExpression operand, bool isTypeOfIsNotExpression, TypeSymbol targetType, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Operand();
    public bool get_IsTypeOfIsNotExpression();
    public TypeSymbol get_TargetType();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundTypeOf Update(BoundExpression operand, bool isTypeOfIsNotExpression, TypeSymbol targetType, TypeSymbol type);
    private sealed virtual override ITypeSymbol get_IIsTypeExpression_IsType();
    private sealed virtual override IOperation get_IIsTypeExpression_Operand();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundTypeOrValueData : ValueType {
    private BoundExpression _valueExpression;
    private DiagnosticBag _valueDiagnostics;
    private BoundExpression _typeExpression;
    private DiagnosticBag _typeDiagnostics;
    public BoundExpression ValueExpression { get; }
    public DiagnosticBag ValueDiagnostics { get; }
    public BoundExpression TypeExpression { get; }
    public DiagnosticBag TypeDiagnostics { get; }
    public BoundTypeOrValueData(BoundExpression valueExpression, DiagnosticBag valueDiagnostics, BoundExpression typeExpression, DiagnosticBag typeDiagnostics);
    public BoundExpression get_ValueExpression();
    public DiagnosticBag get_ValueDiagnostics();
    public BoundExpression get_TypeExpression();
    public DiagnosticBag get_TypeDiagnostics();
    public static bool op_Equality(BoundTypeOrValueData a, BoundTypeOrValueData b);
    public static bool op_Inequality(BoundTypeOrValueData a, BoundTypeOrValueData b);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override bool Equals(BoundTypeOrValueData b);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundTypeOrValueExpression : BoundExpression {
    private BoundTypeOrValueData _Data;
    public BoundTypeOrValueData Data { get; }
    public BoundTypeOrValueExpression(VisualBasicSyntaxNode syntax, BoundTypeOrValueData data, TypeSymbol type, bool hasErrors);
    public BoundTypeOrValueExpression(VisualBasicSyntaxNode syntax, BoundTypeOrValueData data, TypeSymbol type);
    public BoundTypeOrValueData get_Data();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundTypeOrValueExpression Update(BoundTypeOrValueData data, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundUnaryOperator : BoundExpression {
    private UnaryOperatorKind _OperatorKind;
    private BoundExpression _Operand;
    private bool _Checked;
    private ConstantValue _ConstantValueOpt;
    public UnaryOperatorKind OperatorKind { get; }
    public BoundExpression Operand { get; }
    public bool Checked { get; }
    public ConstantValue ConstantValueOpt { get; }
    public Symbol ExpressionSymbol { get; }
    private IMethodSymbol IHasOperatorMethodExpression_OperatorMethod { get; }
    private bool IHasOperatorMethodExpression_UsesOperatorMethod { get; }
    private IOperation IUnaryOperatorExpression_Operand { get; }
    private UnaryOperationKind IUnaryOperatorExpression_UnaryOperationKind { get; }
    public BoundUnaryOperator(VisualBasicSyntaxNode syntax, UnaryOperatorKind operatorKind, BoundExpression operand, bool checked, ConstantValue constantValueOpt, TypeSymbol type, bool hasErrors);
    public BoundUnaryOperator(VisualBasicSyntaxNode syntax, UnaryOperatorKind operatorKind, BoundExpression operand, bool checked, TypeSymbol type, bool hasErrors);
    public UnaryOperatorKind get_OperatorKind();
    public BoundExpression get_Operand();
    public bool get_Checked();
    public virtual ConstantValue get_ConstantValueOpt();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundUnaryOperator Update(UnaryOperatorKind operatorKind, BoundExpression operand, bool checked, ConstantValue constantValueOpt, TypeSymbol type);
    public virtual Symbol get_ExpressionSymbol();
    private sealed virtual override IMethodSymbol get_IHasOperatorMethodExpression_OperatorMethod();
    private sealed virtual override bool get_IHasOperatorMethodExpression_UsesOperatorMethod();
    private sealed virtual override IOperation get_IUnaryOperatorExpression_Operand();
    private sealed virtual override UnaryOperationKind get_IUnaryOperatorExpression_UnaryOperationKind();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundUnstructuredExceptionHandlingCatchFilter : BoundExpression {
    private BoundLocal _ActiveHandlerLocal;
    private BoundLocal _ResumeTargetLocal;
    public BoundLocal ActiveHandlerLocal { get; }
    public BoundLocal ResumeTargetLocal { get; }
    public BoundUnstructuredExceptionHandlingCatchFilter(VisualBasicSyntaxNode syntax, BoundLocal activeHandlerLocal, BoundLocal resumeTargetLocal, TypeSymbol type, bool hasErrors);
    public BoundLocal get_ActiveHandlerLocal();
    public BoundLocal get_ResumeTargetLocal();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundUnstructuredExceptionHandlingCatchFilter Update(BoundLocal activeHandlerLocal, BoundLocal resumeTargetLocal, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundUnstructuredExceptionHandlingStatement : BoundStatement {
    private bool _ContainsOnError;
    private bool _ContainsResume;
    private StatementSyntax _ResumeWithoutLabelOpt;
    private bool _TrackLineNumber;
    private BoundBlock _Body;
    public bool ContainsOnError { get; }
    public bool ContainsResume { get; }
    public StatementSyntax ResumeWithoutLabelOpt { get; }
    public bool TrackLineNumber { get; }
    public BoundBlock Body { get; }
    public BoundUnstructuredExceptionHandlingStatement(VisualBasicSyntaxNode syntax, bool containsOnError, bool containsResume, StatementSyntax resumeWithoutLabelOpt, bool trackLineNumber, BoundBlock body, bool hasErrors);
    public bool get_ContainsOnError();
    public bool get_ContainsResume();
    public StatementSyntax get_ResumeWithoutLabelOpt();
    public bool get_TrackLineNumber();
    public BoundBlock get_Body();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundUnstructuredExceptionHandlingStatement Update(bool containsOnError, bool containsResume, StatementSyntax resumeWithoutLabelOpt, bool trackLineNumber, BoundBlock body);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundUnstructuredExceptionOnErrorSwitch : BoundStatement {
    private BoundExpression _Value;
    private ImmutableArray`1<BoundGotoStatement> _Jumps;
    public BoundExpression Value { get; }
    public ImmutableArray`1<BoundGotoStatement> Jumps { get; }
    public BoundUnstructuredExceptionOnErrorSwitch(VisualBasicSyntaxNode syntax, BoundExpression value, ImmutableArray`1<BoundGotoStatement> jumps, bool hasErrors);
    public BoundExpression get_Value();
    public ImmutableArray`1<BoundGotoStatement> get_Jumps();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundUnstructuredExceptionOnErrorSwitch Update(BoundExpression value, ImmutableArray`1<BoundGotoStatement> jumps);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundUnstructuredExceptionResumeSwitch : BoundStatement {
    private BoundLocal _ResumeTargetTemporary;
    private BoundLabelStatement _ResumeLabel;
    private BoundLabelStatement _ResumeNextLabel;
    private ImmutableArray`1<BoundGotoStatement> _Jumps;
    public BoundLocal ResumeTargetTemporary { get; }
    public BoundLabelStatement ResumeLabel { get; }
    public BoundLabelStatement ResumeNextLabel { get; }
    public ImmutableArray`1<BoundGotoStatement> Jumps { get; }
    public BoundUnstructuredExceptionResumeSwitch(VisualBasicSyntaxNode syntax, BoundLocal resumeTargetTemporary, BoundLabelStatement resumeLabel, BoundLabelStatement resumeNextLabel, ImmutableArray`1<BoundGotoStatement> jumps, bool hasErrors);
    public BoundLocal get_ResumeTargetTemporary();
    public BoundLabelStatement get_ResumeLabel();
    public BoundLabelStatement get_ResumeNextLabel();
    public ImmutableArray`1<BoundGotoStatement> get_Jumps();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundUnstructuredExceptionResumeSwitch Update(BoundLocal resumeTargetTemporary, BoundLabelStatement resumeLabel, BoundLabelStatement resumeNextLabel, ImmutableArray`1<BoundGotoStatement> jumps);
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedBinaryOperator : BoundExpression {
    private BinaryOperatorKind _OperatorKind;
    private BoundExpression _UnderlyingExpression;
    private bool _Checked;
    public BinaryOperatorKind OperatorKind { get; }
    public BoundExpression UnderlyingExpression { get; }
    public bool Checked { get; }
    public BoundExpression Left { get; }
    public BoundExpression Right { get; }
    public BoundCall Call { get; }
    private IOperation IBinaryOperatorExpression_LeftOperand { get; }
    private BinaryOperationKind IBinaryOperatorExpression_BinaryOperationKind { get; }
    private IOperation IBinaryOperatorExpression_RightOperand { get; }
    private IMethodSymbol IHasOperatorMethodExpression_OperatorMethod { get; }
    private bool IHasOperatorMethodExpression_UsesOperatorMethod { get; }
    public BoundUserDefinedBinaryOperator(VisualBasicSyntaxNode syntax, BinaryOperatorKind operatorKind, BoundExpression underlyingExpression, bool checked, TypeSymbol type, bool hasErrors);
    public BinaryOperatorKind get_OperatorKind();
    public BoundExpression get_UnderlyingExpression();
    public bool get_Checked();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundUserDefinedBinaryOperator Update(BinaryOperatorKind operatorKind, BoundExpression underlyingExpression, bool checked, TypeSymbol type);
    public BoundExpression get_Left();
    public BoundExpression get_Right();
    public BoundCall get_Call();
    private sealed virtual override IOperation get_IBinaryOperatorExpression_LeftOperand();
    private sealed virtual override BinaryOperationKind get_IBinaryOperatorExpression_BinaryOperationKind();
    private sealed virtual override IOperation get_IBinaryOperatorExpression_RightOperand();
    private sealed virtual override IMethodSymbol get_IHasOperatorMethodExpression_OperatorMethod();
    private sealed virtual override bool get_IHasOperatorMethodExpression_UsesOperatorMethod();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedConversion : BoundExpression {
    private BoundExpression _UnderlyingExpression;
    private byte _InOutConversionFlags;
    public BoundExpression UnderlyingExpression { get; }
    public byte InOutConversionFlags { get; }
    public BoundExpression Operand { get; }
    public BoundConversion InConversionOpt { get; }
    public BoundConversion OutConversionOpt { get; }
    public BoundCall Call { get; }
    private ConversionKind IConversionExpression_ConversionKind { get; }
    private bool IConversionExpression_IsExplicit { get; }
    private IOperation IConversionExpression_Operand { get; }
    private IMethodSymbol IHasOperatorMethodExpression_OperatorMethod { get; }
    private bool IHasOperatorMethodExpression_UsesOperatorMethod { get; }
    public BoundUserDefinedConversion(VisualBasicSyntaxNode syntax, BoundExpression underlyingExpression, byte inOutConversionFlags, TypeSymbol type, bool hasErrors);
    public BoundExpression get_UnderlyingExpression();
    public byte get_InOutConversionFlags();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundUserDefinedConversion Update(BoundExpression underlyingExpression, byte inOutConversionFlags, TypeSymbol type);
    public BoundExpression get_Operand();
    public BoundConversion get_InConversionOpt();
    public BoundConversion get_OutConversionOpt();
    public BoundCall get_Call();
    private sealed virtual override ConversionKind get_IConversionExpression_ConversionKind();
    private sealed virtual override bool get_IConversionExpression_IsExplicit();
    private sealed virtual override IOperation get_IConversionExpression_Operand();
    private sealed virtual override IMethodSymbol get_IHasOperatorMethodExpression_OperatorMethod();
    private sealed virtual override bool get_IHasOperatorMethodExpression_UsesOperatorMethod();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedShortCircuitingOperator : BoundExpression {
    private BoundExpression _LeftOperand;
    private BoundRValuePlaceholder _LeftOperandPlaceholder;
    private BoundExpression _LeftTest;
    private BoundUserDefinedBinaryOperator _BitwiseOperator;
    public BoundExpression LeftOperand { get; }
    public BoundRValuePlaceholder LeftOperandPlaceholder { get; }
    public BoundExpression LeftTest { get; }
    public BoundUserDefinedBinaryOperator BitwiseOperator { get; }
    private IOperation IBinaryOperatorExpression_LeftOperand { get; }
    private BinaryOperationKind IBinaryOperatorExpression_BinaryOperationKind { get; }
    private IOperation IBinaryOperatorExpression_RightOperand { get; }
    private IMethodSymbol IHasOperatorMethodExpression_OperatorMethod { get; }
    private bool IHasOperatorMethodExpression_UsesOperatorMethod { get; }
    public BoundUserDefinedShortCircuitingOperator(VisualBasicSyntaxNode syntax, BoundExpression leftOperand, BoundRValuePlaceholder leftOperandPlaceholder, BoundExpression leftTest, BoundUserDefinedBinaryOperator bitwiseOperator, TypeSymbol type, bool hasErrors);
    public BoundExpression get_LeftOperand();
    public BoundRValuePlaceholder get_LeftOperandPlaceholder();
    public BoundExpression get_LeftTest();
    public BoundUserDefinedBinaryOperator get_BitwiseOperator();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundUserDefinedShortCircuitingOperator Update(BoundExpression leftOperand, BoundRValuePlaceholder leftOperandPlaceholder, BoundExpression leftTest, BoundUserDefinedBinaryOperator bitwiseOperator, TypeSymbol type);
    private sealed virtual override IOperation get_IBinaryOperatorExpression_LeftOperand();
    private sealed virtual override BinaryOperationKind get_IBinaryOperatorExpression_BinaryOperationKind();
    private sealed virtual override IOperation get_IBinaryOperatorExpression_RightOperand();
    private sealed virtual override IMethodSymbol get_IHasOperatorMethodExpression_OperatorMethod();
    private sealed virtual override bool get_IHasOperatorMethodExpression_UsesOperatorMethod();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundUserDefinedUnaryOperator : BoundExpression {
    private UnaryOperatorKind _OperatorKind;
    private BoundExpression _UnderlyingExpression;
    public UnaryOperatorKind OperatorKind { get; }
    public BoundExpression UnderlyingExpression { get; }
    public BoundExpression Operand { get; }
    public BoundCall Call { get; }
    private IMethodSymbol IHasOperatorMethodExpression_OperatorMethod { get; }
    private bool IHasOperatorMethodExpression_UsesOperatorMethod { get; }
    private IOperation IUnaryOperatorExpression_Operand { get; }
    private UnaryOperationKind IUnaryOperatorExpression_UnaryOperationKind { get; }
    public BoundUserDefinedUnaryOperator(VisualBasicSyntaxNode syntax, UnaryOperatorKind operatorKind, BoundExpression underlyingExpression, TypeSymbol type, bool hasErrors);
    public UnaryOperatorKind get_OperatorKind();
    public BoundExpression get_UnderlyingExpression();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundUserDefinedUnaryOperator Update(UnaryOperatorKind operatorKind, BoundExpression underlyingExpression, TypeSymbol type);
    public BoundExpression get_Operand();
    public BoundCall get_Call();
    private sealed virtual override IMethodSymbol get_IHasOperatorMethodExpression_OperatorMethod();
    private sealed virtual override bool get_IHasOperatorMethodExpression_UsesOperatorMethod();
    private sealed virtual override IOperation get_IUnaryOperatorExpression_Operand();
    private sealed virtual override UnaryOperationKind get_IUnaryOperatorExpression_UnaryOperationKind();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundUsingStatement : BoundStatement {
    private ImmutableArray`1<BoundLocalDeclarationBase> _ResourceList;
    private BoundExpression _ResourceExpressionOpt;
    private BoundBlock _Body;
    private UsingInfo _UsingInfo;
    private static ConditionalWeakTable`2<BoundUsingStatement, Variables> s_variablesMappings;
    public ImmutableArray`1<BoundLocalDeclarationBase> ResourceList { get; }
    public BoundExpression ResourceExpressionOpt { get; }
    public BoundBlock Body { get; }
    public UsingInfo UsingInfo { get; }
    private IOperation IUsingStatement_Value { get; }
    private IVariableDeclarationStatement IUsingStatement_Declaration { get; }
    private IOperation IUsingStatement_Body { get; }
    private static BoundUsingStatement();
    public BoundUsingStatement(VisualBasicSyntaxNode syntax, ImmutableArray`1<BoundLocalDeclarationBase> resourceList, BoundExpression resourceExpressionOpt, BoundBlock body, UsingInfo usingInfo, bool hasErrors);
    public ImmutableArray`1<BoundLocalDeclarationBase> get_ResourceList();
    public BoundExpression get_ResourceExpressionOpt();
    public BoundBlock get_Body();
    public UsingInfo get_UsingInfo();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundUsingStatement Update(ImmutableArray`1<BoundLocalDeclarationBase> resourceList, BoundExpression resourceExpressionOpt, BoundBlock body, UsingInfo usingInfo);
    private sealed virtual override IOperation get_IUsingStatement_Value();
    private sealed virtual override IVariableDeclarationStatement get_IUsingStatement_Declaration();
    private sealed virtual override IOperation get_IUsingStatement_Body();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BoundValuePlaceholderBase : BoundExpression {
    protected BoundValuePlaceholderBase(BoundKind kind, VisualBasicSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    protected BoundValuePlaceholderBase(BoundKind kind, VisualBasicSyntaxNode syntax, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundValueTypeMeReference : BoundExpression {
    public bool IsLValue { get; }
    public BoundValueTypeMeReference(VisualBasicSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    public BoundValueTypeMeReference(VisualBasicSyntaxNode syntax, TypeSymbol type);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundValueTypeMeReference Update(TypeSymbol type);
    public virtual bool get_IsLValue();
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundWhileStatement : BoundLoopStatement {
    private BoundExpression _Condition;
    private BoundStatement _Body;
    public BoundExpression Condition { get; }
    public BoundStatement Body { get; }
    private IOperation IForWhileUntilLoopStatement_Condition { get; }
    private IOperation ILoopStatement_Body { get; }
    private LoopKind ILoopStatement_LoopKind { get; }
    private bool IWhileUntilLoopStatement_IsTopTest { get; }
    private bool IWhileUntilLoopStatement_IsWhile { get; }
    public BoundWhileStatement(VisualBasicSyntaxNode syntax, BoundExpression condition, BoundStatement body, LabelSymbol continueLabel, LabelSymbol exitLabel, bool hasErrors);
    public BoundExpression get_Condition();
    public BoundStatement get_Body();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundWhileStatement Update(BoundExpression condition, BoundStatement body, LabelSymbol continueLabel, LabelSymbol exitLabel);
    private sealed virtual override IOperation get_IForWhileUntilLoopStatement_Condition();
    private sealed virtual override IOperation get_ILoopStatement_Body();
    private sealed virtual override LoopKind get_ILoopStatement_LoopKind();
    private sealed virtual override bool get_IWhileUntilLoopStatement_IsTopTest();
    private sealed virtual override bool get_IWhileUntilLoopStatement_IsWhile();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundWithLValueExpressionPlaceholder : BoundLValuePlaceholderBase {
    public BoundWithLValueExpressionPlaceholder(VisualBasicSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    public BoundWithLValueExpressionPlaceholder(VisualBasicSyntaxNode syntax, TypeSymbol type);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundWithLValueExpressionPlaceholder Update(TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundWithRValueExpressionPlaceholder : BoundRValuePlaceholderBase {
    public BoundWithRValueExpressionPlaceholder(VisualBasicSyntaxNode syntax, TypeSymbol type, bool hasErrors);
    public BoundWithRValueExpressionPlaceholder(VisualBasicSyntaxNode syntax, TypeSymbol type);
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundWithRValueExpressionPlaceholder Update(TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundWithStatement : BoundStatement {
    private BoundExpression _OriginalExpression;
    private BoundBlock _Body;
    private WithBlockBinder _Binder;
    public BoundExpression OriginalExpression { get; }
    public BoundBlock Body { get; }
    public WithBlockBinder Binder { get; }
    internal BoundValuePlaceholderBase ExpressionPlaceholder { get; }
    internal ImmutableArray`1<BoundExpression> DraftInitializers { get; }
    internal BoundExpression DraftPlaceholderSubstitute { get; }
    private IOperation IWithStatement_Body { get; }
    private IOperation IWithStatement_Value { get; }
    public BoundWithStatement(VisualBasicSyntaxNode syntax, BoundExpression originalExpression, BoundBlock body, WithBlockBinder binder, bool hasErrors);
    public BoundExpression get_OriginalExpression();
    public BoundBlock get_Body();
    public WithBlockBinder get_Binder();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundWithStatement Update(BoundExpression originalExpression, BoundBlock body, WithBlockBinder binder);
    internal BoundValuePlaceholderBase get_ExpressionPlaceholder();
    internal ImmutableArray`1<BoundExpression> get_DraftInitializers();
    internal BoundExpression get_DraftPlaceholderSubstitute();
    private sealed virtual override IOperation get_IWithStatement_Body();
    private sealed virtual override IOperation get_IWithStatement_Value();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundXmlAttribute : BoundExpression {
    private BoundExpression _Name;
    private BoundExpression _Value;
    private bool _MatchesImport;
    private BoundExpression _ObjectCreation;
    public BoundExpression Name { get; }
    public BoundExpression Value { get; }
    public bool MatchesImport { get; }
    public BoundExpression ObjectCreation { get; }
    public BoundXmlAttribute(VisualBasicSyntaxNode syntax, BoundExpression name, BoundExpression value, bool matchesImport, BoundExpression objectCreation, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Name();
    public BoundExpression get_Value();
    public bool get_MatchesImport();
    public BoundExpression get_ObjectCreation();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundXmlAttribute Update(BoundExpression name, BoundExpression value, bool matchesImport, BoundExpression objectCreation, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundXmlCData : BoundExpression {
    private BoundLiteral _Value;
    private BoundExpression _ObjectCreation;
    public BoundLiteral Value { get; }
    public BoundExpression ObjectCreation { get; }
    public BoundXmlCData(VisualBasicSyntaxNode syntax, BoundLiteral value, BoundExpression objectCreation, TypeSymbol type, bool hasErrors);
    public BoundLiteral get_Value();
    public BoundExpression get_ObjectCreation();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundXmlCData Update(BoundLiteral value, BoundExpression objectCreation, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundXmlComment : BoundExpression {
    private BoundExpression _Value;
    private BoundExpression _ObjectCreation;
    public BoundExpression Value { get; }
    public BoundExpression ObjectCreation { get; }
    public BoundXmlComment(VisualBasicSyntaxNode syntax, BoundExpression value, BoundExpression objectCreation, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Value();
    public BoundExpression get_ObjectCreation();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundXmlComment Update(BoundExpression value, BoundExpression objectCreation, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundXmlContainerRewriterInfo : object {
    public bool IsRoot;
    public BoundRValuePlaceholder Placeholder;
    public BoundExpression ObjectCreation;
    public BoundRValuePlaceholder XmlnsAttributesPlaceholder;
    public BoundExpression XmlnsAttributes;
    public BoundRValuePlaceholder PrefixesPlaceholder;
    public BoundRValuePlaceholder NamespacesPlaceholder;
    public ImmutableArray`1<KeyValuePair`2<string, string>> ImportedNamespaces;
    public ImmutableArray`1<KeyValuePair`2<string, string>> InScopeXmlNamespaces;
    public ImmutableArray`1<BoundExpression> SideEffects;
    public bool HasErrors;
    public BoundXmlContainerRewriterInfo(BoundExpression objectCreation);
    public BoundXmlContainerRewriterInfo(bool isRoot, BoundRValuePlaceholder placeholder, BoundExpression objectCreation, BoundRValuePlaceholder xmlnsAttributesPlaceholder, BoundExpression xmlnsAttributes, BoundRValuePlaceholder prefixesPlaceholder, BoundRValuePlaceholder namespacesPlaceholder, ImmutableArray`1<KeyValuePair`2<string, string>> importedNamespaces, ImmutableArray`1<KeyValuePair`2<string, string>> inScopeXmlNamespaces, ImmutableArray`1<BoundExpression> sideEffects);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundXmlDeclaration : BoundExpression {
    private BoundExpression _Version;
    private BoundExpression _Encoding;
    private BoundExpression _Standalone;
    private BoundExpression _ObjectCreation;
    public BoundExpression Version { get; }
    public BoundExpression Encoding { get; }
    public BoundExpression Standalone { get; }
    public BoundExpression ObjectCreation { get; }
    public BoundXmlDeclaration(VisualBasicSyntaxNode syntax, BoundExpression version, BoundExpression encoding, BoundExpression standalone, BoundExpression objectCreation, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Version();
    public BoundExpression get_Encoding();
    public BoundExpression get_Standalone();
    public BoundExpression get_ObjectCreation();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundXmlDeclaration Update(BoundExpression version, BoundExpression encoding, BoundExpression standalone, BoundExpression objectCreation, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundXmlDocument : BoundExpression {
    private BoundExpression _Declaration;
    private ImmutableArray`1<BoundExpression> _ChildNodes;
    private BoundXmlContainerRewriterInfo _RewriterInfo;
    public BoundExpression Declaration { get; }
    public ImmutableArray`1<BoundExpression> ChildNodes { get; }
    public BoundXmlContainerRewriterInfo RewriterInfo { get; }
    public BoundXmlDocument(VisualBasicSyntaxNode syntax, BoundExpression declaration, ImmutableArray`1<BoundExpression> childNodes, BoundXmlContainerRewriterInfo rewriterInfo, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Declaration();
    public ImmutableArray`1<BoundExpression> get_ChildNodes();
    public BoundXmlContainerRewriterInfo get_RewriterInfo();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundXmlDocument Update(BoundExpression declaration, ImmutableArray`1<BoundExpression> childNodes, BoundXmlContainerRewriterInfo rewriterInfo, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundXmlElement : BoundExpression {
    private BoundExpression _Argument;
    private ImmutableArray`1<BoundExpression> _ChildNodes;
    private BoundXmlContainerRewriterInfo _RewriterInfo;
    public BoundExpression Argument { get; }
    public ImmutableArray`1<BoundExpression> ChildNodes { get; }
    public BoundXmlContainerRewriterInfo RewriterInfo { get; }
    public BoundXmlElement(VisualBasicSyntaxNode syntax, BoundExpression argument, ImmutableArray`1<BoundExpression> childNodes, BoundXmlContainerRewriterInfo rewriterInfo, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Argument();
    public ImmutableArray`1<BoundExpression> get_ChildNodes();
    public BoundXmlContainerRewriterInfo get_RewriterInfo();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundXmlElement Update(BoundExpression argument, ImmutableArray`1<BoundExpression> childNodes, BoundXmlContainerRewriterInfo rewriterInfo, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundXmlEmbeddedExpression : BoundExpression {
    private BoundExpression _Expression;
    public BoundExpression Expression { get; }
    public BoundXmlEmbeddedExpression(VisualBasicSyntaxNode syntax, BoundExpression expression, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Expression();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundXmlEmbeddedExpression Update(BoundExpression expression, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundXmlMemberAccess : BoundExpression {
    private BoundExpression _MemberAccess;
    public BoundExpression MemberAccess { get; }
    public BoundXmlMemberAccess(VisualBasicSyntaxNode syntax, BoundExpression memberAccess, TypeSymbol type, bool hasErrors);
    public BoundExpression get_MemberAccess();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundXmlMemberAccess Update(BoundExpression memberAccess, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundXmlName : BoundExpression {
    private BoundExpression _XmlNamespace;
    private BoundExpression _LocalName;
    private BoundExpression _ObjectCreation;
    public BoundExpression XmlNamespace { get; }
    public BoundExpression LocalName { get; }
    public BoundExpression ObjectCreation { get; }
    public BoundXmlName(VisualBasicSyntaxNode syntax, BoundExpression xmlNamespace, BoundExpression localName, BoundExpression objectCreation, TypeSymbol type, bool hasErrors);
    public BoundExpression get_XmlNamespace();
    public BoundExpression get_LocalName();
    public BoundExpression get_ObjectCreation();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundXmlName Update(BoundExpression xmlNamespace, BoundExpression localName, BoundExpression objectCreation, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundXmlNamespace : BoundExpression {
    private BoundExpression _XmlNamespace;
    private BoundExpression _ObjectCreation;
    public BoundExpression XmlNamespace { get; }
    public BoundExpression ObjectCreation { get; }
    public BoundXmlNamespace(VisualBasicSyntaxNode syntax, BoundExpression xmlNamespace, BoundExpression objectCreation, TypeSymbol type, bool hasErrors);
    public BoundExpression get_XmlNamespace();
    public BoundExpression get_ObjectCreation();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundXmlNamespace Update(BoundExpression xmlNamespace, BoundExpression objectCreation, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundXmlProcessingInstruction : BoundExpression {
    private BoundExpression _Target;
    private BoundExpression _Data;
    private BoundExpression _ObjectCreation;
    public BoundExpression Target { get; }
    public BoundExpression Data { get; }
    public BoundExpression ObjectCreation { get; }
    public BoundXmlProcessingInstruction(VisualBasicSyntaxNode syntax, BoundExpression target, BoundExpression data, BoundExpression objectCreation, TypeSymbol type, bool hasErrors);
    public BoundExpression get_Target();
    public BoundExpression get_Data();
    public BoundExpression get_ObjectCreation();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundXmlProcessingInstruction Update(BoundExpression target, BoundExpression data, BoundExpression objectCreation, TypeSymbol type);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BoundYieldStatement : BoundStatement {
    private BoundExpression _Expression;
    public BoundExpression Expression { get; }
    private IOperation IReturnStatement_ReturnedValue { get; }
    public BoundYieldStatement(VisualBasicSyntaxNode syntax, BoundExpression expression, bool hasErrors);
    internal BoundYieldStatement(VisualBasicSyntaxNode syntax, BoundExpression expression, bool hasErrors, bool returnTypeIsBeingInferred);
    public BoundExpression get_Expression();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public BoundYieldStatement Update(BoundExpression expression);
    private sealed virtual override IOperation get_IReturnStatement_ReturnedValue();
    protected virtual OperationKind StatementKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.VisualBasic.CatchBlockBinder : BlockBaseBinder {
    private CatchBlockSyntax _syntax;
    private ImmutableArray`1<LocalSymbol> _locals;
    internal ImmutableArray`1<LocalSymbol> Locals { get; }
    public CatchBlockBinder(Binder enclosing, CatchBlockSyntax syntax);
    internal virtual ImmutableArray`1<LocalSymbol> get_Locals();
    private ImmutableArray`1<LocalSymbol> BuildLocals();
}
internal enum Microsoft.CodeAnalysis.VisualBasic.ClosureKind : Enum {
    public int value__;
    public static ClosureKind Static;
    public static ClosureKind ThisOnly;
    public static ClosureKind General;
}
internal class Microsoft.CodeAnalysis.VisualBasic.ClsComplianceChecker : VisualBasicSymbolVisitor {
    private static ParallelOptions s_defaultParallelOptions;
    private VisualBasicCompilation _compilation;
    private SyntaxTree _filterTree;
    private Nullable`1<TextSpan> _filterSpanWithinTree;
    private ConcurrentQueue`1<Diagnostic> _diagnostics;
    private CancellationToken _cancellationToken;
    private ConcurrentDictionary`2<Symbol, Compliance> _declaredOrInheritedCompliance;
    private static ClsComplianceChecker();
    private ClsComplianceChecker(VisualBasicCompilation compilation, SyntaxTree filterTree, Nullable`1<TextSpan> filterSpanWithinTree, ConcurrentQueue`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    public static void CheckCompliance(VisualBasicCompilation compilation, DiagnosticBag diagnostics, CancellationToken cancellationToken, SyntaxTree filterTree, Nullable`1<TextSpan> filterSpanWithinTree);
    public virtual void VisitAssembly(AssemblySymbol symbol);
    public virtual void VisitModule(ModuleSymbol symbol);
    public virtual void VisitNamespace(NamespaceSymbol symbol);
    public virtual void VisitNamedType(NamedTypeSymbol symbol);
    private bool HasAcceptableAttributeConstructor(NamedTypeSymbol attributeType);
    public virtual void VisitMethod(MethodSymbol symbol);
    public virtual void VisitProperty(PropertySymbol symbol);
    public virtual void VisitEvent(EventSymbol symbol);
    public virtual void VisitField(FieldSymbol symbol);
    private bool VisitTypeOrMember(Symbol symbol, Compliance compliance);
    private void CheckForNonCompliantAbstractMember(Symbol symbol);
    private void CheckBaseTypeCompliance(NamedTypeSymbol symbol);
    private void CheckForCompliantWithinNonCompliant(Symbol symbol);
    private void CheckTypeParameterCompliance(ImmutableArray`1<TypeParameterSymbol> typeParameters, NamedTypeSymbol context);
    private void CheckParameterCompliance(ImmutableArray`1<ParameterSymbol> parameters, NamedTypeSymbol context);
    private bool TryGetAttributeWarningLocation(VisualBasicAttributeData attribute, Location& location);
    private void CheckReturnTypeCompliance(Symbol symbol);
    private void CheckEventTypeCompliance(EventSymbol symbol);
    private void CheckMemberDistinctness(NamespaceOrTypeSymbol symbol);
    private void CheckSymbolDistinctness(Symbol symbol, ValueSet<string, Symbol> sameNameSymbols);
    private void CheckName(Symbol symbol);
    private bool DoNotVisit(Symbol symbol);
    private bool IsSyntacticallyFilteredOut(Symbol symbol);
    private bool ShouldReportNonCompliantType(TypeSymbol type, NamedTypeSymbol context, Symbol diagnosticSymbol);
    private void ReportNonCompliantTypeArguments(TypeSymbol type, NamedTypeSymbol context, Symbol diagnosticSymbol);
    private void ReportNonCompliantTypeArguments(NamedTypeSymbol type, NamedTypeSymbol context, Symbol diagnosticSymbol);
    private bool IsCompliantType(TypeSymbol type, NamedTypeSymbol context);
    private bool IsCompliantType(NamedTypeSymbol type);
    private Compliance GetDeclaredOrInheritedCompliance(Symbol symbol);
    private Compliance GetInheritedCompliance(Symbol symbol);
    private Nullable`1<bool> GetDeclaredCompliance(Symbol symbol, Location& attributeLocation);
    private Nullable`1<bool> GetDeclaredComplianceHelper(Symbol symbol, Location& attributeLocation, Boolean& isAttributeInherited);
    private Symbol GetContainingModuleOrAssembly(Symbol symbol);
    private static bool IsAccessibleOutsideAssembly(Symbol symbol);
    private static bool IsAccessibleIfContainerIsAccessible(Symbol symbol);
    private void AddDiagnostic(Symbol symbol, ERRID code, Object[] args);
    private void AddDiagnostic(Symbol symbol, ERRID code, Location location, Object[] args);
    private static bool IsImplicitClass(Symbol symbol);
    private static bool IsTrue(Compliance compliance);
    private static bool IsDeclared(Compliance compliance);
    private static bool SignaturesCollide(Symbol x, Symbol y);
    private static bool IsArrayOfArrays(ArrayTypeSymbol arrayType);
    private static ImmutableArray`1<TypeSymbol> GetParameterTypes(Symbol symbol);
    private static ImmutableArray`1<RefKind> GetParameterRefKinds(Symbol symbol);
}
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGen.CodeGenerator : object {
    private MethodSymbol _method;
    private BoundStatement _block;
    private ILBuilder _builder;
    private PEModuleBuilder _module;
    private DiagnosticBag _diagnostics;
    private ILEmitStyle _ilEmitStyle;
    private bool _emitPdbSequencePoints;
    private HashSet`1<LocalSymbol> _stackLocals;
    private int _tryNestingLevel;
    private BoundCatchBlock _currentCatchBlock;
    private SynthesizedLocalOrdinalsDispenser _synthesizedLocalOrdinals;
    private int _uniqueNameId;
    private static object s_returnLabel;
    private bool _unhandledReturn;
    private bool _checkCallsForUnsafeJITOptimization;
    private int _asyncCatchHandlerOffset;
    private ArrayBuilder`1<int> _asyncYieldPoints;
    private ArrayBuilder`1<int> _asyncResumePoints;
    private int _recursionDepth;
    private static ILOpCode[] s_compOpCodes;
    private static int s_IL_OP_CODE_ROW_LENGTH;
    private static ILOpCode[] s_condJumpOpCodes;
    private static CodeGenerator();
    public CodeGenerator(MethodSymbol method, BoundStatement boundBody, ILBuilder builder, PEModuleBuilder moduleBuilder, DiagnosticBag diagnostics, OptimizationLevel optimizations, bool emittingPdb);
    private bool IsDebugPlus();
    public void Generate();
    public void Generate(Int32& asyncCatchHandlerOffset, ImmutableArray`1& asyncYieldPoints, ImmutableArray`1& asyncResumePoints);
    private void GenerateImpl();
    private void HandleReturn();
    private void EmitFieldAccess(BoundFieldAccess fieldAccess);
    private bool IsStackLocal(LocalSymbol local);
    private void EmitLocalStore(BoundLocal local);
    private void EmitSymbolToken(FieldSymbol symbol, VisualBasicSyntaxNode syntaxNode);
    private void EmitSymbolToken(MethodSymbol symbol, VisualBasicSyntaxNode syntaxNode);
    private void EmitSymbolToken(TypeSymbol symbol, VisualBasicSyntaxNode syntaxNode);
    private void EmitSequencePointExpression(BoundSequencePointExpression node, bool used);
    private void EmitSequencePointExpressionAddress(BoundSequencePointExpression node, AddressKind addressKind);
    private void EmitSequencePointStatement(BoundSequencePoint node);
    private void EmitSequencePointStatement(BoundSequencePointWithSpan node);
    private void SetInitialDebugDocument();
    private void EmitHiddenSequencePoint();
    private void EmitSequencePoint(VisualBasicSyntaxNode syntax);
    private TextSpan EmitSequencePoint(SyntaxTree tree, TextSpan span);
    private LocalDefinition EmitAddress(BoundExpression expression, AddressKind addressKind);
    private void EmitPseudoVariableAddress(BoundPseudoVariable expression);
    private LocalDefinition EmitAddressOfTempClone(BoundExpression expression);
    private LocalDefinition EmitSequenceAddress(BoundSequence sequence, AddressKind addressKind);
    private BoundLocal DigForLocal(BoundExpression value);
    private bool HasHome(BoundExpression expression);
    private bool HasHome(BoundFieldAccess fieldAccess);
    private bool AllowedToTakeRef(BoundExpression expression, AddressKind addressKind);
    private bool AllowedToTakeRef(BoundLocal boundLocal, AddressKind addressKind);
    private bool AllowedToTakeRef(BoundFieldAccess fieldAccess, AddressKind addressKind);
    private void EmitArrayElementAddress(BoundArrayAccess arrayAccess, AddressKind addressKind);
    private LocalDefinition EmitFieldAddress(BoundFieldAccess fieldAccess, AddressKind addressKind);
    private void EmitStaticFieldAddress(FieldSymbol field, VisualBasicSyntaxNode syntaxNode);
    private void EmitParameterAddress(BoundParameter parameter);
    private LocalDefinition EmitReceiverRef(BoundExpression receiver, bool isAccessConstrained, AddressKind addressKind);
    private LocalDefinition EmitInstanceFieldAddress(BoundFieldAccess fieldAccess, AddressKind addressKind);
    private void EmitArrayInitializers(ArrayTypeSymbol arrayType, BoundArrayInitialization inits);
    private void EmitElementInitializers(ArrayTypeSymbol arrayType, ImmutableArray`1<BoundExpression> inits, bool includeConstants);
    private void EmitOnedimensionalElementInitializers(ArrayTypeSymbol arrayType, ImmutableArray`1<BoundExpression> inits, bool includeConstants);
    private static bool ShouldEmitInitExpression(bool includeConstants, BoundExpression init);
    private void EmitMultidimensionalElementInitializers(ArrayTypeSymbol arrayType, ImmutableArray`1<BoundExpression> inits, bool includeConstants);
    private void EmitAllElementInitializersRecursive(ArrayTypeSymbol arrayType, ArrayBuilder`1<IndexDesc> indices, bool includeConstants);
    private ConstantValue AsConstOrDefault(BoundExpression init);
    private ArrayInitializerStyle ShouldEmitBlockInitializer(TypeSymbol elementType, ImmutableArray`1<BoundExpression> inits);
    private void InitializerCountRecursive(ImmutableArray`1<BoundExpression> inits, Int32& initCount, Int32& constInits);
    private ImmutableArray`1<byte> GetRawData(ImmutableArray`1<BoundExpression> initializers);
    private void SerializeArrayRecursive(BlobBuilder bw, ImmutableArray`1<BoundExpression> inits);
    private bool IsMultidimensionalInitializer(ImmutableArray`1<BoundExpression> inits);
    private static bool IsSimpleType(PrimitiveTypeCode type);
    private void EmitConvertIntrinsic(BoundConversion conversion, PrimitiveTypeCode underlyingFrom, PrimitiveTypeCode underlyingTo);
    private void EmitConvertSimpleNumeric(BoundConversion conversion, PrimitiveTypeCode typeFrom, PrimitiveTypeCode typeTo, bool checked);
    private void EmitConversionExpression(BoundConversion conversion, bool used);
    private bool IsUnboxingDirectCast(BoundDirectCast conversion);
    private void EmitDirectCastExpression(BoundDirectCast conversion, bool used);
    private bool ConversionHasSideEffects(BoundConversion conversion);
    private bool ConversionHasSideEffects(BoundDirectCast conversion);
    private bool ConversionHasSideEffects(BoundTryCast conversion);
    private void EmitTryCastExpression(BoundTryCast conversion, bool used);
    private void EmitExpression(BoundExpression expression, bool used);
    private void EmitExpressionCoreWithStackGuard(BoundExpression expression, bool used);
    private void EmitExpressionCore(BoundExpression expression, bool used);
    private void EmitConditionalAccessReceiverPlaceholder(BoundConditionalAccessReceiverPlaceholder expression, bool used);
    private void EmitComplexConditionalAccessReceiver(BoundComplexConditionalAccessReceiver expression, bool used);
    private void EmitConditionalAccess(BoundLoweredConditionalAccess conditional, bool used);
    private void EmitComplexConditionalAccessReceiverAddress(BoundComplexConditionalAccessReceiver expression);
    private void EmitDelegateCreationExpression(BoundDelegateCreationExpression expression, bool used);
    private void EmitLocalLoad(BoundLocal local, bool used);
    private void EmitDelegateCreation(BoundExpression receiver, MethodSymbol method, TypeSymbol delegateType, bool used, VisualBasicSyntaxNode syntaxNode);
    private void EmitMeOrMyClassReferenceExpression(BoundExpression thisRef);
    private void EmitPseudoVariableValue(BoundPseudoVariable expression, bool used);
    private void EmitSequenceExpression(BoundSequence sequence, bool used);
    private void EmitSideEffects(ImmutableArray`1<BoundExpression> sideEffects);
    private void EmitExpressions(ImmutableArray`1<BoundExpression> expressions, bool used);
    private void EmitArguments(ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<ParameterSymbol> parameters);
    private void EmitArrayElementLoad(BoundArrayAccess arrayAccess, bool used);
    private void EmitFieldLoad(BoundFieldAccess fieldAccess, bool used);
    private void EmitDupExpression(BoundDup dupExpression, bool used);
    private void EmitStaticFieldLoad(FieldSymbol field, bool used, VisualBasicSyntaxNode syntaxNode);
    private void EmitInstanceFieldLoad(BoundFieldAccess fieldAccess, bool used);
    private bool EmitFieldLoadReceiverAddress(BoundExpression receiver);
    private bool FieldLoadPrefersRef(BoundExpression receiver);
    internal static bool FieldLoadMustUseRef(BoundExpression expr);
    private int ParameterSlot(BoundParameter parameter);
    private void EmitParameterLoad(BoundParameter parameter);
    private void EmitLoadIndirect(TypeSymbol type, VisualBasicSyntaxNode syntaxNode);
    private bool CanUseCallOnRefTypeReceiver(BoundExpression receiver);
    private bool IsMeReceiver(BoundExpression receiver);
    private void EmitCallExpression(BoundCall call, bool used);
    private bool MayUseCallForStructMethod(MethodSymbol method);
    private void EmitTypeOfExpression(BoundTypeOf expression, bool used, bool optimize);
    private void EmitTernaryConditionalExpression(BoundTernaryConditionalExpression expr, bool used);
    private void EmitBinaryConditionalExpression(BoundBinaryConditionalExpression expr, bool used);
    private TypeSymbol StackMergeType(BoundExpression expr);
    private static bool IsVarianceCast(TypeSymbol toType, TypeSymbol fromType);
    private void EmitStaticCast(TypeSymbol toType, VisualBasicSyntaxNode syntax);
    private void EmitArrayCreationExpression(BoundArrayCreation expression, bool used);
    private void EmitArrayLengthExpression(BoundArrayLength expression, bool used);
    private void EmitObjectCreationExpression(BoundObjectCreationExpression expression, bool used);
    private void EmitInitObj(TypeSymbol type, bool used, VisualBasicSyntaxNode syntaxNode);
    private void EmitNewObj(MethodSymbol constructor, ImmutableArray`1<BoundExpression> arguments, bool used, VisualBasicSyntaxNode syntaxNode);
    private void EmitLoadDefaultValueOfTypeParameter(TypeSymbol type, bool used, VisualBasicSyntaxNode syntaxNode);
    private void EmitLoadDefaultValueOfTypeFromConstructorCall(MethodSymbol constructor, bool used, VisualBasicSyntaxNode syntaxNode);
    private void EmitLoadDefaultValueOfTypeFromNothingLiteral(TypeSymbol type, bool used, VisualBasicSyntaxNode syntaxNode);
    private void EmitStructConstructorCallOnTarget(MethodSymbol constructor, ImmutableArray`1<BoundExpression> arguments, BoundExpression target, VisualBasicSyntaxNode syntaxNode);
    private void EmitInitObjOnTarget(BoundExpression target);
    private void EmitConstantExpression(TypeSymbol type, ConstantValue constantValue, bool used, VisualBasicSyntaxNode syntaxNode);
    private void EmitConstantExpression(BoundExpression expression);
    private void EmitAssignmentExpression(BoundAssignmentOperator assignmentOperator, bool used);
    private bool TryEmitAssignmentInPlace(BoundAssignmentOperator assignmentOperator, bool used);
    private bool SafeToGetWriteableReference(BoundExpression left);
    private void InPlaceInit(BoundExpression target, bool used);
    private void InPlaceCtorCall(BoundExpression target, BoundObjectCreationExpression objCreation, bool used);
    private bool PartialCtorResultCannotEscape(BoundExpression left);
    private bool TargetIsNotOnHeap(BoundExpression left);
    private bool EmitAssignmentPreamble(BoundExpression assignmentTarget);
    private LocalDefinition EmitAssignmentDuplication(BoundAssignmentOperator assignmentOperator, bool used, bool lhsUsesStack);
    private void EmitAssignmentPostfix(LocalDefinition temp);
    private void EmitReferenceAssignment(BoundReferenceAssignment capture, bool used, bool needReference);
    private void EmitStore(BoundExpression expression);
    private void EmitMeStore(BoundMeReference thisRef);
    private void EmitArrayElementStore(ArrayTypeSymbol arrayType, VisualBasicSyntaxNode syntaxNode);
    private void EmitVectorElementStore(ArrayTypeSymbol arrayType, VisualBasicSyntaxNode syntaxNode);
    private void EmitFieldStore(BoundFieldAccess fieldAccess);
    private void EmitParameterStore(BoundParameter parameter);
    private void EmitStoreIndirect(TypeSymbol type, VisualBasicSyntaxNode syntaxNode);
    private void EmitPopIfUnused(bool used);
    private void EmitGetType(BoundGetType boundTypeOfOperator, bool used);
    private void EmitFieldInfoExpression(BoundFieldInfo node, bool used);
    private void EmitMethodInfoExpression(BoundMethodInfo node, bool used);
    private void EmitBox(TypeSymbol type, VisualBasicSyntaxNode syntaxNode);
    private void EmitUnboxAny(TypeSymbol type, VisualBasicSyntaxNode syntaxNode);
    private void EmitUnaryOperatorExpression(BoundUnaryOperator expression, bool used);
    private static bool OperatorHasSideEffects(BoundUnaryOperator expression);
    private void EmitBinaryOperatorExpression(BoundBinaryOperator expression, bool used);
    private bool IsCondOperator(BinaryOperatorKind operationKind);
    private void EmitBinaryOperator(BoundBinaryOperator expression);
    private void EmitBinaryOperatorSimple(BoundBinaryOperator expression);
    private bool OperatorHasSideEffects(BoundBinaryOperator expression);
    private void EmitBinaryArithOperator(BoundBinaryOperator expression);
    private void EmitBinaryArithOperatorInstructionAndDowncast(BoundBinaryOperator expression);
    private void DowncastResultOfArithmeticOperation(PrimitiveTypeCode targetPrimitiveType, bool isChecked);
    public static int GetShiftSizeMask(TypeSymbol leftOperandType);
    private void EmitShortCircuitingOperator(BoundBinaryOperator condition, bool sense, bool stopSense, bool stopValue);
    private void EmitBinaryCondOperator(BoundBinaryOperator binOp, bool sense);
    private void EmitIsNotNullOrZero(BoundExpression comparand, ConstantValue nullOrZero);
    private void EmitIsNullOrZero(BoundExpression comparand, ConstantValue nullOrZero);
    private void EmitBinaryCondOperatorHelper(ILOpCode opCode, BoundExpression left, BoundExpression right, bool sense);
    private ConstResKind EmitCondExpr(BoundExpression condition, bool sense);
    private void EmitIsSense(bool sense);
    private void EmitStatement(BoundStatement statement);
    private int EmitStatementAndCountInstructions(BoundStatement statement);
    private void EmitNoOpStatement(BoundNoOpStatement statement);
    private void EmitTryStatement(BoundTryStatement statement, bool emitCatchesOnly);
    private void EmitCatchBlock(BoundCatchBlock catchBlock);
    private bool ShouldNoteProjectErrors();
    private void EmitSetProjectError(VisualBasicSyntaxNode syntaxNode, BoundExpression errorLineNumberOpt);
    private void EmitClearProjectError(VisualBasicSyntaxNode syntaxNode);
    private void EmitConditionalGoto(BoundConditionalGoto boundConditionalGoto);
    private bool CanPassToBrfalse(TypeSymbol ts);
    private BoundExpression TryReduce(BoundBinaryOperator condition, Boolean& sense);
    private ILOpCode CodeForJump(BoundBinaryOperator expression, bool sense, ILOpCode& revOpCode);
    private void EmitCondBranch(BoundExpression condition, Object& lazyDest, bool sense);
    private void EmitCondBranchCoreWithStackGuard(BoundExpression condition, Object& lazyDest, bool sense);
    private void EmitCondBranchCore(BoundExpression condition, Object& lazyDest, bool sense);
    [ConditionalAttribute("DEBUG")]
private void ValidateReferenceEqualityOperands(BoundBinaryOperator binOp);
    private void EmitSequenceCondBranch(BoundSequence sequence, Object& lazyDest, bool sense);
    private void EmitLabelStatement(BoundLabelStatement boundLabelStatement);
    private void EmitGotoStatement(BoundGotoStatement boundGotoStatement);
    private void EmitReturnStatement(BoundReturnStatement boundReturnStatement);
    private void EmitThrowStatement(BoundThrowStatement boundThrowStatement);
    private void EmitSelectStatement(BoundSelectStatement boundSelectStatement);
    private ImmutableArray`1<GeneratedLabelSymbol> CreateCaseBlockLabels(ImmutableArray`1<BoundCaseBlock> caseBlocks);
    private KeyValuePair`2[] GetCaseLabelsForEmitSwitchHeader(ImmutableArray`1<BoundCaseBlock> caseBlocks, ImmutableArray`1<GeneratedLabelSymbol> caseBlockLabels, LabelSymbol& fallThroughLabel);
    private void EmitSwitchTableHeader(BoundExpression selectExpression, KeyValuePair`2[] caseLabels, LabelSymbol fallThroughLabel);
    private void EmitStringSwitchJumpTable(KeyValuePair`2[] caseLabels, LabelSymbol fallThroughLabel, LocalDefinition key, VisualBasicSyntaxNode syntaxNode);
    private void EmitStringCompareAndBranch(LocalOrParameter key, SyntaxNode syntaxNode, ConstantValue stringConstant, object targetLabel, IReference stringCompareMethodRef);
    private void EmitCaseBlocks(ImmutableArray`1<BoundCaseBlock> caseBlocks, ImmutableArray`1<GeneratedLabelSymbol> caseBlockLabels, LabelSymbol exitLabel);
    private void EmitBlock(BoundBlock scope);
    private LocalDefinition DefineLocal(LocalSymbol local, VisualBasicSyntaxNode syntaxNode);
    private string GetLocalDebugName(LocalSymbol local, LocalDebugId& localId);
    private bool IsSlotReusable(LocalSymbol local);
    private void FreeLocal(LocalSymbol local);
    private LocalDefinition GetLocal(BoundLocal localExpression);
    private LocalDefinition GetLocal(LocalSymbol symbol);
    private LocalDefinition AllocateTemp(TypeSymbol type, VisualBasicSyntaxNode syntaxNode);
    private void FreeTemp(LocalDefinition temp);
    private void FreeOptTemp(LocalDefinition temp);
    private void EmitUnstructuredExceptionOnErrorSwitch(BoundUnstructuredExceptionOnErrorSwitch node);
    private void EmitSwitch(ImmutableArray`1<BoundGotoStatement> jumps);
    private void EmitStateMachineScope(BoundStateMachineScope scope);
    private void DefineUserDefinedStateMachineHoistedLocal(StateMachineFieldSymbol field);
    private void EmitUnstructuredExceptionResumeSwitch(BoundUnstructuredExceptionResumeSwitch node);
}
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGen.Optimizer : object {
    public static BoundStatement Optimize(Symbol container, BoundStatement src, bool debugFriendly, HashSet`1& stackLocals);
}
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGen.StackScheduler : object {
    public static BoundStatement OptimizeLocalsOut(Symbol container, BoundStatement src, bool debugFriendly, HashSet`1& stackLocals);
    private static Dictionary`2<LocalSymbol, LocalDefUseInfo> FilterValidStackLocals(Dictionary`2<LocalSymbol, LocalDefUseInfo> info);
}
public class Microsoft.CodeAnalysis.VisualBasic.CollectionRangeVariableSymbolInfo : ValueType {
    [CompilerGeneratedAttribute]
private SymbolInfo _ToQueryableCollectionConversion;
    [CompilerGeneratedAttribute]
private SymbolInfo _AsClauseConversion;
    [CompilerGeneratedAttribute]
private SymbolInfo _SelectMany;
    internal static CollectionRangeVariableSymbolInfo None;
    public SymbolInfo ToQueryableCollectionConversion { get; }
    public SymbolInfo AsClauseConversion { get; }
    public SymbolInfo SelectMany { get; }
    private static CollectionRangeVariableSymbolInfo();
    internal CollectionRangeVariableSymbolInfo(SymbolInfo toQueryableCollectionConversion, SymbolInfo asClauseConversion, SymbolInfo selectMany);
    [CompilerGeneratedAttribute]
public SymbolInfo get_ToQueryableCollectionConversion();
    [CompilerGeneratedAttribute]
public SymbolInfo get_AsClauseConversion();
    [CompilerGeneratedAttribute]
public SymbolInfo get_SelectMany();
}
internal class Microsoft.CodeAnalysis.VisualBasic.CommandLineDiagnosticFormatter : VisualBasicDiagnosticFormatter {
    private string _baseDirectory;
    private Func`1<ImmutableArray`1<AdditionalTextFile>> _getAdditionalTextFiles;
    internal CommandLineDiagnosticFormatter(string baseDirectory, Func`1<ImmutableArray`1<AdditionalTextFile>> getAdditionalTextFiles);
    public virtual string Format(Diagnostic diagnostic, IFormatProvider formatter);
    internal virtual string FormatSourcePath(string path, string basePath, IFormatProvider formatter);
    private Nullable`1<TextSpan> GetDiagnosticSpanAndFileText(Diagnostic diagnostic, SourceText& text);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CompileTimeCalculations : object {
    internal static long UncheckedCLng(ulong v);
    internal static long UncheckedCLng(double v);
    internal static ulong UncheckedCULng(long v);
    internal static ulong UncheckedCULng(int v);
    internal static ulong UncheckedCULng(double v);
    internal static int UncheckedCInt(ulong v);
    internal static int UncheckedCInt(long v);
    internal static UInt32 UncheckedCUInt(ulong v);
    internal static UInt32 UncheckedCUInt(long v);
    internal static UInt32 UncheckedCUInt(int v);
    internal static short UncheckedCShort(ulong v);
    internal static short UncheckedCShort(long v);
    internal static short UncheckedCShort(int v);
    internal static short UncheckedCShort(ushort v);
    internal static int UncheckedCInt(UInt32 v);
    internal static short UncheckedCShort(UInt32 v);
    internal static ushort UncheckedCUShort(short v);
    internal static ushort UncheckedCUShort(int v);
    internal static ushort UncheckedCUShort(long v);
    internal static byte UncheckedCByte(sbyte v);
    internal static byte UncheckedCByte(int v);
    internal static byte UncheckedCByte(long v);
    internal static byte UncheckedCByte(ushort v);
    internal static sbyte UncheckedCSByte(byte v);
    internal static sbyte UncheckedCSByte(int v);
    internal static sbyte UncheckedCSByte(long v);
    internal static int UncheckedMul(int x, int y);
    internal static long UncheckedMul(long x, long y);
    internal static long UncheckedIntegralDiv(long x, long y);
    private static int UncheckedAdd(int x, int y);
    private static long UncheckedAdd(long x, long y);
    private static ulong UncheckedAdd(ulong x, ulong y);
    private static long UncheckedSub(long x, long y);
    private static UInt32 UncheckedSub(UInt32 x, UInt32 y);
    private static long UncheckedNegate(long x);
    internal static long GetConstantValueAsInt64(ConstantValue& value);
    internal static ConstantValue GetConstantValue(ConstantValueTypeDiscriminator type, long value);
    internal static long NarrowIntegralResult(long sourceValue, ConstantValueTypeDiscriminator sourceType, ConstantValueTypeDiscriminator resultType, Boolean& overflow);
    internal static long NarrowIntegralResult(long sourceValue, SpecialType sourceType, SpecialType resultType, Boolean& overflow);
    internal static long NarrowIntegralResult(long sourceValue, TypeSymbol sourceType, TypeSymbol resultType, Boolean& overflow);
    internal static ConstantValue ConvertIntegralValue(long sourceValue, ConstantValueTypeDiscriminator sourceType, ConstantValueTypeDiscriminator targetType, Boolean& integerOverflow);
    internal static ConstantValue ConvertFloatingValue(double sourceValue, ConstantValueTypeDiscriminator targetType, Boolean& integerOverflow);
    internal static ConstantValue ConvertDecimalValue(decimal sourceValue, ConstantValueTypeDiscriminator targetType, Boolean& integerOverflow);
    internal static double NarrowFloatingResult(double value, ConstantValueTypeDiscriminator resultType, Boolean& overflow);
    internal static double NarrowFloatingResult(double value, SpecialType resultType, Boolean& overflow);
    private static bool DetectFloatingToIntegralOverflow(double sourceValue, bool isUnsigned);
    private static long ConvertFloatingToUI64(double sourceValue);
    private static bool IsUnsignedLongType(ConstantValueTypeDiscriminator type);
    internal static bool TypeAllowsCompileTimeConversions(ConstantValueTypeDiscriminator type);
    internal static bool TypeAllowsCompileTimeOperations(ConstantValueTypeDiscriminator type);
    internal static ConstantValue AdjustConstantValueFromMetadata(ConstantValue value, TypeSymbol targetType, bool isByRefParamValue);
    internal static long Multiply(long leftValue, long rightValue, SpecialType sourceType, SpecialType resultType, Boolean& integerOverflow);
    internal static long Multiply(long leftValue, long rightValue, ConstantValueTypeDiscriminator sourceType, ConstantValueTypeDiscriminator resultType, Boolean& integerOverflow);
}
internal class Microsoft.CodeAnalysis.VisualBasic.CompoundDiagnosticInfo : DiagnosticInfo {
    internal CompoundDiagnosticInfo(DiagnosticInfo[] arguments);
    public virtual string GetMessage(IFormatProvider formatProvider);
}
internal class Microsoft.CodeAnalysis.VisualBasic.ConditionalAccessBinder : Binder {
    private ConditionalAccessExpressionSyntax _conditionalAccess;
    private BoundValuePlaceholderBase _placeholder;
    public ConditionalAccessBinder(Binder containingBinder, ConditionalAccessExpressionSyntax conditionalAccess, BoundValuePlaceholderBase placeholder);
    protected virtual BoundExpression TryGetConditionalAccessReceiver(ConditionalAccessExpressionSyntax node);
}
internal class Microsoft.CodeAnalysis.VisualBasic.ConstantFieldsInProgressBinder : Binder {
    private SymbolsInProgress`1<FieldSymbol> _inProgress;
    private FieldSymbol _field;
    internal SymbolsInProgress`1<FieldSymbol> ConstantFieldsInProgress { get; }
    public Symbol ContainingMember { get; }
    internal ConstantFieldsInProgressBinder(SymbolsInProgress`1<FieldSymbol> inProgress, Binder next, FieldSymbol field);
    internal virtual SymbolsInProgress`1<FieldSymbol> get_ConstantFieldsInProgress();
    public virtual Symbol get_ContainingMember();
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Constants : object {
    internal static string ATTACH_LISTENER_PREFIX;
    internal static string REMOVE_LISTENER_PREFIX;
    internal static string FIRE_LISTENER_PREFIX;
    internal static string EVENT_DELEGATE_SUFFIX;
    internal static string EVENT_VARIABLE_SUFFIX;
}
internal class Microsoft.CodeAnalysis.VisualBasic.ControlFlowPass : AbstractFlowPass`1<LocalState> {
    protected bool _convertInsufficientExecutionStackExceptionToCancelledByStackGuardException;
    internal ControlFlowPass(FlowAnalysisInfo info, bool suppressConstExpressionsSupport);
    internal ControlFlowPass(FlowAnalysisInfo info, FlowAnalysisRegionInfo region, bool suppressConstantExpressionsSupport);
    protected virtual bool IntersectWith(LocalState& self, LocalState& other);
    protected virtual void UnionWith(LocalState& self, LocalState& other);
    protected virtual string Dump(LocalState state);
    protected virtual LocalState ReachableState();
    protected virtual LocalState UnreachableState();
    protected virtual void Visit(BoundNode node, bool dontLeaveRegion);
    public static bool Analyze(FlowAnalysisInfo info, DiagnosticBag diagnostics, bool suppressConstantExpressionsSupport);
    protected virtual bool ConvertInsufficientExecutionStackExceptionToCancelledByStackGuardException();
    protected virtual void VisitStatement(BoundStatement statement);
    protected virtual void VisitTryBlock(BoundStatement tryBlock, BoundTryStatement node, LocalState& tryState);
    protected virtual void VisitCatchBlock(BoundCatchBlock node, LocalState& finallyState);
    protected virtual void VisitFinallyBlock(BoundStatement finallyBlock, LocalState& endState);
}
public class Microsoft.CodeAnalysis.VisualBasic.Conversion : ValueType {
    private ConversionKind _convKind;
    private MethodSymbol _method;
    internal ConversionKind Kind { get; }
    public bool Exists { get; }
    public bool IsNarrowing { get; }
    public bool IsWidening { get; }
    public bool IsIdentity { get; }
    public bool IsDefault { get; }
    public bool IsNumeric { get; }
    public bool IsBoolean { get; }
    public bool IsReference { get; }
    public bool IsAnonymousDelegate { get; }
    public bool IsLambda { get; }
    public bool IsArray { get; }
    public bool IsValueType { get; }
    public bool IsNullableValueType { get; }
    public bool IsString { get; }
    public bool IsTypeParameter { get; }
    public bool IsUserDefined { get; }
    internal MethodSymbol Method { get; }
    public IMethodSymbol MethodSymbol { get; }
    internal Conversion(KeyValuePair`2<ConversionKind, MethodSymbol> conv);
    internal ConversionKind get_Kind();
    public bool get_Exists();
    public bool get_IsNarrowing();
    public bool get_IsWidening();
    public bool get_IsIdentity();
    public bool get_IsDefault();
    public bool get_IsNumeric();
    public bool get_IsBoolean();
    public bool get_IsReference();
    public bool get_IsAnonymousDelegate();
    public bool get_IsLambda();
    public bool get_IsArray();
    public bool get_IsValueType();
    public bool get_IsNullableValueType();
    public bool get_IsString();
    public bool get_IsTypeParameter();
    public bool get_IsUserDefined();
    internal MethodSymbol get_Method();
    public IMethodSymbol get_MethodSymbol();
    public static bool op_Equality(Conversion left, Conversion right);
    public static bool op_Inequality(Conversion left, Conversion right);
    public virtual bool Equals(object obj);
    public sealed virtual override bool Equals(Conversion other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.VisualBasic.ConversionKind : Enum {
    public int value__;
    public static ConversionKind FailedDueToNumericOverflow;
    public static ConversionKind FailedDueToIntegerOverflow;
    public static ConversionKind FailedDueToNumericOverflowMask;
    public static ConversionKind FailedDueToQueryLambdaBodyMismatch;
    public static ConversionKind FailedDueToArrayLiteralElementConversion;
    public static ConversionKind Widening;
    public static ConversionKind Narrowing;
    public static ConversionKind Identity;
    public static ConversionKind Numeric;
    public static ConversionKind WideningNumeric;
    public static ConversionKind NarrowingNumeric;
    public static ConversionKind Nullable;
    public static ConversionKind WideningNullable;
    public static ConversionKind NarrowingNullable;
    public static ConversionKind Reference;
    public static ConversionKind WideningReference;
    public static ConversionKind NarrowingReference;
    public static ConversionKind Array;
    public static ConversionKind WideningArray;
    public static ConversionKind NarrowingArray;
    public static ConversionKind TypeParameter;
    public static ConversionKind WideningTypeParameter;
    public static ConversionKind NarrowingTypeParameter;
    public static ConversionKind Value;
    public static ConversionKind WideningValue;
    public static ConversionKind NarrowingValue;
    public static ConversionKind String;
    public static ConversionKind WideningString;
    public static ConversionKind NarrowingString;
    public static ConversionKind Boolean;
    public static ConversionKind NarrowingBoolean;
    public static ConversionKind WideningNothingLiteral;
    public static ConversionKind InvolvesNarrowingFromNumericConstant;
    public static ConversionKind InvolvesEnumTypeConversions;
    public static ConversionKind Lambda;
    public static ConversionKind DelegateRelaxationLevelNone;
    public static ConversionKind DelegateRelaxationLevelWidening;
    public static ConversionKind DelegateRelaxationLevelWideningDropReturnOrArgs;
    public static ConversionKind DelegateRelaxationLevelWideningToNonLambda;
    public static ConversionKind DelegateRelaxationLevelNarrowing;
    public static ConversionKind DelegateRelaxationLevelInvalid;
    public static ConversionKind DelegateRelaxationLevelMask;
    public static ConversionKind VarianceConversionAmbiguity;
    public static ConversionKind MightSucceedAtRuntime;
    public static ConversionKind AnonymousDelegate;
    public static ConversionKind NeedAStub;
    public static ConversionKind ConvertedToExpressionTree;
    public static ConversionKind UserDefined;
    public static ConversionKind NarrowingDueToContraVarianceInDelegate;
    public static ConversionKind InterpolatedString;
}
internal class Microsoft.CodeAnalysis.VisualBasic.Conversions : object {
    public static KeyValuePair`2<ConversionKind, MethodSymbol> Identity;
    private static Conversions();
    private static Nullable`1<ConversionKind> FastClassifyPredefinedConversion(TypeSymbol source, TypeSymbol target);
    public static ConstantValue TryFoldConstantConversion(BoundExpression source, TypeSymbol destination, Boolean& integerOverflow);
    private static ConstantValue TryFoldConstantNumericOrBooleanConversion(ConstantValue& sourceValue, TypeSymbol sourceType, TypeSymbol targetType, Boolean& integerOverflow);
    public static ConstantValue TryFoldNothingReferenceConversion(BoundExpression source, ConversionKind conversion, TypeSymbol targetType);
    internal static ConstantValue TryFoldNothingReferenceConversion(ConstantValue sourceValue, ConversionKind conversion, TypeSymbol targetType);
    public static KeyValuePair`2<ConversionKind, MethodSymbol> ClassifyConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    public static ConversionKind ClassifyPredefinedConversion(BoundExpression source, TypeSymbol destination, Binder binder, HashSet`1& useSiteDiagnostics);
    private static ConversionKind ClassifyPredefinedConversion(BoundExpression source, TypeSymbol destination, Binder binder, Boolean& userDefinedConversionsMightStillBeApplicable, HashSet`1& useSiteDiagnostics);
    public static KeyValuePair`2<ConversionKind, MethodSymbol> ClassifyConversion(BoundExpression source, TypeSymbol destination, Binder binder, HashSet`1& useSiteDiagnostics);
    private static ConversionKind ClassifyExpressionReclassification(BoundExpression source, TypeSymbol destination, Binder binder, HashSet`1& useSiteDiagnostics);
    private static ConversionKind ClassifyUnboundLambdaConversion(UnboundLambda source, TypeSymbol destination);
    public static ConversionKind ClassifyArrayLiteralConversion(BoundArrayLiteral source, TypeSymbol destination, Binder binder, HashSet`1& useSiteDiagnostics);
    public static ConversionKind ClassifyInterpolatedStringConversion(BoundInterpolatedStringExpression source, TypeSymbol destination, Binder binder);
    private static ConversionKind ClassifyArrayInitialization(BoundArrayInitialization source, TypeSymbol targetElementType, Binder binder, HashSet`1& useSiteDiagnostics);
    private static ConversionKind ClassifyAddressOfConversion(BoundAddressOfOperator source, TypeSymbol destination);
    private static ConversionKind ClassifyQueryLambdaConversion(BoundQueryLambda source, TypeSymbol destination, Binder binder, HashSet`1& useSiteDiagnostics);
    public static KeyValuePair`2<ConversionKind, MethodSymbol> ClassifyConversionOfOperandOfConditionalBranch(BoundExpression operand, TypeSymbol booleanType, Binder binder, Boolean& applyNullableIsTrueOperator, OverloadResolutionResult& isTrueOperator, HashSet`1& useSiteDiagnostics);
    private static ConversionKind ClassifyGroupTypeInferenceLambdaConversion(GroupTypeInferenceLambda source, TypeSymbol destination);
    private static ConversionKind ClassifyNumericConstantConversion(BoundExpression constantExpression, TypeSymbol destination, Binder binder);
    private static ConversionKind ClassifyNothingLiteralConversion(BoundExpression constantExpression, TypeSymbol destination);
    public static ConversionKind ClassifyDirectCastConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    public static ConversionKind ClassifyDirectCastConversion(BoundExpression source, TypeSymbol destination, Binder binder, HashSet`1& useSiteDiagnostics);
    public static ConversionKind ClassifyTryCastConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    public static ConversionKind ClassifyTryCastConversion(BoundExpression source, TypeSymbol destination, Binder binder, HashSet`1& useSiteDiagnostics);
    private static ConversionKind ClassifyTryCastConversionForTypeParameters(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private static bool ClassOrBasesSatisfyConstraints(TypeSymbol class, TypeParameterSymbol typeParam, HashSet`1& useSiteDiagnostics);
    private static TypeSymbol GetNonInterfaceTypeConstraintOrSelf(TypeSymbol type, HashSet`1& useSiteDiagnostics);
    private static KeyValuePair`2<ConversionKind, MethodSymbol> ClassifyUserDefinedConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private static KeyValuePair`2<ConversionKind, MethodSymbol> ClassifyUserDefinedConversion(BoundExpression source, TypeSymbol destination, Binder binder, HashSet`1& useSiteDiagnostics);
    public static ConversionKind ClassifyPredefinedConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private static ConversionKind ClassifyPredefinedConversionSlow(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private static ConversionKind AddDelegateRelaxationInformationForADelegate(TypeSymbol source, TypeSymbol destination, ConversionKind convKind);
    private static ConversionKind ClassifyIdentityConversion(TypeSymbol source, TypeSymbol destination);
    private static ConversionKind ClassifyReferenceConversion(TypeSymbol source, TypeSymbol destination, int varianceCompatibilityClassificationDepth, HashSet`1& useSiteDiagnostics);
    private static ConversionKind ClassifyReferenceConversionFromArrayToAnInterface(TypeSymbol source, TypeSymbol destination, int varianceCompatibilityClassificationDepth, HashSet`1& useSiteDiagnostics);
    public static bool HasWideningDirectCastConversionButNotEnumTypeConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private static ConversionKind ClassifyConversionToVariantCompatibleDelegateType(NamedTypeSymbol source, NamedTypeSymbol destination, int varianceCompatibilityClassificationDepth, HashSet`1& useSiteDiagnostics);
    private static ConversionKind ClassifyImmediateVarianceCompatibility(NamedTypeSymbol source, NamedTypeSymbol destination, int varianceCompatibilityClassificationDepth, HashSet`1& useSiteDiagnostics);
    private static bool ClassifyAsReferenceType(TypeSymbol candidate, Boolean& isClassType, Boolean& isDelegateType, Boolean& isInterfaceType, Boolean& isArrayType);
    private static bool IsClassType(TypeSymbol type);
    private static bool IsValueType(TypeSymbol type);
    private static bool IsDelegateType(TypeSymbol type);
    private static bool IsArrayType(TypeSymbol type);
    private static bool IsInterfaceType(TypeSymbol type);
    public static bool IsDerivedFrom(TypeSymbol derivedType, TypeSymbol baseType, HashSet`1& useSiteDiagnostics);
    private static ConversionKind ClassifyAnonymousDelegateConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private static ConversionKind ClassifyArrayConversion(TypeSymbol source, TypeSymbol destination, int varianceCompatibilityClassificationDepth, HashSet`1& useSiteDiagnostics);
    public static ConversionKind ClassifyArrayElementConversion(TypeSymbol srcElem, TypeSymbol dstElem, HashSet`1& useSiteDiagnostics);
    internal static ConversionKind Classify_Reference_Array_TypeParameterConversion(TypeSymbol srcElem, TypeSymbol dstElem, int varianceCompatibilityClassificationDepth, HashSet`1& useSiteDiagnostics);
    private static ConversionKind ClassifyArrayConversionBasedOnElementTypes(TypeSymbol srcElem, TypeSymbol dstElem, int varianceCompatibilityClassificationDepth, HashSet`1& useSiteDiagnostics);
    private static int ArrayElementBitSize(TypeSymbol type);
    private static TypeSymbol GetValueTypeConstraint(TypeSymbol typeParam, HashSet`1& useSiteDiagnostics);
    private static NamedTypeSymbol GetNonErrorEnumUnderlyingType(TypeSymbol type);
    private static ConversionKind ClassifyValueTypeConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private static ConversionKind ClassifyNullableConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    public static ConversionKind ClassifyStringConversion(TypeSymbol source, TypeSymbol destination);
    private static ConversionKind ClassifyTypeParameterConversion(TypeSymbol source, TypeSymbol destination, int varianceCompatibilityClassificationDepth, HashSet`1& useSiteDiagnostics);
    private static ConversionKind ClassifyConversionFromTypeParameter(TypeParameterSymbol typeParameter, TypeSymbol destination, int varianceCompatibilityClassificationDepth, HashSet`1& useSiteDiagnostics);
    private static ConversionKind ClassifyConversionFromTypeParameter(TypeParameterSymbol typeParameter, TypeSymbol destination, ArrayBuilder`1& queue, int varianceCompatibilityClassificationDepth, HashSet`1& useSiteDiagnostics);
    private static ConversionKind ClassifyConversionToTypeParameter(TypeSymbol source, TypeParameterSymbol typeParameter, int varianceCompatibilityClassificationDepth, HashSet`1& useSiteDiagnostics);
    public static MethodConversionKind ClassifyMethodConversionBasedOnReturnType(TypeSymbol returnTypeOfConvertFromMethod, TypeSymbol returnTypeOfConvertToMethod, HashSet`1& useSiteDiagnostics);
    public static MethodConversionKind ClassifyMethodConversionBasedOnArgumentConversion(ConversionKind conversion, TypeSymbol delegateParameterType);
    public static MethodConversionKind ClassifyMethodConversionForLambdaOrAnonymousDelegate(MethodSymbol toMethod, MethodSymbol lambdaOrDelegateInvokeSymbol, HashSet`1& useSiteDiagnostics);
    public static MethodConversionKind ClassifyMethodConversionForLambdaOrAnonymousDelegate(TargetSignature toMethodSignature, MethodSymbol lambdaOrDelegateInvokeSymbol, HashSet`1& useSiteDiagnostics);
    public static MethodConversionKind ClassifyMethodConversionForEventRaise(MethodSymbol toDelegateInvokeMethod, ImmutableArray`1<ParameterSymbol> parameters, HashSet`1& useSiteDiagnostics);
    private static MethodConversionKind ClassifyMethodConversionForLambdaOrAnonymousDelegateBasedOnParameters(TargetSignature toMethodSignature, ImmutableArray`1<ParameterSymbol> parameters, HashSet`1& useSiteDiagnostics);
    public static ConversionKind DetermineDelegateRelaxationLevelForLambdaReturn(BoundExpression expressionOpt, HashSet`1& useSiteDiagnostics);
    public static ConversionKind DetermineDelegateRelaxationLevel(MethodConversionKind methodConversion);
    public static bool IsDelegateRelaxationSupportedFor(MethodConversionKind methodConversion);
    public static bool IsStubRequiredForMethodConversion(MethodConversionKind methodConversions);
    public static bool IsNarrowingMethodConversion(MethodConversionKind methodConversion, bool isForAddressOf);
    public static RequiredConversion InvertConversionRequirement(RequiredConversion restriction);
    public static RequiredConversion StrengthenConversionRequirementToReference(RequiredConversion restriction);
    public static RequiredConversion CombineConversionRequirements(RequiredConversion restriction1, RequiredConversion restriction2);
    public static bool IsWideningConversion(ConversionKind conv);
    public static bool IsNarrowingConversion(ConversionKind conv);
    public static bool NoConversion(ConversionKind conv);
    public static bool ConversionExists(ConversionKind conv);
    public static bool IsIdentityConversion(ConversionKind conv);
    public static bool FailedDueToNumericOverflow(ConversionKind conv);
    public static bool FailedDueToQueryLambdaBodyMismatch(ConversionKind conv);
    public static bool IsCLRPredefinedConversion(ConversionKind conversion);
}
internal class Microsoft.CodeAnalysis.VisualBasic.CustomSymbolDisplayFormatter : object {
    internal static SymbolDisplayFormat QualifiedNameFormat;
    internal static SymbolDisplayFormat WithContainingTypeFormat;
    internal static SymbolDisplayFormat ErrorMessageFormatNoModifiersNoReturnType;
    internal static SymbolDisplayFormat ErrorNameWithKindFormat;
    internal static SymbolDisplayFormat DelegateSignatureFormat;
    internal static SymbolDisplayFormat ShortWithTypeArgsFormat;
    internal static SymbolDisplayFormat ShortWithTypeArgsAndContainingTypesFormat;
    private static CustomSymbolDisplayFormatter();
    public static FormattedSymbol QualifiedName(Symbol symbol);
    public static FormattedSymbol WithContainingType(Symbol symbol);
    public static FormattedSymbol ErrorNameWithKind(Symbol symbol);
    public static FormattedSymbol ShortErrorName(Symbol symbol);
    public static FormattedSymbol DelegateSignature(Symbol symbol);
    public static FormattedSymbol ShortNameWithTypeArgs(Symbol symbol);
    public static FormattedSymbol ShortNameWithTypeArgsAndContainingTypes(Symbol symbol);
    public static FormattedSymbol DefaultErrorFormat(Symbol symbol);
}
internal class Microsoft.CodeAnalysis.VisualBasic.DataFlowPass : AbstractFlowPass`1<LocalState> {
    protected HashSet`1<Symbol> initiallyAssignedVariables;
    private bool _trackStructsWithIntrinsicTypedFields;
    private HashSet`1<LocalSymbol> _unusedVariables;
    private HashSet`1<Symbol> _writtenVariables;
    private Dictionary`2<VariableIdentifier, int> _variableSlot;
    protected VariableIdentifier[] variableBySlot;
    protected int nextVariableSlot;
    private BitVector _alreadyReported;
    private bool _seenOnErrorOrResume;
    protected bool _convertInsufficientExecutionStackExceptionToCancelledByStackGuardException;
    private Dictionary`2<NamedTypeSymbol, bool> _isEmptyStructType;
    private Dictionary`2<TypeSymbol, ImmutableArray`1<FieldSymbol>> _typeToMembersCache;
    private Nullable`1<LocalState> _tryState;
    private static BitVector UnreachableBitsSet { get; }
    protected bool EnableBreakingFlowAnalysisFeatures { get; }
    protected bool ProcessCompilerGeneratedLocals { get; }
    protected bool SuppressRedimOperandRvalueOnPreserve { get; }
    protected bool IgnoreOutSemantics { get; }
    internal DataFlowPass(FlowAnalysisInfo info, bool suppressConstExpressionsSupport, bool trackStructsWithIntrinsicTypedFields);
    internal DataFlowPass(FlowAnalysisInfo info, FlowAnalysisRegionInfo region, bool suppressConstExpressionsSupport, HashSet`1<Symbol> initiallyAssignedVariables, bool trackUnassignments, bool trackStructsWithIntrinsicTypedFields);
    protected virtual bool IntersectWith(LocalState& self, LocalState& other);
    protected virtual void UnionWith(LocalState& self, LocalState& other);
    private static BitVector get_UnreachableBitsSet();
    private static bool IntersectBitArrays(BitVector& receiver, BitVector other);
    private static void UnionBitArrays(BitVector& receiver, BitVector other);
    protected void Normalize(LocalState& _state);
    protected virtual void InitForScan();
    protected virtual bool Scan();
    private void ReportUnused(LocalSymbol local);
    protected virtual void ReportUnassignedByRefParameter(ParameterSymbol parameter);
    public static void Analyze(FlowAnalysisInfo info, DiagnosticBag diagnostics, bool suppressConstExpressionsSupport);
    protected virtual bool ConvertInsufficientExecutionStackExceptionToCancelledByStackGuardException();
    protected virtual void Free();
    protected virtual string Dump(LocalState state);
    protected void AppendBitNames(BitVector a, StringBuilder builder);
    protected void AppendBitName(int bit, StringBuilder builder);
    protected virtual void NoteRead(Symbol variable);
    protected virtual void NoteWrite(Symbol variable, BoundExpression value);
    protected Symbol GetNodeSymbol(BoundNode node);
    protected virtual void NoteWrite(BoundExpression node, BoundExpression value);
    protected virtual void NoteRead(BoundFieldAccess fieldAccess);
    protected int VariableSlot(Symbol local, int containingSlot);
    protected SlotCollection MakeSlotsForExpression(BoundExpression node);
    protected int MakeSlot(Symbol local, int containingSlot);
    protected virtual bool IsEmptyStructType(TypeSymbol type);
    private bool IsTrackableStructType(TypeSymbol symbol);
    private bool IsSlotAlreadyReported(TypeSymbol symbolType, int slot);
    private void MarkSlotAsReported(TypeSymbol symbolType, int slot);
    private void SetSlotUnassigned(int slot);
    private void SetSlotUnassigned(int slot, LocalState& state);
    private void SetSlotAssigned(int slot, LocalState& state);
    private void SetSlotAssigned(int slot);
    private bool ShouldIgnoreStructField(FieldSymbol field);
    private ImmutableArray`1<FieldSymbol> GetStructInstanceFields(TypeSymbol type);
    private TypeSymbol GetVariableType(Symbol symbol);
    protected void SetSlotState(int slot, bool assigned);
    protected void CheckAssigned(Symbol symbol, VisualBasicSyntaxNode node, ReadWriteContext<LocalState> rwContext);
    private void CheckAssigned(BoundFieldAccess fieldAccess, VisualBasicSyntaxNode node, ReadWriteContext<LocalState> rwContext);
    protected virtual void VisitAmbiguousLocalSymbol(AmbiguousLocalsPseudoSymbol ambiguous);
    protected virtual void VisitLvalue(BoundExpression node, bool dontLeaveRegion);
    private bool IsAssigned(BoundExpression node, Int32& unassignedSlot);
    protected virtual bool get_EnableBreakingFlowAnalysisFeatures();
    protected virtual bool get_ProcessCompilerGeneratedLocals();
    private Location GetUnassignedSymbolFirstLocation(Symbol sym, BoundFieldAccess boundFieldAccess);
    protected virtual void ReportUnassigned(Symbol sym, VisualBasicSyntaxNode node, ReadWriteContext<LocalState> rwContext, int slot, BoundFieldAccess boundFieldAccess);
    private void CheckAssignedFunctionValue(LocalSymbol local, VisualBasicSyntaxNode node);
    private void ReportUnassignedFunctionValue(LocalSymbol local, VisualBasicSyntaxNode node);
    private static string GetFunctionLocalName(MethodSymbol method, LocalSymbol local);
    protected virtual void Assign(BoundNode node, BoundExpression value, bool assigned);
    protected virtual void VisitTryBlock(BoundStatement tryBlock, BoundTryStatement node, LocalState& _tryState);
    protected virtual void VisitCatchBlock(BoundCatchBlock catchBlock, LocalState& finallyState);
    private void VisitCatchBlockInternal(BoundCatchBlock catchBlock, LocalState& finallyState);
    protected virtual void VisitFinallyBlock(BoundStatement finallyBlock, LocalState& unsetInFinally);
    protected virtual LocalState ReachableState();
    private void EnterParameters(ImmutableArray`1<ParameterSymbol> parameters);
    protected virtual void EnterParameter(ParameterSymbol parameter);
    private void LeaveParameters(ImmutableArray`1<ParameterSymbol> parameters);
    private void LeaveParameter(ParameterSymbol parameter);
    protected virtual LocalState UnreachableState();
    protected virtual LocalState AllBitsSet();
    protected virtual void VisitLocalInReadWriteContext(BoundLocal node, ReadWriteContext<LocalState> rwContext);
    public virtual BoundNode VisitLocal(BoundLocal node);
    public virtual BoundNode VisitRangeVariable(BoundRangeVariable node);
    protected bool ConsiderLocalInitiallyAssigned(LocalSymbol variable);
    public virtual BoundNode VisitLocalDeclaration(BoundLocalDeclaration node);
    protected virtual bool TreatTheLocalAsAssignedWithinTheLambda(LocalSymbol local, BoundExpression right);
    private static bool IsConvertedLambda(BoundExpression value);
    internal virtual void AssignLocalOnDeclaration(LocalSymbol local, BoundLocalDeclaration node);
    public virtual BoundNode VisitBlock(BoundBlock node);
    public virtual BoundNode VisitLambda(BoundLambda node);
    public virtual BoundNode VisitQueryLambda(BoundQueryLambda node);
    public virtual BoundNode VisitQueryExpression(BoundQueryExpression node);
    public virtual BoundNode VisitQuerySource(BoundQuerySource node);
    public virtual BoundNode VisitQueryableSource(BoundQueryableSource node);
    public virtual BoundNode VisitToQueryableCollectionConversion(BoundToQueryableCollectionConversion node);
    public virtual BoundNode VisitQueryClause(BoundQueryClause node);
    public virtual BoundNode VisitAggregateClause(BoundAggregateClause node);
    public virtual BoundNode VisitOrdering(BoundOrdering node);
    public virtual BoundNode VisitRangeVariableAssignment(BoundRangeVariableAssignment node);
    public virtual BoundNode VisitMeReference(BoundMeReference node);
    public virtual BoundNode VisitParameter(BoundParameter node);
    public virtual BoundNode VisitFieldAccess(BoundFieldAccess node);
    protected virtual void VisitFieldAccessInReadWriteContext(BoundFieldAccess node, ReadWriteContext<LocalState> rwContext);
    public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node);
    protected virtual bool get_SuppressRedimOperandRvalueOnPreserve();
    public virtual BoundNode VisitRedimClause(BoundRedimClause node);
    public virtual BoundNode VisitReferenceAssignment(BoundReferenceAssignment node);
    protected virtual void VisitForControlInitialization(BoundForToStatement node);
    protected virtual void VisitForControlInitialization(BoundForEachStatement node);
    protected virtual void VisitForStatementVariableDeclaration(BoundForStatement node);
    public virtual BoundNode VisitAnonymousTypeCreationExpression(BoundAnonymousTypeCreationExpression node);
    public virtual BoundNode VisitWithStatement(BoundWithStatement node);
    public virtual BoundNode VisitUsingStatement(BoundUsingStatement node);
    protected virtual bool get_IgnoreOutSemantics();
    protected sealed virtual void VisitArgument(BoundExpression arg, ParameterSymbol p);
    protected virtual void WriteArgument(BoundExpression arg, bool isOut);
    protected void CheckAssignedFromArgumentWrite(BoundExpression expr, VisualBasicSyntaxNode node);
    protected virtual void VisitLateBoundArgument(BoundExpression arg, bool isByRef);
    public virtual BoundNode VisitReturnStatement(BoundReturnStatement node);
    public virtual BoundNode VisitMyBaseReference(BoundMyBaseReference node);
    public virtual BoundNode VisitMyClassReference(BoundMyClassReference node);
    private bool DeclaredVariableIsAlwaysAssignedBeforeInitializer(VisualBasicSyntaxNode syntax, BoundExpression boundInitializer, BoundValuePlaceholderBase& placeholder);
    public virtual BoundNode VisitAsNewLocalDeclarations(BoundAsNewLocalDeclarations node);
    protected virtual LocalSymbol CreateLocalSymbolForVariables(ImmutableArray`1<BoundLocalDeclaration> declarations);
    protected virtual void VisitObjectCreationExpressionInitializer(BoundObjectInitializerExpressionBase node);
    public virtual BoundNode VisitOnErrorStatement(BoundOnErrorStatement node);
    public virtual BoundNode VisitResumeStatement(BoundResumeStatement node);
}
internal class Microsoft.CodeAnalysis.VisualBasic.DataFlowsInWalker : AbstractRegionDataFlowPass {
    private HashSet`1<Symbol> _dataFlowsIn;
    private DataFlowsInWalker(FlowAnalysisInfo info, FlowAnalysisRegionInfo region, HashSet`1<Symbol> unassignedVariables);
    internal static HashSet`1<Symbol> Analyze(FlowAnalysisInfo info, FlowAnalysisRegionInfo region, HashSet`1<Symbol> unassignedVariables, Nullable`1& succeeded, Boolean& invalidRegionDetected);
    private LocalState ResetState(LocalState state);
    protected virtual void EnterRegion();
    protected virtual void NoteBranch(PendingBranch<LocalState> pending, BoundStatement stmt, BoundLabelStatement labelStmt);
    public virtual BoundNode VisitRangeVariable(BoundRangeVariable node);
    protected virtual void VisitAmbiguousLocalSymbol(AmbiguousLocalsPseudoSymbol ambiguous);
    protected virtual void ReportUnassigned(Symbol local, VisualBasicSyntaxNode node, ReadWriteContext<LocalState> rwContext, int slot, BoundFieldAccess boundFieldAccess);
    internal virtual void AssignLocalOnDeclaration(LocalSymbol local, BoundLocalDeclaration node);
}
internal class Microsoft.CodeAnalysis.VisualBasic.DataFlowsOutWalker : AbstractRegionDataFlowPass {
    private ImmutableArray`1<ISymbol> _dataFlowsIn;
    private HashSet`1<Symbol> _originalUnassigned;
    private HashSet`1<Symbol> _dataFlowsOut;
    private DataFlowsOutWalker(FlowAnalysisInfo info, FlowAnalysisRegionInfo region, HashSet`1<Symbol> unassignedVariables, HashSet`1<Symbol> originalUnassigned, ImmutableArray`1<ISymbol> dataFlowsIn);
    internal static HashSet`1<Symbol> Analyze(FlowAnalysisInfo info, FlowAnalysisRegionInfo region, HashSet`1<Symbol> unassignedVariables, ImmutableArray`1<ISymbol> dataFlowsIn);
    protected virtual void EnterRegion();
    protected virtual void Assign(BoundNode node, BoundExpression value, bool assigned);
    protected virtual void ReportUnassigned(Symbol local, VisualBasicSyntaxNode node, ReadWriteContext<LocalState> rwContext, int slot, BoundFieldAccess boundFieldAccess);
    protected virtual void ReportUnassignedByRefParameter(ParameterSymbol parameter);
    protected virtual void NoteWrite(Symbol variable, BoundExpression value);
    private bool WasUsedBeforeAssignment(Symbol sym);
    internal virtual void AssignLocalOnDeclaration(LocalSymbol local, BoundLocalDeclaration node);
}
internal class Microsoft.CodeAnalysis.VisualBasic.DeclarationInitializerBinder : Binder {
    private Symbol _symbol;
    private VisualBasicSyntaxNode _root;
    public Symbol ContainingMember { get; }
    internal VisualBasicSyntaxNode Root { get; }
    public DeclarationInitializerBinder(Symbol symbol, Binder next, VisualBasicSyntaxNode root);
    public virtual Symbol get_ContainingMember();
    internal VisualBasicSyntaxNode get_Root();
    public virtual Binder GetBinder(VisualBasicSyntaxNode node);
    public virtual Binder GetBinder(SyntaxList`1<StatementSyntax> stmts);
}
internal class Microsoft.CodeAnalysis.VisualBasic.DefaultParametersInProgressBinder : SymbolsInProgressBinder`1<ParameterSymbol> {
    internal SymbolsInProgress`1<ParameterSymbol> DefaultParametersInProgress { get; }
    internal DefaultParametersInProgressBinder(SymbolsInProgress`1<ParameterSymbol> inProgress, Binder next);
    internal virtual SymbolsInProgress`1<ParameterSymbol> get_DefaultParametersInProgress();
}
internal class Microsoft.CodeAnalysis.VisualBasic.DescendantBinderFactory : object {
    private ExecutableCodeBinder _rootBinder;
    private VisualBasicSyntaxNode _root;
    private ImmutableDictionary`2<VisualBasicSyntaxNode, BlockBaseBinder> _lazyNodeToBinderMap;
    private ImmutableDictionary`2<SyntaxList`1<StatementSyntax>, BlockBaseBinder> _lazyStmtListToBinderMap;
    internal VisualBasicSyntaxNode Root { get; }
    internal ExecutableCodeBinder RootBinder { get; }
    internal ImmutableDictionary`2<VisualBasicSyntaxNode, BlockBaseBinder> NodeToBinderMap { get; }
    internal ImmutableDictionary`2<SyntaxList`1<StatementSyntax>, BlockBaseBinder> StmtListToBinderMap { get; }
    public DescendantBinderFactory(ExecutableCodeBinder binder, VisualBasicSyntaxNode root);
    internal VisualBasicSyntaxNode get_Root();
    internal ExecutableCodeBinder get_RootBinder();
    internal Binder GetBinder(VisualBasicSyntaxNode node);
    internal Binder GetBinder(SyntaxList`1<StatementSyntax> statementList);
    internal ImmutableDictionary`2<VisualBasicSyntaxNode, BlockBaseBinder> get_NodeToBinderMap();
    internal ImmutableDictionary`2<SyntaxList`1<StatementSyntax>, BlockBaseBinder> get_StmtListToBinderMap();
    private void BuildBinderMaps();
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.DiagnosticBagExtensions : object {
    [ExtensionAttribute]
internal static DiagnosticInfo Add(DiagnosticBag diagnostics, ERRID code, Location location);
    [ExtensionAttribute]
internal static DiagnosticInfo Add(DiagnosticBag diagnostics, ERRID code, Location location, Object[] args);
    [ExtensionAttribute]
internal static void Add(DiagnosticBag diagnostics, DiagnosticInfo info, Location location);
    [ExtensionAttribute]
internal static bool Add(DiagnosticBag diagnostics, VisualBasicSyntaxNode node, HashSet`1<DiagnosticInfo> useSiteDiagnostics);
    [ExtensionAttribute]
internal static bool Add(DiagnosticBag diagnostics, BoundNode node, HashSet`1<DiagnosticInfo> useSiteDiagnostics);
    [ExtensionAttribute]
internal static bool Add(DiagnosticBag diagnostics, SyntaxNodeOrToken node, HashSet`1<DiagnosticInfo> useSiteDiagnostics);
    [ExtensionAttribute]
internal static bool Add(DiagnosticBag diagnostics, Location location, HashSet`1<DiagnosticInfo> useSiteDiagnostics);
}
internal class Microsoft.CodeAnalysis.VisualBasic.DiagnosticsPass : BoundTreeWalkerWithStackGuardWithoutRecursionOnTheLeftOfBinaryOperator {
    private DiagnosticBag _diagnostics;
    private VisualBasicCompilation _compilation;
    private MethodSymbol _containingSymbol;
    private Dictionary`2<BoundValuePlaceholderBase, BoundWithStatement> _withExpressionPlaceholderMap;
    private Stack`1<BoundExpression> _expressionsBeingVisited;
    private bool _inExpressionLambda;
    private HashSet`1<BoundNode> _expressionTreePlaceholders;
    private bool IsInExpressionLambda { get; }
    private DiagnosticsPass(VisualBasicCompilation compilation, DiagnosticBag diagnostics, MethodSymbol containingSymbol);
    public static void IssueDiagnostics(BoundNode node, DiagnosticBag diagnostics, MethodSymbol containingSymbol);
    private bool get_IsInExpressionLambda();
    public virtual BoundNode VisitQueryLambda(BoundQueryLambda node);
    public virtual BoundNode VisitParameter(BoundParameter node);
    public virtual BoundNode VisitMeReference(BoundMeReference node);
    public virtual BoundNode VisitMyClassReference(BoundMyClassReference node);
    private ERRID GetMeAccessError();
    public virtual BoundNode VisitWithRValueExpressionPlaceholder(BoundWithRValueExpressionPlaceholder node);
    private void CheckMeAccessInWithExpression(BoundValuePlaceholderBase node);
    public virtual BoundNode VisitWithStatement(BoundWithStatement node);
    public virtual BoundNode Visit(BoundNode node);
    public virtual BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node);
    public virtual BoundNode VisitUserDefinedUnaryOperator(BoundUserDefinedUnaryOperator node);
    public virtual BoundNode VisitAnonymousTypePropertyAccess(BoundAnonymousTypePropertyAccess node);
    public virtual BoundNode VisitAnonymousTypeCreationExpression(BoundAnonymousTypeCreationExpression node);
    public virtual BoundNode VisitSequence(BoundSequence node);
    public virtual BoundNode VisitUserDefinedBinaryOperator(BoundUserDefinedBinaryOperator node);
    public virtual BoundNode VisitObjectInitializerExpression(BoundObjectInitializerExpression node);
    public virtual BoundNode VisitWithLValueExpressionPlaceholder(BoundWithLValueExpressionPlaceholder node);
    public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node);
    public virtual BoundNode VisitFieldAccess(BoundFieldAccess node);
    public virtual BoundNode VisitArrayCreation(BoundArrayCreation node);
    public virtual BoundNode VisitLambda(BoundLambda node);
    public virtual BoundNode VisitCall(BoundCall node);
    public virtual BoundNode VisitPropertyAccess(BoundPropertyAccess node);
    public virtual BoundNode VisitEventAccess(BoundEventAccess node);
    private void VisitLambdaConversion(BoundExpression operand, BoundLambda relaxationLambda);
    private bool CheckLambdaForByRefParameters(BoundLambda lambda);
    public virtual BoundNode VisitConversion(BoundConversion node);
    public virtual BoundNode VisitTryCast(BoundTryCast node);
    public virtual BoundNode VisitDirectCast(BoundDirectCast node);
    public virtual BoundNode VisitLateInvocation(BoundLateInvocation node);
    public virtual BoundNode VisitLateMemberAccess(BoundLateMemberAccess node);
    public virtual BoundNode VisitConditionalAccess(BoundConditionalAccess node);
    private void GenerateExpressionTreeNotSupportedDiagnostic(BoundNode node);
    private void GenerateDiagnostic(ERRID code, BoundNode node);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.DocumentationCommentBinder : Binder {
    protected Symbol CommentedSymbol;
    protected DocumentationCommentBinder(Binder containingBinder, Symbol commentedSymbol);
    [ConditionalAttribute("DEBUG")]
private static void CheckBinderSymbolRelationship(Binder containingBinder, Symbol commentedSymbol);
    public static bool IsIntrinsicTypeForDocumentationComment(SyntaxKind kind);
    internal static BinderType GetBinderTypeForNameAttribute(BaseXmlAttributeSyntax node);
    internal static BinderType GetBinderTypeForNameAttribute(string parentNodeName);
    internal static string GetParentXmlElementName(BaseXmlAttributeSyntax attr);
    internal virtual ImmutableArray`1<Symbol> BindXmlNameAttributeValue(IdentifierNameSyntax identifier, HashSet`1& useSiteDiagnostics);
    internal virtual ImmutableArray`1<Symbol> BindInsideCrefAttributeValue(TypeSyntax name, bool preserveAliases, DiagnosticBag diagnosticBag, HashSet`1& useSiteDiagnostics);
    internal virtual ImmutableArray`1<Symbol> BindInsideCrefAttributeValue(CrefReferenceSyntax reference, bool preserveAliases, DiagnosticBag diagnosticBag, HashSet`1& useSiteDiagnostics);
    protected static ImmutableArray`1<Symbol> FindSymbolInSymbolArray(string name, ImmutableArray`1<TSymbol> symbols);
    internal virtual LookupOptions BinderSpecificLookupOptions(LookupOptions options);
    protected void RemoveOverriddenMethodsAndProperties(ArrayBuilder`1<Symbol> symbols);
}
internal class Microsoft.CodeAnalysis.VisualBasic.DocumentationCommentCrefBinder : DocumentationCommentBinder {
    private TypeParametersBinder _typeParameterBinder;
    public DocumentationCommentCrefBinder(Binder containingBinder, Symbol commentedSymbol);
    private Binder GetOrCreateTypeParametersAwareBinder(Dictionary`2<string, CrefTypeParameterSymbol> typeParameters);
    private bool HasTrailingSkippedTokensAndShouldReportError(CrefReferenceSyntax reference);
    internal virtual ImmutableArray`1<Symbol> BindInsideCrefAttributeValue(CrefReferenceSyntax reference, bool preserveAliases, DiagnosticBag diagnosticBag, HashSet`1& useSiteDiagnostics);
    internal virtual ImmutableArray`1<Symbol> BindInsideCrefAttributeValue(TypeSyntax name, bool preserveAliases, DiagnosticBag diagnosticBag, HashSet`1& useSiteDiagnostics);
    private ImmutableArray`1<Symbol> BindInsideCrefSignatureOrReturnType(CrefReferenceSyntax crefReference, TypeSyntax name, bool preserveAliases, DiagnosticBag diagnosticBag);
    private Binder GetOrCreateTypeParametersAwareBinder(CrefReferenceSyntax crefReference);
    private ImmutableArray`1<Symbol> BindInsideCrefReferenceName(TypeSyntax name, int argCount, bool preserveAliases, HashSet`1& useSiteDiagnostics);
    private CrefReferenceSyntax GetEnclosingCrefReference(TypeSyntax nameFromCref, Boolean& partOfSignatureOrReturnType);
    private void BindSignatureAndReturnValue(CrefReferenceSyntax reference, Dictionary`2<string, CrefTypeParameterSymbol> typeParameters, ArrayBuilder`1& signatureTypes, TypeSymbol& returnType, DiagnosticBag diagnosticBag);
    private void CollectCrefNameSymbolsStrict(TypeSyntax nameFromCref, int argsCount, Dictionary`2<string, CrefTypeParameterSymbol> typeParameters, ArrayBuilder`1<Symbol> symbols, bool preserveAlias, HashSet`1& useSiteDiagnostics);
    private void CollectTopLevelOperatorReferenceStrict(CrefOperatorReferenceSyntax reference, int argCount, ArrayBuilder`1<Symbol> symbols, HashSet`1& useSiteDiagnostics);
    private void CollectSimpleNameSymbolsStrict(SimpleNameSyntax node, Dictionary`2<string, CrefTypeParameterSymbol> typeParameters, ArrayBuilder`1<Symbol> symbols, bool preserveAlias, HashSet`1& useSiteDiagnostics, bool typeOrNamespaceOnly);
    private void CollectQualifiedNameSymbolsStrict(QualifiedNameSyntax node, Dictionary`2<string, CrefTypeParameterSymbol> typeParameters, ArrayBuilder`1<Symbol> symbols, bool preserveAlias, HashSet`1& useSiteDiagnostics);
    private void CollectQualifiedOperatorReferenceSymbolsStrict(QualifiedCrefOperatorReferenceSyntax node, int argCount, Dictionary`2<string, CrefTypeParameterSymbol> typeParameters, ArrayBuilder`1<Symbol> symbols, HashSet`1& useSiteDiagnostics);
    private void CollectConstructorsSymbolsStrict(ArrayBuilder`1<Symbol> symbols);
    private void CollectConstructorsSymbolsStrict(Symbol containingSymbol, ArrayBuilder`1<Symbol> symbols);
    private void CollectSimpleNameSymbolsStrict(string name, int arity, ArrayBuilder`1<Symbol> symbols, bool preserveAlias, HashSet`1& useSiteDiagnostics, bool typeOrNamespaceOnly);
    private void CollectSimpleNameSymbolsStrict(Symbol containingSymbol, bool allowColorColor, string name, int arity, ArrayBuilder`1<Symbol> symbols, bool preserveAlias, HashSet`1& useSiteDiagnostics);
    private void CreateTypeParameterSymbolsAndConstructSymbols(GenericNameSyntax genericName, ArrayBuilder`1<Symbol> symbols, Dictionary`2<string, CrefTypeParameterSymbol> typeParameters);
    private void CollectGoodOrAmbiguousFromLookupResult(LookupResult lookupResult, ArrayBuilder`1<Symbol> symbols, bool preserveAlias);
    private void CollectOperatorsAndConversionsInType(CrefOperatorReferenceSyntax crefOperator, int argCount, TypeSymbol type, ArrayBuilder`1<Symbol> symbols, HashSet`1& useSiteDiagnostics);
    private void CollectOperatorsAndConversionsInType(TypeSymbol type, ArrayBuilder`1<Symbol> symbols, MethodKind kind, string name1, OperatorInfo info1, HashSet`1& useSiteDiagnostics, string name2, OperatorInfo info2);
    private static bool NameSyntaxHasComplexGenericArguments(TypeSyntax name);
    private static bool CrefReferenceIsLegalForLegacyMode(TypeSyntax nameFromCref);
    private ImmutableArray`1<Symbol> BindNameInsideCrefReferenceInLegacyMode(TypeSyntax nameFromCref, bool preserveAliases, HashSet`1& useSiteDiagnostics);
    private void BindQualifiedNameForCref(QualifiedNameSyntax node, ArrayBuilder`1<Symbol> symbols, bool preserveAliases, HashSet`1& useSiteDiagnostics);
    private void LookupSimpleNameInContainingSymbol(Symbol containingSymbol, bool allowColorColor, string name, int arity, bool preserveAliases, LookupResult lookupResult, LookupOptions options, HashSet`1& useSiteDiagnostics);
    private void BindSimpleNameForCref(string name, int arity, ArrayBuilder`1<Symbol> symbols, bool preserveAliases, HashSet`1& useSiteDiagnostics, Symbol containingSymbol, bool allowColorColor, bool typeOrNamespaceOnly);
    private void BindSimpleNameForCref(SimpleNameSyntax node, ArrayBuilder`1<Symbol> symbols, bool preserveAliases, HashSet`1& useSiteDiagnostics, bool typeOrNamespaceOnly);
    private void BindPredefinedTypeForCref(PredefinedTypeSyntax node, ArrayBuilder`1<Symbol> symbols);
    private Symbol ConstructGenericSymbolWithTypeArgumentsForCref(Symbol genericSymbol, GenericNameSyntax genericName);
    private ImmutableArray`1<TypeSymbol> BingTypeArgumentsForCref(SeparatedSyntaxList`1<TypeSyntax> args);
    private void CreateGoodOrAmbiguousFromLookupResultAndFree(LookupResult lookupResult, ArrayBuilder`1<Symbol> result, bool preserveAliases);
}
internal class Microsoft.CodeAnalysis.VisualBasic.DocumentationCommentIdVisitor : VisualBasicSymbolVisitor`2<StringBuilder, object> {
    public static DocumentationCommentIdVisitor Instance;
    private static DocumentationCommentIdVisitor();
    public virtual object DefaultVisit(Symbol symbol, StringBuilder builder);
    public virtual object VisitNamespace(NamespaceSymbol symbol, StringBuilder builder);
    public virtual object VisitEvent(EventSymbol symbol, StringBuilder builder);
    public virtual object VisitMethod(MethodSymbol symbol, StringBuilder builder);
    public virtual object VisitField(FieldSymbol symbol, StringBuilder builder);
    public virtual object VisitProperty(PropertySymbol symbol, StringBuilder builder);
    public virtual object VisitNamedType(NamedTypeSymbol symbol, StringBuilder builder);
    public virtual object VisitArrayType(ArrayTypeSymbol symbol, StringBuilder builder);
    public virtual object VisitTypeParameter(TypeParameterSymbol symbol, StringBuilder builder);
    public virtual object VisitErrorType(ErrorTypeSymbol symbol, StringBuilder builder);
    private static object VisitSymbolUsingPrefix(Symbol symbol, StringBuilder builder, string prefix);
}
internal class Microsoft.CodeAnalysis.VisualBasic.DocumentationCommentParamBinder : DocumentationCommentBinder {
    private static LookupOptions s_invalidLookupOptions;
    private ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public DocumentationCommentParamBinder(Binder containingBinder, Symbol commentedSymbol);
    private ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal virtual ImmutableArray`1<Symbol> BindXmlNameAttributeValue(IdentifierNameSyntax identifier, HashSet`1& useSiteDiagnostics);
    internal virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
    internal virtual void LookupInSingleBinder(LookupResult lookupResult, string name, int arity, LookupOptions options, Binder originalBinder, HashSet`1& useSiteDiagnostics);
}
internal class Microsoft.CodeAnalysis.VisualBasic.DocumentationCommentTypeParamBinder : DocumentationCommentBinder {
    protected ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public DocumentationCommentTypeParamBinder(Binder containingBinder, Symbol commentedSymbol);
    internal virtual ImmutableArray`1<Symbol> BindXmlNameAttributeValue(IdentifierNameSyntax identifier, HashSet`1& useSiteDiagnostics);
    protected ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
    internal virtual void LookupInSingleBinder(LookupResult lookupResult, string name, int arity, LookupOptions options, Binder originalBinder, HashSet`1& useSiteDiagnostics);
}
internal class Microsoft.CodeAnalysis.VisualBasic.DocumentationCommentTypeParamRefBinder : DocumentationCommentTypeParamBinder {
    public DocumentationCommentTypeParamRefBinder(Binder containingBinder, Symbol commentedSymbol);
    internal virtual ImmutableArray`1<Symbol> BindXmlNameAttributeValue(IdentifierNameSyntax identifier, HashSet`1& useSiteDiagnostics);
}
internal class Microsoft.CodeAnalysis.VisualBasic.DominantTypeData : object {
    public TypeSymbol ResultType;
    public RequiredConversion InferenceRestrictions;
    public bool IsStrictCandidate;
    public bool IsUnstrictCandidate;
}
internal class Microsoft.CodeAnalysis.VisualBasic.EarlyWellKnownAttributeBinder : Binder {
    private Symbol _owner;
    public Symbol ContainingMember { get; }
    public BindingLocation BindingLocation { get; }
    internal EarlyWellKnownAttributeBinder(Symbol owner, Binder containingBinder);
    public virtual Symbol get_ContainingMember();
    public virtual BindingLocation get_BindingLocation();
    internal SourceAttributeData GetAttribute(AttributeSyntax node, NamedTypeSymbol boundAttributeType, Boolean& generatedDiagnostics);
    internal static bool CanBeValidAttributeArgument(ExpressionSyntax node, Binder memberAccessBinder);
    internal virtual LookupOptions BinderSpecificLookupOptions(LookupOptions options);
}
internal class Microsoft.CodeAnalysis.VisualBasic.EmbeddedTreeLocation : VBLocation {
    internal EmbeddedSymbolKind _embeddedKind;
    internal TextSpan _span;
    public LocationKind Kind { get; }
    internal EmbeddedSymbolKind EmbeddedKind { get; }
    internal TextSpan PossiblyEmbeddedOrMySourceSpan { get; }
    internal SyntaxTree PossiblyEmbeddedOrMySourceTree { get; }
    public EmbeddedTreeLocation(EmbeddedSymbolKind embeddedKind, TextSpan span);
    public virtual LocationKind get_Kind();
    internal virtual EmbeddedSymbolKind get_EmbeddedKind();
    internal virtual TextSpan get_PossiblyEmbeddedOrMySourceSpan();
    internal virtual SyntaxTree get_PossiblyEmbeddedOrMySourceTree();
    public bool Equals(EmbeddedTreeLocation other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.AssemblyReference : object {
    private AssemblySymbol _targetAssembly;
    public AssemblyIdentity Identity { get; }
    public Version AssemblyVersionPattern { get; }
    private string INamedEntityName { get; }
    public AssemblyReference(AssemblySymbol assemblySymbol);
    public sealed virtual override AssemblyIdentity get_Identity();
    public sealed virtual override Version get_AssemblyVersionPattern();
    private sealed virtual override void IReferenceDispatch(MetadataVisitor visitor);
    private sealed virtual override string get_INamedEntityName();
    private sealed virtual override IAssemblyReference IModuleReferenceGetContainingAssembly(EmitContext context);
    public virtual string ToString();
    private sealed virtual override IEnumerable`1<ICustomAttribute> IReferenceAttributes(EmitContext context);
    private sealed virtual override IDefinition IReferenceAsDefinition(EmitContext context);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.EmitHelpers : object {
    internal static EmitDifferenceResult EmitDifference(VisualBasicCompilation compilation, EmitBaseline baseline, IEnumerable`1<SemanticEdit> edits, Func`2<ISymbol, bool> isAddedSymbol, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection`1<MethodDefinitionHandle> updatedMethods, CompilationTestData testData, CancellationToken cancellationToken);
    internal static EmitBaseline MapToCompilation(VisualBasicCompilation compilation, PEDeltaAssemblyBuilder moduleBeingBuilt);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.GenericMethodInstanceReference : MethodReference {
    public IGenericMethodInstanceReference AsGenericMethodInstanceReference { get; }
    public GenericMethodInstanceReference(MethodSymbol underlyingMethod);
    public virtual void Dispatch(MetadataVisitor visitor);
    private sealed virtual override IEnumerable`1<ITypeReference> IGenericMethodInstanceReferenceGetGenericArguments(EmitContext context);
    private sealed virtual override IMethodReference IGenericMethodInstanceReferenceGetGenericMethod(EmitContext context);
    public virtual IGenericMethodInstanceReference get_AsGenericMethodInstanceReference();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.GenericNamespaceTypeInstanceReference : GenericTypeInstanceReference {
    public IGenericTypeInstanceReference AsGenericTypeInstanceReference { get; }
    public INamespaceTypeReference AsNamespaceTypeReference { get; }
    public INestedTypeReference AsNestedTypeReference { get; }
    public ISpecializedNestedTypeReference AsSpecializedNestedTypeReference { get; }
    public GenericNamespaceTypeInstanceReference(NamedTypeSymbol underlyingNamedType);
    public virtual IGenericTypeInstanceReference get_AsGenericTypeInstanceReference();
    public virtual INamespaceTypeReference get_AsNamespaceTypeReference();
    public virtual INestedTypeReference get_AsNestedTypeReference();
    public virtual ISpecializedNestedTypeReference get_AsSpecializedNestedTypeReference();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.GenericNestedTypeInstanceReference : GenericTypeInstanceReference {
    public IGenericTypeInstanceReference AsGenericTypeInstanceReference { get; }
    public INamespaceTypeReference AsNamespaceTypeReference { get; }
    public INestedTypeReference AsNestedTypeReference { get; }
    public ISpecializedNestedTypeReference AsSpecializedNestedTypeReference { get; }
    public GenericNestedTypeInstanceReference(NamedTypeSymbol underlyingNamedType);
    private sealed virtual override ITypeReference ITypeMemberReferenceGetContainingType(EmitContext context);
    public virtual IGenericTypeInstanceReference get_AsGenericTypeInstanceReference();
    public virtual INamespaceTypeReference get_AsNamespaceTypeReference();
    public virtual INestedTypeReference get_AsNestedTypeReference();
    public virtual ISpecializedNestedTypeReference get_AsSpecializedNestedTypeReference();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Emit.GenericTypeInstanceReference : NamedTypeReference {
    private INamedTypeReference IGenericTypeInstanceReferenceGenericType { get; }
    public GenericTypeInstanceReference(NamedTypeSymbol underlyingNamedType);
    public sealed virtual void Dispatch(MetadataVisitor visitor);
    private sealed virtual override ImmutableArray`1<ITypeReference> IGenericTypeInstanceReferenceGetGenericArguments(EmitContext context);
    private sealed virtual override INamedTypeReference get_IGenericTypeInstanceReferenceGenericType();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Emit.MethodReference : TypeMemberReference {
    protected MethodSymbol m_UnderlyingMethod;
    protected Symbol UnderlyingSymbol { get; }
    private bool IMethodReferenceAcceptsExtraArguments { get; }
    private ushort IMethodReferenceGenericParameterCount { get; }
    private bool IMethodReferenceIsGeneric { get; }
    private ushort IMethodReferenceParameterCount { get; }
    private ImmutableArray`1<IParameterTypeInformation> IMethodReferenceExtraParameters { get; }
    private CallingConvention ISignatureCallingConvention { get; }
    private ImmutableArray`1<ICustomModifier> ISignatureReturnValueCustomModifiers { get; }
    private bool ISignatureReturnValueIsByRef { get; }
    public IGenericMethodInstanceReference AsGenericMethodInstanceReference { get; }
    public ISpecializedMethodReference AsSpecializedMethodReference { get; }
    public MethodReference(MethodSymbol underlyingMethod);
    protected virtual Symbol get_UnderlyingSymbol();
    private sealed virtual override bool get_IMethodReferenceAcceptsExtraArguments();
    private sealed virtual override ushort get_IMethodReferenceGenericParameterCount();
    private sealed virtual override bool get_IMethodReferenceIsGeneric();
    private sealed virtual override ushort get_IMethodReferenceParameterCount();
    private sealed virtual override IMethodDefinition IMethodReferenceGetResolvedMethod(EmitContext context);
    private sealed virtual override ImmutableArray`1<IParameterTypeInformation> get_IMethodReferenceExtraParameters();
    private sealed virtual override CallingConvention get_ISignatureCallingConvention();
    private sealed virtual override ImmutableArray`1<IParameterTypeInformation> ISignatureGetParameters(EmitContext context);
    private sealed virtual override ImmutableArray`1<ICustomModifier> get_ISignatureReturnValueCustomModifiers();
    private sealed virtual override bool get_ISignatureReturnValueIsByRef();
    private sealed virtual override ITypeReference ISignatureGetType(EmitContext context);
    public virtual override IGenericMethodInstanceReference get_AsGenericMethodInstanceReference();
    public virtual override ISpecializedMethodReference get_AsSpecializedMethodReference();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.ModuleReference : object {
    private PEModuleBuilder _moduleBeingBuilt;
    private ModuleSymbol _underlyingModule;
    private string INamedEntityName { get; }
    private bool IFileReferenceHasMetadata { get; }
    private string IFileReferenceFileName { get; }
    internal ModuleReference(PEModuleBuilder moduleBeingBuilt, ModuleSymbol underlyingModule);
    private sealed virtual override void IReferenceDispatch(MetadataVisitor visitor);
    private sealed virtual override string get_INamedEntityName();
    private sealed virtual override bool get_IFileReferenceHasMetadata();
    private sealed virtual override string get_IFileReferenceFileName();
    private sealed virtual override ImmutableArray`1<byte> IFileReferenceGetHashValue(AssemblyHashAlgorithm algorithmId);
    private sealed virtual override IAssemblyReference IModuleReferenceGetContainingAssembly(EmitContext context);
    public virtual string ToString();
    private sealed virtual override IEnumerable`1<ICustomAttribute> IReferenceAttributes(EmitContext context);
    private sealed virtual override IDefinition IReferenceAsDefinition(EmitContext context);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Emit.NamedTypeReference : object {
    protected NamedTypeSymbol m_UnderlyingNamedType;
    private ushort INamedTypeReferenceGenericParameterCount { get; }
    private bool INamedTypeReferenceMangleName { get; }
    private string INamedEntityName { get; }
    private bool ITypeReferenceIsEnum { get; }
    private bool ITypeReferenceIsValueType { get; }
    private TypeDefinitionHandle ITypeReferenceTypeDef { get; }
    private IGenericMethodParameterReference ITypeReferenceAsGenericMethodParameterReference { get; }
    public IGenericTypeInstanceReference AsGenericTypeInstanceReference { get; }
    private IGenericTypeParameterReference ITypeReferenceAsGenericTypeParameterReference { get; }
    public INamespaceTypeReference AsNamespaceTypeReference { get; }
    public INestedTypeReference AsNestedTypeReference { get; }
    public ISpecializedNestedTypeReference AsSpecializedNestedTypeReference { get; }
    public NamedTypeReference(NamedTypeSymbol underlyingNamedType);
    private sealed virtual override ushort get_INamedTypeReferenceGenericParameterCount();
    private sealed virtual override bool get_INamedTypeReferenceMangleName();
    private sealed virtual override string get_INamedEntityName();
    private sealed virtual override bool get_ITypeReferenceIsEnum();
    private sealed virtual override bool get_ITypeReferenceIsValueType();
    private sealed virtual override ITypeDefinition ITypeReferenceGetResolvedType(EmitContext context);
    private sealed virtual override PrimitiveTypeCode ITypeReferenceTypeCode(EmitContext context);
    private sealed virtual override TypeDefinitionHandle get_ITypeReferenceTypeDef();
    private sealed virtual override IGenericMethodParameterReference get_ITypeReferenceAsGenericMethodParameterReference();
    public abstract virtual override IGenericTypeInstanceReference get_AsGenericTypeInstanceReference();
    private sealed virtual override IGenericTypeParameterReference get_ITypeReferenceAsGenericTypeParameterReference();
    private sealed virtual override INamespaceTypeDefinition ITypeReferenceAsNamespaceTypeDefinition(EmitContext context);
    public abstract virtual override INamespaceTypeReference get_AsNamespaceTypeReference();
    private sealed virtual override INestedTypeDefinition ITypeReferenceAsNestedTypeDefinition(EmitContext context);
    public abstract virtual override INestedTypeReference get_AsNestedTypeReference();
    public abstract virtual override ISpecializedNestedTypeReference get_AsSpecializedNestedTypeReference();
    private sealed virtual override ITypeDefinition ITypeReferenceAsTypeDefinition(EmitContext context);
    public virtual string ToString();
    private sealed virtual override IEnumerable`1<ICustomAttribute> IReferenceAttributes(EmitContext context);
    public abstract virtual override void Dispatch(MetadataVisitor visitor);
    private sealed virtual override IDefinition IReferenceAsDefinition(EmitContext context);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.NoPia.EmbeddedEvent : CommonEmbeddedEvent<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, VisualBasicSyntaxNode, VisualBasicAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> {
    protected bool IsRuntimeSpecial { get; }
    protected bool IsSpecialName { get; }
    protected EmbeddedType ContainingType { get; }
    protected TypeMemberVisibility Visibility { get; }
    protected string Name { get; }
    public EmbeddedEvent(EventSymbol underlyingEvent, EmbeddedMethod adder, EmbeddedMethod remover, EmbeddedMethod caller);
    protected virtual IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationSatte);
    protected virtual bool get_IsRuntimeSpecial();
    protected virtual bool get_IsSpecialName();
    protected virtual ITypeReference GetType(PEModuleBuilder moduleBuilder, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    protected virtual EmbeddedType get_ContainingType();
    protected virtual TypeMemberVisibility get_Visibility();
    protected virtual string get_Name();
    protected virtual void EmbedCorrespondingComEventInterfaceMethodInternal(VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, bool isUsedForComAwareEventBinding);
    private bool EmbedMatchingInterfaceMethods(NamedTypeSymbol sourceInterface, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.NoPia.EmbeddedField : CommonEmbeddedField<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, VisualBasicSyntaxNode, VisualBasicAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> {
    internal EmbeddedTypesManager TypeManager { get; }
    protected bool IsCompileTimeConstant { get; }
    protected bool IsNotSerialized { get; }
    protected bool IsReadOnly { get; }
    protected bool IsRuntimeSpecial { get; }
    protected bool IsSpecialName { get; }
    protected bool IsStatic { get; }
    protected bool IsMarshalledExplicitly { get; }
    protected IMarshallingInformation MarshallingInformation { get; }
    protected ImmutableArray`1<byte> MarshallingDescriptor { get; }
    protected Nullable`1<int> TypeLayoutOffset { get; }
    protected TypeMemberVisibility Visibility { get; }
    protected string Name { get; }
    public EmbeddedField(EmbeddedType containingType, FieldSymbol underlyingField);
    internal virtual EmbeddedTypesManager get_TypeManager();
    protected virtual IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    protected virtual IMetadataConstant GetCompileTimeValue(EmitContext context);
    protected virtual bool get_IsCompileTimeConstant();
    protected virtual bool get_IsNotSerialized();
    protected virtual bool get_IsReadOnly();
    protected virtual bool get_IsRuntimeSpecial();
    protected virtual bool get_IsSpecialName();
    protected virtual bool get_IsStatic();
    protected virtual bool get_IsMarshalledExplicitly();
    protected virtual IMarshallingInformation get_MarshallingInformation();
    protected virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    protected virtual Nullable`1<int> get_TypeLayoutOffset();
    protected virtual TypeMemberVisibility get_Visibility();
    protected virtual string get_Name();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.NoPia.EmbeddedMethod : CommonEmbeddedMethod<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, VisualBasicSyntaxNode, VisualBasicAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> {
    internal EmbeddedTypesManager TypeManager { get; }
    protected bool IsAbstract { get; }
    protected bool IsAccessCheckedOnOverride { get; }
    protected bool IsConstructor { get; }
    protected bool IsExternal { get; }
    protected bool IsHiddenBySignature { get; }
    protected bool IsNewSlot { get; }
    protected IPlatformInvokeInformation PlatformInvokeData { get; }
    protected bool IsRuntimeSpecial { get; }
    protected bool IsSpecialName { get; }
    protected bool IsSealed { get; }
    protected bool IsStatic { get; }
    protected bool IsVirtual { get; }
    protected bool ReturnValueIsMarshalledExplicitly { get; }
    protected IMarshallingInformation ReturnValueMarshallingInformation { get; }
    protected ImmutableArray`1<byte> ReturnValueMarshallingDescriptor { get; }
    protected TypeMemberVisibility Visibility { get; }
    protected string Name { get; }
    protected bool AcceptsExtraArguments { get; }
    protected CallingConvention CallingConvention { get; }
    protected ISignature UnderlyingMethodSignature { get; }
    protected INamespace ContainingNamespace { get; }
    public EmbeddedMethod(EmbeddedType containingType, MethodSymbol underlyingMethod);
    internal virtual EmbeddedTypesManager get_TypeManager();
    protected virtual IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    protected virtual ImmutableArray`1<EmbeddedParameter> GetParameters();
    protected virtual ImmutableArray`1<EmbeddedTypeParameter> GetTypeParameters();
    protected virtual bool get_IsAbstract();
    protected virtual bool get_IsAccessCheckedOnOverride();
    protected virtual bool get_IsConstructor();
    protected virtual bool get_IsExternal();
    protected virtual bool get_IsHiddenBySignature();
    protected virtual bool get_IsNewSlot();
    protected virtual IPlatformInvokeInformation get_PlatformInvokeData();
    protected virtual bool get_IsRuntimeSpecial();
    protected virtual bool get_IsSpecialName();
    protected virtual bool get_IsSealed();
    protected virtual bool get_IsStatic();
    protected virtual bool get_IsVirtual();
    protected virtual MethodImplAttributes GetImplementationAttributes(EmitContext context);
    protected virtual bool get_ReturnValueIsMarshalledExplicitly();
    protected virtual IMarshallingInformation get_ReturnValueMarshallingInformation();
    protected virtual ImmutableArray`1<byte> get_ReturnValueMarshallingDescriptor();
    protected virtual TypeMemberVisibility get_Visibility();
    protected virtual string get_Name();
    protected virtual bool get_AcceptsExtraArguments();
    protected virtual CallingConvention get_CallingConvention();
    protected virtual ISignature get_UnderlyingMethodSignature();
    protected virtual INamespace get_ContainingNamespace();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.NoPia.EmbeddedParameter : CommonEmbeddedParameter<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, VisualBasicSyntaxNode, VisualBasicAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> {
    protected bool HasDefaultValue { get; }
    protected bool IsIn { get; }
    protected bool IsOut { get; }
    protected bool IsOptional { get; }
    protected bool IsMarshalledExplicitly { get; }
    protected IMarshallingInformation MarshallingInformation { get; }
    protected ImmutableArray`1<byte> MarshallingDescriptor { get; }
    protected string Name { get; }
    protected IParameterTypeInformation UnderlyingParameterTypeInformation { get; }
    protected ushort Index { get; }
    public EmbeddedParameter(CommonEmbeddedMember<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, VisualBasicSyntaxNode, VisualBasicAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> containingPropertyOrMethod, ParameterSymbol underlyingParameter);
    protected virtual IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    protected virtual bool get_HasDefaultValue();
    protected virtual IMetadataConstant GetDefaultValue(EmitContext context);
    protected virtual bool get_IsIn();
    protected virtual bool get_IsOut();
    protected virtual bool get_IsOptional();
    protected virtual bool get_IsMarshalledExplicitly();
    protected virtual IMarshallingInformation get_MarshallingInformation();
    protected virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    protected virtual string get_Name();
    protected virtual IParameterTypeInformation get_UnderlyingParameterTypeInformation();
    protected virtual ushort get_Index();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.NoPia.EmbeddedProperty : CommonEmbeddedProperty<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, VisualBasicSyntaxNode, VisualBasicAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> {
    protected bool IsRuntimeSpecial { get; }
    protected bool IsSpecialName { get; }
    protected CallingConvention CallingConvention { get; }
    protected bool ReturnValueIsModified { get; }
    protected ImmutableArray`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    protected bool ReturnValueIsByRef { get; }
    protected EmbeddedType ContainingType { get; }
    protected TypeMemberVisibility Visibility { get; }
    protected string Name { get; }
    public EmbeddedProperty(PropertySymbol underlyingProperty, EmbeddedMethod getter, EmbeddedMethod setter);
    protected virtual IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    protected virtual ImmutableArray`1<EmbeddedParameter> GetParameters();
    protected virtual bool get_IsRuntimeSpecial();
    protected virtual bool get_IsSpecialName();
    protected virtual CallingConvention get_CallingConvention();
    protected virtual bool get_ReturnValueIsModified();
    protected virtual ImmutableArray`1<ICustomModifier> get_ReturnValueCustomModifiers();
    protected virtual bool get_ReturnValueIsByRef();
    protected virtual ITypeReference GetType(PEModuleBuilder moduleBuilder, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    protected virtual EmbeddedType get_ContainingType();
    protected virtual TypeMemberVisibility get_Visibility();
    protected virtual string get_Name();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.NoPia.EmbeddedType : CommonEmbeddedType<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, VisualBasicSyntaxNode, VisualBasicAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> {
    private bool _embeddedAllMembersOfImplementedInterface;
    protected bool IsPublic { get; }
    protected bool IsAbstract { get; }
    protected bool IsBeforeFieldInit { get; }
    protected bool IsComImport { get; }
    protected bool IsInterface { get; }
    protected bool IsSerializable { get; }
    protected bool IsSpecialName { get; }
    protected bool IsWindowsRuntimeImport { get; }
    protected bool IsSealed { get; }
    protected CharSet StringFormat { get; }
    public EmbeddedType(EmbeddedTypesManager typeManager, NamedTypeSymbol underlyingNamedType);
    public void EmbedAllMembersOfImplementedInterface(VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    protected virtual int GetAssemblyRefIndex();
    protected virtual bool get_IsPublic();
    protected virtual ITypeReference GetBaseClass(PEModuleBuilder moduleBuilder, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    protected virtual IEnumerable`1<FieldSymbol> GetFieldsToEmit();
    protected virtual IEnumerable`1<MethodSymbol> GetMethodsToEmit();
    protected virtual IEnumerable`1<EventSymbol> GetEventsToEmit();
    protected virtual IEnumerable`1<PropertySymbol> GetPropertiesToEmit();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Emit.NoPia.EmbeddedType/VB$StateMachine_11_GetInterfaces")]
protected virtual IEnumerable`1<ITypeReference> GetInterfaces(EmitContext context);
    protected virtual bool get_IsAbstract();
    protected virtual bool get_IsBeforeFieldInit();
    protected virtual bool get_IsComImport();
    protected virtual bool get_IsInterface();
    protected virtual bool get_IsSerializable();
    protected virtual bool get_IsSpecialName();
    protected virtual bool get_IsWindowsRuntimeImport();
    protected virtual bool get_IsSealed();
    protected virtual Nullable`1<TypeLayout> GetTypeLayoutIfStruct();
    protected virtual CharSet get_StringFormat();
    protected virtual IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    protected virtual VisualBasicAttributeData CreateCompilerGeneratedAttribute();
    protected virtual VisualBasicAttributeData CreateTypeIdentifierAttribute(bool hasGuid, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    protected virtual void ReportMissingAttribute(AttributeDescription description, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    protected virtual void EmbedDefaultMembers(string defaultMember, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.NoPia.EmbeddedTypeParameter : CommonEmbeddedTypeParameter<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, VisualBasicSyntaxNode, VisualBasicAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> {
    protected bool MustBeReferenceType { get; }
    protected bool MustBeValueType { get; }
    protected bool MustHaveDefaultConstructor { get; }
    protected string Name { get; }
    protected ushort Index { get; }
    public EmbeddedTypeParameter(EmbeddedMethod containingMethod, TypeParameterSymbol underlyingTypeParameter);
    protected virtual IEnumerable`1<ITypeReference> GetConstraints(EmitContext context);
    protected virtual bool get_MustBeReferenceType();
    protected virtual bool get_MustBeValueType();
    protected virtual bool get_MustHaveDefaultConstructor();
    protected virtual string get_Name();
    protected virtual ushort get_Index();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.NoPia.EmbeddedTypesManager : EmbeddedTypesManager`21<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, VisualBasicSyntaxNode, VisualBasicAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> {
    private ConcurrentDictionary`2<AssemblySymbol, string> _assemblyGuidMap;
    private ConcurrentDictionary`2<Symbol, bool> _reportedSymbolsMap;
    private NamedTypeSymbol _lazySystemStringType;
    private MethodSymbol[] _lazyWellKnownTypeMethods;
    public EmbeddedTypesManager(PEModuleBuilder moduleBeingBuilt);
    public NamedTypeSymbol GetSystemStringType(VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    public MethodSymbol GetWellKnownMethod(WellKnownMember method, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    private MethodSymbol LazyGetWellKnownTypeMethod(MethodSymbol& lazyMethod, WellKnownMember method, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal virtual int GetTargetAttributeSignatureIndex(Symbol underlyingSymbol, VisualBasicAttributeData attrData, AttributeDescription description);
    internal virtual VisualBasicAttributeData CreateSynthesizedAttribute(WellKnownMember constructor, VisualBasicAttributeData attrData, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal string GetAssemblyGuidString(AssemblySymbol assembly);
    protected virtual void OnGetTypesCompleted(ImmutableArray`1<EmbeddedType> types, DiagnosticBag diagnostics);
    protected virtual void ReportNameCollisionBetweenEmbeddedTypes(EmbeddedType typeA, EmbeddedType typeB, DiagnosticBag diagnostics);
    protected virtual void ReportNameCollisionWithAlreadyDeclaredType(EmbeddedType type, DiagnosticBag diagnostics);
    internal virtual void ReportIndirectReferencesToLinkedAssemblies(AssemblySymbol assembly, DiagnosticBag diagnostics);
    internal static bool IsValidEmbeddableType(NamedTypeSymbol type, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, EmbeddedTypesManager typeManagerOpt);
    private void VerifyNotFrozen();
    private static void ReportNotEmbeddableSymbol(ERRID id, Symbol symbol, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, EmbeddedTypesManager typeManagerOpt);
    internal static void ReportDiagnostic(DiagnosticBag diagnostics, ERRID id, VisualBasicSyntaxNode syntaxNodeOpt, Object[] args);
    private static void ReportDiagnostic(DiagnosticBag diagnostics, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticInfo info);
    internal INamedTypeReference EmbedTypeIfNeedTo(NamedTypeSymbol namedType, bool fromImplements, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    private EmbeddedType EmbedType(NamedTypeSymbol namedType, bool fromImplements, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal virtual EmbeddedField EmbedField(EmbeddedType type, FieldSymbol field, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal virtual EmbeddedMethod EmbedMethod(EmbeddedType type, MethodSymbol method, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal virtual EmbeddedProperty EmbedProperty(EmbeddedType type, PropertySymbol property, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal virtual EmbeddedEvent EmbedEvent(EmbeddedType type, EventSymbol event, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, bool isUsedForComAwareEventBinding);
    protected virtual EmbeddedType GetEmbeddedTypeForMember(Symbol member, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal static ImmutableArray`1<EmbeddedParameter> EmbedParameters(CommonEmbeddedMember<PEModuleBuilder, ModuleCompilationState, EmbeddedTypesManager, VisualBasicSyntaxNode, VisualBasicAttributeData, Symbol, AssemblySymbol, NamedTypeSymbol, FieldSymbol, MethodSymbol, EventSymbol, PropertySymbol, ParameterSymbol, TypeParameterSymbol, EmbeddedType, EmbeddedField, EmbeddedMethod, EmbeddedEvent, EmbeddedProperty, EmbeddedParameter, EmbeddedTypeParameter> containingPropertyOrMethod, ImmutableArray`1<ParameterSymbol> underlyingParameters);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.ParameterTypeInformation : object {
    private ParameterSymbol _underlyingParameter;
    private ImmutableArray`1<ICustomModifier> IParameterTypeInformationCustomModifiers { get; }
    private bool IParameterTypeInformationIsByReference { get; }
    private ushort IParameterTypeInformationCountOfCustomModifiersPrecedingByRef { get; }
    private ushort IParameterListEntryIndex { get; }
    public ParameterTypeInformation(ParameterSymbol underlyingParameter);
    private sealed virtual override ImmutableArray`1<ICustomModifier> get_IParameterTypeInformationCustomModifiers();
    private sealed virtual override bool get_IParameterTypeInformationIsByReference();
    private sealed virtual override ushort get_IParameterTypeInformationCountOfCustomModifiersPrecedingByRef();
    private sealed virtual override ITypeReference IParameterTypeInformationGetType(EmitContext context);
    private sealed virtual override ushort get_IParameterListEntryIndex();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.PEAssemblyBuilder : PEAssemblyBuilderBase {
    internal bool AllowOmissionOfConditionalCalls { get; }
    public int CurrentGenerationOrdinal { get; }
    public PEAssemblyBuilder(SourceAssemblySymbol sourceAssembly, EmitOptions emitOptions, OutputKind outputKind, ModulePropertiesForSerialization serializationProperties, IEnumerable`1<ResourceDescription> manifestResources, ImmutableArray`1<NamedTypeSymbol> additionalTypes);
    internal virtual bool get_AllowOmissionOfConditionalCalls();
    public virtual int get_CurrentGenerationOrdinal();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Emit.PEAssemblyBuilderBase : PEModuleBuilder {
    protected SourceAssemblySymbol m_SourceAssembly;
    private ImmutableArray`1<NamedTypeSymbol> _additionalTypes;
    private ImmutableArray`1<IFileReference> _lazyFiles;
    private string _metadataName;
    private UInt32 IAssemblyFlags { get; }
    private string IAssemblySignatureKey { get; }
    private ImmutableArray`1<byte> IAssemblyPublicKey { get; }
    private AssemblyIdentity Identity { get; }
    private Version AssemblyVersionPattern { get; }
    internal string Name { get; }
    private AssemblyHashAlgorithm IAssemblyHashAlgorithm { get; }
    public PEAssemblyBuilderBase(SourceAssemblySymbol sourceAssembly, EmitOptions emitOptions, OutputKind outputKind, ModulePropertiesForSerialization serializationProperties, IEnumerable`1<ResourceDescription> manifestResources, ImmutableArray`1<NamedTypeSymbol> additionalTypes);
    public virtual void Dispatch(MetadataVisitor visitor);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetAdditionalTopLevelTypes();
    private sealed virtual override IEnumerable`1<IFileReference> IAssemblyGetFiles(EmitContext context);
    private static bool Free(ArrayBuilder`1<IFileReference> builder);
    private sealed virtual override UInt32 get_IAssemblyFlags();
    private sealed virtual override string get_IAssemblySignatureKey();
    private sealed virtual override ImmutableArray`1<byte> get_IAssemblyPublicKey();
    protected virtual void AddEmbeddedResourcesFromAddedModules(ArrayBuilder`1<ManagedResource> builder, DiagnosticBag diagnostics);
    private sealed virtual override AssemblyIdentity get_Identity();
    private sealed virtual override Version get_AssemblyVersionPattern();
    internal virtual string get_Name();
    private sealed virtual override AssemblyHashAlgorithm get_IAssemblyHashAlgorithm();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.PEDeltaAssemblyBuilder : PEAssemblyBuilderBase {
    private EmitBaseline _previousGeneration;
    private VisualBasicDefinitionMap _previousDefinitions;
    private SymbolChanges _changes;
    private DeepTranslator _deepTranslator;
    public int CurrentGenerationOrdinal { get; }
    internal EmitBaseline PreviousGeneration { get; }
    internal VisualBasicDefinitionMap PreviousDefinitions { get; }
    internal bool SupportsPrivateImplClass { get; }
    internal SymbolChanges Changes { get; }
    internal bool AllowOmissionOfConditionalCalls { get; }
    protected IEnumerable`1<string> LinkedAssembliesDebugInfo { get; }
    public PEDeltaAssemblyBuilder(SourceAssemblySymbol sourceAssembly, EmitOptions emitOptions, OutputKind outputKind, ModulePropertiesForSerialization serializationProperties, IEnumerable`1<ResourceDescription> manifestResources, EmitBaseline previousGeneration, IEnumerable`1<SemanticEdit> edits, Func`2<ISymbol, bool> isAddedSymbol);
    internal virtual ITypeReference EncTranslateLocalVariableType(TypeSymbol type, DiagnosticBag diagnostics);
    public virtual int get_CurrentGenerationOrdinal();
    private MetadataSymbols GetOrCreateMetadataSymbols(EmitBaseline initialBaseline, VisualBasicCompilation compilation);
    internal static IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> GetAnonymousTypeMapFromMetadata(MetadataReader reader, MetadataDecoder metadataDecoder);
    private static AnonymousTypeKey GetAnonymousTypeKey(NamedTypeSymbol type);
    private static AnonymousTypeKey GetAnonymousDelegateKey(NamedTypeSymbol type);
    internal EmitBaseline get_PreviousGeneration();
    internal VisualBasicDefinitionMap get_PreviousDefinitions();
    internal virtual bool get_SupportsPrivateImplClass();
    internal sealed virtual override IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> GetAnonymousTypeMap();
    internal virtual VariableSlotAllocator TryCreateVariableSlotAllocator(MethodSymbol method, MethodSymbol topLevelMethod, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<AnonymousTypeKey> GetPreviousAnonymousTypes();
    internal virtual int GetNextAnonymousTypeIndex(bool fromDelegates);
    internal virtual bool TryGetAnonymousTypeName(NamedTypeSymbol template, String& name, Int32& index);
    internal SymbolChanges get_Changes();
    internal virtual IEnumerable`1<INamespaceTypeDefinition> GetTopLevelTypesCore(EmitContext context);
    internal sealed virtual override void OnCreatedIndices(DiagnosticBag diagnostics);
    internal virtual bool get_AllowOmissionOfConditionalCalls();
    protected virtual IEnumerable`1<string> get_LinkedAssembliesDebugInfo();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Emit.PEModuleBuilder : PEModuleBuilder`9<VisualBasicCompilation, SourceModuleSymbol, AssemblySymbol, TypeSymbol, NamedTypeSymbol, MethodSymbol, VisualBasicSyntaxNode, EmbeddedTypesManager, ModuleCompilationState> {
    private ConcurrentDictionary`2<MethodSymbol, bool> _disableJITOptimization;
    private string _metadataName;
    private ImmutableArray`1<NamedTypeSymbol> _lazyExportedTypes;
    private ImmutableArray`1<UsedNamespaceOrType> _lazyTranslatedImports;
    private string _lazyDefaultNamespace;
    private ConcurrentDictionary`2<string, MethodData> _testData;
    private SymbolDisplayFormat _testDataKeyFormat;
    private SymbolDisplayFormat _testDataOperatorKeyFormat;
    protected ConcurrentDictionary`2<Symbol, IModuleReference> m_AssemblyOrModuleSymbolToModuleRefMap;
    private ConcurrentDictionary`2<Symbol, object> _genericInstanceMap;
    private ConcurrentSet`1<ErrorTypeSymbol> _reportedErrorTypesMap;
    private EmbeddedTypesManager _embeddedTypesManagerOpt;
    private ConcurrentSet`1<Symbol> _addedEmbeddedSymbols;
    internal bool AllowOmissionOfConditionalCalls { get; }
    internal string Name { get; }
    internal string ModuleName { get; }
    internal AssemblySymbol CorLibrary { get; }
    protected bool GenerateVisualBasicStylePdb { get; }
    protected IEnumerable`1<string> LinkedAssembliesDebugInfo { get; }
    protected string DefaultNamespace { get; }
    internal bool IgnoreAccessibility { get; }
    internal bool SaveTestData { get; }
    public EmbeddedTypesManager EmbeddedTypesManagerOpt { get; }
    internal PEModuleBuilder(SourceModuleSymbol sourceModule, EmitOptions emitOptions, OutputKind outputKind, ModulePropertiesForSerialization serializationProperties, IEnumerable`1<ResourceDescription> manifestResources);
    internal abstract virtual bool get_AllowOmissionOfConditionalCalls();
    internal virtual string get_Name();
    internal sealed virtual string get_ModuleName();
    internal sealed virtual AssemblySymbol get_CorLibrary();
    protected virtual bool get_GenerateVisualBasicStylePdb();
    protected virtual IEnumerable`1<string> get_LinkedAssembliesDebugInfo();
    protected sealed virtual ImmutableArray`1<UsedNamespaceOrType> GetImports();
    public void TranslateImports(DiagnosticBag diagnostics);
    protected sealed virtual string get_DefaultNamespace();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Emit.PEModuleBuilder/VB$StateMachine_25_GetAssemblyReferencesFromAddedModules")]
protected virtual IEnumerable`1<IAssemblyReference> GetAssemblyReferencesFromAddedModules(DiagnosticBag diagnostics);
    private void ValidateReferencedAssembly(AssemblySymbol assembly, AssemblyReference asmRef, DiagnosticBag diagnostics);
    internal sealed virtual ICustomAttribute SynthesizeAttribute(WellKnownMember attributeConstructor);
    internal sealed virtual IEnumerable`1<ICustomAttribute> GetSourceAssemblyAttributes();
    internal sealed virtual IEnumerable`1<SecurityAttribute> GetSourceAssemblySecurityAttributes();
    internal sealed virtual IEnumerable`1<ICustomAttribute> GetSourceModuleAttributes();
    protected virtual MultiDictionary`2<DebugSourceDocument, DefinitionWithLocation> GetSymbolToLocationMap();
    private void AddSymbolLocation(MultiDictionary`2<DebugSourceDocument, DefinitionWithLocation> result, Symbol symbol);
    private void AddSymbolLocation(MultiDictionary`2<DebugSourceDocument, DefinitionWithLocation> result, Location location, IDefinition definition);
    private Location GetSmallestSourceLocationOrNull(Symbol symbol);
    internal virtual bool get_IgnoreAccessibility();
    internal virtual VariableSlotAllocator TryCreateVariableSlotAllocator(MethodSymbol method, MethodSymbol topLevelMethod, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<AnonymousTypeKey> GetPreviousAnonymousTypes();
    internal virtual int GetNextAnonymousTypeIndex(bool fromDelegates);
    internal virtual bool TryGetAnonymousTypeName(NamedTypeSymbol template, String& name, Int32& index);
    internal virtual ImmutableArray`1<INamespaceTypeDefinition> GetAnonymousTypes();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Emit.PEModuleBuilder/VB$StateMachine_42_GetTopLevelTypesCore")]
internal virtual IEnumerable`1<INamespaceTypeDefinition> GetTopLevelTypesCore(EmitContext context);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetAdditionalTopLevelTypes();
    public virtual IEnumerable`1<ITypeReference> GetExportedTypes(EmitContext context);
    private void GetExportedTypes(NamespaceOrTypeSymbol symbol, ArrayBuilder`1<NamedTypeSymbol> builder);
    private static void GetForwardedTypes(HashSet`1<NamedTypeSymbol> seenTopLevelTypes, CommonAssemblyWellKnownAttributeData`1<NamedTypeSymbol> wellKnownAttributeData, ArrayBuilder`1<NamedTypeSymbol> builder);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Emit.PEModuleBuilder/VB$StateMachine_47_GetReferencedAssembliesUsedSoFar")]
internal IEnumerable`1<AssemblySymbol> GetReferencedAssembliesUsedSoFar();
    internal sealed virtual INamedTypeReference GetSystemType(VisualBasicSyntaxNode syntaxOpt, DiagnosticBag diagnostics);
    internal sealed virtual INamedTypeReference GetSpecialType(SpecialType specialType, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    public virtual IMethodReference GetInitArrayHelper();
    protected virtual bool IsPlatformType(ITypeReference typeRef, PlatformType platformType);
    protected virtual IAssemblyReference GetCorLibraryReferenceToEmit(EmitContext context);
    internal sealed virtual IEnumerable`1<INestedTypeDefinition> GetSynthesizedNestedTypes(NamedTypeSymbol container);
    public void SetDisableJITOptimization(MethodSymbol methodSymbol);
    public bool JITOptimizationIsDisabled(MethodSymbol methodSymbol);
    internal bool get_SaveTestData();
    internal void SetMethodTestData(MethodSymbol methodSymbol, ILBuilder builder);
    internal void SetMethodTestData(ConcurrentDictionary`2<string, MethodData> methods);
    public virtual EmbeddedTypesManager get_EmbeddedTypesManagerOpt();
    private void ProcessReferencedSymbol(Symbol symbol);
    internal sealed virtual IAssemblyReference Translate(AssemblySymbol assembly, DiagnosticBag diagnostics);
    internal IModuleReference Translate(ModuleSymbol module, DiagnosticBag diagnostics);
    protected virtual IModuleReference TranslateModule(ModuleSymbol module, DiagnosticBag diagnostics);
    internal INamedTypeReference Translate(NamedTypeSymbol namedTypeSymbol, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, bool fromImplements, bool needDeclaration);
    internal IGenericParameterReference Translate(TypeParameterSymbol param);
    internal sealed virtual ITypeReference Translate(TypeSymbol typeSymbol, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal IFieldReference Translate(FieldSymbol fieldSymbol, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, bool needDeclaration);
    public static TypeMemberVisibility MemberVisibility(Symbol symbol);
    internal virtual IMethodReference Translate(MethodSymbol symbol, DiagnosticBag diagnostics, bool needDeclaration);
    internal IMethodReference Translate(MethodSymbol methodSymbol, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, bool needDeclaration);
    internal IMethodReference TranslateOverriddenMethodReference(MethodSymbol methodSymbol, VisualBasicSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal ImmutableArray`1<IParameterTypeInformation> Translate(ImmutableArray`1<ParameterSymbol> params);
    private static bool MustBeWrapped(ParameterSymbol param);
    private ImmutableArray`1<IParameterTypeInformation> TranslateAll(ImmutableArray`1<ParameterSymbol> params);
    private IParameterTypeInformation CreateParameterTypeInformationWrapper(ParameterSymbol param);
    private static bool ContainerIsGeneric(Symbol container);
    internal IArrayTypeReference Translate(ArrayTypeSymbol symbol);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.PENetModuleBuilder : PEModuleBuilder {
    internal bool AllowOmissionOfConditionalCalls { get; }
    public int CurrentGenerationOrdinal { get; }
    internal PENetModuleBuilder(SourceModuleSymbol sourceModule, EmitOptions emitOptions, ModulePropertiesForSerialization serializationProperties, IEnumerable`1<ResourceDescription> manifestResources);
    protected virtual void AddEmbeddedResourcesFromAddedModules(ArrayBuilder`1<ManagedResource> builder, DiagnosticBag diagnostics);
    internal virtual bool get_AllowOmissionOfConditionalCalls();
    public virtual int get_CurrentGenerationOrdinal();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.SpecializedFieldReference : TypeMemberReference {
    private FieldSymbol _underlyingField;
    protected Symbol UnderlyingSymbol { get; }
    private IFieldReference ISpecializedFieldReferenceUnspecializedVersion { get; }
    private ISpecializedFieldReference IFieldReferenceAsSpecializedFieldReference { get; }
    private bool IsContextualNamedEntity { get; }
    public SpecializedFieldReference(FieldSymbol underlyingField);
    protected virtual Symbol get_UnderlyingSymbol();
    public virtual void Dispatch(MetadataVisitor visitor);
    private sealed virtual override IFieldReference get_ISpecializedFieldReferenceUnspecializedVersion();
    private sealed virtual override ISpecializedFieldReference get_IFieldReferenceAsSpecializedFieldReference();
    private sealed virtual override ITypeReference IFieldReferenceGetType(EmitContext context);
    private sealed virtual override IFieldDefinition IFieldReferenceGetResolvedField(EmitContext context);
    private sealed virtual override void AssociateWithMetadataWriter(MetadataWriter metadataWriter);
    private sealed virtual override bool get_IsContextualNamedEntity();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.SpecializedGenericMethodInstanceReference : SpecializedMethodReference {
    private SpecializedMethodReference _genericMethod;
    public IGenericMethodInstanceReference AsGenericMethodInstanceReference { get; }
    public SpecializedGenericMethodInstanceReference(MethodSymbol underlyingMethod);
    public sealed virtual override IMethodReference GetGenericMethod(EmitContext context);
    public sealed virtual override IEnumerable`1<ITypeReference> GetGenericArguments(EmitContext context);
    public virtual IGenericMethodInstanceReference get_AsGenericMethodInstanceReference();
    public virtual void Dispatch(MetadataVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.SpecializedGenericNestedTypeInstanceReference : SpecializedNestedTypeReference {
    private INamedTypeReference IGenericTypeInstanceReferenceGenericType { get; }
    public IGenericTypeInstanceReference AsGenericTypeInstanceReference { get; }
    public INamespaceTypeReference AsNamespaceTypeReference { get; }
    public INestedTypeReference AsNestedTypeReference { get; }
    public ISpecializedNestedTypeReference AsSpecializedNestedTypeReference { get; }
    public SpecializedGenericNestedTypeInstanceReference(NamedTypeSymbol underlyingNamedType);
    public virtual void Dispatch(MetadataVisitor visitor);
    private sealed virtual override ImmutableArray`1<ITypeReference> IGenericTypeInstanceReferenceGetGenericArguments(EmitContext context);
    private sealed virtual override INamedTypeReference get_IGenericTypeInstanceReferenceGenericType();
    public virtual IGenericTypeInstanceReference get_AsGenericTypeInstanceReference();
    public virtual INamespaceTypeReference get_AsNamespaceTypeReference();
    public virtual INestedTypeReference get_AsNestedTypeReference();
    public virtual ISpecializedNestedTypeReference get_AsSpecializedNestedTypeReference();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.SpecializedMethodReference : MethodReference {
    private IMethodReference ISpecializedMethodReferenceUnspecializedVersion { get; }
    public ISpecializedMethodReference AsSpecializedMethodReference { get; }
    public SpecializedMethodReference(MethodSymbol underlyingMethod);
    public virtual void Dispatch(MetadataVisitor visitor);
    private sealed virtual override IMethodReference get_ISpecializedMethodReferenceUnspecializedVersion();
    public virtual ISpecializedMethodReference get_AsSpecializedMethodReference();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.SpecializedNestedTypeReference : NamedTypeReference {
    private INestedTypeReference ISpecializedNestedTypeReferenceUnspecializedVersion { get; }
    public IGenericTypeInstanceReference AsGenericTypeInstanceReference { get; }
    public INamespaceTypeReference AsNamespaceTypeReference { get; }
    public INestedTypeReference AsNestedTypeReference { get; }
    public ISpecializedNestedTypeReference AsSpecializedNestedTypeReference { get; }
    public SpecializedNestedTypeReference(NamedTypeSymbol underlyingNamedType);
    private sealed virtual override INestedTypeReference get_ISpecializedNestedTypeReferenceUnspecializedVersion();
    public virtual void Dispatch(MetadataVisitor visitor);
    private sealed virtual override ITypeReference ITypeMemberReferenceGetContainingType(EmitContext context);
    public virtual IGenericTypeInstanceReference get_AsGenericTypeInstanceReference();
    public virtual INamespaceTypeReference get_AsNamespaceTypeReference();
    public virtual INestedTypeReference get_AsNestedTypeReference();
    public virtual ISpecializedNestedTypeReference get_AsSpecializedNestedTypeReference();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Emit.TypeMemberReference : object {
    protected Symbol UnderlyingSymbol { get; }
    private string INamedEntityName { get; }
    protected abstract virtual Symbol get_UnderlyingSymbol();
    public virtual override ITypeReference GetContainingType(EmitContext context);
    private sealed virtual override string get_INamedEntityName();
    public virtual string ToString();
    private sealed virtual override IEnumerable`1<ICustomAttribute> IReferenceAttributes(EmitContext context);
    public abstract virtual override void Dispatch(MetadataVisitor visitor);
    private sealed virtual override IDefinition IReferenceAsDefinition(EmitContext context);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.VisualBasicDefinitionMap : DefinitionMap`1<VisualBasicSymbolMatcher> {
    private MetadataDecoder _metadataDecoder;
    internal CommonMessageProvider MessageProvider { get; }
    public VisualBasicDefinitionMap(PEModule module, IEnumerable`1<SemanticEdit> edits, MetadataDecoder metadataDecoder, VisualBasicSymbolMatcher mapToMetadata, VisualBasicSymbolMatcher mapToPrevious);
    internal virtual CommonMessageProvider get_MessageProvider();
    internal bool TryGetAnonymousTypeName(NamedTypeSymbol template, String& name, Int32& index);
    internal virtual bool TryGetTypeHandle(ITypeDefinition def, TypeDefinitionHandle& handle);
    internal virtual bool TryGetEventHandle(IEventDefinition def, EventDefinitionHandle& handle);
    internal virtual bool TryGetFieldHandle(IFieldDefinition def, FieldDefinitionHandle& handle);
    internal virtual bool TryGetMethodHandle(IMethodDefinition def, MethodDefinitionHandle& handle);
    internal virtual bool TryGetPropertyHandle(IPropertyDefinition def, PropertyDefinitionHandle& handle);
    protected virtual ITypeSymbol TryGetStateMachineType(EntityHandle methodHandle);
    protected virtual void GetStateMachineFieldMapFromMetadata(ITypeSymbol stateMachineType, ImmutableArray`1<LocalSlotDebugInfo> localSlotDebugInfo, IReadOnlyDictionary`2& hoistedLocalMap, IReadOnlyDictionary`2& awaiterMap, Int32& awaiterSlotCount);
    protected virtual ImmutableArray`1<EncLocalInfo> TryGetLocalSlotMapFromMetadata(MethodDefinitionHandle handle, EditAndContinueMethodDebugInformation debugInfo);
    private static ImmutableArray`1<EncLocalInfo> CreateLocalSlotMap(EditAndContinueMethodDebugInformation methodEncInfo, ImmutableArray`1<LocalInfo`1<TypeSymbol>> slotMetadata);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Emit.VisualBasicSymbolMatcher : SymbolMatcher {
    private static StringComparer s_nameComparer;
    private MatchDefs _defs;
    private MatchSymbols _symbols;
    private static VisualBasicSymbolMatcher();
    public VisualBasicSymbolMatcher(IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> anonymousTypeMap, SourceAssemblySymbol sourceAssembly, EmitContext sourceContext, SourceAssemblySymbol otherAssembly, EmitContext otherContext, ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> otherSynthesizedMembersOpt);
    public VisualBasicSymbolMatcher(IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> anonymousTypeMap, SourceAssemblySymbol sourceAssembly, EmitContext sourceContext, PEAssemblySymbol otherAssembly);
    public virtual IDefinition MapDefinition(IDefinition def);
    public virtual ITypeReference MapReference(ITypeReference reference);
    internal bool TryGetAnonymousTypeName(NamedTypeSymbol template, String& name, Int32& index);
}
internal class Microsoft.CodeAnalysis.VisualBasic.EntryPointsWalker : AbstractRegionControlFlowPass {
    private HashSet`1<LabelStatementSyntax> _entryPoints;
    private EntryPointsWalker(FlowAnalysisInfo info, FlowAnalysisRegionInfo region);
    internal static IEnumerable`1<LabelStatementSyntax> Analyze(FlowAnalysisInfo info, FlowAnalysisRegionInfo region, Nullable`1& succeeded);
    private bool Analyze();
    protected virtual void Free();
    protected virtual void NoteBranch(PendingBranch<LocalState> pending, BoundStatement stmt, BoundLabelStatement labelStmt);
}
internal enum Microsoft.CodeAnalysis.VisualBasic.ERRID : Enum {
    public int value__;
    public static ERRID Void;
    public static ERRID Unknown;
    public static ERRID ERR_None;
    public static ERRID ERR_FileNotFound;
    public static ERRID ERR_ArgumentRequired;
    public static ERRID WRN_BadSwitch;
    public static ERRID ERR_NoSources;
    public static ERRID ERR_SwitchNeedsBool;
    public static ERRID ERR_NoResponseFile;
    public static ERRID ERR_CantOpenFileWrite;
    public static ERRID ERR_InvalidSwitchValue;
    public static ERRID ERR_BinaryFile;
    public static ERRID ERR_BadCodepage;
    public static ERRID ERR_LibNotFound;
    public static ERRID ERR_IconFileAndWin32ResFile;
    public static ERRID WRN_NoConfigInResponseFile;
    public static ERRID ERR_NoSourcesOut;
    public static ERRID ERR_NeedModule;
    public static ERRID ERR_InvalidAssemblyName;
    public static ERRID FTL_InputFileNameTooLong;
    public static ERRID ERR_ConflictingManifestSwitches;
    public static ERRID WRN_IgnoreModuleManifest;
    public static ERRID WRN_BadUILang;
    public static ERRID ERR_VBCoreNetModuleConflict;
    public static ERRID ERR_InvalidFormatForGuidForOption;
    public static ERRID ERR_MissingGuidForOption;
    public static ERRID ERR_BadChecksumAlgorithm;
    public static ERRID ERR_MutuallyExclusiveOptions;
    public static ERRID ERR_InvalidInNamespace;
    public static ERRID ERR_UndefinedType1;
    public static ERRID ERR_MissingNext;
    public static ERRID ERR_IllegalCharConstant;
    public static ERRID ERR_UnreferencedAssemblyEvent3;
    public static ERRID ERR_UnreferencedModuleEvent3;
    public static ERRID ERR_UnreferencedModuleBase3;
    public static ERRID ERR_UnreferencedModuleImplements3;
    public static ERRID ERR_LbExpectedEndIf;
    public static ERRID ERR_LbNoMatchingIf;
    public static ERRID ERR_LbBadElseif;
    public static ERRID ERR_InheritsFromRestrictedType1;
    public static ERRID ERR_InvOutsideProc;
    public static ERRID ERR_DelegateCantImplement;
    public static ERRID ERR_DelegateCantHandleEvents;
    public static ERRID ERR_IsOperatorRequiresReferenceTypes1;
    public static ERRID ERR_TypeOfRequiresReferenceType1;
    public static ERRID ERR_ReadOnlyHasSet;
    public static ERRID ERR_WriteOnlyHasGet;
    public static ERRID ERR_InvInsideProc;
    public static ERRID ERR_EndProp;
    public static ERRID ERR_EndSubExpected;
    public static ERRID ERR_EndFunctionExpected;
    public static ERRID ERR_LbElseNoMatchingIf;
    public static ERRID ERR_CantRaiseBaseEvent;
    public static ERRID ERR_TryWithoutCatchOrFinally;
    public static ERRID ERR_EventsCantBeFunctions;
    public static ERRID ERR_MissingEndBrack;
    public static ERRID ERR_Syntax;
    public static ERRID ERR_Overflow;
    public static ERRID ERR_IllegalChar;
    public static ERRID ERR_StrictDisallowsObjectOperand1;
    public static ERRID ERR_LoopControlMustNotBeProperty;
    public static ERRID ERR_MethodBodyNotAtLineStart;
    public static ERRID ERR_MaximumNumberOfErrors;
    public static ERRID ERR_UseOfKeywordNotInInstanceMethod1;
    public static ERRID ERR_UseOfKeywordFromStructure1;
    public static ERRID ERR_BadAttributeConstructor1;
    public static ERRID ERR_ParamArrayWithOptArgs;
    public static ERRID ERR_ExpectedArray1;
    public static ERRID ERR_ParamArrayNotArray;
    public static ERRID ERR_ParamArrayRank;
    public static ERRID ERR_ArrayRankLimit;
    public static ERRID ERR_AsNewArray;
    public static ERRID ERR_TooManyArgs1;
    public static ERRID ERR_ExpectedCase;
    public static ERRID ERR_RequiredConstExpr;
    public static ERRID ERR_RequiredConstConversion2;
    public static ERRID ERR_InvalidMe;
    public static ERRID ERR_ReadOnlyAssignment;
    public static ERRID ERR_ExitSubOfFunc;
    public static ERRID ERR_ExitPropNot;
    public static ERRID ERR_ExitFuncOfSub;
    public static ERRID ERR_LValueRequired;
    public static ERRID ERR_ForIndexInUse1;
    public static ERRID ERR_NextForMismatch1;
    public static ERRID ERR_CaseElseNoSelect;
    public static ERRID ERR_CaseNoSelect;
    public static ERRID ERR_CantAssignToConst;
    public static ERRID ERR_NamedSubscript;
    public static ERRID ERR_ExpectedEndIf;
    public static ERRID ERR_ExpectedEndWhile;
    public static ERRID ERR_ExpectedLoop;
    public static ERRID ERR_ExpectedNext;
    public static ERRID ERR_ExpectedEndWith;
    public static ERRID ERR_ElseNoMatchingIf;
    public static ERRID ERR_EndIfNoMatchingIf;
    public static ERRID ERR_EndSelectNoSelect;
    public static ERRID ERR_ExitDoNotWithinDo;
    public static ERRID ERR_EndWhileNoWhile;
    public static ERRID ERR_LoopNoMatchingDo;
    public static ERRID ERR_NextNoMatchingFor;
    public static ERRID ERR_EndWithWithoutWith;
    public static ERRID ERR_MultiplyDefined1;
    public static ERRID ERR_ExpectedEndSelect;
    public static ERRID ERR_ExitForNotWithinFor;
    public static ERRID ERR_ExitWhileNotWithinWhile;
    public static ERRID ERR_ReadOnlyProperty1;
    public static ERRID ERR_ExitSelectNotWithinSelect;
    public static ERRID ERR_BranchOutOfFinally;
    public static ERRID ERR_QualNotObjectRecord1;
    public static ERRID ERR_TooFewIndices;
    public static ERRID ERR_TooManyIndices;
    public static ERRID ERR_EnumNotExpression1;
    public static ERRID ERR_TypeNotExpression1;
    public static ERRID ERR_ClassNotExpression1;
    public static ERRID ERR_StructureNotExpression1;
    public static ERRID ERR_InterfaceNotExpression1;
    public static ERRID ERR_NamespaceNotExpression1;
    public static ERRID ERR_BadNamespaceName1;
    public static ERRID ERR_XmlPrefixNotExpression;
    public static ERRID ERR_MultipleExtends;
    public static ERRID ERR_PropMustHaveGetSet;
    public static ERRID ERR_WriteOnlyHasNoWrite;
    public static ERRID ERR_ReadOnlyHasNoGet;
    public static ERRID ERR_BadAttribute1;
    public static ERRID ERR_LabelNotDefined1;
    public static ERRID ERR_ErrorCreatingWin32ResourceFile;
    public static ERRID ERR_UnableToCreateTempFile;
    public static ERRID ERR_RequiredNewCall2;
    public static ERRID ERR_UnimplementedMember3;
    public static ERRID ERR_BadWithRef;
    public static ERRID ERR_DuplicateAccessCategoryUsed;
    public static ERRID ERR_DuplicateModifierCategoryUsed;
    public static ERRID ERR_DuplicateSpecifier;
    public static ERRID ERR_TypeConflict6;
    public static ERRID ERR_UnrecognizedTypeKeyword;
    public static ERRID ERR_ExtraSpecifiers;
    public static ERRID ERR_UnrecognizedType;
    public static ERRID ERR_InvalidUseOfKeyword;
    public static ERRID ERR_InvalidEndEnum;
    public static ERRID ERR_MissingEndEnum;
    public static ERRID ERR_ExpectedDeclaration;
    public static ERRID ERR_ParamArrayMustBeLast;
    public static ERRID ERR_SpecifiersInvalidOnInheritsImplOpt;
    public static ERRID ERR_ExpectedSpecifier;
    public static ERRID ERR_ExpectedComma;
    public static ERRID ERR_ExpectedAs;
    public static ERRID ERR_ExpectedRparen;
    public static ERRID ERR_ExpectedLparen;
    public static ERRID ERR_InvalidNewInType;
    public static ERRID ERR_ExpectedExpression;
    public static ERRID ERR_ExpectedOptional;
    public static ERRID ERR_ExpectedIdentifier;
    public static ERRID ERR_ExpectedIntLiteral;
    public static ERRID ERR_ExpectedEOS;
    public static ERRID ERR_ExpectedForOptionStmt;
    public static ERRID ERR_InvalidOptionCompare;
    public static ERRID ERR_ExpectedOptionCompare;
    public static ERRID ERR_StrictDisallowImplicitObject;
    public static ERRID ERR_StrictDisallowsImplicitProc;
    public static ERRID ERR_StrictDisallowsImplicitArgs;
    public static ERRID ERR_InvalidParameterSyntax;
    public static ERRID ERR_ExpectedSubFunction;
    public static ERRID ERR_ExpectedStringLiteral;
    public static ERRID ERR_MissingLibInDeclare;
    public static ERRID ERR_DelegateNoInvoke1;
    public static ERRID ERR_MissingIsInTypeOf;
    public static ERRID ERR_DuplicateOption1;
    public static ERRID ERR_ModuleCantInherit;
    public static ERRID ERR_ModuleCantImplement;
    public static ERRID ERR_BadImplementsType;
    public static ERRID ERR_BadConstFlags1;
    public static ERRID ERR_BadWithEventsFlags1;
    public static ERRID ERR_BadDimFlags1;
    public static ERRID ERR_DuplicateParamName1;
    public static ERRID ERR_LoopDoubleCondition;
    public static ERRID ERR_ExpectedRelational;
    public static ERRID ERR_ExpectedExitKind;
    public static ERRID ERR_ExpectedNamedArgument;
    public static ERRID ERR_BadMethodFlags1;
    public static ERRID ERR_BadEventFlags1;
    public static ERRID ERR_BadDeclareFlags1;
    public static ERRID ERR_BadLocalConstFlags1;
    public static ERRID ERR_BadLocalDimFlags1;
    public static ERRID ERR_ExpectedConditionalDirective;
    public static ERRID ERR_ExpectedEQ;
    public static ERRID ERR_ConstructorNotFound1;
    public static ERRID ERR_InvalidEndInterface;
    public static ERRID ERR_MissingEndInterface;
    public static ERRID ERR_InheritsFrom2;
    public static ERRID ERR_InheritanceCycle1;
    public static ERRID ERR_InheritsFromNonClass;
    public static ERRID ERR_MultiplyDefinedType3;
    public static ERRID ERR_BadOverrideAccess2;
    public static ERRID ERR_CantOverrideNotOverridable2;
    public static ERRID ERR_DuplicateProcDef1;
    public static ERRID ERR_BadInterfaceMethodFlags1;
    public static ERRID ERR_NamedParamNotFound2;
    public static ERRID ERR_BadInterfacePropertyFlags1;
    public static ERRID ERR_NamedArgUsedTwice2;
    public static ERRID ERR_InterfaceCantUseEventSpecifier1;
    public static ERRID ERR_TypecharNoMatch2;
    public static ERRID ERR_ExpectedSubOrFunction;
    public static ERRID ERR_BadEmptyEnum1;
    public static ERRID ERR_InvalidConstructorCall;
    public static ERRID ERR_CantOverrideConstructor;
    public static ERRID ERR_OverrideNotNeeded3;
    public static ERRID ERR_ExpectedDot;
    public static ERRID ERR_DuplicateLocals1;
    public static ERRID ERR_InvInsideEndsProc;
    public static ERRID ERR_LocalSameAsFunc;
    public static ERRID ERR_RecordEmbeds2;
    public static ERRID ERR_RecordCycle2;
    public static ERRID ERR_InterfaceCycle1;
    public static ERRID ERR_SubNewCycle2;
    public static ERRID ERR_SubNewCycle1;
    public static ERRID ERR_InheritsFromCantInherit3;
    public static ERRID ERR_OverloadWithOptional2;
    public static ERRID ERR_OverloadWithReturnType2;
    public static ERRID ERR_TypeCharWithType1;
    public static ERRID ERR_TypeCharOnSub;
    public static ERRID ERR_OverloadWithDefault2;
    public static ERRID ERR_MissingSubscript;
    public static ERRID ERR_OverrideWithDefault2;
    public static ERRID ERR_OverrideWithOptional2;
    public static ERRID ERR_FieldOfValueFieldOfMarshalByRef3;
    public static ERRID ERR_TypeMismatch2;
    public static ERRID ERR_CaseAfterCaseElse;
    public static ERRID ERR_ConvertArrayMismatch4;
    public static ERRID ERR_ConvertObjectArrayMismatch3;
    public static ERRID ERR_ForLoopType1;
    public static ERRID ERR_OverloadWithByref2;
    public static ERRID ERR_InheritsFromNonInterface;
    public static ERRID ERR_BadInterfaceOrderOnInherits;
    public static ERRID ERR_DuplicateDefaultProps1;
    public static ERRID ERR_DefaultMissingFromProperty2;
    public static ERRID ERR_OverridingPropertyKind2;
    public static ERRID ERR_NewInInterface;
    public static ERRID ERR_BadFlagsOnNew1;
    public static ERRID ERR_OverloadingPropertyKind2;
    public static ERRID ERR_NoDefaultNotExtend1;
    public static ERRID ERR_OverloadWithArrayVsParamArray2;
    public static ERRID ERR_BadInstanceMemberAccess;
    public static ERRID ERR_ExpectedRbrace;
    public static ERRID ERR_ModuleAsType1;
    public static ERRID ERR_NewIfNullOnNonClass;
    public static ERRID ERR_CatchAfterFinally;
    public static ERRID ERR_CatchNoMatchingTry;
    public static ERRID ERR_FinallyAfterFinally;
    public static ERRID ERR_FinallyNoMatchingTry;
    public static ERRID ERR_EndTryNoTry;
    public static ERRID ERR_ExpectedEndTry;
    public static ERRID ERR_BadDelegateFlags1;
    public static ERRID ERR_NoConstructorOnBase2;
    public static ERRID ERR_InaccessibleSymbol2;
    public static ERRID ERR_InaccessibleMember3;
    public static ERRID ERR_CatchNotException1;
    public static ERRID ERR_ExitTryNotWithinTry;
    public static ERRID ERR_BadRecordFlags1;
    public static ERRID ERR_BadEnumFlags1;
    public static ERRID ERR_BadInterfaceFlags1;
    public static ERRID ERR_OverrideWithByref2;
    public static ERRID ERR_MyBaseAbstractCall1;
    public static ERRID ERR_IdentNotMemberOfInterface4;
    public static ERRID ERR_WithEventsRequiresClass;
    public static ERRID ERR_WithEventsAsStruct;
    public static ERRID ERR_ConvertArrayRankMismatch2;
    public static ERRID ERR_RedimRankMismatch;
    public static ERRID ERR_StartupCodeNotFound1;
    public static ERRID ERR_ConstAsNonConstant;
    public static ERRID ERR_InvalidEndSub;
    public static ERRID ERR_InvalidEndFunction;
    public static ERRID ERR_InvalidEndProperty;
    public static ERRID ERR_ModuleCantUseMethodSpecifier1;
    public static ERRID ERR_ModuleCantUseEventSpecifier1;
    public static ERRID ERR_StructCantUseVarSpecifier1;
    public static ERRID ERR_InvalidOverrideDueToReturn2;
    public static ERRID ERR_ConstantWithNoValue;
    public static ERRID ERR_ExpressionOverflow1;
    public static ERRID ERR_DuplicatePropertyGet;
    public static ERRID ERR_DuplicatePropertySet;
    public static ERRID ERR_NameNotDeclared1;
    public static ERRID ERR_BinaryOperands3;
    public static ERRID ERR_ExpectedProcedure;
    public static ERRID ERR_OmittedArgument2;
    public static ERRID ERR_NameNotMember2;
    public static ERRID ERR_EndClassNoClass;
    public static ERRID ERR_BadClassFlags1;
    public static ERRID ERR_ImportsMustBeFirst;
    public static ERRID ERR_NonNamespaceOrClassOnImport2;
    public static ERRID ERR_TypecharNotallowed;
    public static ERRID ERR_ObjectReferenceNotSupplied;
    public static ERRID ERR_MyClassNotInClass;
    public static ERRID ERR_IndexedNotArrayOrProc;
    public static ERRID ERR_EventSourceIsArray;
    public static ERRID ERR_SharedConstructorWithParams;
    public static ERRID ERR_SharedConstructorIllegalSpec1;
    public static ERRID ERR_ExpectedEndClass;
    public static ERRID ERR_UnaryOperand2;
    public static ERRID ERR_BadFlagsWithDefault1;
    public static ERRID ERR_VoidValue;
    public static ERRID ERR_ConstructorFunction;
    public static ERRID ERR_InvalidLiteralExponent;
    public static ERRID ERR_NewCannotHandleEvents;
    public static ERRID ERR_CircularEvaluation1;
    public static ERRID ERR_BadFlagsOnSharedMeth1;
    public static ERRID ERR_BadFlagsOnSharedProperty1;
    public static ERRID ERR_BadFlagsOnStdModuleProperty1;
    public static ERRID ERR_SharedOnProcThatImpl;
    public static ERRID ERR_NoWithEventsVarOnHandlesList;
    public static ERRID ERR_AccessMismatch6;
    public static ERRID ERR_InheritanceAccessMismatch5;
    public static ERRID ERR_NarrowingConversionDisallowed2;
    public static ERRID ERR_NoArgumentCountOverloadCandidates1;
    public static ERRID ERR_NoViableOverloadCandidates1;
    public static ERRID ERR_NoCallableOverloadCandidates2;
    public static ERRID ERR_NoNonNarrowingOverloadCandidates2;
    public static ERRID ERR_ArgumentNarrowing3;
    public static ERRID ERR_NoMostSpecificOverload2;
    public static ERRID ERR_NotMostSpecificOverload;
    public static ERRID ERR_OverloadCandidate2;
    public static ERRID ERR_NoGetProperty1;
    public static ERRID ERR_NoSetProperty1;
    public static ERRID ERR_ParamTypingInconsistency;
    public static ERRID ERR_ParamNameFunctionNameCollision;
    public static ERRID ERR_DateToDoubleConversion;
    public static ERRID ERR_DoubleToDateConversion;
    public static ERRID ERR_ZeroDivide;
    public static ERRID ERR_TryAndOnErrorDoNotMix;
    public static ERRID ERR_PropertyAccessIgnored;
    public static ERRID ERR_InterfaceNoDefault1;
    public static ERRID ERR_InvalidAssemblyAttribute1;
    public static ERRID ERR_InvalidModuleAttribute1;
    public static ERRID ERR_AmbiguousInUnnamedNamespace1;
    public static ERRID ERR_DefaultMemberNotProperty1;
    public static ERRID ERR_AmbiguousInNamespace2;
    public static ERRID ERR_AmbiguousInImports2;
    public static ERRID ERR_AmbiguousInModules2;
    public static ERRID ERR_ArrayInitializerTooFewDimensions;
    public static ERRID ERR_ArrayInitializerTooManyDimensions;
    public static ERRID ERR_InitializerTooFewElements1;
    public static ERRID ERR_InitializerTooManyElements1;
    public static ERRID ERR_NewOnAbstractClass;
    public static ERRID ERR_DuplicateNamedImportAlias1;
    public static ERRID ERR_DuplicatePrefix;
    public static ERRID ERR_StrictDisallowsLateBinding;
    public static ERRID ERR_AddressOfOperandNotMethod;
    public static ERRID ERR_EndExternalSource;
    public static ERRID ERR_ExpectedEndExternalSource;
    public static ERRID ERR_NestedExternalSource;
    public static ERRID ERR_AddressOfNotDelegate1;
    public static ERRID ERR_SyncLockRequiresReferenceType1;
    public static ERRID ERR_MethodAlreadyImplemented2;
    public static ERRID ERR_DuplicateInInherits1;
    public static ERRID ERR_NamedParamArrayArgument;
    public static ERRID ERR_OmittedParamArrayArgument;
    public static ERRID ERR_ParamArrayArgumentMismatch;
    public static ERRID ERR_EventNotFound1;
    public static ERRID ERR_ModuleCantUseVariableSpecifier1;
    public static ERRID ERR_SharedEventNeedsSharedHandler;
    public static ERRID ERR_ExpectedMinus;
    public static ERRID ERR_InterfaceMemberSyntax;
    public static ERRID ERR_InvInsideInterface;
    public static ERRID ERR_InvInsideEndsInterface;
    public static ERRID ERR_BadFlagsInNotInheritableClass1;
    public static ERRID ERR_UnimplementedMustOverride;
    public static ERRID ERR_BaseOnlyClassesMustBeExplicit2;
    public static ERRID ERR_NegativeArraySize;
    public static ERRID ERR_MyClassAbstractCall1;
    public static ERRID ERR_EndDisallowedInDllProjects;
    public static ERRID ERR_BlockLocalShadowing1;
    public static ERRID ERR_ModuleNotAtNamespace;
    public static ERRID ERR_NamespaceNotAtNamespace;
    public static ERRID ERR_InvInsideEndsEnum;
    public static ERRID ERR_InvalidOptionStrict;
    public static ERRID ERR_EndStructureNoStructure;
    public static ERRID ERR_EndModuleNoModule;
    public static ERRID ERR_EndNamespaceNoNamespace;
    public static ERRID ERR_ExpectedEndStructure;
    public static ERRID ERR_ExpectedEndModule;
    public static ERRID ERR_ExpectedEndNamespace;
    public static ERRID ERR_OptionStmtWrongOrder;
    public static ERRID ERR_StructCantInherit;
    public static ERRID ERR_NewInStruct;
    public static ERRID ERR_InvalidEndGet;
    public static ERRID ERR_MissingEndGet;
    public static ERRID ERR_InvalidEndSet;
    public static ERRID ERR_MissingEndSet;
    public static ERRID ERR_InvInsideEndsProperty;
    public static ERRID ERR_DuplicateWriteabilityCategoryUsed;
    public static ERRID ERR_ExpectedGreater;
    public static ERRID ERR_AttributeStmtWrongOrder;
    public static ERRID ERR_NoExplicitArraySizes;
    public static ERRID ERR_BadPropertyFlags1;
    public static ERRID ERR_InvalidOptionExplicit;
    public static ERRID ERR_MultipleParameterSpecifiers;
    public static ERRID ERR_MultipleOptionalParameterSpecifiers;
    public static ERRID ERR_UnsupportedProperty1;
    public static ERRID ERR_InvalidOptionalParameterUsage1;
    public static ERRID ERR_ReturnFromNonFunction;
    public static ERRID ERR_UnterminatedStringLiteral;
    public static ERRID ERR_UnsupportedType1;
    public static ERRID ERR_InvalidEnumBase;
    public static ERRID ERR_ByRefIllegal1;
    public static ERRID ERR_UnreferencedAssembly3;
    public static ERRID ERR_UnreferencedModule3;
    public static ERRID ERR_ReturnWithoutValue;
    public static ERRID ERR_UnsupportedField1;
    public static ERRID ERR_UnsupportedMethod1;
    public static ERRID ERR_NoNonIndexProperty1;
    public static ERRID ERR_BadAttributePropertyType1;
    public static ERRID ERR_LocalsCannotHaveAttributes;
    public static ERRID ERR_PropertyOrFieldNotDefined1;
    public static ERRID ERR_InvalidAttributeUsage2;
    public static ERRID ERR_InvalidMultipleAttributeUsage1;
    public static ERRID ERR_CantThrowNonException;
    public static ERRID ERR_MustBeInCatchToRethrow;
    public static ERRID ERR_ParamArrayMustBeByVal;
    public static ERRID ERR_UseOfObsoleteSymbol2;
    public static ERRID ERR_RedimNoSizes;
    public static ERRID ERR_InitWithMultipleDeclarators;
    public static ERRID ERR_InitWithExplicitArraySizes;
    public static ERRID ERR_EndSyncLockNoSyncLock;
    public static ERRID ERR_ExpectedEndSyncLock;
    public static ERRID ERR_NameNotEvent2;
    public static ERRID ERR_AddOrRemoveHandlerEvent;
    public static ERRID ERR_UnrecognizedEnd;
    public static ERRID ERR_ArrayInitForNonArray2;
    public static ERRID ERR_EndRegionNoRegion;
    public static ERRID ERR_ExpectedEndRegion;
    public static ERRID ERR_InheritsStmtWrongOrder;
    public static ERRID ERR_AmbiguousAcrossInterfaces3;
    public static ERRID ERR_DefaultPropertyAmbiguousAcrossInterfaces4;
    public static ERRID ERR_InterfaceEventCantUse1;
    public static ERRID ERR_ExecutableAsDeclaration;
    public static ERRID ERR_StructureNoDefault1;
    public static ERRID ERR_MustShadow2;
    public static ERRID ERR_OverrideWithOptionalTypes2;
    public static ERRID ERR_ExpectedEndOfExpression;
    public static ERRID ERR_StructsCannotHandleEvents;
    public static ERRID ERR_OverridesImpliesOverridable;
    public static ERRID ERR_LocalNamedSameAsParam1;
    public static ERRID ERR_ModuleCantUseTypeSpecifier1;
    public static ERRID ERR_InValidSubMainsFound1;
    public static ERRID ERR_MoreThanOneValidMainWasFound2;
    public static ERRID ERR_CannotConvertValue2;
    public static ERRID ERR_OnErrorInSyncLock;
    public static ERRID ERR_NarrowingConversionCollection2;
    public static ERRID ERR_GotoIntoTryHandler;
    public static ERRID ERR_GotoIntoSyncLock;
    public static ERRID ERR_GotoIntoWith;
    public static ERRID ERR_GotoIntoFor;
    public static ERRID ERR_BadAttributeNonPublicConstructor;
    public static ERRID ERR_DefaultEventNotFound1;
    public static ERRID ERR_InvalidNonSerializedUsage;
    public static ERRID ERR_ExpectedContinueKind;
    public static ERRID ERR_ContinueDoNotWithinDo;
    public static ERRID ERR_ContinueForNotWithinFor;
    public static ERRID ERR_ContinueWhileNotWithinWhile;
    public static ERRID ERR_DuplicateParameterSpecifier;
    public static ERRID ERR_ModuleCantUseDLLDeclareSpecifier1;
    public static ERRID ERR_StructCantUseDLLDeclareSpecifier1;
    public static ERRID ERR_TryCastOfValueType1;
    public static ERRID ERR_TryCastOfUnconstrainedTypeParam1;
    public static ERRID ERR_AmbiguousDelegateBinding2;
    public static ERRID ERR_SharedStructMemberCannotSpecifyNew;
    public static ERRID ERR_GenericSubMainsFound1;
    public static ERRID ERR_GeneralProjectImportsError3;
    public static ERRID ERR_InvalidTypeForAliasesImport2;
    public static ERRID ERR_UnsupportedConstant2;
    public static ERRID ERR_ObsoleteArgumentsNeedParens;
    public static ERRID ERR_ObsoleteLineNumbersAreLabels;
    public static ERRID ERR_ObsoleteStructureNotType;
    public static ERRID ERR_ObsoleteObjectNotVariant;
    public static ERRID ERR_ObsoleteLetSetNotNeeded;
    public static ERRID ERR_ObsoletePropertyGetLetSet;
    public static ERRID ERR_ObsoleteWhileWend;
    public static ERRID ERR_ObsoleteRedimAs;
    public static ERRID ERR_ObsoleteOptionalWithoutValue;
    public static ERRID ERR_ObsoleteGosub;
    public static ERRID ERR_ObsoleteOnGotoGosub;
    public static ERRID ERR_ObsoleteEndIf;
    public static ERRID ERR_ObsoleteExponent;
    public static ERRID ERR_ObsoleteAsAny;
    public static ERRID ERR_ObsoleteGetStatement;
    public static ERRID ERR_OverrideWithArrayVsParamArray2;
    public static ERRID ERR_CircularBaseDependencies4;
    public static ERRID ERR_NestedBase2;
    public static ERRID ERR_AccessMismatchOutsideAssembly4;
    public static ERRID ERR_InheritanceAccessMismatchOutside3;
    public static ERRID ERR_UseOfObsoletePropertyAccessor3;
    public static ERRID ERR_UseOfObsoletePropertyAccessor2;
    public static ERRID ERR_AccessMismatchImplementedEvent6;
    public static ERRID ERR_AccessMismatchImplementedEvent4;
    public static ERRID ERR_InheritanceCycleInImportedType1;
    public static ERRID ERR_NoNonObsoleteConstructorOnBase3;
    public static ERRID ERR_NoNonObsoleteConstructorOnBase4;
    public static ERRID ERR_RequiredNonObsoleteNewCall3;
    public static ERRID ERR_RequiredNonObsoleteNewCall4;
    public static ERRID ERR_InheritsTypeArgAccessMismatch7;
    public static ERRID ERR_InheritsTypeArgAccessMismatchOutside5;
    public static ERRID ERR_PartialTypeAccessMismatch3;
    public static ERRID ERR_PartialTypeBadMustInherit1;
    public static ERRID ERR_MustOverOnNotInheritPartClsMem1;
    public static ERRID ERR_BaseMismatchForPartialClass3;
    public static ERRID ERR_PartialTypeTypeParamNameMismatch3;
    public static ERRID ERR_PartialTypeConstraintMismatch1;
    public static ERRID ERR_LateBoundOverloadInterfaceCall1;
    public static ERRID ERR_RequiredAttributeConstConversion2;
    public static ERRID ERR_AmbiguousOverrides3;
    public static ERRID ERR_OverriddenCandidate1;
    public static ERRID ERR_AmbiguousImplements3;
    public static ERRID ERR_AddressOfNotCreatableDelegate1;
    public static ERRID ERR_ComClassGenericMethod;
    public static ERRID ERR_SyntaxInCastOp;
    public static ERRID ERR_ArrayInitializerForNonConstDim;
    public static ERRID ERR_DelegateBindingFailure3;
    public static ERRID ERR_StructLayoutAttributeNotAllowed;
    public static ERRID ERR_IterationVariableShadowLocal1;
    public static ERRID ERR_InvalidOptionInfer;
    public static ERRID ERR_CircularInference1;
    public static ERRID ERR_InAccessibleOverridingMethod5;
    public static ERRID ERR_NoSuitableWidestType1;
    public static ERRID ERR_AmbiguousWidestType3;
    public static ERRID ERR_ExpectedAssignmentOperatorInInit;
    public static ERRID ERR_ExpectedQualifiedNameInInit;
    public static ERRID ERR_ExpectedLbrace;
    public static ERRID ERR_UnrecognizedTypeOrWith;
    public static ERRID ERR_DuplicateAggrMemberInit1;
    public static ERRID ERR_NonFieldPropertyAggrMemberInit1;
    public static ERRID ERR_SharedMemberAggrMemberInit1;
    public static ERRID ERR_ParameterizedPropertyInAggrInit1;
    public static ERRID ERR_NoZeroCountArgumentInitCandidates1;
    public static ERRID ERR_AggrInitInvalidForObject;
    public static ERRID ERR_InitializerExpected;
    public static ERRID ERR_LineContWithCommentOrNoPrecSpace;
    public static ERRID ERR_InvInsideEnum;
    public static ERRID ERR_InvInsideBlock;
    public static ERRID ERR_UnexpectedExpressionStatement;
    public static ERRID ERR_WinRTEventWithoutDelegate;
    public static ERRID ERR_SecurityCriticalAsyncInClassOrStruct;
    public static ERRID ERR_SecurityCriticalAsync;
    public static ERRID ERR_BadModuleFile1;
    public static ERRID ERR_BadRefLib1;
    public static ERRID ERR_EventHandlerSignatureIncompatible2;
    public static ERRID ERR_ProjectCCError1;
    public static ERRID ERR_InterfaceImplementedTwice1;
    public static ERRID ERR_InterfaceNotImplemented1;
    public static ERRID ERR_AmbiguousImplementsMember3;
    public static ERRID ERR_ImplementsOnNew;
    public static ERRID ERR_ArrayInitInStruct;
    public static ERRID ERR_EventTypeNotDelegate;
    public static ERRID ERR_ProtectedTypeOutsideClass;
    public static ERRID ERR_DefaultPropertyWithNoParams;
    public static ERRID ERR_InitializerInStruct;
    public static ERRID ERR_DuplicateImport1;
    public static ERRID ERR_BadModuleFlags1;
    public static ERRID ERR_ImplementsStmtWrongOrder;
    public static ERRID ERR_MemberConflictWithSynth4;
    public static ERRID ERR_SynthMemberClashesWithSynth7;
    public static ERRID ERR_SynthMemberClashesWithMember5;
    public static ERRID ERR_MemberClashesWithSynth6;
    public static ERRID ERR_SetHasOnlyOneParam;
    public static ERRID ERR_SetValueNotPropertyType;
    public static ERRID ERR_SetHasToBeByVal1;
    public static ERRID ERR_StructureCantUseProtected;
    public static ERRID ERR_BadInterfaceDelegateSpecifier1;
    public static ERRID ERR_BadInterfaceEnumSpecifier1;
    public static ERRID ERR_BadInterfaceClassSpecifier1;
    public static ERRID ERR_BadInterfaceStructSpecifier1;
    public static ERRID ERR_UseOfObsoleteSymbolNoMessage1;
    public static ERRID ERR_MetaDataIsNotAssembly;
    public static ERRID ERR_MetaDataIsNotModule;
    public static ERRID ERR_ReferenceComparison3;
    public static ERRID ERR_CatchVariableNotLocal1;
    public static ERRID ERR_ModuleMemberCantImplement;
    public static ERRID ERR_EventDelegatesCantBeFunctions;
    public static ERRID ERR_InvalidDate;
    public static ERRID ERR_CantOverride4;
    public static ERRID ERR_CantSpecifyArraysOnBoth;
    public static ERRID ERR_NotOverridableRequiresOverrides;
    public static ERRID ERR_PrivateTypeOutsideType;
    public static ERRID ERR_TypeRefResolutionError3;
    public static ERRID ERR_ParamArrayWrongType;
    public static ERRID ERR_CoClassMissing2;
    public static ERRID ERR_InvalidMeReference;
    public static ERRID ERR_InvalidImplicitMeReference;
    public static ERRID ERR_RuntimeMemberNotFound2;
    public static ERRID ERR_BadPropertyAccessorFlags;
    public static ERRID ERR_BadPropertyAccessorFlagsRestrict;
    public static ERRID ERR_OnlyOneAccessorForGetSet;
    public static ERRID ERR_NoAccessibleSet;
    public static ERRID ERR_NoAccessibleGet;
    public static ERRID ERR_WriteOnlyNoAccessorFlag;
    public static ERRID ERR_ReadOnlyNoAccessorFlag;
    public static ERRID ERR_BadPropertyAccessorFlags1;
    public static ERRID ERR_BadPropertyAccessorFlags2;
    public static ERRID ERR_BadPropertyAccessorFlags3;
    public static ERRID ERR_InAccessibleCoClass3;
    public static ERRID ERR_MissingValuesForArraysInApplAttrs;
    public static ERRID ERR_ExitEventMemberNotInvalid;
    public static ERRID ERR_InvInsideEndsEvent;
    public static ERRID ERR_MissingEndEvent;
    public static ERRID ERR_MissingEndAddHandler;
    public static ERRID ERR_MissingEndRemoveHandler;
    public static ERRID ERR_MissingEndRaiseEvent;
    public static ERRID ERR_CustomEventInvInInterface;
    public static ERRID ERR_CustomEventRequiresAs;
    public static ERRID ERR_InvalidEndEvent;
    public static ERRID ERR_InvalidEndAddHandler;
    public static ERRID ERR_InvalidEndRemoveHandler;
    public static ERRID ERR_InvalidEndRaiseEvent;
    public static ERRID ERR_DuplicateAddHandlerDef;
    public static ERRID ERR_DuplicateRemoveHandlerDef;
    public static ERRID ERR_DuplicateRaiseEventDef;
    public static ERRID ERR_MissingAddHandlerDef1;
    public static ERRID ERR_MissingRemoveHandlerDef1;
    public static ERRID ERR_MissingRaiseEventDef1;
    public static ERRID ERR_EventAddRemoveHasOnlyOneParam;
    public static ERRID ERR_EventAddRemoveByrefParamIllegal;
    public static ERRID ERR_SpecifiersInvOnEventMethod;
    public static ERRID ERR_AddRemoveParamNotEventType;
    public static ERRID ERR_RaiseEventShapeMismatch1;
    public static ERRID ERR_EventMethodOptionalParamIllegal1;
    public static ERRID ERR_CantReferToMyGroupInsideGroupType1;
    public static ERRID ERR_InvalidUseOfCustomModifier;
    public static ERRID ERR_InvalidOptionStrictCustom;
    public static ERRID ERR_ObsoleteInvalidOnEventMember;
    public static ERRID ERR_DelegateBindingIncompatible2;
    public static ERRID ERR_ExpectedXmlName;
    public static ERRID ERR_UndefinedXmlPrefix;
    public static ERRID ERR_DuplicateXmlAttribute;
    public static ERRID ERR_MismatchedXmlEndTag;
    public static ERRID ERR_MissingXmlEndTag;
    public static ERRID ERR_ReservedXmlPrefix;
    public static ERRID ERR_MissingVersionInXmlDecl;
    public static ERRID ERR_IllegalAttributeInXmlDecl;
    public static ERRID ERR_QuotedEmbeddedExpression;
    public static ERRID ERR_VersionMustBeFirstInXmlDecl;
    public static ERRID ERR_AttributeOrder;
    public static ERRID ERR_ExpectedXmlEndEmbedded;
    public static ERRID ERR_ExpectedXmlEndPI;
    public static ERRID ERR_ExpectedXmlEndComment;
    public static ERRID ERR_ExpectedXmlEndCData;
    public static ERRID ERR_ExpectedSQuote;
    public static ERRID ERR_ExpectedQuote;
    public static ERRID ERR_ExpectedLT;
    public static ERRID ERR_StartAttributeValue;
    public static ERRID ERR_ExpectedDiv;
    public static ERRID ERR_NoXmlAxesLateBinding;
    public static ERRID ERR_IllegalXmlStartNameChar;
    public static ERRID ERR_IllegalXmlNameChar;
    public static ERRID ERR_IllegalXmlCommentChar;
    public static ERRID ERR_EmbeddedExpression;
    public static ERRID ERR_ExpectedXmlWhiteSpace;
    public static ERRID ERR_IllegalProcessingInstructionName;
    public static ERRID ERR_DTDNotSupported;
    public static ERRID ERR_IllegalXmlWhiteSpace;
    public static ERRID ERR_ExpectedSColon;
    public static ERRID ERR_ExpectedXmlBeginEmbedded;
    public static ERRID ERR_XmlEntityReference;
    public static ERRID ERR_InvalidAttributeValue1;
    public static ERRID ERR_InvalidAttributeValue2;
    public static ERRID ERR_ReservedXmlNamespace;
    public static ERRID ERR_IllegalDefaultNamespace;
    public static ERRID ERR_QualifiedNameNotAllowed;
    public static ERRID ERR_ExpectedXmlns;
    public static ERRID ERR_IllegalXmlnsPrefix;
    public static ERRID ERR_XmlFeaturesNotAvailable;
    public static ERRID ERR_UnableToReadUacManifest2;
    public static ERRID ERR_TypeMismatchForXml3;
    public static ERRID ERR_BinaryOperandsForXml4;
    public static ERRID ERR_FullWidthAsXmlDelimiter;
    public static ERRID ERR_XmlEndCDataNotAllowedInContent;
    public static ERRID ERR_EventImplRemoveHandlerParamWrong;
    public static ERRID ERR_MixingWinRTAndNETEvents;
    public static ERRID ERR_AddParamWrongForWinRT;
    public static ERRID ERR_RemoveParamWrongForWinRT;
    public static ERRID ERR_ReImplementingWinRTInterface5;
    public static ERRID ERR_ReImplementingWinRTInterface4;
    public static ERRID ERR_XmlEndElementNoMatchingStart;
    public static ERRID ERR_UndefinedTypeOrNamespace1;
    public static ERRID ERR_BadInterfaceInterfaceSpecifier1;
    public static ERRID ERR_TypeClashesWithVbCoreType4;
    public static ERRID ERR_SecurityAttributeMissingAction;
    public static ERRID ERR_SecurityAttributeInvalidAction;
    public static ERRID ERR_SecurityAttributeInvalidActionAssembly;
    public static ERRID ERR_SecurityAttributeInvalidActionTypeOrMethod;
    public static ERRID ERR_PrincipalPermissionInvalidAction;
    public static ERRID ERR_PermissionSetAttributeInvalidFile;
    public static ERRID ERR_PermissionSetAttributeFileReadError;
    public static ERRID ERR_ExpectedWarningKeyword;
    public static ERRID ERR_InvalidSubsystemVersion;
    public static ERRID ERR_LibAnycpu32bitPreferredConflict;
    public static ERRID ERR_RestrictedAccess;
    public static ERRID ERR_RestrictedConversion1;
    public static ERRID ERR_NoTypecharInLabel;
    public static ERRID ERR_RestrictedType1;
    public static ERRID ERR_NoTypecharInAlias;
    public static ERRID ERR_NoAccessibleConstructorOnBase;
    public static ERRID ERR_BadStaticLocalInStruct;
    public static ERRID ERR_DuplicateLocalStatic1;
    public static ERRID ERR_ImportAliasConflictsWithType2;
    public static ERRID ERR_CantShadowAMustOverride1;
    public static ERRID ERR_MultipleEventImplMismatch3;
    public static ERRID ERR_BadSpecifierCombo2;
    public static ERRID ERR_MustBeOverloads2;
    public static ERRID ERR_MustOverridesInClass1;
    public static ERRID ERR_HandlesSyntaxInClass;
    public static ERRID ERR_SynthMemberShadowsMustOverride5;
    public static ERRID ERR_CannotOverrideInAccessibleMember;
    public static ERRID ERR_HandlesSyntaxInModule;
    public static ERRID ERR_IsNotOpRequiresReferenceTypes1;
    public static ERRID ERR_ClashWithReservedEnumMember1;
    public static ERRID ERR_MultiplyDefinedEnumMember2;
    public static ERRID ERR_BadUseOfVoid;
    public static ERRID ERR_EventImplMismatch5;
    public static ERRID ERR_ForwardedTypeUnavailable3;
    public static ERRID ERR_TypeFwdCycle2;
    public static ERRID ERR_BadTypeInCCExpression;
    public static ERRID ERR_BadCCExpression;
    public static ERRID ERR_VoidArrayDisallowed;
    public static ERRID ERR_MetadataMembersAmbiguous3;
    public static ERRID ERR_TypeOfExprAlwaysFalse2;
    public static ERRID ERR_OnlyPrivatePartialMethods1;
    public static ERRID ERR_PartialMethodsMustBePrivate;
    public static ERRID ERR_OnlyOnePartialMethodAllowed2;
    public static ERRID ERR_OnlyOneImplementingMethodAllowed3;
    public static ERRID ERR_PartialMethodMustBeEmpty;
    public static ERRID ERR_PartialMethodsMustBeSub1;
    public static ERRID ERR_PartialMethodGenericConstraints2;
    public static ERRID ERR_PartialDeclarationImplements1;
    public static ERRID ERR_NoPartialMethodInAddressOf1;
    public static ERRID ERR_ImplementationMustBePrivate2;
    public static ERRID ERR_PartialMethodParamNamesMustMatch3;
    public static ERRID ERR_PartialMethodTypeParamNameMismatch3;
    public static ERRID ERR_PropertyDoesntImplementAllAccessors;
    public static ERRID ERR_InvalidAttributeUsageOnAccessor;
    public static ERRID ERR_NestedTypeInInheritsClause2;
    public static ERRID ERR_TypeInItsInheritsClause1;
    public static ERRID ERR_BaseTypeReferences2;
    public static ERRID ERR_IllegalBaseTypeReferences3;
    public static ERRID ERR_InvalidCoClass1;
    public static ERRID ERR_InvalidOutputName;
    public static ERRID ERR_InvalidFileAlignment;
    public static ERRID ERR_InvalidDebugInformationFormat;
    public static ERRID ERR_ConstantStringTooLong;
    public static ERRID ERR_MustInheritEventNotOverridden;
    public static ERRID ERR_BadAttributeSharedProperty1;
    public static ERRID ERR_BadAttributeReadOnlyProperty1;
    public static ERRID ERR_DuplicateResourceName1;
    public static ERRID ERR_AttributeMustBeClassNotStruct1;
    public static ERRID ERR_AttributeMustInheritSysAttr;
    public static ERRID ERR_AttributeCannotBeAbstract;
    public static ERRID ERR_UnableToOpenResourceFile1;
    public static ERRID ERR_BadAttributeNonPublicProperty1;
    public static ERRID ERR_STAThreadAndMTAThread0;
    public static ERRID ERR_IndirectUnreferencedAssembly4;
    public static ERRID ERR_BadAttributeNonPublicType1;
    public static ERRID ERR_BadAttributeNonPublicContType2;
    public static ERRID ERR_BadMetaDataReference1;
    public static ERRID ERR_DllImportOnNonEmptySubOrFunction;
    public static ERRID ERR_DllImportNotLegalOnDeclare;
    public static ERRID ERR_DllImportNotLegalOnGetOrSet;
    public static ERRID ERR_DllImportOnGenericSubOrFunction;
    public static ERRID ERR_ComClassOnGeneric;
    public static ERRID ERR_DllImportOnInstanceMethod;
    public static ERRID ERR_DllImportOnInterfaceMethod;
    public static ERRID ERR_DllImportNotLegalOnEventMethod;
    public static ERRID ERR_FriendAssemblyBadArguments;
    public static ERRID ERR_FriendAssemblyStrongNameRequired;
    public static ERRID ERR_FriendAssemblyNameInvalid;
    public static ERRID ERR_FriendAssemblyBadAccessOverride2;
    public static ERRID ERR_AbsentReferenceToPIA1;
    public static ERRID ERR_CannotLinkClassWithNoPIA1;
    public static ERRID ERR_InvalidStructMemberNoPIA1;
    public static ERRID ERR_NoPIAAttributeMissing2;
    public static ERRID ERR_NestedGlobalNamespace;
    public static ERRID ERR_PIAHasNoAssemblyGuid1;
    public static ERRID ERR_DuplicateLocalTypes3;
    public static ERRID ERR_PIAHasNoTypeLibAttribute1;
    public static ERRID ERR_SourceInterfaceMustBeInterface;
    public static ERRID ERR_EventNoPIANoBackingMember;
    public static ERRID ERR_NestedInteropType;
    public static ERRID ERR_IsNestedIn2;
    public static ERRID ERR_LocalTypeNameClash2;
    public static ERRID ERR_InteropMethodWithBody1;
    public static ERRID ERR_UseOfLocalBeforeDeclaration1;
    public static ERRID ERR_UseOfKeywordFromModule1;
    public static ERRID ERR_BogusWithinLineIf;
    public static ERRID ERR_CharToIntegralTypeMismatch1;
    public static ERRID ERR_IntegralToCharTypeMismatch1;
    public static ERRID ERR_NoDirectDelegateConstruction1;
    public static ERRID ERR_MethodMustBeFirstStatementOnLine;
    public static ERRID ERR_AttrAssignmentNotFieldOrProp1;
    public static ERRID ERR_StrictDisallowsObjectComparison1;
    public static ERRID ERR_NoConstituentArraySizes;
    public static ERRID ERR_FileAttributeNotAssemblyOrModule;
    public static ERRID ERR_FunctionResultCannotBeIndexed1;
    public static ERRID ERR_ArgumentSyntax;
    public static ERRID ERR_ExpectedResumeOrGoto;
    public static ERRID ERR_ExpectedAssignmentOperator;
    public static ERRID ERR_NamedArgAlsoOmitted2;
    public static ERRID ERR_CannotCallEvent1;
    public static ERRID ERR_ForEachCollectionDesignPattern1;
    public static ERRID ERR_DefaultValueForNonOptionalParam;
    public static ERRID ERR_ExpectedDotAfterMyBase;
    public static ERRID ERR_ExpectedDotAfterMyClass;
    public static ERRID ERR_StrictArgumentCopyBackNarrowing3;
    public static ERRID ERR_LbElseifAfterElse;
    public static ERRID ERR_StandaloneAttribute;
    public static ERRID ERR_NoUniqueConstructorOnBase2;
    public static ERRID ERR_ExtraNextVariable;
    public static ERRID ERR_RequiredNewCallTooMany2;
    public static ERRID ERR_ForCtlVarArraySizesSpecified;
    public static ERRID ERR_BadFlagsOnNewOverloads;
    public static ERRID ERR_TypeCharOnGenericParam;
    public static ERRID ERR_TooFewGenericArguments1;
    public static ERRID ERR_TooManyGenericArguments1;
    public static ERRID ERR_GenericConstraintNotSatisfied2;
    public static ERRID ERR_TypeOrMemberNotGeneric1;
    public static ERRID ERR_NewIfNullOnGenericParam;
    public static ERRID ERR_MultipleClassConstraints1;
    public static ERRID ERR_ConstNotClassInterfaceOrTypeParam1;
    public static ERRID ERR_DuplicateTypeParamName1;
    public static ERRID ERR_UnboundTypeParam2;
    public static ERRID ERR_IsOperatorGenericParam1;
    public static ERRID ERR_ArgumentCopyBackNarrowing3;
    public static ERRID ERR_ShadowingGenericParamWithMember1;
    public static ERRID ERR_GenericParamBase2;
    public static ERRID ERR_ImplementsGenericParam;
    public static ERRID ERR_OnlyNullLowerBound;
    public static ERRID ERR_ClassConstraintNotInheritable1;
    public static ERRID ERR_ConstraintIsRestrictedType1;
    public static ERRID ERR_GenericParamsOnInvalidMember;
    public static ERRID ERR_GenericArgsOnAttributeSpecifier;
    public static ERRID ERR_AttrCannotBeGenerics;
    public static ERRID ERR_BadStaticLocalInGenericMethod;
    public static ERRID ERR_SyntMemberShadowsGenericParam3;
    public static ERRID ERR_ConstraintAlreadyExists1;
    public static ERRID ERR_InterfacePossiblyImplTwice2;
    public static ERRID ERR_ModulesCannotBeGeneric;
    public static ERRID ERR_GenericClassCannotInheritAttr;
    public static ERRID ERR_DeclaresCantBeInGeneric;
    public static ERRID ERR_OverrideWithConstraintMismatch2;
    public static ERRID ERR_ImplementsWithConstraintMismatch3;
    public static ERRID ERR_OpenTypeDisallowed;
    public static ERRID ERR_HandlesInvalidOnGenericMethod;
    public static ERRID ERR_MultipleNewConstraints;
    public static ERRID ERR_MustInheritForNewConstraint2;
    public static ERRID ERR_NoSuitableNewForNewConstraint2;
    public static ERRID ERR_BadGenericParamForNewConstraint2;
    public static ERRID ERR_NewArgsDisallowedForTypeParam;
    public static ERRID ERR_DuplicateRawGenericTypeImport1;
    public static ERRID ERR_NoTypeArgumentCountOverloadCand1;
    public static ERRID ERR_TypeArgsUnexpected;
    public static ERRID ERR_NameSameAsMethodTypeParam1;
    public static ERRID ERR_TypeParamNameFunctionNameCollision;
    public static ERRID ERR_BadConstraintSyntax;
    public static ERRID ERR_OfExpected;
    public static ERRID ERR_ArrayOfRawGenericInvalid;
    public static ERRID ERR_ForEachAmbiguousIEnumerable1;
    public static ERRID ERR_IsNotOperatorGenericParam1;
    public static ERRID ERR_TypeParamQualifierDisallowed;
    public static ERRID ERR_TypeParamMissingCommaOrRParen;
    public static ERRID ERR_TypeParamMissingAsCommaOrRParen;
    public static ERRID ERR_MultipleReferenceConstraints;
    public static ERRID ERR_MultipleValueConstraints;
    public static ERRID ERR_NewAndValueConstraintsCombined;
    public static ERRID ERR_RefAndValueConstraintsCombined;
    public static ERRID ERR_BadTypeArgForStructConstraint2;
    public static ERRID ERR_BadTypeArgForRefConstraint2;
    public static ERRID ERR_RefAndClassTypeConstrCombined;
    public static ERRID ERR_ValueAndClassTypeConstrCombined;
    public static ERRID ERR_ConstraintClashIndirectIndirect4;
    public static ERRID ERR_ConstraintClashDirectIndirect3;
    public static ERRID ERR_ConstraintClashIndirectDirect3;
    public static ERRID ERR_ConstraintCycleLink2;
    public static ERRID ERR_ConstraintCycle2;
    public static ERRID ERR_TypeParamWithStructConstAsConst;
    public static ERRID ERR_NullableDisallowedForStructConstr1;
    public static ERRID ERR_ConflictingDirectConstraints3;
    public static ERRID ERR_InterfaceUnifiesWithInterface2;
    public static ERRID ERR_BaseUnifiesWithInterfaces3;
    public static ERRID ERR_InterfaceBaseUnifiesWithBase4;
    public static ERRID ERR_InterfaceUnifiesWithBase3;
    public static ERRID ERR_OptionalsCantBeStructGenericParams;
    public static ERRID ERR_AddressOfNullableMethod;
    public static ERRID ERR_IsOperatorNullable1;
    public static ERRID ERR_IsNotOperatorNullable1;
    public static ERRID ERR_ClassInheritsBaseUnifiesWithInterfaces3;
    public static ERRID ERR_ClassInheritsInterfaceBaseUnifiesWithBase4;
    public static ERRID ERR_ClassInheritsInterfaceUnifiesWithBase3;
    public static ERRID ERR_ShadowingTypeOutsideClass1;
    public static ERRID ERR_PropertySetParamCollisionWithValue;
    public static ERRID ERR_SxSIndirectRefHigherThanDirectRef3;
    public static ERRID ERR_DuplicateReference2;
    public static ERRID ERR_DuplicateReferenceStrong;
    public static ERRID ERR_IllegalCallOrIndex;
    public static ERRID ERR_ConflictDefaultPropertyAttribute;
    public static ERRID ERR_BadAttributeUuid2;
    public static ERRID ERR_ComClassAndReservedAttribute1;
    public static ERRID ERR_ComClassRequiresPublicClass2;
    public static ERRID ERR_ComClassReservedDispIdZero1;
    public static ERRID ERR_ComClassReservedDispId1;
    public static ERRID ERR_ComClassDuplicateGuids1;
    public static ERRID ERR_ComClassCantBeAbstract0;
    public static ERRID ERR_ComClassRequiresPublicClass1;
    public static ERRID ERR_UnknownOperator;
    public static ERRID ERR_DuplicateConversionCategoryUsed;
    public static ERRID ERR_OperatorNotOverloadable;
    public static ERRID ERR_InvalidHandles;
    public static ERRID ERR_InvalidImplements;
    public static ERRID ERR_EndOperatorExpected;
    public static ERRID ERR_EndOperatorNotAtLineStart;
    public static ERRID ERR_InvalidEndOperator;
    public static ERRID ERR_ExitOperatorNotValid;
    public static ERRID ERR_ParamArrayIllegal1;
    public static ERRID ERR_OptionalIllegal1;
    public static ERRID ERR_OperatorMustBePublic;
    public static ERRID ERR_OperatorMustBeShared;
    public static ERRID ERR_BadOperatorFlags1;
    public static ERRID ERR_OneParameterRequired1;
    public static ERRID ERR_TwoParametersRequired1;
    public static ERRID ERR_OneOrTwoParametersRequired1;
    public static ERRID ERR_ConvMustBeWideningOrNarrowing;
    public static ERRID ERR_OperatorDeclaredInModule;
    public static ERRID ERR_InvalidSpecifierOnNonConversion1;
    public static ERRID ERR_UnaryParamMustBeContainingType1;
    public static ERRID ERR_BinaryParamMustBeContainingType1;
    public static ERRID ERR_ConvParamMustBeContainingType1;
    public static ERRID ERR_OperatorRequiresBoolReturnType1;
    public static ERRID ERR_ConversionToSameType;
    public static ERRID ERR_ConversionToInterfaceType;
    public static ERRID ERR_ConversionToBaseType;
    public static ERRID ERR_ConversionToDerivedType;
    public static ERRID ERR_ConversionToObject;
    public static ERRID ERR_ConversionFromInterfaceType;
    public static ERRID ERR_ConversionFromBaseType;
    public static ERRID ERR_ConversionFromDerivedType;
    public static ERRID ERR_ConversionFromObject;
    public static ERRID ERR_MatchingOperatorExpected2;
    public static ERRID ERR_UnacceptableLogicalOperator3;
    public static ERRID ERR_ConditionOperatorRequired3;
    public static ERRID ERR_CopyBackTypeMismatch3;
    public static ERRID ERR_ForLoopOperatorRequired2;
    public static ERRID ERR_UnacceptableForLoopOperator2;
    public static ERRID ERR_UnacceptableForLoopRelOperator2;
    public static ERRID ERR_OperatorRequiresIntegerParameter1;
    public static ERRID ERR_CantSpecifyNullableOnBoth;
    public static ERRID ERR_BadTypeArgForStructConstraintNull;
    public static ERRID ERR_CantSpecifyArrayAndNullableOnBoth;
    public static ERRID ERR_CantSpecifyTypeCharacterOnIIF;
    public static ERRID ERR_IllegalOperandInIIFCount;
    public static ERRID ERR_IllegalOperandInIIFName;
    public static ERRID ERR_IllegalOperandInIIFConversion;
    public static ERRID ERR_IllegalCondTypeInIIF;
    public static ERRID ERR_CantCallIIF;
    public static ERRID ERR_CantSpecifyAsNewAndNullable;
    public static ERRID ERR_IllegalOperandInIIFConversion2;
    public static ERRID ERR_BadNullTypeInCCExpression;
    public static ERRID ERR_NullableImplicit;
    public static ERRID ERR_MissingRuntimeHelper;
    public static ERRID ERR_DuplicateResourceFileName1;
    public static ERRID ERR_ExpectedDotAfterGlobalNameSpace;
    public static ERRID ERR_NoGlobalExpectedIdentifier;
    public static ERRID ERR_NoGlobalInHandles;
    public static ERRID ERR_ElseIfNoMatchingIf;
    public static ERRID ERR_BadAttributeConstructor2;
    public static ERRID ERR_EndUsingWithoutUsing;
    public static ERRID ERR_ExpectedEndUsing;
    public static ERRID ERR_GotoIntoUsing;
    public static ERRID ERR_UsingRequiresDisposePattern;
    public static ERRID ERR_UsingResourceVarNeedsInitializer;
    public static ERRID ERR_UsingResourceVarCantBeArray;
    public static ERRID ERR_OnErrorInUsing;
    public static ERRID ERR_PropertyNameConflictInMyCollection;
    public static ERRID ERR_InvalidImplicitVar;
    public static ERRID ERR_ObjectInitializerRequiresFieldName;
    public static ERRID ERR_ExpectedFrom;
    public static ERRID ERR_LambdaBindingMismatch1;
    public static ERRID ERR_CannotLiftByRefParamQuery1;
    public static ERRID ERR_ExpressionTreeNotSupported;
    public static ERRID ERR_CannotLiftStructureMeQuery;
    public static ERRID ERR_InferringNonArrayType1;
    public static ERRID ERR_ByRefParamInExpressionTree;
    public static ERRID ERR_DuplicateAnonTypeMemberName1;
    public static ERRID ERR_BadAnonymousTypeForExprTree;
    public static ERRID ERR_CannotLiftAnonymousType1;
    public static ERRID ERR_ExtensionOnlyAllowedOnModuleSubOrFunction;
    public static ERRID ERR_ExtensionMethodNotInModule;
    public static ERRID ERR_ExtensionMethodNoParams;
    public static ERRID ERR_ExtensionMethodOptionalFirstArg;
    public static ERRID ERR_ExtensionMethodParamArrayFirstArg;
    public static ERRID ERR_AnonymousTypeFieldNameInference;
    public static ERRID ERR_NameNotMemberOfAnonymousType2;
    public static ERRID ERR_ExtensionAttributeInvalid;
    public static ERRID ERR_AnonymousTypePropertyOutOfOrder1;
    public static ERRID ERR_AnonymousTypeDisallowsTypeChar;
    public static ERRID ERR_ExtensionMethodUncallable1;
    public static ERRID ERR_ExtensionMethodOverloadCandidate3;
    public static ERRID ERR_DelegateBindingMismatch;
    public static ERRID ERR_DelegateBindingTypeInferenceFails;
    public static ERRID ERR_TooManyArgs;
    public static ERRID ERR_NamedArgAlsoOmitted1;
    public static ERRID ERR_NamedArgUsedTwice1;
    public static ERRID ERR_NamedParamNotFound1;
    public static ERRID ERR_OmittedArgument1;
    public static ERRID ERR_UnboundTypeParam1;
    public static ERRID ERR_ExtensionMethodOverloadCandidate2;
    public static ERRID ERR_AnonymousTypeNeedField;
    public static ERRID ERR_AnonymousTypeNameWithoutPeriod;
    public static ERRID ERR_AnonymousTypeExpectedIdentifier;
    public static ERRID ERR_TooManyArgs2;
    public static ERRID ERR_NamedArgAlsoOmitted3;
    public static ERRID ERR_NamedArgUsedTwice3;
    public static ERRID ERR_NamedParamNotFound3;
    public static ERRID ERR_OmittedArgument3;
    public static ERRID ERR_UnboundTypeParam3;
    public static ERRID ERR_TooFewGenericArguments2;
    public static ERRID ERR_TooManyGenericArguments2;
    public static ERRID ERR_ExpectedInOrEq;
    public static ERRID ERR_ExpectedQueryableSource;
    public static ERRID ERR_QueryOperatorNotFound;
    public static ERRID ERR_CannotUseOnErrorGotoWithClosure;
    public static ERRID ERR_CannotGotoNonScopeBlocksWithClosure;
    public static ERRID ERR_CannotLiftRestrictedTypeQuery;
    public static ERRID ERR_QueryAnonymousTypeFieldNameInference;
    public static ERRID ERR_QueryDuplicateAnonTypeMemberName1;
    public static ERRID ERR_QueryAnonymousTypeDisallowsTypeChar;
    public static ERRID ERR_ReadOnlyInClosure;
    public static ERRID ERR_ExprTreeNoMultiDimArrayCreation;
    public static ERRID ERR_ExprTreeNoLateBind;
    public static ERRID ERR_ExpectedBy;
    public static ERRID ERR_QueryInvalidControlVariableName1;
    public static ERRID ERR_ExpectedIn;
    public static ERRID ERR_QueryNameNotDeclared;
    public static ERRID ERR_NestedFunctionArgumentNarrowing3;
    public static ERRID ERR_AnonTypeFieldXMLNameInference;
    public static ERRID ERR_QueryAnonTypeFieldXMLNameInference;
    public static ERRID ERR_ExpectedInto;
    public static ERRID ERR_TypeCharOnAggregation;
    public static ERRID ERR_ExpectedOn;
    public static ERRID ERR_ExpectedEquals;
    public static ERRID ERR_ExpectedAnd;
    public static ERRID ERR_EqualsTypeMismatch;
    public static ERRID ERR_EqualsOperandIsBad;
    public static ERRID ERR_LambdaNotDelegate1;
    public static ERRID ERR_LambdaNotCreatableDelegate1;
    public static ERRID ERR_CannotInferNullableForVariable1;
    public static ERRID ERR_NullableTypeInferenceNotSupported;
    public static ERRID ERR_ExpectedJoin;
    public static ERRID ERR_NullableParameterMustSpecifyType;
    public static ERRID ERR_IterationVariableShadowLocal2;
    public static ERRID ERR_LambdasCannotHaveAttributes;
    public static ERRID ERR_LambdaInSelectCaseExpr;
    public static ERRID ERR_AddressOfInSelectCaseExpr;
    public static ERRID ERR_NullableCharNotSupported;
    public static ERRID ERR_CannotLiftStructureMeLambda;
    public static ERRID ERR_CannotLiftByRefParamLambda1;
    public static ERRID ERR_CannotLiftRestrictedTypeLambda;
    public static ERRID ERR_LambdaParamShadowLocal1;
    public static ERRID ERR_StrictDisallowImplicitObjectLambda;
    public static ERRID ERR_CantSpecifyParamsOnLambdaParamNoType;
    public static ERRID ERR_TypeInferenceFailure1;
    public static ERRID ERR_TypeInferenceFailure2;
    public static ERRID ERR_TypeInferenceFailure3;
    public static ERRID ERR_TypeInferenceFailureNoExplicit1;
    public static ERRID ERR_TypeInferenceFailureNoExplicit2;
    public static ERRID ERR_TypeInferenceFailureNoExplicit3;
    public static ERRID ERR_TypeInferenceFailureAmbiguous1;
    public static ERRID ERR_TypeInferenceFailureAmbiguous2;
    public static ERRID ERR_TypeInferenceFailureAmbiguous3;
    public static ERRID ERR_TypeInferenceFailureNoExplicitAmbiguous1;
    public static ERRID ERR_TypeInferenceFailureNoExplicitAmbiguous2;
    public static ERRID ERR_TypeInferenceFailureNoExplicitAmbiguous3;
    public static ERRID ERR_TypeInferenceFailureNoBest1;
    public static ERRID ERR_TypeInferenceFailureNoBest2;
    public static ERRID ERR_TypeInferenceFailureNoBest3;
    public static ERRID ERR_TypeInferenceFailureNoExplicitNoBest1;
    public static ERRID ERR_TypeInferenceFailureNoExplicitNoBest2;
    public static ERRID ERR_TypeInferenceFailureNoExplicitNoBest3;
    public static ERRID ERR_DelegateBindingMismatchStrictOff2;
    public static ERRID ERR_InaccessibleReturnTypeOfMember2;
    public static ERRID ERR_LocalNamedSameAsParamInLambda1;
    public static ERRID ERR_MultilineLambdasCannotContainOnError;
    public static ERRID ERR_LambdaBindingMismatch2;
    public static ERRID ERR_MultilineLambdaShadowLocal1;
    public static ERRID ERR_StaticInLambda;
    public static ERRID ERR_MultilineLambdaMissingSub;
    public static ERRID ERR_MultilineLambdaMissingFunction;
    public static ERRID ERR_StatementLambdaInExpressionTree;
    public static ERRID ERR_AttributeOnLambdaReturnType;
    public static ERRID ERR_ExpectedIdentifierOrGroup;
    public static ERRID ERR_UnexpectedGroup;
    public static ERRID ERR_DelegateBindingMismatchStrictOff3;
    public static ERRID ERR_DelegateBindingIncompatible3;
    public static ERRID ERR_ArgumentNarrowing2;
    public static ERRID ERR_OverloadCandidate1;
    public static ERRID ERR_AutoPropertyInitializedInStructure;
    public static ERRID ERR_InitializedExpandedProperty;
    public static ERRID ERR_NewExpandedProperty;
    public static ERRID ERR_LanguageVersion;
    public static ERRID ERR_ArrayInitNoType;
    public static ERRID ERR_NotACollection1;
    public static ERRID ERR_NoAddMethod1;
    public static ERRID ERR_CantCombineInitializers;
    public static ERRID ERR_EmptyAggregateInitializer;
    public static ERRID ERR_VarianceDisallowedHere;
    public static ERRID ERR_VarianceInterfaceNesting;
    public static ERRID ERR_VarianceOutParamDisallowed1;
    public static ERRID ERR_VarianceInParamDisallowed1;
    public static ERRID ERR_VarianceOutParamDisallowedForGeneric3;
    public static ERRID ERR_VarianceInParamDisallowedForGeneric3;
    public static ERRID ERR_VarianceOutParamDisallowedHere2;
    public static ERRID ERR_VarianceInParamDisallowedHere2;
    public static ERRID ERR_VarianceOutParamDisallowedHereForGeneric4;
    public static ERRID ERR_VarianceInParamDisallowedHereForGeneric4;
    public static ERRID ERR_VarianceTypeDisallowed2;
    public static ERRID ERR_VarianceTypeDisallowedForGeneric4;
    public static ERRID ERR_LambdaTooManyTypesObjectDisallowed;
    public static ERRID ERR_VarianceTypeDisallowedHere3;
    public static ERRID ERR_VarianceTypeDisallowedHereForGeneric5;
    public static ERRID ERR_AmbiguousCastConversion2;
    public static ERRID ERR_VariancePreventsSynthesizedEvents2;
    public static ERRID ERR_NestingViolatesCLS1;
    public static ERRID ERR_VarianceOutNullableDisallowed2;
    public static ERRID ERR_VarianceInNullableDisallowed2;
    public static ERRID ERR_VarianceOutByValDisallowed1;
    public static ERRID ERR_VarianceInReturnDisallowed1;
    public static ERRID ERR_VarianceOutConstraintDisallowed1;
    public static ERRID ERR_VarianceInReadOnlyPropertyDisallowed1;
    public static ERRID ERR_VarianceOutWriteOnlyPropertyDisallowed1;
    public static ERRID ERR_VarianceOutPropertyDisallowed1;
    public static ERRID ERR_VarianceInPropertyDisallowed1;
    public static ERRID ERR_VarianceOutByRefDisallowed1;
    public static ERRID ERR_VarianceInByRefDisallowed1;
    public static ERRID ERR_LambdaNoType;
    public static ERRID ERR_VarianceConversionFailedOut6;
    public static ERRID ERR_VarianceConversionFailedIn6;
    public static ERRID ERR_VarianceIEnumerableSuggestion3;
    public static ERRID ERR_VarianceConversionFailedTryOut4;
    public static ERRID ERR_VarianceConversionFailedTryIn4;
    public static ERRID ERR_AutoPropertyCantHaveParams;
    public static ERRID ERR_IdentityDirectCastForFloat;
    public static ERRID ERR_TypeDisallowsElements;
    public static ERRID ERR_TypeDisallowsAttributes;
    public static ERRID ERR_TypeDisallowsDescendants;
    public static ERRID ERR_TypeOrMemberNotGeneric2;
    public static ERRID ERR_ExtensionMethodCannotBeLateBound;
    public static ERRID ERR_TypeInferenceArrayRankMismatch1;
    public static ERRID ERR_QueryStrictDisallowImplicitObject;
    public static ERRID ERR_IfNoType;
    public static ERRID ERR_IfNoTypeObjectDisallowed;
    public static ERRID ERR_IfTooManyTypesObjectDisallowed;
    public static ERRID ERR_ArrayInitNoTypeObjectDisallowed;
    public static ERRID ERR_ArrayInitTooManyTypesObjectDisallowed;
    public static ERRID ERR_LambdaNoTypeObjectDisallowed;
    public static ERRID ERR_OverloadsModifierInModule;
    public static ERRID ERR_SubRequiresSingleStatement;
    public static ERRID ERR_SubDisallowsStatement;
    public static ERRID ERR_SubRequiresParenthesesLParen;
    public static ERRID ERR_SubRequiresParenthesesDot;
    public static ERRID ERR_SubRequiresParenthesesBang;
    public static ERRID ERR_CannotEmbedInterfaceWithGeneric;
    public static ERRID ERR_CannotUseGenericTypeAcrossAssemblyBoundaries;
    public static ERRID ERR_CannotUseGenericBaseTypeAcrossAssemblyBoundaries;
    public static ERRID ERR_BadAsyncByRefParam;
    public static ERRID ERR_BadIteratorByRefParam;
    public static ERRID ERR_BadAsyncExpressionLambda;
    public static ERRID ERR_BadAsyncInQuery;
    public static ERRID ERR_BadGetAwaiterMethod1;
    public static ERRID ERR_RestrictedResumableType1;
    public static ERRID ERR_BadAwaitNothing;
    public static ERRID ERR_AsyncSubMain;
    public static ERRID ERR_PartialMethodsMustNotBeAsync1;
    public static ERRID ERR_InvalidAsyncIteratorModifiers;
    public static ERRID ERR_BadAwaitNotInAsyncMethodOrLambda;
    public static ERRID ERR_BadIteratorReturn;
    public static ERRID ERR_BadYieldInTryHandler;
    public static ERRID ERR_BadYieldInNonIteratorMethod;
    public static ERRID ERR_BadReturnValueInIterator;
    public static ERRID ERR_BadAwaitInTryHandler;
    public static ERRID ERR_BadAwaitObject;
    public static ERRID ERR_BadAsyncReturn;
    public static ERRID ERR_BadResumableAccessReturnVariable;
    public static ERRID ERR_BadIteratorExpressionLambda;
    public static ERRID ERR_ConstructorAsync;
    public static ERRID ERR_InvalidLambdaModifier;
    public static ERRID ERR_ReturnFromNonGenericTaskAsync;
    public static ERRID ERR_BadAutoPropertyFlags1;
    public static ERRID ERR_BadOverloadCandidates2;
    public static ERRID ERR_BadStaticInitializerInResumable;
    public static ERRID ERR_ResumablesCannotContainOnError;
    public static ERRID ERR_FriendRefNotEqualToThis;
    public static ERRID ERR_FriendRefSigningMismatch;
    public static ERRID ERR_FailureSigningAssembly;
    public static ERRID ERR_SignButNoPrivateKey;
    public static ERRID ERR_InvalidVersionFormat;
    public static ERRID ERR_ExpectedSingleScript;
    public static ERRID ERR_ReferenceDirectiveOnlyAllowedInScripts;
    public static ERRID ERR_NamespaceNotAllowedInScript;
    public static ERRID ERR_KeywordNotAllowedInScript;
    public static ERRID ERR_ReservedAssemblyName;
    public static ERRID ERR_ConstructorCannotBeDeclaredPartial;
    public static ERRID ERR_ModuleEmitFailure;
    public static ERRID ERR_ParameterNotValidForType;
    public static ERRID ERR_MarshalUnmanagedTypeNotValidForFields;
    public static ERRID ERR_MarshalUnmanagedTypeOnlyValidForFields;
    public static ERRID ERR_AttributeParameterRequired1;
    public static ERRID ERR_AttributeParameterRequired2;
    public static ERRID ERR_InvalidVersionFormat2;
    public static ERRID ERR_InvalidAssemblyCultureForExe;
    public static ERRID ERR_InvalidMultipleAttributeUsageInNetModule2;
    public static ERRID ERR_SecurityAttributeInvalidTarget;
    public static ERRID ERR_PublicKeyFileFailure;
    public static ERRID ERR_PublicKeyContainerFailure;
    public static ERRID ERR_InvalidAssemblyCulture;
    public static ERRID ERR_EncUpdateFailedMissingAttribute;
    public static ERRID ERR_CantAwaitAsyncSub1;
    public static ERRID ERR_ResumableLambdaInExpressionTree;
    public static ERRID ERR_DllImportOnResumableMethod;
    public static ERRID ERR_CannotLiftRestrictedTypeResumable1;
    public static ERRID ERR_BadIsCompletedOnCompletedGetResult2;
    public static ERRID ERR_SynchronizedAsyncMethod;
    public static ERRID ERR_BadAsyncReturnOperand1;
    public static ERRID ERR_DoesntImplementAwaitInterface2;
    public static ERRID ERR_BadAwaitInNonAsyncMethod;
    public static ERRID ERR_BadAwaitInNonAsyncVoidMethod;
    public static ERRID ERR_BadAwaitInNonAsyncLambda;
    public static ERRID ERR_LoopControlMustNotAwait;
    public static ERRID ERR_MyGroupCollectionAttributeCycle;
    public static ERRID ERR_LiteralExpected;
    public static ERRID ERR_PartialMethodDefaultParameterValueMismatch2;
    public static ERRID ERR_PartialMethodParamArrayMismatch2;
    public static ERRID ERR_NetModuleNameMismatch;
    public static ERRID ERR_BadCompilationOption;
    public static ERRID ERR_CmdOptionConflictsSource;
    public static ERRID ERR_InvalidSignaturePublicKey;
    public static ERRID ERR_CollisionWithPublicTypeInModule;
    public static ERRID ERR_ExportedTypeConflictsWithDeclaration;
    public static ERRID ERR_ExportedTypesConflict;
    public static ERRID ERR_AgnosticToMachineModule;
    public static ERRID ERR_ConflictingMachineModule;
    public static ERRID ERR_CryptoHashFailed;
    public static ERRID ERR_CantHaveWin32ResAndManifest;
    public static ERRID ERR_ForwardedTypeConflictsWithDeclaration;
    public static ERRID ERR_ForwardedTypeConflictsWithExportedType;
    public static ERRID ERR_ForwardedTypesConflict;
    public static ERRID ERR_TooLongMetadataName;
    public static ERRID ERR_MissingNetModuleReference;
    public static ERRID ERR_UnsupportedModule1;
    public static ERRID ERR_UnsupportedEvent1;
    public static ERRID ERR_NetModuleNameMustBeUnique;
    public static ERRID ERR_PDBWritingFailed;
    public static ERRID ERR_ParamDefaultValueDiffersFromAttribute;
    public static ERRID ERR_ResourceInModule;
    public static ERRID ERR_FieldHasMultipleDistinctConstantValues;
    public static ERRID ERR_AmbiguousInNamespaces2;
    public static ERRID ERR_EncNoPIAReference;
    public static ERRID ERR_LinkedNetmoduleMetadataMustProvideFullPEImage;
    public static ERRID ERR_CantReadRulesetFile;
    public static ERRID ERR_MetadataReferencesNotSupported;
    public static ERRID ERR_PlatformDoesntSupport;
    public static ERRID ERR_CantUseRequiredAttribute;
    public static ERRID ERR_EncodinglessSyntaxTree;
    public static ERRID ERR_InvalidFormatSpecifier;
    public static ERRID ERR_CannotBeMadeNullable1;
    public static ERRID ERR_BadConditionalWithRef;
    public static ERRID ERR_NullPropagatingOpInExpressionTree;
    public static ERRID ERR_TooLongOrComplexExpression;
    public static ERRID ERR_BadPdbData;
    public static ERRID ERR_AutoPropertyCantBeWriteOnly;
    public static ERRID ERR_ExpressionDoesntHaveName;
    public static ERRID ERR_InvalidNameOfSubExpression;
    public static ERRID ERR_MethodTypeArgsUnexpected;
    public static ERRID ERR_InReferencedAssembly;
    public static ERRID ERR_EncReferenceToAddedMember;
    public static ERRID ERR_InterpolationFormatWhitespace;
    public static ERRID ERR_InterpolationAlignmentOutOfRange;
    public static ERRID ERR_InterpolatedStringFactoryError;
    public static ERRID ERR_DebugEntryPointNotSourceMethodDefinition;
    public static ERRID ERR_InvalidPathMap;
    public static ERRID ERR_PublicSignNoKey;
    public static ERRID ERR_TooManyUserStrings;
    public static ERRID ERR_PeWritingFailure;
    public static ERRID ERR_OptionMustBeAbsolutePath;
    public static ERRID ERR_LastPlusOne;
    public static ERRID WRN_UseOfObsoleteSymbol2;
    public static ERRID WRN_MustOverloadBase4;
    public static ERRID WRN_OverrideType5;
    public static ERRID WRN_MustOverride2;
    public static ERRID WRN_DefaultnessShadowed4;
    public static ERRID WRN_UseOfObsoleteSymbolNoMessage1;
    public static ERRID WRN_AssemblyGeneration0;
    public static ERRID WRN_AssemblyGeneration1;
    public static ERRID WRN_ComClassNoMembers1;
    public static ERRID WRN_SynthMemberShadowsMember5;
    public static ERRID WRN_MemberShadowsSynthMember6;
    public static ERRID WRN_SynthMemberShadowsSynthMember7;
    public static ERRID WRN_UseOfObsoletePropertyAccessor3;
    public static ERRID WRN_UseOfObsoletePropertyAccessor2;
    public static ERRID WRN_FieldNotCLSCompliant1;
    public static ERRID WRN_BaseClassNotCLSCompliant2;
    public static ERRID WRN_ProcTypeNotCLSCompliant1;
    public static ERRID WRN_ParamNotCLSCompliant1;
    public static ERRID WRN_InheritedInterfaceNotCLSCompliant2;
    public static ERRID WRN_CLSMemberInNonCLSType3;
    public static ERRID WRN_NameNotCLSCompliant1;
    public static ERRID WRN_EnumUnderlyingTypeNotCLS1;
    public static ERRID WRN_NonCLSMemberInCLSInterface1;
    public static ERRID WRN_NonCLSMustOverrideInCLSType1;
    public static ERRID WRN_ArrayOverloadsNonCLS2;
    public static ERRID WRN_RootNamespaceNotCLSCompliant1;
    public static ERRID WRN_RootNamespaceNotCLSCompliant2;
    public static ERRID WRN_GenericConstraintNotCLSCompliant1;
    public static ERRID WRN_TypeNotCLSCompliant1;
    public static ERRID WRN_OptionalValueNotCLSCompliant1;
    public static ERRID WRN_CLSAttrInvalidOnGetSet;
    public static ERRID WRN_TypeConflictButMerged6;
    public static ERRID WRN_ShadowingGenericParamWithParam1;
    public static ERRID WRN_CannotFindStandardLibrary1;
    public static ERRID WRN_EventDelegateTypeNotCLSCompliant2;
    public static ERRID WRN_DebuggerHiddenIgnoredOnProperties;
    public static ERRID WRN_SelectCaseInvalidRange;
    public static ERRID WRN_CLSEventMethodInNonCLSType3;
    public static ERRID WRN_ExpectedInitComponentCall2;
    public static ERRID WRN_NamespaceCaseMismatch3;
    public static ERRID WRN_UndefinedOrEmptyNamespaceOrClass1;
    public static ERRID WRN_UndefinedOrEmptyProjectNamespaceOrClass1;
    public static ERRID WRN_IndirectRefToLinkedAssembly2;
    public static ERRID WRN_DelaySignButNoKey;
    public static ERRID WRN_UnimplementedCommandLineSwitch;
    public static ERRID WRN_NoNonObsoleteConstructorOnBase3;
    public static ERRID WRN_NoNonObsoleteConstructorOnBase4;
    public static ERRID WRN_RequiredNonObsoleteNewCall3;
    public static ERRID WRN_RequiredNonObsoleteNewCall4;
    public static ERRID WRN_MissingAsClauseinOperator;
    public static ERRID WRN_ConstraintsFailedForInferredArgs2;
    public static ERRID WRN_ConditionalNotValidOnFunction;
    public static ERRID WRN_UseSwitchInsteadOfAttribute;
    public static ERRID WRN_ReferencedAssemblyDoesNotHaveStrongName;
    public static ERRID WRN_RecursiveAddHandlerCall;
    public static ERRID WRN_ImplicitConversionCopyBack;
    public static ERRID WRN_MustShadowOnMultipleInheritance2;
    public static ERRID WRN_RecursiveOperatorCall;
    public static ERRID WRN_ImplicitConversionSubst1;
    public static ERRID WRN_LateBindingResolution;
    public static ERRID WRN_ObjectMath1;
    public static ERRID WRN_ObjectMath2;
    public static ERRID WRN_ObjectAssumedVar1;
    public static ERRID WRN_ObjectAssumed1;
    public static ERRID WRN_ObjectAssumedProperty1;
    public static ERRID WRN_UnusedLocal;
    public static ERRID WRN_SharedMemberThroughInstance;
    public static ERRID WRN_RecursivePropertyCall;
    public static ERRID WRN_OverlappingCatch;
    public static ERRID WRN_DefAsgUseNullRefByRef;
    public static ERRID WRN_DuplicateCatch;
    public static ERRID WRN_ObjectMath1Not;
    public static ERRID WRN_BadChecksumValExtChecksum;
    public static ERRID WRN_MultipleDeclFileExtChecksum;
    public static ERRID WRN_BadGUIDFormatExtChecksum;
    public static ERRID WRN_ObjectMathSelectCase;
    public static ERRID WRN_EqualToLiteralNothing;
    public static ERRID WRN_NotEqualToLiteralNothing;
    public static ERRID WRN_UnusedLocalConst;
    public static ERRID WRN_ComClassInterfaceShadows5;
    public static ERRID WRN_ComClassPropertySetObject1;
    public static ERRID WRN_DefAsgUseNullRef;
    public static ERRID WRN_DefAsgNoRetValFuncRef1;
    public static ERRID WRN_DefAsgNoRetValOpRef1;
    public static ERRID WRN_DefAsgNoRetValPropRef1;
    public static ERRID WRN_DefAsgUseNullRefByRefStr;
    public static ERRID WRN_DefAsgUseNullRefStr;
    public static ERRID WRN_StaticLocalNoInference;
    public static ERRID WRN_InvalidAssemblyName;
    public static ERRID WRN_XMLDocBadXMLLine;
    public static ERRID WRN_XMLDocMoreThanOneCommentBlock;
    public static ERRID WRN_XMLDocNotFirstOnLine;
    public static ERRID WRN_XMLDocInsideMethod;
    public static ERRID WRN_XMLDocParseError1;
    public static ERRID WRN_XMLDocDuplicateXMLNode1;
    public static ERRID WRN_XMLDocIllegalTagOnElement2;
    public static ERRID WRN_XMLDocBadParamTag2;
    public static ERRID WRN_XMLDocParamTagWithoutName;
    public static ERRID WRN_XMLDocCrefAttributeNotFound1;
    public static ERRID WRN_XMLMissingFileOrPathAttribute1;
    public static ERRID WRN_XMLCannotWriteToXMLDocFile2;
    public static ERRID WRN_XMLDocWithoutLanguageElement;
    public static ERRID WRN_XMLDocReturnsOnWriteOnlyProperty;
    public static ERRID WRN_XMLDocOnAPartialType;
    public static ERRID WRN_XMLDocReturnsOnADeclareSub;
    public static ERRID WRN_XMLDocStartTagWithNoEndTag;
    public static ERRID WRN_XMLDocBadGenericParamTag2;
    public static ERRID WRN_XMLDocGenericParamTagWithoutName;
    public static ERRID WRN_XMLDocExceptionTagWithoutCRef;
    public static ERRID WRN_XMLDocInvalidXMLFragment;
    public static ERRID WRN_XMLDocBadFormedXML;
    public static ERRID WRN_InterfaceConversion2;
    public static ERRID WRN_LiftControlVariableLambda;
    public static ERRID WRN_LambdaPassedToRemoveHandler;
    public static ERRID WRN_LiftControlVariableQuery;
    public static ERRID WRN_RelDelegatePassedToRemoveHandler;
    public static ERRID WRN_AmbiguousCastConversion2;
    public static ERRID WRN_VarianceDeclarationAmbiguous3;
    public static ERRID WRN_ArrayInitNoTypeObjectAssumed;
    public static ERRID WRN_TypeInferenceAssumed3;
    public static ERRID WRN_VarianceConversionFailedOut6;
    public static ERRID WRN_VarianceConversionFailedIn6;
    public static ERRID WRN_VarianceIEnumerableSuggestion3;
    public static ERRID WRN_VarianceConversionFailedTryOut4;
    public static ERRID WRN_VarianceConversionFailedTryIn4;
    public static ERRID WRN_IfNoTypeObjectAssumed;
    public static ERRID WRN_IfTooManyTypesObjectAssumed;
    public static ERRID WRN_ArrayInitTooManyTypesObjectAssumed;
    public static ERRID WRN_LambdaNoTypeObjectAssumed;
    public static ERRID WRN_LambdaTooManyTypesObjectAssumed;
    public static ERRID WRN_MissingAsClauseinVarDecl;
    public static ERRID WRN_MissingAsClauseinFunction;
    public static ERRID WRN_MissingAsClauseinProperty;
    public static ERRID WRN_ObsoleteIdentityDirectCastForValueType;
    public static ERRID WRN_ImplicitConversion2;
    public static ERRID WRN_MutableStructureInUsing;
    public static ERRID WRN_MutableGenericStructureInUsing;
    public static ERRID WRN_DefAsgNoRetValFuncVal1;
    public static ERRID WRN_DefAsgNoRetValOpVal1;
    public static ERRID WRN_DefAsgNoRetValPropVal1;
    public static ERRID WRN_AsyncLacksAwaits;
    public static ERRID WRN_AsyncSubCouldBeFunction;
    public static ERRID WRN_UnobservedAwaitableExpression;
    public static ERRID WRN_UnobservedAwaitableDelegate;
    public static ERRID WRN_PrefixAndXmlnsLocalName;
    public static ERRID WRN_UseValueForXmlExpression3;
    public static ERRID WRN_ReturnTypeAttributeOnWriteOnlyProperty;
    public static ERRID WRN_InvalidVersionFormat;
    public static ERRID WRN_MainIgnored;
    public static ERRID WRN_EmptyPrefixAndXmlnsLocalName;
    public static ERRID WRN_DefAsgNoRetValWinRtEventVal1;
    public static ERRID WRN_AssemblyAttributeFromModuleIsOverridden;
    public static ERRID WRN_RefCultureMismatch;
    public static ERRID WRN_ConflictingMachineAssembly;
    public static ERRID WRN_PdbLocalNameTooLong;
    public static ERRID WRN_PdbUsingNameTooLong;
    public static ERRID WRN_XMLDocCrefToTypeParameter;
    public static ERRID WRN_AnalyzerCannotBeCreated;
    public static ERRID WRN_NoAnalyzerInAssembly;
    public static ERRID WRN_UnableToLoadAnalyzer;
    public static ERRID ERRWRN_Last;
    public static ERRID HDN_UnusedImportClause;
    public static ERRID HDN_UnusedImportStatement;
    public static ERRID INF_UnableToLoadSomeTypesInAnalyzer;
    public static ERRID IDS_ProjectSettingsLocationName;
    public static ERRID IDS_FunctionReturnType;
    public static ERRID IDS_TheSystemCannotFindThePathSpecified;
    public static ERRID IDS_UnrecognizedFileFormat;
    public static ERRID IDS_MSG_ADDMODULE;
    public static ERRID IDS_MSG_ADDLINKREFERENCE;
    public static ERRID IDS_MSG_ADDREFERENCE;
    public static ERRID IDS_LogoLine1;
    public static ERRID IDS_LogoLine2;
    public static ERRID IDS_VBCHelp;
    public static ERRID IDS_InvalidPreprocessorConstantType;
    public static ERRID IDS_ToolName;
    public static ERRID FEATURE_AutoProperties;
    public static ERRID FEATURE_LineContinuation;
    public static ERRID FEATURE_StatementLambdas;
    public static ERRID FEATURE_CoContraVariance;
    public static ERRID FEATURE_CollectionInitializers;
    public static ERRID FEATURE_SubLambdas;
    public static ERRID FEATURE_ArrayLiterals;
    public static ERRID FEATURE_AsyncExpressions;
    public static ERRID FEATURE_Iterators;
    public static ERRID FEATURE_GlobalNamespace;
    public static ERRID FEATURE_NullPropagatingOperator;
    public static ERRID FEATURE_NameOfExpressions;
    public static ERRID FEATURE_ReadonlyAutoProperties;
    public static ERRID FEATURE_RegionsEverywhere;
    public static ERRID FEATURE_MultilineStringLiterals;
    public static ERRID FEATURE_CObjInAttributeArguments;
    public static ERRID FEATURE_LineContinuationComments;
    public static ERRID FEATURE_TypeOfIsNot;
    public static ERRID FEATURE_YearFirstDateLiterals;
    public static ERRID FEATURE_WarningDirectives;
    public static ERRID FEATURE_PartialModules;
    public static ERRID FEATURE_PartialInterfaces;
    public static ERRID FEATURE_ImplementingReadonlyOrWriteonlyPropertyWithReadwrite;
    public static ERRID FEATURE_IOperation;
}
internal class Microsoft.CodeAnalysis.VisualBasic.ErrorFactory : object {
    private static string s_titleSuffix;
    private static string s_descriptionSuffix;
    private static Lazy`1<ImmutableDictionary`2<ERRID, string>> s_helpLinksMap;
    private static Lazy`1<ImmutableDictionary`2<ERRID, string>> s_categoriesMap;
    public static DiagnosticInfo EmptyErrorInfo;
    public static DiagnosticInfo VoidDiagnosticInfo;
    public static Func`1<DiagnosticInfo> GetErrorInfo_ERR_WithEventsRequiresClass;
    public static Func`1<DiagnosticInfo> GetErrorInfo_ERR_StrictDisallowImplicitObject;
    public static Func`1<DiagnosticInfo> GetErrorInfo_WRN_ObjectAssumedVar1_WRN_StaticLocalNoInference;
    public static Func`1<DiagnosticInfo> GetErrorInfo_WRN_ObjectAssumedVar1_WRN_MissingAsClauseinVarDecl;
    public static Func`1<DiagnosticInfo> GetErrorInfo_ERR_StrictDisallowsImplicitProc;
    public static Func`1<DiagnosticInfo> GetErrorInfo_ERR_StrictDisallowsImplicitArgs;
    public static Func`1<DiagnosticInfo> GetErrorInfo_WRN_ObjectAssumed1_WRN_MissingAsClauseinFunction;
    public static Func`1<DiagnosticInfo> GetErrorInfo_WRN_ObjectAssumed1_WRN_MissingAsClauseinOperator;
    public static Func`1<DiagnosticInfo> GetErrorInfo_WRN_ObjectAssumedProperty1_WRN_MissingAsClauseinProperty;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    private static ErrorFactory();
    private static ImmutableDictionary`2<ERRID, string> CreateHelpLinks();
    private static ImmutableDictionary`2<ERRID, string> CreateCategoriesMap();
    public static DiagnosticInfo ErrorInfo(ERRID id);
    public static DiagnosticInfo ErrorInfo(ERRID id, Object[] arguments);
    public static DiagnosticInfo ErrorInfo(ERRID id, SyntaxToken& syntaxToken);
    public static DiagnosticInfo ErrorInfo(ERRID id, SyntaxKind& syntaxTokenKind);
    public static DiagnosticInfo ErrorInfo(ERRID id, SyntaxToken& syntaxToken, TypeSymbol type);
    public static DiagnosticInfo ErrorInfo(ERRID id, SyntaxToken& syntaxToken, TypeSymbol type1, TypeSymbol type2);
    internal static ResourceManager get_ResourceManager();
    internal static string IdToString(ERRID id);
    public static string IdToString(ERRID id, CultureInfo language);
    public static LocalizableResourceString GetMessageFormat(ERRID id);
    public static LocalizableResourceString GetTitle(ERRID id);
    public static LocalizableResourceString GetDescription(ERRID id);
    public static string GetHelpLink(ERRID id);
    public static string GetCategory(ERRID id);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ErrorFacts : object {
    public static bool IsWarning(ERRID code);
    public static bool IsFatal(ERRID code);
    public static bool IsInfo(ERRID code);
    public static bool IsHidden(ERRID code);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ErrorMessageHelpers : object {
    [ExtensionAttribute]
public static string ToDisplay(Accessibility access);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.ExecutableCodeBinder : Binder {
    private VisualBasicSyntaxNode _syntaxRoot;
    private DescendantBinderFactory _descendantBinderFactory;
    private MultiDictionary`2<string, SourceLabelSymbol> _labelsMap;
    private ImmutableArray`1<SourceLabelSymbol> _labels;
    private static MultiDictionary`2<string, SourceLabelSymbol> s_emptyLabelMap;
    internal ImmutableArray`1<SourceLabelSymbol> Labels { get; }
    private MultiDictionary`2<string, SourceLabelSymbol> LabelsMap { get; }
    public VisualBasicSyntaxNode Root { get; }
    public ImmutableDictionary`2<VisualBasicSyntaxNode, BlockBaseBinder> NodeToBinderMap { get; }
    internal ImmutableDictionary`2<SyntaxList`1<StatementSyntax>, BlockBaseBinder> StmtListToBinderMap { get; }
    private static ExecutableCodeBinder();
    public ExecutableCodeBinder(VisualBasicSyntaxNode root, Binder containingBinder);
    internal ImmutableArray`1<SourceLabelSymbol> get_Labels();
    private ImmutableArray`1<SourceLabelSymbol> BuildLabels();
    private MultiDictionary`2<string, SourceLabelSymbol> get_LabelsMap();
    private static MultiDictionary`2<string, SourceLabelSymbol> BuildLabelsMap(ImmutableArray`1<SourceLabelSymbol> labels);
    internal virtual LabelSymbol LookupLabelByNameToken(SyntaxToken labelName);
    internal virtual void LookupInSingleBinder(LookupResult lookupResult, string name, int arity, LookupOptions options, Binder originalBinder, HashSet`1& useSiteDiagnostics);
    internal virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
    public virtual Binder GetBinder(SyntaxList`1<StatementSyntax> stmtList);
    public virtual Binder GetBinder(VisualBasicSyntaxNode node);
    public VisualBasicSyntaxNode get_Root();
    public ImmutableDictionary`2<VisualBasicSyntaxNode, BlockBaseBinder> get_NodeToBinderMap();
    internal ImmutableDictionary`2<SyntaxList`1<StatementSyntax>, BlockBaseBinder> get_StmtListToBinderMap();
}
internal class Microsoft.CodeAnalysis.VisualBasic.ExitableStatementBinder : BlockBaseBinder {
    private LabelSymbol _continueLabel;
    private SyntaxKind _continueKind;
    private LabelSymbol _exitLabel;
    private SyntaxKind _exitKind;
    internal ImmutableArray`1<LocalSymbol> Locals { get; }
    public ExitableStatementBinder(Binder enclosing, SyntaxKind continueKind, SyntaxKind exitKind);
    internal virtual ImmutableArray`1<LocalSymbol> get_Locals();
    public virtual LabelSymbol GetContinueLabel(SyntaxKind continueSyntaxKind);
    public virtual LabelSymbol GetExitLabel(SyntaxKind exitSyntaxKind);
    public virtual LabelSymbol GetReturnLabel();
}
internal class Microsoft.CodeAnalysis.VisualBasic.ExitPointsWalker : AbstractRegionControlFlowPass {
    private ArrayBuilder`1<StatementSyntax> _branchesOutOf;
    private ArrayBuilder`1<LabelSymbol> _labelsInside;
    private ExitPointsWalker(FlowAnalysisInfo info, FlowAnalysisRegionInfo region);
    internal static IEnumerable`1<StatementSyntax> Analyze(FlowAnalysisInfo info, FlowAnalysisRegionInfo region);
    private bool Analyze();
    protected virtual void Free();
    public virtual BoundNode VisitLabelStatement(BoundLabelStatement node);
    public virtual BoundNode VisitDoLoopStatement(BoundDoLoopStatement node);
    public virtual BoundNode VisitForToStatement(BoundForToStatement node);
    public virtual BoundNode VisitForEachStatement(BoundForEachStatement node);
    public virtual BoundNode VisitWhileStatement(BoundWhileStatement node);
    public virtual BoundNode VisitSelectStatement(BoundSelectStatement node);
    protected virtual void LeaveRegion();
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Expression : object {
    internal static UnaryOperationKind DeriveUnaryOperationKind(UnaryOperatorKind operatorKind, BoundExpression operand);
    internal static BinaryOperationKind DeriveBinaryOperationKind(BinaryOperatorKind operatorKind, BoundExpression left);
}
internal class Microsoft.CodeAnalysis.VisualBasic.ExpressionLambdaRewriter : object {
    private Binder _binder;
    private SyntheticBoundNodeFactory _factory;
    private TypeSubstitution _typeMap;
    private NamedTypeSymbol _expressionType;
    private NamedTypeSymbol _int32Type;
    private NamedTypeSymbol _objectType;
    private NamedTypeSymbol _memberInfoType;
    private NamedTypeSymbol _memberBindingType;
    private NamedTypeSymbol _elementInitType;
    private Dictionary`2<ParameterSymbol, BoundExpression> _parameterMap;
    private int _recursionDepth;
    private static string s_coalesceLambdaParameterName;
    public NamedTypeSymbol ElementInitType { get; }
    public NamedTypeSymbol MemberBindingType { get; }
    public NamedTypeSymbol MemberInfoType { get; }
    public NamedTypeSymbol Int32Type { get; }
    public NamedTypeSymbol ObjectType { get; }
    private DiagnosticBag Diagnostics { get; }
    private ExpressionLambdaRewriter(MethodSymbol currentMethod, TypeCompilationState compilationState, TypeSubstitution typeMap, Binder binder, VisualBasicSyntaxNode node, int recursionDepth, DiagnosticBag diagnostics);
    public NamedTypeSymbol get_ElementInitType();
    public NamedTypeSymbol get_MemberBindingType();
    public NamedTypeSymbol get_MemberInfoType();
    public NamedTypeSymbol get_Int32Type();
    public NamedTypeSymbol get_ObjectType();
    internal static BoundExpression RewriteLambda(BoundLambda node, MethodSymbol currentMethod, NamedTypeSymbol delegateType, TypeCompilationState compilationState, TypeSubstitution typeMap, DiagnosticBag diagnostics, HashSet`1<BoundNode> rewrittenNodes, int recursionDepth);
    private DiagnosticBag get_Diagnostics();
    private BoundExpression TranslateLambdaBody(BoundBlock block);
    private BoundExpression GenerateDiagnosticAndReturnDummyExpression(ERRID code, BoundNode node, Object[] args);
    private BoundExpression Visit(BoundExpression node);
    private BoundExpression VisitExpressionWithoutStackGuard(BoundExpression node);
    private BoundExpression VisitInternal(BoundExpression node);
    private BoundExpression VisitExpressionWithStackGuard(BoundExpression node);
    private BoundExpression VisitLambdaInternal(BoundLambda node, NamedTypeSymbol delegateType);
    private BoundExpression VisitCall(BoundCall node);
    private BoundExpression VisitFieldAccess(BoundFieldAccess node);
    private BoundExpression VisitPropertyAccess(BoundPropertyAccess node);
    private BoundExpression VisitLambda(BoundLambda node);
    private BoundExpression VisitDelegateCreationExpression(BoundDelegateCreationExpression node);
    private BoundExpression VisitParameter(BoundParameter node);
    private BoundExpression VisitArrayAccess(BoundArrayAccess node);
    private BoundExpression BuildIndices(ImmutableArray`1<BoundExpression> expressions);
    private BoundExpression VisitBadExpression(BoundBadExpression node);
    private BoundExpression VisitObjectCreationExpression(BoundObjectCreationExpression node);
    private BoundExpression VisitNewT(BoundNewT node);
    private BoundExpression VisitObjectCreationContinued(BoundExpression creation, BoundExpression initializerOpt);
    private BoundExpression VisitObjectInitializer(BoundObjectInitializerExpression initializer);
    private BoundExpression VisitCollectionInitializer(BoundCollectionInitializerExpression initializer);
    private BoundExpression VisitObjectCreationExpressionInternal(BoundObjectCreationExpression node);
    private BoundExpression VisitSequence(BoundSequence node);
    private BoundExpression VisitArrayLength(BoundArrayLength node);
    private BoundExpression VisitArrayCreation(BoundArrayCreation node);
    private BoundExpression ConvertArgumentsIntoArray(ImmutableArray`1<BoundExpression> exprs);
    private BoundExpression VisitTypeOf(BoundTypeOf node);
    private BoundExpression Call(BoundExpression receiver, MethodSymbol method, BoundExpression[] params);
    private BoundExpression Default(TypeSymbol type);
    private BoundExpression New(SpecialMember helper, BoundExpression argument);
    private BoundExpression Negate(BoundExpression expr);
    private BoundExpression InitWithParameterlessValueTypeConstructor(TypeSymbol type);
    private bool IsIntegralType(TypeSymbol type);
    private TypeSymbol GetUnderlyingType(TypeSymbol type);
    private BoundExpression CreateLiteralExpression(BoundExpression node);
    private BoundExpression CreateLiteralExpression(BoundExpression node, TypeSymbol type);
    private BoundExpression ConvertRuntimeHelperToExpressionTree(string helperMethodName, BoundExpression[] arguments);
    private BoundExpression ConvertRuntimeHelperToExpressionTree(string helperMethodName, ImmutableArray`1<TypeSymbol> typeArgs, BoundExpression[] arguments);
    private BoundMethodGroup GetExprFactoryMethodGroup(string methodName, ImmutableArray`1<TypeSymbol> typeArgs);
    private BoundExpression VisitBinaryOperator(BoundBinaryOperator node);
    private BoundExpression VisitUserDefinedBinaryOperator(BoundUserDefinedBinaryOperator node);
    private BoundExpression VisitUserDefinedShortCircuitingOperator(BoundUserDefinedShortCircuitingOperator node);
    private BoundExpression ConvertUserDefinedLikeOrConcate(BoundUserDefinedBinaryOperator node);
    private BoundExpression ConvertBooleanOperator(BoundBinaryOperator node);
    private BoundExpression ConvertShortCircuitedBooleanOperator(BoundBinaryOperator node);
    private BoundExpression ConvertBinaryOperator(BoundBinaryOperator node);
    private BoundExpression GenerateCastsForBinaryAndUnaryOperator(BoundExpression loweredOperand, bool isNullable, TypeSymbol notNullableType, bool checked, bool needToCastBackToByteOrSByte);
    private BoundExpression MaskShiftCountOperand(BoundBinaryOperator node, TypeSymbol resultType, bool isChecked);
    private BoundExpression MaskShiftCountOperand(BoundExpression loweredOperand, TypeSymbol shiftedType, int shiftMask, ConstantValue shiftConst, bool isChecked);
    private MethodSymbol GetHelperForDecimalBinaryOperation(BinaryOperatorKind opKind);
    private MethodSymbol GetHelperForDateTimeBinaryOperation(BinaryOperatorKind opKind);
    private MethodSymbol GetHelperForObjectBinaryOperation(BinaryOperatorKind opKind);
    private string GetBinaryOperatorMethodName(BinaryOperatorKind opKind, bool isChecked);
    private BoundExpression AdjustCallArgumentForLiftedOperator(BoundExpression oldArg, TypeSymbol parameterType);
    private BoundExpression AdjustCallForLiftedOperator(BinaryOperatorKind opKind, BoundCall call, TypeSymbol resultType);
    private BoundExpression AdjustCallForLiftedOperator(UnaryOperatorKind opKind, BoundCall call, TypeSymbol resultType);
    private BoundExpression AdjustCallForLiftedOperator_DoNotCallDirectly(BoundCall call, TypeSymbol resultType);
    private BoundExpression VisitTernaryConditionalExpression(BoundTernaryConditionalExpression node);
    private BoundExpression VisitBinaryConditionalExpression(BoundBinaryConditionalExpression node);
    private ParameterSymbol CreateCoalesceLambdaParameterSymbol(TypeSymbol paramType);
    private BoundExpression CreateCoalesceLambdaParameter(ParameterSymbol paramSymbol);
    private BoundExpression BuildLambdaForCoalesceCall(TypeSymbol toType, ParameterSymbol lambdaParameter, BoundExpression body);
    private BoundExpression BuildLambdaBodyForCoalesce(BoundConversion conversion, TypeSymbol toType, ParameterSymbol lambdaParameter, bool isChecked);
    private BoundExpression CreateUserDefinedNullableToUnderlyingConversion(BoundExpression expression, TypeSymbol nullableType, bool isChecked);
    private BoundExpression ReplaceArgWithParameterInUserDefinedConversion(BoundConversion conversion, TypeSymbol toType, BoundExpression parameter, bool isChecked);
    private BoundExpression VisitConversion(BoundConversion node);
    private BoundExpression VisitDirectCast(BoundDirectCast node);
    private BoundExpression VisitTryCast(BoundTryCast node);
    private BoundExpression ConvertExpression(BoundExpression operand, ConversionKind conversion, TypeSymbol typeFrom, TypeSymbol typeTo, bool isChecked, bool explicitCastInCode, ConversionSemantics semantics);
    private BoundExpression ConvertLambda(BoundLambda node, TypeSymbol type);
    private BoundExpression CreateBuiltInConversion(TypeSymbol typeFrom, TypeSymbol typeTo, BoundExpression rewrittenOperand, bool isChecked, bool isExplicit, ConversionSemantics semantics, bool specialConversionForNullable);
    private TypeSymbol GetSignedVersionOfNumericType(TypeSymbol type);
    private BoundExpression ConvertUnderlyingToNullable(BoundExpression operand, TypeSymbol nullableType, bool isChecked);
    private BoundExpression ConvertNullableToUnderlying(BoundExpression operand, TypeSymbol nullableType, bool isChecked);
    private BoundExpression CreateUserDefinedConversion(BoundUserDefinedConversion node, TypeSymbol resultType, bool isLifted, bool isChecked);
    private BoundExpression CreateTypeAs(BoundExpression expr, TypeSymbol type);
    private BoundExpression CreateTypeAsIfNeeded(BoundExpression operand, TypeSymbol oldType, TypeSymbol newType);
    private BoundExpression Convert(BoundExpression expr, TypeSymbol type, bool isChecked);
    private BoundExpression Convert(BoundExpression expr, TypeSymbol type, MethodSymbol helper, bool isChecked);
    private BoundExpression ConvertIfNeeded(BoundExpression operand, TypeSymbol oldType, TypeSymbol newType, bool isChecked);
    private MethodSymbol GetConversionHelperMethod(SpecialType stFrom, SpecialType stTo);
    private BoundExpression VisitUnaryOperator(BoundUnaryOperator node);
    private BoundExpression VisitNullableIsTrueOperator(BoundNullableIsTrueOperator node);
    private BoundExpression BuildLambdaBodyForCoalesce(UnaryOperatorKind opKind, BoundCall call, TypeSymbol resultType, ParameterSymbol lambdaParameter);
    private BoundExpression VisitUserDefinedUnaryOperator(BoundUserDefinedUnaryOperator node);
    private BoundExpression RewriteUserDefinedOperator(BoundUserDefinedUnaryOperator node);
    private MethodSymbol GetHelperForDecimalUnaryOperation(UnaryOperatorKind opKind);
    private MethodSymbol GetHelperForObjectUnaryOperation(UnaryOperatorKind opKind);
    private string GetUnaryOperatorMethodName(UnaryOperatorKind opKind, bool isChecked);
}
internal class Microsoft.CodeAnalysis.VisualBasic.ExtensionMethodGroup : object {
    private Binder _lookupBinder;
    private LookupOptions _lookupOptions;
    private ImmutableArray`1<MethodSymbol> _lazyMethods;
    private HashSet`1<DiagnosticInfo> _lazyUseSiteDiagnostics;
    public ExtensionMethodGroup(Binder lookupBinder, LookupOptions lookupOptions);
    public ImmutableArray`1<MethodSymbol> LazyLookupAdditionalExtensionMethods(BoundMethodGroup group, HashSet`1& useSiteDiagnostics);
}
internal class Microsoft.CodeAnalysis.VisualBasic.FinallyBlockBinder : ExitableStatementBinder {
    public FinallyBlockBinder(Binder enclosing);
    public virtual LabelSymbol GetExitLabel(SyntaxKind exitSyntaxKind);
}
internal class Microsoft.CodeAnalysis.VisualBasic.FlowAnalysisInfo : ValueType {
    public VisualBasicCompilation Compilation;
    public Symbol Symbol;
    public BoundNode Node;
    public FlowAnalysisInfo(VisualBasicCompilation _compilation, Symbol _symbol, BoundNode _node);
}
internal class Microsoft.CodeAnalysis.VisualBasic.FlowAnalysisPass : object {
    public static void Analyze(MethodSymbol method, BoundBlock block, DiagnosticBag diagnostics);
    private static void Analyze(VisualBasicCompilation compilation, MethodSymbol method, BoundBlock block, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.VisualBasic.FlowAnalysisRegionInfo : ValueType {
    public BoundNode FirstInRegion;
    public BoundNode LastInRegion;
    public TextSpan Region;
    public FlowAnalysisRegionInfo(BoundNode _firstInRegion, BoundNode _lastInRegion, TextSpan _region);
}
internal class Microsoft.CodeAnalysis.VisualBasic.ForEachEnumeratorInfo : object {
    public BoundExpression GetEnumerator;
    public BoundExpression MoveNext;
    public BoundExpression Current;
    public bool NeedToDispose;
    public bool IsOrInheritsFromOrImplementsIDisposable;
    public BoundExpression DisposeCondition;
    public BoundExpression DisposeCast;
    public BoundExpression CurrentConversion;
    public BoundLValuePlaceholder EnumeratorPlaceholder;
    public BoundRValuePlaceholder CurrentPlaceholder;
    public BoundRValuePlaceholder CollectionPlaceholder;
    public ForEachEnumeratorInfo(BoundExpression getEnumerator, BoundExpression moveNext, BoundExpression current, bool needToDispose, bool isOrInheritsFromOrImplementsIDisposable, BoundExpression disposeCondition, BoundExpression disposeCast, BoundExpression currentConversion, BoundLValuePlaceholder enumeratorPlaceholder, BoundRValuePlaceholder currentPlaceholder, BoundRValuePlaceholder collectionPlaceholder);
}
public class Microsoft.CodeAnalysis.VisualBasic.ForEachStatementInfo : ValueType {
    [CompilerGeneratedAttribute]
private IMethodSymbol _GetEnumeratorMethod;
    [CompilerGeneratedAttribute]
private IMethodSymbol _MoveNextMethod;
    [CompilerGeneratedAttribute]
private IPropertySymbol _CurrentProperty;
    [CompilerGeneratedAttribute]
private IMethodSymbol _DisposeMethod;
    [CompilerGeneratedAttribute]
private ITypeSymbol _ElementType;
    [CompilerGeneratedAttribute]
private Conversion _ElementConversion;
    [CompilerGeneratedAttribute]
private Conversion _CurrentConversion;
    public IMethodSymbol GetEnumeratorMethod { get; }
    public IMethodSymbol MoveNextMethod { get; }
    public IPropertySymbol CurrentProperty { get; }
    public IMethodSymbol DisposeMethod { get; }
    public ITypeSymbol ElementType { get; }
    public Conversion ElementConversion { get; }
    public Conversion CurrentConversion { get; }
    internal ForEachStatementInfo(IMethodSymbol getEnumeratorMethod, IMethodSymbol moveNextMethod, IPropertySymbol currentProperty, IMethodSymbol disposeMethod, ITypeSymbol elementType, Conversion elementConversion, Conversion currentConversion);
    [CompilerGeneratedAttribute]
public IMethodSymbol get_GetEnumeratorMethod();
    [CompilerGeneratedAttribute]
public IMethodSymbol get_MoveNextMethod();
    [CompilerGeneratedAttribute]
public IPropertySymbol get_CurrentProperty();
    [CompilerGeneratedAttribute]
public IMethodSymbol get_DisposeMethod();
    [CompilerGeneratedAttribute]
public ITypeSymbol get_ElementType();
    [CompilerGeneratedAttribute]
public Conversion get_ElementConversion();
    [CompilerGeneratedAttribute]
public Conversion get_CurrentConversion();
}
internal class Microsoft.CodeAnalysis.VisualBasic.ForLoopVerification : object {
    public static void VerifyForLoops(BoundBlock block, DiagnosticBag diagnostics);
    internal static Symbol ReferencedSymbol(BoundExpression expression);
}
internal class Microsoft.CodeAnalysis.VisualBasic.ForOrForEachBlockBinder : ExitableStatementBinder {
    private ForOrForEachBlockSyntax _syntax;
    private ImmutableArray`1<LocalSymbol> _locals;
    internal ImmutableArray`1<LocalSymbol> Locals { get; }
    public ForOrForEachBlockBinder(Binder enclosing, ForOrForEachBlockSyntax syntax);
    internal virtual ImmutableArray`1<LocalSymbol> get_Locals();
    private ImmutableArray`1<LocalSymbol> BuildLocals();
    private LocalSymbol CreateLocalSymbol(SyntaxToken identifier);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.FunctionExtensions : object {
    [ExtensionAttribute]
public static HashSet`1<T> TransitiveClosure(Func`2<T, IEnumerable`1<T>> relation, T item);
}
[ExtensionAttribute]
[StandardModuleAttribute]
public class Microsoft.CodeAnalysis.VisualBasic.GeneratedExtensionSyntaxFacts : object {
    [ExtensionAttribute]
public static string GetText(SyntaxKind kind);
}
internal class Microsoft.CodeAnalysis.VisualBasic.GetTypeBinder : Binder {
    private Dictionary`2<GenericNameSyntax, bool> _allowedMap;
    private bool _isTypeExpressionOpen;
    internal bool IsTypeExpressionOpen { get; }
    internal GetTypeBinder(ExpressionSyntax typeExpression, Binder containingBinder);
    internal bool get_IsTypeExpressionOpen();
    public virtual bool IsUnboundTypeAllowed(GenericNameSyntax Syntax);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.VisualBasic.GlobalImport : object {
    private SyntaxReference _clause;
    private string _importedName;
    public ImportsClauseSyntax Clause { get; }
    internal bool IsXmlClause { get; }
    public string Name { get; }
    internal GlobalImport(ImportsClauseSyntax clause, string importedName);
    public ImportsClauseSyntax get_Clause();
    internal bool get_IsXmlClause();
    public string get_Name();
    public static GlobalImport Parse(string importedNames);
    public static GlobalImport Parse(string importedNames, ImmutableArray`1& diagnostics);
    public static IEnumerable`1<GlobalImport> Parse(IEnumerable`1<string> importedNames);
    public static IEnumerable`1<GlobalImport> Parse(String[] importedNames);
    public static IEnumerable`1<GlobalImport> Parse(IEnumerable`1<string> importedNames, ImmutableArray`1& diagnostics);
    internal Diagnostic MapDiagnostic(Diagnostic unmappedDiag);
    private string GetDebuggerDisplay();
    public virtual bool Equals(object obj);
    public sealed virtual override bool Equals(GlobalImport other);
    public virtual int GetHashCode();
    public static bool op_Equality(GlobalImport left, GlobalImport right);
    public static bool op_Inequality(GlobalImport left, GlobalImport right);
}
internal class Microsoft.CodeAnalysis.VisualBasic.GroupTypeInferenceLambda : BoundExpression {
    private Binder _Binder;
    private ImmutableArray`1<ParameterSymbol> _Parameters;
    private VisualBasicCompilation _Compilation;
    public Binder Binder { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public VisualBasicCompilation Compilation { get; }
    public GroupTypeInferenceLambda(VisualBasicSyntaxNode syntax, Binder binder, ImmutableArray`1<ParameterSymbol> parameters, VisualBasicCompilation compilation, bool hasErrors);
    public GroupTypeInferenceLambda(VisualBasicSyntaxNode syntax, Binder binder, ImmutableArray`1<ParameterSymbol> parameters, VisualBasicCompilation compilation);
    public Binder get_Binder();
    public ImmutableArray`1<ParameterSymbol> get_Parameters();
    public VisualBasicCompilation get_Compilation();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public GroupTypeInferenceLambda Update(Binder binder, ImmutableArray`1<ParameterSymbol> parameters, VisualBasicCompilation compilation);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public TypeSymbol InferLambdaReturnType(ImmutableArray`1<ParameterSymbol> delegateParams);
}
public class Microsoft.CodeAnalysis.VisualBasic.HandledEvent : object {
    private HandledEventKind _kind;
    private EventSymbol _eventSymbol;
    private PropertySymbol _WithEventsContainerOpt;
    private PropertySymbol _WithEventsSourcePropertyOpt;
    internal BoundExpression delegateCreation;
    internal MethodSymbol hookupMethod;
    public HandledEventKind HandlesKind { get; }
    public IEventSymbol EventSymbol { get; }
    public IPropertySymbol EventContainer { get; }
    public IPropertySymbol WithEventsSourceProperty { get; }
    internal HandledEvent(HandledEventKind kind, EventSymbol eventSymbol, PropertySymbol withEventsContainerOpt, PropertySymbol withEventsSourcePropertyOpt, BoundExpression delegateCreation, MethodSymbol hookupMethod);
    public HandledEventKind get_HandlesKind();
    public IEventSymbol get_EventSymbol();
    public IPropertySymbol get_EventContainer();
    public IPropertySymbol get_WithEventsSourceProperty();
}
public enum Microsoft.CodeAnalysis.VisualBasic.HandledEventKind : Enum {
    public int value__;
    public static HandledEventKind Me;
    public static HandledEventKind MyClass;
    public static HandledEventKind MyBase;
    public static HandledEventKind WithEvents;
}
internal interface Microsoft.CodeAnalysis.VisualBasic.IDiagnosticInfoWithSymbols {
    public abstract virtual void GetAssociatedSymbols(ArrayBuilder`1<Symbol> builder);
}
internal class Microsoft.CodeAnalysis.VisualBasic.IgnoreAccessibilityBinder : Binder {
    public IgnoreAccessibilityBinder(Binder containingBinder);
    internal virtual LookupOptions BinderSpecificLookupOptions(LookupOptions options);
    public virtual AccessCheckResult CheckAccessibility(Symbol sym, HashSet`1& useSiteDiagnostics, TypeSymbol accessThroughType, ConsList`1<Symbol> basesBeingResolved);
}
internal class Microsoft.CodeAnalysis.VisualBasic.IgnoreBaseClassesBinder : Binder {
    public IgnoreBaseClassesBinder(Binder containingBinder);
}
internal class Microsoft.CodeAnalysis.VisualBasic.ImplicitVariableBinder : Binder {
    private Symbol _containerOfLocals;
    private bool _frozen;
    private Dictionary`2<string, LocalSymbol> _implicitLocals;
    private MultiDictionary`2<string, ShadowedVariableInfo> _possiblyShadowingVariables;
    public bool AllImplicitVariableDeclarationsAreHandled { get; }
    public bool ImplicitVariableDeclarationAllowed { get; }
    public ImmutableArray`1<LocalSymbol> ImplicitlyDeclaredVariables { get; }
    public ImplicitVariableBinder(Binder containingBinder, Symbol containerOfLocals);
    internal virtual BoundExpression BindGroupAggregationExpression(GroupAggregationSyntax group, DiagnosticBag diagnostics);
    internal virtual BoundExpression BindFunctionAggregationExpression(FunctionAggregationSyntax function, DiagnosticBag diagnostics);
    public virtual void DisallowFurtherImplicitVariableDeclaration(DiagnosticBag diagnostics);
    public virtual bool get_AllImplicitVariableDeclarationsAreHandled();
    public virtual bool get_ImplicitVariableDeclarationAllowed();
    public virtual ImmutableArray`1<LocalSymbol> get_ImplicitlyDeclaredVariables();
    public virtual LocalSymbol DeclareImplicitLocalVariable(IdentifierNameSyntax nameSyntax, DiagnosticBag diagnostics);
    public void RememberPossibleShadowingVariable(string name, SyntaxNodeOrToken syntax, ERRID errorId);
    internal virtual void LookupInSingleBinder(LookupResult lookupResult, string name, int arity, LookupOptions options, Binder originalBinder, HashSet`1& useSiteDiagnostics);
    internal virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
}
internal class Microsoft.CodeAnalysis.VisualBasic.ImportAliasesBinder : Binder {
    private IReadOnlyDictionary`2<string, AliasAndImportsClausePosition> _importedAliases;
    public Symbol ContainingMember { get; }
    public ImportAliasesBinder(Binder containingBinder, IReadOnlyDictionary`2<string, AliasAndImportsClausePosition> importedAliases);
    internal virtual void LookupInSingleBinder(LookupResult lookupResult, string name, int arity, LookupOptions options, Binder originalBinder, HashSet`1& useSiteDiagnostics);
    internal virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
    public virtual Symbol get_ContainingMember();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.ImportData : object {
    public HashSet`1<NamespaceOrTypeSymbol> Members;
    public Dictionary`2<string, AliasAndImportsClausePosition> Aliases;
    public Dictionary`2<string, XmlNamespaceAndImportsClausePosition> XmlNamespaces;
    protected ImportData(HashSet`1<NamespaceOrTypeSymbol> members, Dictionary`2<string, AliasAndImportsClausePosition> aliases, Dictionary`2<string, XmlNamespaceAndImportsClausePosition> xmlNamespaces);
    public abstract virtual void AddMember(SyntaxReference syntaxRef, NamespaceOrTypeSymbol member, int importsClausePosition);
    public abstract virtual void AddAlias(SyntaxReference syntaxRef, string name, AliasSymbol alias, int importsClausePosition);
}
internal class Microsoft.CodeAnalysis.VisualBasic.ImportedTypesAndNamespacesMembersBinder : Binder {
    private ImmutableArray`1<NamespaceOrTypeAndImportsClausePosition> _importedSymbols;
    internal static Func`2<ImmutableArray`1<Symbol>, AmbiguousSymbolDiagnostic> GenerateAmbiguityError;
    private static ImportedTypesAndNamespacesMembersBinder();
    public ImportedTypesAndNamespacesMembersBinder(Binder containingBinder, ImmutableArray`1<NamespaceOrTypeAndImportsClausePosition> importedSymbols);
    internal virtual void LookupInSingleBinder(LookupResult lookupResult, string name, int arity, LookupOptions options, Binder originalBinder, HashSet`1& useSiteDiagnostics);
    protected virtual void CollectProbableExtensionMethodsInSingleBinder(string name, ArrayBuilder`1<MethodSymbol> methods, Binder originalBinder);
    protected virtual void AddExtensionMethodLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
    internal virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.VisualBasic.InferenceErrorReasons : Enum {
    public byte value__;
    public static InferenceErrorReasons Other;
    public static InferenceErrorReasons Ambiguous;
    public static InferenceErrorReasons NoBest;
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.InitializerRewriter : object {
    internal static BoundBlock BuildConstructorBody(TypeCompilationState compilationState, MethodSymbol constructorMethod, BoundStatement constructorInitializerOpt, ProcessedFieldOrPropertyInitializers processedInitializers, BoundBlock block);
    internal static BoundBlock BuildScriptInitializerBody(SynthesizedInteractiveInitializerMethod initializerMethod, ProcessedFieldOrPropertyInitializers processedInitializers, BoundBlock block);
    private static ImmutableArray`1<BoundStatement> RewriteInitializersAsStatements(SynthesizedInteractiveInitializerMethod method, ImmutableArray`1<BoundInitializer> boundInitializers);
    private static BoundStatement RewriteInitializerAsStatement(BoundInitializer initializer);
    internal static bool HasExplicitMeConstructorCall(BoundBlock block, TypeSymbol container, Boolean& isMyBaseConstructorCall);
}
internal class Microsoft.CodeAnalysis.VisualBasic.InitializerSemanticModel : MemberSemanticModel {
    private InitializerSemanticModel(VisualBasicSyntaxNode root, Binder binder, SyntaxTreeSemanticModel parentSemanticModelOpt, int speculatedPosition, bool ignoreAccessibility);
    internal static InitializerSemanticModel Create(DeclarationInitializerBinder binder, bool ignoreAccessibility);
    internal static InitializerSemanticModel CreateSpeculative(SyntaxTreeSemanticModel parentSemanticModel, EqualsValueSyntax root, Binder binder, int position);
    internal virtual BoundNode Bind(Binder binder, VisualBasicSyntaxNode node, DiagnosticBag diagnostics);
    private BoundNode BindInitializer(Binder binder, VisualBasicSyntaxNode initializer, DiagnosticBag diagnostics);
    internal virtual BoundNode GetBoundRoot();
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, EqualsValueSyntax initializer, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, ExecutableStatementSyntax statement, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelForMethodBodyCore(SyntaxTreeSemanticModel parentModel, int position, MethodBlockBaseSyntax body, SemanticModel& speculativeModel);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.InvalidModifiers : object {
    public static SyntaxKind[] InvalidModifiersInNotInheritableClass;
    public static SyntaxKind[] InvalidModifiersInNotInheritableOtherPartialClass;
    public static SyntaxKind[] InvalidModifiersInModule;
    public static SyntaxKind[] InvalidModifiersInInterface;
    public static SyntaxKind[] InvalidModifiersIfShared;
    public static SyntaxKind[] InvalidModifiersIfDefault;
    public static SyntaxKind[] InvalidAsyncIterator;
    private static InvalidModifiers();
}
internal class Microsoft.CodeAnalysis.VisualBasic.IteratorAndAsyncCaptureWalker : DataFlowPass {
    private OrderedSet`1<Symbol> _variablesToHoist;
    private Dictionary`2<LocalSymbol, BoundExpression> _byRefLocalsInitializers;
    private MultiDictionary`2<Symbol, VisualBasicSyntaxNode> _lazyDisallowedCaptures;
    protected bool IgnoreOutSemantics { get; }
    protected bool EnableBreakingFlowAnalysisFeatures { get; }
    protected bool ProcessCompilerGeneratedLocals { get; }
    public IteratorAndAsyncCaptureWalker(FlowAnalysisInfo info);
    public static Result Analyze(FlowAnalysisInfo info, DiagnosticBag diagnostics);
    private static bool HoistInDebugBuild(Symbol symbol, bool skipByRefLocals);
    protected virtual bool Scan();
    private void CaptureVariable(Symbol variable, VisualBasicSyntaxNode syntax);
    protected virtual void EnterParameter(ParameterSymbol parameter);
    protected virtual void ReportUnassigned(Symbol symbol, VisualBasicSyntaxNode node, ReadWriteContext<LocalState> rwContext, int slot, BoundFieldAccess boundFieldAccess);
    protected virtual LocalState UnreachableState();
    protected virtual bool get_IgnoreOutSemantics();
    protected virtual bool IsEmptyStructType(TypeSymbol type);
    protected virtual bool get_EnableBreakingFlowAnalysisFeatures();
    private void MarkLocalsUnassigned();
    public virtual BoundNode VisitAwaitOperator(BoundAwaitOperator node);
    public virtual BoundNode VisitSequence(BoundSequence node);
    protected virtual bool get_ProcessCompilerGeneratedLocals();
    public virtual BoundNode VisitReferenceAssignment(BoundReferenceAssignment node);
    public virtual BoundNode VisitYieldStatement(BoundYieldStatement node);
    protected virtual bool TreatTheLocalAsAssignedWithinTheLambda(LocalSymbol local, BoundExpression right);
}
internal class Microsoft.CodeAnalysis.VisualBasic.IteratorRewriter : StateMachineRewriter`1<FieldSymbol> {
    private TypeSymbol _elementType;
    private bool _isEnumerable;
    private FieldSymbol _currentField;
    private FieldSymbol _initialThreadIdField;
    protected bool PreserveInitialParameterValues { get; }
    internal TypeSubstitution TypeMap { get; }
    public IteratorRewriter(BoundStatement body, MethodSymbol method, bool isEnumerable, IteratorStateMachine stateMachineType, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics);
    internal static BoundBlock Rewrite(BoundBlock body, MethodSymbol method, int methodOrdinal, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics, IteratorStateMachine& stateMachineType);
    internal virtual bool EnsureAllSymbolsAndSignature();
    protected virtual void GenerateControlFields();
    protected virtual void GenerateMethodImplementations();
    protected virtual BoundStatement GenerateStateMachineCreation(LocalSymbol stateMachineVariable, NamedTypeSymbol frameType);
    protected virtual void InitializeStateMachine(ArrayBuilder`1<BoundStatement> bodyBuilder, NamedTypeSymbol frameType, LocalSymbol stateMachineLocal);
    protected virtual bool get_PreserveInitialParameterValues();
    internal virtual TypeSubstitution get_TypeMap();
    private void GenerateMoveNextAndDispose(SynthesizedMethod moveNextMethod, SynthesizedMethod disposeMethod);
    protected virtual FieldSymbol CreateByValLocalCapture(FieldSymbol field, LocalSymbol local);
    protected virtual FieldSymbol CreateParameterCapture(FieldSymbol field, ParameterSymbol parameter);
    protected virtual void InitializeParameterWithProxy(ParameterSymbol parameter, FieldSymbol proxy, LocalSymbol stateMachineVariable, ArrayBuilder`1<BoundExpression> initializers);
}
internal class Microsoft.CodeAnalysis.VisualBasic.IteratorStateMachine : StateMachineTypeSymbol {
    private SynthesizedSimpleConstructorSymbol _constructor;
    private MethodSymbol _iteratorMethod;
    public TypeKind TypeKind { get; }
    protected internal MethodSymbol Constructor { get; }
    protected internal IteratorStateMachine(VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, MethodSymbol iteratorMethod, int iteratorMethodOrdinal, TypeSymbol valueTypeSymbol, bool isEnumerable);
    private static ImmutableArray`1<NamedTypeSymbol> GetIteratorInterfaces(TypeSymbol elementType, bool isEnumerable, AssemblySymbol containingAssembly);
    public virtual TypeKind get_TypeKind();
    protected internal virtual MethodSymbol get_Constructor();
}
internal class Microsoft.CodeAnalysis.VisualBasic.LambdaBodyBinder : SubOrFunctionBodyBinder {
    private LocalSymbol _functionValue;
    public LambdaBodyBinder(LambdaSymbol lambdaSymbol, Binder containingBinder);
    private LocalSymbol CreateFunctionValueLocal(LambdaSymbol lambdaSymbol);
    public virtual LocalSymbol GetLocalForFunctionValue();
    public virtual LabelSymbol GetContinueLabel(SyntaxKind continueSyntaxKind);
    public virtual LabelSymbol GetExitLabel(SyntaxKind exitSyntaxKind);
    public virtual LabelSymbol GetReturnLabel();
    internal virtual void LookupInSingleBinder(LookupResult lookupResult, string name, int arity, LookupOptions options, Binder originalBinder, HashSet`1& useSiteDiagnostics);
}
internal class Microsoft.CodeAnalysis.VisualBasic.LambdaCapturedVariable : SynthesizedFieldSymbol {
    private bool _isMe;
    public bool IsShared { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsConst { get; }
    internal bool IsCapturedFrame { get; }
    internal LambdaCapturedVariable(LambdaFrame frame, Symbol captured, TypeSymbol type, string fieldName, bool isMeParameter);
    public static LambdaCapturedVariable Create(LambdaFrame frame, Symbol captured, Int32& uniqueId);
    public static string GetCapturedVariableFieldName(Symbol captured, Int32& uniqueId);
    public static TypeSymbol GetCapturedVariableFieldType(LambdaFrame frame, Symbol captured);
    public static bool IsMe(Symbol captured);
    public virtual bool get_IsShared();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool get_IsConst();
    internal virtual bool get_IsCapturedFrame();
}
internal class Microsoft.CodeAnalysis.VisualBasic.LambdaFrame : SynthesizedContainer {
    private ImmutableArray`1<TypeParameterSymbol> _typeParameters;
    private MethodSymbol _topLevelMethod;
    private MethodSymbol _sharedConstructor;
    private FieldSymbol _singletonCache;
    internal int ClosureOrdinal;
    internal ArrayBuilder`1<LambdaCapturedVariable> CapturedLocals;
    private SynthesizedLambdaConstructor _constructor;
    internal TypeSubstitution TypeMap;
    private VisualBasicSyntaxNode _scopeSyntaxOpt;
    private static Func`2<Symbol, TypeSubstitution> s_typeSubstitutionFactory;
    internal static Func`3<TypeParameterSymbol, Symbol, TypeParameterSymbol> CreateTypeParameter;
    public VisualBasicSyntaxNode ScopeSyntax { get; }
    public Accessibility DeclaredAccessibility { get; }
    protected internal MethodSymbol Constructor { get; }
    protected internal MethodSymbol SharedConstructor { get; }
    internal FieldSymbol SingletonCache { get; }
    internal bool IsSerializable { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public TypeKind TypeKind { get; }
    public int Arity { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    internal bool IsInterface { get; }
    public bool HasMethodBodyDependency { get; }
    public IMethodSymbol Method { get; }
    private static LambdaFrame();
    internal LambdaFrame(MethodSymbol topLevelMethod, VisualBasicSyntaxNode scopeSyntaxOpt, DebugId methodId, DebugId closureId, bool copyConstructor, bool isStatic, bool isDelegateRelaxationFrame);
    private static string MakeName(SyntaxNode scopeSyntaxOpt, DebugId methodId, DebugId closureId, bool isStatic, bool isDelegateRelaxation);
    [ConditionalAttribute("DEBUG")]
private static void AssertIsClosureScopeSyntax(VisualBasicSyntaxNode syntaxOpt);
    public VisualBasicSyntaxNode get_ScopeSyntax();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    public virtual ImmutableArray`1<Symbol> GetMembers();
    protected internal virtual MethodSymbol get_Constructor();
    protected internal MethodSymbol get_SharedConstructor();
    internal FieldSymbol get_SingletonCache();
    internal virtual bool get_IsSerializable();
    internal virtual IEnumerable`1<FieldSymbol> GetFieldsToEmit();
    internal virtual NamedTypeSymbol MakeAcyclicBaseType(DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<NamedTypeSymbol> MakeAcyclicInterfaces(DiagnosticBag diagnostics);
    internal virtual NamedTypeSymbol MakeDeclaredBase(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<NamedTypeSymbol> MakeDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual TypeKind get_TypeKind();
    public virtual int get_Arity();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal virtual bool get_IsInterface();
    public sealed virtual override bool get_HasMethodBodyDependency();
    public sealed virtual override IMethodSymbol get_Method();
}
internal class Microsoft.CodeAnalysis.VisualBasic.LambdaRewriter : MethodToClassRewriter`1<FieldSymbol> {
    private Analysis _analysis;
    private MethodSymbol _topLevelMethod;
    private int _topLevelMethodOrdinal;
    private LambdaFrame _lazyStaticLambdaFrame;
    private Dictionary`2<BoundNode, LambdaFrame> _frames;
    private Dictionary`2<NamedTypeSymbol, Symbol> _framePointers;
    private MethodSymbol _currentMethod;
    private ParameterSymbol _currentFrameThis;
    private ArrayBuilder`1<LambdaDebugInfo> _lambdaDebugInfoBuilder;
    private int _delegateRelaxationIdDispenser;
    private int _synthesizedFieldNameIdDispenser;
    private Symbol _innermostFramePointer;
    private TypeSubstitution _currentLambdaBodyTypeSubstitution;
    private ImmutableArray`1<TypeParameterSymbol> _currentTypeParameters;
    private BoundExpression _meProxyDeferredInit;
    private bool _meIsInitialized;
    private bool _meProxyDeferredInitDone;
    private bool _inExpressionLambda;
    private bool _reported_ERR_CannotUseOnErrorGotoWithClosure;
    private HashSet`1<BoundNode> _rewrittenNodes;
    protected MethodSymbol CurrentMethod { get; }
    protected MethodSymbol TopLevelMethod { get; }
    protected TypeSubstitution TypeMap { get; }
    protected bool IsInExpressionLambda { get; }
    private LambdaRewriter(Analysis analysis, MethodSymbol method, int methodOrdinal, ArrayBuilder`1<LambdaDebugInfo> lambdaDebugInfoBuilder, int delegateRelaxationIdDispenser, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics);
    public static BoundBlock Rewrite(BoundBlock node, MethodSymbol method, int methodOrdinal, ArrayBuilder`1<LambdaDebugInfo> lambdaDebugInfoBuilder, ArrayBuilder`1<ClosureDebugInfo> closureDebugInfoBuilder, Int32& delegateRelaxationIdDispenser, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState CompilationState, ISet`1<Symbol> symbolsCapturedWithoutCopyCtor, DiagnosticBag diagnostics, HashSet`1<BoundNode> rewrittenNodes);
    protected virtual MethodSymbol get_CurrentMethod();
    protected virtual MethodSymbol get_TopLevelMethod();
    protected virtual TypeSubstitution get_TypeMap();
    protected virtual bool get_IsInExpressionLambda();
    private void MakeFrames(ArrayBuilder`1<ClosureDebugInfo> closureDebugInfo);
    private LambdaFrame GetFrameForScope(bool copyConstructor, Symbol captured, BoundNode scope, ArrayBuilder`1<ClosureDebugInfo> closureDebugInfo, Int32& delegateRelaxationIdDispenser);
    private LambdaFrame GetStaticFrame(BoundNode lambda, DiagnosticBag diagnostics);
    private BoundExpression FrameOfType(VisualBasicSyntaxNode syntax, NamedTypeSymbol frameType);
    internal virtual BoundExpression FramePointer(VisualBasicSyntaxNode syntax, NamedTypeSymbol frameClass);
    protected virtual BoundNode MaterializeProxy(BoundExpression origExpression, FieldSymbol proxy);
    private BoundBlock MakeFrameCtor(LambdaFrame frame, DiagnosticBag diagnostics);
    internal static NamedTypeSymbol ConstructFrameType(LambdaFrame type, ImmutableArray`1<T> typeArguments);
    private BoundNode IntroduceFrame(BoundNode node, LambdaFrame frame, Func`3<ArrayBuilder`1<BoundExpression>, ArrayBuilder`1<LocalSymbol>, BoundNode> F, LambdaSymbol origLambda);
    private void InitVariableProxy(VisualBasicSyntaxNode syntaxNode, Symbol originalSymbol, LocalSymbol framePointer, NamedTypeSymbol frameType, ArrayBuilder`1<BoundExpression> prologue);
    public virtual BoundNode VisitMeReference(BoundMeReference node);
    public virtual BoundNode VisitMyClassReference(BoundMyClassReference node);
    public virtual BoundNode VisitMyBaseReference(BoundMyBaseReference node);
    public virtual BoundNode VisitRangeVariable(BoundRangeVariable node);
    private BoundStatement RewriteStatementList(BoundStatementList node, ArrayBuilder`1<BoundExpression> prologue, ArrayBuilder`1<LocalSymbol> newLocals);
    public virtual BoundNode VisitBlock(BoundBlock node);
    public virtual BoundNode VisitSequence(BoundSequence node);
    public virtual BoundNode VisitCatchBlock(BoundCatchBlock node);
    private BoundCatchBlock RewriteCatch(BoundCatchBlock node, ArrayBuilder`1<BoundExpression> prologue, ArrayBuilder`1<LocalSymbol> newLocals);
    public virtual BoundNode VisitStatementList(BoundStatementList node);
    public BoundBlock RewriteLambdaAsMethod(SynthesizedLambdaMethod method, BoundLambda lambda);
    public virtual BoundNode VisitTryCast(BoundTryCast node);
    public virtual BoundNode VisitDirectCast(BoundDirectCast node);
    public virtual BoundNode VisitConversion(BoundConversion conversion);
    private DebugId GetTopLevelMethodId();
    private DebugId GetClosureId(SyntaxNode syntax, ArrayBuilder`1<ClosureDebugInfo> closureDebugInfo);
    private DebugId GetLambdaId(SyntaxNode syntax, ClosureKind closureKind, int closureOrdinal);
    private BoundExpression RewriteLambda(BoundLambda node, TypeSymbol type, bool convertToExpressionTree);
    private bool InLoopOrLambda(SyntaxNode lambdaSyntax, SyntaxNode scopeSyntax);
    public virtual BoundNode VisitLambda(BoundLambda node);
    private BoundNode LowestCommonAncestor(BoundNode gotoBlock, BoundNode labelBlock);
    private bool IsLegalBranch(BoundNode gotoBlock, BoundNode labelBlock);
    public virtual BoundNode VisitGotoStatement(BoundGotoStatement node);
    public virtual BoundNode VisitCall(BoundCall node);
    public virtual BoundNode VisitLoweredConditionalAccess(BoundLoweredConditionalAccess node);
    private BoundCall OptimizeMethodCallForDelegateInvoke(BoundCall node, MethodSymbol method, BoundExpression receiver, ImmutableArray`1<BoundExpression> arguments);
}
internal class Microsoft.CodeAnalysis.VisualBasic.LambdaUtilities : object {
    public static bool IsLambda(SyntaxNode node);
    public static bool IsNotLambda(SyntaxNode node);
    public static SyntaxNode GetLambda(SyntaxNode lambdaBody);
    public static SyntaxNode GetCorrespondingLambdaBody(SyntaxNode oldBody, SyntaxNode newLambdaOrPeer);
    public static bool IsLambdaBody(SyntaxNode node);
    public static bool IsLambdaBodyStatementOrExpression(SyntaxNode node, SyntaxNode& lambdaBody);
    private static bool IsJoinClause(SyntaxNode node);
    internal static VisualBasicSyntaxNode GetLambdaExpressionLambdaBody(LambdaExpressionSyntax lambda);
    internal static VisualBasicSyntaxNode GetFromOrAggregateVariableLambdaBody(CollectionRangeVariableSyntax rangeVariable);
    internal static VisualBasicSyntaxNode GetOrderingLambdaBody(OrderingSyntax ordering);
    internal static VisualBasicSyntaxNode GetAggregationLambdaBody(FunctionAggregationSyntax aggregation);
    internal static VisualBasicSyntaxNode GetLetVariableLambdaBody(ExpressionRangeVariableSyntax rangeVariable);
    internal static VisualBasicSyntaxNode GetSelectLambdaBody(SelectClauseSyntax selectClause);
    internal static VisualBasicSyntaxNode GetAggregateLambdaBody(AggregateClauseSyntax aggregateClause);
    internal static VisualBasicSyntaxNode GetGroupByItemsLambdaBody(GroupByClauseSyntax groupByClause);
    internal static VisualBasicSyntaxNode GetGroupByKeysLambdaBody(GroupByClauseSyntax groupByClause);
    internal static VisualBasicSyntaxNode GetJoinLeftLambdaBody(JoinClauseSyntax joinClause);
    internal static VisualBasicSyntaxNode GetJoinRightLambdaBody(JoinClauseSyntax joinClause);
    private static SyntaxNode GetExpressionRangeVariableLambdaBody(ExpressionRangeVariableSyntax rangeVariable);
    public static bool TryGetLambdaBodies(SyntaxNode node, SyntaxNode& lambdaBody1, SyntaxNode& lambdaBody2);
    internal static IEnumerable`1<SyntaxNode> GetLambdaBodyExpressionsAndStatements(SyntaxNode lambdaBody);
    private static IEnumerable`1<SyntaxNode> GetAggregateLambdaBodyExpressions(AggregateClauseSyntax clause);
    private static void AddFirstJoinVariableRecursive(ArrayBuilder`1<SyntaxNode> result, JoinClauseSyntax joinClause);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.LambdaUtilities/VB$StateMachine_24_EnumerateExpressions")]
private static IEnumerable`1<SyntaxNode> EnumerateExpressions(SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> variables);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.LambdaUtilities/VB$StateMachine_25_EnumerateExpressions")]
private static IEnumerable`1<SyntaxNode> EnumerateExpressions(SeparatedSyntaxList`1<CollectionRangeVariableSyntax> variables);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.LambdaUtilities/VB$StateMachine_26_EnumerateJoinClauseLeftExpressions")]
private static IEnumerable`1<SyntaxNode> EnumerateJoinClauseLeftExpressions(JoinClauseSyntax clause);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.LambdaUtilities/VB$StateMachine_27_EnumerateJoinClauseRightExpressions")]
private static IEnumerable`1<SyntaxNode> EnumerateJoinClauseRightExpressions(JoinClauseSyntax clause);
    private static bool TryGetSimpleLambdaBody(SyntaxNode node, SyntaxNode& lambdaBody);
    internal static bool IsLambdaExpressionRangeVariable(SyntaxNode expressionRangeVariable);
    internal static bool IsLambdaCollectionRangeVariable(SyntaxNode collectionRangeVariable);
    private static bool IsQueryStartingClause(SyntaxNode clause);
    private static SeparatedSyntaxList`1<CollectionRangeVariableSyntax> GetCollectionRangeVariables(SyntaxNode clause);
    internal static bool IsLambdaJoinCondition(SyntaxNode joinCondition);
    public static bool AreEquivalentIgnoringLambdaBodies(SyntaxNode oldNode, SyntaxNode newNode);
    internal static bool IsNonUserCodeQueryLambda(SyntaxNode syntax);
    internal static bool IsClosureScope(SyntaxNode node);
}
public enum Microsoft.CodeAnalysis.VisualBasic.LanguageVersion : Enum {
    public int value__;
    public static LanguageVersion VisualBasic9;
    public static LanguageVersion VisualBasic10;
    public static LanguageVersion VisualBasic11;
    public static LanguageVersion VisualBasic12;
    public static LanguageVersion VisualBasic14;
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.LanguageVersionEnumBounds : object {
    [ExtensionAttribute]
internal static bool IsValid(LanguageVersion value);
    [ExtensionAttribute]
internal static string GetErrorName(LanguageVersion value);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.VisualBasic.LateBoundAccessKind : Enum {
    public int value__;
    public static LateBoundAccessKind Unknown;
    public static LateBoundAccessKind Get;
    public static LateBoundAccessKind Set;
    public static LateBoundAccessKind Call;
}
internal class Microsoft.CodeAnalysis.VisualBasic.LazyObsoleteDiagnosticInfo : DiagnosticInfo {
    private DiagnosticInfo _lazyActualObsoleteDiagnostic;
    private Symbol _symbol;
    private Symbol _containingSymbol;
    internal LazyObsoleteDiagnosticInfo(Symbol sym, Symbol containingSymbol);
    internal virtual DiagnosticInfo GetResolvedInfo();
}
internal class Microsoft.CodeAnalysis.VisualBasic.LexicalOrderSymbolComparer : object {
    public static LexicalOrderSymbolComparer Instance;
    private static LexicalOrderSymbolComparer();
    public sealed virtual override int Compare(Symbol x, Symbol y);
}
internal class Microsoft.CodeAnalysis.VisualBasic.LocalBinderBuilder : VisualBasicSyntaxVisitor {
    private ImmutableDictionary`2<VisualBasicSyntaxNode, BlockBaseBinder> _nodeMap;
    private ImmutableDictionary`2<SyntaxList`1<StatementSyntax>, BlockBaseBinder> _listMap;
    private MethodSymbol _enclosingMethod;
    private Binder _containingBinder;
    public ImmutableDictionary`2<VisualBasicSyntaxNode, BlockBaseBinder> NodeToBinderMap { get; }
    public ImmutableDictionary`2<SyntaxList`1<StatementSyntax>, BlockBaseBinder> StmtListToBinderMap { get; }
    public LocalBinderBuilder(MethodSymbol enclosingMethod);
    public LocalBinderBuilder(MethodSymbol enclosingMethod, ImmutableDictionary`2<VisualBasicSyntaxNode, BlockBaseBinder> nodeMap, ImmutableDictionary`2<SyntaxList`1<StatementSyntax>, BlockBaseBinder> listMap);
    public void MakeBinder(VisualBasicSyntaxNode node, Binder containingBinder);
    public ImmutableDictionary`2<VisualBasicSyntaxNode, BlockBaseBinder> get_NodeToBinderMap();
    public ImmutableDictionary`2<SyntaxList`1<StatementSyntax>, BlockBaseBinder> get_StmtListToBinderMap();
    private void VisitStatementsInList(IEnumerable`1<StatementSyntax> list, BlockBaseBinder currentBinder);
    private void CreateBinderFromStatementList(SyntaxList`1<StatementSyntax> list, Binder outerBinder);
    private void RememberBinder(VisualBasicSyntaxNode node, Binder binder);
    public virtual void VisitCompilationUnit(CompilationUnitSyntax node);
    public virtual void VisitMethodBlock(MethodBlockSyntax node);
    public virtual void VisitConstructorBlock(ConstructorBlockSyntax node);
    public virtual void VisitOperatorBlock(OperatorBlockSyntax node);
    public virtual void VisitAccessorBlock(AccessorBlockSyntax node);
    private void VisitMethodBlockBase(MethodBlockBaseSyntax methodBlock);
    public virtual void VisitSingleLineLambdaExpression(SingleLineLambdaExpressionSyntax node);
    public virtual void VisitMultiLineLambdaExpression(MultiLineLambdaExpressionSyntax node);
    public virtual void VisitWhileBlock(WhileBlockSyntax node);
    public virtual void VisitUsingBlock(UsingBlockSyntax node);
    public virtual void VisitSyncLockBlock(SyncLockBlockSyntax node);
    public virtual void VisitWithBlock(WithBlockSyntax node);
    public virtual void VisitSingleLineIfStatement(SingleLineIfStatementSyntax node);
    public virtual void VisitSingleLineElseClause(SingleLineElseClauseSyntax node);
    public virtual void VisitMultiLineIfBlock(MultiLineIfBlockSyntax node);
    public virtual void VisitElseBlock(ElseBlockSyntax node);
    public virtual void VisitElseIfBlock(ElseIfBlockSyntax node);
    public virtual void VisitTryBlock(TryBlockSyntax node);
    public virtual void VisitCatchBlock(CatchBlockSyntax node);
    public virtual void VisitFinallyBlock(FinallyBlockSyntax node);
    public virtual void VisitSelectBlock(SelectBlockSyntax node);
    public virtual void VisitCaseBlock(CaseBlockSyntax node);
    public virtual void VisitDoLoopBlock(DoLoopBlockSyntax node);
    public virtual void VisitForBlock(ForBlockSyntax node);
    public virtual void VisitForEachBlock(ForEachBlockSyntax node);
}
internal class Microsoft.CodeAnalysis.VisualBasic.LocalInProgressBinder : Binder {
    private ConsList`1<LocalSymbol> _symbols;
    public ConsList`1<LocalSymbol> ImplicitlyTypedLocalsBeingBound { get; }
    public LocalInProgressBinder(Binder containingBinder, LocalSymbol symbol);
    public virtual ConsList`1<LocalSymbol> get_ImplicitlyTypedLocalsBeingBound();
}
public class Microsoft.CodeAnalysis.VisualBasic.LocalizableErrorArgument : ValueType {
    private ERRID _id;
    internal LocalizableErrorArgument(ERRID id);
    public virtual string ToString();
    public sealed virtual override string ToString_IFormattable(string format, IFormatProvider formatProvider);
}
internal class Microsoft.CodeAnalysis.VisualBasic.LocalRewriter : BoundTreeRewriterWithStackGuard {
    private MethodSymbol _topMethod;
    private PEModuleBuilder _emitModule;
    private TypeCompilationState _compilationState;
    private SynthesizedSubmissionFields _previousSubmissionFields;
    private bool _globalGenerateDebugInfo;
    private DiagnosticBag _diagnostics;
    private ISet`1<Symbol> _symbolsCapturedWithoutCopyCtor;
    private MethodSymbol _currentMethodOrLambda;
    private Dictionary`2<RangeVariableSymbol, BoundExpression> _rangeVariableMap;
    private Dictionary`2<BoundValuePlaceholderBase, BoundExpression> _placeholderReplacementMapDoNotUseDirectly;
    private bool _hasLambdas;
    private bool _inExpressionLambda;
    private Dictionary`2<LocalSymbol, KeyValuePair`2<SynthesizedStaticLocalBackingField, SynthesizedStaticLocalBackingField>> _staticLocalMap;
    private XmlLiteralFixupData _xmlFixupData;
    private ImmutableArray`1<KeyValuePair`2<string, string>> _xmlImportedNamespaces;
    private UnstructuredExceptionHandlingState _unstructuredExceptionHandling;
    private LocalSymbol _currentLineTemporary;
    private bool _createSequencePointsForTopLevelNonCompilerGeneratedExpressions;
    private int _conditionalAccessReceiverPlaceholderId;
    private RewritingFlags _flags;
    private static int s_activeHandler_None;
    private static int s_activeHandler_ResumeNext;
    private static int s_activeHandler_FirstNonReservedOnErrorGotoIndex;
    private static int s_activeHandler_FirstOnErrorResumeNextIndex;
    private Dictionary`2<TypeSymbol, bool> _valueTypesCleanUpCache;
    private BoundExpression PlaceholderReplacement { get; }
    public bool OptimizationLevelIsDebug { get; }
    private VisualBasicCompilation Compilation { get; }
    private SourceAssemblySymbol ContainingAssembly { get; }
    private bool GenerateDebugInfo { get; }
    private LocalRewriter(MethodSymbol topMethod, MethodSymbol currentMethod, TypeCompilationState compilationState, SynthesizedSubmissionFields previousSubmissionFields, bool generateDebugInfo, DiagnosticBag diagnostics, RewritingFlags flags, int recursionDepth);
    private BoundExpression get_PlaceholderReplacement(BoundValuePlaceholderBase placeholder);
    [ConditionalAttribute("DEBUG")]
private static void AssertPlaceholderReplacement(BoundValuePlaceholderBase placeholder, BoundExpression value);
    private void AddPlaceholderReplacement(BoundValuePlaceholderBase placeholder, BoundExpression value);
    private void UpdatePlaceholderReplacement(BoundValuePlaceholderBase placeholder, BoundExpression value);
    private void RemovePlaceholderReplacement(BoundValuePlaceholderBase placeholder);
    public bool get_OptimizationLevelIsDebug();
    private static BoundNode RewriteNode(BoundNode node, MethodSymbol topMethod, MethodSymbol currentMethod, TypeCompilationState compilationState, SynthesizedSubmissionFields previousSubmissionFields, bool generateDebugInfo, DiagnosticBag diagnostics, HashSet`1& rewrittenNodes, Boolean& hasLambdas, ISet`1& symbolsCapturedWithoutCtor, RewritingFlags flags, int recursionDepth);
    private static BoundBlock InsertXmlLiteralsPreamble(BoundNode node, ImmutableArray`1<LocalWithInitialization> fixups);
    public static BoundBlock Rewrite(BoundBlock node, MethodSymbol topMethod, TypeCompilationState compilationState, SynthesizedSubmissionFields previousSubmissionFields, DiagnosticBag diagnostics, HashSet`1& rewrittenNodes, Boolean& hasLambdas, ISet`1& symbolsCapturedWithoutCopyCtor, RewritingFlags flags, MethodSymbol currentMethod);
    public static BoundExpression RewriteExpressionTree(BoundExpression node, MethodSymbol method, TypeCompilationState compilationState, SynthesizedSubmissionFields previousSubmissionFields, DiagnosticBag diagnostics, HashSet`1<BoundNode> rewrittenNodes, int recursionDepth);
    public virtual BoundNode Visit(BoundNode node);
    private BoundExpression VisitExpression(BoundExpression node);
    private VisualBasicCompilation get_Compilation();
    private SourceAssemblySymbol get_ContainingAssembly();
    private bool get_GenerateDebugInfo();
    private BoundStatement InsertEndBlockSequencePoint(BoundStatement statement, VisualBasicSyntaxNode spSyntax);
    private BoundStatement Concat(BoundStatement statement, BoundStatement additionOpt);
    private BoundBlock AppendToBlock(BoundBlock block, BoundStatement additionOpt);
    private BoundStatement InsertBlockEpilogue(BoundStatement statement, BoundStatement endBlockResumeTargetOpt, VisualBasicSyntaxNode sequencePointSyntax);
    private BoundStatement PrependWithSequencePoint(BoundStatement statement, VisualBasicSyntaxNode spSyntax);
    private BoundStatement PrependWithSequencePoint(BoundStatement statement, VisualBasicSyntaxNode syntax, TextSpan span);
    private BoundBlock PrependWithSequencePoint(BoundBlock statement, VisualBasicSyntaxNode syntax);
    public virtual BoundNode VisitSequencePointWithSpan(BoundSequencePointWithSpan node);
    public virtual BoundNode VisitSequencePoint(BoundSequencePoint node);
    private BoundStatement MarkStatementWithSequencePoint(BoundStatement node);
    public virtual BoundNode VisitBadExpression(BoundBadExpression node);
    private BoundExpression RewriteReceiverArgumentsAndGenerateAccessorCall(VisualBasicSyntaxNode syntax, MethodSymbol methodSymbol, BoundExpression receiverOpt, ImmutableArray`1<BoundExpression> arguments, ConstantValue constantValueOpt, bool suppressObjectClone, TypeSymbol type);
    private LabelSymbol GenerateLabel(string baseName);
    public virtual BoundNode VisitRValuePlaceholder(BoundRValuePlaceholder node);
    public virtual BoundNode VisitLValuePlaceholder(BoundLValuePlaceholder node);
    public virtual BoundNode VisitCompoundAssignmentTargetPlaceholder(BoundCompoundAssignmentTargetPlaceholder node);
    public virtual BoundNode VisitByRefArgumentPlaceholder(BoundByRefArgumentPlaceholder node);
    public virtual BoundNode VisitLValueToRValueWrapper(BoundLValueToRValueWrapper node);
    private NamedTypeSymbol GetSpecialType(SpecialType specialType);
    private NamedTypeSymbol GetSpecialTypeWithUseSiteDiagnostics(SpecialType specialType, SyntaxNode syntax);
    private Symbol GetSpecialTypeMember(SpecialMember specialMember);
    private bool ReportMissingOrBadRuntimeHelper(BoundNode node, SpecialMember specialMember, Symbol memberSymbol);
    internal static bool ReportMissingOrBadRuntimeHelper(BoundNode node, SpecialMember specialMember, Symbol memberSymbol, DiagnosticBag diagnostics, bool embedVBCoreRuntime);
    private static void ReportMissingRuntimeHelper(BoundNode node, SpecialMember specialMember, DiagnosticBag diagnostics, bool embedVBCoreRuntime);
    private bool ReportMissingOrBadRuntimeHelper(BoundNode node, WellKnownMember wellKnownMember, Symbol memberSymbol);
    internal static bool ReportMissingOrBadRuntimeHelper(BoundNode node, WellKnownMember wellKnownMember, Symbol memberSymbol, DiagnosticBag diagnostics, bool embedVBCoreRuntime);
    private static void ReportMissingRuntimeHelper(BoundNode node, WellKnownMember wellKnownMember, DiagnosticBag diagnostics, bool embedVBCoreRuntime);
    private static void ReportMissingRuntimeHelper(BoundNode node, string typeName, string memberName, DiagnosticBag diagnostics, bool embedVBCoreRuntime);
    private static void ReportDiagnostic(BoundNode node, DiagnosticInfo diagnostic, DiagnosticBag diagnostics);
    private void ReportBadType(BoundNode node, TypeSymbol typeSymbol);
    public virtual BoundNode VisitMethodGroup(BoundMethodGroup node);
    public virtual BoundNode VisitParenthesized(BoundParenthesized node);
    private static BoundExpression CacheToLocalIfNotConst(Symbol container, BoundExpression value, ArrayBuilder`1<LocalSymbol> locals, ArrayBuilder`1<BoundExpression> expressions, SynthesizedLocalKind kind, StatementSyntax syntaxOpt);
    internal static BoundExpression GenerateSequenceValueSideEffects(Symbol container, BoundExpression value, ImmutableArray`1<LocalSymbol> temporaries, ImmutableArray`1<BoundExpression> sideEffects);
    private BoundExpression VisitExpressionNode(BoundExpression expression);
    public virtual BoundNode VisitAwaitOperator(BoundAwaitOperator node);
    public virtual BoundNode VisitStopStatement(BoundStopStatement node);
    public virtual BoundNode VisitEndStatement(BoundEndStatement node);
    public virtual BoundNode VisitGetType(BoundGetType node);
    public virtual BoundNode VisitArrayCreation(BoundArrayCreation node);
    public virtual BoundNode VisitAddHandlerStatement(BoundAddHandlerStatement node);
    public virtual BoundNode VisitRemoveHandlerStatement(BoundRemoveHandlerStatement node);
    private BoundNode RewriteAddRemoveHandler(BoundAddRemoveHandlerStatement node);
    private BoundStatement RewriteWinRtEvent(BoundAddRemoveHandlerStatement node, BoundEventAccess unwrappedEventAccess, bool isAddition);
    private static bool EventReceiverNeedsTemp(BoundExpression expression);
    public virtual BoundNode VisitEventAccess(BoundEventAccess node);
    private BoundStatement MakeEventAccessorCall(BoundAddRemoveHandlerStatement node, BoundEventAccess unwrappedEventAccess, MethodSymbol accessorSymbol);
    private BoundEventAccess UnwrapEventAccess(BoundExpression node);
    private BoundExpression GetEventAccessReceiver(BoundEventAccess unwrappedEventAccess);
    private BoundExpression RewriteNoPiaAddRemoveHandler(BoundAddRemoveHandlerStatement node, BoundExpression receiver, EventSymbol event, BoundExpression handler);
    private BoundExpression Convert(SyntheticBoundNodeFactory factory, TypeSymbol type, BoundExpression expr);
    public virtual BoundNode VisitAnonymousTypeCreationExpression(BoundAnonymousTypeCreationExpression node);
    public virtual BoundNode VisitAnonymousTypePropertyAccess(BoundAnonymousTypePropertyAccess node);
    public virtual BoundNode VisitAnonymousTypeFieldInitializer(BoundAnonymousTypeFieldInitializer node);
    public virtual BoundNode VisitAsNewLocalDeclarations(BoundAsNewLocalDeclarations node);
    private static BoundObjectInitializerExpression GetBoundObjectInitializerFromInitializer(BoundExpression initializer);
    public virtual BoundNode VisitAssignmentOperator(BoundAssignmentOperator node);
    private BoundExpression VisitAssignmentOperatorSimple(BoundAssignmentOperator node);
    private BoundExpression VisitAssignmentLeftExpression(BoundAssignmentOperator node);
    private BoundExpression RewritePropertyAssignmentAsSetCall(BoundAssignmentOperator node, BoundExpression setNode);
    [ConditionalAttribute("DEBUG")]
private static void AssertIsWriteableFromMember(BoundPropertyAccess node, Symbol fromMember);
    private BoundExpression RewritePropertyAssignmentAsSetCall(BoundAssignmentOperator node, BoundPropertyAccess setNode);
    private BoundNode RewriteLateBoundAssignment(BoundAssignmentOperator node);
    private BoundExpression VisitAndGenerateObjectCloneIfNeeded(BoundExpression right, bool suppressObjectClone);
    private BoundExpression GenerateObjectCloneIfNeeded(BoundExpression generatedExpression);
    private BoundExpression GenerateObjectCloneIfNeeded(BoundExpression expression, BoundExpression rewrittenExpression);
    private BoundExpression RewriteTrivialMidAssignment(BoundAssignmentOperator node);
    public virtual BoundNode VisitMidResult(BoundMidResult node);
    public virtual BoundNode VisitUserDefinedBinaryOperator(BoundUserDefinedBinaryOperator node);
    public virtual BoundNode VisitUserDefinedShortCircuitingOperator(BoundUserDefinedShortCircuitingOperator node);
    public virtual BoundNode VisitBinaryOperator(BoundBinaryOperator node);
    private BoundNode RewriteBinaryOperatorSimple(BoundBinaryOperator node);
    private BoundExpression ReplaceMyGroupCollectionPropertyGetWithUnderlyingField(BoundExpression operand);
    private BoundExpression TransformRewrittenBinaryOperator(BoundBinaryOperator node);
    private BoundExpression RewriteDateComparisonOperator(BoundBinaryOperator node);
    private BoundExpression RewriteDecimalComparisonOperator(BoundBinaryOperator node);
    private BoundExpression RewriteObjectShortCircuitOperator(BoundBinaryOperator node);
    private BoundExpression RewritePowOperator(BoundBinaryOperator node);
    private BoundExpression RewriteDecimalBinaryOperator(BoundBinaryOperator node, SpecialMember member);
    private BoundExpression RewriteStringComparisonOperator(BoundBinaryOperator node);
    private BoundExpression RewriteObjectComparisonOperator(BoundBinaryOperator node, WellKnownMember member);
    private BoundExpression RewriteLikeOperator(BoundBinaryOperator node, WellKnownMember member);
    private BoundExpression RewriteObjectBinaryOperator(BoundBinaryOperator node, WellKnownMember member);
    private BoundNode RewriteLiftedIntrinsicBinaryOperatorSimple(BoundBinaryOperator node);
    private BoundExpression FinishRewriteOfLiftedIntrinsicBinaryOperator(BoundBinaryOperator node, BoundExpression left, BoundExpression right);
    private BoundExpression RewriteLiftedBooleanBinaryOperator(BoundBinaryOperator node, BoundExpression left, BoundExpression right, bool leftHasNoValue, bool rightHasNoValue, bool leftHasValue, bool rightHasValue);
    private BoundExpression RewriteNullableIsOrIsNotOperator(BoundBinaryOperator node);
    private BoundExpression RewriteNullableIsOrIsNotOperator(bool isIs, BoundExpression operand, TypeSymbol resultType);
    private BoundNode RewriteLiftedUserDefinedBinaryOperator(BoundUserDefinedBinaryOperator node);
    private BoundExpression ApplyUnliftedBinaryOp(BoundBinaryOperator originalOperator, BoundExpression left, BoundExpression right);
    public virtual BoundNode VisitBlock(BoundBlock node);
    public virtual BoundNode VisitCall(BoundCall node);
    private static void UpdateMethodAndArgumentsIfReducedFromMethod(MethodSymbol& method, BoundExpression& receiver, ImmutableArray`1& arguments);
    public virtual BoundNode VisitByRefArgumentWithCopyBack(BoundByRefArgumentWithCopyBack node);
    private ImmutableArray`1<BoundExpression> RewriteCallArguments(ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<ParameterSymbol> parameters, ImmutableArray`1& temporaries, ImmutableArray`1& copyBack, bool suppressObjectClone);
    private BoundExpression PassArgAsTempClone(BoundExpression argument, BoundExpression rewrittenArgument, ArrayBuilder`1& tempsArray);
    private BoundExpression RewriteByRefArgumentWithCopyBack(BoundByRefArgumentWithCopyBack argument, ArrayBuilder`1& tempsArray, ArrayBuilder`1& copyBackArray);
    private bool ShouldCaptureConditionalAccessReceiver(BoundExpression receiver);
    public virtual BoundNode VisitConditionalAccess(BoundConditionalAccess node);
    private static bool IsConditionalAccess(BoundExpression operand, BoundExpression& whenNotNull, BoundExpression& whenNull);
    private static BoundExpression UpdateConditionalAccess(BoundExpression operand, BoundExpression whenNotNull, BoundExpression whenNull);
    public virtual BoundNode VisitBinaryConditionalExpression(BoundBinaryConditionalExpression node);
    private BoundExpression RewriteBinaryConditionalExpressionInExpressionLambda(BoundBinaryConditionalExpression node);
    public BoundNode TransformRewrittenBinaryConditionalExpression(BoundNode node);
    public BoundExpression TransformRewrittenBinaryConditionalExpression(BoundBinaryConditionalExpression node);
    private BoundNode RewriteNullableBinaryConditionalExpression(BoundBinaryConditionalExpression node);
    private BoundExpression MakeResultFromNonNullLeft(BoundExpression rewrittenLeft, BoundExpression convertedTestExpression, BoundRValuePlaceholder testExpressionPlaceholder);
    private BoundExpression VisitExpressionNode(BoundExpression node, BoundValuePlaceholderBase placeholder, BoundExpression placeholderSubstitute);
    public virtual BoundNode VisitTernaryConditionalExpression(BoundTernaryConditionalExpression node);
    private BoundExpression TransformRewrittenTernaryConditionalExpression(BoundTernaryConditionalExpression node);
    private BoundExpression RewriteConstant(BoundExpression node, ConstantValue constantValue);
    private static BoundExpression RewriteDecimalConstant(BoundExpression node, ConstantValue nodeValue, MethodSymbol currentMethod, DiagnosticBag diagnostics);
    private static BoundExpression RewriteDateConstant(BoundExpression node, ConstantValue nodeValue, MethodSymbol currentMethod, DiagnosticBag diagnostics);
    public virtual BoundNode VisitContinueStatement(BoundContinueStatement node);
    public virtual BoundNode VisitConversion(BoundConversion node);
    private BoundNode RewriteLambdaRelaxationConversion(BoundConversion node);
    private BoundNode RewriteLambdaRelaxationConversion(BoundDirectCast node);
    private BoundNode RewriteLambdaRelaxationConversion(BoundTryCast node);
    private static bool NoParameterRelaxation(BoundExpression from, LambdaSymbol toLambda);
    private BoundNode RewriteAnonymousDelegateConversion(BoundConversion node);
    private bool CouldPossiblyBeNothing(SyntheticBoundNodeFactory F, BoundExpression node);
    private BoundExpression RewriteNullableConversion(BoundConversion node);
    private BoundExpression RewriteNullableConversion(BoundConversion node, BoundExpression rewrittenOperand);
    private BoundExpression FinishRewriteNullableConversion(BoundConversion node, TypeSymbol resultType, BoundExpression operand, BoundExpression operandHasValue, ArrayBuilder`1<LocalSymbol> temps, ArrayBuilder`1<BoundExpression> inits);
    private BoundExpression RewriteNullableReferenceConversion(BoundConversion node, BoundExpression rewrittenOperand);
    private BoundNode RewriteNullableUserDefinedConversion(BoundUserDefinedConversion node);
    private BoundExpression TransformRewrittenConversion(BoundConversion rewrittenConversion);
    private BoundExpression InitWithParameterlessValueTypeConstructor(BoundConversion node, NamedTypeSymbol typeTo);
    private BoundExpression RewriteReferenceTypeToCharArrayRankOneConversion(BoundConversion node, TypeSymbol typeFrom, TypeSymbol typeTo);
    private BoundExpression RewriteAsDirectCast(BoundConversion node);
    private BoundExpression RewriteFromObjectConversion(BoundConversion node, TypeSymbol typeFrom, TypeSymbol underlyingTypeTo);
    private BoundExpression RewriteToStringConversion(BoundConversion node, TypeSymbol underlyingTypeFrom, TypeSymbol typeTo);
    private BoundExpression RewriteFromStringConversion(BoundConversion node, TypeSymbol typeFrom, TypeSymbol underlyingTypeTo);
    private BoundExpression RewriteNumericOrBooleanToDecimalConversion(BoundConversion node, TypeSymbol underlyingTypeFrom, TypeSymbol typeTo);
    private BoundExpression RewriteDecimalToNumericOrBooleanConversion(BoundConversion node, TypeSymbol typeFrom, TypeSymbol underlyingTypeTo);
    private BoundExpression RewriteFloatingToIntegralConversion(BoundConversion node, TypeSymbol typeFrom, TypeSymbol underlyingTypeTo);
    public virtual BoundNode VisitDirectCast(BoundDirectCast node);
    public virtual BoundNode VisitTryCast(BoundTryCast node);
    public virtual BoundNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node);
    public virtual BoundNode VisitDimStatement(BoundDimStatement node);
    public virtual BoundNode VisitDoLoopStatement(BoundDoLoopStatement node);
    private BoundNode VisitTopConditionLoop(BoundDoLoopStatement node);
    private BoundNode VisitBottomConditionLoop(BoundDoLoopStatement node);
    private BoundNode VisitInfiniteLoop(BoundDoLoopStatement node);
    public virtual BoundNode VisitEraseStatement(BoundEraseStatement node);
    public virtual BoundNode VisitExitStatement(BoundExitStatement node);
    public virtual BoundNode VisitExpressionStatement(BoundExpressionStatement node);
    private bool IsOmittedBoundCall(BoundExpression expression);
    public virtual BoundNode VisitFieldAccess(BoundFieldAccess node);
    public virtual BoundNode VisitFieldInitializer(BoundFieldInitializer node);
    public virtual BoundNode VisitPropertyInitializer(BoundPropertyInitializer node);
    private BoundNode VisitFieldOrPropertyInitializer(BoundFieldOrPropertyInitializer node, ImmutableArray`1<Symbol> initializedSymbols);
    private BoundStatement MarkInitializerSequencePoint(BoundStatement rewrittenStatement, VisualBasicSyntaxNode syntax, int nameIndex);
    public virtual BoundNode VisitForEachStatement(BoundForEachStatement node);
    private void RewriteForEachArrayOrString(BoundForEachStatement node, ArrayBuilder`1<BoundStatement> statements, ArrayBuilder`1<LocalSymbol> locals, bool isArray, BoundExpression collectionExpression);
    private BoundStatement CreateLocalAndAssignment(StatementSyntax syntaxNode, BoundExpression initExpression, BoundLocal& boundLocal, ArrayBuilder`1<LocalSymbol> locals, SynthesizedLocalKind kind);
    private BoundStatement CreateIndexIncrement(VisualBasicSyntaxNode syntaxNode, BoundLocal boundIndex);
    private BoundStatementList CreateLoweredWhileStatements(BoundForEachStatement forEachStatement, BoundExpression limit, BoundLocal index, BoundStatement currentAssignment, BoundStatement incrementAssignment, bool generateUnstructuredExceptionHandlingResumeCode);
    private void RewriteForEachIEnumerable(BoundForEachStatement node, ArrayBuilder`1<BoundStatement> statements, ArrayBuilder`1<LocalSymbol> locals);
    public BoundStatement GenerateDisposeCallForForeachAndUsing(VisualBasicSyntaxNode syntaxNode, BoundLocal rewrittenBoundLocal, BoundExpression rewrittenCondition, bool IsOrInheritsFromOrImplementsIDisposable, BoundExpression rewrittenDisposeConversion);
    public virtual BoundNode VisitForToStatement(BoundForToStatement node);
    private BoundBlock FinishNonObjectForLoop(BoundForToStatement forStatement, BoundExpression rewrittenControlVariable, BoundExpression rewrittenInitialValue, BoundExpression rewrittenLimit, BoundExpression rewrittenStep);
    private static bool WillDoAtLeastOneIteration(BoundExpression rewrittenInitialValue, BoundExpression rewrittenLimit, BoundExpression rewrittenStep);
    private BoundBlock FinishObjectForLoop(BoundForToStatement forStatement, BoundExpression rewrittenControlVariable, BoundExpression rewrittenInitialValue, BoundExpression rewrittenLimit, BoundExpression rewrittenStep);
    private BoundStatement RewriteForLoopIncrement(BoundExpression controlVariable, BoundExpression stepValue, bool isChecked, BoundForToUserDefinedOperators operatorsOpt);
    private BoundExpression NegateIfStepNegative(BoundExpression value, BoundExpression step);
    private BoundExpression RewriteForLoopCondition(BoundExpression controlVariable, BoundExpression limit, BoundExpression stepValue, BoundForToUserDefinedOperators operatorsOpt, SynthesizedLocal positiveFlag);
    public virtual BoundNode VisitGotoStatement(BoundGotoStatement node);
    public virtual BoundNode VisitHostObjectMemberReference(BoundHostObjectMemberReference node);
    public virtual BoundNode VisitIfStatement(BoundIfStatement node);
    private BoundStatement RewriteIfStatement(VisualBasicSyntaxNode syntaxNode, VisualBasicSyntaxNode conditionSyntax, BoundExpression rewrittenCondition, BoundStatement rewrittenConsequence, BoundStatement rewrittenAlternative, bool generateDebugInfo, ImmutableArray`1<BoundStatement> unstructuredExceptionHandlingResumeTarget);
    public virtual BoundNode VisitInterpolatedStringExpression(BoundInterpolatedStringExpression node);
    private BoundExpression RewriteInterpolatedStringConversion(BoundConversion conversion);
    private BoundExpression InvokeInterpolatedStringFactory(BoundInterpolatedStringExpression node, TypeSymbol factoryType, string factoryMethodName, TypeSymbol targetType, SyntheticBoundNodeFactory factory);
    public virtual BoundNode VisitLabelStatement(BoundLabelStatement node);
    public virtual BoundNode VisitLambda(BoundLambda node);
    public virtual BoundNode VisitLateAddressOfOperator(BoundLateAddressOfOperator node);
    private static BoundExpression BuildDelegateRelaxationLambda(VisualBasicSyntaxNode syntaxNode, NamedTypeSymbol targetType, BoundLateMemberAccess boundMember, Binder binder, DiagnosticBag diagnostics);
    private BoundExpression LateMakeReceiverArgument(VisualBasicSyntaxNode node, BoundExpression rewrittenReceiver, TypeSymbol objectType);
    private BoundExpression LateMakeContainerArgument(VisualBasicSyntaxNode node, BoundExpression receiver, TypeSymbol containerType, TypeSymbol typeType);
    private BoundExpression LateMakeTypeArgumentArrayArgument(VisualBasicSyntaxNode node, BoundTypeArguments arguments, TypeSymbol typeArrayType);
    private BoundExpression LateMakeCopyBackArray(VisualBasicSyntaxNode node, ImmutableArray`1<bool> flags, TypeSymbol booleanArrayType);
    private BoundExpression LateMakeArgumentArrayArgument(VisualBasicSyntaxNode node, ImmutableArray`1<BoundExpression> rewrittenArguments, ImmutableArray`1<string> argumentNames, TypeSymbol objectArrayType);
    private BoundExpression LateMakeSetArgumentArrayArgument(VisualBasicSyntaxNode node, BoundExpression rewrittenValue, ImmutableArray`1<BoundExpression> rewrittenArguments, ImmutableArray`1<string> argumentNames, TypeSymbol objectArrayType);
    private BoundExpression LateAssignToArrayElement(VisualBasicSyntaxNode node, BoundExpression arrayRef, int index, BoundExpression value, TypeSymbol intType);
    private BoundExpression LateMakeArgumentArrayArgumentNoNamed(VisualBasicSyntaxNode node, ImmutableArray`1<BoundExpression> rewrittenArguments, TypeSymbol objectArrayType);
    private BoundExpression LateMakeArgumentNameArrayArgument(VisualBasicSyntaxNode node, ImmutableArray`1<string> argumentNames, TypeSymbol stringArrayType);
    private BoundExpression LateMakeConditionalCopyback(BoundExpression assignmentTarget, BoundExpression valueArrayRef, BoundExpression copyBackArrayRef, int argNum);
    private BoundExpression LateMakeCopyback(VisualBasicSyntaxNode syntax, BoundExpression assignmentTarget, BoundExpression convertedValue);
    private BoundExpression LateIndexGet(BoundLateInvocation node, BoundExpression receiverExpr, ImmutableArray`1<BoundExpression> argExpressions);
    private BoundExpression LateSet(VisualBasicSyntaxNode syntax, BoundLateMemberAccess memberAccess, BoundExpression assignmentValue, ImmutableArray`1<BoundExpression> argExpressions, ImmutableArray`1<string> argNames, bool isCopyBack);
    private BoundExpression LateIndexSet(VisualBasicSyntaxNode syntax, BoundLateInvocation invocation, BoundExpression assignmentValue, bool isCopyBack);
    private BoundExpression LateCallOrGet(BoundLateMemberAccess memberAccess, BoundExpression receiverExpression, ImmutableArray`1<BoundExpression> argExpressions, ImmutableArray`1<BoundExpression> assignmentArguments, ImmutableArray`1<string> argNames, bool useLateCall);
    private void LateCaptureArgsComplex(ArrayBuilder`1& temps, ImmutableArray`1& arguments, ImmutableArray`1& writeTargets);
    private BoundLiteral MakeStringLiteral(VisualBasicSyntaxNode node, string value, TypeSymbol stringType);
    private BoundLiteral MakeBooleanLiteral(VisualBasicSyntaxNode node, bool value, TypeSymbol booleanType);
    private BoundGetType MakeGetTypeExpression(VisualBasicSyntaxNode node, TypeSymbol type, TypeSymbol typeType);
    private BoundArrayCreation MakeArrayOfGetTypeExpressions(VisualBasicSyntaxNode node, ImmutableArray`1<TypeSymbol> types, TypeSymbol typeArrayType);
    private bool TryGetWellknownMember(T& result, WellKnownMember memberId, VisualBasicSyntaxNode syntax, bool isOptional);
    private bool TryGetSpecialMember(T& result, SpecialMember memberId, VisualBasicSyntaxNode syntax);
    public virtual BoundNode VisitLateInvocation(BoundLateInvocation node);
    private BoundExpression RewriteLateBoundIndexInvocation(BoundLateInvocation invocation, BoundExpression receiverExpression, ImmutableArray`1<BoundExpression> argExpressions);
    private BoundExpression RewriteLateBoundMemberInvocation(BoundLateMemberAccess memberAccess, BoundExpression receiverExpression, ImmutableArray`1<BoundExpression> argExpressions, ImmutableArray`1<string> argNames, bool useLateCall);
    public virtual BoundNode VisitLateMemberAccess(BoundLateMemberAccess memberAccess);
    public virtual BoundNode VisitLocalDeclaration(BoundLocalDeclaration node);
    private BoundStatement RewriteLocalDeclarationAsInitializer(BoundLocalDeclaration node, BoundExpression rewrittenInitializer, KeyValuePair`2<SynthesizedStaticLocalBackingField, SynthesizedStaticLocalBackingField> staticLocalBackingFields, bool objectInitializerNeedsTemporary);
    private BoundStatement MarkInitializerSequencePoint(BoundStatement rewrittenStatement, VisualBasicSyntaxNode syntax);
    private KeyValuePair`2<SynthesizedStaticLocalBackingField, SynthesizedStaticLocalBackingField> CreateBackingFieldsForStaticLocal(LocalSymbol localSymbol, bool hasInitializer);
    public virtual BoundNode VisitLocal(BoundLocal node);
    private BoundStatement EnforceStaticLocalInitializationSemantics(KeyValuePair`2<SynthesizedStaticLocalBackingField, SynthesizedStaticLocalBackingField> staticLocalBackingFields, BoundStatement rewrittenInitialization);
    private BoundExpression WrapInNullable(BoundExpression expr, TypeSymbol nullableType);
    private BoundExpression ProcessNullableOperand(BoundExpression operand, BoundExpression& hasValueExpr, ArrayBuilder`1& temps, ArrayBuilder`1& inits, bool doNotCaptureLocals);
    private BoundExpression ProcessNullableOperand(BoundExpression operand, BoundExpression& hasValueExpr, ArrayBuilder`1& temps, ArrayBuilder`1& inits, bool doNotCaptureLocals, bool operandHasValue);
    private bool RightCanChangeLeftLocal(BoundExpression left, BoundExpression right);
    private BoundExpression CaptureNullableIfNeeded(BoundExpression operand, SynthesizedLocal& temp, BoundExpression& init, bool doNotCaptureLocals);
    private BoundExpression CaptureNullableIfNeeded(BoundExpression operand, ArrayBuilder`1& temps, ArrayBuilder`1& inits, bool doNotCaptureLocals);
    private BoundExpression NullableValueOrDefault(BoundExpression expr);
    private BoundExpression NullableValue(BoundExpression expr);
    private BoundExpression NullableHasValue(BoundExpression expr);
    private static BoundExpression NullableNull(VisualBasicSyntaxNode syntax, TypeSymbol nullableType);
    private static BoundExpression NullableNull(BoundExpression candidateNullExpression, TypeSymbol type);
    private BoundExpression NullableFalse(VisualBasicSyntaxNode syntax, TypeSymbol nullableOfBoolean);
    private BoundExpression NullableTrue(VisualBasicSyntaxNode syntax, TypeSymbol nullableOfBoolean);
    private MethodSymbol GetNullableMethod(VisualBasicSyntaxNode syntax, TypeSymbol nullableType, SpecialMember member);
    private BoundExpression NullableOfBooleanValue(VisualBasicSyntaxNode syntax, bool isTrue, TypeSymbol nullableOfBoolean);
    private static bool HasNoValue(BoundExpression expr);
    private static bool HasValue(BoundExpression expr);
    private BoundExpression MakeBinaryExpression(VisualBasicSyntaxNode syntax, BinaryOperatorKind binaryOpKind, BoundExpression left, BoundExpression right, bool isChecked, TypeSymbol resultType);
    private BoundExpression MakeBooleanBinaryExpression(VisualBasicSyntaxNode syntax, BinaryOperatorKind binaryOpKind, BoundExpression left, BoundExpression right);
    private BoundLiteral MakeNullLiteral(VisualBasicSyntaxNode syntax, TypeSymbol type);
    private static BoundExpression MakeSequence(BoundExpression first, BoundExpression second);
    private static BoundExpression MakeSequence(VisualBasicSyntaxNode syntax, BoundExpression first, BoundExpression second);
    private BoundExpression MakeTernaryConditionalExpression(VisualBasicSyntaxNode syntax, BoundExpression condition, BoundExpression whenTrue, BoundExpression whenFalse);
    private static BoundExpression GetSideeffects(BoundExpression operand);
    public virtual BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node);
    public virtual BoundNode VisitNoPiaObjectCreationExpression(BoundNoPiaObjectCreationExpression node);
    private BoundNode VisitObjectCreationInitializer(BoundObjectInitializerExpressionBase objectInitializer, BoundExpression objectCreationExpression, BoundExpression rewrittenObjectCreationExpression);
    public virtual BoundNode VisitNewT(BoundNewT node);
    public BoundNode RewriteCollectionInitializerExpression(BoundCollectionInitializerExpression node, BoundExpression objectCreationExpression, BoundExpression rewrittenObjectCreationExpression);
    public BoundNode RewriteObjectInitializerExpression(BoundObjectInitializerExpression node, BoundExpression objectCreationExpression, BoundExpression rewrittenObjectCreationExpression);
    private BoundExpression ReplaceObjectOrCollectionInitializer(BoundExpression rewrittenObjectCreationExpression, BoundObjectInitializerExpressionBase rewrittenInitializer);
    public virtual BoundNode VisitOmittedArgument(BoundOmittedArgument node);
    public virtual BoundNode VisitPreviousSubmissionReference(BoundPreviousSubmissionReference node);
    public virtual BoundNode VisitPropertyAccess(BoundPropertyAccess node);
    public virtual BoundNode VisitQueryExpression(BoundQueryExpression node);
    public virtual BoundNode VisitQueryClause(BoundQueryClause node);
    public virtual BoundNode VisitOrdering(BoundOrdering node);
    public virtual BoundNode VisitRangeVariableAssignment(BoundRangeVariableAssignment node);
    public virtual BoundNode VisitGroupAggregation(BoundGroupAggregation node);
    public virtual BoundNode VisitQueryLambda(BoundQueryLambda node);
    private void PopulateRangeVariableMapForAnonymousType(VisualBasicSyntaxNode syntax, BoundExpression anonymousTypeInstance, ImmutableArray`1<RangeVariableSymbol> rangeVariables, Int32& firstUnmappedRangeVariable);
    public virtual BoundNode VisitRangeVariable(BoundRangeVariable node);
    public virtual BoundNode VisitQueryableSource(BoundQueryableSource node);
    public virtual BoundNode VisitQuerySource(BoundQuerySource node);
    public virtual BoundNode VisitToQueryableCollectionConversion(BoundToQueryableCollectionConversion node);
    public virtual BoundNode VisitAggregateClause(BoundAggregateClause node);
    public virtual BoundNode VisitRaiseEventStatement(BoundRaiseEventStatement node);
    private BoundExpression GetWindowsRuntimeEventReceiver(VisualBasicSyntaxNode syntax, BoundExpression rewrittenReceiver);
    public virtual BoundNode VisitRedimStatement(BoundRedimStatement node);
    public virtual BoundNode VisitRedimClause(BoundRedimClause node);
    public virtual BoundNode VisitReturnStatement(BoundReturnStatement node);
    private BoundStatement RewriteReturnStatement(BoundReturnStatement node);
    public virtual BoundNode VisitSelectStatement(BoundSelectStatement node);
    protected BoundNode RewriteSelectStatement(BoundSelectStatement node, VisualBasicSyntaxNode syntaxNode, BoundExpressionStatement selectExpressionStmt, BoundRValuePlaceholder exprPlaceholderOpt, ImmutableArray`1<BoundCaseBlock> caseBlocks, bool recommendSwitchTable, LabelSymbol exitLabel);
    private void EnsureStringHashFunction(BoundSelectStatement node);
    private BoundExpressionStatement RewriteSelectExpression(bool generateUnstructuredExceptionHandlingResumeCode, BoundExpressionStatement selectExpressionStmt, BoundExpression& rewrittenSelectExpression, ImmutableArray`1& tempLocals, ArrayBuilder`1<BoundStatement> statementBuilder, ImmutableArray`1<BoundCaseBlock> caseBlocks, bool recommendSwitchTable, BoundLabelStatement& endSelectResumeLabel);
    private BoundStatement RewriteCaseBlocksRecursive(BoundSelectStatement selectStatement, bool generateUnstructuredExceptionHandlingResumeCode, ImmutableArray`1<BoundCaseBlock> caseBlocks, int startFrom, LocalSymbol& lazyConditionalBranchLocal);
    private BoundExpression RewriteCaseStatement(bool generateUnstructuredExceptionHandlingResumeCode, BoundCaseStatement node, ImmutableArray`1& unstructuredExceptionHandlingResumeTarget);
    private static bool ShouldGenerateHashTableSwitch(PEModuleBuilder module, BoundSelectStatement node);
    public virtual BoundNode VisitCaseBlock(BoundCaseBlock node);
    internal BoundExpression AddConditionSequencePoint(BoundExpression condition, BoundCatchBlock containingCatchWithFilter);
    internal BoundExpression AddConditionSequencePoint(BoundExpression condition, BoundStatement containingStatement);
    internal BoundExpression AddConditionSequencePoint(BoundExpression condition, BoundStatement containingStatement, LocalSymbol& lazyConditionalBranchLocal);
    private BoundExpression AddConditionSequencePoint(BoundExpression condition, SyntaxNode synthesizedVariableSyntax, LocalSymbol& lazyConditionalBranchLocal, bool wasGenerated, bool shareLocal);
    internal BoundExpression AddConditionSequencePoint(BoundExpression condition, LocalSymbol conditionalBranchLocal);
    private static BoundLocal MakeLocalRead(VisualBasicSyntaxNode syntax, LocalSymbol localSym);
    private static BoundLocal MakeLocalWrite(VisualBasicSyntaxNode syntax, LocalSymbol localSym);
    private static BoundExpression MakeAssignmentExpression(VisualBasicSyntaxNode syntax, BoundExpression left, BoundExpression right);
    private BoundExpression RewriteConcatenateOperator(BoundBinaryOperator node);
    private void FlattenConcatArg(BoundExpression lowered, ArrayBuilder`1<BoundExpression> flattened);
    private BoundExpression TryFoldTwoConcatOperands(SyntheticBoundNodeFactory factory, BoundExpression loweredLeft, BoundExpression loweredRight);
    private static bool IsNullOrEmptyStringConstant(BoundExpression operand);
    private ConstantValue TryFoldTwoConcatConsts(ConstantValue leftConst, ConstantValue rightConst);
    private BoundExpression RewriteStringConcatenationOneExpr(SyntheticBoundNodeFactory factory, BoundExpression loweredOperand);
    private BoundExpression RewriteStringConcatenationTwoExprs(BoundExpression node, SyntheticBoundNodeFactory factory, BoundExpression loweredLeft, BoundExpression loweredRight);
    private BoundExpression RewriteStringConcatenationThreeExprs(BoundExpression node, SyntheticBoundNodeFactory factory, BoundExpression loweredFirst, BoundExpression loweredSecond, BoundExpression loweredThird);
    private BoundExpression RewriteStringConcatenationFourExprs(BoundExpression node, SyntheticBoundNodeFactory factory, BoundExpression loweredFirst, BoundExpression loweredSecond, BoundExpression loweredThird, BoundExpression loweredFourth);
    private BoundExpression RewriteStringConcatenationManyExprs(BoundExpression node, SyntheticBoundNodeFactory factory, ImmutableArray`1<BoundExpression> loweredArgs);
    public virtual BoundNode VisitSyncLockStatement(BoundSyncLockStatement node);
    private BoundStatement GenerateMonitorEnter(VisualBasicSyntaxNode syntaxNode, BoundExpression boundLockObject, BoundLocal& boundLockTakenLocal, BoundStatement& boundLockTakenInitialization);
    private BoundStatement GenerateMonitorExit(VisualBasicSyntaxNode syntaxNode, BoundExpression boundLockObject, BoundLocal boundLockTakenLocal);
    public virtual BoundNode VisitThrowStatement(BoundThrowStatement node);
    public virtual BoundNode VisitTryStatement(BoundTryStatement node);
    private static bool HasSideEffects(BoundStatement statement);
    public BoundStatement RewriteTryStatement(VisualBasicSyntaxNode syntaxNode, BoundBlock tryBlock, ImmutableArray`1<BoundCatchBlock> catchBlocks, BoundBlock finallyBlockOpt, LabelSymbol exitLabelOpt);
    private BoundBlock RewriteFinallyBlock(BoundBlock node);
    private BoundBlock RewriteTryBlock(BoundBlock node);
    public virtual BoundNode VisitCatchBlock(BoundCatchBlock node);
    private void ReportErrorsOnCatchBlockHelpers(BoundCatchBlock node);
    public virtual BoundNode VisitNullableIsTrueOperator(BoundNullableIsTrueOperator node);
    public virtual BoundNode VisitUserDefinedUnaryOperator(BoundUserDefinedUnaryOperator node);
    public virtual BoundNode VisitUnaryOperator(BoundUnaryOperator node);
    private BoundExpression RewriteUnaryOperator(BoundUnaryOperator node);
    private BoundExpression RewriteObjectUnaryOperator(BoundUnaryOperator node);
    private BoundExpression RewriteDecimalUnaryOperator(BoundUnaryOperator node);
    private BoundNode RewriteLiftedUnaryOperator(BoundUnaryOperator node);
    private BoundExpression RewriteLiftedUserDefinedUnaryOperator(BoundUserDefinedUnaryOperator node);
    private BoundExpression ApplyUnliftedUnaryOp(BoundUnaryOperator originalOperator, BoundExpression operandValue);
    public virtual BoundNode VisitUnstructuredExceptionHandlingStatement(BoundUnstructuredExceptionHandlingStatement node);
    private BoundBlock RewriteUnstructuredExceptionHandlingStatementIntoBlock(BoundUnstructuredExceptionHandlingStatement node);
    public virtual BoundNode VisitOnErrorStatement(BoundOnErrorStatement node);
    public virtual BoundNode VisitResumeStatement(BoundResumeStatement node);
    private BoundLabelStatement AddResumeTargetLabel(VisualBasicSyntaxNode syntax);
    private void AddResumeTargetLabelAndUpdateCurrentStatementTemporary(VisualBasicSyntaxNode syntax, bool canThrow, ArrayBuilder`1<BoundStatement> statements);
    private bool ShouldGenerateUnstructuredExceptionHandlingResumeCode(BoundStatement statement);
    private UnstructuredExceptionHandlingContext LeaveUnstructuredExceptionHandlingContext(BoundNode node);
    private void RestoreUnstructuredExceptionHandlingContext(BoundNode node, UnstructuredExceptionHandlingContext saved);
    private bool InsideValidUnstructuredExceptionHandlingResumeContext();
    private bool InsideValidUnstructuredExceptionHandlingOnErrorContext();
    private void RegisterUnstructuredExceptionHandlingResumeTarget(VisualBasicSyntaxNode syntax, bool canThrow, ArrayBuilder`1<BoundStatement> statements);
    private BoundStatement RegisterUnstructuredExceptionHandlingResumeTarget(VisualBasicSyntaxNode syntax, BoundStatement node, bool canThrow);
    private BoundLabelStatement RegisterUnstructuredExceptionHandlingNonThrowingResumeTarget(VisualBasicSyntaxNode syntax);
    private ImmutableArray`1<BoundStatement> RegisterUnstructuredExceptionHandlingResumeTarget(VisualBasicSyntaxNode syntax, bool canThrow);
    public virtual BoundNode VisitUsingStatement(BoundUsingStatement node);
    private BoundBlock RewriteSingleUsingToTryFinally(UsingBlockSyntax syntaxNode, VisualBasicSyntaxNode syntaxForSequencePoint, LocalSymbol localSymbol, BoundExpression initializationExpression, ValueTuple`3& placeholderInfo, BoundBlock currentBody);
    public virtual BoundNode VisitWhileStatement(BoundWhileStatement node);
    protected BoundNode RewriteWhileStatement(BoundStatement statement, VisualBasicSyntaxNode statementBeginSyntax, VisualBasicSyntaxNode statementEndSyntax, BoundExpression rewrittenCondition, BoundStatement rewrittenBody, LabelSymbol continueLabel, LabelSymbol exitLabel, bool loopIfTrue, BoundLabelStatement loopResumeLabelOpt, ImmutableArray`1<BoundStatement> conditionResumeTargetOpt, BoundStatement afterBodyResumeTargetOpt);
    public virtual BoundNode VisitWithStatement(BoundWithStatement node);
    private BoundBlock RewriteWithBlockStatements(BoundBlock block, VisualBasicSyntaxNode syntax, bool generateUnstructuredExceptionHandlingResumeCode, ImmutableArray`1<LocalSymbol> locals, ImmutableArray`1<BoundExpression> initializers, BoundValuePlaceholderBase placeholder, BoundExpression replaceWith);
    private bool LocalOrFieldNeedsToBeCleanedUp(TypeSymbol currentType);
    public virtual BoundNode VisitWithLValueExpressionPlaceholder(BoundWithLValueExpressionPlaceholder node);
    public virtual BoundNode VisitWithRValueExpressionPlaceholder(BoundWithRValueExpressionPlaceholder node);
    public virtual BoundNode VisitXmlComment(BoundXmlComment node);
    public virtual BoundNode VisitXmlDocument(BoundXmlDocument node);
    public virtual BoundNode VisitXmlDeclaration(BoundXmlDeclaration node);
    public virtual BoundNode VisitXmlProcessingInstruction(BoundXmlProcessingInstruction node);
    public virtual BoundNode VisitXmlAttribute(BoundXmlAttribute node);
    public virtual BoundNode VisitXmlElement(BoundXmlElement node);
    public virtual BoundNode VisitXmlEmbeddedExpression(BoundXmlEmbeddedExpression node);
    public virtual BoundNode VisitXmlMemberAccess(BoundXmlMemberAccess node);
    public virtual BoundNode VisitXmlName(BoundXmlName node);
    public virtual BoundNode VisitXmlNamespace(BoundXmlNamespace node);
    public virtual BoundNode VisitXmlCData(BoundXmlCData node);
    private BoundExpression VisitXmlContainer(BoundXmlContainerRewriterInfo rewriterInfo);
    private BoundLocal CreateTempLocal(VisualBasicSyntaxNode syntax, TypeSymbol type, BoundExpression expr, ArrayBuilder`1<BoundExpression> sideEffects);
    private BoundExpression VisitXmlContainerInExpressionLambda(BoundXmlContainerRewriterInfo rewriterInfo);
    private BoundLocal CreateTempLocalInExpressionLambda(VisualBasicSyntaxNode syntax, TypeSymbol type, BoundExpression expr);
    private void CreatePrefixesAndNamespacesArrays(BoundXmlContainerRewriterInfo rewriterInfo, VisualBasicSyntaxNode syntax, BoundExpression& prefixes, BoundExpression& namespaces);
    private BoundExpression BindXmlNamespace(VisualBasicSyntaxNode syntax, BoundExpression namespace);
    private BoundLiteral CreateStringLiteral(VisualBasicSyntaxNode syntax, string str);
    private BoundExpression CreateCompilerGeneratedXmlnsPrefix(VisualBasicSyntaxNode syntax, string prefix);
    private BoundExpression CreateCompilerGeneratedXmlNamespace(VisualBasicSyntaxNode syntax, string namespace);
    private BoundExpression CreateCompilerGeneratedArray(VisualBasicSyntaxNode syntax, TypeSymbol arrayType, ImmutableArray`1<BoundExpression> items);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.LocationExtensions : object {
    [ExtensionAttribute]
public static EmbeddedSymbolKind EmbeddedKind(Location location);
    [ExtensionAttribute]
public static TextSpan PossiblyEmbeddedOrMySourceSpan(Location location);
    [ExtensionAttribute]
public static SyntaxTree PossiblyEmbeddedOrMySourceTree(Location location);
}
internal class Microsoft.CodeAnalysis.VisualBasic.LocationSpecificBinder : Binder {
    private BindingLocation _location;
    private Symbol _owner;
    public BindingLocation BindingLocation { get; }
    public Symbol ContainingMember { get; }
    public LocationSpecificBinder(BindingLocation location, Binder containingBinder);
    public LocationSpecificBinder(BindingLocation location, Symbol owner, Binder containingBinder);
    public virtual BindingLocation get_BindingLocation();
    public virtual Symbol get_ContainingMember();
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.LookupOptionExtensions : object {
    internal static LookupOptions QueryOperatorLookupOptions;
    internal static LookupOptions ConsiderationMask;
    [ExtensionAttribute]
internal static bool IsAttributeTypeLookup(LookupOptions options);
    [ExtensionAttribute]
internal static bool IsValid(LookupOptions options);
    [ExtensionAttribute]
internal static void ThrowIfInvalid(LookupOptions options);
    [ExtensionAttribute]
internal static bool ShouldLookupExtensionMethods(LookupOptions options);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.VisualBasic.LookupOptions : Enum {
    public int value__;
    public static LookupOptions Default;
    public static LookupOptions NamespacesOrTypesOnly;
    public static LookupOptions LabelsOnly;
    public static LookupOptions MustBeInstance;
    public static LookupOptions MustNotBeInstance;
    public static LookupOptions MustNotBeReturnValueVariable;
    public static LookupOptions NoBaseClassLookup;
    public static LookupOptions IgnoreAccessibility;
    public static LookupOptions AllMethodsOfAnyArity;
    public static LookupOptions IgnoreExtensionMethods;
    public static LookupOptions EagerlyLookupExtensionMethods;
    public static LookupOptions MethodsOnly;
    public static LookupOptions UseBaseReferenceAccessibility;
    public static LookupOptions AttributeTypeOnly;
    public static LookupOptions MustNotBeLocalOrParameter;
    public static LookupOptions EventsOnly;
    public static LookupOptions NoSystemObjectLookupForInterfaces;
    public static LookupOptions IgnoreCorLibraryDuplicatedTypes;
    public static LookupOptions AllowIntrinsicAliases;
}
internal class Microsoft.CodeAnalysis.VisualBasic.LookupResult : object {
    private LookupResultKind _kind;
    private ArrayBuilder`1<Symbol> _symList;
    private DiagnosticInfo _diagInfo;
    private ObjectPool`1<LookupResult> _pool;
    private static ObjectPool`1<LookupResult> s_poolInstance;
    private static Func`2<ImmutableArray`1<Symbol>, AmbiguousSymbolDiagnostic> s_ambiguousInTypeError;
    private static Func`2<ImmutableArray`1<Symbol>, AmbiguousSymbolDiagnostic> s_ambiguousInNSError;
    public LookupResultKind Kind { get; }
    public bool StopFurtherLookup { get; }
    public bool IsGood { get; }
    public bool IsGoodOrAmbiguous { get; }
    public bool IsAmbiguous { get; }
    public bool IsWrongArity { get; }
    public bool HasDiagnostic { get; }
    public DiagnosticInfo Diagnostic { get; }
    public bool HasSymbol { get; }
    public bool HasSingleSymbol { get; }
    public ArrayBuilder`1<Symbol> Symbols { get; }
    public Symbol SingleSymbol { get; }
    public bool IsClear { get; }
    private static LookupResult();
    private LookupResult(ObjectPool`1<LookupResult> pool);
    public LookupResultKind get_Kind();
    public bool get_StopFurtherLookup();
    public bool get_IsGood();
    public bool get_IsGoodOrAmbiguous();
    public bool get_IsAmbiguous();
    public bool get_IsWrongArity();
    public bool get_HasDiagnostic();
    public DiagnosticInfo get_Diagnostic();
    public bool get_HasSymbol();
    public bool get_HasSingleSymbol();
    public ArrayBuilder`1<Symbol> get_Symbols();
    public Symbol get_SingleSymbol();
    private static ObjectPool`1<LookupResult> CreatePool();
    public static LookupResult GetInstance();
    public void Free();
    public void Clear();
    public bool get_IsClear();
    private void SetFrom(LookupResultKind kind, Symbol sym, DiagnosticInfo diagInfo);
    public void SetFrom(SingleLookupResult other);
    public void SetFrom(LookupResult other);
    public void SetFrom(Symbol s);
    public void SetFrom(ImmutableArray`1<Symbol> syms, Func`2<ImmutableArray`1<Symbol>, AmbiguousSymbolDiagnostic> generateAmbiguityDiagnostic);
    public void MergePrioritized(LookupResult other);
    public void MergePrioritized(SingleLookupResult other);
    public void MergeAmbiguous(LookupResult other, Func`2<ImmutableArray`1<Symbol>, AmbiguousSymbolDiagnostic> generateAmbiguityDiagnostic);
    public void MergeAmbiguous(SingleLookupResult other, Func`2<ImmutableArray`1<Symbol>, AmbiguousSymbolDiagnostic> generateAmbiguityDiagnostic);
    public static bool CanOverload(Symbol sym1, Symbol sym2);
    public bool AllSymbolsHaveOverloads();
    public void MergeOverloadedOrPrioritizedExtensionMethods(SingleLookupResult other);
    public void MergeOverloadedOrPrioritized(LookupResult other, bool checkIfCurrentHasOverloads);
    public void MergeOverloadedOrPrioritized(SingleLookupResult other, bool checkIfCurrentHasOverloads);
    public void MergeMembersOfTheSameType(SingleLookupResult other, bool imported);
    private void MergeOverloadedOrAmbiguousInTheSameType(SingleLookupResult other, bool imported);
    private bool AreEquivalentEnumConstants(Symbol symbol1, Symbol symbol2);
    private void CompactSymbols(int lost);
    private int RemoveAmbiguousSymbols(Symbol other, int ambiguous);
    public static int CompareAccessibilityOfSymbolsConflictingInSameContainer(Symbol first, Symbol second);
    public void MergeMembersOfTheSameNamespace(SingleLookupResult other, ModuleSymbol sourceModule, LookupOptions options);
    private static SymbolLocation GetSymbolLocation(Symbol sym, ModuleSymbol sourceModule, LookupOptions options);
    private int ResolveAmbiguityInTheSameNamespace(SingleLookupResult other, ModuleSymbol sourceModule, LookupOptions options);
    private static int ResolveAmbiguityInTheSameNamespace(Symbol first, Symbol second, ModuleSymbol sourceModule);
    private static int ResolveAmbiguityBetweenTypeAndMergedNamespaceInTheSameNamespace(NamespaceSymbol possiblyMergedNamespace, Symbol type);
    public void ReplaceSymbol(Symbol newSym);
    internal static LookupResultKind WorseResultKind(LookupResultKind resultKind1, LookupResultKind resultKind2);
}
internal enum Microsoft.CodeAnalysis.VisualBasic.LookupResultKind : Enum {
    public int value__;
    public static LookupResultKind Empty;
    public static LookupResultKind NotATypeOrNamespace;
    public static LookupResultKind NotAnAttributeType;
    public static LookupResultKind WrongArity;
    public static LookupResultKind NotCreatable;
    public static LookupResultKind Inaccessible;
    public static LookupResultKind NotReferencable;
    public static LookupResultKind NotAValue;
    public static LookupResultKind NotAVariable;
    public static LookupResultKind MustNotBeInstance;
    public static LookupResultKind MustBeInstance;
    public static LookupResultKind NotAnEvent;
    public static LookupResultKind LateBound;
    public static LookupResultKind EmptyAndStopLookup;
    public static LookupResultKind WrongArityAndStopLookup;
    public static LookupResultKind OverloadResolutionFailure;
    public static LookupResultKind NotAWithEventsMember;
    public static LookupResultKind Ambiguous;
    public static LookupResultKind MemberGroup;
    public static LookupResultKind Good;
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.LookupResultKindExtensions : object {
    [ExtensionAttribute]
public static CandidateReason ToCandidateReason(LookupResultKind resultKind);
}
internal class Microsoft.CodeAnalysis.VisualBasic.LookupSymbolsInfo : AbstractLookupSymbolsInfo`1<Symbol> {
    private static int s_poolSize;
    private static ObjectPool`1<LookupSymbolsInfo> s_pool;
    private static LookupSymbolsInfo();
    public void Free();
    public static LookupSymbolsInfo GetInstance();
}
internal class Microsoft.CodeAnalysis.VisualBasic.MemberModifiers : ValueType {
    private SourceMemberFlags _foundFlags;
    private SourceMemberFlags _computedFlags;
    public SourceMemberFlags FoundFlags { get; }
    public SourceMemberFlags ComputedFlags { get; }
    public SourceMemberFlags AllFlags { get; }
    public MemberModifiers(SourceMemberFlags foundFlags, SourceMemberFlags computedFlags);
    public SourceMemberFlags get_FoundFlags();
    public SourceMemberFlags get_ComputedFlags();
    public SourceMemberFlags get_AllFlags();
}
internal enum Microsoft.CodeAnalysis.VisualBasic.MemberResolutionKind : Enum {
    public int value__;
    public static MemberResolutionKind Applicable;
    public static MemberResolutionKind HasUseSiteError;
    public static MemberResolutionKind Ambiguous;
    public static MemberResolutionKind BadGenericArity;
    public static MemberResolutionKind ArgumentCountMismatch;
    public static MemberResolutionKind TypeInferenceFailed;
    public static MemberResolutionKind ArgumentMismatch;
    public static MemberResolutionKind GenericConstraintsViolated;
    public static MemberResolutionKind RequiresNarrowing;
    public static MemberResolutionKind RequiresNarrowingNotFromObject;
    public static MemberResolutionKind ExtensionMethodVsInstanceMethod;
    public static MemberResolutionKind Shadowed;
    public static MemberResolutionKind LessApplicable;
}
internal class Microsoft.CodeAnalysis.VisualBasic.MemberResolutionResult`1 : ValueType {
    private CandidateAnalysisResult _candidate;
    private bool _isValid;
    public TMember Member { get; }
    public MemberResolutionKind Resolution { get; }
    public bool IsValid { get; }
    internal bool IsExpandedParamArrayForm { get; }
    internal MemberResolutionResult`1(CandidateAnalysisResult candidate, bool isValid);
    public TMember get_Member();
    public MemberResolutionKind get_Resolution();
    public bool get_IsValid();
    internal bool get_IsExpandedParamArrayForm();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.MemberSemanticModel : VBSemanticModel {
    private VisualBasicSyntaxNode _root;
    private Binder _rootBinder;
    private SyntaxTreeSemanticModel _parentSemanticModelOpt;
    private int _speculatedPosition;
    private bool _ignoresAccessibility;
    private ReaderWriterLockSlim _rwLock;
    private SmallDictionary`2<VisualBasicSyntaxNode, ImmutableArray`1<BoundNode>> _guardedNodeMap;
    private Dictionary`2<VisualBasicSyntaxNode, ImmutableArray`1<Binder>> _guardedQueryBindersMap;
    private Dictionary`2<FieldInitializerSyntax, AnonymousTypeFieldInitializerBinder> _guardedAnonymousTypeBinderMap;
    private DiagnosticBag _guardedDiagnostics;
    internal Binder RootBinder { get; }
    internal VisualBasicSyntaxNode Root { get; }
    public bool IsSpeculativeSemanticModel { get; }
    public int OriginalPositionForSpeculation { get; }
    public SemanticModel ParentModel { get; }
    public bool IgnoresAccessibility { get; }
    public VisualBasicCompilation Compilation { get; }
    internal Symbol MemberSymbol { get; }
    public SyntaxTree SyntaxTree { get; }
    internal MemberSemanticModel(VisualBasicSyntaxNode root, Binder rootBinder, SyntaxTreeSemanticModel parentSemanticModelOpt, int speculatedPosition, bool ignoreAccessibility);
    internal Binder get_RootBinder();
    internal sealed virtual VisualBasicSyntaxNode get_Root();
    public sealed virtual bool get_IsSpeculativeSemanticModel();
    public sealed virtual int get_OriginalPositionForSpeculation();
    public sealed virtual SemanticModel get_ParentModel();
    public sealed virtual bool get_IgnoresAccessibility();
    internal sealed virtual Binder GetEnclosingBinder(int position);
    private Binder GetEnclosingBinder(VisualBasicSyntaxNode node);
    internal virtual BoundNode GetBoundRoot();
    public virtual Conversion ClassifyConversion(ExpressionSyntax expression, ITypeSymbol destination);
    internal BoundNode GetUpperBoundNode(VisualBasicSyntaxNode node);
    internal BoundNode GetLowerBoundNode(VisualBasicSyntaxNode node);
    protected VisualBasicSyntaxNode GetBindableParent(VisualBasicSyntaxNode node);
    internal BoundNodeSummary GetBoundNodeSummary(VisualBasicSyntaxNode node);
    internal virtual BoundNodeSummary GetInvokeSummaryForRaiseEvent(RaiseEventStatementSyntax node);
    private static BoundNode UnwrapRaiseEvent(BoundNode node);
    private static bool IsStandaloneStatement(StatementSyntax node);
    public virtual ImmutableArray`1<Diagnostic> GetSyntaxDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetDeclarationDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetMethodBodyDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public virtual INamedTypeSymbol GetDeclaredSymbol(TypeStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual INamedTypeSymbol GetDeclaredSymbol(EnumStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual INamespaceSymbol GetDeclaredSymbol(NamespaceStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    internal virtual ISymbol GetDeclaredSymbol(MethodBaseSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IParameterSymbol GetDeclaredSymbol(ParameterSyntax parameter, CancellationToken cancellationToken);
    public virtual IAliasSymbol GetDeclaredSymbol(SimpleImportsClauseSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual ITypeParameterSymbol GetDeclaredSymbol(TypeParameterSyntax typeParameter, CancellationToken cancellationToken);
    public virtual IFieldSymbol GetDeclaredSymbol(EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual ISymbol GetDeclaredSymbol(ModifiedIdentifierSyntax identifierSyntax, CancellationToken cancellationToken);
    public virtual INamedTypeSymbol GetDeclaredSymbol(AnonymousObjectCreationExpressionSyntax anonymousObjectCreationExpressionSyntax, CancellationToken cancellationToken);
    public virtual IPropertySymbol GetDeclaredSymbol(FieldInitializerSyntax fieldInitializerSyntax, CancellationToken cancellationToken);
    public virtual IRangeVariableSymbol GetDeclaredSymbol(CollectionRangeVariableSyntax rangeVariableSyntax, CancellationToken cancellationToken);
    public virtual IRangeVariableSymbol GetDeclaredSymbol(ExpressionRangeVariableSyntax rangeVariableSyntax, CancellationToken cancellationToken);
    public virtual IRangeVariableSymbol GetDeclaredSymbol(AggregationRangeVariableSyntax rangeVariableSyntax, CancellationToken cancellationToken);
    internal virtual ImmutableArray`1<ISymbol> GetDeclaredSymbols(FieldDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    internal virtual ForEachStatementInfo GetForEachStatementInfoWorker(ForEachBlockSyntax node);
    internal virtual SymbolInfo GetAttributeSymbolInfo(AttributeSyntax attribute, CancellationToken cancellationToken);
    internal virtual VisualBasicTypeInfo GetAttributeTypeInfo(AttributeSyntax attribute, CancellationToken cancellationToken);
    internal virtual ImmutableArray`1<Symbol> GetAttributeMemberGroup(AttributeSyntax attribute, CancellationToken cancellationToken);
    internal virtual SymbolInfo GetExpressionSymbolInfo(ExpressionSyntax node, SymbolInfoOptions options, CancellationToken cancellationToken);
    internal virtual IOperation GetOperationWorker(VisualBasicSyntaxNode node, GetOperationOptions options, CancellationToken cancellationToken);
    internal virtual VisualBasicTypeInfo GetExpressionTypeInfo(ExpressionSyntax node, CancellationToken cancellationToken);
    internal virtual ImmutableArray`1<Symbol> GetExpressionMemberGroup(ExpressionSyntax node, CancellationToken cancellationToken);
    internal virtual ConstantValue GetExpressionConstantValue(ExpressionSyntax node, CancellationToken cancellationToken);
    internal virtual SymbolInfo GetCollectionInitializerAddSymbolInfo(ObjectCreationExpressionSyntax collectionInitializer, ExpressionSyntax node, CancellationToken cancellationToken);
    internal virtual SymbolInfo GetCrefReferenceSymbolInfo(CrefReferenceSyntax crefReference, SymbolInfoOptions options, CancellationToken cancellationToken);
    internal virtual SymbolInfo GetQueryClauseSymbolInfo(QueryClauseSyntax node, CancellationToken cancellationToken);
    internal virtual SymbolInfo GetLetClauseSymbolInfo(ExpressionRangeVariableSyntax node, CancellationToken cancellationToken);
    internal virtual SymbolInfo GetOrderingSymbolInfo(OrderingSyntax node, CancellationToken cancellationToken);
    internal virtual AggregateClauseSymbolInfo GetAggregateClauseSymbolInfoWorker(AggregateClauseSyntax node, CancellationToken cancellationToken);
    internal virtual CollectionRangeVariableSymbolInfo GetCollectionRangeVariableSymbolInfoWorker(CollectionRangeVariableSyntax node, CancellationToken cancellationToken);
    internal sealed virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, TypeSyntax type, SpeculativeBindingOption bindingOption, SemanticModel& speculativeModel);
    internal sealed virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, RangeArgumentSyntax rangeArgument, SemanticModel& speculativeModel);
    internal void CacheBoundNodes(BoundNode boundNode, VisualBasicSyntaxNode thisSyntaxNodeOnly);
    public virtual VisualBasicCompilation get_Compilation();
    internal Symbol get_MemberSymbol();
    public virtual SyntaxTree get_SyntaxTree();
    private void EnsureFullyBoundIfImplicitVariablesAllowed();
    private ImmutableArray`1<BoundNode> GuardedGetBoundNodesFromMap(VisualBasicSyntaxNode node);
    private Binder GetEnclosingBinderInternal(Binder memberBinder, VisualBasicSyntaxNode binderRoot, VisualBasicSyntaxNode node, int position);
    private bool InQueryInterior(VisualBasicSyntaxNode node, int position, Binder& binder);
    private Binder GetAggregateClauseLambdaBinder(AggregateClauseSyntax aggregate, int position);
    private Binder GetGroupJoinClauseLambdaBinder(GroupJoinClauseSyntax join, int position);
    private Binder GetJoinClauseLambdaBinder(JoinClauseSyntax join, int position);
    private Binder GetFromClauseLambdaBinder(FromClauseSyntax from, int position);
    private Binder GetCollectionRangeVariablesLambdaBinder(SeparatedSyntaxList`1<CollectionRangeVariableSyntax> variables, int position);
    private Binder GetLetClauseLambdaBinder(LetClauseSyntax let, int position);
    private Binder GetGroupByClauseLambdaBinder(GroupByClauseSyntax groupBy, int position);
    private Binder GetFunctionAggregationLambdaBinder(FunctionAggregationSyntax func, int position);
    private Binder GetSingleLambdaClauseLambdaBinder(QueryClauseSyntax operatorSyntax, SyntaxToken operatorKeyWord, int position);
    private ImmutableArray`1<Binder> GetQueryClauseLambdaBinders(VisualBasicSyntaxNode node);
    private bool InAnonymousTypeInitializerInterior(VisualBasicSyntaxNode node, int position, Binder& binder);
    private bool InWithStatementExpressionInterior(VisualBasicSyntaxNode node);
    private LambdaBodyBinder GetLambdaBodyBinder(LambdaExpressionSyntax lambda);
    private BoundLambda GetBoundLambda(LambdaExpressionSyntax lambda);
    [ConditionalAttribute("DEBUG")]
private void AssertIfShouldHaveFound(VisualBasicSyntaxNode node);
    internal ImmutableArray`1<BoundNode> GetBoundNodes(VisualBasicSyntaxNode node);
    private bool IsNonExpressionCollectionInitializer(VisualBasicSyntaxNode syntax);
    private void GuardedIncrementalBind(VisualBasicSyntaxNode bindingRoot, Binder enclosingBinder);
    private VisualBasicSyntaxNode GetBindingRoot(VisualBasicSyntaxNode node);
    internal virtual AwaitExpressionInfo GetAwaitExpressionInfoWorker(AwaitExpressionSyntax awaitExpression, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.MessageProvider : CommonMessageProvider {
    public static MessageProvider Instance;
    public string CodePrefix { get; }
    public Type ErrorCodeType { get; }
    public int ERR_FailedToCreateTempFile { get; }
    public int ERR_ExpectedSingleScript { get; }
    public int ERR_OpenResponseFile { get; }
    public int ERR_InvalidPathMap { get; }
    public int FTL_InputFileNameTooLong { get; }
    public int ERR_FileNotFound { get; }
    public int ERR_NoSourceFile { get; }
    public int ERR_CantOpenFileWrite { get; }
    public int ERR_OutputWriteFailed { get; }
    public int WRN_NoConfigNotOnCommandLine { get; }
    public int ERR_BinaryFile { get; }
    public int WRN_AnalyzerCannotBeCreated { get; }
    public int WRN_NoAnalyzerInAssembly { get; }
    public int WRN_UnableToLoadAnalyzer { get; }
    public int INF_UnableToLoadSomeTypesInAnalyzer { get; }
    public int ERR_CantReadRulesetFile { get; }
    public int ERR_CompileCancelled { get; }
    public int ERR_BadCompilationOptionValue { get; }
    public int ERR_MutuallyExclusiveOptions { get; }
    public int ERR_InvalidDebugInformationFormat { get; }
    public int ERR_InvalidOutputName { get; }
    public int ERR_InvalidFileAlignment { get; }
    public int ERR_InvalidSubsystemVersion { get; }
    public int ERR_MetadataFileNotAssembly { get; }
    public int ERR_MetadataFileNotModule { get; }
    public int ERR_InvalidAssemblyMetadata { get; }
    public int ERR_InvalidModuleMetadata { get; }
    public int ERR_ErrorOpeningAssemblyFile { get; }
    public int ERR_ErrorOpeningModuleFile { get; }
    public int ERR_MetadataFileNotFound { get; }
    public int ERR_MetadataReferencesNotSupported { get; }
    public int ERR_LinkedNetmoduleMetadataMustProvideFullPEImage { get; }
    public int ERR_CantReadResource { get; }
    public int ERR_PublicKeyFileFailure { get; }
    public int ERR_PublicKeyContainerFailure { get; }
    public int ERR_OptionMustBeAbsolutePath { get; }
    public int ERR_CantOpenWin32Resource { get; }
    public int ERR_CantOpenWin32Manifest { get; }
    public int ERR_CantOpenWin32Icon { get; }
    public int ERR_ErrorBuildingWin32Resource { get; }
    public int ERR_BadWin32Resource { get; }
    public int ERR_ResourceFileNameNotUnique { get; }
    public int ERR_ResourceNotUnique { get; }
    public int ERR_ResourceInModule { get; }
    public int ERR_PermissionSetAttributeFileReadError { get; }
    public int WRN_PdbUsingNameTooLong { get; }
    public int WRN_PdbLocalNameTooLong { get; }
    public int ERR_PdbWritingFailed { get; }
    public int ERR_MetadataNameTooLong { get; }
    public int ERR_EncReferenceToAddedMember { get; }
    public int ERR_TooManyUserStrings { get; }
    public int ERR_PeWritingFailure { get; }
    public int ERR_ModuleEmitFailure { get; }
    public int ERR_EncUpdateFailedMissingAttribute { get; }
    private static MessageProvider();
    private sealed virtual override void WriteTo(ObjectWriter writer);
    private sealed virtual override Func`2<ObjectReader, object> GetReader();
    public virtual string get_CodePrefix();
    public virtual string LoadMessage(int code, CultureInfo language);
    public virtual LocalizableString GetMessageFormat(int code);
    public virtual LocalizableString GetDescription(int code);
    public virtual LocalizableString GetTitle(int code);
    public virtual string GetHelpLink(int code);
    public virtual string GetCategory(int code);
    public virtual DiagnosticSeverity GetSeverity(int code);
    public virtual int GetWarningLevel(int code);
    public virtual Type get_ErrorCodeType();
    public virtual Diagnostic CreateDiagnostic(int code, Location location, Object[] args);
    public virtual string GetErrorDisplayString(ISymbol symbol);
    public virtual string GetMessagePrefix(string id, DiagnosticSeverity severity, bool isWarningAsError, CultureInfo culture);
    public virtual ReportDiagnostic GetDiagnosticReport(DiagnosticInfo diagnosticInfo, CompilationOptions options);
    public virtual int get_ERR_FailedToCreateTempFile();
    public virtual int get_ERR_ExpectedSingleScript();
    public virtual int get_ERR_OpenResponseFile();
    public virtual int get_ERR_InvalidPathMap();
    public virtual int get_FTL_InputFileNameTooLong();
    public virtual int get_ERR_FileNotFound();
    public virtual int get_ERR_NoSourceFile();
    public virtual int get_ERR_CantOpenFileWrite();
    public virtual int get_ERR_OutputWriteFailed();
    public virtual int get_WRN_NoConfigNotOnCommandLine();
    public virtual int get_ERR_BinaryFile();
    public virtual int get_WRN_AnalyzerCannotBeCreated();
    public virtual int get_WRN_NoAnalyzerInAssembly();
    public virtual int get_WRN_UnableToLoadAnalyzer();
    public virtual int get_INF_UnableToLoadSomeTypesInAnalyzer();
    public virtual int get_ERR_CantReadRulesetFile();
    public virtual int get_ERR_CompileCancelled();
    public virtual int get_ERR_BadCompilationOptionValue();
    public virtual int get_ERR_MutuallyExclusiveOptions();
    public virtual int get_ERR_InvalidDebugInformationFormat();
    public virtual int get_ERR_InvalidOutputName();
    public virtual int get_ERR_InvalidFileAlignment();
    public virtual int get_ERR_InvalidSubsystemVersion();
    public virtual int get_ERR_MetadataFileNotAssembly();
    public virtual int get_ERR_MetadataFileNotModule();
    public virtual int get_ERR_InvalidAssemblyMetadata();
    public virtual int get_ERR_InvalidModuleMetadata();
    public virtual int get_ERR_ErrorOpeningAssemblyFile();
    public virtual int get_ERR_ErrorOpeningModuleFile();
    public virtual int get_ERR_MetadataFileNotFound();
    public virtual int get_ERR_MetadataReferencesNotSupported();
    public virtual int get_ERR_LinkedNetmoduleMetadataMustProvideFullPEImage();
    public virtual void ReportDuplicateMetadataReferenceStrong(DiagnosticBag diagnostics, Location location, MetadataReference reference, AssemblyIdentity identity, MetadataReference equivalentReference, AssemblyIdentity equivalentIdentity);
    public virtual void ReportDuplicateMetadataReferenceWeak(DiagnosticBag diagnostics, Location location, MetadataReference reference, AssemblyIdentity identity, MetadataReference equivalentReference, AssemblyIdentity equivalentIdentity);
    public virtual int get_ERR_CantReadResource();
    public virtual int get_ERR_PublicKeyFileFailure();
    public virtual int get_ERR_PublicKeyContainerFailure();
    public virtual int get_ERR_OptionMustBeAbsolutePath();
    public virtual int get_ERR_CantOpenWin32Resource();
    public virtual int get_ERR_CantOpenWin32Manifest();
    public virtual int get_ERR_CantOpenWin32Icon();
    public virtual int get_ERR_ErrorBuildingWin32Resource();
    public virtual int get_ERR_BadWin32Resource();
    public virtual int get_ERR_ResourceFileNameNotUnique();
    public virtual int get_ERR_ResourceNotUnique();
    public virtual int get_ERR_ResourceInModule();
    public virtual int get_ERR_PermissionSetAttributeFileReadError();
    public virtual void ReportInvalidAttributeArgument(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int parameterIndex, AttributeData attribute);
    public virtual void ReportInvalidNamedArgument(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int namedArgumentIndex, ITypeSymbol attributeClass, string parameterName);
    public virtual void ReportParameterNotValidForType(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int namedArgumentIndex);
    public virtual void ReportMarshalUnmanagedTypeNotValidForFields(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int parameterIndex, string unmanagedTypeName, AttributeData attribute);
    public virtual void ReportMarshalUnmanagedTypeOnlyValidForFields(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int parameterIndex, string unmanagedTypeName, AttributeData attribute);
    public virtual void ReportAttributeParameterRequired(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, string parameterName);
    public virtual void ReportAttributeParameterRequired(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, string parameterName1, string parameterName2);
    public virtual int get_WRN_PdbUsingNameTooLong();
    public virtual int get_WRN_PdbLocalNameTooLong();
    public virtual int get_ERR_PdbWritingFailed();
    public virtual int get_ERR_MetadataNameTooLong();
    public virtual int get_ERR_EncReferenceToAddedMember();
    public virtual int get_ERR_TooManyUserStrings();
    public virtual int get_ERR_PeWritingFailure();
    public virtual int get_ERR_ModuleEmitFailure();
    public virtual int get_ERR_EncUpdateFailedMissingAttribute();
}
internal class Microsoft.CodeAnalysis.VisualBasic.MethodBodyBinder : SubOrFunctionBodyBinder {
    private LocalSymbol _functionValue;
    public bool IsInQuery { get; }
    internal bool SuppressCallerInfo { get; }
    public MethodBodyBinder(MethodSymbol methodSymbol, VisualBasicSyntaxNode root, Binder containingBinder);
    private LocalSymbol CreateFunctionValueLocal(MethodSymbol methodSymbol, VisualBasicSyntaxNode root);
    public virtual LocalSymbol GetLocalForFunctionValue();
    public virtual bool get_IsInQuery();
    internal virtual bool get_SuppressCallerInfo();
}
internal class Microsoft.CodeAnalysis.VisualBasic.MethodBodySemanticModel : MemberSemanticModel {
    private MethodBodySemanticModel(VisualBasicSyntaxNode root, Binder binder, SyntaxTreeSemanticModel parentSemanticModelOpt, int speculatedPosition, bool ignoreAccessibility);
    internal static MethodBodySemanticModel Create(SubOrFunctionBodyBinder binder, bool ignoreAccessibility);
    internal static MethodBodySemanticModel CreateSpeculative(SyntaxTreeSemanticModel parentSemanticModel, VisualBasicSyntaxNode root, Binder binder, int position);
    internal virtual bool TryGetSpeculativeSemanticModelForMethodBodyCore(SyntaxTreeSemanticModel parentModel, int position, MethodBlockBaseSyntax method, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, ExecutableStatementSyntax statement, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, EqualsValueSyntax initializer, SemanticModel& speculativeModel);
}
internal class Microsoft.CodeAnalysis.VisualBasic.MethodCompiler : VisualBasicSymbolVisitor {
    private VisualBasicCompilation _compilation;
    private CancellationToken _cancellationToken;
    private bool _emittingPdb;
    private DiagnosticBag _diagnostics;
    private bool _hasDeclarationErrors;
    private NamespaceScopeBuilder _namespaceScopeBuilder;
    private PEModuleBuilder _moduleBeingBuiltOpt;
    private Predicate`1<Symbol> _filterOpt;
    private DebugDocumentProvider _debugDocumentProvider;
    private bool _doEmitPhase;
    private ConcurrentStack`1<Task> _compilerTasks;
    private bool _globalHasErrors;
    private bool GlobalHasErrors { get; }
    private bool DoEmitPhase { get; }
    private MethodCompiler(VisualBasicCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, bool emittingPdb, bool doEmitPhase, bool hasDeclarationErrors, DiagnosticBag diagnostics, Predicate`1<Symbol> filter, CancellationToken cancellationToken);
    private bool get_GlobalHasErrors();
    private void SetGlobalErrorIfTrue(bool arg);
    private static bool IsDefinedOrImplementedInSourceTree(Symbol symbol, SyntaxTree tree, Nullable`1<TextSpan> span);
    public static void GetCompileDiagnostics(VisualBasicCompilation compilation, NamespaceSymbol root, SyntaxTree tree, Nullable`1<TextSpan> filterSpanWithinTree, bool hasDeclarationErrors, DiagnosticBag diagnostics, bool doEmitPhase, CancellationToken cancellationToken);
    internal static void CompileMethodBodies(VisualBasicCompilation compilation, PEModuleBuilder moduleBeingBuiltOpt, bool emittingPdb, bool hasDeclarationErrors, Predicate`1<Symbol> filter, DiagnosticBag diagnostics, CancellationToken cancellationToken);
    private static MethodSymbol GetEntryPoint(VisualBasicCompilation compilation, PEModuleBuilder moduleBeingBuilt, DiagnosticBag diagnostics, CancellationToken cancellationToken);
    private void WaitForWorkers();
    private void ProcessEmbeddedMethods();
    private void VisitEmbeddedMethod(MethodSymbol method);
    [ConditionalAttribute("DEBUG")]
private void AssertAllInitializersAreConstants(ImmutableArray`1<ImmutableArray`1<FieldOrPropertyInitializer>> initializers);
    private bool get_DoEmitPhase();
    public virtual void VisitNamespace(NamespaceSymbol symbol);
    private Task CompileNamespaceAsTask(NamespaceSymbol symbol);
    private void CompileNamespace(NamespaceSymbol symbol);
    public virtual void VisitNamedType(NamedTypeSymbol symbol);
    private Task CompileNamedTypeAsTask(NamedTypeSymbol symbol, Predicate`1<Symbol> filter);
    private void CompileNamedType(NamedTypeSymbol containingType, Predicate`1<Symbol> filter);
    private void CreateExplicitInterfaceImplementationStubs(TypeCompilationState compilationState, MethodSymbol method);
    private static MethodSymbol GetDesignerInitializeComponentMethod(SourceMemberContainerTypeSymbol sourceTypeSymbol);
    private void CompileSynthesizedMethods(PrivateImplementationDetails privateImplClass);
    private void CompileSynthesizedMethods(ImmutableArray`1<NamedTypeSymbol> additionalTypes);
    private void CompileSynthesizedMethods(TypeCompilationState compilationState);
    private void DetectAndReportCyclesInConstructorCalls(Dictionary`2<MethodSymbol, MethodSymbol> constructorCallMap, DiagnosticBag diagnostics);
    private void ReportConstructorCycles(int startsAt, int endsAt, ArrayBuilder`1<MethodSymbol> path, DiagnosticBag diagnostics);
    internal static bool CanBindMethod(MethodSymbol method);
    private void CompileMethod(MethodSymbol method, int methodOrdinal, Int32& withEventPropertyIdDispenser, Int32& delegateRelaxationIdDispenser, Predicate`1<Symbol> filter, TypeCompilationState compilationState, ProcessedFieldOrPropertyInitializers processedInitializers, Binder containingTypeBinder, SynthesizedSubmissionFields previousSubmissionFields, MethodSymbol& referencedConstructor);
    private void CreateSyntheticWithEventOverridesIfNeeded(ImmutableArray`1<HandledEvent> handledEvents, Int32& delegateRelaxationIdDispenser, Int32& withEventPropertyIdDispenser, TypeCompilationState compilationState, Binder containingTypeBinder, DiagnosticBag diagnostics, SynthesizedSubmissionFields previousSubmissionFields);
    private static MethodSymbol TryGetMethodCalledInBoundExpressionStatement(BoundExpressionStatement stmt);
    private void LowerAndEmitMethod(MethodSymbol method, int methodOrdinal, BoundBlock block, Binder binderOpt, TypeCompilationState compilationState, DiagnosticBag diagsForCurrentMethod, ProcessedFieldOrPropertyInitializers processedInitializers, SynthesizedSubmissionFields previousSubmissionFields, MethodSymbol constructorToInject, Int32& delegateRelaxationIdDispenser);
    internal static MethodBody GenerateMethodBody(PEModuleBuilder moduleBuilder, MethodSymbol method, int methodOrdinal, BoundStatement block, ImmutableArray`1<LambdaDebugInfo> lambdaDebugInfo, ImmutableArray`1<ClosureDebugInfo> closureDebugInfo, StateMachineTypeSymbol stateMachineTypeOpt, VariableSlotAllocator variableSlotAllocatorOpt, DebugDocumentProvider debugDocumentProvider, DiagnosticBag diagnostics, bool emittingPdb);
    private static void GetStateMachineSlotDebugInfo(PEModuleBuilder moduleBuilder, IEnumerable`1<IFieldDefinition> fieldDefs, VariableSlotAllocator variableSlotAllocatorOpt, DiagnosticBag diagnostics, ImmutableArray`1& hoistedVariableSlots, ImmutableArray`1& awaiterSlots);
    private static BoundBlock BindAndAnalyzeMethodBody(MethodSymbol method, TypeCompilationState compilationState, DiagnosticBag diagnostics, Binder containingTypeBinder, MethodSymbol& referencedConstructor, Boolean& injectDefaultConstructorCall, Binder& methodBodyBinder);
    private static MethodSymbol FindConstructorToCallByDefault(MethodSymbol constructor, DiagnosticBag diagnostics, Binder binderForAccessibilityCheckOpt);
    private static BoundExpressionStatement BindDefaultConstructorInitializer(MethodSymbol constructor, MethodSymbol constructorToCall, DiagnosticBag diagnostics, Binder binderOpt);
    internal static BoundExpressionStatement BindDefaultConstructorInitializer(MethodSymbol constructor, DiagnosticBag diagnostics);
    private static DebugSourceDocument CreateDebugDocumentForFile(string normalizedPath);
    private static bool PassesFilter(Predicate`1<Symbol> filterOpt, Symbol symbol);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.VisualBasic.MethodConversionKind : Enum {
    public int value__;
    public static MethodConversionKind Identity;
    public static MethodConversionKind OneArgumentIsVbOrBoxWidening;
    public static MethodConversionKind OneArgumentIsClrWidening;
    public static MethodConversionKind OneArgumentIsNarrowing;
    public static MethodConversionKind ReturnIsWidening;
    public static MethodConversionKind ReturnIsClrNarrowing;
    public static MethodConversionKind ReturnIsIsVbOrBoxNarrowing;
    public static MethodConversionKind ReturnValueIsDropped;
    public static MethodConversionKind AllArgumentsIgnored;
    public static MethodConversionKind ExcessOptionalArgumentsOnTarget;
    public static MethodConversionKind Error_ByRefByValMismatch;
    public static MethodConversionKind Error_Unspecified;
    public static MethodConversionKind Error_IllegalToIgnoreAllArguments;
    public static MethodConversionKind Error_RestrictedType;
    public static MethodConversionKind Error_SubToFunction;
    public static MethodConversionKind Error_ReturnTypeMismatch;
    public static MethodConversionKind Error_OverloadResolution;
    public static MethodConversionKind AllErrorReasons;
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.MethodToClassRewriter`1 : BoundTreeRewriterWithStackGuard {
    protected Dictionary`2<Symbol, TProxy> Proxies;
    protected Dictionary`2<LocalSymbol, LocalSymbol> LocalMap;
    protected Dictionary`2<ParameterSymbol, ParameterSymbol> ParameterMap;
    protected Dictionary`2<BoundValuePlaceholderBase, BoundExpression> PlaceholderReplacementMap;
    protected TypeCompilationState CompilationState;
    protected DiagnosticBag Diagnostics;
    protected VariableSlotAllocator SlotAllocatorOpt;
    protected bool PreserveOriginalLocals;
    protected TypeSubstitution TypeMap { get; }
    protected MethodSymbol CurrentMethod { get; }
    protected MethodSymbol TopLevelMethod { get; }
    protected bool IsInExpressionLambda { get; }
    protected MethodToClassRewriter`1(VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics, bool preserveOriginalLocals);
    private MethodSymbol SubstituteMethodForMyBaseOrMyClassCall(BoundExpression receiverOpt, MethodSymbol originalMethodBeingCalled);
    private MethodSymbol GetOrCreateMyBaseOrMyClassWrapperFunction(BoundExpression receiver, MethodSymbol method);
    protected abstract virtual TypeSubstitution get_TypeMap();
    internal abstract virtual BoundExpression FramePointer(VisualBasicSyntaxNode syntax, NamedTypeSymbol frameClass);
    protected abstract virtual MethodSymbol get_CurrentMethod();
    protected abstract virtual MethodSymbol get_TopLevelMethod();
    protected abstract virtual bool get_IsInExpressionLambda();
    public virtual BoundNode VisitLocalDeclaration(BoundLocalDeclaration node);
    public sealed virtual TypeSymbol VisitType(TypeSymbol type);
    public sealed virtual BoundNode VisitMethodInfo(BoundMethodInfo node);
    public virtual BoundNode VisitPropertyAccess(BoundPropertyAccess node);
    public virtual BoundNode VisitCall(BoundCall node);
    private bool ShouldRewriteMethodSymbol(BoundExpression originalReceiver, BoundExpression rewrittenReceiverOpt, MethodSymbol newMethod);
    public sealed virtual BoundNode VisitParameter(BoundParameter node);
    protected abstract virtual BoundNode MaterializeProxy(BoundExpression origExpression, TProxy proxy);
    public sealed virtual BoundNode VisitLocal(BoundLocal node);
    public virtual BoundNode VisitFieldInfo(BoundFieldInfo node);
    public virtual BoundNode VisitFieldAccess(BoundFieldAccess node);
    public virtual BoundNode VisitDelegateCreationExpression(BoundDelegateCreationExpression node);
    public virtual BoundNode VisitObjectCreationExpression(BoundObjectCreationExpression node);
    private MethodSymbol VisitMethodSymbol(MethodSymbol method);
    private PropertySymbol VisitPropertySymbol(PropertySymbol property);
    private FieldSymbol VisitFieldSymbol(FieldSymbol field);
    public virtual BoundNode VisitBlock(BoundBlock node);
    public virtual BoundNode VisitSequence(BoundSequence node);
    public abstract virtual BoundNode VisitCatchBlock(BoundCatchBlock node);
    protected BoundBlock RewriteBlock(BoundBlock node, ArrayBuilder`1<BoundExpression> prologue, ArrayBuilder`1<LocalSymbol> newLocals);
    protected BoundBlock RewriteBlock(BoundBlock node);
    protected LocalSymbol CreateReplacementLocalOrReturnSelf(LocalSymbol originalLocal, TypeSymbol newType, bool onlyReplaceIfFunctionValue, Boolean& wasReplaced);
    protected BoundSequence RewriteSequence(BoundSequence node);
    protected BoundSequence RewriteSequence(BoundSequence node, ArrayBuilder`1<BoundExpression> prologue, ArrayBuilder`1<LocalSymbol> newLocals);
    public virtual BoundNode VisitRValuePlaceholder(BoundRValuePlaceholder node);
    public virtual BoundNode VisitLValuePlaceholder(BoundLValuePlaceholder node);
    public virtual BoundNode VisitAwaitOperator(BoundAwaitOperator node);
    public virtual BoundNode VisitSelectStatement(BoundSelectStatement node);
    public virtual BoundNode VisitUserDefinedShortCircuitingOperator(BoundUserDefinedShortCircuitingOperator node);
}
internal class Microsoft.CodeAnalysis.VisualBasic.MethodTypeParametersBinder : Binder {
    private ImmutableArray`1<TypeParameterSymbol> _typeParameters;
    public MethodTypeParametersBinder(Binder containingBinder, ImmutableArray`1<TypeParameterSymbol> typeParameters);
    internal virtual void LookupInSingleBinder(LookupResult lookupResult, string name, int arity, LookupOptions options, Binder originalBinder, HashSet`1& useSiteDiagnostics);
    internal virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
}
internal class Microsoft.CodeAnalysis.VisualBasic.ModuleCompilationState : ModuleCompilationState`2<NamedTypeSymbol, MethodSymbol> {
}
internal class Microsoft.CodeAnalysis.VisualBasic.MyTemplateLocation : VBLocation {
    private TextSpan _span;
    private SyntaxTree _tree;
    public LocationKind Kind { get; }
    internal TextSpan PossiblyEmbeddedOrMySourceSpan { get; }
    internal SyntaxTree PossiblyEmbeddedOrMySourceTree { get; }
    public MyTemplateLocation(SyntaxTree tree, TextSpan span);
    public virtual LocationKind get_Kind();
    internal virtual TextSpan get_PossiblyEmbeddedOrMySourceSpan();
    internal virtual SyntaxTree get_PossiblyEmbeddedOrMySourceTree();
    public bool Equals(MyTemplateLocation other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.VisualBasic.NamedTypeBinder : Binder {
    private NamedTypeSymbol _typeSymbol;
    public NamespaceOrTypeSymbol ContainingNamespaceOrType { get; }
    public NamedTypeSymbol ContainingType { get; }
    public Symbol ContainingMember { get; }
    public bool IsInQuery { get; }
    public NamedTypeBinder(Binder containingBinder, NamedTypeSymbol typeSymbol);
    public virtual Binder GetBinder(VisualBasicSyntaxNode node);
    public virtual Binder GetBinder(SyntaxList`1<StatementSyntax> stmtList);
    public virtual NamespaceOrTypeSymbol get_ContainingNamespaceOrType();
    internal virtual void LookupInSingleBinder(LookupResult lookupResult, string name, int arity, LookupOptions options, Binder originalBinder, HashSet`1& useSiteDiagnostics);
    protected virtual void CollectProbableExtensionMethodsInSingleBinder(string name, ArrayBuilder`1<MethodSymbol> methods, Binder originalBinder);
    protected virtual void AddExtensionMethodLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
    internal virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
    private void LookupTypeParameter(LookupResult lookupResult, string name, int arity, LookupOptions options, Binder originalBinder, HashSet`1& useSiteDiagnostics);
    public virtual AccessCheckResult CheckAccessibility(Symbol sym, HashSet`1& useSiteDiagnostics, TypeSymbol accessThroughType, ConsList`1<Symbol> basesBeingResolved);
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual Symbol get_ContainingMember();
    public virtual bool get_IsInQuery();
}
internal class Microsoft.CodeAnalysis.VisualBasic.NamespaceBinder : Binder {
    private NamespaceSymbol _nsSymbol;
    public NamespaceOrTypeSymbol ContainingNamespaceOrType { get; }
    public NamespaceSymbol NamespaceSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public Symbol ContainingMember { get; }
    public bool IsInQuery { get; }
    public NamespaceBinder(Binder containingBinder, NamespaceSymbol nsSymbol);
    public virtual NamespaceOrTypeSymbol get_ContainingNamespaceOrType();
    public NamespaceSymbol get_NamespaceSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual Symbol get_ContainingMember();
    public virtual bool get_IsInQuery();
    internal virtual void LookupInSingleBinder(LookupResult lookupResult, string name, int arity, LookupOptions options, Binder originalBinder, HashSet`1& useSiteDiagnostics);
    protected virtual void CollectProbableExtensionMethodsInSingleBinder(string name, ArrayBuilder`1<MethodSymbol> methods, Binder originalBinder);
    protected virtual void AddExtensionMethodLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
    internal virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
}
internal class Microsoft.CodeAnalysis.VisualBasic.NamespaceDeclarationSyntaxReference : TranslationSyntaxReference {
    public NamespaceDeclarationSyntaxReference(SyntaxReference reference);
    protected virtual SyntaxNode Translate(SyntaxReference reference, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.NamespaceOrTypeAndImportsClausePosition : ValueType {
    public NamespaceOrTypeSymbol NamespaceOrType;
    public int ImportsClausePosition;
    public NamespaceOrTypeAndImportsClausePosition(NamespaceOrTypeSymbol namespaceOrType, int importsClausePosition);
}
internal class Microsoft.CodeAnalysis.VisualBasic.NamespaceScopeBuilder : object {
    public static ImmutableArray`1<UsedNamespaceOrType> BuildNamespaceScope(PEModuleBuilder moduleBuilder, IReadOnlyDictionary`2<string, XmlNamespaceAndImportsClausePosition> xmlNamespacesOpt, IEnumerable`1<AliasAndImportsClausePosition> aliasImportsOpt, ImmutableArray`1<NamespaceOrTypeAndImportsClausePosition> memberImports, DiagnosticBag diagnostics);
    private static ITypeReference GetTypeReference(TypeSymbol type, CommonPEModuleBuilder moduleBuilder, DiagnosticBag diagnostics);
}
internal enum Microsoft.CodeAnalysis.VisualBasic.NoOpStatementFlavor : Enum {
    public int value__;
    public static NoOpStatementFlavor Default;
    public static NoOpStatementFlavor AwaitYieldPoint;
    public static NoOpStatementFlavor AwaitResumePoint;
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ObjectDisplay.ObjectDisplay : object {
    private static char s_nullChar;
    private static char s_back;
    private static char s_Cr;
    private static char s_formFeed;
    private static char s_Lf;
    private static char s_tab;
    private static char s_verticalTab;
    internal static string NullLiteral { get; }
    public static string FormatPrimitive(object obj, ObjectDisplayOptions options);
    internal static string get_NullLiteral();
    internal static string FormatLiteral(bool value);
    internal static string FormatLiteral(string value, ObjectDisplayOptions options);
    internal static string FormatLiteral(char c, ObjectDisplayOptions options);
    private static string EscapeQuote(char c);
    internal static string FormatLiteral(sbyte value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(byte value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(short value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(ushort value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(int value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(UInt32 value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(long value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(ulong value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(double value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(float value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(decimal value, ObjectDisplayOptions options, CultureInfo cultureInfo);
    internal static string FormatLiteral(DateTime value);
    private static int Character(char c);
    private static int Identifier(char c);
    private static int Number(char c);
    private static int Punctuation(char c);
    private static int Operator(char c);
    private static int Space();
    private static int Quotes();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.ObjectDisplay.ObjectDisplay/VB$StateMachine_33_TokenizeString")]
internal static IEnumerable`1<int> TokenizeString(string str, ObjectDisplayOptions options);
    internal static bool IsPrintable(char c);
    internal static string GetWellKnownCharacterName(char c);
    private static CultureInfo GetFormatCulture(CultureInfo cultureInfo);
    [ConditionalAttribute("DEBUG")]
private static void ValidateOptions(ObjectDisplayOptions options);
}
internal class Microsoft.CodeAnalysis.VisualBasic.ObjectInitializerBinder : Binder {
    private BoundExpression _receiver;
    public ObjectInitializerBinder(Binder containingBinder, BoundExpression receiver);
    protected internal virtual BoundExpression TryBindOmittedLeftForMemberAccess(MemberAccessExpressionSyntax node, DiagnosticBag diagnostics, Binder accessingBinder, Boolean& wholeMemberAccessExpressionBound);
    protected internal virtual BoundExpression TryBindOmittedLeftForXmlMemberAccess(XmlMemberAccessExpressionSyntax node, DiagnosticBag diagnostics, Binder accessingBinder);
    protected virtual BoundExpression TryBindOmittedLeftForDictionaryAccess(MemberAccessExpressionSyntax node, Binder accessingBinder, DiagnosticBag diagnostics);
    protected virtual BoundExpression TryBindOmittedLeftForConditionalAccess(ConditionalAccessExpressionSyntax node, Binder accessingBinder, DiagnosticBag diagnostics);
}
internal enum Microsoft.CodeAnalysis.VisualBasic.OnErrorStatementKind : Enum {
    public byte value__;
    public static OnErrorStatementKind GoToZero;
    public static OnErrorStatementKind GoToMinusOne;
    public static OnErrorStatementKind GoToLabel;
    public static OnErrorStatementKind ResumeNext;
}
public enum Microsoft.CodeAnalysis.VisualBasic.OptionStrict : Enum {
    public byte value__;
    public static OptionStrict Off;
    public static OptionStrict Custom;
    public static OptionStrict On;
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.OptionStrictEnumBounds : object {
    [ExtensionAttribute]
internal static bool IsValid(OptionStrict value);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.OptionsValidator : object {
    internal static GlobalImport[] ParseImports(IEnumerable`1<string> importsClauses, DiagnosticBag diagnostics);
    internal static bool IsValidNamespaceName(string name);
    private static bool IsValidRootNamespaceComponent(string name, int start, int end, bool allowEscaping);
}
internal enum Microsoft.CodeAnalysis.VisualBasic.OutputLevel : Enum {
    public int value__;
    public static OutputLevel Quiet;
    public static OutputLevel Normal;
    public static OutputLevel Verbose;
}
internal class Microsoft.CodeAnalysis.VisualBasic.OverloadResolution : object {
    private static Dictionary`2<string, OperatorInfo> s_operatorNames;
    private static int s_stateSize;
    private static OverloadResolution();
    internal static OperatorInfo GetOperatorInfo(string name);
    internal static SyntaxKind GetOperatorTokenKind(string name);
    internal static SyntaxKind GetOperatorTokenKind(OperatorInfo opInfo);
    internal static SyntaxKind GetOperatorTokenKind(UnaryOperatorKind op);
    internal static SyntaxKind GetOperatorTokenKind(BinaryOperatorKind op);
    internal static string TryGetOperatorName(BinaryOperatorKind op);
    internal static string TryGetOperatorName(UnaryOperatorKind op);
    internal static bool ValidateOverloadedOperator(MethodSymbol method, OperatorInfo opInfo, DiagnosticBag diagnosticsOpt);
    private static bool OverloadedOperatorTargetsContainingType(NamedTypeSymbol containingType, TypeSymbol typeFromSignature);
    public static UnaryOperatorKind MapUnaryOperatorKind(SyntaxKind opCode);
    public static UnaryOperatorKind ResolveUnaryOperator(UnaryOperatorKind opCode, BoundExpression operand, Binder binder, SpecialType& intrinsicOperatorType, OverloadResolutionResult& userDefinedOperator, HashSet`1& useSiteDiagnostics);
    internal static SpecialType ResolveNotLiftedIntrinsicUnaryOperator(UnaryOperatorKind opCode, SpecialType operandSpecialType);
    public static ConstantValue TryFoldConstantUnaryOperator(UnaryOperatorKind op, BoundExpression operand, TypeSymbol resultType, Boolean& integerOverflow);
    public static BinaryOperatorKind MapBinaryOperatorKind(SyntaxKind opCode);
    public static BinaryOperatorKind ResolveBinaryOperator(BinaryOperatorKind opCode, BoundExpression left, BoundExpression right, Binder binder, bool considerUserDefinedOrLateBound, SpecialType& intrinsicOperatorType, OverloadResolutionResult& userDefinedOperator, HashSet`1& useSiteDiagnostics);
    public static bool UseUserDefinedBinaryOperators(BinaryOperatorKind opCode, TypeSymbol leftType, TypeSymbol rightType);
    public static ConstantValue TryFoldConstantBinaryOperator(BinaryOperatorKind operatorKind, BoundExpression left, BoundExpression right, TypeSymbol resultType, Boolean& integerOverflow, Boolean& divideByZero, Boolean& compoundLengthOutOfLimit, Int32& compoundStringLength);
    private static ConstantValue FoldIntegralCharOrDateTimeBinaryOperator(BinaryOperatorKind op, ConstantValue left, ConstantValue right, TypeSymbol operandType, TypeSymbol resultType, Boolean& integerOverflow, Boolean& divideByZero);
    private static ConstantValue FoldFloatingBinaryOperator(BinaryOperatorKind op, ConstantValue left, ConstantValue right, TypeSymbol operandType, TypeSymbol resultType);
    private static ConstantValue FoldDecimalBinaryOperator(BinaryOperatorKind op, ConstantValue left, ConstantValue right, TypeSymbol resultType, Boolean& divideByZero);
    private static ConstantValue FoldStringBinaryOperator(BinaryOperatorKind op, ConstantValue left, ConstantValue right, Int32& compoundStringLength);
    private static ConstantValue FoldBooleanBinaryOperator(BinaryOperatorKind op, ConstantValue left, ConstantValue right);
    internal static SpecialType ResolveNotLiftedIntrinsicBinaryOperator(BinaryOperatorKind opCode, SpecialType left, SpecialType right);
    public static KeyValuePair`2<ConversionKind, MethodSymbol> ResolveUserDefinedConversion(TypeSymbol source, TypeSymbol destination, HashSet`1& useSiteDiagnostics);
    private static bool DetermineMostSpecificWideningConversion(TypeSymbol source, TypeSymbol destination, ArrayBuilder`1<MethodSymbol> opSet, ArrayBuilder`1<KeyValuePair`2<ConversionKind, ConversionKind>> conversionKinds, BitVector& applicable, MethodSymbol& bestMatch, bool suppressViabilityChecks, HashSet`1& useSiteDiagnostics);
    private static MethodSymbol ChooseMostSpecificConversionOperator(ArrayBuilder`1<MethodSymbol> opSet, BitVector applicable, TypeSymbol mostSpecificSourceType, TypeSymbol mostSpecificTargetType, Boolean& bestMatchIsAmbiguous);
    private static bool ClassifyConversionOperatorInOutConversions(TypeSymbol source, TypeSymbol destination, MethodSymbol method, ConversionKind& conversionIn, ConversionKind& conversionOut, bool suppressViabilityChecks, HashSet`1& useSiteDiagnostics);
    private static bool IsConversionOperatorViableBasedOnTypesInvolved(MethodSymbol method, TypeSymbol inputType, TypeSymbol outputType);
    private static bool DetermineMostSpecificNarrowingConversion(TypeSymbol source, TypeSymbol destination, ArrayBuilder`1<MethodSymbol> opSet, ArrayBuilder`1<KeyValuePair`2<ConversionKind, ConversionKind>> conversionKinds, BitVector& applicable, MethodSymbol& bestMatch, bool suppressViabilityChecks, HashSet`1& useSiteDiagnostics);
    private static TypeSymbol MostEncompassed(ArrayBuilder`1<TypeSymbol> typeSet, HashSet`1& useSiteDiagnostics);
    private static TypeSymbol MostEncompassing(ArrayBuilder`1<TypeSymbol> typeSet, HashSet`1& useSiteDiagnostics);
    private static MethodSymbol LeastGenericConversionOperator(MethodSymbol method1, MethodSymbol method2, Int32& bestDegreeOfGenericity, Boolean& isAmbiguous);
    private static int DetermineConversionOperatorDegreeOfGenericity(MethodSymbol method);
    internal static bool IsWidening(MethodSymbol method);
    private static void CollectUserDefinedConversionOperators(TypeSymbol source, TypeSymbol destination, ArrayBuilder`1<MethodSymbol> opSet, HashSet`1& useSiteDiagnostics);
    internal static void CollectUserDefinedOperators(TypeSymbol type1, TypeSymbol type2, MethodKind opKind, string name1, OperatorInfo name1Info, string name2Opt, OperatorInfo name2InfoOpt, ArrayBuilder`1<MethodSymbol> opSet, HashSet`1& useSiteDiagnostics);
    private static bool CollectUserDefinedOperators(TypeSymbol type, string opName, MethodKind opKind, OperatorInfo opInfo, ArrayBuilder`1<MethodSymbol> opSet);
    private static TypeSymbol GetTypeToLookForOperatorsIn(TypeSymbol type, HashSet`1& useSiteDiagnostics);
    public static OverloadResolutionResult ResolveIsTrueOperator(BoundExpression argument, Binder binder, HashSet`1& useSiteDiagnostics);
    public static OverloadResolutionResult ResolveIsFalseOperator(BoundExpression argument, Binder binder, HashSet`1& useSiteDiagnostics);
    public static OverloadResolutionResult ResolveUserDefinedUnaryOperator(BoundExpression argument, UnaryOperatorKind opKind, Binder binder, HashSet`1& useSiteDiagnostics, bool includeEliminatedCandidates);
    public static OverloadResolutionResult ResolveUserDefinedBinaryOperator(BoundExpression left, BoundExpression right, BinaryOperatorKind opKind, Binder binder, HashSet`1& useSiteDiagnostics, bool includeEliminatedCandidates);
    private static OverloadResolutionResult OperatorInvocationOverloadResolution(ArrayBuilder`1<MethodSymbol> opSet, BoundExpression argument1, BoundExpression argument2, Binder binder, bool lateBindingIsAllowed, bool includeEliminatedCandidates, HashSet`1& useSiteDiagnostics);
    internal static bool CanLiftType(TypeSymbol type);
    internal static bool IsValidInLiftedSignature(TypeSymbol type);
    private static ParameterSymbol LiftParameterSymbol(ParameterSymbol param, NamedTypeSymbol nullableOfT);
    public static OverloadResolutionResult MethodOrPropertyInvocationOverloadResolution(BoundMethodOrPropertyGroup group, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNames, Binder binder, VisualBasicSyntaxNode callerInfoOpt, HashSet`1& useSiteDiagnostics, bool includeEliminatedCandidates, bool forceExpandedForm);
    public static OverloadResolutionResult QueryOperatorInvocationOverloadResolution(BoundMethodGroup methodGroup, ImmutableArray`1<BoundExpression> arguments, Binder binder, HashSet`1& useSiteDiagnostics, bool includeEliminatedCandidates);
    public static OverloadResolutionResult MethodInvocationOverloadResolution(BoundMethodGroup methodGroup, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNames, Binder binder, VisualBasicSyntaxNode callerInfoOpt, HashSet`1& useSiteDiagnostics, bool includeEliminatedCandidates, TypeSymbol delegateReturnType, BoundNode delegateReturnTypeReferenceBoundNode, bool lateBindingIsAllowed, bool isQueryOperatorInvocation, bool forceExpandedForm);
    private static OverloadResolutionResult ReportOverloadResolutionFailedOrLateBound(ArrayBuilder`1<CandidateAnalysisResult> candidates, int applicableNarrowingCandidateCount, bool lateBindingIsAllowed, HashSet`1<BoundExpression> asyncLambdaSubToFunctionMismatch);
    public static OverloadResolutionResult PropertyInvocationOverloadResolution(BoundPropertyGroup propertyGroup, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNames, Binder binder, VisualBasicSyntaxNode callerInfoOpt, HashSet`1& useSiteDiagnostics, bool includeEliminatedCandidates);
    private static bool ShouldConsiderExtensionMethods(ArrayBuilder`1<CandidateAnalysisResult> candidates);
    private static OverloadResolutionResult ResolveOverloading(BoundMethodOrPropertyGroup methodOrPropertyGroup, ArrayBuilder`1<CandidateAnalysisResult> candidates, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNames, TypeSymbol delegateReturnType, bool lateBindingIsAllowed, Binder binder, HashSet`1& asyncLambdaSubToFunctionMismatch, VisualBasicSyntaxNode callerInfoOpt, bool forceExpandedForm, HashSet`1& useSiteDiagnostics);
    private static int EliminateNarrowingCandidates(ArrayBuilder`1<CandidateAnalysisResult> candidates);
    private static int EliminateLessApplicableToTheArguments(ArrayBuilder`1<CandidateAnalysisResult> candidates, ImmutableArray`1<BoundExpression> arguments, TypeSymbol delegateReturnType, bool appliedTieBreakingRules, Binder binder, HashSet`1& useSiteDiagnostics, bool mostApplicableMustNarrowOnlyFromNumericConstants);
    private static int CountApplicableCandidates(ArrayBuilder`1<CandidateAnalysisResult> candidates);
    private static int ApplyTieBreakingRulesToEquallyApplicableCandidates(ArrayBuilder`1<CandidateAnalysisResult> candidates, ImmutableArray`1<BoundExpression> arguments, TypeSymbol delegateReturnType, Binder binder, HashSet`1& useSiteDiagnostics);
    private static bool FastFindMostApplicableCandidates(ArrayBuilder`1<CandidateAnalysisResult> candidates, ImmutableArray`1<BoundExpression> arguments, ArrayBuilder`1<int> indexesOfMostApplicableCandidates, Binder binder, HashSet`1& useSiteDiagnostics);
    private static int ApplyTieBreakingRules(ArrayBuilder`1<CandidateAnalysisResult> candidates, ArrayBuilder`1<int> bucket, ImmutableArray`1<BoundExpression> arguments, TypeSymbol delegateReturnType, Binder binder, HashSet`1& useSiteDiagnostics);
    private static bool ShadowBasedOnTieBreakingRules(CandidateAnalysisResult left, CandidateAnalysisResult right, ImmutableArray`1<BoundExpression> arguments, TypeSymbol delegateReturnType, Boolean& leftWins, Boolean& rightWins, Binder binder, HashSet`1& useSiteDiagnostics);
    private static bool ShadowBasedOnSubOrFunction(CandidateAnalysisResult left, CandidateAnalysisResult right, TypeSymbol delegateReturnType, Boolean& leftWins, Boolean& rightWins);
    private static int ShadowBasedOnDelegateRelaxation(ArrayBuilder`1<CandidateAnalysisResult> candidates, Int32& applicableNarrowingCandidates);
    private static bool ShadowBasedOnOptionalParametersDefaultsUsed(CandidateAnalysisResult left, CandidateAnalysisResult right, Boolean& leftWins, Boolean& rightWins);
    private static void ShadowBasedOnInferenceLevel(ArrayBuilder`1<CandidateAnalysisResult> candidates, ImmutableArray`1<BoundExpression> arguments, bool haveNamedArguments, TypeSymbol delegateReturnType, Binder binder, Int32& applicableCandidates, Int32& applicableNarrowingCandidates, HashSet`1& useSiteDiagnostics);
    private static ApplicabilityComparisonResult CompareApplicabilityToTheArguments(CandidateAnalysisResult& left, CandidateAnalysisResult& right, ImmutableArray`1<BoundExpression> arguments, Binder binder, HashSet`1& useSiteDiagnostics);
    private static ApplicabilityComparisonResult CompareParameterTypeApplicability(TypeSymbol left, TypeSymbol right, BoundExpression argument, Binder binder, HashSet`1& useSiteDiagnostics);
    private static ArrayBuilder`1<ArrayBuilder`1<int>> GroupEquallyApplicableCandidates(ArrayBuilder`1<CandidateAnalysisResult> candidates, ImmutableArray`1<BoundExpression> arguments, Binder binder);
    private static bool CandidatesAreEquallyApplicableToArguments(CandidateAnalysisResult& left, CandidateAnalysisResult& right, ImmutableArray`1<BoundExpression> arguments, Binder binder);
    private static bool ParametersAreEquallyApplicableToArgument(TypeSymbol leftParamType, TypeSymbol rightParamType, BoundExpression argument, Binder binder);
    private static int AnalyzeNarrowingCandidates(ArrayBuilder`1<CandidateAnalysisResult> candidates, ImmutableArray`1<BoundExpression> arguments, TypeSymbol delegateReturnType, bool lateBindingIsAllowed, Binder binder, Boolean& resolutionIsLateBound, HashSet`1& useSiteDiagnostics);
    private static bool IsUnwrappingNullable(ConversionKind conv, TypeSymbol sourceType, TypeSymbol targetType);
    private static bool IsUnwrappingNullable(TypeSymbol sourceType, TypeSymbol targetType, HashSet`1& useSiteDiagnostics);
    private static bool HaveNarrowingOnlyFromObjectCandidates(ArrayBuilder`1<CandidateAnalysisResult> candidates);
    private static int EliminateNotApplicableToArguments(BoundMethodOrPropertyGroup methodOrPropertyGroup, ArrayBuilder`1<CandidateAnalysisResult> candidates, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNames, Binder binder, Int32& applicableNarrowingCandidates, HashSet`1& asyncLambdaSubToFunctionMismatch, VisualBasicSyntaxNode callerInfoOpt, bool forceExpandedForm, HashSet`1& useSiteDiagnostics);
    private static void BuildParameterToArgumentMap(CandidateAnalysisResult& candidate, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNames, ArrayBuilder`1& parameterToArgumentMap, ArrayBuilder`1& paramArrayItems);
    private static void MatchArguments(BoundMethodOrPropertyGroup methodOrPropertyGroup, CandidateAnalysisResult& candidate, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNames, Binder binder, HashSet`1& asyncLambdaSubToFunctionMismatch, VisualBasicSyntaxNode callerInfoOpt, bool forceExpandedForm, HashSet`1& useSiteDiagnostics);
    private static void MatchArgumentToByRefParameter(BoundMethodOrPropertyGroup methodOrPropertyGroup, CandidateAnalysisResult& candidate, BoundExpression argument, TypeSymbol targetType, Binder binder, KeyValuePair`2& outConversionKind, KeyValuePair`2& outConversionBackKind, HashSet`1& asyncLambdaSubToFunctionMismatch, HashSet`1& useSiteDiagnostics);
    private static bool MatchArgumentToByValParameter(BoundMethodOrPropertyGroup methodOrPropertyGroup, CandidateAnalysisResult& candidate, BoundExpression argument, TypeSymbol targetType, Binder binder, KeyValuePair`2& outConversionKind, HashSet`1& asyncLambdaSubToFunctionMismatch, HashSet`1& useSiteDiagnostics, bool isDefaultValueArgument);
    private static bool IsWithinAppliedAttributeName(VisualBasicSyntaxNode syntax);
    public static bool CanPassToParamArray(BoundExpression expression, TypeSymbol targetType, KeyValuePair`2& outConvKind, Binder binder, HashSet`1& useSiteDiagnostics);
    private static void CollectOverloadedCandidates(Binder binder, ArrayBuilder`1<CandidateAnalysisResult> results, ArrayBuilder`1<Candidate> group, ImmutableArray`1<TypeSymbol> typeArguments, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNames, TypeSymbol delegateReturnType, BoundNode delegateReturnTypeReferenceBoundNode, bool includeEliminatedCandidates, bool isQueryOperatorInvocation, bool forceExpandedForm, HashSet`1& asyncLambdaSubToFunctionMismatch, HashSet`1& useSiteDiagnostics);
    private static QuickApplicabilityInfo DoQuickApplicabilityCheck(Candidate candidate, ImmutableArray`1<TypeSymbol> typeArguments, ImmutableArray`1<BoundExpression> arguments, bool isQueryOperatorInvocation, bool forceExpandedForm, HashSet`1& useSiteDiagnostics);
    private static void CollectOverloadedCandidate(ArrayBuilder`1<CandidateAnalysisResult> results, QuickApplicabilityInfo candidate, ImmutableArray`1<TypeSymbol> typeArguments, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNames, TypeSymbol delegateReturnType, BoundNode delegateReturnTypeReferenceBoundNode, bool includeEliminatedCandidates, Binder binder, HashSet`1& asyncLambdaSubToFunctionMismatch, HashSet`1& useSiteDiagnostics);
    private static void InferTypeArgumentsIfNeedToAndCombineWithExistingCandidates(ArrayBuilder`1<CandidateAnalysisResult> results, CandidateAnalysisResult newCandidate, ImmutableArray`1<TypeSymbol> typeArguments, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNames, TypeSymbol delegateReturnType, BoundNode delegateReturnTypeReferenceBoundNode, Binder binder, HashSet`1& asyncLambdaSubToFunctionMismatch, HashSet`1& useSiteDiagnostics);
    private static void CombineCandidates(ArrayBuilder`1<CandidateAnalysisResult> results, CandidateAnalysisResult newCandidate, int argumentCount, ImmutableArray`1<string> argumentNames, HashSet`1& useSiteDiagnostics);
    private static bool ShadowBasedOnOverriding(CandidateAnalysisResult existingCandidate, CandidateAnalysisResult newCandidate, Boolean& existingWins, Boolean& newWins);
    private static bool ShadowBasedOnExtensionVsInstanceAndPrecedence(CandidateAnalysisResult left, CandidateAnalysisResult right, Boolean& leftWins, Boolean& rightWins);
    private static bool ShadowBasedOnGenericity(CandidateAnalysisResult left, CandidateAnalysisResult right, Boolean& leftWins, Boolean& rightWins, ImmutableArray`1<BoundExpression> arguments, Binder binder);
    private static bool SignatureMismatchForThePurposeOfShadowingBasedOnGenericity(TypeSymbol leftParamType, TypeSymbol rightParamType, BoundExpression argument, Binder binder);
    private static bool ShadowBasedOnDepthOfGenericity(CandidateAnalysisResult left, CandidateAnalysisResult right, Boolean& leftWins, Boolean& rightWins, ImmutableArray`1<BoundExpression> arguments, Binder binder);
    private static bool CompareParameterTypeGenericDepth(TypeSymbol leftType, TypeSymbol rightType, Boolean& leftWins, Boolean& rightWins);
    private static bool ShadowBasedOnExtensionMethodTargetTypeGenericity(CandidateAnalysisResult left, CandidateAnalysisResult right, Boolean& leftWins, Boolean& rightWins);
    private static TypeParameterKind DetectReferencesToGenericParameters(NamedTypeSymbol symbol, TypeParameterKind track, BitVector methodTypeParametersToTreatAsTypeTypeParameters);
    private static TypeParameterKind DetectReferencesToGenericParameters(TypeParameterSymbol symbol, TypeParameterKind track, BitVector methodTypeParametersToTreatAsTypeTypeParameters);
    private static TypeParameterKind DetectReferencesToGenericParameters(TypeSymbol this, TypeParameterKind track, BitVector methodTypeParametersToTreatAsTypeTypeParameters);
    private static bool ShadowBasedOnReceiverType(CandidateAnalysisResult left, CandidateAnalysisResult right, Boolean& leftWins, Boolean& rightWins, HashSet`1& useSiteDiagnostics);
    public static bool DoesReceiverMatchInstance(TypeSymbol instanceType, TypeSymbol receiverType, HashSet`1& useSiteDiagnostics);
    private static bool ShadowBasedOnParamArrayUsage(CandidateAnalysisResult left, CandidateAnalysisResult right, Boolean& leftWins, Boolean& rightWins);
    internal static TypeSymbol GetParameterTypeFromVirtualSignature(CandidateAnalysisResult& candidate, int paramIndex);
    private static TypeSymbol GetParameterTypeFromVirtualSignature(CandidateAnalysisResult& candidate, int paramIndex, TypeSymbol& typeForGenericityCheck);
    internal static void AdvanceParameterInVirtualSignature(CandidateAnalysisResult& candidate, Int32& paramIndex);
    private static bool InferTypeArguments(CandidateAnalysisResult& candidate, ImmutableArray`1<BoundExpression> arguments, ImmutableArray`1<string> argumentNames, TypeSymbol delegateReturnType, BoundNode delegateReturnTypeReferenceBoundNode, HashSet`1& asyncLambdaSubToFunctionMismatch, Binder binder, HashSet`1& useSiteDiagnostics);
    private static Candidate ConstructIfNeedTo(Candidate candidate, ImmutableArray`1<TypeSymbol> typeArguments);
}
internal class Microsoft.CodeAnalysis.VisualBasic.OverloadResolutionResult`1 : object {
    private Nullable`1<MemberResolutionResult`1<TMember>> _validResult;
    private Nullable`1<MemberResolutionResult`1<TMember>> _bestResult;
    private ImmutableArray`1<MemberResolutionResult`1<TMember>> _results;
    public bool Succeeded { get; }
    public Nullable`1<MemberResolutionResult`1<TMember>> ValidResult { get; }
    public Nullable`1<MemberResolutionResult`1<TMember>> BestResult { get; }
    public ImmutableArray`1<MemberResolutionResult`1<TMember>> Results { get; }
    internal OverloadResolutionResult`1(ImmutableArray`1<MemberResolutionResult`1<TMember>> results, Nullable`1<MemberResolutionResult`1<TMember>> validResult, Nullable`1<MemberResolutionResult`1<TMember>> bestResult);
    public bool get_Succeeded();
    public Nullable`1<MemberResolutionResult`1<TMember>> get_ValidResult();
    public Nullable`1<MemberResolutionResult`1<TMember>> get_BestResult();
    public ImmutableArray`1<MemberResolutionResult`1<TMember>> get_Results();
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.PEDocumentationCommentUtils : object {
    internal static string GetDocumentationComment(Symbol symbol, PEModuleSymbol containingPEModule, CultureInfo preferredCulture, CancellationToken cancellationToken, Tuple`2& lazyDocComment);
}
[StandardModuleAttribute]
public class Microsoft.CodeAnalysis.VisualBasic.PredefinedPreprocessorSymbols : object {
    internal static double CurrentVersionNumber;
    public static ImmutableArray`1<KeyValuePair`2<string, object>> AddPredefinedPreprocessorSymbols(OutputKind kind, IEnumerable`1<KeyValuePair`2<string, object>> symbols);
    public static ImmutableArray`1<KeyValuePair`2<string, object>> AddPredefinedPreprocessorSymbols(OutputKind kind, KeyValuePair`2[] symbols);
    public static ImmutableArray`1<KeyValuePair`2<string, object>> AddPredefinedPreprocessorSymbols(OutputKind kind, ImmutableArray`1<KeyValuePair`2<string, object>> symbols);
    internal static string GetTargetString(OutputKind kind);
}
internal class Microsoft.CodeAnalysis.VisualBasic.ProjectImportsBinder : Binder {
    private SyntaxTree _tree;
    internal bool SuppressObsoleteDiagnostics { get; }
    public ProjectImportsBinder(Binder containingBinder, SyntaxTree tree);
    public virtual SyntaxReference GetSyntaxReference(VisualBasicSyntaxNode node);
    internal virtual bool get_SuppressObsoleteDiagnostics();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.VisualBasic.PropertyAccessKind : Enum {
    public int value__;
    public static PropertyAccessKind Unknown;
    public static PropertyAccessKind Get;
    public static PropertyAccessKind Set;
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.PseudoVariableExpressions : object {
    internal abstract virtual BoundExpression GetAddress(BoundPseudoVariable variable);
    internal abstract virtual BoundExpression GetValue(BoundPseudoVariable variable, DiagnosticBag diagnostics);
}
internal enum Microsoft.CodeAnalysis.VisualBasic.QualificationKind : Enum {
    public int value__;
    public static QualificationKind Unqualified;
    public static QualificationKind QualifiedViaValue;
    public static QualificationKind QualifiedViaTypeName;
    public static QualificationKind QualifiedViaNamespace;
}
internal class Microsoft.CodeAnalysis.VisualBasic.ReadWriteWalker : AbstractRegionDataFlowPass {
    private HashSet`1<Symbol> _readInside;
    private HashSet`1<Symbol> _writtenInside;
    private HashSet`1<Symbol> _readOutside;
    private HashSet`1<Symbol> _writtenOutside;
    private HashSet`1<Symbol> _captured;
    private Symbol _currentMethodOrLambda;
    private BoundQueryLambda _currentQueryLambda;
    private ReadWriteWalker(FlowAnalysisInfo info, FlowAnalysisRegionInfo region);
    internal static void Analyze(FlowAnalysisInfo info, FlowAnalysisRegionInfo region, IEnumerable`1& readInside, IEnumerable`1& writtenInside, IEnumerable`1& readOutside, IEnumerable`1& writtenOutside, IEnumerable`1& captured);
    protected virtual void NoteRead(Symbol variable);
    protected virtual void NoteWrite(Symbol variable, BoundExpression value);
    private void NoteCaptured(Symbol variable);
    protected virtual void NoteRead(BoundFieldAccess fieldAccess);
    protected virtual void NoteWrite(BoundExpression node, BoundExpression value);
    private void NoteReceiverRead(BoundFieldAccess fieldAccess);
    private void NoteReceiverWritten(BoundFieldAccess fieldAccess);
    private void NoteReceiverReadOrWritten(BoundFieldAccess fieldAccess, HashSet`1<Symbol> readOrWritten);
    private bool IsCompilerGeneratedTempLocal(Symbol variable);
    private void CheckCaptured(Symbol variable);
    public virtual BoundNode VisitLambda(BoundLambda node);
    public virtual BoundNode VisitQueryLambda(BoundQueryLambda node);
    public virtual BoundNode VisitQueryableSource(BoundQueryableSource node);
    public virtual BoundNode VisitRangeVariableAssignment(BoundRangeVariableAssignment node);
    private bool Analyze();
}
internal class Microsoft.CodeAnalysis.VisualBasic.ReducedExtensionPropertySymbol : PropertySymbol {
    private PropertySymbol _originalDefinition;
    internal PropertySymbol ReducedFrom { get; }
    internal PropertySymbol ReducedFromDefinition { get; }
    internal TypeSymbol ReceiverType { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal CallingConvention CallingConvention { get; }
    public Symbol ContainingSymbol { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public ImmutableArray`1<PropertySymbol> ExplicitInterfaceImplementations { get; }
    public MethodSymbol GetMethod { get; }
    internal FieldSymbol AssociatedField { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public bool IsDefault { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverloads { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public int ParameterCount { get; }
    public MethodSymbol SetMethod { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    internal bool IsMyGroupCollectionProperty { get; }
    public ReducedExtensionPropertySymbol(PropertySymbol originalDefinition);
    internal virtual PropertySymbol get_ReducedFrom();
    internal virtual PropertySymbol get_ReducedFromDefinition();
    internal virtual TypeSymbol get_ReceiverType();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    internal virtual CallingConvention get_CallingConvention();
    public virtual Symbol get_ContainingSymbol();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<PropertySymbol> get_ExplicitInterfaceImplementations();
    public virtual MethodSymbol get_GetMethod();
    internal virtual FieldSymbol get_AssociatedField();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual bool get_IsDefault();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsShared();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual int get_ParameterCount();
    public virtual MethodSymbol get_SetMethod();
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
    private ReducedExtensionAccessorSymbol ReduceAccessorIfAny(MethodSymbol methodOpt);
    internal virtual bool get_IsMyGroupCollectionProperty();
}
internal class Microsoft.CodeAnalysis.VisualBasic.RegionAnalysisContext : ValueType {
    private VisualBasicCompilation _compilation;
    private Symbol _symbol;
    private BoundNode _boundNode;
    private BoundNode _firstInRegion;
    private BoundNode _lastInRegion;
    private TextSpan _region;
    public bool Failed;
    internal FlowAnalysisInfo AnalysisInfo { get; }
    internal FlowAnalysisRegionInfo RegionInfo { get; }
    internal RegionAnalysisContext(VisualBasicCompilation compilation, Symbol member, BoundNode boundNode, BoundNode firstInRegion, BoundNode lastInRegion, TextSpan region);
    internal RegionAnalysisContext(VisualBasicCompilation compilation);
    internal FlowAnalysisInfo get_AnalysisInfo();
    internal FlowAnalysisRegionInfo get_RegionInfo();
}
internal class Microsoft.CodeAnalysis.VisualBasic.RegionReachableWalker : AbstractRegionControlFlowPass {
    private Nullable`1<bool> _regionStartPointIsReachable;
    private Nullable`1<bool> _regionEndPointIsReachable;
    private RegionReachableWalker(FlowAnalysisInfo info, FlowAnalysisRegionInfo region);
    internal static void Analyze(FlowAnalysisInfo info, FlowAnalysisRegionInfo region, Boolean& startPointIsReachable, Boolean& endPointIsReachable);
    protected virtual void EnterRegion();
    protected virtual void LeaveRegion();
}
internal enum Microsoft.CodeAnalysis.VisualBasic.RequiredConversion : Enum {
    public int value__;
    public static RequiredConversion Identity;
    public static RequiredConversion Any;
    public static RequiredConversion AnyReverse;
    public static RequiredConversion AnyAndReverse;
    public static RequiredConversion ArrayElement;
    public static RequiredConversion Reference;
    public static RequiredConversion ReverseReference;
    public static RequiredConversion None;
    public static RequiredConversion Count;
}
internal enum Microsoft.CodeAnalysis.VisualBasic.ResumeStatementKind : Enum {
    public byte value__;
    public static ResumeStatementKind Plain;
    public static ResumeStatementKind Next;
    public static ResumeStatementKind Label;
}
internal class Microsoft.CodeAnalysis.VisualBasic.Rewriter : object {
    public static BoundBlock LowerBodyOrInitializer(MethodSymbol method, int methodOrdinal, BoundBlock body, SynthesizedSubmissionFields previousSubmissionFields, TypeCompilationState compilationState, DiagnosticBag diagnostics, VariableSlotAllocator& lazyVariableSlotAllocator, ArrayBuilder`1<LambdaDebugInfo> lambdaDebugInfoBuilder, ArrayBuilder`1<ClosureDebugInfo> closureDebugInfoBuilder, Int32& delegateRelaxationIdDispenser, StateMachineTypeSymbol& stateMachineTypeOpt, bool allowOmissionOfConditionalCalls, bool isBodySynthesized);
    internal static BoundBlock RewriteIteratorAndAsync(BoundBlock bodyWithoutLambdas, MethodSymbol method, int methodOrdinal, TypeCompilationState compilationState, DiagnosticBag diagnostics, VariableSlotAllocator slotAllocatorOpt, StateMachineTypeSymbol& stateMachineTypeOpt);
}
internal class Microsoft.CodeAnalysis.VisualBasic.SemanticModelBinder : Binder {
    private bool _ignoreAccessibility;
    public bool IsSemanticModelBinder { get; }
    protected SemanticModelBinder(Binder containingBinder, bool ignoreAccessibility);
    public static Binder Mark(Binder binder, bool ignoreAccessibility);
    internal virtual LookupOptions BinderSpecificLookupOptions(LookupOptions options);
    public sealed virtual bool get_IsSemanticModelBinder();
}
internal class Microsoft.CodeAnalysis.VisualBasic.SimpleSyntaxReference : SyntaxReference {
    private SyntaxTree _tree;
    private SyntaxNode _node;
    public SyntaxTree SyntaxTree { get; }
    public TextSpan Span { get; }
    internal SimpleSyntaxReference(SyntaxTree tree, SyntaxNode node);
    public virtual SyntaxTree get_SyntaxTree();
    public virtual TextSpan get_Span();
    public virtual SyntaxNode GetSyntax(CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.SingleLookupResult : ValueType {
    internal LookupResultKind Kind;
    internal Symbol Symbol;
    internal DiagnosticInfo Diagnostic;
    public static SingleLookupResult Empty;
    public static SingleLookupResult EmptyAndStopLookup;
    public bool HasDiagnostic { get; }
    public bool StopFurtherLookup { get; }
    public bool IsGoodOrAmbiguous { get; }
    public bool IsGood { get; }
    public bool IsAmbiguous { get; }
    private static SingleLookupResult();
    internal SingleLookupResult(LookupResultKind kind, Symbol symbol, DiagnosticInfo diagInfo);
    public bool get_HasDiagnostic();
    public static SingleLookupResult Good(Symbol sym);
    public static SingleLookupResult Ambiguous(ImmutableArray`1<Symbol> syms, Func`2<ImmutableArray`1<Symbol>, AmbiguousSymbolDiagnostic> generateAmbiguityDiagnostic);
    public static SingleLookupResult WrongArityAndStopLookup(Symbol sym, ERRID err);
    public static SingleLookupResult WrongArityAndStopLookup(Symbol sym, DiagnosticInfo diagInfo);
    public static SingleLookupResult WrongArity(Symbol sym, DiagnosticInfo diagInfo);
    public static SingleLookupResult WrongArity(Symbol sym, ERRID err);
    public static SingleLookupResult MustNotBeInstance(Symbol sym, ERRID err);
    public static SingleLookupResult MustBeInstance(Symbol sym);
    public static SingleLookupResult Inaccessible(Symbol sym, DiagnosticInfo diagInfo);
    internal static SingleLookupResult NotAnAttributeType(Symbol sym, DiagnosticInfo error);
    public bool get_StopFurtherLookup();
    public bool get_IsGoodOrAmbiguous();
    public bool get_IsGood();
    public bool get_IsAmbiguous();
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SourceDocumentationCommentUtils : object {
    internal static string GetDocumentationCommentForSymbol(Symbol symbol, CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.SourceFileBinder : Binder {
    private SourceFile _sourceFile;
    public OptionStrict OptionStrict { get; }
    public bool OptionInfer { get; }
    public bool OptionExplicit { get; }
    public bool OptionCompareText { get; }
    public QuickAttributeChecker QuickAttributeChecker { get; }
    public SourceFileBinder(Binder containingBinder, SourceFile sourceFile, SyntaxTree tree);
    public virtual SyntaxReference GetSyntaxReference(VisualBasicSyntaxNode node);
    public virtual OptionStrict get_OptionStrict();
    public virtual bool get_OptionInfer();
    public virtual bool get_OptionExplicit();
    public virtual bool get_OptionCompareText();
    public virtual QuickAttributeChecker get_QuickAttributeChecker();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.VisualBasic.SourceMemberFlags : Enum {
    public int value__;
    public static SourceMemberFlags None;
    public static SourceMemberFlags AccessibilityPrivate;
    public static SourceMemberFlags AccessibilityProtected;
    public static SourceMemberFlags AccessibilityFriend;
    public static SourceMemberFlags AccessibilityProtectedFriend;
    public static SourceMemberFlags AccessibilityPublic;
    public static SourceMemberFlags AccessibilityMask;
    public static SourceMemberFlags Private;
    public static SourceMemberFlags Protected;
    public static SourceMemberFlags Friend;
    public static SourceMemberFlags Public;
    public static SourceMemberFlags AllAccessibilityModifiers;
    public static SourceMemberFlags Shared;
    public static SourceMemberFlags ReadOnly;
    public static SourceMemberFlags WriteOnly;
    public static SourceMemberFlags AllWriteabilityModifiers;
    public static SourceMemberFlags Overrides;
    public static SourceMemberFlags Overridable;
    public static SourceMemberFlags MustOverride;
    public static SourceMemberFlags NotOverridable;
    public static SourceMemberFlags AllOverrideModifiers;
    public static SourceMemberFlags PrivateOverridableModifiers;
    public static SourceMemberFlags PrivateMustOverrideModifiers;
    public static SourceMemberFlags PrivateNotOverridableModifiers;
    public static SourceMemberFlags Overloads;
    public static SourceMemberFlags Shadows;
    public static SourceMemberFlags AllShadowingModifiers;
    public static SourceMemberFlags ShadowsAndOverrides;
    public static SourceMemberFlags Default;
    public static SourceMemberFlags WithEvents;
    public static SourceMemberFlags Widening;
    public static SourceMemberFlags Narrowing;
    public static SourceMemberFlags AllConversionModifiers;
    public static SourceMemberFlags InvalidInNotInheritableClass;
    public static SourceMemberFlags InvalidInNotInheritableOtherPartialClass;
    public static SourceMemberFlags InvalidInModule;
    public static SourceMemberFlags InvalidInInterface;
    public static SourceMemberFlags InvalidIfShared;
    public static SourceMemberFlags InvalidIfDefault;
    public static SourceMemberFlags Partial;
    public static SourceMemberFlags MustInherit;
    public static SourceMemberFlags NotInheritable;
    public static SourceMemberFlags TypeInheritModifiers;
    public static SourceMemberFlags Async;
    public static SourceMemberFlags Iterator;
    public static SourceMemberFlags Dim;
    public static SourceMemberFlags Const;
    public static SourceMemberFlags Static;
    public static SourceMemberFlags DeclarationModifierFlagMask;
    public static SourceMemberFlags DeclarationModifierFlagShift;
    public static SourceMemberFlags InferredFieldType;
    public static SourceMemberFlags FirstFieldDeclarationOfType;
    public static SourceMemberFlags MethodIsSub;
    public static SourceMemberFlags MethodHandlesEvents;
    public static SourceMemberFlags MethodKindOrdinary;
    public static SourceMemberFlags MethodKindConstructor;
    public static SourceMemberFlags MethodKindSharedConstructor;
    public static SourceMemberFlags MethodKindDelegateInvoke;
    public static SourceMemberFlags MethodKindOperator;
    public static SourceMemberFlags MethodKindConversion;
    public static SourceMemberFlags MethodKindPropertyGet;
    public static SourceMemberFlags MethodKindPropertySet;
    public static SourceMemberFlags MethodKindEventAdd;
    public static SourceMemberFlags MethodKindEventRemove;
    public static SourceMemberFlags MethodKindEventRaise;
    public static SourceMemberFlags MethodKindDeclare;
    public static SourceMemberFlags MethodKindMask;
    public static SourceMemberFlags MethodKindShift;
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SourceMemberFlagsExtensions : object {
    [ExtensionAttribute]
internal static MethodKind ToMethodKind(SourceMemberFlags flags);
}
internal class Microsoft.CodeAnalysis.VisualBasic.SourceModuleBinder : Binder {
    private SourceModuleSymbol _sourceModule;
    public OptionStrict OptionStrict { get; }
    public bool OptionInfer { get; }
    public bool OptionExplicit { get; }
    public bool OptionCompareText { get; }
    public bool CheckOverflow { get; }
    public QuickAttributeChecker QuickAttributeChecker { get; }
    public SourceModuleBinder(Binder containingBinder, SourceModuleSymbol sourceModule);
    public virtual AccessCheckResult CheckAccessibility(Symbol sym, HashSet`1& useSiteDiagnostics, TypeSymbol accessThroughType, ConsList`1<Symbol> basesBeingResolved);
    public virtual ErrorTypeSymbol GetErrorSymbol(string name, DiagnosticInfo errorInfo, ImmutableArray`1<Symbol> candidateSymbols, LookupResultKind resultKind);
    public virtual OptionStrict get_OptionStrict();
    public virtual bool get_OptionInfer();
    public virtual bool get_OptionExplicit();
    public virtual bool get_OptionCompareText();
    public virtual bool get_CheckOverflow();
    public virtual QuickAttributeChecker get_QuickAttributeChecker();
}
internal class Microsoft.CodeAnalysis.VisualBasic.SpeculativeBinder : SemanticModelBinder {
    private SpeculativeBinder(Binder containingBinder);
    public static SpeculativeBinder Create(Binder containingBinder);
    public virtual SyntaxReference GetSyntaxReference(VisualBasicSyntaxNode node);
    internal virtual BoundExpression BindGroupAggregationExpression(GroupAggregationSyntax group, DiagnosticBag diagnostics);
    internal virtual BoundExpression BindFunctionAggregationExpression(FunctionAggregationSyntax function, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.VisualBasic.SpeculativeMemberSemanticModel : MemberSemanticModel {
    public SpeculativeMemberSemanticModel(SyntaxTreeSemanticModel parentSemanticModel, VisualBasicSyntaxNode root, Binder binder, int position);
    internal virtual bool TryGetSpeculativeSemanticModelForMethodBodyCore(SyntaxTreeSemanticModel parentModel, int position, MethodBlockBaseSyntax method, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, ExecutableStatementSyntax statement, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, EqualsValueSyntax initializer, SemanticModel& speculativeModel);
}
internal class Microsoft.CodeAnalysis.VisualBasic.SpeculativeStatementBinder : ExecutableCodeBinder {
    public bool IsSemanticModelBinder { get; }
    public SpeculativeStatementBinder(VisualBasicSyntaxNode root, Binder containingBinder);
    public virtual bool get_IsSemanticModelBinder();
}
internal class Microsoft.CodeAnalysis.VisualBasic.SpeculativeSyntaxTreeSemanticModel : SyntaxTreeSemanticModel {
    private SyntaxTreeSemanticModel _parentSemanticModel;
    private ExpressionSyntax _root;
    private Binder _rootBinder;
    private int _position;
    private SpeculativeBindingOption _bindingOption;
    public bool IsSpeculativeSemanticModel { get; }
    public int OriginalPositionForSpeculation { get; }
    public SemanticModel ParentModel { get; }
    internal VisualBasicSyntaxNode Root { get; }
    public SyntaxTree SyntaxTree { get; }
    private SpeculativeSyntaxTreeSemanticModel(SyntaxTreeSemanticModel parentSemanticModel, ExpressionSyntax root, Binder binder, int position, SpeculativeBindingOption bindingOption);
    public static SpeculativeSyntaxTreeSemanticModel Create(SyntaxTreeSemanticModel parentSemanticModel, ExpressionSyntax root, Binder binder, int position, SpeculativeBindingOption bindingOption);
    public virtual bool get_IsSpeculativeSemanticModel();
    public virtual int get_OriginalPositionForSpeculation();
    public virtual SemanticModel get_ParentModel();
    internal virtual VisualBasicSyntaxNode get_Root();
    public virtual SyntaxTree get_SyntaxTree();
    internal virtual BoundNode Bind(Binder binder, VisualBasicSyntaxNode node, DiagnosticBag diagnostics);
    internal virtual Binder GetEnclosingBinder(int position);
    private SpeculativeBindingOption GetSpeculativeBindingOption(ExpressionSyntax node);
    internal virtual SymbolInfo GetExpressionSymbolInfo(ExpressionSyntax node, SymbolInfoOptions options, CancellationToken cancellationToken);
    internal virtual VisualBasicTypeInfo GetExpressionTypeInfo(ExpressionSyntax node, CancellationToken cancellationToken);
    internal virtual ImmutableArray`1<Symbol> GetExpressionMemberGroup(ExpressionSyntax node, CancellationToken cancellationToken);
    internal virtual ConstantValue GetExpressionConstantValue(ExpressionSyntax node, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetSyntaxDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetDeclarationDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.StateMachineFieldSymbol : SynthesizedFieldSymbol {
    internal int SlotIndex;
    internal LocalSlotDebugInfo SlotDebugInfo;
    public bool HasMethodBodyDependency { get; }
    public IMethodSymbol Method { get; }
    public StateMachineFieldSymbol(NamedTypeSymbol stateMachineType, Symbol implicitlyDefinedBy, TypeSymbol type, string name, Accessibility accessibility, bool isReadOnly, bool isShared, bool isSpecialNameAndRuntimeSpecial);
    public StateMachineFieldSymbol(NamedTypeSymbol stateMachineType, Symbol implicitlyDefinedBy, TypeSymbol type, string name, SynthesizedLocalKind synthesizedKind, int slotindex, Accessibility accessibility, bool isReadOnly, bool isShared, bool isSpecialNameAndRuntimeSpecial);
    public StateMachineFieldSymbol(NamedTypeSymbol stateMachineType, Symbol implicitlyDefinedBy, TypeSymbol type, string name, LocalSlotDebugInfo slotDebugInfo, int slotIndex, Accessibility accessibility, bool isReadOnly, bool isShared, bool isSpecialNameAndRuntimeSpecial);
    public sealed virtual override bool get_HasMethodBodyDependency();
    public sealed virtual override IMethodSymbol get_Method();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.StateMachineRewriter`1 : object {
    protected BoundStatement Body;
    protected MethodSymbol Method;
    protected DiagnosticBag Diagnostics;
    protected SyntheticBoundNodeFactory F;
    protected SynthesizedContainer StateMachineType;
    protected VariableSlotAllocator SlotAllocatorOpt;
    protected SynthesizedLocalOrdinalsDispenser SynthesizedLocalOrdinals;
    protected FieldSymbol StateField;
    protected Dictionary`2<Symbol, TProxy> nonReusableLocalProxies;
    protected int nextFreeHoistedLocalSlot;
    protected IReadOnlySet`1<Symbol> hoistedVariables;
    protected Dictionary`2<Symbol, TProxy> InitialParameters;
    protected bool PreserveInitialParameterValues { get; }
    internal TypeSubstitution TypeMap { get; }
    protected StateMachineRewriter`1(BoundStatement body, MethodSymbol method, StateMachineTypeSymbol stateMachineType, VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, DiagnosticBag diagnostics);
    protected abstract virtual bool get_PreserveInitialParameterValues();
    internal abstract virtual TypeSubstitution get_TypeMap();
    protected abstract virtual void GenerateControlFields();
    protected abstract virtual void InitializeStateMachine(ArrayBuilder`1<BoundStatement> bodyBuilder, NamedTypeSymbol frameType, LocalSymbol stateMachineLocal);
    protected abstract virtual BoundStatement GenerateStateMachineCreation(LocalSymbol stateMachineVariable, NamedTypeSymbol frameType);
    protected abstract virtual void GenerateMethodImplementations();
    protected BoundBlock Rewrite();
    private BoundBlock GenerateKickoffMethodBody();
    private void CreateNonReusableLocalProxies(Result captured, Int32& nextFreeHoistedLocalSlot);
    protected TProxy CaptureParameterSymbol(TypeSubstitution typeMap, ParameterSymbol parameter);
    protected TProxy CaptureLocalSymbol(TypeSubstitution typeMap, LocalSymbol local, Dictionary`2<LocalSymbol, BoundExpression> initializers);
    protected abstract virtual void InitializeParameterWithProxy(ParameterSymbol parameter, TProxy proxy, LocalSymbol stateMachineVariable, ArrayBuilder`1<BoundExpression> initializers);
    protected abstract virtual TProxy CreateByValLocalCapture(FieldSymbol field, LocalSymbol local);
    protected abstract virtual TProxy CreateParameterCapture(FieldSymbol field, ParameterSymbol parameter);
    protected virtual TProxy CreateByRefLocalCapture(TypeSubstitution typeMap, LocalSymbol local, Dictionary`2<LocalSymbol, BoundExpression> initializers);
    protected FieldSymbol MakeHoistedFieldForLocal(LocalSymbol local, TypeSymbol localType, int slotIndex, LocalDebugId id);
    internal virtual bool EnsureAllSymbolsAndSignature();
    internal Symbol EnsureSpecialType(SpecialType type, DiagnosticBag bag);
    internal Symbol EnsureWellKnownType(WellKnownType type, DiagnosticBag bag);
    internal Symbol EnsureSpecialMember(SpecialMember member, DiagnosticBag bag);
    internal Symbol EnsureWellKnownMember(WellKnownMember member, DiagnosticBag bag);
    internal void EnsureSpecialPropertyGetter(SpecialMember member, DiagnosticBag bag);
    internal SynthesizedMethod OpenMethodImplementation(WellKnownMember interfaceMethod, string name, Accessibility accessibility, bool hasMethodBodyDependency, PropertySymbol associatedProperty);
    internal SynthesizedMethod OpenMethodImplementation(SpecialMember interfaceMethod, string name, Accessibility accessibility, bool hasMethodBodyDependency, PropertySymbol associatedProperty);
    internal SynthesizedMethod OpenMethodImplementation(NamedTypeSymbol interfaceType, SpecialMember interfaceMethod, string name, Accessibility accessibility, bool hasMethodBodyDependency, PropertySymbol associatedProperty);
    private SynthesizedMethod OpenMethodImplementation(MethodSymbol methodToImplement, string methodName, Accessibility accessibility, bool hasMethodBodyDependency, PropertySymbol associatedProperty);
    internal MethodSymbol OpenPropertyImplementation(SpecialMember interfaceProperty, string name, Accessibility accessibility);
    internal MethodSymbol OpenPropertyImplementation(NamedTypeSymbol interfaceType, SpecialMember interfaceMethod, string name, Accessibility accessibility);
    private MethodSymbol OpenPropertyImplementation(MethodSymbol getterToImplement, string name, Accessibility accessibility);
    internal void CloseMethod(BoundStatement body);
    internal virtual BoundStatement RewriteBodyIfNeeded(BoundStatement body, MethodSymbol topMethod, MethodSymbol currentMethod);
    internal SynthesizedMethod OpenMoveNextMethodImplementation(WellKnownMember interfaceMethod, Accessibility accessibility);
    internal SynthesizedMethod OpenMoveNextMethodImplementation(SpecialMember interfaceMethod, Accessibility accessibility);
    private SynthesizedMethod OpenMoveNextMethodImplementation(MethodSymbol methodToImplement, Accessibility accessibility);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.StateMachineStates : object {
    public static int FinishedStateMachine;
    public static int NotStartedStateMachine;
    public static int FirstUnusedState;
    private static StateMachineStates();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.StateMachineTypeSymbol : SynthesizedContainer {
    private ImmutableArray`1<VisualBasicAttributeData> _attributes;
    public MethodSymbol KickoffMethod;
    public bool HasMethodBodyDependency { get; }
    public IMethodSymbol Method { get; }
    internal bool IsInterface { get; }
    public StateMachineTypeSymbol(VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, MethodSymbol kickoffMethod, int kickoffMethodOrdinal, NamedTypeSymbol baseType, ImmutableArray`1<NamedTypeSymbol> originalInterfaces);
    private static string MakeName(VariableSlotAllocator slotAllocatorOpt, TypeCompilationState compilationState, MethodSymbol kickoffMethod, int kickoffMethodOrdinal);
    public sealed virtual override bool get_HasMethodBodyDependency();
    public sealed virtual override IMethodSymbol get_Method();
    internal sealed virtual bool get_IsInterface();
    public sealed virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
}
internal class Microsoft.CodeAnalysis.VisualBasic.StatementListBinder : BlockBaseBinder {
    private SyntaxList`1<StatementSyntax> _statementList;
    private ImmutableArray`1<LocalSymbol> _locals;
    internal ImmutableArray`1<LocalSymbol> Locals { get; }
    public StatementListBinder(Binder containing, SyntaxList`1<StatementSyntax> statementList);
    internal virtual ImmutableArray`1<LocalSymbol> get_Locals();
    private ImmutableArray`1<LocalSymbol> BuildLocals();
}
internal class Microsoft.CodeAnalysis.VisualBasic.StatementSyntaxWalker : VisualBasicSyntaxVisitor {
    public virtual void VisitList(IEnumerable`1<VisualBasicSyntaxNode> list);
    public virtual void VisitCompilationUnit(CompilationUnitSyntax node);
    public virtual void VisitNamespaceBlock(NamespaceBlockSyntax node);
    public virtual void VisitModuleBlock(ModuleBlockSyntax node);
    public virtual void VisitClassBlock(ClassBlockSyntax node);
    public virtual void VisitStructureBlock(StructureBlockSyntax node);
    public virtual void VisitInterfaceBlock(InterfaceBlockSyntax node);
    public virtual void VisitEnumBlock(EnumBlockSyntax node);
    public virtual void VisitMethodBlock(MethodBlockSyntax node);
    public virtual void VisitConstructorBlock(ConstructorBlockSyntax node);
    public virtual void VisitOperatorBlock(OperatorBlockSyntax node);
    public virtual void VisitAccessorBlock(AccessorBlockSyntax node);
    public virtual void VisitPropertyBlock(PropertyBlockSyntax node);
    public virtual void VisitEventBlock(EventBlockSyntax node);
    public virtual void VisitWhileBlock(WhileBlockSyntax node);
    public virtual void VisitUsingBlock(UsingBlockSyntax node);
    public virtual void VisitSyncLockBlock(SyncLockBlockSyntax node);
    public virtual void VisitWithBlock(WithBlockSyntax node);
    public virtual void VisitSingleLineIfStatement(SingleLineIfStatementSyntax node);
    public virtual void VisitSingleLineElseClause(SingleLineElseClauseSyntax node);
    public virtual void VisitMultiLineIfBlock(MultiLineIfBlockSyntax node);
    public virtual void VisitElseIfBlock(ElseIfBlockSyntax node);
    public virtual void VisitElseBlock(ElseBlockSyntax node);
    public virtual void VisitTryBlock(TryBlockSyntax node);
    public virtual void VisitCatchBlock(CatchBlockSyntax node);
    public virtual void VisitFinallyBlock(FinallyBlockSyntax node);
    public virtual void VisitSelectBlock(SelectBlockSyntax node);
    public virtual void VisitCaseBlock(CaseBlockSyntax node);
    public virtual void VisitDoLoopBlock(DoLoopBlockSyntax node);
    public virtual void VisitForBlock(ForBlockSyntax node);
    public virtual void VisitForEachBlock(ForEachBlockSyntax node);
}
internal class Microsoft.CodeAnalysis.VisualBasic.StatementWalker : BoundTreeWalker {
    protected virtual BoundExpression VisitExpressionWithoutStackGuard(BoundExpression node);
}
internal class Microsoft.CodeAnalysis.VisualBasic.StringConstants : object {
    internal static string AnonymousTypeName;
    internal static string AnonymousMethodName;
    internal static string AsEnumerableMethod;
    internal static string AsQueryableMethod;
    internal static string DistinctMethod;
    internal static string CastMethod;
    internal static string DelegateConstructorInstanceParameterName;
    internal static string DelegateConstructorMethodParameterName;
    internal static string DelegateMethodCallbackParameterName;
    internal static string DelegateMethodInstanceParameterName;
    internal static string DelegateMethodResultParameterName;
    internal static string DelegateStubParameterPrefix;
    internal static string ElementAtMethod;
    internal static string Group;
    internal static string GroupByMethod;
    internal static string GroupJoinMethod;
    internal static string It;
    internal static string It1;
    internal static string It2;
    internal static string ItAnonymous;
    internal static string JoinMethod;
    internal static string Lambda;
    internal static string NamedSymbolErrorName;
    internal static string OrderByDescendingMethod;
    internal static string OrderByMethod;
    internal static string SelectManyMethod;
    internal static string SelectMethod;
    internal static string SkipMethod;
    internal static string SkipWhileMethod;
    internal static string TakeMethod;
    internal static string TakeWhileMethod;
    internal static string ThenByDescendingMethod;
    internal static string ThenByMethod;
    internal static string UnnamedNamespaceErrName;
    internal static string WhereMethod;
    internal static string HoistedMeName;
    internal static string HoistedUserVariablePrefix;
    internal static string HoistedSpecialVariablePrefix;
    internal static string HoistedWithLocalPrefix;
    internal static string StateMachineHoistedUserVariablePrefix;
    internal static string ClosureVariablePrefix;
    internal static string DisplayClassPrefix;
    internal static string StateMachineTypeNamePrefix;
    internal static string LambdaMethodNamePrefix;
    internal static string DisplayClassGenericParameterNamePrefix;
    internal static string BaseMethodWrapperNamePrefix;
    internal static string StateMachineBuilderFieldName;
    internal static string StateMachineStateFieldName;
    internal static string DelegateRelaxationDisplayClassPrefix;
    internal static string DelegateRelaxationMethodNamePrefix;
    internal static string HoistedSynthesizedLocalPrefix;
    internal static string LambdaCacheFieldPrefix;
    internal static string DelegateRelaxationCacheFieldPrefix;
    internal static string StateMachineAwaiterFieldPrefix;
    internal static string ReusableHoistedLocalFieldName;
    internal static string StateMachineExpressionCapturePrefix;
    internal static string StateMachineTypeParameterPrefix;
    internal static string IteratorCurrentFieldName;
    internal static string IteratorInitialThreadIdName;
    internal static string IteratorParameterProxyPrefix;
    internal static string StaticLocalFieldNamePrefix;
    internal static string PropertyGetPrefix;
    internal static string PropertySetPrefix;
    internal static string WinMdPropertySetPrefix;
    internal static string ValueParameterName;
    internal static string WithEventsValueParameterName;
    internal static string AutoPropertyValueParameterName;
    internal static string DefaultXmlnsPrefix;
    internal static string DefaultXmlNamespace;
    internal static string XmlPrefix;
    internal static string XmlNamespace;
    internal static string XmlnsPrefix;
    internal static string XmlnsNamespace;
    internal static string XmlAddMethodName;
    internal static string XmlGetMethodName;
    internal static string XmlElementsMethodName;
    internal static string XmlDescendantsMethodName;
    internal static string XmlAttributeValueMethodName;
    internal static string XmlCreateAttributeMethodName;
    internal static string XmlCreateNamespaceAttributeMethodName;
    internal static string XmlRemoveNamespaceAttributesMethodName;
    internal static string ValueProperty;
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.SubOrFunctionBodyBinder : ExecutableCodeBinder {
    private MethodSymbol _methodSymbol;
    protected Dictionary`2<string, Symbol> _parameterMap;
    public Symbol ContainingMember { get; }
    public SubOrFunctionBodyBinder(MethodSymbol methodOrLambdaSymbol, VisualBasicSyntaxNode root, Binder containingBinder);
    public virtual Symbol get_ContainingMember();
    public abstract virtual LocalSymbol GetLocalForFunctionValue();
    internal virtual void LookupInSingleBinder(LookupResult lookupResult, string name, int arity, LookupOptions options, Binder originalBinder, HashSet`1& useSiteDiagnostics);
    internal virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbol : object {
    public string Name { get; }
    public string MetadataName { get; }
    public SymbolKind Kind { get; }
    public Symbol ContainingSymbol { get; }
    public NamespaceSymbol ContainingNamespace { get; }
    public NamedTypeSymbol ContainingType { get; }
    internal NamespaceOrTypeSymbol ContainingNamespaceOrType { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    public ModuleSymbol ContainingModule { get; }
    public Symbol OriginalDefinition { get; }
    protected Symbol OriginalSymbolDefinition { get; }
    public bool IsDefinition { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsShared { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsImplicitlyDeclared { get; }
    internal ThreeState ObsoleteState { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal Symbol ImplicitlyDefinedBy { get; }
    internal bool ShadowsExplicitly { get; }
    public bool CanBeReferencedByName { get; }
    internal bool CanBeReferencedByNameIgnoringIllegalCharacters { get; }
    internal bool IsEmbedded { get; }
    internal EmbeddedSymbolKind EmbeddedSymbolKind { get; }
    internal Nullable`1<CharSet> EffectiveDefaultMarshallingCharSet { get; }
    internal bool Dangerous_IsFromSomeCompilationIncludingRetargeting { get; }
    internal bool IsLambdaMethod { get; }
    internal bool IsMyGroupCollectionProperty { get; }
    internal bool IsQueryLambdaMethod { get; }
    public bool HasUnsupportedMetadata { get; }
    protected int HighestPriorityUseSiteError { get; }
    private IAssemblySymbol ISymbol_ContainingAssembly { get; }
    private IModuleSymbol ISymbol_ContainingModule { get; }
    private INamespaceSymbol ISymbol_ContainingNamespace { get; }
    private ISymbol ISymbol_ContainingSymbol { get; }
    private INamedTypeSymbol ISymbol_ContainingType { get; }
    private Accessibility ISymbol_DeclaredAccessibility { get; }
    protected bool ISymbol_IsAbstract { get; }
    private bool ISymbol_IsDefinition { get; }
    private bool ISymbol_IsOverride { get; }
    protected bool ISymbol_IsSealed { get; }
    protected bool ISymbol_IsStatic { get; }
    private bool ISymbol_IsImplicitlyDeclared { get; }
    private bool ISymbol_IsVirtual { get; }
    private bool ISymbol_CanBeReferencedByName { get; }
    public string Language { get; }
    private ImmutableArray`1<Location> ISymbol_Locations { get; }
    private ImmutableArray`1<SyntaxReference> ISymbol_DeclaringSyntaxReferences { get; }
    private string ISymbol_Name { get; }
    private ISymbol ISymbol_OriginalDefinition { get; }
    private SymbolKind ISymbol_Kind { get; }
    private bool ISymbol_IsExtern { get; }
    internal virtual override IDefinition IReferenceAsDefinition(EmitContext context);
    internal virtual override void IReferenceDispatch(MetadataVisitor visitor);
    internal bool IsDefinitionOrDistinct();
    private sealed virtual override IEnumerable`1<ICustomAttribute> IReferenceGetAttributes(EmitContext context);
    internal virtual IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    internal IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState, bool emittingAssemblyAttributesInNetModule);
    internal IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ImmutableArray`1<VisualBasicAttributeData> userDefined, ArrayBuilder`1<SynthesizedAttributeData> synthesized, bool isReturnType, bool emittingAssemblyAttributesInNetModule);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbol/VB$StateMachine_7_GetCustomAttributesToEmitIterator")]
private IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmitIterator(ImmutableArray`1<VisualBasicAttributeData> userDefined, ArrayBuilder`1<SynthesizedAttributeData> synthesized, bool isReturnType, bool emittingAssemblyAttributesInNetModule);
    [ConditionalAttribute("DEBUG")]
protected internal void CheckDefinitionInvariant();
    internal static bool HaveSameSignature(MethodSymbol method1, MethodSymbol method2);
    internal static bool HaveSameSignatureAndConstraintsAndReturnType(MethodSymbol method1, MethodSymbol method2);
    public static bool IsSymbolAccessible(Symbol symbol, NamedTypeSymbol within, NamedTypeSymbol throughTypeOpt);
    public static bool IsSymbolAccessible(Symbol symbol, AssemblySymbol within);
    public virtual string get_Name();
    public virtual override string get_MetadataName();
    internal virtual void SetMetadataName(string metadataName);
    public abstract virtual SymbolKind get_Kind();
    public abstract virtual Symbol get_ContainingSymbol();
    public NamespaceSymbol get_ContainingNamespace();
    public virtual NamedTypeSymbol get_ContainingType();
    internal NamespaceOrTypeSymbol get_ContainingNamespaceOrType();
    public virtual AssemblySymbol get_ContainingAssembly();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
    public virtual ModuleSymbol get_ContainingModule();
    public Symbol get_OriginalDefinition();
    protected virtual Symbol get_OriginalSymbolDefinition();
    public bool get_IsDefinition();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public abstract virtual ImmutableArray`1<Location> get_Locations();
    public abstract virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal static ImmutableArray`1<VisualBasicSyntaxNode> GetDeclaringSyntaxNodeHelper(ImmutableArray`1<Location> locations);
    internal static ImmutableArray`1<SyntaxReference> GetDeclaringSyntaxReferenceHelper(ImmutableArray`1<Location> locations);
    internal static ImmutableArray`1<SyntaxReference> GetDeclaringSyntaxReferenceHelper(ImmutableArray`1<SyntaxReference> references);
    internal static ImmutableArray`1<SyntaxReference> GetDeclaringSyntaxReferenceHelper(SyntaxReference reference);
    public abstract virtual Accessibility get_DeclaredAccessibility();
    public abstract virtual bool get_IsShared();
    public abstract virtual bool get_IsOverridable();
    public abstract virtual bool get_IsOverrides();
    public abstract virtual bool get_IsMustOverride();
    public abstract virtual bool get_IsNotOverridable();
    public virtual bool get_IsImplicitlyDeclared();
    internal ThreeState get_ObsoleteState();
    internal abstract virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual Symbol get_ImplicitlyDefinedBy(Dictionary`2<string, ArrayBuilder`1<Symbol>> membersInProgress);
    internal virtual bool get_ShadowsExplicitly();
    public bool get_CanBeReferencedByName();
    internal bool get_CanBeReferencedByNameIgnoringIllegalCharacters();
    internal bool get_IsEmbedded();
    internal virtual EmbeddedSymbolKind get_EmbeddedSymbolKind();
    internal Nullable`1<CharSet> get_EffectiveDefaultMarshallingCharSet();
    internal bool IsFromCompilation(VisualBasicCompilation compilation);
    internal bool get_Dangerous_IsFromSomeCompilationIncludingRetargeting();
    internal virtual bool get_IsLambdaMethod();
    internal virtual bool get_IsMyGroupCollectionProperty();
    internal virtual bool get_IsQueryLambdaMethod();
    internal bool GetGuidStringDefaultImplementation(String& guidString);
    public virtual override string GetDocumentationCommentId();
    public virtual override string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    public static bool op_Equality(Symbol left, Symbol right);
    public static bool op_Inequality(Symbol left, Symbol right);
    public virtual bool Equals(object obj);
    public sealed virtual override bool Equals(ISymbol other);
    public virtual int GetHashCode();
    public sealed virtual string ToString();
    public string ToDisplayString(SymbolDisplayFormat format);
    public ImmutableArray`1<SymbolDisplayPart> ToDisplayParts(SymbolDisplayFormat format);
    public string ToMinimalDisplayString(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    public ImmutableArray`1<SymbolDisplayPart> ToMinimalDisplayParts(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    private string GetDebuggerDisplay();
    internal abstract virtual TResult Accept(VisualBasicSymbolVisitor`2<TArgument, TResult> visitor, TArgument arg);
    internal virtual bool IsDefinedInSourceTree(SyntaxTree tree, Nullable`1<TextSpan> definedWithinSpan, CancellationToken cancellationToken);
    internal static bool IsDefinedInSourceTree(SyntaxNode syntaxNode, SyntaxTree tree, Nullable`1<TextSpan> definedWithinSpan, CancellationToken cancellationToken);
    internal virtual void GenerateDeclarationErrors(CancellationToken cancellationToken);
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    public virtual override bool get_HasUnsupportedMetadata();
    internal DiagnosticInfo DeriveUseSiteErrorInfoFromType(TypeSymbol type);
    protected virtual int get_HighestPriorityUseSiteError();
    internal DiagnosticInfo MergeUseSiteErrorInfo(DiagnosticInfo first, DiagnosticInfo second);
    internal DiagnosticInfo DeriveUseSiteErrorInfoFromParameter(ParameterSymbol param, int highestPriorityUseSiteError);
    internal DiagnosticInfo DeriveUseSiteErrorInfoFromParameters(ImmutableArray`1<ParameterSymbol> parameters);
    internal DiagnosticInfo DeriveUseSiteErrorInfoFromCustomModifiers(ImmutableArray`1<CustomModifier> customModifiers);
    internal static DiagnosticInfo GetUnificationUseSiteDiagnosticRecursive(ImmutableArray`1<T> types, Symbol owner, HashSet`1& checkedTypes);
    internal static DiagnosticInfo GetUnificationUseSiteDiagnosticRecursive(ImmutableArray`1<CustomModifier> modifiers, Symbol owner, HashSet`1& checkedTypes);
    internal static DiagnosticInfo GetUnificationUseSiteDiagnosticRecursive(ImmutableArray`1<ParameterSymbol> parameters, Symbol owner, HashSet`1& checkedTypes);
    internal static DiagnosticInfo GetUnificationUseSiteDiagnosticRecursive(ImmutableArray`1<TypeParameterSymbol> typeParameters, Symbol owner, HashSet`1& checkedTypes);
    public abstract virtual override void Accept(SymbolVisitor visitor);
    public abstract virtual override TResult Accept(SymbolVisitor`1<TResult> visitor);
    public abstract virtual void Accept(VisualBasicSymbolVisitor visitor);
    public abstract virtual TResult Accept(VisualBasicSymbolVisitor`1<TResult> visitor);
    private sealed virtual override IAssemblySymbol get_ISymbol_ContainingAssembly();
    private sealed virtual override IModuleSymbol get_ISymbol_ContainingModule();
    private sealed virtual override INamespaceSymbol get_ISymbol_ContainingNamespace();
    private sealed virtual override ISymbol get_ISymbol_ContainingSymbol();
    private sealed virtual override INamedTypeSymbol get_ISymbol_ContainingType();
    private sealed virtual override Accessibility get_ISymbol_DeclaredAccessibility();
    protected virtual override bool get_ISymbol_IsAbstract();
    private sealed virtual override bool get_ISymbol_IsDefinition();
    private sealed virtual override bool get_ISymbol_IsOverride();
    protected virtual override bool get_ISymbol_IsSealed();
    protected virtual override bool get_ISymbol_IsStatic();
    private sealed virtual override bool get_ISymbol_IsImplicitlyDeclared();
    private sealed virtual override bool get_ISymbol_IsVirtual();
    private sealed virtual override bool get_ISymbol_CanBeReferencedByName();
    public sealed virtual override string get_Language();
    private sealed virtual override ImmutableArray`1<Location> get_ISymbol_Locations();
    private sealed virtual override ImmutableArray`1<SyntaxReference> get_ISymbol_DeclaringSyntaxReferences();
    private sealed virtual override string get_ISymbol_Name();
    private sealed virtual override ISymbol get_ISymbol_OriginalDefinition();
    private sealed virtual override SymbolKind get_ISymbol_Kind();
    private sealed virtual override string ISymbol_ToDisplayString(SymbolDisplayFormat format);
    private sealed virtual override ImmutableArray`1<SymbolDisplayPart> ISymbol_ToDisplayParts(SymbolDisplayFormat format);
    private sealed virtual override string ISymbol_ToMinimalDisplayString(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    private sealed virtual override ImmutableArray`1<SymbolDisplayPart> ISymbol_ToMinimalDisplayParts(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    private sealed virtual override bool get_ISymbol_IsExtern();
    private sealed virtual override ImmutableArray`1<AttributeData> ISymbol_GetAttributes();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal static void AddSynthesizedAttribute(ArrayBuilder`1& attributes, SynthesizedAttributeData attribute);
    internal AttributeTargets GetAttributeTarget();
    internal virtual VisualBasicAttributeData EarlyDecodeWellKnownAttribute(EarlyDecodeWellKnownAttributeArguments`4& arguments);
    internal bool EarlyDecodeDeprecatedOrObsoleteAttribute(EarlyDecodeWellKnownAttributeArguments`4& arguments, VisualBasicAttributeData& boundAttribute, ObsoleteAttributeData& obsoleteData);
    internal virtual void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    internal virtual void PostDecodeWellKnownAttributes(ImmutableArray`1<VisualBasicAttributeData> boundAttributes, ImmutableArray`1<AttributeSyntax> allAttributeSyntaxNodes, DiagnosticBag diagnostics, AttributeLocation symbolPart, WellKnownAttributeData decodedData);
    internal void LoadAndValidateAttributes(OneOrMany`1<SyntaxList`1<AttributeListSyntax>> attributeBlockSyntaxList, CustomAttributesBag`1& lazyCustomAttributesBag, AttributeLocation symbolPart);
    private ImmutableArray`1<AttributeSyntax> GetAttributesToBind(OneOrMany`1<SyntaxList`1<AttributeListSyntax>> attributeDeclarationSyntaxLists, AttributeLocation symbolPart, VisualBasicCompilation compilation, ImmutableArray`1& binders);
    internal Binder GetAttributeBinder(SyntaxList`1<AttributeListSyntax> syntaxList, SourceModuleSymbol sourceModule);
    private static bool MatchAttributeTarget(IAttributeTargetSymbol attributeTarget, AttributeLocation symbolPart, AttributeTargetSyntax targetOpt);
    private static ImmutableArray`1<AttributeSyntax> GetAttributesToBind(SyntaxList`1<AttributeListSyntax> attributeBlockSyntaxList);
    internal static void GetAttributesToBind(SyntaxList`1<AttributeListSyntax> attributeBlockSyntaxList, ArrayBuilder`1& attributeSyntaxBuilder);
    private EarlyWellKnownAttributeData EarlyDecodeWellKnownAttributes(ImmutableArray`1<Binder> binders, ImmutableArray`1<NamedTypeSymbol> boundAttributeTypes, ImmutableArray`1<AttributeSyntax> attributesToBind, VisualBasicAttributeData[] attributeBuilder, AttributeLocation symbolPart);
    internal WellKnownAttributeData ValidateAttributeUsageAndDecodeWellKnownAttributes(ImmutableArray`1<Binder> binders, ImmutableArray`1<AttributeSyntax> attributeSyntaxList, ImmutableArray`1<VisualBasicAttributeData> boundAttributes, DiagnosticBag diagnostics, AttributeLocation symbolPart);
    private bool ValidateAttributeUsage(VisualBasicAttributeData attribute, AttributeSyntax node, VisualBasicCompilation compilation, AttributeLocation symbolPart, DiagnosticBag diagnostics, HashSet`1<NamedTypeSymbol> uniqueAttributeTypes);
    private void ReportExtensionAttributeUseSiteError(VisualBasicAttributeData attribute, AttributeSyntax nodeOpt, VisualBasicCompilation compilation, DiagnosticBag diagnostics);
    private void MarkEmbeddedAttributeTypeReference(VisualBasicAttributeData attribute, AttributeSyntax nodeOpt, VisualBasicCompilation compilation);
    internal void ForceCompleteObsoleteAttribute();
}
[StandardModuleAttribute]
public class Microsoft.CodeAnalysis.VisualBasic.SymbolDisplay : object {
    public static string ToDisplayString(ISymbol symbol, SymbolDisplayFormat format);
    public static string ToMinimalDisplayString(ISymbol symbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    public static ImmutableArray`1<SymbolDisplayPart> ToDisplayParts(ISymbol symbol, SymbolDisplayFormat format);
    public static ImmutableArray`1<SymbolDisplayPart> ToMinimalDisplayParts(ISymbol symbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    private static ImmutableArray`1<SymbolDisplayPart> ToDisplayParts(ISymbol symbol, SemanticModel semanticModelOpt, int positionOpt, SymbolDisplayFormat format, bool minimal);
    public static string FormatPrimitive(object obj, bool quoteStrings, bool useHexadecimalNumbers);
    internal static void AddSymbolDisplayParts(ArrayBuilder`1<SymbolDisplayPart> parts, string str);
    internal static void AddSymbolDisplayParts(ArrayBuilder`1<SymbolDisplayPart> parts, char c);
}
internal class Microsoft.CodeAnalysis.VisualBasic.SymbolDisplayVisitor : AbstractSymbolDisplayVisitor`1<SemanticModel> {
    private bool _escapeKeywordIdentifiers;
    internal SymbolDisplayVisitor(ArrayBuilder`1<SymbolDisplayPart> builder, SymbolDisplayFormat format, SemanticModel semanticModelOpt, int positionOpt);
    private SymbolDisplayVisitor(ArrayBuilder`1<SymbolDisplayPart> builder, SymbolDisplayFormat format, SemanticModel semanticModelOpt, int positionOpt, bool escapeKeywordIdentifiers, bool isFirstSymbolVisited);
    public virtual void VisitField(IFieldSymbol symbol);
    public virtual void VisitProperty(IPropertySymbol symbol);
    public virtual void VisitEvent(IEventSymbol symbol);
    private void AddAccessor(ISymbol property, IMethodSymbol method, SyntaxKind keyword);
    public virtual void VisitMethod(IMethodSymbol symbol);
    private void AddMethodKind(IMethodSymbol symbol);
    private void AddMethodName(IMethodSymbol symbol);
    private void AddMethodGenericParameters(IMethodSymbol method);
    private void AddMethodParameters(IMethodSymbol method);
    private void AddMethodReturnType(IMethodSymbol method);
    private void VisitDeclareMethod(IMethodSymbol method);
    private static string Quote(string str);
    public virtual void VisitParameter(IParameterSymbol symbol);
    private void AddCustomModifiersIfRequired(ImmutableArray`1<CustomModifier> customModifiers, bool leadingSpace, bool trailingSpace);
    private void AddFieldModifiersIfRequired(IFieldSymbol symbol);
    private void AddMemberModifiersIfRequired(ISymbol symbol);
    private void AddParametersIfRequired(bool isExtensionMethod, ImmutableArray`1<IParameterSymbol> parameters);
    private bool IsWithEventsProperty(ISymbol symbol);
    private bool IsOverloads(ISymbol symbol);
    private bool IsDeclareMethod(IMethodSymbol method);
    private bool IsExplicitByRefParameter(IParameterSymbol parameter);
    [ConditionalAttribute("DEBUG")]
private void AssertContainingSymbol(ISymbol symbol);
    public virtual void VisitArrayType(IArrayTypeSymbol symbol);
    private void AddArrayRank(IArrayTypeSymbol symbol);
    public virtual void VisitDynamicType(IDynamicTypeSymbol symbol);
    public virtual void VisitPointerType(IPointerTypeSymbol symbol);
    public virtual void VisitTypeParameter(ITypeParameterSymbol symbol);
    public virtual void VisitNamedType(INamedTypeSymbol symbol);
    private bool CanShowDelegateSignature(INamedTypeSymbol symbol);
    private void AddNameAndTypeArgumentsOrParameters(INamedTypeSymbol symbol, bool noEscaping);
    private void AddAnonymousTypeName(INamedTypeSymbol symbol);
    private string CreateAnonymousTypeMember(IPropertySymbol prop);
    private string CreateAnonymousTypeMemberWorker(IPropertySymbol prop);
    private bool AddSpecialTypeKeyword(INamedTypeSymbol symbol);
    private void AddTypeKind(INamedTypeSymbol symbol);
    private static SyntaxKind GetTypeKindKeyword(TypeKind typeKind);
    private void AddTypeParameterVarianceIfRequired(ITypeParameterSymbol symbol);
    private void AddTypeArguments(ImmutableArray`1<ITypeSymbol> typeArguments, ImmutableArray`1<ImmutableArray`1<CustomModifier>> modifiers);
    private static int TypeParameterSpecialConstraintCount(ITypeParameterSymbol typeParam);
    private void AddTypeParameterConstraints(ITypeParameterSymbol typeParam);
    private static bool IsNullableType(INamedTypeSymbol symbol);
    protected virtual AbstractSymbolDisplayVisitor`1<SemanticModel> MakeNotFirstVisitor();
    internal SymbolDisplayPart CreatePart(SymbolDisplayPartKind kind, ISymbol symbol, string text, bool noEscaping);
    private static bool AlwaysEscape(SymbolDisplayPartKind kind, string text);
    private static bool IsEscapable(SymbolDisplayPartKind kind);
    private string EscapeIdentifier(string identifier);
    public virtual void VisitAssembly(IAssemblySymbol symbol);
    public virtual void VisitLabel(ILabelSymbol symbol);
    public virtual void VisitAlias(IAliasSymbol symbol);
    public virtual void VisitModule(IModuleSymbol symbol);
    public virtual void VisitNamespace(INamespaceSymbol symbol);
    private void VisitNamespace(INamespaceSymbol symbol, string emittedName);
    private void AddGlobalNamespace(INamespaceSymbol symbol);
    public virtual void VisitLocal(ILocalSymbol symbol);
    public virtual void VisitRangeVariable(IRangeVariableSymbol symbol);
    protected virtual void AddSpace();
    private void AddOperator(SyntaxKind operatorKind);
    private void AddPunctuation(SyntaxKind punctuationKind);
    private void AddPseudoPunctuation(string text);
    private void AddKeyword(SyntaxKind keywordKind);
    private void AddAccessibilityIfRequired(ISymbol symbol);
    private bool ShouldVisitNamespace(ISymbol containingSymbol);
    private bool IncludeNamedType(INamedTypeSymbol namedType);
    private static bool IsEnumMember(ISymbol symbol);
    protected virtual void AddBitwiseOr();
    protected virtual void AddExplicitlyCastedLiteralValue(INamedTypeSymbol namedType, SpecialType type, object value);
    protected virtual void AddLiteralValue(SpecialType type, object value);
    private void AddConstantValue(ITypeSymbol type, object constantValue, bool preferNumericValueOrExpandedFlagsForEnum);
    protected virtual bool ShouldRestrictMinimallyQualifyLookupToNamespacesAndTypes();
    private void MinimallyQualify(INamespaceSymbol symbol, string emittedName, string parentsEmittedName);
    private void MinimallyQualify(INamedTypeSymbol symbol);
    private bool TryAddAlias(INamespaceOrTypeSymbol symbol, ArrayBuilder`1<SymbolDisplayPart> builder);
    private IAliasSymbol GetAliasSymbol(INamespaceOrTypeSymbol symbol);
    private SyntaxTree GetSyntaxTree(SemanticModel semanticModel);
    private string RemoveAttributeSuffixIfNecessary(INamedTypeSymbol symbol, string symbolName);
    private bool IsDerivedFromAttributeType(INamedTypeSymbol derivedType);
    [CompilerGeneratedAttribute]
private string _Lambda$__30-0(IPropertySymbol p);
}
internal class Microsoft.CodeAnalysis.VisualBasic.SymbolInfoFactory : object {
    internal static SymbolInfo Create(ImmutableArray`1<Symbol> symbols, LookupResultKind resultKind);
    internal static SymbolInfo Create(ImmutableArray`1<ISymbol> symbols, LookupResultKind resultKind);
    internal static SymbolInfo Create(ImmutableArray`1<ISymbol> symbols, CandidateReason reason);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.AccessibilityExtensions : object {
    [ExtensionAttribute]
internal static string ToDiagnosticString(Accessibility a);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.AliasSymbol : Symbol {
    private NamespaceOrTypeSymbol _aliasTarget;
    private string _aliasName;
    private ImmutableArray`1<Location> _aliasLocations;
    private Symbol _aliasContainer;
    public string Name { get; }
    public SymbolKind Kind { get; }
    public NamespaceOrTypeSymbol Target { get; }
    private INamespaceOrTypeSymbol IAliasSymbol_Target { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsNotOverridable { get; }
    public bool IsMustOverride { get; }
    public bool IsOverrides { get; }
    public bool IsOverridable { get; }
    public bool IsShared { get; }
    public Accessibility DeclaredAccessibility { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public Symbol ContainingSymbol { get; }
    internal AliasSymbol(VisualBasicCompilation compilation, Symbol aliasContainer, string aliasName, NamespaceOrTypeSymbol aliasTarget, Location aliasLocation);
    public virtual string get_Name();
    public virtual SymbolKind get_Kind();
    public NamespaceOrTypeSymbol get_Target();
    private sealed virtual override INamespaceOrTypeSymbol get_IAliasSymbol_Target();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsShared();
    public virtual Accessibility get_DeclaredAccessibility();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual Symbol get_ContainingSymbol();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual TResult Accept(VisualBasicSymbolVisitor`2<TArg, TResult> visitor, TArg a);
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSymbolVisitor visitor);
    public virtual TResult Accept(VisualBasicSymbolVisitor`1<TResult> visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeDescriptor : ValueType {
    public static string SubReturnParameterName;
    public static string FunctionReturnParameterName;
    public Location Location;
    public ImmutableArray`1<AnonymousTypeField> Fields;
    public string Key;
    public bool IsImplicitlyDeclared;
    public ImmutableArray`1<AnonymousTypeField> Parameters { get; }
    public AnonymousTypeDescriptor(ImmutableArray`1<AnonymousTypeField> fields, Location _location, bool _isImplicitlyDeclared);
    internal static string GetReturnParameterName(bool isFunction);
    public ImmutableArray`1<AnonymousTypeField> get_Parameters();
    internal static string ComputeKey(ImmutableArray`1<T> fields, Func`2<T, string> getName, Func`2<T, bool> getIsKey);
    [ConditionalAttribute("DEBUG")]
internal void AssertGood();
    public sealed virtual override bool Equals(AnonymousTypeDescriptor other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool SubstituteTypeParametersIfNeeded(TypeSubstitution substitution, AnonymousTypeDescriptor& newDescriptor);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeExtensions : object {
    [ExtensionAttribute]
internal static bool IsSubDescription(ImmutableArray`1<AnonymousTypeField> fields);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeField : ValueType {
    public string Name;
    public Location Location;
    private TypeSymbol _type;
    public bool IsKey;
    public TypeSymbol Type { get; }
    public bool IsByRef { get; }
    public AnonymousTypeField(string name, TypeSymbol type, Location location, bool isKeyOrByRef);
    public AnonymousTypeField(string name, Location location, bool isKey);
    public TypeSymbol get_Type();
    public bool get_IsByRef();
    [ConditionalAttribute("DEBUG")]
internal void AssertGood();
    internal void AssignFieldType(TypeSymbol newType);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.AnonymousTypeManager : CommonAnonymousTypeManager {
    public VisualBasicCompilation Compilation;
    private ConcurrentDictionary`2<string, AnonymousTypeTemplateSymbol> _concurrentTypesCache;
    private ConcurrentDictionary`2<string, AnonymousDelegateTemplateSymbol> _concurrentDelegatesCache;
    public NamedTypeSymbol System_Boolean { get; }
    public NamedTypeSymbol System_Int32 { get; }
    public NamedTypeSymbol System_Object { get; }
    public NamedTypeSymbol System_IntPtr { get; }
    public NamedTypeSymbol System_IAsyncResult { get; }
    public NamedTypeSymbol System_AsyncCallback { get; }
    public NamedTypeSymbol System_MulticastDelegate { get; }
    public NamedTypeSymbol System_String { get; }
    public NamedTypeSymbol System_Void { get; }
    public MethodSymbol System_String__Format_IFormatProvider { get; }
    public MethodSymbol System_Object__ToString { get; }
    public MethodSymbol System_Runtime_CompilerServices_CompilerGeneratedAttribute__ctor { get; }
    public MethodSymbol System_Diagnostics_DebuggerDisplayAttribute__ctor { get; }
    public PropertySymbol System_Diagnostics_DebuggerDisplayAttribute__Type { get; }
    public MethodSymbol System_Object__GetHashCode { get; }
    public MethodSymbol System_Object__Equals { get; }
    public NamedTypeSymbol System_IEquatable_T { get; }
    public MethodSymbol System_IEquatable_T_Equals { get; }
    public SourceModuleSymbol ContainingModule { get; }
    private ConcurrentDictionary`2<string, AnonymousTypeTemplateSymbol> AnonymousTypeTemplates { get; }
    private ConcurrentDictionary`2<string, AnonymousDelegateTemplateSymbol> AnonymousDelegateTemplates { get; }
    internal ImmutableArray`1<NamedTypeSymbol> AllCreatedTemplates { get; }
    public AnonymousTypeManager(VisualBasicCompilation compilation);
    public bool ReportMissingOrErroneousSymbols(DiagnosticBag diagnostics, bool hasClass, bool hasDelegate, bool hasKeys);
    private static void ReportErrorOnSymbol(Symbol symbol, DiagnosticBag diagnostics, Boolean& hasError);
    private static void ReportErrorOnWellKnownMember(Symbol symbol, WellKnownMember member, DiagnosticBag diagnostics, Boolean& hasError, bool embedVBCore);
    private static void ReportErrorOnSpecialMember(Symbol symbol, SpecialMember member, DiagnosticBag diagnostics, Boolean& hasError, bool embedVBCore);
    private bool CheckAndReportMissingSymbols(ArrayBuilder`1<AnonymousTypeOrDelegateTemplateSymbol> anonymousTypes, DiagnosticBag diagnostics);
    public NamedTypeSymbol get_System_Boolean();
    public NamedTypeSymbol get_System_Int32();
    public NamedTypeSymbol get_System_Object();
    public NamedTypeSymbol get_System_IntPtr();
    public NamedTypeSymbol get_System_IAsyncResult();
    public NamedTypeSymbol get_System_AsyncCallback();
    public NamedTypeSymbol get_System_MulticastDelegate();
    public NamedTypeSymbol get_System_String();
    public NamedTypeSymbol get_System_Void();
    public MethodSymbol get_System_String__Format_IFormatProvider();
    public MethodSymbol get_System_Object__ToString();
    public MethodSymbol get_System_Runtime_CompilerServices_CompilerGeneratedAttribute__ctor();
    public MethodSymbol get_System_Diagnostics_DebuggerDisplayAttribute__ctor();
    public PropertySymbol get_System_Diagnostics_DebuggerDisplayAttribute__Type();
    public MethodSymbol get_System_Object__GetHashCode();
    public MethodSymbol get_System_Object__Equals();
    public NamedTypeSymbol get_System_IEquatable_T();
    public MethodSymbol get_System_IEquatable_T_Equals();
    public SourceModuleSymbol get_ContainingModule();
    public AnonymousTypePublicSymbol ConstructAnonymousTypeSymbol(AnonymousTypeDescriptor typeDescr);
    public AnonymousDelegatePublicSymbol ConstructAnonymousDelegateSymbol(AnonymousTypeDescriptor delegateDescriptor);
    public static bool EqualsIgnoringCustomModifiers(TypeSymbol left, TypeSymbol right);
    [ConditionalAttribute("DEBUG")]
private void CheckSourceLocationSeen(AnonymousTypeOrDelegatePublicSymbol anonymous);
    private ConcurrentDictionary`2<string, AnonymousTypeTemplateSymbol> get_AnonymousTypeTemplates();
    private ConcurrentDictionary`2<string, AnonymousDelegateTemplateSymbol> get_AnonymousDelegateTemplates();
    private NamedTypeSymbol ConstructAnonymousTypeImplementationSymbol(AnonymousTypePublicSymbol anonymous);
    private NamedTypeSymbol ConstructAnonymousDelegateImplementationSymbol(AnonymousDelegatePublicSymbol anonymous);
    private void AddFromCache(ArrayBuilder`1<AnonymousTypeOrDelegateTemplateSymbol> builder, ConcurrentDictionary`2<string, T> cache);
    private static AnonymousTypeDescriptor CreatePlaceholderTypeDescriptor(AnonymousTypeKey key);
    public void AssignTemplatesNamesAndCompile(MethodCompiler compiler, PEModuleBuilder moduleBeingBuilt, DiagnosticBag diagnostics);
    internal static AnonymousTypeKey GetAnonymousTypeKey(NamedTypeSymbol type);
    internal IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> GetAnonymousTypeMap();
    internal static bool IsAnonymousTypeTemplate(NamedTypeSymbol type);
    internal static NamedTypeSymbol TranslateAnonymousTypeSymbol(NamedTypeSymbol type);
    internal static MethodSymbol TranslateAnonymousTypeMethodSymbol(MethodSymbol method);
    internal ImmutableArray`1<NamedTypeSymbol> get_AllCreatedTemplates();
    private void GetAllCreatedTemplates(ArrayBuilder`1<AnonymousTypeOrDelegateTemplateSymbol> builder);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol : TypeSymbol {
    private bool IArrayTypeReferenceIsSZArray { get; }
    private IEnumerable`1<int> IArrayTypeReferenceLowerBounds { get; }
    private UInt32 IArrayTypeReferenceRank { get; }
    private IEnumerable`1<ulong> IArrayTypeReferenceSizes { get; }
    private bool ITypeReferenceIsEnum { get; }
    private bool ITypeReferenceIsValueType { get; }
    private TypeDefinitionHandle ITypeReferenceTypeDef { get; }
    private IGenericMethodParameterReference ITypeReferenceAsGenericMethodParameterReference { get; }
    private IGenericTypeInstanceReference ITypeReferenceAsGenericTypeInstanceReference { get; }
    private IGenericTypeParameterReference ITypeReferenceAsGenericTypeParameterReference { get; }
    private INamespaceTypeReference ITypeReferenceAsNamespaceTypeReference { get; }
    private INestedTypeReference ITypeReferenceAsNestedTypeReference { get; }
    private ISpecializedNestedTypeReference ITypeReferenceAsSpecializedNestedTypeReference { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public int Rank { get; }
    internal bool IsSZArray { get; }
    internal ImmutableArray`1<int> Sizes { get; }
    internal ImmutableArray`1<int> LowerBounds { get; }
    internal bool HasDefaultSizesAndLowerBounds { get; }
    public TypeSymbol ElementType { get; }
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    public SymbolKind Kind { get; }
    public TypeKind TypeKind { get; }
    public Symbol ContainingSymbol { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    private ITypeSymbol IArrayTypeSymbol_ElementType { get; }
    private int IArrayTypeSymbol_Rank { get; }
    private ImmutableArray`1<CustomModifier> IArrayTypeSymbol_CustomModifiers { get; }
    private sealed virtual override ITypeReference IArrayTypeReferenceGetElementType(EmitContext context);
    private sealed virtual override bool get_IArrayTypeReferenceIsSZArray();
    private sealed virtual override IEnumerable`1<int> get_IArrayTypeReferenceLowerBounds();
    private sealed virtual override UInt32 get_IArrayTypeReferenceRank();
    private sealed virtual override IEnumerable`1<ulong> get_IArrayTypeReferenceSizes();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.ArrayTypeSymbol/VB$StateMachine_10_GetSizes")]
private IEnumerable`1<ulong> GetSizes();
    private sealed virtual override bool get_ITypeReferenceIsEnum();
    private sealed virtual override bool get_ITypeReferenceIsValueType();
    private sealed virtual override ITypeDefinition ITypeReferenceGetResolvedType(EmitContext context);
    private sealed virtual override PrimitiveTypeCode ITypeReferenceTypeCode(EmitContext context);
    private sealed virtual override TypeDefinitionHandle get_ITypeReferenceTypeDef();
    private sealed virtual override IGenericMethodParameterReference get_ITypeReferenceAsGenericMethodParameterReference();
    private sealed virtual override IGenericTypeInstanceReference get_ITypeReferenceAsGenericTypeInstanceReference();
    private sealed virtual override IGenericTypeParameterReference get_ITypeReferenceAsGenericTypeParameterReference();
    private sealed virtual override INamespaceTypeDefinition ITypeReferenceAsNamespaceTypeDefinition(EmitContext context);
    private sealed virtual override INamespaceTypeReference get_ITypeReferenceAsNamespaceTypeReference();
    private sealed virtual override INestedTypeDefinition ITypeReferenceAsNestedTypeDefinition(EmitContext context);
    private sealed virtual override INestedTypeReference get_ITypeReferenceAsNestedTypeReference();
    private sealed virtual override ISpecializedNestedTypeReference get_ITypeReferenceAsSpecializedNestedTypeReference();
    private sealed virtual override ITypeDefinition ITypeReferenceAsTypeDefinition(EmitContext context);
    internal sealed virtual void IReferenceDispatch(MetadataVisitor visitor);
    internal sealed virtual IDefinition IReferenceAsDefinition(EmitContext context);
    internal static ArrayTypeSymbol CreateVBArray(TypeSymbol elementType, ImmutableArray`1<CustomModifier> customModifiers, int rank, VisualBasicCompilation compilation);
    internal static ArrayTypeSymbol CreateVBArray(TypeSymbol elementType, ImmutableArray`1<CustomModifier> customModifiers, int rank, AssemblySymbol declaringAssembly);
    internal static ArrayTypeSymbol CreateMDArray(TypeSymbol elementType, ImmutableArray`1<CustomModifier> customModifiers, int rank, ImmutableArray`1<int> sizes, ImmutableArray`1<int> lowerBounds, AssemblySymbol declaringAssembly);
    internal static ArrayTypeSymbol CreateSZArray(TypeSymbol elementType, ImmutableArray`1<CustomModifier> customModifiers, VisualBasicCompilation compilation);
    internal static ArrayTypeSymbol CreateSZArray(TypeSymbol elementType, ImmutableArray`1<CustomModifier> customModifiers, AssemblySymbol declaringAssembly);
    private static ImmutableArray`1<NamedTypeSymbol> GetSZArrayInterfaces(TypeSymbol elementType, AssemblySymbol declaringAssembly);
    public abstract virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public abstract virtual int get_Rank();
    internal abstract virtual bool get_IsSZArray();
    internal bool HasSameShapeAs(ArrayTypeSymbol other);
    internal virtual ImmutableArray`1<int> get_Sizes();
    internal virtual ImmutableArray`1<int> get_LowerBounds();
    internal bool HasSameSizesAndLowerBoundsAs(ArrayTypeSymbol other);
    internal abstract virtual bool get_HasDefaultSizesAndLowerBounds();
    public abstract virtual TypeSymbol get_ElementType();
    internal abstract virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsValueType();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public virtual SymbolKind get_Kind();
    public virtual TypeKind get_TypeKind();
    public virtual Symbol get_ContainingSymbol();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual TResult Accept(VisualBasicSymbolVisitor`2<TArgument, TResult> visitor, TArgument arg);
    public virtual Accessibility get_DeclaredAccessibility();
    internal abstract virtual TypeWithModifiers InternalSubstituteTypeParameters(TypeSubstitution substitution);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    internal virtual DiagnosticInfo GetUnificationUseSiteDiagnosticRecursive(Symbol owner, HashSet`1& checkedTypes);
    private sealed virtual override ITypeSymbol get_IArrayTypeSymbol_ElementType();
    private sealed virtual override int get_IArrayTypeSymbol_Rank();
    private sealed virtual override ImmutableArray`1<CustomModifier> get_IArrayTypeSymbol_CustomModifiers();
    private sealed virtual override bool IArrayTypeSymbol_Equals(IArrayTypeSymbol symbol);
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSymbolVisitor visitor);
    public virtual TResult Accept(VisualBasicSymbolVisitor`1<TResult> visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.AssemblySymbol : Symbol {
    private AssemblySymbol _corLibrary;
    private static Char[] s_nestedTypeNameSeparators;
    internal AssemblySymbol CorLibrary { get; }
    public string Name { get; }
    public bool IsInteractive { get; }
    public AssemblyIdentity Identity { get; }
    public Version AssemblyVersionPattern { get; }
    internal Machine Machine { get; }
    internal bool Bit32Required { get; }
    public ImmutableArray`1<ModuleSymbol> Modules { get; }
    public NamespaceSymbol GlobalNamespace { get; }
    public SymbolKind Kind { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal bool IsMissing { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Symbol ContainingSymbol { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool KeepLookingForDeclaredSpecialTypes { get; }
    internal bool IsLinked { get; }
    public ICollection`1<string> TypeNames { get; }
    public ICollection`1<string> NamespaceNames { get; }
    internal NamedTypeSymbol ObjectType { get; }
    public bool MightContainExtensionMethods { get; }
    internal ImmutableArray`1<byte> PublicKey { get; }
    private INamespaceSymbol IAssemblySymbol_GlobalNamespace { get; }
    private IEnumerable`1<IModuleSymbol> IAssemblySymbol_Modules { get; }
    private static AssemblySymbol();
    internal AssemblySymbol get_CorLibrary();
    internal void SetCorLibrary(AssemblySymbol corLibrary);
    public virtual string get_Name();
    public virtual override bool get_IsInteractive();
    public abstract virtual override AssemblyMetadata GetMetadata();
    public abstract virtual override AssemblyIdentity get_Identity();
    public abstract virtual override Version get_AssemblyVersionPattern();
    internal Machine get_Machine();
    internal bool get_Bit32Required();
    public abstract virtual ImmutableArray`1<ModuleSymbol> get_Modules();
    public abstract virtual NamespaceSymbol get_GlobalNamespace();
    internal NamespaceSymbol GetAssemblyNamespace(NamespaceSymbol namespaceSymbol);
    public sealed virtual SymbolKind get_Kind();
    public sealed virtual AssemblySymbol get_ContainingAssembly();
    internal virtual TResult Accept(VisualBasicSymbolVisitor`2<TArgument, TResult> visitor, TArgument arg);
    internal abstract virtual bool get_IsMissing();
    public sealed virtual Accessibility get_DeclaredAccessibility();
    public sealed virtual bool get_IsMustOverride();
    public sealed virtual bool get_IsNotOverridable();
    public sealed virtual bool get_IsOverridable();
    public sealed virtual bool get_IsOverrides();
    public sealed virtual bool get_IsShared();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public sealed virtual Symbol get_ContainingSymbol();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal NamedTypeSymbol LookupTopLevelMetadataType(MetadataTypeName& emittedName, bool digThroughForwardedTypes);
    internal abstract virtual NamedTypeSymbol LookupTopLevelMetadataTypeWithCycleDetection(MetadataTypeName& emittedName, ConsList`1<AssemblySymbol> visitedAssemblies, bool digThroughForwardedTypes);
    public NamedTypeSymbol ResolveForwardedType(string fullyQualifiedMetadataName);
    internal NamedTypeSymbol TryLookupForwardedMetadataType(MetadataTypeName& emittedName, bool ignoreCase);
    internal virtual NamedTypeSymbol TryLookupForwardedMetadataTypeWithCycleDetection(MetadataTypeName& emittedName, ConsList`1<AssemblySymbol> visitedAssemblies, bool ignoreCase);
    internal ErrorTypeSymbol CreateCycleInTypeForwarderErrorTypeSymbol(MetadataTypeName& emittedName);
    internal abstract virtual NamedTypeSymbol GetDeclaredSpecialType(SpecialType type);
    internal virtual void RegisterDeclaredSpecialType(NamedTypeSymbol corType);
    internal virtual bool get_KeepLookingForDeclaredSpecialTypes();
    internal abstract virtual ImmutableArray`1<AssemblySymbol> GetNoPiaResolutionAssemblies();
    internal abstract virtual void SetNoPiaResolutionAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal abstract virtual ImmutableArray`1<AssemblySymbol> GetLinkedReferencedAssemblies();
    internal abstract virtual void SetLinkedReferencedAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal abstract virtual bool get_IsLinked();
    internal virtual bool GetGuidString(String& guidString);
    public abstract virtual override ICollection`1<string> get_TypeNames();
    public abstract virtual override ICollection`1<string> get_NamespaceNames();
    internal abstract virtual IEnumerable`1<ImmutableArray`1<byte>> GetInternalsVisibleToPublicKeys(string simpleName);
    internal abstract virtual bool AreInternalsVisibleToThisAssembly(AssemblySymbol other);
    internal NamedTypeSymbol GetSpecialType(SpecialType type);
    internal NamedTypeSymbol get_ObjectType();
    internal NamedTypeSymbol GetPrimitiveType(PrimitiveTypeCode type);
    public NamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName);
    internal NamedTypeSymbol GetTypeByMetadataName(string metadataName, bool includeReferences, bool isWellKnownType, bool useCLSCompliantNameArityEncoding);
    internal NamedTypeSymbol GetTopLevelTypeByMetadataName(MetadataTypeName& metadataName, bool includeReferences, bool isWellKnownType);
    internal static bool IsAcceptableMatchForGetTypeByNameAndArity(NamedTypeSymbol candidate);
    public abstract virtual override bool get_MightContainExtensionMethods();
    internal abstract virtual ImmutableArray`1<byte> get_PublicKey();
    protected IVTConclusion PerformIVTCheck(ImmutableArray`1<byte> key, AssemblyIdentity otherIdentity);
    internal bool IsValidWellKnownType(NamedTypeSymbol result);
    private sealed virtual override INamespaceSymbol get_IAssemblySymbol_GlobalNamespace();
    private sealed virtual override bool IAssemblySymbol_GivesAccessTo(IAssemblySymbol toAssembly);
    private sealed virtual override IEnumerable`1<IModuleSymbol> get_IAssemblySymbol_Modules();
    private sealed virtual override INamedTypeSymbol IAssemblySymbol_ResolveForwardedType(string metadataName);
    private sealed virtual override INamedTypeSymbol IAssemblySymbol_GetTypeByMetadataName(string metadataName);
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSymbolVisitor visitor);
    public virtual TResult Accept(VisualBasicSymbolVisitor`1<TResult> visitor);
    internal virtual Symbol GetSpecialTypeMember(SpecialMember member);
    internal virtual Symbol GetDeclaredSpecialTypeMember(SpecialMember member);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.AttributeDataExtensions : object {
    [ExtensionAttribute]
public static int IndexOfAttribute(ImmutableArray`1<VisualBasicAttributeData> attributes, Symbol targetSymbol, AttributeDescription description);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.VisualBasic.Symbols.AttributeLocation : Enum {
    public int value__;
    public static AttributeLocation None;
    public static AttributeLocation Assembly;
    public static AttributeLocation Module;
    public static AttributeLocation Type;
    public static AttributeLocation Method;
    public static AttributeLocation Field;
    public static AttributeLocation Property;
    public static AttributeLocation Event;
    public static AttributeLocation Parameter;
    public static AttributeLocation Return;
    public static AttributeLocation TypeParameter;
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.BaseTypeAnalysis : object {
    internal static DiagnosticInfo GetDependenceDiagnosticForBase(SourceNamedTypeSymbol this, ConsList`1<Symbol> basesBeingResolved);
    internal static DiagnosticInfo GetDependenceDiagnosticForBase(SourceNamedTypeSymbol this, TypeSymbol base);
    private static DiagnosticInfo GetInheritanceDetails(ConsList`1<DependencyDesc> chain);
    private static DiagnosticInfo GetBaseTypeReferenceDetails(ConsList`1<DependencyDesc> chain);
    private static DiagnosticInfo GetInheritanceOrDependenceDetails(ConsList`1<DependencyDesc> chain, ERRID inheritsOrDepends);
    private static ConsList`1<DependencyDesc> GetDependenceChain(HashSet`1<Symbol> visited, SourceNamedTypeSymbol root, TypeSymbol current);
    internal static DiagnosticInfo GetDependencyDiagnosticsForImportedClass(NamedTypeSymbol this);
    internal static DiagnosticInfo GetDependencyDiagnosticsForImportedBaseInterface(NamedTypeSymbol this, NamedTypeSymbol base);
    private static bool HasCycles(HashSet`1<TypeSymbol> derived, HashSet`1<TypeSymbol> verified, NamedTypeSymbol interface);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.BoundLambdaParameterSymbol : LambdaParameterSymbol {
    private LambdaSymbol _lambdaSymbol;
    private VisualBasicSyntaxNode _syntaxNode;
    public VisualBasicSyntaxNode Syntax { get; }
    public Symbol ContainingSymbol { get; }
    public BoundLambdaParameterSymbol(string name, int ordinal, TypeSymbol type, bool isByRef, VisualBasicSyntaxNode syntaxNode, Location location);
    public VisualBasicSyntaxNode get_Syntax();
    public virtual Symbol get_ContainingSymbol();
    public void SetLambdaSymbol(LambdaSymbol lambda);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.ConstantValueUtils : object {
    public static EvaluatedConstant EvaluateFieldConstant(SourceFieldSymbol field, SyntaxReference equalsValueOrAsNewNodeRef, SymbolsInProgress`1<FieldSymbol> inProgress, DiagnosticBag diagnostics);
    private static BoundExpression BindFieldOrEnumInitializer(Binder binder, FieldSymbol fieldOrEnumSymbol, VisualBasicSyntaxNode equalsValueOrAsNewSyntax, DiagnosticBag diagnostics, ConstantValue& constValue);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.ConstraintsHelper : object {
    private static Func`3<TypeSymbol, CheckConstraintsDiagnosticsBuilders, bool> s_checkConstraintsSingleTypeFunc;
    private static ConstraintsHelper();
    [ExtensionAttribute]
public static ImmutableArray`1<TypeParameterConstraint> RemoveDirectConstraintConflicts(TypeParameterSymbol typeParameter, ImmutableArray`1<TypeParameterConstraint> constraints, ConsList`1<TypeParameterSymbol> inProgress, DirectConstraintConflictKind reportConflicts, ArrayBuilder`1<TypeParameterDiagnosticInfo> diagnosticsBuilder);
    [ExtensionAttribute]
public static void ReportIndirectConstraintConflicts(SourceTypeParameterSymbol typeParameter, ArrayBuilder`1<TypeParameterDiagnosticInfo> diagnosticsBuilder, ArrayBuilder`1& useSiteDiagnosticsBuilder);
    [ExtensionAttribute]
public static void CheckAllConstraints(TypeSymbol type, Location loc, DiagnosticBag diagnostics);
    [ExtensionAttribute]
public static void CheckAllConstraints(TypeSymbol type, ArrayBuilder`1<TypeParameterDiagnosticInfo> diagnosticsBuilder, ArrayBuilder`1& useSiteDiagnosticsBuilder);
    private static bool CheckConstraintsSingleType(TypeSymbol type, CheckConstraintsDiagnosticsBuilders diagnostics);
    [ExtensionAttribute]
public static bool CheckConstraints(NamedTypeSymbol type, SeparatedSyntaxList`1<TypeSyntax> typeArgumentsSyntax, DiagnosticBag diagnostics);
    [ExtensionAttribute]
public static bool CheckConstraints(NamedTypeSymbol type, ArrayBuilder`1<TypeParameterDiagnosticInfo> diagnosticsBuilder, ArrayBuilder`1& useSiteDiagnosticsBuilder);
    [ExtensionAttribute]
public static bool CheckConstraints(MethodSymbol method, Location diagnosticLocation, DiagnosticBag diagnostics);
    [ExtensionAttribute]
public static bool CheckConstraints(MethodSymbol method, ArrayBuilder`1<TypeParameterDiagnosticInfo> diagnosticsBuilder, ArrayBuilder`1& useSiteDiagnosticsBuilder);
    private static bool CheckTypeConstraints(NamedTypeSymbol type, ArrayBuilder`1<TypeParameterDiagnosticInfo> diagnosticsBuilder, ArrayBuilder`1& useSiteDiagnosticsBuilder);
    private static bool CheckMethodConstraints(MethodSymbol method, ArrayBuilder`1<TypeParameterDiagnosticInfo> diagnosticsBuilder, ArrayBuilder`1& useSiteDiagnosticsBuilder);
    [ExtensionAttribute]
public static bool CheckConstraints(Symbol constructedSymbol, TypeSubstitution substitution, ImmutableArray`1<TypeParameterSymbol> typeParameters, ImmutableArray`1<TypeSymbol> typeArguments, ArrayBuilder`1<TypeParameterDiagnosticInfo> diagnosticsBuilder, ArrayBuilder`1& useSiteDiagnosticsBuilder);
    public static bool CheckConstraints(Symbol constructedSymbol, TypeSubstitution substitution, TypeParameterSymbol typeParameter, TypeSymbol typeArgument, ArrayBuilder`1<TypeParameterDiagnosticInfo> diagnosticsBuilder, HashSet`1& useSiteDiagnostics);
    private static bool AppendUseSiteDiagnostics(HashSet`1<DiagnosticInfo> useSiteDiagnostics, TypeParameterSymbol typeParameter, ArrayBuilder`1& useSiteDiagnosticsBuilder);
    [ExtensionAttribute]
public static TypeSymbol GetNonInterfaceConstraint(TypeParameterSymbol typeParameter, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
public static NamedTypeSymbol GetClassConstraint(TypeParameterSymbol typeParameter, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
private static void GetAllConstraints(TypeParameterSymbol typeParameter, ArrayBuilder`1<TypeParameterAndConstraint> constraintsBuilder, Nullable`1<TypeParameterConstraint> fromConstraintOpt);
    private static bool SatisfiesTypeConstraint(TypeSymbol typeArgument, TypeSymbol constraintType, HashSet`1& useSiteDiagnostics);
    private static bool SatisfiesConstructorConstraint(TypeParameterSymbol typeParameter, TypeSymbol typeArgument, ArrayBuilder`1<TypeParameterDiagnosticInfo> diagnosticsBuilder);
    private static bool SatisfiesReferenceTypeConstraint(TypeParameterSymbol typeParameter, TypeSymbol typeArgument, ArrayBuilder`1<TypeParameterDiagnosticInfo> diagnosticsBuilder);
    private static bool SatisfiesValueTypeConstraint(Symbol constructedSymbol, TypeParameterSymbol typeParameter, TypeSymbol typeArgument, ArrayBuilder`1<TypeParameterDiagnosticInfo> diagnosticsBuilder, HashSet`1& useSiteDiagnostics);
    private static bool HasConflict(TypeParameterConstraint constraint1, TypeParameterConstraint constraint2, HashSet`1& useSiteDiagnostics);
    private static bool HasValueTypeConstraintConflict(TypeParameterConstraint constraint, HashSet`1& useSiteDiagnostics);
    private static bool HasReferenceTypeConstraintConflict(TypeParameterConstraint constraint);
    private static bool IsNullableTypeOrTypeParameter(TypeSymbol type, HashSet`1& useSiteDiagnostics);
    private static CompoundDiagnosticInfo GetConstraintCycleInfo(ConsList`1<TypeParameterSymbol> cycle);
    public static bool HasPublicParameterlessConstructor(NamedTypeSymbol type);
    private static bool ContainsTypeConstraint(ArrayBuilder`1<TypeParameterConstraint> constraints, TypeSymbol constraintType);
    private static bool RequiresChecking(NamedTypeSymbol type);
    private static bool RequiresChecking(MethodSymbol method);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.CRC32 : object {
    private static UInt32[] s_CRC32_LOOKUP_TABLE;
    private static UInt32 s_CRC32_poly;
    private static UnicodeEncoding s_encoding;
    private static CRC32();
    public static UInt32 ComputeCRC32(String[] names);
    private static UInt32 Crc32Update(UInt32 crc32, Byte[] bytes);
    private static UInt32 CalcEntry(UInt32 crc);
    private static UInt32[] InitCrc32Table();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.CrefTypeParameterSymbol : TypeParameterSymbol {
    private int _ordinal;
    private string _name;
    private SyntaxReference _syntaxReference;
    public int Ordinal { get; }
    public string Name { get; }
    public bool HasConstructorConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    internal ImmutableArray`1<TypeSymbol> ConstraintTypesNoUseSiteDiagnostics { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public TypeParameterKind TypeParameterKind { get; }
    public VarianceKind Variance { get; }
    public CrefTypeParameterSymbol(int ordinal, string name, TypeSyntax syntax);
    public virtual int get_Ordinal();
    public virtual string get_Name();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    public virtual bool get_HasConstructorConstraint();
    public virtual bool get_HasReferenceTypeConstraint();
    public virtual bool get_HasValueTypeConstraint();
    internal virtual ImmutableArray`1<TypeSymbol> get_ConstraintTypesNoUseSiteDiagnostics();
    internal virtual ImmutableArray`1<TypeParameterConstraint> GetConstraints();
    internal virtual void ResolveConstraints(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual void EnsureAllConstraintsAreResolved();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual TypeParameterKind get_TypeParameterKind();
    public virtual VarianceKind get_Variance();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.CustomEventAccessorSymbol : SourceNonPropertyAccessorMethodSymbol {
    private SourceEventSymbol _event;
    private string _name;
    private ImmutableArray`1<MethodSymbol> _lazyExplicitImplementations;
    private static CheckParameterModifierDelegate s_checkAddRemoveParameterModifierCallback;
    private static CheckParameterModifierDelegate s_checkRaiseParameterModifierCallback;
    public string Name { get; }
    public string MetadataName { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public Accessibility DeclaredAccessibility { get; }
    public Symbol AssociatedSymbol { get; }
    internal bool ShadowsExplicitly { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public MethodSymbol OverriddenMethod { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public bool IsExtensionMethod { get; }
    internal bool MayBeReducibleExtensionMethod { get; }
    public bool IsSub { get; }
    private static CustomEventAccessorSymbol();
    internal CustomEventAccessorSymbol(SourceMemberContainerTypeSymbol container, SourceEventSymbol event, string name, SourceMemberFlags flags, SyntaxReference syntaxRef, Location location);
    public virtual string get_Name();
    public virtual string get_MetadataName();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual Accessibility get_DeclaredAccessibility();
    protected virtual ImmutableArray`1<ParameterSymbol> GetParameters(SourceModuleSymbol sourceModule, DiagnosticBag diagBag);
    public virtual Symbol get_AssociatedSymbol();
    internal virtual bool get_ShadowsExplicitly();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual MethodSymbol get_OverriddenMethod();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual bool get_IsExtensionMethod();
    internal virtual bool get_MayBeReducibleExtensionMethod();
    protected virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    protected virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetReturnTypeAttributeDeclarations();
    public virtual bool get_IsSub();
    private ImmutableArray`1<ParameterSymbol> BindParameters(Location location, Binder binder, ParameterListSyntax parameterListOpt, DiagnosticBag diagnostics);
    private static SourceParameterFlags CheckEventMethodParameterModifier(Symbol container, SyntaxToken token, SourceParameterFlags flag, DiagnosticBag diagnostics);
    private static SourceParameterFlags CheckAddRemoveParameterModifier(Symbol container, SyntaxToken token, SourceParameterFlags flag, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.CustomModifierUtils : object {
    public static ImmutableArray`1<ParameterSymbol> CopyParameterCustomModifiers(ImmutableArray`1<ParameterSymbol> overriddenMemberParameters, ImmutableArray`1<ParameterSymbol> parameters);
    public static bool CopyParameterCustomModifiers(ParameterSymbol overriddenParam, ParameterSymbol& thisParam);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.Declaration : object {
    [CompilerGeneratedAttribute]
private string _Name;
    public DeclarationKind Kind { get; }
    public string Name { get; public set; }
    public ImmutableArray`1<Declaration> Children { get; }
    protected Declaration(string name);
    public abstract virtual DeclarationKind get_Kind();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string AutoPropertyValue);
    public ImmutableArray`1<Declaration> get_Children();
    protected abstract virtual ImmutableArray`1<Declaration> GetDeclarationChildren();
}
internal enum Microsoft.CodeAnalysis.VisualBasic.Symbols.DeclarationKind : Enum {
    public byte value__;
    public static DeclarationKind Namespace;
    public static DeclarationKind Class;
    public static DeclarationKind Interface;
    public static DeclarationKind Structure;
    public static DeclarationKind Enum;
    public static DeclarationKind Delegate;
    public static DeclarationKind Module;
    public static DeclarationKind Script;
    public static DeclarationKind Submission;
    public static DeclarationKind ImplicitClass;
    public static DeclarationKind EventSyntheticDelegate;
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.VisualBasic.Symbols.DeclarationModifiers : Enum {
    public int value__;
    public static DeclarationModifiers None;
    public static DeclarationModifiers Private;
    public static DeclarationModifiers Protected;
    public static DeclarationModifiers Friend;
    public static DeclarationModifiers Public;
    public static DeclarationModifiers AllAccessibilityModifiers;
    public static DeclarationModifiers Shared;
    public static DeclarationModifiers ReadOnly;
    public static DeclarationModifiers WriteOnly;
    public static DeclarationModifiers AllWriteabilityModifiers;
    public static DeclarationModifiers Overrides;
    public static DeclarationModifiers Overridable;
    public static DeclarationModifiers MustOverride;
    public static DeclarationModifiers NotOverridable;
    public static DeclarationModifiers AllOverrideModifiers;
    public static DeclarationModifiers Overloads;
    public static DeclarationModifiers Shadows;
    public static DeclarationModifiers AllShadowingModifiers;
    public static DeclarationModifiers Default;
    public static DeclarationModifiers WithEvents;
    public static DeclarationModifiers Widening;
    public static DeclarationModifiers Narrowing;
    public static DeclarationModifiers AllConversionModifiers;
    public static DeclarationModifiers Partial;
    public static DeclarationModifiers MustInherit;
    public static DeclarationModifiers NotInheritable;
    public static DeclarationModifiers Async;
    public static DeclarationModifiers Iterator;
    public static DeclarationModifiers Dim;
    public static DeclarationModifiers Const;
    public static DeclarationModifiers Static;
    public static DeclarationModifiers InvalidInNotInheritableClass;
    public static DeclarationModifiers InvalidInModule;
    public static DeclarationModifiers InvalidInInterface;
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.DeclarationModifiersExtensions : object {
    [ExtensionAttribute]
internal static Accessibility ToAccessibility(DeclarationModifiers modifiers);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.DeclarationTable : object {
    public static DeclarationTable Empty;
    private ImmutableSetWithInsertionOrder`1<DeclarationTableEntry> _allOlderRootDeclarations;
    private DeclarationTableEntry _latestLazyRootDeclaration;
    private Cache _cache;
    private MergedNamespaceDeclaration _mergedRoot;
    private Lazy`1<ICollection`1<string>> _typeNames;
    private Lazy`1<ICollection`1<string>> _namespaceNames;
    private Lazy`1<ICollection`1<ReferenceDirective>> _referenceDirectives;
    private ImmutableArray`1<RootSingleNamespaceDeclaration> _lazyAllRootDeclarations;
    private static Predicate`1<Declaration> s_isNamespacePredicate;
    private static Predicate`1<Declaration> s_isTypePredicate;
    public ICollection`1<string> TypeNames { get; }
    public ICollection`1<string> NamespaceNames { get; }
    public ICollection`1<ReferenceDirective> ReferenceDirectives { get; }
    private static DeclarationTable();
    private DeclarationTable(ImmutableSetWithInsertionOrder`1<DeclarationTableEntry> allOlderRootDeclarations, DeclarationTableEntry latestLazyRootDeclaration, Cache cache);
    public DeclarationTable AddRootDeclaration(DeclarationTableEntry lazyRootDeclaration);
    public DeclarationTable RemoveRootDeclaration(DeclarationTableEntry lazyRootDeclaration);
    public ImmutableArray`1<RootSingleNamespaceDeclaration> AllRootNamespaces();
    private void GetOlderNamespaces(ArrayBuilder`1<RootSingleNamespaceDeclaration> builder);
    private MergedNamespaceDeclaration MergeOlderNamespaces();
    private ImmutableArray`1<T> SelectManyFromOlderDeclarationsNoEmbedded(Func`2<RootSingleNamespaceDeclaration, ImmutableArray`1<T>> selector);
    public MergedNamespaceDeclaration GetMergedRoot(VisualBasicCompilation compilation);
    internal MergedNamespaceDeclaration CalculateMergedRoot(VisualBasicCompilation compilation);
    private ICollection`1<string> GetMergedTypeNames();
    private ICollection`1<string> GetMergedNamespaceNames();
    private ICollection`1<ReferenceDirective> GetMergedReferenceDirectives();
    private RootSingleNamespaceDeclaration GetLatestRootDeclarationIfAny(bool includeEmbedded);
    private static ICollection`1<string> GetTypeNames(Declaration declaration);
    private static ICollection`1<string> GetNamespaceNames(Declaration declaration);
    private static ICollection`1<string> GetNames(Declaration declaration, Predicate`1<Declaration> predicate);
    public ICollection`1<string> get_TypeNames();
    public ICollection`1<string> get_NamespaceNames();
    public ICollection`1<ReferenceDirective> get_ReferenceDirectives();
    public static bool ContainsName(MergedNamespaceDeclaration mergedRoot, Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.DeclarationTableEntry : object {
    public Lazy`1<RootSingleNamespaceDeclaration> Root;
    public bool IsEmbedded;
    public DeclarationTableEntry(Lazy`1<RootSingleNamespaceDeclaration> root, bool isEmbedded);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.DeclarationTreeBuilder : VisualBasicSyntaxVisitor`1<SingleNamespaceOrTypeDeclaration> {
    private ImmutableArray`1<string> _rootNamespace;
    private string _scriptClassName;
    private bool _isSubmission;
    private SyntaxTree _syntaxTree;
    private DeclarationTreeBuilder(SyntaxTree syntaxTree, ImmutableArray`1<string> rootNamespace, string scriptClassName, bool isSubmission);
    public static RootSingleNamespaceDeclaration ForTree(SyntaxTree tree, ImmutableArray`1<string> rootNamespace, string scriptClassName, bool isSubmission);
    private SingleNamespaceOrTypeDeclaration ForDeclaration(SyntaxNode node);
    private ImmutableArray`1<SingleNamespaceOrTypeDeclaration> VisitNamespaceChildren(VisualBasicSyntaxNode node, SyntaxList`1<StatementSyntax> members);
    private ArrayBuilder`1<SingleNamespaceOrTypeDeclaration> VisitNamespaceChildren(VisualBasicSyntaxNode node, SyntaxList`1<StatementSyntax> members, SingleNamespaceOrTypeDeclaration& implicitClass);
    private static ImmutableArray`1<ReferenceDirective> GetReferenceDirectives(CompilationUnitSyntax compilationUnit);
    private SingleNamespaceOrTypeDeclaration CreateImplicitClass(VisualBasicSyntaxNode parent, String[] memberNames, ImmutableArray`1<SingleTypeDeclaration> children, TypeDeclarationFlags declFlags);
    private SingleNamespaceOrTypeDeclaration CreateScriptClass(VisualBasicSyntaxNode parent, ImmutableArray`1<SingleTypeDeclaration> children, String[] memberNames, TypeDeclarationFlags declFlags);
    public virtual SingleNamespaceOrTypeDeclaration VisitCompilationUnit(CompilationUnitSyntax node);
    private void FindGlobalDeclarations(ImmutableArray`1<SingleNamespaceOrTypeDeclaration> declarations, SingleNamespaceOrTypeDeclaration implicitClass, ImmutableArray`1& globalDeclarations, ImmutableArray`1& nonGlobal);
    private string UnescapeIdentifier(string identifier);
    private SingleNamespaceDeclaration BuildRootNamespace(CompilationUnitSyntax node, ImmutableArray`1<SingleNamespaceOrTypeDeclaration> children);
    public virtual SingleNamespaceOrTypeDeclaration VisitNamespaceBlock(NamespaceBlockSyntax nsBlockSyntax);
    private SingleNamespaceOrTypeDeclaration VisitTypeBlockNew(TypeBlockSyntax topTypeBlockSyntax);
    public virtual SingleNamespaceOrTypeDeclaration VisitModuleBlock(ModuleBlockSyntax moduleBlockSyntax);
    public virtual SingleNamespaceOrTypeDeclaration VisitClassBlock(ClassBlockSyntax classBlockSyntax);
    public virtual SingleNamespaceOrTypeDeclaration VisitStructureBlock(StructureBlockSyntax structureBlockSyntax);
    public virtual SingleNamespaceOrTypeDeclaration VisitInterfaceBlock(InterfaceBlockSyntax interfaceBlockSyntax);
    public virtual SingleNamespaceOrTypeDeclaration VisitEnumBlock(EnumBlockSyntax enumBlockSyntax);
    private ImmutableArray`1<SingleTypeDeclaration> VisitTypeChildren(SyntaxList`1<StatementSyntax> members);
    private String[] GetNonTypeMemberNames(SyntaxList`1<StatementSyntax> members, TypeDeclarationFlags& declFlags);
    private String[] GetMemberNames(EnumBlockSyntax enumBlockSyntax, TypeDeclarationFlags& declFlags);
    private void AddMemberNames(MethodBaseSyntax methodDecl, PooledHashSet`1<string> results);
    public virtual SingleNamespaceOrTypeDeclaration VisitDelegateStatement(DelegateStatementSyntax node);
    public virtual SingleNamespaceOrTypeDeclaration VisitEventStatement(EventStatementSyntax node);
    public static DeclarationKind GetKind(SyntaxKind kind);
    public static int GetArity(TypeParameterListSyntax typeParamsSyntax);
    private static DeclarationModifiers GetModifiers(SyntaxTokenList modifiers);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.VisualBasic.Symbols.DirectConstraintConflictKind : Enum {
    public int value__;
    public static DirectConstraintConflictKind None;
    public static DirectConstraintConflictKind DuplicateTypeConstraint;
    public static DirectConstraintConflictKind RedundantConstraint;
    public static DirectConstraintConflictKind All;
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.EmbeddedResources : object {
    private static string s_embedded;
    private static string s_internalXmlHelper;
    private static string s_vbCoreSourceText;
    private static string s_vbMyTemplateText;
    public static string Embedded { get; }
    public static string InternalXmlHelper { get; }
    public static string VbCoreSourceText { get; }
    public static string VbMyTemplateText { get; }
    public static string get_Embedded();
    public static string get_InternalXmlHelper();
    public static string get_VbCoreSourceText();
    public static string get_VbMyTemplateText();
    private static string GetManifestResourceString(string name);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.EmbeddedSymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsEmbeddedSyntaxTree(SyntaxTree tree);
    [ExtensionAttribute]
public static EmbeddedSymbolKind GetEmbeddedKind(SyntaxTree tree);
    [ExtensionAttribute]
public static bool IsEmbeddedOrMyTemplateTree(SyntaxTree tree);
    [ExtensionAttribute]
public static bool IsEmbeddedOrMyTemplateLocation(Location location);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.VisualBasic.Symbols.EmbeddedSymbolKind : Enum {
    public byte value__;
    public static EmbeddedSymbolKind None;
    public static EmbeddedSymbolKind Unset;
    public static EmbeddedSymbolKind EmbeddedAttribute;
    public static EmbeddedSymbolKind VbCore;
    public static EmbeddedSymbolKind XmlHelper;
    public static EmbeddedSymbolKind All;
    public static EmbeddedSymbolKind LastValue;
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.EmbeddedSymbolManager : object {
    internal Func`2<Symbol, bool> IsReferencedPredicate;
    private EmbeddedSymbolKind _embedded;
    private ConcurrentDictionary`2<Symbol, bool> _symbols;
    private int _sealed;
    private bool _standardModuleAttributeReferenced;
    private static SyntaxTree s_embeddedSyntax;
    private static SyntaxTree s_vbCoreSyntax;
    private static SyntaxTree s_internalXmlHelperSyntax;
    public EmbeddedSymbolKind Embedded { get; }
    public bool IsAnySymbolReferenced { get; }
    public static SyntaxTree EmbeddedSyntax { get; }
    public static SyntaxTree VbCoreSyntaxTree { get; }
    public static SyntaxTree InternalXmlHelperSyntax { get; }
    private static EmbeddedSymbolManager();
    public EmbeddedSymbolManager(EmbeddedSymbolKind embedded);
    public EmbeddedSymbolKind get_Embedded();
    public void RegisterModuleDeclaration();
    public void MarkAllDeferredSymbolsAsReferenced(VisualBasicCompilation compilation);
    [ConditionalAttribute("DEBUG")]
internal void AssertMarkAllDeferredSymbolsAsReferencedIsCalled();
    public bool get_IsAnySymbolReferenced();
    internal void GetCurrentReferencedSymbolsSnapshot(ArrayBuilder`1<Symbol> builder, ConcurrentSet`1<Symbol> filter);
    public void MarkSymbolAsReferenced(Symbol symbol, ConcurrentSet`1<Symbol> allSymbols);
    public void MarkSymbolAsReferenced(Symbol symbol);
    public bool IsSymbolReferenced(Symbol symbol);
    public void SealCollection();
    private void AddReferencedSymbolWithDependents(Symbol symbol, ConcurrentSet`1<Symbol> allSymbols);
    private void AddReferencedSymbolRaw(Symbol symbol, ConcurrentSet`1<Symbol> allSymbols);
    [ConditionalAttribute("DEBUG")]
private static void ValidateType(NamedTypeSymbol type);
    [ConditionalAttribute("DEBUG")]
private static void ValidateField(FieldSymbol field);
    [ConditionalAttribute("DEBUG")]
internal static void ValidateMethod(MethodSymbol method);
    internal static EmbeddedSymbolKind GetEmbeddedKind(SyntaxTree tree);
    internal static SyntaxTree GetEmbeddedTree(EmbeddedSymbolKind kind);
    public static SyntaxTree get_EmbeddedSyntax();
    public static SyntaxTree get_VbCoreSyntaxTree();
    public static SyntaxTree get_InternalXmlHelperSyntax();
    [CompilerGeneratedAttribute]
private bool _Lambda$__6-0(Symbol t);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.EnumConversions : object {
    [ExtensionAttribute]
internal static TypeKind ToCommon(TypeKind kind);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.ErrorMethodSymbol : MethodSymbol {
    public static ErrorMethodSymbol UnknownMethod;
    private TypeSymbol _containingType;
    private TypeSymbol _returnType;
    private string _name;
    public int Arity { get; }
    public Symbol AssociatedSymbol { get; }
    internal CallingConvention CallingConvention { get; }
    public Symbol ContainingSymbol { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal bool HasSpecialName { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    public bool IsAsync { get; }
    public bool IsExtensionMethod { get; }
    public bool IsExternalMethod { get; }
    public bool IsIterator { get; }
    internal bool IsMethodKindBasedOnSyntax { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverloads { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public bool IsSub { get; }
    public bool IsVararg { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public MethodKind MethodKind { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    internal MarshalPseudoCustomAttributeData ReturnTypeMarshallingInformation { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    internal bool GenerateDebugInfoImpl { get; }
    private static ErrorMethodSymbol();
    public ErrorMethodSymbol(TypeSymbol containingType, TypeSymbol returnType, string name);
    public virtual int get_Arity();
    public virtual Symbol get_AssociatedSymbol();
    internal virtual CallingConvention get_CallingConvention();
    public virtual Symbol get_ContainingSymbol();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    public virtual DllImportData GetDllImportData();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual bool get_HasSpecialName();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    public virtual bool get_IsAsync();
    public virtual bool get_IsExtensionMethod();
    public virtual bool get_IsExternalMethod();
    public virtual bool get_IsIterator();
    internal virtual bool get_IsMethodKindBasedOnSyntax();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsShared();
    public virtual bool get_IsSub();
    public virtual bool get_IsVararg();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual MethodKind get_MethodKind();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnTypeMarshallingInformation();
    internal virtual VisualBasicSyntaxNode get_Syntax();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_GenerateDebugInfoImpl();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.ErrorTypeSymbol : NamedTypeSymbol {
    internal static ErrorTypeSymbol UnknownResultType;
    internal DiagnosticInfo ErrorInfo { get; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public SymbolKind Kind { get; }
    public TypeKind TypeKind { get; }
    internal bool IsInterface { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public int Arity { get; }
    public NamedTypeSymbol EnumUnderlyingType { get; }
    public string Name { get; }
    internal bool MangleName { get; }
    internal bool HasSpecialName { get; }
    internal bool IsSerializable { get; }
    internal TypeLayout Layout { get; }
    internal CharSet MarshallingCharSet { get; }
    internal ImmutableArray`1<TypeSymbol> TypeArgumentsNoUseSiteDiagnostics { get; }
    internal bool HasTypeArgumentsCustomModifiers { get; }
    internal ImmutableArray`1<ImmutableArray`1<CustomModifier>> TypeArgumentsCustomModifiers { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public NamedTypeSymbol ConstructedFrom { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsMustInherit { get; }
    public bool IsNotInheritable { get; }
    public bool MightContainExtensionMethods { get; }
    internal bool HasEmbeddedAttribute { get; }
    internal bool IsExtensibleInterfaceNoUseSiteDiagnostics { get; }
    internal bool IsWindowsRuntimeImport { get; }
    internal bool ShouldAddWinRTMembers { get; }
    internal bool IsComImport { get; }
    internal TypeSymbol CoClassType { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal TypeSubstitution TypeSubstitution { get; }
    internal bool CanConstruct { get; }
    internal string DefaultPropertyName { get; }
    internal NamedTypeSymbol NonErrorGuessType { get; }
    internal LookupResultKind ResultKind { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public ImmutableArray`1<Symbol> CandidateSymbols { get; }
    public CandidateReason CandidateReason { get; }
    public ImmutableArray`1<ISymbol> IErrorTypeSymbol_CandidateSymbols { get; }
    private static ErrorTypeSymbol();
    internal virtual DiagnosticInfo get_ErrorInfo();
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    internal virtual DiagnosticInfo GetUnificationUseSiteDiagnosticRecursive(Symbol owner, HashSet`1& checkedTypes);
    internal virtual NamedTypeSymbol MakeDeclaredBase(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<NamedTypeSymbol> MakeDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    internal virtual NamedTypeSymbol MakeAcyclicBaseType(DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<NamedTypeSymbol> MakeAcyclicInterfaces(DiagnosticBag diagnostics);
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsValueType();
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    internal virtual IEnumerable`1<FieldSymbol> GetFieldsToEmit();
    public sealed virtual SymbolKind get_Kind();
    public sealed virtual TypeKind get_TypeKind();
    internal sealed virtual bool get_IsInterface();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual int get_Arity();
    public virtual NamedTypeSymbol get_EnumUnderlyingType();
    public virtual string get_Name();
    internal virtual bool get_MangleName();
    internal sealed virtual bool get_HasSpecialName();
    internal sealed virtual bool get_IsSerializable();
    internal virtual TypeLayout get_Layout();
    internal virtual CharSet get_MarshallingCharSet();
    internal virtual ImmutableArray`1<TypeSymbol> get_TypeArgumentsNoUseSiteDiagnostics();
    internal virtual bool get_HasTypeArgumentsCustomModifiers();
    internal virtual ImmutableArray`1<ImmutableArray`1<CustomModifier>> get_TypeArgumentsCustomModifiers();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual NamedTypeSymbol get_ConstructedFrom();
    internal virtual TResult Accept(VisualBasicSymbolVisitor`2<TArgument, TResult> visitor, TArgument arg);
    public sealed virtual Accessibility get_DeclaredAccessibility();
    public sealed virtual bool get_IsMustInherit();
    public sealed virtual bool get_IsNotInheritable();
    public sealed virtual bool get_MightContainExtensionMethods();
    internal virtual bool get_HasEmbeddedAttribute();
    internal virtual bool get_IsExtensibleInterfaceNoUseSiteDiagnostics();
    internal virtual bool get_IsWindowsRuntimeImport();
    internal virtual bool get_ShouldAddWinRTMembers();
    internal virtual bool get_IsComImport();
    internal virtual TypeSymbol get_CoClassType();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual AttributeUsageInfo GetAttributeUsageInfo();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual TypeWithModifiers InternalSubstituteTypeParameters(TypeSubstitution substitution);
    internal virtual TypeSubstitution get_TypeSubstitution();
    internal virtual bool get_CanConstruct();
    public virtual NamedTypeSymbol Construct(ImmutableArray`1<TypeSymbol> typeArguments);
    internal virtual string get_DefaultPropertyName();
    internal NamedTypeSymbol get_NonErrorGuessType();
    internal virtual LookupResultKind get_ResultKind();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual ImmutableArray`1<Symbol> get_CandidateSymbols();
    public sealed virtual override CandidateReason get_CandidateReason();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual void GenerateDeclarationErrors(CancellationToken cancellationToken);
    public sealed virtual override ImmutableArray`1<ISymbol> get_IErrorTypeSymbol_CandidateSymbols();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.EvaluatedConstant : object {
    public static EvaluatedConstant None;
    public ConstantValue Value;
    public TypeSymbol Type;
    private static EvaluatedConstant();
    public EvaluatedConstant(ConstantValue value, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSignatureComparer : object {
    public static EventSignatureComparer ExplicitEventImplementationComparer;
    public static EventSignatureComparer OverrideSignatureComparer;
    public static EventSignatureComparer RuntimeEventSignatureComparer;
    public static EventSignatureComparer WinRTConflictComparer;
    private bool _considerName;
    private bool _considerType;
    private bool _considerCustomModifiers;
    private static EventSignatureComparer();
    private EventSignatureComparer(bool considerName, bool considerType, bool considerCustomModifiers);
    public sealed virtual override bool Equals(EventSymbol event1, EventSymbol event2);
    public sealed virtual override int GetHashCode(EventSymbol event);
    private static bool HaveSameTypes(EventSymbol event1, EventSymbol event2, bool considerCustomModifiers);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.EventSymbol : Symbol {
    private IEnumerable`1<IMethodReference> IEventDefinitionAccessors { get; }
    private IMethodReference IEventDefinitionAdder { get; }
    private IMethodReference IEventDefinitionRemover { get; }
    private bool IEventDefinitionIsRuntimeSpecial { get; }
    internal bool HasRuntimeSpecialName { get; }
    private bool IEventDefinitionIsSpecialName { get; }
    private IMethodReference IEventDefinitionCaller { get; }
    private ITypeDefinition IEventDefinitionContainingTypeDefinition { get; }
    private TypeMemberVisibility IEventDefinitionVisibility { get; }
    private string IEventDefinitionName { get; }
    public EventSymbol OriginalDefinition { get; }
    protected Symbol OriginalSymbolDefinition { get; }
    public bool IsWindowsRuntimeEvent { get; }
    public TypeSymbol Type { get; }
    public MethodSymbol AddMethod { get; }
    public MethodSymbol RemoveMethod { get; }
    public MethodSymbol RaiseMethod { get; }
    internal bool HasSpecialName { get; }
    internal bool HasAssociatedField { get; }
    internal FieldSymbol AssociatedField { get; }
    public EventSymbol OverriddenEvent { get; }
    internal OverriddenMembersResult`1<EventSymbol> OverriddenOrHiddenMembers { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<EventSymbol> ExplicitInterfaceImplementations { get; }
    public SymbolKind Kind { get; }
    internal ImmutableArray`1<ParameterSymbol> DelegateParameters { get; }
    internal TypeSymbol DelegateReturnType { get; }
    internal ImmutableArray`1<CustomModifier> DelegateReturnTypeCustomModifiers { get; }
    protected int HighestPriorityUseSiteError { get; }
    public bool HasUnsupportedMetadata { get; }
    internal EmbeddedSymbolKind EmbeddedSymbolKind { get; }
    private ITypeSymbol IEventSymbol_Type { get; }
    private IMethodSymbol IEventSymbol_AddMethod { get; }
    private IMethodSymbol IEventSymbol_RemoveMethod { get; }
    private IMethodSymbol IEventSymbol_RaiseMethod { get; }
    private IEventSymbol IEventSymbol_OriginalDefinition { get; }
    private IEventSymbol IEventSymbol_OverriddenEvent { get; }
    private ImmutableArray`1<IEventSymbol> IEventSymbol_ExplicitInterfaceImplementations { get; }
    private sealed virtual override IEnumerable`1<IMethodReference> get_IEventDefinitionAccessors();
    private sealed virtual override IMethodReference get_IEventDefinitionAdder();
    private sealed virtual override IMethodReference get_IEventDefinitionRemover();
    private sealed virtual override bool get_IEventDefinitionIsRuntimeSpecial();
    internal virtual bool get_HasRuntimeSpecialName();
    private sealed virtual override bool get_IEventDefinitionIsSpecialName();
    private sealed virtual override IMethodReference get_IEventDefinitionCaller();
    private sealed virtual override ITypeReference IEventDefinitionGetType(EmitContext context);
    private sealed virtual override ITypeDefinition get_IEventDefinitionContainingTypeDefinition();
    private sealed virtual override TypeMemberVisibility get_IEventDefinitionVisibility();
    private sealed virtual override ITypeReference ITypeMemberReferenceGetContainingType(EmitContext context);
    internal virtual void IReferenceDispatch(MetadataVisitor visitor);
    internal virtual IDefinition IReferenceAsDefinition(EmitContext context);
    private sealed virtual override string get_IEventDefinitionName();
    public virtual EventSymbol get_OriginalDefinition();
    protected sealed virtual Symbol get_OriginalSymbolDefinition();
    public abstract virtual override bool get_IsWindowsRuntimeEvent();
    public abstract virtual TypeSymbol get_Type();
    public abstract virtual MethodSymbol get_AddMethod();
    public abstract virtual MethodSymbol get_RemoveMethod();
    public abstract virtual MethodSymbol get_RaiseMethod();
    internal abstract virtual bool get_HasSpecialName();
    internal bool get_HasAssociatedField();
    public ImmutableArray`1<VisualBasicAttributeData> GetFieldAttributes();
    internal abstract virtual FieldSymbol get_AssociatedField();
    public EventSymbol get_OverriddenEvent();
    internal virtual OverriddenMembersResult`1<EventSymbol> get_OverriddenOrHiddenMembers();
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public abstract virtual ImmutableArray`1<EventSymbol> get_ExplicitInterfaceImplementations();
    public sealed virtual SymbolKind get_Kind();
    internal virtual ImmutableArray`1<ParameterSymbol> get_DelegateParameters();
    internal TypeSymbol get_DelegateReturnType();
    internal ImmutableArray`1<CustomModifier> get_DelegateReturnTypeCustomModifiers();
    private MethodSymbol DelegateInvokeMethod();
    internal virtual TResult Accept(VisualBasicSymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    internal DiagnosticInfo CalculateUseSiteErrorInfo();
    protected virtual int get_HighestPriorityUseSiteError();
    public sealed virtual bool get_HasUnsupportedMetadata();
    internal virtual EmbeddedSymbolKind get_EmbeddedSymbolKind();
    private sealed virtual override ITypeSymbol get_IEventSymbol_Type();
    private sealed virtual override IMethodSymbol get_IEventSymbol_AddMethod();
    private sealed virtual override IMethodSymbol get_IEventSymbol_RemoveMethod();
    private sealed virtual override IMethodSymbol get_IEventSymbol_RaiseMethod();
    private sealed virtual override IEventSymbol get_IEventSymbol_OriginalDefinition();
    private sealed virtual override IEventSymbol get_IEventSymbol_OverriddenEvent();
    private sealed virtual override ImmutableArray`1<IEventSymbol> get_IEventSymbol_ExplicitInterfaceImplementations();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSymbolVisitor visitor);
    public virtual TResult Accept(VisualBasicSymbolVisitor`1<TResult> visitor);
    public sealed virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.EventWellKnownAttributeData : CommonEventWellKnownAttributeData {
    private bool _hasNonSerializedAttribute;
    internal bool HasNonSerializedAttribute { get; internal set; }
    internal bool get_HasNonSerializedAttribute();
    internal void set_HasNonSerializedAttribute(bool value);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.ExtendedErrorTypeSymbol : InstanceErrorTypeSymbol {
    private DiagnosticInfo _diagnosticInfo;
    private bool _reportErrorWhenReferenced;
    private string _name;
    private ImmutableArray`1<Symbol> _candidateSymbols;
    private LookupResultKind _resultKind;
    private NamespaceOrTypeSymbol _containingSymbol;
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Symbol> CandidateSymbols { get; }
    internal LookupResultKind ResultKind { get; }
    internal DiagnosticInfo ErrorInfo { get; }
    public string Name { get; }
    internal bool MangleName { get; }
    internal ExtendedErrorTypeSymbol(DiagnosticInfo errorInfo, bool reportErrorWhenReferenced, NamedTypeSymbol nonErrorGuessType);
    internal ExtendedErrorTypeSymbol(DiagnosticInfo errorInfo, string name, bool reportErrorWhenReferenced, NamedTypeSymbol nonErrorGuessType);
    internal ExtendedErrorTypeSymbol(DiagnosticInfo errorInfo, string name, int arity, ImmutableArray`1<Symbol> candidateSymbols, LookupResultKind resultKind, bool reportErrorWhenReferenced);
    internal ExtendedErrorTypeSymbol(DiagnosticInfo errorInfo, string name, int arity, bool reportErrorWhenReferenced, NamedTypeSymbol nonErrorGuessType);
    internal ExtendedErrorTypeSymbol(NamespaceOrTypeSymbol containingSymbol, string name, int arity);
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Symbol> get_CandidateSymbols();
    internal virtual LookupResultKind get_ResultKind();
    internal virtual DiagnosticInfo get_ErrorInfo();
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    public virtual string get_Name();
    internal virtual bool get_MangleName();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldOrPropertyInitializer : ValueType {
    public ImmutableArray`1<Symbol> FieldsOrProperties;
    public SyntaxReference Syntax;
    internal int PrecedingInitializersLength;
    internal bool IsMetadataConstant;
    public FieldOrPropertyInitializer(SyntaxReference syntax, int precedingInitializersLength);
    public FieldOrPropertyInitializer(FieldSymbol field, SyntaxReference syntax, int precedingInitializersLength);
    public FieldOrPropertyInitializer(ImmutableArray`1<Symbol> fieldsOrProperties, SyntaxReference syntax, int precedingInitializersLength);
    public FieldOrPropertyInitializer(PropertySymbol property, SyntaxReference syntax, int precedingInitializersLength);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.FieldSymbol : Symbol {
    private ISpecializedFieldReference IFieldReferenceAsSpecializedFieldReference { get; }
    private string INamedEntityName { get; }
    internal bool IFieldReferenceIsContextualNamedEntity { get; }
    private ImmutableArray`1<byte> IFieldDefinitionFieldMapping { get; }
    private bool IFieldDefinitionIsCompileTimeConstant { get; }
    private bool IFieldDefinitionIsNotSerialized { get; }
    private bool IFieldDefinitionIsReadOnly { get; }
    private bool IFieldDefinitionIsRuntimeSpecial { get; }
    private bool IFieldDefinitionIsSpecialName { get; }
    private bool IFieldDefinitionIsStatic { get; }
    private bool IFieldDefinitionIsMarshalledExplicitly { get; }
    internal bool IsMarshalledExplicitly { get; }
    private IMarshallingInformation IFieldDefinitionMarshallingInformation { get; }
    private ImmutableArray`1<byte> IFieldDefinitionMarshallingDescriptor { get; }
    internal ImmutableArray`1<byte> MarshallingDescriptor { get; }
    private UInt32 IFieldDefinitionOffset { get; }
    private ITypeDefinition ITypeDefinitionMemberContainingTypeDefinition { get; }
    private TypeMemberVisibility ITypeDefinitionMemberVisibility { get; }
    private IFieldReference ISpecializedFieldReferenceUnspecializedVersion { get; }
    public FieldSymbol OriginalDefinition { get; }
    protected Symbol OriginalSymbolDefinition { get; }
    public TypeSymbol Type { get; }
    internal bool HasDeclaredType { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public Symbol AssociatedSymbol { get; }
    public bool IsReadOnly { get; }
    public bool IsConst { get; }
    internal bool IsMetadataConstant { get; }
    internal bool IsConstButNotMetadataConstant { get; }
    public bool HasConstantValue { get; }
    public object ConstantValue { get; }
    public SymbolKind Kind { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    internal bool HasSpecialName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal bool IsNotSerialized { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal UnmanagedType MarshallingType { get; }
    internal Nullable`1<int> TypeLayoutOffset { get; }
    internal ParameterSymbol MeParameter { get; }
    internal bool IsCapturedFrame { get; }
    protected int HighestPriorityUseSiteError { get; }
    public bool HasUnsupportedMetadata { get; }
    internal EmbeddedSymbolKind EmbeddedSymbolKind { get; }
    private ISymbol IFieldSymbol_AssociatedSymbol { get; }
    private bool IFieldSymbol_IsConst { get; }
    private bool IFieldSymbol_IsVolatile { get; }
    private ITypeSymbol IFieldSymbol_Type { get; }
    private bool IFieldSymbol_HasConstantValue { get; }
    private object IFieldSymbol_ConstantValue { get; }
    private ImmutableArray`1<CustomModifier> IFieldSymbol_CustomModifiers { get; }
    private IFieldSymbol IFieldSymbol_OriginalDefinition { get; }
    private sealed virtual override ITypeReference IFieldReferenceGetType(EmitContext context);
    private sealed virtual override IFieldDefinition IFieldReferenceGetResolvedField(EmitContext context);
    private IFieldDefinition ResolvedFieldImpl(PEModuleBuilder moduleBeingBuilt);
    private sealed virtual override ISpecializedFieldReference get_IFieldReferenceAsSpecializedFieldReference();
    private sealed virtual override ITypeReference ITypeMemberReferenceGetContainingType(EmitContext context);
    internal sealed virtual void IReferenceDispatch(MetadataVisitor visitor);
    internal sealed virtual IDefinition IReferenceAsDefinition(EmitContext context);
    private sealed virtual override string get_INamedEntityName();
    internal virtual override bool get_IFieldReferenceIsContextualNamedEntity();
    private sealed virtual override IMetadataConstant IFieldDefinition_GetCompileTimeValue(EmitContext context);
    internal IMetadataConstant GetMetadataConstantValue(EmitContext context);
    private sealed virtual override ImmutableArray`1<byte> get_IFieldDefinitionFieldMapping();
    private sealed virtual override bool get_IFieldDefinitionIsCompileTimeConstant();
    private sealed virtual override bool get_IFieldDefinitionIsNotSerialized();
    private sealed virtual override bool get_IFieldDefinitionIsReadOnly();
    private sealed virtual override bool get_IFieldDefinitionIsRuntimeSpecial();
    private sealed virtual override bool get_IFieldDefinitionIsSpecialName();
    private sealed virtual override bool get_IFieldDefinitionIsStatic();
    private sealed virtual override bool get_IFieldDefinitionIsMarshalledExplicitly();
    internal virtual bool get_IsMarshalledExplicitly();
    private sealed virtual override IMarshallingInformation get_IFieldDefinitionMarshallingInformation();
    private sealed virtual override ImmutableArray`1<byte> get_IFieldDefinitionMarshallingDescriptor();
    internal virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    private sealed virtual override UInt32 get_IFieldDefinitionOffset();
    private sealed virtual override ITypeDefinition get_ITypeDefinitionMemberContainingTypeDefinition();
    private sealed virtual override TypeMemberVisibility get_ITypeDefinitionMemberVisibility();
    private sealed virtual override IFieldReference get_ISpecializedFieldReferenceUnspecializedVersion();
    public virtual FieldSymbol get_OriginalDefinition();
    protected sealed virtual Symbol get_OriginalSymbolDefinition();
    public abstract virtual TypeSymbol get_Type();
    internal virtual bool get_HasDeclaredType();
    public abstract virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public abstract virtual Symbol get_AssociatedSymbol();
    public abstract virtual override bool get_IsReadOnly();
    public abstract virtual bool get_IsConst();
    internal bool get_IsMetadataConstant();
    internal bool get_IsConstButNotMetadataConstant();
    public virtual bool get_HasConstantValue();
    public virtual object get_ConstantValue();
    internal abstract virtual ConstantValue GetConstantValue(SymbolsInProgress`1<FieldSymbol> inProgress);
    internal virtual TypeSymbol GetInferredType(SymbolsInProgress`1<FieldSymbol> inProgress);
    public sealed virtual SymbolKind get_Kind();
    internal virtual TResult Accept(VisualBasicSymbolVisitor`2<TArgument, TResult> visitor, TArgument arg);
    public sealed virtual bool get_IsMustOverride();
    public sealed virtual bool get_IsNotOverridable();
    public sealed virtual bool get_IsOverridable();
    public sealed virtual bool get_IsOverrides();
    internal abstract virtual bool get_HasSpecialName();
    internal abstract virtual bool get_HasRuntimeSpecialName();
    internal abstract virtual bool get_IsNotSerialized();
    internal abstract virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual UnmanagedType get_MarshallingType();
    internal abstract virtual Nullable`1<int> get_TypeLayoutOffset();
    internal virtual ParameterSymbol get_MeParameter();
    internal virtual bool get_IsCapturedFrame();
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    internal DiagnosticInfo CalculateUseSiteErrorInfo();
    protected virtual int get_HighestPriorityUseSiteError();
    public sealed virtual bool get_HasUnsupportedMetadata();
    internal virtual EmbeddedSymbolKind get_EmbeddedSymbolKind();
    internal FieldSymbol AsMember(NamedTypeSymbol newOwner);
    private sealed virtual override ISymbol get_IFieldSymbol_AssociatedSymbol();
    private sealed virtual override bool get_IFieldSymbol_IsConst();
    private sealed virtual override bool get_IFieldSymbol_IsVolatile();
    private sealed virtual override ITypeSymbol get_IFieldSymbol_Type();
    private sealed virtual override bool get_IFieldSymbol_HasConstantValue();
    private sealed virtual override object get_IFieldSymbol_ConstantValue();
    private sealed virtual override ImmutableArray`1<CustomModifier> get_IFieldSymbol_CustomModifiers();
    private sealed virtual override IFieldSymbol get_IFieldSymbol_OriginalDefinition();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSymbolVisitor visitor);
    public virtual TResult Accept(VisualBasicSymbolVisitor`1<TResult> visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.GeneratedLabelSymbol : LabelSymbol {
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public GeneratedLabelSymbol(string name);
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
}
internal enum Microsoft.CodeAnalysis.VisualBasic.Symbols.GeneratedNameKind : Enum {
    public int value__;
    public static GeneratedNameKind None;
    public static GeneratedNameKind HoistedMeField;
    public static GeneratedNameKind HoistedSynthesizedLocalField;
    public static GeneratedNameKind HoistedUserVariableField;
    public static GeneratedNameKind IteratorCurrentField;
    public static GeneratedNameKind IteratorInitialThreadIdField;
    public static GeneratedNameKind IteratorParameterProxyField;
    public static GeneratedNameKind StateMachineAwaiterField;
    public static GeneratedNameKind StateMachineStateField;
    public static GeneratedNameKind StateMachineHoistedUserVariableField;
    public static GeneratedNameKind StaticLocalField;
    public static GeneratedNameKind TransparentIdentifier;
    public static GeneratedNameKind AnonymousTransparentIdentifier;
    public static GeneratedNameKind AnonymousType;
    public static GeneratedNameKind LambdaCacheField;
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.GeneratedNames : object {
    internal static char DotReplacementInTypeNames;
    private static char s_methodNameSeparator;
    private static char s_idSeparator;
    private static char s_generationSeparator;
    internal static string AnonymousTypeOrDelegateCommonPrefix;
    internal static string AnonymousTypeTemplateNamePrefix;
    internal static string AnonymousDelegateTemplateNamePrefix;
    internal static GeneratedNameKind GetKind(string name);
    public static string MakeStateMachineTypeName(string methodName, int methodOrdinal, int generation);
    public static string MakeStateMachineStateFieldName();
    public static string MakeBaseMethodWrapperName(string methodName, bool isMyBase);
    public static string ReusableHoistedLocalFieldName(int number);
    public static string MakeStaticLambdaDisplayClassName(int methodOrdinal, int generation);
    internal static string MakeLambdaDisplayClassName(int methodOrdinal, int generation, int closureOrdinal, int closureGeneration, bool isDelegateRelaxation);
    internal static string MakeDisplayClassGenericParameterName(int parameterIndex);
    internal static string MakeLambdaMethodName(int methodOrdinal, int generation, int lambdaOrdinal, int lambdaGeneration, SynthesizedLambdaKind lambdaKind);
    public static string MakeCachedFrameInstanceName();
    internal static string MakeLambdaCacheFieldName(int methodOrdinal, int generation, int lambdaOrdinal, int lambdaGeneration, SynthesizedLambdaKind lambdaKind);
    internal static string MakeDelegateRelaxationParameterName(int parameterIndex);
    private static string MakeMethodScopedSynthesizedName(string prefix, int methodOrdinal, int methodGeneration, string methodNameOpt, int entityOrdinal, int entityGeneration, bool isTypeName);
    public static bool TryParseStateMachineTypeName(string stateMachineTypeName, String& methodName);
    public static string MakeStateMachineBuilderFieldName();
    public static string MakeIteratorCurrentFieldName();
    public static string MakeStateMachineAwaiterFieldName(int index);
    public static string MakeStateMachineParameterName(string paramName);
    public static string MakeIteratorParameterProxyName(string paramName);
    public static string MakeIteratorInitialThreadIdName();
    public static bool TryParseHoistedUserVariableName(string proxyName, String& variableName);
    public static bool TryParseStateMachineHoistedUserVariableName(string proxyName, String& variableName, Int32& index);
    public static string MakeStateMachineCapturedMeName();
    public static string MakeStateMachineCapturedClosureMeName(string closureName);
    internal static string MakeAnonymousTypeTemplateName(string prefix, int index, int submissionSlotIndex, string moduleId);
    internal static bool TryParseAnonymousTypeTemplateName(string prefix, string name, Int32& index);
    internal static string MakeSynthesizedLocalName(SynthesizedLocalKind kind, Int32& uniqueId);
    internal static string MakeLambdaDisplayClassStorageName(int uniqueId);
    internal static string MakeSignatureString(Byte[] signature);
    internal static string MakeStaticLocalFieldName(string methodName, string methodSignature, string localName);
    internal static bool TryParseStaticLocalFieldName(string fieldName, String& methodName, String& methodSignature, String& localName);
    internal static bool TryParseSlotIndex(string prefix, string fieldName, Int32& slotIndex);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.GeneratedUnstructuredExceptionHandlingResumeLabel : GeneratedLabelSymbol {
    public StatementSyntax ResumeStatement;
    public GeneratedUnstructuredExceptionHandlingResumeLabel(StatementSyntax resumeStmt);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.GlobalNamespaceDeclaration : SingleNamespaceDeclaration {
    public bool IsGlobalNamespace { get; }
    public GlobalNamespaceDeclaration(bool hasImports, SyntaxReference syntaxReference, Location nameLocation, ImmutableArray`1<SingleNamespaceOrTypeDeclaration> children);
    public virtual bool get_IsGlobalNamespace();
}
internal interface Microsoft.CodeAnalysis.VisualBasic.Symbols.IAttributeTargetSymbol {
    public AttributeLocation DefaultAttributeLocation { get; }
    public abstract virtual AttributeLocation get_DefaultAttributeLocation();
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.ImplementsHelper : object {
    public static ImmutableArray`1<Symbol> GetExplicitInterfaceImplementations(Symbol member);
    public static Location GetImplementingLocation(Symbol sourceSym, Symbol implementedSym);
    public static QualifiedNameSyntax FindImplementingSyntax(ImplementsClauseSyntax implementsClause, TSymbol implementingSym, TSymbol implementedSym, SourceMemberContainerTypeSymbol container, Binder binder);
    public static ImmutableArray`1<TSymbol> ProcessImplementsClause(ImplementsClauseSyntax implementsClause, TSymbol implementingSym, SourceMemberContainerTypeSymbol container, Binder binder, DiagnosticBag diagBag);
    public static TSymbol FindExplicitlyImplementedMember(TSymbol implementingSym, NamedTypeSymbol containingType, QualifiedNameSyntax implementedMemberSyntax, Binder binder, DiagnosticBag diagBag, ArrayBuilder`1<Symbol> candidateSymbols, LookupResultKind& resultKind);
    private static bool MembersAreMatchingForPurposesOfInterfaceImplementation(Symbol implementingSym, Symbol implementedSym);
    private static TSymbol ValidateImplementedMember(TSymbol implementingSym, TSymbol implementedSym, QualifiedNameSyntax implementedMemberSyntax, Binder binder, DiagnosticBag diagBag);
    public static void ValidateImplementedMethodConstraints(SourceMethodSymbol implementingMethod, MethodSymbol implementedMethod, DiagnosticBag diagBag);
    public static TSymbol ComputeImplementationForInterfaceMember(TSymbol interfaceMember, TypeSymbol implementingType, IEqualityComparer`1<TSymbol> comparer);
    private static TSymbol FindImplicitImplementationDeclaredInType(TSymbol interfaceMember, TypeSymbol currType, IEqualityComparer`1<TSymbol> comparer);
    public static ImmutableArray`1<TSymbol> SubstituteExplicitInterfaceImplementations(ImmutableArray`1<TSymbol> unsubstitutedImplementations, TypeSubstitution substitution);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.ImplicitNamedTypeSymbol : SourceMemberContainerTypeSymbol {
    public bool IsImplicitlyDeclared { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    internal bool IsComImport { get; }
    internal bool HasSpecialName { get; }
    internal bool IsWindowsRuntimeImport { get; }
    internal bool ShouldAddWinRTMembers { get; }
    internal bool IsSerializable { get; }
    internal TypeLayout Layout { get; }
    internal bool HasStructLayoutAttribute { get; }
    internal CharSet MarshallingCharSet { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool HasEmbeddedAttribute { get; }
    internal TypeSymbol CoClassType { get; }
    internal bool IsExtensibleInterfaceNoUseSiteDiagnostics { get; }
    internal ImplicitNamedTypeSymbol(MergedTypeDeclaration declaration, NamespaceOrTypeSymbol containingSymbol, SourceModuleSymbol containingModule);
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual AttributeUsageInfo GetAttributeUsageInfo();
    internal virtual NamedTypeSymbol MakeAcyclicBaseType(DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<NamedTypeSymbol> MakeAcyclicInterfaces(DiagnosticBag diagnostics);
    internal virtual NamedTypeSymbol MakeDeclaredBase(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<NamedTypeSymbol> MakeDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal virtual bool get_IsComImport();
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_IsWindowsRuntimeImport();
    internal virtual bool get_ShouldAddWinRTMembers();
    internal virtual bool get_IsSerializable();
    internal virtual TypeLayout get_Layout();
    internal bool get_HasStructLayoutAttribute();
    internal virtual CharSet get_MarshallingCharSet();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual bool get_HasEmbeddedAttribute();
    internal virtual TypeSymbol get_CoClassType();
    internal virtual bool get_IsExtensibleInterfaceNoUseSiteDiagnostics();
    protected virtual Location GetInheritsOrImplementsLocation(NamedTypeSymbol base, bool getInherits);
    protected virtual void AddDeclaredNonTypeMembers(MembersAndInitializersBuilder membersBuilder, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.IndexedTypeParameterSymbol : TypeParameterSymbol {
    private static TypeParameterSymbol[] s_parameterPool;
    private int _index;
    public TypeParameterKind TypeParameterKind { get; }
    public int Ordinal { get; }
    public VarianceKind Variance { get; }
    public bool HasValueTypeConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasConstructorConstraint { get; }
    internal ImmutableArray`1<TypeSymbol> ConstraintTypesNoUseSiteDiagnostics { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    private static IndexedTypeParameterSymbol();
    private IndexedTypeParameterSymbol(int index);
    internal static TypeParameterSymbol GetTypeParameter(int index);
    private static void GrowPool(int count);
    internal static ImmutableArray`1<TypeParameterSymbol> Take(int count);
    public virtual TypeParameterKind get_TypeParameterKind();
    public virtual int get_Ordinal();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual VarianceKind get_Variance();
    public virtual bool get_HasValueTypeConstraint();
    public virtual bool get_HasReferenceTypeConstraint();
    public virtual bool get_HasConstructorConstraint();
    internal virtual ImmutableArray`1<TypeSymbol> get_ConstraintTypesNoUseSiteDiagnostics();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual void EnsureAllConstraintsAreResolved();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.InstanceErrorTypeSymbol : ErrorTypeSymbol {
    protected int _arity;
    private ImmutableArray`1<TypeParameterSymbol> _lazyTypeParameters;
    public int Arity { get; }
    internal bool CanConstruct { get; }
    internal TypeSubstitution TypeSubstitution { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    internal ImmutableArray`1<TypeSymbol> TypeArgumentsNoUseSiteDiagnostics { get; }
    internal ImmutableArray`1<ImmutableArray`1<CustomModifier>> TypeArgumentsCustomModifiers { get; }
    internal bool HasTypeArgumentsCustomModifiers { get; }
    internal InstanceErrorTypeSymbol(int arity);
    public sealed virtual int get_Arity();
    internal virtual bool get_CanConstruct();
    public sealed virtual NamedTypeSymbol Construct(ImmutableArray`1<TypeSymbol> typeArguments);
    internal virtual TypeSubstitution get_TypeSubstitution();
    internal sealed virtual TypeWithModifiers InternalSubstituteTypeParameters(TypeSubstitution substitution);
    private NamedTypeSymbol InternalSubstituteTypeParametersInInstanceErrorTypeSymbol(TypeSubstitution substitution);
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal virtual ImmutableArray`1<TypeSymbol> get_TypeArgumentsNoUseSiteDiagnostics();
    internal sealed virtual ImmutableArray`1<ImmutableArray`1<CustomModifier>> get_TypeArgumentsCustomModifiers();
    internal sealed virtual bool get_HasTypeArgumentsCustomModifiers();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.InstanceTypeSymbol : NamedTypeSymbol {
    internal ImmutableArray`1<TypeSymbol> TypeArgumentsNoUseSiteDiagnostics { get; }
    internal ImmutableArray`1<ImmutableArray`1<CustomModifier>> TypeArgumentsCustomModifiers { get; }
    internal bool HasTypeArgumentsCustomModifiers { get; }
    internal bool CanConstruct { get; }
    internal TypeSubstitution TypeSubstitution { get; }
    public NamedTypeSymbol ConstructedFrom { get; }
    internal sealed virtual ImmutableArray`1<TypeSymbol> get_TypeArgumentsNoUseSiteDiagnostics();
    internal sealed virtual ImmutableArray`1<ImmutableArray`1<CustomModifier>> get_TypeArgumentsCustomModifiers();
    internal sealed virtual bool get_HasTypeArgumentsCustomModifiers();
    internal virtual bool get_CanConstruct();
    public sealed virtual NamedTypeSymbol Construct(ImmutableArray`1<TypeSymbol> typeArguments);
    internal virtual TypeWithModifiers InternalSubstituteTypeParameters(TypeSubstitution substitution);
    private NamedTypeSymbol InternalSubstituteTypeParametersInNamedType(TypeSubstitution substitution);
    internal virtual TypeSubstitution get_TypeSubstitution();
    public virtual NamedTypeSymbol get_ConstructedFrom();
    protected DiagnosticInfo CalculateUseSiteErrorInfo();
    private DiagnosticInfo DeriveUseSiteErrorInfoFromBase();
    internal sealed virtual DiagnosticInfo GetUnificationUseSiteDiagnosticRecursive(Symbol owner, HashSet`1& checkedTypes);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.LabelSymbol : Symbol {
    private string _name;
    public string Name { get; }
    public bool IsNotOverridable { get; }
    public bool IsMustOverride { get; }
    public bool IsOverrides { get; }
    public bool IsOverridable { get; }
    public bool IsShared { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public MethodSymbol ContainingMethod { get; }
    public Symbol ContainingSymbol { get; }
    public SymbolKind Kind { get; }
    internal SyntaxToken LabelName { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal IMethodSymbol ILabelSymbol_ContainingMethod { get; }
    public LabelSymbol(string name);
    public virtual string get_Name();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsShared();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<Location> get_Locations();
    internal virtual TResult Accept(VisualBasicSymbolVisitor`2<TArgument, TResult> visitor, TArgument arg);
    public virtual MethodSymbol get_ContainingMethod();
    public virtual Symbol get_ContainingSymbol();
    public virtual SymbolKind get_Kind();
    internal virtual SyntaxToken get_LabelName();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal sealed virtual override IMethodSymbol get_ILabelSymbol_ContainingMethod();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSymbolVisitor visitor);
    public virtual TResult Accept(VisualBasicSymbolVisitor`1<TResult> visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.LambdaParameterSymbol : ParameterSymbol {
    private ImmutableArray`1<Location> _location;
    private string _name;
    private TypeSymbol _type;
    private ushort _ordinal;
    private bool _isByRef;
    public string Name { get; }
    public int Ordinal { get; }
    public bool HasExplicitDefaultValue { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    public bool IsOptional { get; }
    internal bool IsMetadataOut { get; }
    internal bool IsMetadataIn { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal bool HasOptionCompare { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerMemberName { get; }
    internal bool IsCallerFilePath { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    public bool IsParamArray { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public TypeSymbol Type { get; }
    public bool IsByRef { get; }
    internal bool IsExplicitByRef { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    protected LambdaParameterSymbol(string name, int ordinal, TypeSymbol type, bool isByRef, Location location);
    public sealed virtual string get_Name();
    public sealed virtual int get_Ordinal();
    public sealed virtual bool get_HasExplicitDefaultValue();
    internal virtual ConstantValue get_ExplicitDefaultConstantValue(SymbolsInProgress`1<ParameterSymbol> inProgress);
    public sealed virtual bool get_IsOptional();
    internal sealed virtual bool get_IsMetadataOut();
    internal sealed virtual bool get_IsMetadataIn();
    internal sealed virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual bool get_HasOptionCompare();
    internal virtual bool get_IsIDispatchConstant();
    internal virtual bool get_IsIUnknownConstant();
    internal virtual bool get_IsCallerLineNumber();
    internal virtual bool get_IsCallerMemberName();
    internal virtual bool get_IsCallerFilePath();
    internal sealed virtual ushort get_CountOfCustomModifiersPrecedingByRef();
    public sealed virtual bool get_IsParamArray();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public sealed virtual TypeSymbol get_Type();
    public sealed virtual bool get_IsByRef();
    internal sealed virtual bool get_IsExplicitByRef();
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.LambdaSymbol : MethodSymbol {
    internal static TypeSymbol ReturnTypeIsBeingInferred;
    internal static TypeSymbol ReturnTypeIsUnknown;
    internal static TypeSymbol ReturnTypePendingDelegate;
    internal static TypeSymbol ReturnTypeVoidReplacement;
    internal static TypeSymbol ErrorRecoveryInferenceError;
    private VisualBasicSyntaxNode _syntaxNode;
    private ImmutableArray`1<ParameterSymbol> _parameters;
    protected TypeSymbol m_ReturnType;
    private Binder _binder;
    public SynthesizedLambdaKind SynthesizedKind { get; }
    internal bool IsQueryLambdaMethod { get; }
    public int Arity { get; }
    internal bool HasSpecialName { get; }
    public Symbol AssociatedSymbol { get; }
    internal CallingConvention CallingConvention { get; }
    public Symbol ContainingSymbol { get; }
    internal Binder ContainingBinder { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public bool IsExtensionMethod { get; }
    public bool IsExternalMethod { get; }
    internal MarshalPseudoCustomAttributeData ReturnTypeMarshallingInformation { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool HasDeclarativeSecurity { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverloads { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public bool IsSub { get; }
    public bool IsVararg { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal bool IsLambdaMethod { get; }
    public MethodKind MethodKind { get; }
    internal bool IsMethodKindBasedOnSyntax { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool GenerateDebugInfoImpl { get; }
    private static LambdaSymbol();
    protected LambdaSymbol(VisualBasicSyntaxNode syntaxNode, ImmutableArray`1<BoundLambdaParameterSymbol> parameters, TypeSymbol returnType, Binder binder);
    public abstract virtual SynthesizedLambdaKind get_SynthesizedKind();
    internal sealed virtual bool get_IsQueryLambdaMethod();
    public virtual int get_Arity();
    internal virtual bool get_HasSpecialName();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    public virtual Symbol get_AssociatedSymbol();
    internal virtual CallingConvention get_CallingConvention();
    public virtual Symbol get_ContainingSymbol();
    internal Binder get_ContainingBinder();
    internal virtual bool TryGetMeParameter(ParameterSymbol& meParameter);
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual bool get_IsExtensionMethod();
    public virtual bool get_IsExternalMethod();
    public virtual DllImportData GetDllImportData();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnTypeMarshallingInformation();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    internal sealed virtual bool get_HasDeclarativeSecurity();
    internal sealed virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsShared();
    public virtual bool get_IsSub();
    public virtual bool get_IsVararg();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual bool get_IsLambdaMethod();
    public virtual MethodKind get_MethodKind();
    internal sealed virtual bool get_IsMethodKindBasedOnSyntax();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    internal virtual VisualBasicSyntaxNode get_Syntax();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_GenerateDebugInfoImpl();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.LexicalSortKey : ValueType {
    private SyntaxTreeKind _embeddedKind;
    private int _treeOrdinal;
    private int _position;
    public static LexicalSortKey NotInSource;
    public static LexicalSortKey NotInitialized;
    private SyntaxTreeKind EmbeddedKind { get; }
    public int TreeOrdinal { get; }
    public int Position { get; }
    public bool IsInitialized { get; }
    private static LexicalSortKey();
    private LexicalSortKey(SyntaxTreeKind embeddedKind, int treeOrdinal, int location);
    private LexicalSortKey(SyntaxTreeKind embeddedKind, SyntaxTree tree, int location, VisualBasicCompilation compilation);
    public LexicalSortKey(SyntaxTree tree, int position, VisualBasicCompilation compilation);
    public LexicalSortKey(SyntaxReference syntaxRef, VisualBasicCompilation compilation);
    public LexicalSortKey(Location location, VisualBasicCompilation compilation);
    public LexicalSortKey(VisualBasicSyntaxNode node, VisualBasicCompilation compilation);
    public LexicalSortKey(SyntaxToken token, VisualBasicCompilation compilation);
    private SyntaxTreeKind get_EmbeddedKind();
    public int get_TreeOrdinal();
    public int get_Position();
    private static SyntaxTreeKind GetEmbeddedKind(SyntaxTree tree);
    public static int Compare(LexicalSortKey& xSortKey, LexicalSortKey& ySortKey);
    public static int Compare(Location first, Location second, VisualBasicCompilation compilation);
    public static LexicalSortKey First(LexicalSortKey xSortKey, LexicalSortKey ySortKey);
    public bool get_IsInitialized();
    public void SetFrom(LexicalSortKey& other);
}
internal enum Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalDeclarationKind : Enum {
    public byte value__;
    public static LocalDeclarationKind None;
    public static LocalDeclarationKind Variable;
    public static LocalDeclarationKind ImplicitVariable;
    public static LocalDeclarationKind Constant;
    public static LocalDeclarationKind Static;
    public static LocalDeclarationKind Using;
    public static LocalDeclarationKind Catch;
    public static LocalDeclarationKind For;
    public static LocalDeclarationKind ForEach;
    public static LocalDeclarationKind FunctionValue;
    public static LocalDeclarationKind AmbiguousLocals;
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.LocalSymbol : Symbol {
    internal static ErrorTypeSymbol UseBeforeDeclarationResultType;
    private Symbol _container;
    private TypeSymbol _lazyType;
    internal bool IsImportedFromMetadata { get; }
    internal LocalDeclarationKind DeclarationKind { get; }
    internal SynthesizedLocalKind SynthesizedKind { get; }
    public TypeSymbol Type { get; }
    internal bool ConstHasType { get; }
    internal bool IsReadOnly { get; }
    public string Name { get; }
    internal SyntaxToken IdentifierToken { get; }
    public SymbolKind Kind { get; }
    public ImmutableArray`1<Location> Locations { get; }
    internal Location IdentifierLocation { get; }
    public Symbol ContainingSymbol { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsShared { get; }
    public bool IsOverridable { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsUsing { get; }
    public bool IsCatch { get; }
    public bool IsConst { get; }
    internal bool CanScheduleToStack { get; }
    public bool IsStatic { get; }
    public bool IsFor { get; }
    public bool IsForEach { get; }
    public bool IsFunctionValue { get; }
    internal bool IsCompilerGenerated { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool IsByRef { get; }
    internal bool IsPinned { get; }
    public bool HasConstantValue { get; }
    public object ConstantValue { get; }
    internal bool HasInferredType { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    private ITypeSymbol ILocalSymbol_Type { get; }
    private bool ILocalSymbol_IsConst { get; }
    protected bool ISymbol_IsStatic { get; }
    private bool ILocalSymbolInternal_IsImportedFromMetadata { get; }
    private SynthesizedLocalKind ILocalSymbolInternal_SynthesizedKind { get; }
    private static LocalSymbol();
    internal LocalSymbol(Symbol container, TypeSymbol type);
    internal static LocalSymbol Create(Symbol container, Binder binder, SyntaxToken declaringIdentifier, ModifiedIdentifierSyntax modifiedIdentifierOpt, AsClauseSyntax asClauseOpt, EqualsValueSyntax initializerOpt, LocalDeclarationKind declarationKind);
    internal static LocalSymbol Create(Symbol container, Binder binder, SyntaxToken declaringIdentifier, LocalDeclarationKind declarationKind, TypeSymbol type);
    internal static LocalSymbol Create(Symbol container, Binder binder, SyntaxToken declaringIdentifier, LocalDeclarationKind declarationKind, TypeSymbol type, string name);
    internal static LocalSymbol Create(LocalSymbol originalVariable, TypeSymbol type);
    internal static LocalSymbol CreateInferredForFromTo(Symbol container, Binder binder, SyntaxToken declaringIdentifier, ExpressionSyntax fromValue, ExpressionSyntax toValue, ForStepClauseSyntax stepClauseOpt);
    internal static LocalSymbol CreateInferredForEach(Symbol container, Binder binder, SyntaxToken declaringIdentifier, ExpressionSyntax expression);
    internal virtual bool get_IsImportedFromMetadata();
    internal abstract virtual LocalDeclarationKind get_DeclarationKind();
    internal abstract virtual SynthesizedLocalKind get_SynthesizedKind();
    public virtual TypeSymbol get_Type();
    internal bool get_ConstHasType();
    internal virtual bool get_IsReadOnly();
    public void SetType(TypeSymbol type);
    internal virtual TypeSymbol ComputeType(Binder containingBinder);
    public abstract virtual string get_Name();
    internal abstract virtual SyntaxToken get_IdentifierToken();
    internal abstract virtual SyntaxNode GetDeclaratorSyntax();
    public sealed virtual SymbolKind get_Kind();
    public virtual ImmutableArray`1<Location> get_Locations();
    internal abstract virtual Location get_IdentifierLocation();
    public virtual Symbol get_ContainingSymbol();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsShared();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverrides();
    public bool get_IsUsing();
    public bool get_IsCatch();
    public bool get_IsConst();
    internal virtual bool get_CanScheduleToStack();
    public bool get_IsStatic();
    public bool get_IsFor();
    public bool get_IsForEach();
    public abstract virtual override bool get_IsFunctionValue();
    internal bool get_IsCompilerGenerated();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual TResult Accept(VisualBasicSymbolVisitor`2<TArgument, TResult> visitor, TArgument arg);
    internal virtual bool get_IsByRef();
    internal virtual bool get_IsPinned();
    public sealed virtual override bool get_HasConstantValue();
    public sealed virtual override object get_ConstantValue();
    internal virtual DiagnosticBag GetConstantValueDiagnostics(Binder binder);
    internal virtual BoundExpression GetConstantExpression(Binder binder);
    internal virtual ConstantValue GetConstantValue(Binder binder);
    internal virtual bool get_HasInferredType();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    private sealed virtual override ITypeSymbol get_ILocalSymbol_Type();
    private sealed virtual override bool get_ILocalSymbol_IsConst();
    protected virtual bool get_ISymbol_IsStatic();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSymbolVisitor visitor);
    public virtual TResult Accept(VisualBasicSymbolVisitor`1<TResult> visitor);
    private sealed virtual override bool get_ILocalSymbolInternal_IsImportedFromMetadata();
    private sealed virtual override SynthesizedLocalKind get_ILocalSymbolInternal_SynthesizedKind();
    private sealed virtual override SyntaxNode ILocalSymbolInternal_GetDeclaratorSyntax();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.MemberSignatureComparer : object {
    public static MemberSignatureComparer WinRTComparer;
    private MethodSignatureComparer _methodComparer;
    private PropertySignatureComparer _propertyComparer;
    private EventSignatureComparer _eventComparer;
    private static MemberSignatureComparer();
    private MemberSignatureComparer(MethodSignatureComparer methodComparer, PropertySignatureComparer propertyComparer, EventSignatureComparer eventComparer);
    public sealed virtual override bool Equals(Symbol sym1, Symbol sym2);
    public sealed virtual override int GetHashCode(Symbol sym);
    [ConditionalAttribute("DEBUG")]
private void CheckSymbolKind(Symbol sym);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.MeParameterSymbol : ParameterSymbol {
    private Symbol _container;
    private TypeSymbol _type;
    public string Name { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Symbol ContainingSymbol { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    public bool HasExplicitDefaultValue { get; }
    public bool IsOptional { get; }
    public bool IsParamArray { get; }
    public int Ordinal { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public bool IsByRef { get; }
    internal bool IsExplicitByRef { get; }
    internal bool IsMetadataOut { get; }
    internal bool IsMetadataIn { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal bool HasOptionCompare { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerMemberName { get; }
    internal bool IsCallerFilePath { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    public bool IsMe { get; }
    public bool IsImplicitlyDeclared { get; }
    internal MeParameterSymbol(Symbol memberSymbol);
    internal MeParameterSymbol(Symbol memberSymbol, TypeSymbol type);
    public virtual string get_Name();
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual Symbol get_ContainingSymbol();
    internal virtual ConstantValue get_ExplicitDefaultConstantValue(SymbolsInProgress`1<ParameterSymbol> inProgress);
    public virtual bool get_HasExplicitDefaultValue();
    public virtual bool get_IsOptional();
    public virtual bool get_IsParamArray();
    public virtual int get_Ordinal();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual bool get_IsByRef();
    internal virtual bool get_IsExplicitByRef();
    internal virtual bool get_IsMetadataOut();
    internal virtual bool get_IsMetadataIn();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual bool get_HasOptionCompare();
    internal virtual bool get_IsIDispatchConstant();
    internal virtual bool get_IsIUnknownConstant();
    internal virtual bool get_IsCallerLineNumber();
    internal virtual bool get_IsCallerMemberName();
    internal virtual bool get_IsCallerFilePath();
    internal virtual ushort get_CountOfCustomModifiersPrecedingByRef();
    public virtual bool get_IsMe();
    public virtual bool get_IsImplicitlyDeclared();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedNamespaceDeclaration : MergedNamespaceOrTypeDeclaration {
    private ImmutableArray`1<SingleNamespaceDeclaration> _declarations;
    private bool _multipleSpellings;
    private ImmutableArray`1<MergedNamespaceOrTypeDeclaration> _children;
    public DeclarationKind Kind { get; }
    public ImmutableArray`1<SingleNamespaceDeclaration> Declarations { get; }
    public ImmutableArray`1<Location> NameLocations { get; }
    public ImmutableArray`1<SyntaxReference> SyntaxReferences { get; }
    public ImmutableArray`1<MergedNamespaceOrTypeDeclaration> Children { get; }
    public bool HasMultipleSpellings { get; }
    private MergedNamespaceDeclaration(ImmutableArray`1<SingleNamespaceDeclaration> declarations);
    public static MergedNamespaceDeclaration Create(IEnumerable`1<SingleNamespaceDeclaration> declarations);
    public static MergedNamespaceDeclaration Create(SingleNamespaceDeclaration[] declarations);
    public virtual DeclarationKind get_Kind();
    public ImmutableArray`1<SingleNamespaceDeclaration> get_Declarations();
    public LexicalSortKey GetLexicalSortKey(VisualBasicCompilation compilation);
    public ImmutableArray`1<Location> get_NameLocations();
    public ImmutableArray`1<SyntaxReference> get_SyntaxReferences();
    protected virtual ImmutableArray`1<Declaration> GetDeclarationChildren();
    private ImmutableArray`1<MergedNamespaceOrTypeDeclaration> MakeChildren();
    public ImmutableArray`1<MergedNamespaceOrTypeDeclaration> get_Children();
    public bool get_HasMultipleSpellings();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedNamespaceOrTypeDeclaration : Declaration {
    protected MergedNamespaceOrTypeDeclaration(string name);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedNamespaceSymbol : PEOrSourceOrMergedNamespaceSymbol {
    protected ImmutableArray`1<NamespaceSymbol> _namespacesToMerge;
    protected MergedNamespaceSymbol _containingNamespace;
    private CachingDictionary`2<string, Symbol> _cachedLookup;
    private ImmutableArray`1<NamedTypeSymbol> _lazyModuleMembers;
    private ImmutableArray`1<Symbol> _lazyMembers;
    private int _lazyEmbeddedKind;
    public ImmutableArray`1<NamespaceSymbol> ConstituentNamespaces { get; }
    public string Name { get; }
    internal EmbeddedSymbolKind EmbeddedSymbolKind { get; }
    public Symbol ContainingSymbol { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal ThreeState RawContainsAccessibleTypes { get; }
    private MergedNamespaceSymbol(MergedNamespaceSymbol containingNamespace, ImmutableArray`1<NamespaceSymbol> namespacesToMerge);
    public static NamespaceSymbol CreateGlobalNamespace(AssemblySymbol extent);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedNamespaceSymbol/VB$StateMachine_7_ConstituentGlobalNamespaces")]
private static IEnumerable`1<NamespaceSymbol> ConstituentGlobalNamespaces(AssemblySymbol extent);
    private static NamespaceSymbol Create(AssemblySymbol extent, AssemblyMergedNamespaceSymbol containingNamespace, ImmutableArray`1<NamespaceSymbol> namespacesToMerge);
    internal static NamespaceSymbol CreateForTestPurposes(AssemblySymbol extent, IEnumerable`1<NamespaceSymbol> namespacesToMerge);
    public static NamespaceSymbol CreateGlobalNamespace(VisualBasicCompilation extent);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedNamespaceSymbol/VB$StateMachine_11_ConstituentGlobalNamespaces")]
private static IEnumerable`1<NamespaceSymbol> ConstituentGlobalNamespaces(VisualBasicCompilation extent);
    private static NamespaceSymbol Create(VisualBasicCompilation extent, CompilationMergedNamespaceSymbol containingNamespace, IEnumerable`1<NamespaceSymbol> namespacesToMerge);
    public static NamespaceSymbol CreateNamespaceGroup(IEnumerable`1<NamespaceSymbol> namespacesToMerge);
    public virtual NamespaceSymbol Shrink(IEnumerable`1<NamespaceSymbol> namespacesToMerge);
    private static NamespaceSymbol Create(NamespaceGroupSymbol containingNamespace, IEnumerable`1<NamespaceSymbol> namespacesToMerge);
    internal NamespaceSymbol GetConstituentForCompilation(VisualBasicCompilation compilation);
    public virtual ImmutableArray`1<NamespaceSymbol> get_ConstituentNamespaces();
    private ImmutableArray`1<Symbol> SlowGetChildrenOfName(string name);
    protected abstract virtual NamespaceSymbol CreateChildMergedNamespaceSymbol(ImmutableArray`1<NamespaceSymbol> nsSymbols);
    private HashSet`1<string> SlowGetChildNames(IEqualityComparer`1<string> comparer);
    public virtual string get_Name();
    internal virtual EmbeddedSymbolKind get_EmbeddedSymbolKind();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetModuleMembers();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembersUnordered();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual Symbol get_ContainingSymbol();
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    protected sealed virtual Accessibility GetDeclaredAccessibilityOfMostAccessibleDescendantType();
    internal virtual bool IsDeclaredInSourceModule(ModuleSymbol module);
    internal abstract virtual ThreeState get_RawContainsAccessibleTypes();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.MergedTypeDeclaration : MergedNamespaceOrTypeDeclaration {
    private ImmutableArray`1<SingleTypeDeclaration> _declarations;
    private MergedTypeDeclaration[] _children;
    private ICollection`1<string> _memberNames;
    private static Func`2<SingleTypeDeclaration, SingleTypeDeclaration> s_identityFunc;
    private static Func`2<IEnumerable`1<SingleTypeDeclaration>, MergedTypeDeclaration> s_mergeFunc;
    public ImmutableArray`1<SingleTypeDeclaration> Declarations { get; private set; }
    public ImmutableArray`1<SyntaxReference> SyntaxReferences { get; }
    public DeclarationKind Kind { get; }
    public int Arity { get; }
    public ImmutableArray`1<Location> NameLocations { get; }
    public ImmutableArray`1<MergedTypeDeclaration> Children { get; }
    public ICollection`1<string> MemberNames { get; }
    public bool AnyMemberHasAttributes { get; }
    private static MergedTypeDeclaration();
    internal MergedTypeDeclaration(ImmutableArray`1<SingleTypeDeclaration> declarations);
    public ImmutableArray`1<SingleTypeDeclaration> get_Declarations();
    private void set_Declarations(ImmutableArray`1<SingleTypeDeclaration> value);
    public ImmutableArray`1<SyntaxReference> get_SyntaxReferences();
    public virtual DeclarationKind get_Kind();
    public int get_Arity();
    public ImmutableArray`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    public LexicalSortKey GetLexicalSortKey(VisualBasicCompilation compilation);
    public ImmutableArray`1<Location> get_NameLocations();
    private MergedTypeDeclaration[] MakeChildren();
    internal static IEnumerable`1<MergedTypeDeclaration> MakeMergedTypes(IEnumerable`1<SingleTypeDeclaration> types);
    public ImmutableArray`1<MergedTypeDeclaration> get_Children();
    protected virtual ImmutableArray`1<Declaration> GetDeclarationChildren();
    public ICollection`1<string> get_MemberNames();
    public bool get_AnyMemberHasAttributes();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.MemberRefMetadataDecoder : MetadataDecoder {
    private TypeSymbol _containingType;
    public MemberRefMetadataDecoder(PEModuleSymbol moduleSymbol, TypeSymbol containingType);
    protected virtual TypeSymbol GetGenericMethodTypeParamSymbol(int position);
    protected virtual TypeSymbol GetGenericTypeParamSymbol(int position);
    private static void GetGenericTypeArgumentSymbol(int position, NamedTypeSymbol namedType, Int32& cumulativeArity, TypeSymbol& typeArgument);
    internal Symbol FindMember(TypeSymbol targetTypeSymbol, MemberReferenceHandle memberRef, bool methodsOnly);
    private static FieldSymbol FindFieldBySignature(TypeSymbol targetTypeSymbol, string targetMemberName, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers, TypeSymbol type);
    private static MethodSymbol FindMethodBySignature(TypeSymbol targetTypeSymbol, string targetMemberName, SignatureHeader targetMemberSignatureHeader, int targetMemberTypeParamCount, ParamInfo`1[] targetParamInfo);
    private static bool MethodSymbolMatchesParamInfo(MethodSymbol candidateMethod, ParamInfo`1[] targetParamInfo);
    private static bool ParametersMatch(ParameterSymbol candidateParam, ParamInfo`1& targetParam);
    private static bool ReturnTypesMatch(MethodSymbol candidateMethod, ParamInfo`1& targetReturnParam);
    private static bool CustomModifiersMatch(ImmutableArray`1<CustomModifier> candidateReturnTypeCustomModifiers, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> targetReturnTypeCustomModifiers);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.MetadataDecoder : MetadataDecoder`5<PEModuleSymbol, TypeSymbol, MethodSymbol, FieldSymbol, Symbol> {
    private PENamedTypeSymbol _typeContextOpt;
    private PEMethodSymbol _methodContextOpt;
    internal PEModuleSymbol ModuleSymbol { get; }
    public MetadataDecoder(PEModuleSymbol moduleSymbol, PENamedTypeSymbol context);
    public MetadataDecoder(PEModuleSymbol moduleSymbol, PEMethodSymbol context);
    public MetadataDecoder(PEModuleSymbol moduleSymbol);
    private MetadataDecoder(PEModuleSymbol moduleSymbol, PENamedTypeSymbol typeContextOpt, PEMethodSymbol methodContextOpt);
    internal PEModuleSymbol get_ModuleSymbol();
    protected virtual TypeSymbol GetGenericMethodTypeParamSymbol(int position);
    protected virtual TypeSymbol GetGenericTypeParamSymbol(int position);
    protected virtual ConcurrentDictionary`2<TypeDefinitionHandle, TypeSymbol> GetTypeHandleToTypeMap();
    protected virtual ConcurrentDictionary`2<TypeReferenceHandle, TypeSymbol> GetTypeRefHandleToTypeMap();
    protected virtual TypeSymbol LookupNestedTypeDefSymbol(TypeSymbol container, MetadataTypeName& emittedName);
    protected virtual TypeSymbol LookupTopLevelTypeDefSymbol(int referencedAssemblyIndex, MetadataTypeName& emittedName);
    protected virtual TypeSymbol LookupTopLevelTypeDefSymbol(string moduleName, MetadataTypeName& emittedName, Boolean& isNoPiaLocalType);
    protected virtual TypeSymbol LookupTopLevelTypeDefSymbol(MetadataTypeName& emittedName, Boolean& isNoPiaLocalType);
    protected virtual int GetIndexOfReferencedAssembly(AssemblyIdentity identity);
    public static bool IsOrClosedOverATypeFromAssemblies(TypeSymbol this, ImmutableArray`1<AssemblySymbol> assemblies);
    protected virtual TypeSymbol SubstituteNoPiaLocalType(TypeDefinitionHandle typeDef, MetadataTypeName& name, string interfaceGuid, string scope, string identifier);
    internal static NamedTypeSymbol SubstituteNoPiaLocalType(MetadataTypeName& fullEmittedName, bool isInterface, TypeSymbol baseType, string interfaceGuid, string scope, string identifier, AssemblySymbol referringAssembly);
    protected virtual MethodSymbol FindMethodSymbolInType(TypeSymbol typeSymbol, MethodDefinitionHandle targetMethodDef);
    protected virtual FieldSymbol FindFieldSymbolInType(TypeSymbol typeSymbol, FieldDefinitionHandle fieldDef);
    internal virtual Symbol GetSymbolForMemberRef(MemberReferenceHandle memberRef, TypeSymbol scope, bool methodsOnly);
    protected virtual void EnqueueTypeSymbolInterfacesAndBaseTypes(Queue`1<TypeDefinitionHandle> typeDefsToSearch, Queue`1<TypeSymbol> typeSymbolsToSearch, TypeSymbol typeSymbol);
    protected virtual void EnqueueTypeSymbol(Queue`1<TypeDefinitionHandle> typeDefsToSearch, Queue`1<TypeSymbol> typeSymbolsToSearch, TypeSymbol typeSymbol);
    protected virtual MethodDefinitionHandle GetMethodHandle(MethodSymbol method);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEAssemblySymbol : MetadataOrSourceAssemblySymbol {
    private PEAssembly _assembly;
    private DocumentationProvider _documentationProvider;
    private ImmutableArray`1<ModuleSymbol> _modules;
    private ImmutableArray`1<AssemblySymbol> _noPiaResolutionAssemblies;
    private ImmutableArray`1<AssemblySymbol> _linkedReferencedAssemblies;
    private bool _isLinked;
    private byte _lazyMightContainExtensionMethods;
    private ImmutableArray`1<VisualBasicAttributeData> _lazyCustomAttributes;
    internal PEAssembly Assembly { get; }
    public AssemblyIdentity Identity { get; }
    public Version AssemblyVersionPattern { get; }
    internal ImmutableArray`1<byte> PublicKey { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<ModuleSymbol> Modules { get; }
    internal PEModuleSymbol PrimaryModule { get; }
    internal bool IsLinked { get; }
    internal DocumentationProvider DocumentationProvider { get; }
    public bool MightContainExtensionMethods { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    internal PEAssemblySymbol(PEAssembly assembly, DocumentationProvider documentationProvider, bool isLinked, MetadataImportOptions importOptions);
    internal PEAssembly get_Assembly();
    public virtual AssemblyIdentity get_Identity();
    public virtual Version get_AssemblyVersionPattern();
    internal virtual ImmutableArray`1<byte> get_PublicKey();
    internal virtual bool GetGuidString(String& guidString);
    internal virtual bool AreInternalsVisibleToThisAssembly(AssemblySymbol potentialGiverOfAccess);
    internal virtual IEnumerable`1<ImmutableArray`1<byte>> GetInternalsVisibleToPublicKeys(string simpleName);
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<ModuleSymbol> get_Modules();
    internal PEModuleSymbol get_PrimaryModule();
    internal AssemblySymbol LookupAssemblyForForwardedMetadataType(MetadataTypeName& emittedName, bool ignoreCase, String& matchedName);
    internal virtual NamedTypeSymbol TryLookupForwardedMetadataTypeWithCycleDetection(MetadataTypeName& emittedName, ConsList`1<AssemblySymbol> visitedAssemblies, bool ignoreCase);
    internal virtual ImmutableArray`1<AssemblySymbol> GetNoPiaResolutionAssemblies();
    internal virtual void SetNoPiaResolutionAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal virtual void SetLinkedReferencedAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal virtual ImmutableArray`1<AssemblySymbol> GetLinkedReferencedAssemblies();
    internal virtual bool get_IsLinked();
    internal DocumentationProvider get_DocumentationProvider();
    public virtual bool get_MightContainExtensionMethods();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
    public virtual AssemblyMetadata GetMetadata();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEAttributeData : VisualBasicAttributeData {
    private MetadataDecoder _decoder;
    private CustomAttributeHandle _handle;
    private NamedTypeSymbol _attributeClass;
    private MethodSymbol _attributeConstructor;
    private TypedConstant[] _lazyConstructorArguments;
    private KeyValuePair`2[] _lazyNamedArguments;
    private ThreeState _lazyHasErrors;
    public NamedTypeSymbol AttributeClass { get; }
    public MethodSymbol AttributeConstructor { get; }
    public SyntaxReference ApplicationSyntaxReference { get; }
    protected ImmutableArray`1<TypedConstant> CommonConstructorArguments { get; }
    protected ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> CommonNamedArguments { get; }
    internal bool HasErrors { get; }
    internal PEAttributeData(PEModuleSymbol moduleSymbol, CustomAttributeHandle handle);
    public virtual NamedTypeSymbol get_AttributeClass();
    public virtual MethodSymbol get_AttributeConstructor();
    public virtual SyntaxReference get_ApplicationSyntaxReference();
    protected virtual ImmutableArray`1<TypedConstant> get_CommonConstructorArguments();
    protected virtual ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> get_CommonNamedArguments();
    internal virtual bool IsTargetAttribute(string namespaceName, string typeName, bool ignoreCase);
    internal virtual int GetTargetAttributeSignatureIndex(Symbol targetSymbol, AttributeDescription description);
    private void EnsureLazyMembersAreLoaded();
    private void EnsureClassAndConstructorSymbols();
    internal virtual bool get_HasErrors();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEEventSymbol : EventSymbol {
    private string _name;
    private EventAttributes _flags;
    private PENamedTypeSymbol _containingType;
    private EventDefinitionHandle _handle;
    private TypeSymbol _eventType;
    private PEMethodSymbol _addMethod;
    private PEMethodSymbol _removeMethod;
    private PEMethodSymbol _raiseMethod;
    private ImmutableArray`1<VisualBasicAttributeData> _lazyCustomAttributes;
    private Tuple`2<CultureInfo, string> _lazyDocComment;
    private DiagnosticInfo _lazyUseSiteErrorInfo;
    private ObsoleteAttributeData _lazyObsoleteAttributeData;
    private static int s_unsetAccessibility;
    private int _lazyDeclaredAccessibility;
    public bool IsWindowsRuntimeEvent { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public string Name { get; }
    internal EventAttributes EventFlags { get; }
    internal bool HasSpecialName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal EventDefinitionHandle Handle { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public TypeSymbol Type { get; }
    public MethodSymbol AddMethod { get; }
    public MethodSymbol RemoveMethod { get; }
    public MethodSymbol RaiseMethod { get; }
    internal FieldSymbol AssociatedField { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public ImmutableArray`1<EventSymbol> ExplicitInterfaceImplementations { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    internal PEEventSymbol(PEModuleSymbol moduleSymbol, PENamedTypeSymbol containingType, EventDefinitionHandle handle, PEMethodSymbol addMethod, PEMethodSymbol removeMethod, PEMethodSymbol raiseMethod);
    public virtual bool get_IsWindowsRuntimeEvent();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual string get_Name();
    internal EventAttributes get_EventFlags();
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_HasRuntimeSpecialName();
    internal EventDefinitionHandle get_Handle();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsShared();
    public virtual TypeSymbol get_Type();
    public virtual MethodSymbol get_AddMethod();
    public virtual MethodSymbol get_RemoveMethod();
    public virtual MethodSymbol get_RaiseMethod();
    internal virtual FieldSymbol get_AssociatedField();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    internal virtual IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public virtual ImmutableArray`1<EventSymbol> get_ExplicitInterfaceImplementations();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEFieldSymbol : FieldSymbol {
    private FieldDefinitionHandle _handle;
    private string _name;
    private FieldAttributes _flags;
    private PENamedTypeSymbol _containingType;
    private TypeSymbol _lazyType;
    private ImmutableArray`1<CustomModifier> _lazyCustomModifiers;
    private ConstantValue _lazyConstantValue;
    private Tuple`2<CultureInfo, string> _lazyDocComment;
    private ImmutableArray`1<VisualBasicAttributeData> _lazyCustomAttributes;
    private DiagnosticInfo _lazyUseSiteErrorInfo;
    private ObsoleteAttributeData _lazyObsoleteAttributeData;
    public string Name { get; }
    internal FieldAttributes FieldFlags { get; }
    public Symbol AssociatedSymbol { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public Accessibility DeclaredAccessibility { get; }
    internal bool HasSpecialName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal bool IsNotSerialized { get; }
    public bool IsReadOnly { get; }
    public bool IsConst { get; }
    public bool IsShared { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool IsMarshalledExplicitly { get; }
    internal UnmanagedType MarshallingType { get; }
    internal ImmutableArray`1<byte> MarshallingDescriptor { get; }
    internal Nullable`1<int> TypeLayoutOffset { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    internal FieldDefinitionHandle Handle { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    private PEModule PEModule { get; }
    internal PEFieldSymbol(PEModuleSymbol moduleSymbol, PENamedTypeSymbol containingType, FieldDefinitionHandle handle);
    public virtual string get_Name();
    internal FieldAttributes get_FieldFlags();
    public virtual Symbol get_AssociatedSymbol();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    private AttributeDescription GetConstantAttributeDescription();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEFieldSymbol/VB$StateMachine_26_GetCustomAttributesToEmit")]
internal virtual IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_HasRuntimeSpecialName();
    internal virtual bool get_IsNotSerialized();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsConst();
    internal virtual ConstantValue GetConstantValue(SymbolsInProgress`1<FieldSymbol> inProgress);
    public virtual bool get_IsShared();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual bool get_IsMarshalledExplicitly();
    internal virtual UnmanagedType get_MarshallingType();
    internal virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    internal virtual Nullable`1<int> get_TypeLayoutOffset();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    private void EnsureSignatureIsLoaded();
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    internal FieldDefinitionHandle get_Handle();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
    private PEModule get_PEModule();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEGlobalNamespaceSymbol : PENamespaceSymbol {
    private PEModuleSymbol _moduleSymbol;
    public Symbol ContainingSymbol { get; }
    internal PEModuleSymbol ContainingPEModule { get; }
    public string Name { get; }
    public bool IsGlobalNamespace { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public ModuleSymbol ContainingModule { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    internal PEGlobalNamespaceSymbol(PEModuleSymbol moduleSymbol);
    public virtual Symbol get_ContainingSymbol();
    internal virtual PEModuleSymbol get_ContainingPEModule();
    public virtual string get_Name();
    public virtual bool get_IsGlobalNamespace();
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual ModuleSymbol get_ContainingModule();
    protected virtual void EnsureAllMembersLoaded();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEMethodSymbol : MethodSymbol {
    private MethodDefinitionHandle _handle;
    private string _name;
    private ushort _implFlags;
    private ushort _flags;
    private PENamedTypeSymbol _containingType;
    private Symbol _associatedPropertyOrEventOpt;
    private PackedFlags _packedFlags;
    private ImmutableArray`1<TypeParameterSymbol> _lazyTypeParameters;
    private ImmutableArray`1<MethodSymbol> _lazyExplicitMethodImplementations;
    private UncommonFields _uncommonFields;
    private SignatureData _lazySignature;
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal bool IsMetadataFinal { get; }
    internal MethodImplAttributes MethodImplFlags { get; }
    internal MethodAttributes MethodFlags { get; }
    public MethodKind MethodKind { get; }
    internal bool IsMethodKindBasedOnSyntax { get; }
    public Symbol AssociatedSymbol { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsExtensionMethod { get; }
    public bool IsExternalMethod { get; }
    internal bool IsExternal { get; }
    internal bool IsAccessCheckedOnOverride { get; }
    internal bool ReturnValueIsMarshalledExplicitly { get; }
    internal MarshalPseudoCustomAttributeData ReturnTypeMarshallingInformation { get; }
    internal ImmutableArray`1<byte> ReturnValueMarshallingDescriptor { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool HasDeclarativeSecurity { get; }
    private SignatureData Signature { get; }
    public bool IsVararg { get; }
    public bool IsGenericMethod { get; }
    public int Arity { get; }
    internal MethodDefinitionHandle Handle { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverloads { get; }
    internal bool IsHiddenBySignature { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public bool IsSub { get; }
    public bool IsAsync { get; }
    public bool IsIterator { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal int ParameterCount { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    internal PEParameterSymbol ReturnParam { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    internal CallingConvention CallingConvention { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    internal bool GenerateDebugInfoImpl { get; }
    internal PEMethodSymbol(PEModuleSymbol moduleSymbol, PENamedTypeSymbol containingType, MethodDefinitionHandle handle);
    private UncommonFields CreateUncommonFields();
    private UncommonFields AccessUncommonFields();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_HasRuntimeSpecialName();
    internal virtual bool get_IsMetadataFinal();
    internal MethodImplAttributes get_MethodImplFlags();
    internal MethodAttributes get_MethodFlags();
    public virtual MethodKind get_MethodKind();
    internal virtual bool get_IsMethodKindBasedOnSyntax();
    private MethodKind ComputeMethodKind();
    internal virtual bool IsParameterlessConstructor();
    private MethodKind ComputeMethodKindForPotentialOperatorOrConversion(OperatorInfo opInfo);
    private bool IsPotentialOperatorOrConversion(OperatorInfo opInfo);
    private MethodKind ComputeMethodKindForPotentialOperatorOrConversion(OperatorInfo opInfo, MethodKind potentialMethodKind, string additionalNameOpt, bool adjustContendersOfAdditionalName);
    public virtual Symbol get_AssociatedSymbol();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    internal virtual IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public virtual bool get_IsExtensionMethod();
    public virtual bool get_IsExternalMethod();
    public virtual DllImportData GetDllImportData();
    internal virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_IsExternal();
    internal virtual bool get_IsAccessCheckedOnOverride();
    internal virtual bool get_ReturnValueIsMarshalledExplicitly();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnTypeMarshallingInformation();
    internal virtual ImmutableArray`1<byte> get_ReturnValueMarshallingDescriptor();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    private SignatureData get_Signature();
    public virtual bool get_IsVararg();
    public virtual bool get_IsGenericMethod();
    public virtual int get_Arity();
    internal MethodDefinitionHandle get_Handle();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverloads();
    internal virtual bool get_IsHiddenBySignature();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsShared();
    public virtual bool get_IsSub();
    public virtual bool get_IsAsync();
    public virtual bool get_IsIterator();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual int get_ParameterCount();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetReturnTypeAttributes();
    internal PEParameterSymbol get_ReturnParam();
    internal bool SetAssociatedProperty(PEPropertySymbol propertySymbol, MethodKind methodKind);
    internal bool SetAssociatedEvent(PEEventSymbol eventSymbol, MethodKind methodKind);
    private bool SetAssociatedPropertyOrEvent(Symbol propertyOrEventSymbol, MethodKind methodKind);
    private SignatureData LoadSignature();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    private ImmutableArray`1<TypeParameterSymbol> EnsureTypeParametersAreLoaded(DiagnosticInfo& errorInfo);
    private ImmutableArray`1<TypeParameterSymbol> LoadTypeParameters(DiagnosticInfo& errorInfo);
    internal virtual CallingConvention get_CallingConvention();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual VisualBasicSyntaxNode get_Syntax();
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    private DiagnosticInfo InitializeUseSiteErrorInfo(DiagnosticInfo errorInfo);
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
    internal virtual bool TryGetMeParameter(ParameterSymbol& meParameter);
    internal virtual bool get_GenerateDebugInfoImpl();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEModuleSymbol : NonMissingModuleSymbol {
    private AssemblySymbol _assemblySymbol;
    private int _ordinal;
    private PEModule _module;
    private PENamespaceSymbol _globalNamespace;
    private NamedTypeSymbol _lazySystemTypeSymbol;
    private static int s_defaultTypeMapCapacity;
    internal ConcurrentDictionary`2<TypeDefinitionHandle, TypeSymbol> TypeHandleToTypeMap;
    internal ConcurrentDictionary`2<TypeReferenceHandle, TypeSymbol> TypeRefHandleToTypeMap;
    internal ImmutableArray`1<MetadataLocation> MetadataLocation;
    internal MetadataImportOptions ImportOptions;
    private ImmutableArray`1<VisualBasicAttributeData> _lazyCustomAttributes;
    private ImmutableArray`1<VisualBasicAttributeData> _lazyAssemblyAttributes;
    private ICollection`1<string> _lazyTypeNames;
    private ICollection`1<string> _lazyNamespaceNames;
    internal int Ordinal { get; }
    internal Machine Machine { get; }
    internal bool Bit32Required { get; }
    internal PEModule Module { get; }
    public Symbol ContainingSymbol { get; }
    public string Name { get; }
    public NamespaceSymbol GlobalNamespace { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal ICollection`1<string> TypeNames { get; }
    internal ICollection`1<string> NamespaceNames { get; }
    internal DocumentationProvider DocumentationProvider { get; }
    internal NamedTypeSymbol SystemTypeSymbol { get; }
    internal bool HasAssemblyCompilationRelaxationsAttribute { get; }
    internal bool HasAssemblyRuntimeCompatibilityAttribute { get; }
    internal Nullable`1<CharSet> DefaultMarshallingCharSet { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    internal PEModuleSymbol(PEAssemblySymbol assemblySymbol, PEModule module, MetadataImportOptions importOptions, int ordinal);
    internal PEModuleSymbol(SourceAssemblySymbol assemblySymbol, PEModule module, MetadataImportOptions importOptions, int ordinal);
    internal PEModuleSymbol(RetargetingAssemblySymbol assemblySymbol, PEModule module, MetadataImportOptions importOptions, int ordinal);
    private PEModuleSymbol(AssemblySymbol assemblySymbol, PEModule module, MetadataImportOptions importOptions, int ordinal);
    internal virtual int get_Ordinal();
    internal virtual Machine get_Machine();
    internal virtual bool get_Bit32Required();
    internal PEModule get_Module();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    internal ImmutableArray`1<VisualBasicAttributeData> GetAssemblyAttributes();
    internal ImmutableArray`1<VisualBasicAttributeData> GetCustomAttributesForToken(EntityHandle token);
    internal ImmutableArray`1<VisualBasicAttributeData> GetCustomAttributesForToken(EntityHandle token, CustomAttributeHandle& filteredOutAttribute1, AttributeDescription filterOut1, CustomAttributeHandle& filteredOutAttribute2, AttributeDescription filterOut2);
    internal void LoadCustomAttributes(EntityHandle token, ImmutableArray`1& lazyCustomAttributes);
    public virtual string get_Name();
    public virtual NamespaceSymbol get_GlobalNamespace();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual AssemblySymbol get_ContainingAssembly();
    internal void OnNewTypeDeclarationsLoaded(Dictionary`2<string, ImmutableArray`1<PENamedTypeSymbol>> typesDict);
    internal virtual ICollection`1<string> get_TypeNames();
    internal virtual ICollection`1<string> get_NamespaceNames();
    internal virtual ImmutableArray`1<byte> GetHash(AssemblyHashAlgorithm algorithmId);
    internal DocumentationProvider get_DocumentationProvider();
    internal NamedTypeSymbol get_SystemTypeSymbol();
    public NamedTypeSymbol GetEventRegistrationTokenType();
    private NamedTypeSymbol GetWellKnownType(WellKnownType type, bool careAboutAmbiguity);
    private static bool IsAcceptableSystemTypeSymbol(NamedTypeSymbol candidate);
    internal virtual bool get_HasAssemblyCompilationRelaxationsAttribute();
    internal virtual bool get_HasAssemblyRuntimeCompatibilityAttribute();
    internal virtual Nullable`1<CharSet> get_DefaultMarshallingCharSet();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
    internal NamedTypeSymbol LookupTopLevelMetadataType(MetadataTypeName& emittedName, Boolean& isNoPiaLocalType);
    internal AssemblySymbol GetAssemblyForForwardedType(MetadataTypeName& fullName, bool ignoreCase, String& matchedName);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEModuleSymbol/VB$StateMachine_64_GetForwardedTypes")]
internal IEnumerable`1<NamedTypeSymbol> GetForwardedTypes();
    public virtual ModuleMetadata GetMetadata();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbol : InstanceTypeSymbol {
    private NamespaceOrTypeSymbol _container;
    private TypeDefinitionHandle _handle;
    private GenericParameterHandleCollection _genericParameterHandles;
    private string _name;
    private TypeAttributes _flags;
    private ushort _arity;
    private bool _mangleName;
    private Dictionary`2<string, ImmutableArray`1<PENamedTypeSymbol>> _lazyNestedTypes;
    private ICollection`1<string> _lazyMemberNames;
    private Dictionary`2<string, ImmutableArray`1<Symbol>> _lazyMembers;
    private ImmutableArray`1<TypeParameterSymbol> _lazyTypeParameters;
    private NamedTypeSymbol _lazyEnumUnderlyingType;
    private ImmutableArray`1<VisualBasicAttributeData> _lazyCustomAttributes;
    private ImmutableArray`1<string> _lazyConditionalAttributeSymbols;
    private AttributeUsageInfo _lazyAttributeUsageInfo;
    private TypeSymbol _lazyCoClassType;
    private int _lazyTypeKind;
    private Tuple`2<CultureInfo, string> _lazyDocComment;
    private string _lazyDefaultPropertyName;
    private DiagnosticInfo _lazyUseSiteErrorInfo;
    private byte _lazyMightContainExtensionMethods;
    private int _lazyHasEmbeddedAttribute;
    private ObsoleteAttributeData _lazyObsoleteAttributeData;
    private ThreeState _lazyIsExtensibleInterface;
    internal PEModuleSymbol ContainingPEModule { get; }
    public ModuleSymbol ContainingModule { get; }
    public int Arity { get; }
    internal bool MangleName { get; }
    internal TypeLayout Layout { get; }
    internal CharSet MarshallingCharSet { get; }
    internal bool IsSerializable { get; }
    internal bool HasSpecialName { get; }
    internal int MetadataArity { get; }
    internal TypeDefinitionHandle Handle { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public Accessibility DeclaredAccessibility { get; }
    public NamedTypeSymbol EnumUnderlyingType { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public string Name { get; }
    internal TypeAttributes TypeDefFlags { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public bool IsMustInherit { get; }
    internal bool IsMetadataAbstract { get; }
    public bool IsNotInheritable { get; }
    internal bool IsMetadataSealed { get; }
    internal bool IsWindowsRuntimeImport { get; }
    internal bool ShouldAddWinRTMembers { get; }
    public bool MightContainExtensionMethods { get; }
    internal bool HasEmbeddedAttribute { get; }
    public TypeKind TypeKind { get; }
    internal bool IsInterface { get; }
    internal bool IsComImport { get; }
    internal TypeSymbol CoClassType { get; }
    internal string DefaultPropertyName { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal bool IsExtensibleInterfaceNoUseSiteDiagnostics { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    internal PENamedTypeSymbol(PEModuleSymbol moduleSymbol, PENamespaceSymbol containingNamespace, TypeDefinitionHandle handle);
    internal PENamedTypeSymbol(PEModuleSymbol moduleSymbol, PENamedTypeSymbol containingType, TypeDefinitionHandle handle);
    private PENamedTypeSymbol(PEModuleSymbol moduleSymbol, NamespaceOrTypeSymbol container, ushort containerMetadataArity, TypeDefinitionHandle handle);
    internal PEModuleSymbol get_ContainingPEModule();
    public virtual ModuleSymbol get_ContainingModule();
    public virtual int get_Arity();
    internal virtual bool get_MangleName();
    internal virtual TypeLayout get_Layout();
    internal virtual CharSet get_MarshallingCharSet();
    internal virtual bool get_IsSerializable();
    internal virtual bool get_HasSpecialName();
    internal int get_MetadataArity();
    internal TypeDefinitionHandle get_Handle();
    internal virtual IEnumerable`1<NamedTypeSymbol> GetInterfacesToEmit();
    internal virtual NamedTypeSymbol MakeDeclaredBase(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<NamedTypeSymbol> MakeDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    private static ErrorTypeSymbol CyclicInheritanceError(DiagnosticInfo diag);
    internal virtual NamedTypeSymbol MakeAcyclicBaseType(DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<NamedTypeSymbol> MakeAcyclicInterfaces(DiagnosticBag diagnostics);
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual NamedTypeSymbol get_EnumUnderlyingType();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbol/VB$StateMachine_62_GetCustomAttributesToEmit")]
internal virtual IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public virtual IEnumerable`1<string> get_MemberNames();
    private void EnsureNonTypeMemberNamesAreLoaded();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    internal virtual ImmutableArray`1<Symbol> GetMembersUnordered();
    internal virtual IEnumerable`1<FieldSymbol> GetFieldsToEmit();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbol/VB$StateMachine_69_GetMethodsToEmit")]
internal virtual IEnumerable`1<MethodSymbol> GetMethodsToEmit();
    internal virtual IEnumerable`1<PropertySymbol> GetPropertiesToEmit();
    internal virtual IEnumerable`1<EventSymbol> GetEventsToEmit();
    private void EnsureNonTypeMembersAreLoaded();
    private bool IsValidWithEventsProperty(PEPropertySymbol prop);
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembersUnordered();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    private void EnsureNestedTypesAreLoaded();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual string get_Name();
    internal TypeAttributes get_TypeDefFlags();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    private void EnsureTypeParametersAreLoaded();
    public virtual bool get_IsMustInherit();
    internal virtual bool get_IsMetadataAbstract();
    public virtual bool get_IsNotInheritable();
    internal virtual bool get_IsMetadataSealed();
    internal virtual bool get_IsWindowsRuntimeImport();
    internal virtual bool get_ShouldAddWinRTMembers();
    internal virtual bool GetGuidString(String& guidString);
    public sealed virtual bool get_MightContainExtensionMethods();
    internal virtual bool get_HasEmbeddedAttribute();
    internal virtual void BuildExtensionMethodsMap(Dictionary`2<string, ArrayBuilder`1<MethodSymbol>> map, NamespaceSymbol appendThrough);
    internal virtual void AddExtensionMethodLookupSymbolsInfo(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder, NamedTypeSymbol appendThrough);
    public virtual TypeKind get_TypeKind();
    internal virtual bool get_IsInterface();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual bool get_IsComImport();
    internal virtual TypeSymbol get_CoClassType();
    private TypeSymbol MakeComImportCoClassType();
    internal virtual string get_DefaultPropertyName();
    private string GetDefaultPropertyName();
    private Dictionary`2<string, ImmutableArray`1<PENamedTypeSymbol>> CreateNestedTypes();
    private void CreateFields(ArrayBuilder`1<Symbol> members, HashSet`1& witheventPropertyNames);
    private Dictionary`2<MethodDefinitionHandle, PEMethodSymbol> CreateMethods();
    private void CreateProperties(Dictionary`2<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol, ArrayBuilder`1<Symbol> members);
    private void CreateEvents(Dictionary`2<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol, ArrayBuilder`1<Symbol> members);
    private static PEMethodSymbol GetAccessorMethod(PEModuleSymbol moduleSymbol, Dictionary`2<MethodDefinitionHandle, PEMethodSymbol> methodHandleToSymbol, MethodDefinitionHandle methodDef);
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    private DiagnosticInfo CalculateUseSiteErrorInfoImpl();
    private bool MatchesContainingTypeParameters();
    internal virtual void GenerateDeclarationErrors(CancellationToken cancellationToken);
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual AttributeUsageInfo GetAttributeUsageInfo();
    private AttributeUsageInfo DecodeAttributeUsageInfo();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual bool get_IsExtensibleInterfaceNoUseSiteDiagnostics();
    private bool DecodeIsExtensibleInterface();
    private bool HasAttributeForExtensibleInterface();
    internal sealed virtual VisualBasicCompilation get_DeclaringCompilation();
    private static int GetIndexOfFirstMember(ImmutableArray`1<Symbol> members, SymbolKind kind);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbol/VB$StateMachine_149_GetMembers`1")]
private static IEnumerable`1<TSymbol> GetMembers(ImmutableArray`1<Symbol> members, SymbolKind kind, int offset);
    [CompilerGeneratedAttribute]
private VB$AnonymousType_2`2<NamedTypeSymbol, DiagnosticInfo> _Lambda$__52-0(NamedTypeSymbol t);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamedTypeSymbolWithEmittedNamespaceName : PENamedTypeSymbol {
    private string _emittedNamespaceName;
    private SpecialType _corTypeId;
    public SpecialType SpecialType { get; }
    internal PENamedTypeSymbolWithEmittedNamespaceName(PEModuleSymbol moduleSymbol, PENamespaceSymbol containingNamespace, TypeDefinitionHandle typeDef, string emittedNamespaceName);
    public virtual SpecialType get_SpecialType();
    internal virtual string GetEmittedNamespaceName();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENamespaceSymbol : PEOrSourceOrMergedNamespaceSymbol {
    protected Dictionary`2<string, ImmutableArray`1<Symbol>> m_lazyMembers;
    protected Dictionary`2<string, ImmutableArray`1<PENamedTypeSymbol>> m_lazyTypes;
    private Dictionary`2<string, TypeDefinitionHandle> _lazyNoPiaLocalTypes;
    private ImmutableArray`1<NamedTypeSymbol> _lazyModules;
    private ImmutableArray`1<NamedTypeSymbol> _lazyFlattenedTypes;
    internal NamespaceExtent Extent { get; }
    internal EmbeddedSymbolKind EmbeddedSymbolKind { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal PEModuleSymbol ContainingPEModule { get; }
    internal bool AreTypesLoaded { get; }
    internal ImmutableArray`1<NamedTypeSymbol> TypesToCheckForExtensionMethods { get; }
    internal sealed virtual NamespaceExtent get_Extent();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetModuleMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetModuleMembers(string name);
    public sealed virtual ImmutableArray`1<Symbol> GetMembers();
    internal virtual EmbeddedSymbolKind get_EmbeddedSymbolKind();
    public sealed virtual ImmutableArray`1<Symbol> GetMembers(string name);
    public sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal abstract virtual PEModuleSymbol get_ContainingPEModule();
    protected abstract virtual void EnsureAllMembersLoaded();
    protected void LoadAllMembers(IEnumerable`1<IGrouping`2<string, TypeDefinitionHandle>> typesByNS);
    private void LazyInitializeNamespaces(IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<IGrouping`2<string, TypeDefinitionHandle>>>> childNamespaces);
    private void LazyInitializeTypes(IEnumerable`1<IGrouping`2<string, TypeDefinitionHandle>> typeGroups);
    internal bool get_AreTypesLoaded();
    internal virtual ImmutableArray`1<NamedTypeSymbol> get_TypesToCheckForExtensionMethods();
    internal NamedTypeSymbol LookupMetadataType(MetadataTypeName& emittedTypeName, Boolean& isNoPiaLocalType);
    [CompilerGeneratedAttribute]
private PENestedNamespaceSymbol _Lambda$__25-0(KeyValuePair`2<string, IEnumerable`1<IGrouping`2<string, TypeDefinitionHandle>>> child);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PENestedNamespaceSymbol : PENamespaceSymbol {
    internal PENamespaceSymbol m_ContainingNamespaceSymbol;
    protected string m_Name;
    private IEnumerable`1<IGrouping`2<string, TypeDefinitionHandle>> _typesByNS;
    public Symbol ContainingSymbol { get; }
    internal PEModuleSymbol ContainingPEModule { get; }
    public string Name { get; }
    public bool IsGlobalNamespace { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public ModuleSymbol ContainingModule { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    internal PENestedNamespaceSymbol(string name, PENamespaceSymbol containingNamespace, IEnumerable`1<IGrouping`2<string, TypeDefinitionHandle>> typesByNS);
    public virtual Symbol get_ContainingSymbol();
    internal virtual PEModuleSymbol get_ContainingPEModule();
    public virtual string get_Name();
    public virtual bool get_IsGlobalNamespace();
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual ModuleSymbol get_ContainingModule();
    protected virtual void EnsureAllMembersLoaded();
    protected virtual Accessibility GetDeclaredAccessibilityOfMostAccessibleDescendantType();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEParameterSymbol : ParameterSymbol {
    private Symbol _containingSymbol;
    private string _name;
    private TypeSymbol _type;
    private ParameterHandle _handle;
    private ParameterAttributes _flags;
    private ushort _ordinal;
    private byte _packed;
    private static int s_isByRefMask;
    private static int s_hasNameInMetadataMask;
    private static int s_hasOptionCompareMask;
    private ImmutableArray`1<VisualBasicAttributeData> _lazyCustomAttributes;
    private ConstantValue _lazyDefaultValue;
    private ThreeState _lazyHasIDispatchConstantAttribute;
    private ThreeState _lazyHasIUnknownConstantAttribute;
    private ThreeState _lazyHasCallerLineNumberAttribute;
    private ThreeState _lazyHasCallerMemberNameAttribute;
    private ThreeState _lazyHasCallerFilePathAttribute;
    private ThreeState _lazyIsParamArray;
    private ImmutableArray`1<VisualBasicAttributeData> _lazyHiddenAttributes;
    private bool HasNameInMetadata { get; }
    public string MetadataName { get; }
    public string Name { get; }
    internal ParameterAttributes ParamFlags { get; }
    public int Ordinal { get; }
    public Symbol ContainingSymbol { get; }
    internal bool HasMetadataConstantValue { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    internal bool IsMetadataOptional { get; }
    public bool HasExplicitDefaultValue { get; }
    public bool IsOptional { get; }
    public bool IsParamArray { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public TypeSymbol Type { get; }
    public bool IsByRef { get; }
    internal bool IsExplicitByRef { get; }
    internal bool IsMetadataOut { get; }
    internal bool IsMetadataIn { get; }
    internal bool HasOptionCompare { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    internal bool IsMarshalledExplicitly { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal ImmutableArray`1<byte> MarshallingDescriptor { get; }
    internal UnmanagedType MarshallingType { get; }
    internal ParameterHandle Handle { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerMemberName { get; }
    internal bool IsCallerFilePath { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    private PEModule PEModule { get; }
    private PEParameterSymbol(Symbol containingSymbol, string name, bool isByRef, TypeSymbol type, ParameterHandle handle, ParameterAttributes flags, bool isParamArray, bool hasOptionCompare, int ordinal, ConstantValue defaultValue);
    private PEParameterSymbol(PEModuleSymbol moduleSymbol, Symbol containingSymbol, int ordinal, bool isByRef, TypeSymbol type, ParameterHandle handle, Boolean& isBad);
    internal static PEParameterSymbol Create(PEModuleSymbol moduleSymbol, PEMethodSymbol containingSymbol, int ordinal, ParamInfo`1& parameter, Boolean& isBad);
    internal static PEParameterSymbol Create(Symbol containingSymbol, string name, bool isByRef, ushort countOfCustomModifiersPrecedingByRef, TypeSymbol type, ParameterHandle handle, ParameterAttributes flags, bool isParamArray, bool hasOptionCompare, int ordinal, ConstantValue defaultValue, ImmutableArray`1<CustomModifier> customModifiers);
    private static PEParameterSymbol Create(PEModuleSymbol moduleSymbol, Symbol containingSymbol, int ordinal, bool isByRef, ushort countOfCustomModifiersPrecedingByRef, TypeSymbol type, ParameterHandle handle, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers, Boolean& isBad);
    private static byte Pack(bool isByRef, bool hasNameInMetadata, bool hasOptionCompare);
    private static string EnsureParameterNameNotEmpty(string name, Boolean& hasNameInMetadata);
    private bool get_HasNameInMetadata();
    public virtual string get_MetadataName();
    public virtual string get_Name();
    internal ParameterAttributes get_ParamFlags();
    public virtual int get_Ordinal();
    public virtual Symbol get_ContainingSymbol();
    internal virtual bool get_HasMetadataConstantValue();
    internal virtual ConstantValue get_ExplicitDefaultConstantValue(SymbolsInProgress`1<ParameterSymbol> inProgress);
    internal virtual bool get_IsMetadataOptional();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEParameterSymbol/VB$StateMachine_46_GetCustomAttributesToEmit")]
internal virtual IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public virtual bool get_HasExplicitDefaultValue();
    public virtual bool get_IsOptional();
    public virtual bool get_IsParamArray();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual TypeSymbol get_Type();
    public virtual bool get_IsByRef();
    internal virtual bool get_IsExplicitByRef();
    internal virtual bool get_IsMetadataOut();
    internal virtual bool get_IsMetadataIn();
    internal virtual bool get_HasOptionCompare();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    internal virtual bool get_IsMarshalledExplicitly();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    internal virtual UnmanagedType get_MarshallingType();
    internal ParameterHandle get_Handle();
    internal virtual bool get_IsIDispatchConstant();
    internal virtual bool get_IsIUnknownConstant();
    internal virtual bool get_IsCallerLineNumber();
    internal virtual bool get_IsCallerMemberName();
    internal virtual bool get_IsCallerFilePath();
    internal virtual ushort get_CountOfCustomModifiersPrecedingByRef();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
    private PEModule get_PEModule();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PEPropertySymbol : PropertySymbol {
    private string _name;
    private PropertyAttributes _flags;
    private PENamedTypeSymbol _containingType;
    private SignatureHeader _signatureHeader;
    private ImmutableArray`1<ParameterSymbol> _parameters;
    private TypeSymbol _propertyType;
    private PEMethodSymbol _getMethod;
    private PEMethodSymbol _setMethod;
    private PropertyDefinitionHandle _handle;
    private ImmutableArray`1<CustomModifier> _typeCustomModifiers;
    private ImmutableArray`1<VisualBasicAttributeData> _lazyCustomAttributes;
    private Tuple`2<CultureInfo, string> _lazyDocComment;
    private DiagnosticInfo _lazyUseSiteErrorInfo;
    private int _isWithEvents;
    private static int s_unsetAccessibility;
    private int _lazyDeclaredAccessibility;
    private ObsoleteAttributeData _lazyObsoleteAttributeData;
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public string Name { get; }
    internal PropertyAttributes PropertyFlags { get; }
    internal bool HasSpecialName { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsOverloads { get; }
    public bool IsShared { get; }
    public bool IsDefault { get; }
    public bool IsWithEvents { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public MethodSymbol GetMethod { get; }
    public MethodSymbol SetMethod { get; }
    internal FieldSymbol AssociatedField { get; }
    internal CallingConvention CallingConvention { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public ImmutableArray`1<PropertySymbol> ExplicitInterfaceImplementations { get; }
    private MethodSymbol GetterOrSetter { get; }
    internal PropertyDefinitionHandle Handle { get; }
    internal bool IsMyGroupCollectionProperty { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    internal PEPropertySymbol(PEModuleSymbol moduleSymbol, PENamedTypeSymbol containingType, PropertyDefinitionHandle handle, PEMethodSymbol getMethod, PEMethodSymbol setMethod);
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual string get_Name();
    internal PropertyAttributes get_PropertyFlags();
    internal virtual bool get_HasSpecialName();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsShared();
    public virtual bool get_IsDefault();
    public virtual bool get_IsWithEvents();
    internal void SetIsWithEvents(bool value);
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
    public virtual MethodSymbol get_GetMethod();
    public virtual MethodSymbol get_SetMethod();
    internal virtual FieldSymbol get_AssociatedField();
    internal virtual CallingConvention get_CallingConvention();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    internal virtual IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public virtual ImmutableArray`1<PropertySymbol> get_ExplicitInterfaceImplementations();
    private MethodSymbol get_GetterOrSetter();
    private static bool DoSignaturesMatch(MetadataDecoder metadataDecoder, ParamInfo`1[] propertyParams, PEMethodSymbol getMethodOpt, ParamInfo`1[] getMethodParamsOpt, PEMethodSymbol setMethodOpt, ParamInfo`1[] setMethodParamsOpt);
    private static Accessibility GetDeclaredAccessibility(PropertySymbol property);
    private static ImmutableArray`1<ParameterSymbol> GetParameters(PEPropertySymbol property, PEMethodSymbol getMethod, PEMethodSymbol setMethod, ParamInfo`1[] propertyParams, Boolean& parametersMatch);
    private static PEParameterSymbol GetAccessorParameter(PEMethodSymbol accessor, int index);
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    internal PropertyDefinitionHandle get_Handle();
    internal virtual bool get_IsMyGroupCollectionProperty();
    internal virtual bool get_HasRuntimeSpecialName();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.PETypeParameterSymbol : TypeParameterSymbol {
    private Symbol _containingSymbol;
    private GenericParameterHandle _handle;
    private ImmutableArray`1<VisualBasicAttributeData> _lazyCustomAttributes;
    private string _name;
    private ushort _ordinal;
    private GenericParameterAttributes _flags;
    private ImmutableArray`1<TypeSymbol> _lazyConstraintTypes;
    private DiagnosticInfo _lazyBoundsErrorInfo;
    public TypeParameterKind TypeParameterKind { get; }
    public int Ordinal { get; }
    public string Name { get; }
    internal GenericParameterHandle Handle { get; }
    public Symbol ContainingSymbol { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal ImmutableArray`1<TypeSymbol> ConstraintTypesNoUseSiteDiagnostics { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool HasConstructorConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public VarianceKind Variance { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    internal PETypeParameterSymbol(PEModuleSymbol moduleSymbol, PENamedTypeSymbol definingNamedType, ushort ordinal, GenericParameterHandle handle);
    internal PETypeParameterSymbol(PEModuleSymbol moduleSymbol, PEMethodSymbol definingMethod, ushort ordinal, GenericParameterHandle handle);
    private PETypeParameterSymbol(PEModuleSymbol moduleSymbol, Symbol definingSymbol, ushort ordinal, GenericParameterHandle handle);
    public virtual TypeParameterKind get_TypeParameterKind();
    public virtual int get_Ordinal();
    public virtual string get_Name();
    internal GenericParameterHandle get_Handle();
    public virtual Symbol get_ContainingSymbol();
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    internal virtual ImmutableArray`1<TypeSymbol> get_ConstraintTypesNoUseSiteDiagnostics();
    private ImmutableArray`1<TypeParameterConstraint> GetDeclaredConstraints();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool get_HasConstructorConstraint();
    public virtual bool get_HasReferenceTypeConstraint();
    public virtual bool get_HasValueTypeConstraint();
    public virtual VarianceKind get_Variance();
    internal virtual void EnsureAllConstraintsAreResolved();
    internal virtual void ResolveConstraints(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual DiagnosticInfo GetConstraintsUseSiteErrorInfo();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Metadata.PE.SymbolFactory : SymbolFactory`2<PEModuleSymbol, TypeSymbol> {
    internal static SymbolFactory Instance;
    private static SymbolFactory();
    internal virtual TypeSymbol GetMDArrayTypeSymbol(PEModuleSymbol moduleSymbol, int rank, TypeSymbol elementType, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers, ImmutableArray`1<int> sizes, ImmutableArray`1<int> lowerBounds);
    internal virtual TypeSymbol GetByRefReturnTypeSymbol(PEModuleSymbol moduleSymbol, TypeSymbol referencedType, ushort countOfCustomModifiersPrecedingByRef);
    internal virtual TypeSymbol GetSpecialType(PEModuleSymbol moduleSymbol, SpecialType specialType);
    internal virtual TypeSymbol GetSystemTypeSymbol(PEModuleSymbol moduleSymbol);
    internal virtual TypeSymbol GetEnumUnderlyingType(PEModuleSymbol moduleSymbol, TypeSymbol type);
    internal virtual PrimitiveTypeCode GetPrimitiveTypeCode(PEModuleSymbol moduleSymbol, TypeSymbol type);
    internal virtual bool IsVolatileModifierType(PEModuleSymbol moduleSymbol, TypeSymbol type);
    internal virtual TypeSymbol GetSZArrayTypeSymbol(PEModuleSymbol moduleSymbol, TypeSymbol elementType, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers);
    internal virtual TypeSymbol GetUnsupportedMetadataTypeSymbol(PEModuleSymbol moduleSymbol, BadImageFormatException exception);
    internal virtual TypeSymbol MakePointerTypeSymbol(PEModuleSymbol moduleSymbol, TypeSymbol type, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers);
    internal virtual TypeSymbol SubstituteTypeParameters(PEModuleSymbol moduleSymbol, TypeSymbol genericTypeDef, ImmutableArray`1<KeyValuePair`2<TypeSymbol, ImmutableArray`1<ModifierInfo`1<TypeSymbol>>>> arguments, ImmutableArray`1<bool> refersToNoPiaLocalType);
    internal virtual TypeSymbol MakeUnboundIfGeneric(PEModuleSymbol moduleSymbol, TypeSymbol type);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.MetadataOrSourceAssemblySymbol : NonMissingAssemblySymbol {
    private NamedTypeSymbol[] _lazySpecialTypes;
    private int _cachedSpecialTypes;
    private ICollection`1<string> _lazyTypeNames;
    private ICollection`1<string> _lazyNamespaceNames;
    private ConcurrentDictionary`2<AssemblySymbol, IVTConclusion> _assembliesToWhichInternalAccessHasBeenAnalyzed;
    private Symbol[] _lazySpecialTypeMembers;
    internal bool KeepLookingForDeclaredSpecialTypes { get; }
    public ICollection`1<string> TypeNames { get; }
    public ICollection`1<string> NamespaceNames { get; }
    private ConcurrentDictionary`2<AssemblySymbol, IVTConclusion> AssembliesToWhichInternalAccessHasBeenDetermined { get; }
    internal virtual NamedTypeSymbol GetDeclaredSpecialType(SpecialType type);
    internal virtual void RegisterDeclaredSpecialType(NamedTypeSymbol corType);
    internal virtual bool get_KeepLookingForDeclaredSpecialTypes();
    public virtual ICollection`1<string> get_TypeNames();
    public virtual ICollection`1<string> get_NamespaceNames();
    protected IVTConclusion MakeFinalIVTDetermination(AssemblySymbol potentialGiverOfAccess);
    private ConcurrentDictionary`2<AssemblySymbol, IVTConclusion> get_AssembliesToWhichInternalAccessHasBeenDetermined();
    internal virtual Symbol GetDeclaredSpecialTypeMember(SpecialMember member);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodEarlyWellKnownAttributeData : CommonMethodEarlyWellKnownAttributeData {
    private bool _isExtensionMethod;
    internal bool IsExtensionMethod { get; internal set; }
    internal bool get_IsExtensionMethod();
    internal void set_IsExtensionMethod(bool value);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodKindExtensions : object {
    [ExtensionAttribute]
internal static string TryGetAccessorDisplayName(MethodKind kind);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSignatureComparer : object {
    public static MethodSignatureComparer RuntimeMethodSignatureComparer;
    public static MethodSignatureComparer AllAspectsSignatureComparer;
    public static MethodSignatureComparer ParametersAndReturnTypeSignatureComparer;
    public static MethodSignatureComparer CustomModifiersAndParametersAndReturnTypeSignatureComparer;
    public static MethodSignatureComparer VisualBasicSignatureAndConstraintsAndReturnTypeComparer;
    public static MethodSignatureComparer RetargetedExplicitMethodImplementationComparer;
    public static MethodSignatureComparer WinRTConflictComparer;
    private bool _considerName;
    private bool _considerReturnType;
    private bool _considerTypeConstraints;
    private bool _considerCallingConvention;
    private bool _considerByRef;
    private bool _considerCustomModifiers;
    private static MethodSignatureComparer();
    private MethodSignatureComparer(bool considerName, bool considerReturnType, bool considerTypeConstraints, bool considerCallingConvention, bool considerByRef, bool considerCustomModifiers);
    public sealed virtual override bool Equals(MethodSymbol method1, MethodSymbol method2);
    public sealed virtual override int GetHashCode(MethodSymbol method);
    public static SymbolComparisonResults DetailedCompare(MethodSymbol method1, MethodSymbol method2, SymbolComparisonResults comparisons, SymbolComparisonResults stopIfAny);
    public static SymbolComparisonResults DetailedReturnTypeCompare(TypeWithModifiers type1, TypeSubstitution typeSubstitution1, TypeWithModifiers type2, TypeSubstitution typeSubstitution2, SymbolComparisonResults comparisons);
    public static SymbolComparisonResults DetailedParameterCompare(ImmutableArray`1<ParameterSymbol> params1, LazyTypeSubstitution& lazyTypeSubstitution1, ImmutableArray`1<ParameterSymbol> params2, LazyTypeSubstitution& lazyTypeSubstitution2, SymbolComparisonResults comparisons, SymbolComparisonResults stopIfAny);
    private static bool ParameterDefaultValueMismatch(ParameterSymbol param1, ParameterSymbol param2);
    public static bool HaveSameParameterTypes(ImmutableArray`1<ParameterSymbol> params1, TypeSubstitution typeSubstitution1, ImmutableArray`1<ParameterSymbol> params2, TypeSubstitution typeSubstitution2, bool considerByRef, bool considerCustomModifiers);
    private static bool HaveSameReturnTypes(MethodSymbol method1, TypeSubstitution typeSubstitution1, MethodSymbol method2, TypeSubstitution typeSubstitution2, bool considerCustomModifiers);
    private static TypeSubstitution GetTypeSubstitution(MethodSymbol method);
    private static TypeWithModifiers SubstituteType(TypeSubstitution typeSubstitution, TypeWithModifiers typeSymbol);
    internal static bool HaveSameConstraints(MethodSymbol method1, MethodSymbol method2);
    private static bool HaveSameConstraints(MethodSymbol method1, TypeSubstitution typeSubstitution1, MethodSymbol method2, TypeSubstitution typeSubstitution2);
    internal static bool HaveSameConstraints(TypeParameterSymbol typeParameter1, TypeSubstitution typeSubstitution1, TypeParameterSymbol typeParameter2, TypeSubstitution typeSubstitution2);
    private static bool AreConstraintTypesSubset(ArrayBuilder`1<TypeSymbol> constraintTypes1, ArrayBuilder`1<TypeSymbol> constraintTypes2);
    private static bool ContainsIgnoringCustomModifiers(ArrayBuilder`1<TypeSymbol> types, TypeSymbol type);
    private static void SubstituteConstraintTypes(ImmutableArray`1<TypeSymbol> constraintTypes, ArrayBuilder`1<TypeSymbol> result, TypeSubstitution substitution);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbol : Symbol {
    public static MethodImplAttributes DisableJITOptimizationFlags;
    private IGenericMethodInstanceReference IMethodReferenceAsGenericMethodInstanceReference { get; }
    private ISpecializedMethodReference IMethodReferenceAsSpecializedMethodReference { get; }
    private string INamedEntityName { get; }
    private bool IMethodReferenceAcceptsExtraArguments { get; }
    private ushort IMethodReferenceGenericParameterCount { get; }
    private bool IMethodReferenceIsGeneric { get; }
    private ushort IMethodReferenceParameterCount { get; }
    private ImmutableArray`1<IParameterTypeInformation> IMethodReferenceExtraParameters { get; }
    private CallingConvention ISignatureCallingConvention { get; }
    private ImmutableArray`1<ICustomModifier> ISignatureReturnValueCustomModifiers { get; }
    private bool ISignatureReturnValueIsByRef { get; }
    private IMethodReference ISpecializedMethodReferenceUnspecializedVersion { get; }
    private ITypeDefinition ITypeDefinitionMemberContainingTypeDefinition { get; }
    private TypeMemberVisibility ITypeDefinitionMemberVisibility { get; }
    private IEnumerable`1<IGenericMethodParameter> IMethodDefinitionGenericParameters { get; }
    private bool IMethodDefinitionHasDeclarativeSecurity { get; }
    private bool IMethodDefinitionIsImplicitlyDeclared { get; }
    private bool IMethodDefinitionIsAbstract { get; }
    private bool IMethodDefinitionIsAccessCheckedOnOverride { get; }
    internal bool IsAccessCheckedOnOverride { get; }
    private bool IMethodDefinitionIsConstructor { get; }
    private bool IMethodDefinitionIsExternal { get; }
    internal bool IsExternal { get; }
    private bool IMethodDefinitionIsHiddenBySignature { get; }
    internal bool IsHiddenBySignature { get; }
    private bool IMethodDefinitionIsNewSlot { get; }
    private bool IMethodDefinitionIsPlatformInvoke { get; }
    private IPlatformInvokeInformation IMethodDefinitionPlatformInvokeData { get; }
    private bool IMethodDefinitionIsRuntimeSpecial { get; }
    internal bool HasRuntimeSpecialName { get; }
    private bool IMethodDefinitionIsSealed { get; }
    internal bool IsMetadataFinal { get; }
    private bool IMethodDefinitionIsSpecialName { get; }
    private bool IMethodDefinitionIsStatic { get; }
    private bool IMethodDefinitionIsVirtual { get; }
    private ImmutableArray`1<IParameterDefinition> IMethodDefinitionParameters { get; }
    private bool IMethodDefinitionRequiresSecurityObject { get; }
    private IEnumerable`1<ICustomAttribute> IMethodDefinitionReturnValueAttributes { get; }
    private bool IMethodDefinitionReturnValueIsMarshalledExplicitly { get; }
    internal bool ReturnValueIsMarshalledExplicitly { get; }
    private IMarshallingInformation IMethodDefinitionReturnValueMarshallingInformation { get; }
    private ImmutableArray`1<byte> IMethodDefinitionReturnValueMarshallingDescriptor { get; }
    internal ImmutableArray`1<byte> ReturnValueMarshallingDescriptor { get; }
    private IEnumerable`1<SecurityAttribute> IMethodDefinitionSecurityAttributes { get; }
    private INamespace IMethodDefinition_ContainingNamespace { get; }
    public MethodKind MethodKind { get; }
    internal bool IsMethodKindBasedOnSyntax { get; }
    public bool IsVararg { get; }
    public bool IsCheckedBuiltin { get; }
    public bool IsGenericMethod { get; }
    public int Arity { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public MethodSymbol OriginalDefinition { get; }
    protected Symbol OriginalSymbolDefinition { get; }
    public MethodSymbol ConstructedFrom { get; }
    public bool IsSub { get; }
    public bool IsAsync { get; }
    public bool IsIterator { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    internal int ParameterCount { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    internal bool IsConditional { get; }
    internal bool HasSpecialName { get; }
    public Symbol AssociatedSymbol { get; }
    public NamedTypeSymbol AssociatedAnonymousDelegate { get; }
    public MethodSymbol OverriddenMethod { get; }
    internal OverriddenMembersResult`1<MethodSymbol> OverriddenMembers { get; }
    public ImmutableArray`1<HandledEvent> HandledEvents { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public bool IsExternalMethod { get; }
    internal MarshalPseudoCustomAttributeData ReturnTypeMarshallingInformation { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool HasDeclarativeSecurity { get; }
    public bool IsExtensionMethod { get; }
    internal bool MayBeReducibleExtensionMethod { get; }
    public bool IsOverloads { get; }
    internal bool IsRuntimeImplemented { get; }
    internal Symbol ImplicitlyDefinedBy { get; }
    public SymbolKind Kind { get; }
    internal bool IsScriptConstructor { get; }
    internal bool IsScriptInitializer { get; }
    internal bool IsSubmissionConstructor { get; }
    internal bool IsEntryPointCandidate { get; }
    internal bool IsViableMainMethod { get; }
    internal bool CanConstruct { get; }
    internal CallingConvention CallingConvention { get; }
    internal ParameterSymbol MeParameter { get; }
    protected int HighestPriorityUseSiteError { get; }
    public bool HasUnsupportedMetadata { get; }
    public MethodSymbol ReducedFrom { get; }
    internal bool IsReducedExtensionMethod { get; }
    internal MethodSymbol CallsiteReducedFromMethod { get; }
    public TypeSymbol ReceiverType { get; }
    internal ImmutableArray`1<KeyValuePair`2<TypeParameterSymbol, TypeSymbol>> FixedTypeParameters { get; }
    internal int Proximity { get; }
    internal EmbeddedSymbolKind EmbeddedSymbolKind { get; }
    internal bool GenerateDebugInfoImpl { get; }
    internal bool GenerateDebugInfo { get; }
    internal bool PreserveOriginalLocals { get; }
    private int IMethodSymbol_Arity { get; }
    private IMethodSymbol IMethodSymbol_ConstructedFrom { get; }
    private ImmutableArray`1<IMethodSymbol> IMethodSymbol_ExplicitInterfaceImplementations { get; }
    private bool IMethodSymbol_IsExtensionMethod { get; }
    private MethodKind IMethodSymbol_MethodKind { get; }
    private IMethodSymbol IMethodSymbol_OriginalDefinition { get; }
    private IMethodSymbol IMethodSymbol_OverriddenMethod { get; }
    private ITypeSymbol IMethodSymbol_ReceiverType { get; }
    private IMethodSymbol IMethodSymbol_ReducedFrom { get; }
    private ImmutableArray`1<IParameterSymbol> IMethodSymbol_Parameters { get; }
    private bool ISymbol_IsExtern { get; }
    public MethodSymbol PartialImplementationPart { get; }
    public MethodSymbol PartialDefinitionPart { get; }
    private IMethodSymbol IMethodSymbol_PartialDefinitionPart { get; }
    private IMethodSymbol IMethodSymbol_PartialImplementationPart { get; }
    private bool IMethodSymbol_ReturnsVoid { get; }
    private ITypeSymbol IMethodSymbol_ReturnType { get; }
    private ImmutableArray`1<ITypeSymbol> IMethodSymbol_TypeArguments { get; }
    private ImmutableArray`1<ITypeParameterSymbol> IMethodSymbol_TypeParameters { get; }
    private ISymbol IMethodSymbol_AssociatedSymbol { get; }
    private bool IMethodSymbol_IsGenericMethod { get; }
    private bool IMethodSymbol_IsAsync { get; }
    private bool IMethodSymbol_HidesBaseMethodsByName { get; }
    private ImmutableArray`1<CustomModifier> IMethodSymbol_ReturnTypeCustomModifiers { get; }
    private INamedTypeSymbol IMethodSymbol_AssociatedAnonymousDelegate { get; }
    private bool IMethodSymbolInternal_IsIterator { get; }
    private sealed virtual override IGenericMethodInstanceReference get_IMethodReferenceAsGenericMethodInstanceReference();
    private sealed virtual override ISpecializedMethodReference get_IMethodReferenceAsSpecializedMethodReference();
    internal sealed virtual IDefinition IReferenceAsDefinition(EmitContext context);
    private sealed virtual override ITypeReference ITypeMemberReferenceGetContainingType(EmitContext context);
    internal sealed virtual void IReferenceDispatch(MetadataVisitor visitor);
    private sealed virtual override string get_INamedEntityName();
    private sealed virtual override bool get_IMethodReferenceAcceptsExtraArguments();
    private sealed virtual override ushort get_IMethodReferenceGenericParameterCount();
    private sealed virtual override bool get_IMethodReferenceIsGeneric();
    private sealed virtual override ushort get_IMethodReferenceParameterCount();
    private sealed virtual override IMethodDefinition IMethodReferenceGetResolvedMethod(EmitContext context);
    private IMethodDefinition ResolvedMethodImpl(PEModuleBuilder moduleBeingBuilt);
    private sealed virtual override ImmutableArray`1<IParameterTypeInformation> get_IMethodReferenceExtraParameters();
    private sealed virtual override CallingConvention get_ISignatureCallingConvention();
    private sealed virtual override ImmutableArray`1<IParameterTypeInformation> ISignatureGetParameters(EmitContext context);
    private ImmutableArray`1<IParameterTypeInformation> EnumerateDefinitionParameters();
    private sealed virtual override ImmutableArray`1<ICustomModifier> get_ISignatureReturnValueCustomModifiers();
    private sealed virtual override bool get_ISignatureReturnValueIsByRef();
    private sealed virtual override ITypeReference ISignatureGetType(EmitContext context);
    private sealed virtual override IEnumerable`1<ITypeReference> IGenericMethodInstanceReferenceGetGenericArguments(EmitContext context);
    private sealed virtual override IMethodReference IGenericMethodInstanceReferenceGetGenericMethod(EmitContext context);
    private sealed virtual override IMethodReference get_ISpecializedMethodReferenceUnspecializedVersion();
    private sealed virtual override ITypeDefinition get_ITypeDefinitionMemberContainingTypeDefinition();
    private sealed virtual override TypeMemberVisibility get_ITypeDefinitionMemberVisibility();
    private sealed virtual override IMethodBody IMethodDefinitionGetBody(EmitContext context);
    private sealed virtual override IEnumerable`1<IGenericMethodParameter> get_IMethodDefinitionGenericParameters();
    private sealed virtual override bool get_IMethodDefinitionHasDeclarativeSecurity();
    private sealed virtual override bool get_IMethodDefinitionIsImplicitlyDeclared();
    private sealed virtual override bool get_IMethodDefinitionIsAbstract();
    private sealed virtual override bool get_IMethodDefinitionIsAccessCheckedOnOverride();
    internal virtual bool get_IsAccessCheckedOnOverride();
    private sealed virtual override bool get_IMethodDefinitionIsConstructor();
    private sealed virtual override bool get_IMethodDefinitionIsExternal();
    internal virtual bool get_IsExternal();
    private sealed virtual override MethodImplAttributes IMethodDefinitionGetImplementationOptions(EmitContext context);
    private sealed virtual override bool get_IMethodDefinitionIsHiddenBySignature();
    internal virtual bool get_IsHiddenBySignature();
    private sealed virtual override bool get_IMethodDefinitionIsNewSlot();
    internal virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    private sealed virtual override bool get_IMethodDefinitionIsPlatformInvoke();
    private sealed virtual override IPlatformInvokeInformation get_IMethodDefinitionPlatformInvokeData();
    private sealed virtual override bool get_IMethodDefinitionIsRuntimeSpecial();
    internal virtual bool get_HasRuntimeSpecialName();
    private sealed virtual override bool get_IMethodDefinitionIsSealed();
    internal virtual bool get_IsMetadataFinal();
    private sealed virtual override bool get_IMethodDefinitionIsSpecialName();
    private sealed virtual override bool get_IMethodDefinitionIsStatic();
    private sealed virtual override bool get_IMethodDefinitionIsVirtual();
    private sealed virtual override ImmutableArray`1<IParameterDefinition> get_IMethodDefinitionParameters();
    private sealed virtual override bool get_IMethodDefinitionRequiresSecurityObject();
    private sealed virtual override IEnumerable`1<ICustomAttribute> get_IMethodDefinitionReturnValueAttributes();
    private sealed virtual override bool get_IMethodDefinitionReturnValueIsMarshalledExplicitly();
    internal virtual bool get_ReturnValueIsMarshalledExplicitly();
    private sealed virtual override IMarshallingInformation get_IMethodDefinitionReturnValueMarshallingInformation();
    private sealed virtual override ImmutableArray`1<byte> get_IMethodDefinitionReturnValueMarshallingDescriptor();
    internal virtual ImmutableArray`1<byte> get_ReturnValueMarshallingDescriptor();
    private sealed virtual override IEnumerable`1<SecurityAttribute> get_IMethodDefinitionSecurityAttributes();
    private sealed virtual override INamespace get_IMethodDefinition_ContainingNamespace();
    protected bool ValidateGenericConstraintsOnExtensionMethodDefinition();
    public abstract virtual MethodKind get_MethodKind();
    internal abstract virtual bool get_IsMethodKindBasedOnSyntax();
    internal virtual bool IsParameterlessConstructor();
    public abstract virtual override bool get_IsVararg();
    public virtual override bool get_IsCheckedBuiltin();
    public virtual bool get_IsGenericMethod();
    public abstract virtual int get_Arity();
    public abstract virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public abstract virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual MethodSymbol get_OriginalDefinition();
    protected sealed virtual Symbol get_OriginalSymbolDefinition();
    public virtual MethodSymbol get_ConstructedFrom();
    public abstract virtual bool get_IsSub();
    public abstract virtual bool get_IsAsync();
    public abstract virtual bool get_IsIterator();
    public abstract virtual TypeSymbol get_ReturnType();
    public abstract virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetReturnTypeAttributes();
    internal virtual int get_ParameterCount();
    public abstract virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal abstract virtual VisualBasicSyntaxNode get_Syntax();
    internal virtual bool CallsAreOmitted(SyntaxNodeOrToken atNode, SyntaxTree syntaxTree);
    private bool CallsAreConditionallyOmitted(SyntaxNodeOrToken atNode, SyntaxTree syntaxTree);
    internal abstract virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal bool get_IsConditional();
    internal abstract virtual bool get_HasSpecialName();
    public abstract virtual Symbol get_AssociatedSymbol();
    public virtual NamedTypeSymbol get_AssociatedAnonymousDelegate();
    public virtual MethodSymbol get_OverriddenMethod();
    internal virtual OverriddenMembersResult`1<MethodSymbol> get_OverriddenMembers();
    public virtual ImmutableArray`1<HandledEvent> get_HandledEvents();
    public abstract virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public abstract virtual bool get_IsExternalMethod();
    public abstract virtual override DllImportData GetDllImportData();
    internal abstract virtual MarshalPseudoCustomAttributeData get_ReturnTypeMarshallingInformation();
    internal abstract virtual MethodImplAttributes get_ImplementationAttributes();
    internal abstract virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal abstract virtual bool get_HasDeclarativeSecurity();
    public abstract virtual bool get_IsExtensionMethod();
    internal virtual bool get_MayBeReducibleExtensionMethod();
    public abstract virtual bool get_IsOverloads();
    internal bool get_IsRuntimeImplemented();
    internal virtual Symbol get_ImplicitlyDefinedBy(Dictionary`2<string, ArrayBuilder`1<Symbol>> membersInProgress);
    public sealed virtual SymbolKind get_Kind();
    internal bool get_IsScriptConstructor();
    internal virtual bool get_IsScriptInitializer();
    internal bool get_IsSubmissionConstructor();
    internal bool get_IsEntryPointCandidate();
    internal bool get_IsViableMainMethod();
    private bool IsAccessibleEntryPoint();
    internal bool HasEntryPointSignature();
    internal virtual TResult Accept(VisualBasicSymbolVisitor`2<TArgument, TResult> visitor, TArgument arg);
    internal virtual bool get_CanConstruct();
    protected void CheckCanConstructAndTypeArguments(ImmutableArray`1<TypeSymbol> typeArguments);
    public virtual MethodSymbol Construct(ImmutableArray`1<TypeSymbol> typeArguments);
    public MethodSymbol Construct(TypeSymbol[] typeArguments);
    internal abstract virtual CallingConvention get_CallingConvention();
    internal ParameterSymbol get_MeParameter();
    internal virtual bool TryGetMeParameter(ParameterSymbol& meParameter);
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    internal DiagnosticInfo CalculateUseSiteErrorInfo();
    protected virtual int get_HighestPriorityUseSiteError();
    public sealed virtual bool get_HasUnsupportedMetadata();
    public virtual MethodSymbol get_ReducedFrom();
    internal bool get_IsReducedExtensionMethod();
    internal virtual MethodSymbol get_CallsiteReducedFromMethod();
    public virtual TypeSymbol get_ReceiverType();
    public virtual TypeSymbol GetTypeInferredDuringReduction(TypeParameterSymbol reducedFromTypeParameter);
    internal virtual ImmutableArray`1<KeyValuePair`2<TypeParameterSymbol, TypeSymbol>> get_FixedTypeParameters();
    internal MethodSymbol ReduceExtensionMethod(TypeSymbol instanceType, int proximity);
    public MethodSymbol ReduceExtensionMethod(TypeSymbol instanceType);
    internal virtual int get_Proximity();
    internal virtual EmbeddedSymbolKind get_EmbeddedSymbolKind();
    internal virtual BoundBlock GetBoundMethodBody(DiagnosticBag diagnostics, Binder& methodBodyBinder);
    internal abstract virtual bool get_GenerateDebugInfoImpl();
    internal bool get_GenerateDebugInfo();
    internal abstract virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    internal virtual bool get_PreserveOriginalLocals();
    private sealed virtual override int get_IMethodSymbol_Arity();
    private sealed virtual override IMethodSymbol get_IMethodSymbol_ConstructedFrom();
    private sealed virtual override ImmutableArray`1<IMethodSymbol> get_IMethodSymbol_ExplicitInterfaceImplementations();
    private sealed virtual override bool get_IMethodSymbol_IsExtensionMethod();
    private sealed virtual override MethodKind get_IMethodSymbol_MethodKind();
    private sealed virtual override IMethodSymbol get_IMethodSymbol_OriginalDefinition();
    private sealed virtual override IMethodSymbol get_IMethodSymbol_OverriddenMethod();
    private sealed virtual override ITypeSymbol get_IMethodSymbol_ReceiverType();
    private sealed virtual override ITypeSymbol IMethodSymbol_GetTypeInferredDuringReduction(ITypeParameterSymbol reducedFromTypeParameter);
    private sealed virtual override IMethodSymbol get_IMethodSymbol_ReducedFrom();
    private sealed virtual override IMethodSymbol IMethodSymbol_ReduceExtensionMethod(ITypeSymbol receiverType);
    private sealed virtual override ImmutableArray`1<IParameterSymbol> get_IMethodSymbol_Parameters();
    private sealed virtual override bool get_ISymbol_IsExtern();
    public virtual MethodSymbol get_PartialImplementationPart();
    public virtual MethodSymbol get_PartialDefinitionPart();
    private sealed virtual override IMethodSymbol get_IMethodSymbol_PartialDefinitionPart();
    private sealed virtual override IMethodSymbol get_IMethodSymbol_PartialImplementationPart();
    private sealed virtual override bool get_IMethodSymbol_ReturnsVoid();
    private sealed virtual override ITypeSymbol get_IMethodSymbol_ReturnType();
    private sealed virtual override ImmutableArray`1<ITypeSymbol> get_IMethodSymbol_TypeArguments();
    private sealed virtual override ImmutableArray`1<ITypeParameterSymbol> get_IMethodSymbol_TypeParameters();
    private sealed virtual override ISymbol get_IMethodSymbol_AssociatedSymbol();
    private sealed virtual override bool get_IMethodSymbol_IsGenericMethod();
    private sealed virtual override bool get_IMethodSymbol_IsAsync();
    private sealed virtual override bool get_IMethodSymbol_HidesBaseMethodsByName();
    private sealed virtual override ImmutableArray`1<CustomModifier> get_IMethodSymbol_ReturnTypeCustomModifiers();
    private sealed virtual override ImmutableArray`1<AttributeData> IMethodSymbol_GetReturnTypeAttributes();
    private sealed virtual override IMethodSymbol IMethodSymbol_Construct(ITypeSymbol[] arguments);
    private sealed virtual override INamedTypeSymbol get_IMethodSymbol_AssociatedAnonymousDelegate();
    private sealed virtual override bool get_IMethodSymbolInternal_IsIterator();
    private sealed virtual override int IMethodSymbolInternal_CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSymbolVisitor visitor);
    public virtual TResult Accept(VisualBasicSymbolVisitor`1<TResult> visitor);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodSymbolExtensions : object {
    [ExtensionAttribute]
internal static bool CanBeCalledWithNoParameters(MethodSymbol method);
    [ExtensionAttribute]
internal static ParameterSymbol GetParameterSymbol(ImmutableArray`1<ParameterSymbol> parameters, ParameterSyntax parameter);
    [ExtensionAttribute]
internal static bool IsPartial(MethodSymbol method);
    [ExtensionAttribute]
internal static bool IsPartialWithoutImplementation(MethodSymbol method);
    [ExtensionAttribute]
internal static bool IsUserDefinedOperator(MethodSymbol method);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.MethodWellKnownAttributeData : CommonMethodWellKnownAttributeData {
    private bool _hasSTAThreadAttribute;
    private bool _hasMTAThreadAttribute;
    private bool _isPropertyAccessorWithDebuggerHiddenAttribute;
    internal bool HasSTAThreadAttribute { get; internal set; }
    internal bool HasMTAThreadAttribute { get; internal set; }
    internal bool IsPropertyAccessorWithDebuggerHiddenAttribute { get; internal set; }
    internal bool get_HasSTAThreadAttribute();
    internal void set_HasSTAThreadAttribute(bool value);
    internal bool get_HasMTAThreadAttribute();
    internal void set_HasMTAThreadAttribute(bool value);
    internal bool get_IsPropertyAccessorWithDebuggerHiddenAttribute();
    internal void set_IsPropertyAccessorWithDebuggerHiddenAttribute(bool value);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingAssemblySymbol : AssemblySymbol {
    protected AssemblyIdentity m_Identity;
    protected MissingModuleSymbol m_ModuleSymbol;
    private ImmutableArray`1<ModuleSymbol> _lazyModules;
    internal bool IsMissing { get; }
    internal bool IsLinked { get; }
    public AssemblyIdentity Identity { get; }
    public Version AssemblyVersionPattern { get; }
    internal ImmutableArray`1<byte> PublicKey { get; }
    public ImmutableArray`1<ModuleSymbol> Modules { get; }
    public NamespaceSymbol GlobalNamespace { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ICollection`1<string> TypeNames { get; }
    public ICollection`1<string> NamespaceNames { get; }
    public bool MightContainExtensionMethods { get; }
    public MissingAssemblySymbol(AssemblyIdentity identity);
    internal sealed virtual bool get_IsMissing();
    internal virtual bool get_IsLinked();
    internal virtual Symbol GetDeclaredSpecialTypeMember(SpecialMember member);
    public virtual AssemblyIdentity get_Identity();
    public virtual Version get_AssemblyVersionPattern();
    internal virtual ImmutableArray`1<byte> get_PublicKey();
    public virtual ImmutableArray`1<ModuleSymbol> get_Modules();
    public sealed virtual NamespaceSymbol get_GlobalNamespace();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(MissingAssemblySymbol other);
    public virtual ImmutableArray`1<Location> get_Locations();
    internal virtual void SetLinkedReferencedAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal virtual ImmutableArray`1<AssemblySymbol> GetLinkedReferencedAssemblies();
    internal virtual void SetNoPiaResolutionAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal virtual ImmutableArray`1<AssemblySymbol> GetNoPiaResolutionAssemblies();
    internal virtual IEnumerable`1<ImmutableArray`1<byte>> GetInternalsVisibleToPublicKeys(string simpleName);
    public virtual ICollection`1<string> get_TypeNames();
    public virtual ICollection`1<string> get_NamespaceNames();
    internal virtual bool AreInternalsVisibleToThisAssembly(AssemblySymbol other);
    internal virtual NamedTypeSymbol LookupTopLevelMetadataTypeWithCycleDetection(MetadataTypeName& emittedName, ConsList`1<AssemblySymbol> visitedAssemblies, bool digThroughForwardedTypes);
    internal virtual NamedTypeSymbol GetDeclaredSpecialType(SpecialType type);
    public sealed virtual bool get_MightContainExtensionMethods();
    public virtual AssemblyMetadata GetMetadata();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingCorLibrarySymbol : MissingAssemblySymbol {
    internal static MissingCorLibrarySymbol Instance;
    private NamedTypeSymbol[] _lazySpecialTypes;
    private static MissingCorLibrarySymbol();
    internal virtual NamedTypeSymbol GetDeclaredSpecialType(SpecialType type);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingMetadataTypeSymbol : InstanceErrorTypeSymbol {
    protected string m_Name;
    protected bool m_MangleName;
    public string Name { get; }
    internal bool MangleName { get; }
    internal DiagnosticInfo ErrorInfo { get; }
    private MissingMetadataTypeSymbol(string name, int arity, bool mangleName);
    public virtual string get_Name();
    internal virtual bool get_MangleName();
    internal virtual DiagnosticInfo get_ErrorInfo();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingModuleSymbol : ModuleSymbol {
    protected AssemblySymbol m_Assembly;
    protected int m_Ordinal;
    protected MissingNamespaceSymbol m_GlobalNamespace;
    internal int Ordinal { get; }
    internal Machine Machine { get; }
    internal bool Bit32Required { get; }
    public string Name { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public Symbol ContainingSymbol { get; }
    public NamespaceSymbol GlobalNamespace { get; }
    public ImmutableArray`1<Location> Locations { get; }
    internal ICollection`1<string> NamespaceNames { get; }
    internal ICollection`1<string> TypeNames { get; }
    internal bool IsMissing { get; }
    internal bool HasUnifiedReferences { get; }
    internal bool MightContainExtensionMethods { get; }
    internal bool HasAssemblyCompilationRelaxationsAttribute { get; }
    internal bool HasAssemblyRuntimeCompatibilityAttribute { get; }
    internal Nullable`1<CharSet> DefaultMarshallingCharSet { get; }
    public MissingModuleSymbol(AssemblySymbol assembly, int ordinal);
    internal virtual int get_Ordinal();
    internal virtual Machine get_Machine();
    internal virtual bool get_Bit32Required();
    public virtual string get_Name();
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamespaceSymbol get_GlobalNamespace();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual ImmutableArray`1<Location> get_Locations();
    internal virtual ICollection`1<string> get_NamespaceNames();
    internal virtual ICollection`1<string> get_TypeNames();
    internal sealed virtual bool get_IsMissing();
    internal virtual NamedTypeSymbol LookupTopLevelMetadataType(MetadataTypeName& emittedName);
    internal virtual ImmutableArray`1<AssemblyIdentity> GetReferencedAssemblies();
    internal virtual ImmutableArray`1<AssemblySymbol> GetReferencedAssemblySymbols();
    internal virtual void SetReferences(ModuleReferences`1<AssemblySymbol> moduleReferences, SourceAssemblySymbol originatingSourceAssemblyDebugOnly);
    internal virtual bool get_HasUnifiedReferences();
    internal virtual DiagnosticInfo GetUnificationUseSiteErrorInfo(TypeSymbol dependentType);
    internal sealed virtual bool get_MightContainExtensionMethods();
    internal virtual bool get_HasAssemblyCompilationRelaxationsAttribute();
    internal virtual bool get_HasAssemblyRuntimeCompatibilityAttribute();
    internal virtual Nullable`1<CharSet> get_DefaultMarshallingCharSet();
    public virtual ModuleMetadata GetMetadata();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingModuleSymbolWithName : MissingModuleSymbol {
    private string _name;
    public string Name { get; }
    public MissingModuleSymbolWithName(AssemblySymbol assembly, string name);
    public virtual string get_Name();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.MissingNamespaceSymbol : NamespaceSymbol {
    private string _name;
    private Symbol _containingSymbol;
    public string Name { get; }
    public Symbol ContainingSymbol { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal NamespaceExtent Extent { get; }
    public ModuleSymbol ContainingModule { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal Accessibility DeclaredAccessibilityOfMostAccessibleDescendantType { get; }
    internal ImmutableArray`1<NamedTypeSymbol> TypesToCheckForExtensionMethods { get; }
    public MissingNamespaceSymbol(MissingModuleSymbol containingModule);
    public MissingNamespaceSymbol(NamespaceSymbol containingNamespace, string name);
    public virtual string get_Name();
    public virtual Symbol get_ContainingSymbol();
    public virtual AssemblySymbol get_ContainingAssembly();
    internal virtual NamespaceExtent get_Extent();
    public virtual ModuleSymbol get_ContainingModule();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetModuleMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetModuleMembers(string name);
    public virtual ImmutableArray`1<Symbol> GetMembers();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    internal virtual Accessibility get_DeclaredAccessibilityOfMostAccessibleDescendantType();
    internal virtual void AppendProbableExtensionMethods(string name, ArrayBuilder`1<MethodSymbol> methods);
    internal virtual void AddExtensionMethodLookupSymbolsInfo(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder, NamespaceSymbol appendThrough);
    internal virtual ImmutableArray`1<NamedTypeSymbol> get_TypesToCheckForExtensionMethods();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.ModuleSymbol : Symbol {
    internal int Ordinal { get; }
    internal Machine Machine { get; }
    internal bool Bit32Required { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public NamespaceSymbol GlobalNamespace { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public ModuleSymbol ContainingModule { get; }
    public SymbolKind Kind { get; }
    public ImmutableArray`1<AssemblyIdentity> ReferencedAssemblies { get; }
    public ImmutableArray`1<AssemblySymbol> ReferencedAssemblySymbols { get; }
    internal bool HasUnifiedReferences { get; }
    internal ICollection`1<string> TypeNames { get; }
    internal ICollection`1<string> NamespaceNames { get; }
    internal bool HasAssemblyCompilationRelaxationsAttribute { get; }
    internal bool HasAssemblyRuntimeCompatibilityAttribute { get; }
    internal Nullable`1<CharSet> DefaultMarshallingCharSet { get; }
    internal bool IsMissing { get; }
    internal bool MightContainExtensionMethods { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    private INamespaceSymbol IModuleSymbol_GlobalNamespace { get; }
    private ImmutableArray`1<IAssemblySymbol> IModuleSymbol_ReferencedAssemblySymbols { get; }
    internal abstract virtual int get_Ordinal();
    internal abstract virtual Machine get_Machine();
    internal abstract virtual bool get_Bit32Required();
    public sealed virtual Accessibility get_DeclaredAccessibility();
    public sealed virtual bool get_IsMustOverride();
    public sealed virtual bool get_IsNotOverridable();
    public sealed virtual bool get_IsOverridable();
    public sealed virtual bool get_IsOverrides();
    public sealed virtual bool get_IsShared();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public abstract virtual NamespaceSymbol get_GlobalNamespace();
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual ModuleSymbol get_ContainingModule();
    public sealed virtual SymbolKind get_Kind();
    internal virtual TResult Accept(VisualBasicSymbolVisitor`2<TArgument, TResult> visitor, TArgument arg);
    public sealed virtual override ImmutableArray`1<AssemblyIdentity> get_ReferencedAssemblies();
    public abstract virtual override ModuleMetadata GetMetadata();
    internal abstract virtual ImmutableArray`1<AssemblyIdentity> GetReferencedAssemblies();
    public ImmutableArray`1<AssemblySymbol> get_ReferencedAssemblySymbols();
    internal abstract virtual ImmutableArray`1<AssemblySymbol> GetReferencedAssemblySymbols();
    internal abstract virtual void SetReferences(ModuleReferences`1<AssemblySymbol> moduleReferences, SourceAssemblySymbol originatingSourceAssemblyDebugOnly);
    internal abstract virtual bool get_HasUnifiedReferences();
    internal abstract virtual DiagnosticInfo GetUnificationUseSiteErrorInfo(TypeSymbol dependentType);
    internal abstract virtual NamedTypeSymbol LookupTopLevelMetadataType(MetadataTypeName& emittedName);
    internal abstract virtual ICollection`1<string> get_TypeNames();
    internal abstract virtual ICollection`1<string> get_NamespaceNames();
    internal abstract virtual bool get_HasAssemblyCompilationRelaxationsAttribute();
    internal abstract virtual bool get_HasAssemblyRuntimeCompatibilityAttribute();
    internal abstract virtual Nullable`1<CharSet> get_DefaultMarshallingCharSet();
    internal virtual ImmutableArray`1<byte> GetHash(AssemblyHashAlgorithm algorithmId);
    public NamespaceSymbol GetModuleNamespace(INamespaceSymbol namespaceSymbol);
    internal abstract virtual bool get_IsMissing();
    internal abstract virtual bool get_MightContainExtensionMethods();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    private sealed virtual override INamespaceSymbol get_IModuleSymbol_GlobalNamespace();
    private sealed virtual override INamespaceSymbol IModuleSymbol_GetModuleNamespace(INamespaceSymbol namespaceSymbol);
    private sealed virtual override ImmutableArray`1<IAssemblySymbol> get_IModuleSymbol_ReferencedAssemblySymbols();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSymbolVisitor visitor);
    public virtual TResult Accept(VisualBasicSymbolVisitor`1<TResult> visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol : TypeSymbol {
    private NamedTypeSymbol _lazyDeclaredBase;
    private ImmutableArray`1<NamedTypeSymbol> _lazyDeclaredInterfaces;
    private NamedTypeSymbol _lazyBaseType;
    private ImmutableArray`1<NamedTypeSymbol> _lazyInterfaces;
    private bool ITypeReferenceIsEnum { get; }
    private bool ITypeReferenceIsValueType { get; }
    private TypeDefinitionHandle ITypeReferenceTypeDef { get; }
    private IGenericMethodParameterReference ITypeReferenceAsGenericMethodParameterReference { get; }
    private IGenericTypeInstanceReference ITypeReferenceAsGenericTypeInstanceReference { get; }
    private IGenericTypeParameterReference ITypeReferenceAsGenericTypeParameterReference { get; }
    private INamespaceTypeReference ITypeReferenceAsNamespaceTypeReference { get; }
    private INestedTypeReference ITypeReferenceAsNestedTypeReference { get; }
    private ISpecializedNestedTypeReference ITypeReferenceAsSpecializedNestedTypeReference { get; }
    private ushort ITypeDefinitionAlignment { get; }
    private IEnumerable`1<IEventDefinition> ITypeDefinitionEvents { get; }
    private IEnumerable`1<IGenericTypeParameter> ITypeDefinitionGenericParameters { get; }
    private ushort ITypeDefinitionGenericParameterCount { get; }
    private ushort GenericParameterCountImpl { get; }
    private bool ITypeDefinitionHasDeclarativeSecurity { get; }
    private bool ITypeDefinitionIsAbstract { get; }
    internal bool IsMetadataAbstract { get; }
    private bool ITypeDefinitionIsBeforeFieldInit { get; }
    private bool ITypeDefinitionIsComObject { get; }
    private bool ITypeDefinitionIsGeneric { get; }
    private bool ITypeDefinitionIsInterface { get; }
    private bool ITypeDefinitionIsRuntimeSpecial { get; }
    private bool ITypeDefinitionIsSerializable { get; }
    private bool ITypeDefinitionIsSpecialName { get; }
    private bool ITypeDefinitionIsWindowsRuntimeImport { get; }
    private bool ITypeDefinitionIsSealed { get; }
    internal bool IsMetadataSealed { get; }
    private LayoutKind ITypeDefinitionLayout { get; }
    private IEnumerable`1<SecurityAttribute> ITypeDefinitionSecurityAttributes { get; }
    private UInt32 ITypeDefinitionSizeOf { get; }
    private CharSet ITypeDefinitionStringFormat { get; }
    private ushort INamedTypeReferenceGenericParameterCount { get; }
    private bool INamedTypeReferenceMangleName { get; }
    private string INamedEntityName { get; }
    private string INamespaceTypeReferenceNamespaceName { get; }
    private bool INamespaceTypeDefinitionIsPublic { get; }
    private ITypeDefinition ITypeDefinitionMemberContainingTypeDefinition { get; }
    private TypeMemberVisibility ITypeDefinitionMemberVisibility { get; }
    private INamedTypeReference IGenericTypeInstanceReferenceGenericType { get; }
    private INamedTypeReference GenericTypeImpl { get; }
    private INestedTypeReference ISpecializedNestedTypeReferenceUnspecializedVersion { get; }
    public int Arity { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    internal ImmutableArray`1<ImmutableArray`1<CustomModifier>> TypeArgumentsCustomModifiers { get; }
    internal bool HasTypeArgumentsCustomModifiers { get; }
    internal ImmutableArray`1<TypeSymbol> TypeArgumentsNoUseSiteDiagnostics { get; }
    public NamedTypeSymbol ConstructedFrom { get; }
    public NamedTypeSymbol EnumUnderlyingType { get; }
    public NamedTypeSymbol ContainingType { get; }
    public Symbol AssociatedSymbol { get; }
    internal bool KnownCircularStruct { get; }
    internal bool IsExplicitDefinitionOfNoPiaLocalType { get; }
    public string MetadataName { get; }
    internal bool MangleName { get; }
    internal bool HasSpecialName { get; }
    internal bool IsSerializable { get; }
    internal TypeLayout Layout { get; }
    protected CharSet DefaultMarshallingCharSet { get; }
    internal CharSet MarshallingCharSet { get; }
    public MethodSymbol DelegateInvokeMethod { get; }
    public bool IsMustInherit { get; }
    public bool IsNotInheritable { get; }
    public bool MightContainExtensionMethods { get; }
    internal bool HasEmbeddedAttribute { get; }
    internal bool IsExtensibleInterfaceNoUseSiteDiagnostics { get; }
    public ImmutableArray`1<MethodSymbol> InstanceConstructors { get; }
    public ImmutableArray`1<MethodSymbol> SharedConstructors { get; }
    public ImmutableArray`1<MethodSymbol> Constructors { get; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    internal bool CanConstruct { get; }
    internal string DefaultPropertyName { get; }
    internal TypeSubstitution TypeSubstitution { get; }
    public string Name { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public bool IsScriptClass { get; }
    public bool IsSubmissionClass { get; }
    public bool IsImplicitClass { get; }
    public Accessibility DeclaredAccessibility { get; }
    public SymbolKind Kind { get; }
    internal bool IsComImport { get; }
    internal TypeSymbol CoClassType { get; }
    internal bool IsConditional { get; }
    internal bool AreMembersImplicitlyDeclared { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    internal ImmutableArray`1<NamedTypeSymbol> InterfacesNoUseSiteDiagnostics { get; }
    public bool IsGenericType { get; }
    public NamedTypeSymbol OriginalDefinition { get; }
    protected TypeSymbol OriginalTypeSymbolDefinition { get; }
    public bool IsUnboundGenericType { get; }
    internal bool IsWindowsRuntimeImport { get; }
    internal bool ShouldAddWinRTMembers { get; }
    internal bool IsInterface { get; }
    private int INamedTypeSymbol_Arity { get; }
    private INamedTypeSymbol INamedTypeSymbol_ConstructedFrom { get; }
    private IMethodSymbol INamedTypeSymbol_DelegateInvokeMethod { get; }
    private INamedTypeSymbol INamedTypeSymbol_EnumUnderlyingType { get; }
    private IEnumerable`1<string> INamedTypeSymbol_MemberNames { get; }
    private bool INamedTypeSymbol_IsUnboundGenericType { get; }
    private INamedTypeSymbol INamedTypeSymbol_OriginalDefinition { get; }
    private ImmutableArray`1<ITypeSymbol> INamedTypeSymbol_TypeArguments { get; }
    private ImmutableArray`1<ITypeParameterSymbol> INamedTypeSymbol_TypeParameters { get; }
    private bool INamedTypeSymbol_IsScriptClass { get; }
    private bool INamedTypeSymbol_IsImplicitClass { get; }
    private ImmutableArray`1<IMethodSymbol> INamedTypeSymbol_InstanceConstructors { get; }
    private ImmutableArray`1<IMethodSymbol> INamedTypeSymbol_StaticConstructors { get; }
    private ImmutableArray`1<IMethodSymbol> INamedTypeSymbol_Constructors { get; }
    private ISymbol INamedTypeSymbol_AssociatedSymbol { get; }
    protected bool ISymbol_IsAbstract { get; }
    protected bool ISymbol_IsSealed { get; }
    private sealed virtual override bool get_ITypeReferenceIsEnum();
    private sealed virtual override bool get_ITypeReferenceIsValueType();
    private sealed virtual override ITypeDefinition ITypeReferenceGetResolvedType(EmitContext context);
    private sealed virtual override PrimitiveTypeCode ITypeReferenceTypeCode(EmitContext context);
    private sealed virtual override TypeDefinitionHandle get_ITypeReferenceTypeDef();
    private sealed virtual override IGenericMethodParameterReference get_ITypeReferenceAsGenericMethodParameterReference();
    private sealed virtual override IGenericTypeInstanceReference get_ITypeReferenceAsGenericTypeInstanceReference();
    private sealed virtual override IGenericTypeParameterReference get_ITypeReferenceAsGenericTypeParameterReference();
    private sealed virtual override INamespaceTypeReference get_ITypeReferenceAsNamespaceTypeReference();
    private sealed virtual override INamespaceTypeDefinition ITypeReferenceAsNamespaceTypeDefinition(EmitContext context);
    private sealed virtual override INestedTypeReference get_ITypeReferenceAsNestedTypeReference();
    private sealed virtual override INestedTypeDefinition ITypeReferenceAsNestedTypeDefinition(EmitContext context);
    private INestedTypeDefinition AsNestedTypeDefinitionImpl(PEModuleBuilder moduleBeingBuilt);
    private sealed virtual override ISpecializedNestedTypeReference get_ITypeReferenceAsSpecializedNestedTypeReference();
    private sealed virtual override ITypeDefinition ITypeReferenceAsTypeDefinition(EmitContext context);
    private ITypeDefinition AsTypeDefinitionImpl(PEModuleBuilder moduleBeingBuilt);
    internal sealed virtual void IReferenceDispatch(MetadataVisitor visitor);
    internal sealed virtual IDefinition IReferenceAsDefinition(EmitContext context);
    private sealed virtual override ushort get_ITypeDefinitionAlignment();
    private sealed virtual override ITypeReference ITypeDefinitionGetBaseClass(EmitContext context);
    private sealed virtual override IEnumerable`1<IEventDefinition> get_ITypeDefinitionEvents();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol/VB$StateMachine_32_GetEventsToEmit")]
internal virtual IEnumerable`1<EventSymbol> GetEventsToEmit();
    private sealed virtual override IEnumerable`1<MethodImplementation> ITypeDefinitionGetExplicitImplementationOverrides(EmitContext context);
    private void AddExplicitImplementations(EmitContext context, MethodSymbol implementingMethod, ArrayBuilder`1<MethodImplementation> explicitImplements, SourceNamedTypeSymbol sourceNamedType, PEModuleBuilder moduleBeingBuilt);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol/VB$StateMachine_35_ITypeDefinitionGetFields")]
private sealed virtual override IEnumerable`1<IFieldDefinition> ITypeDefinitionGetFields(EmitContext context);
    internal abstract virtual IEnumerable`1<FieldSymbol> GetFieldsToEmit();
    private sealed virtual override IEnumerable`1<IGenericTypeParameter> get_ITypeDefinitionGenericParameters();
    private sealed virtual override ushort get_ITypeDefinitionGenericParameterCount();
    private ushort get_GenericParameterCountImpl();
    private sealed virtual override bool get_ITypeDefinitionHasDeclarativeSecurity();
    internal virtual IEnumerable`1<NamedTypeSymbol> GetSynthesizedImplements();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol/VB$StateMachine_46_ITypeDefinitionInterfaces")]
private sealed virtual override IEnumerable`1<ITypeReference> ITypeDefinitionInterfaces(EmitContext context);
    internal virtual IEnumerable`1<NamedTypeSymbol> GetInterfacesToEmit();
    private sealed virtual override bool get_ITypeDefinitionIsAbstract();
    internal virtual bool get_IsMetadataAbstract();
    private sealed virtual override bool get_ITypeDefinitionIsBeforeFieldInit();
    private sealed virtual override bool get_ITypeDefinitionIsComObject();
    private sealed virtual override bool get_ITypeDefinitionIsGeneric();
    private sealed virtual override bool get_ITypeDefinitionIsInterface();
    private sealed virtual override bool get_ITypeDefinitionIsRuntimeSpecial();
    private sealed virtual override bool get_ITypeDefinitionIsSerializable();
    private sealed virtual override bool get_ITypeDefinitionIsSpecialName();
    private sealed virtual override bool get_ITypeDefinitionIsWindowsRuntimeImport();
    private sealed virtual override bool get_ITypeDefinitionIsSealed();
    internal virtual bool get_IsMetadataSealed();
    private sealed virtual override LayoutKind get_ITypeDefinitionLayout();
    internal virtual ImmutableArray`1<Symbol> GetMembersForCci();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol/VB$StateMachine_75_ITypeDefinitionGetMethods")]
private sealed virtual override IEnumerable`1<IMethodDefinition> ITypeDefinitionGetMethods(EmitContext context);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol/VB$StateMachine_76_GetMethodsToEmit")]
internal virtual IEnumerable`1<MethodSymbol> GetMethodsToEmit();
    private sealed virtual override IEnumerable`1<INestedTypeDefinition> ITypeDefinitionGetNestedTypes(EmitContext context);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol/VB$StateMachine_78_ITypeDefinitionGetProperties")]
private sealed virtual override IEnumerable`1<IPropertyDefinition> ITypeDefinitionGetProperties(EmitContext context);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbol/VB$StateMachine_79_GetPropertiesToEmit")]
internal virtual IEnumerable`1<PropertySymbol> GetPropertiesToEmit();
    private sealed virtual override IEnumerable`1<SecurityAttribute> get_ITypeDefinitionSecurityAttributes();
    private sealed virtual override UInt32 get_ITypeDefinitionSizeOf();
    private sealed virtual override CharSet get_ITypeDefinitionStringFormat();
    private sealed virtual override ushort get_INamedTypeReferenceGenericParameterCount();
    private sealed virtual override bool get_INamedTypeReferenceMangleName();
    private sealed virtual override string get_INamedEntityName();
    private sealed virtual override IUnitReference INamespaceTypeReferenceGetUnit(EmitContext context);
    private sealed virtual override string get_INamespaceTypeReferenceNamespaceName();
    private sealed virtual override bool get_INamespaceTypeDefinitionIsPublic();
    private sealed virtual override ITypeReference ITypeMemberReferenceGetContainingType(EmitContext context);
    private sealed virtual override ITypeDefinition get_ITypeDefinitionMemberContainingTypeDefinition();
    private sealed virtual override TypeMemberVisibility get_ITypeDefinitionMemberVisibility();
    private sealed virtual override ImmutableArray`1<ITypeReference> IGenericTypeInstanceReferenceGetGenericArguments(EmitContext context);
    private sealed virtual override INamedTypeReference get_IGenericTypeInstanceReferenceGenericType();
    private INamedTypeReference get_GenericTypeImpl();
    private sealed virtual override INestedTypeReference get_ISpecializedNestedTypeReferenceUnspecializedVersion();
    public abstract virtual int get_Arity();
    public abstract virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public ImmutableArray`1<TypeSymbol> get_TypeArguments();
    internal abstract virtual ImmutableArray`1<ImmutableArray`1<CustomModifier>> get_TypeArgumentsCustomModifiers();
    internal ImmutableArray`1<ImmutableArray`1<CustomModifier>> CreateEmptyTypeArgumentsCustomModifiers();
    internal static ImmutableArray`1<ImmutableArray`1<CustomModifier>> CreateEmptyTypeArgumentsCustomModifiers(int arity);
    internal abstract virtual bool get_HasTypeArgumentsCustomModifiers();
    internal abstract virtual ImmutableArray`1<TypeSymbol> get_TypeArgumentsNoUseSiteDiagnostics();
    internal ImmutableArray`1<TypeSymbol> TypeArgumentsWithDefinitionUseSiteDiagnostics(HashSet`1& useSiteDiagnostics);
    internal TypeSymbol TypeArgumentWithDefinitionUseSiteDiagnostics(int index, HashSet`1& useSiteDiagnostics);
    public abstract virtual NamedTypeSymbol get_ConstructedFrom();
    public virtual NamedTypeSymbol get_EnumUnderlyingType();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual Symbol get_AssociatedSymbol();
    internal virtual bool get_KnownCircularStruct();
    internal virtual bool get_IsExplicitDefinitionOfNoPiaLocalType();
    internal virtual bool GetGuidString(String& guidString);
    public virtual string get_MetadataName();
    internal abstract virtual bool get_MangleName();
    internal abstract virtual bool get_HasSpecialName();
    internal abstract virtual bool get_IsSerializable();
    internal abstract virtual TypeLayout get_Layout();
    protected CharSet get_DefaultMarshallingCharSet();
    internal abstract virtual CharSet get_MarshallingCharSet();
    public virtual MethodSymbol get_DelegateInvokeMethod();
    public abstract virtual bool get_IsMustInherit();
    public abstract virtual bool get_IsNotInheritable();
    public abstract virtual override bool get_MightContainExtensionMethods();
    internal abstract virtual bool get_HasEmbeddedAttribute();
    internal abstract virtual bool get_IsExtensibleInterfaceNoUseSiteDiagnostics();
    internal virtual void AppendProbableExtensionMethods(string name, ArrayBuilder`1<MethodSymbol> methods);
    internal virtual void BuildExtensionMethodsMap(Dictionary`2<string, ArrayBuilder`1<MethodSymbol>> map, NamespaceSymbol appendThrough);
    internal virtual void GetExtensionMethods(ArrayBuilder`1<MethodSymbol> methods, NamespaceSymbol appendThrough, string Name);
    internal virtual void AddExtensionMethodLookupSymbolsInfo(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
    internal virtual void AddExtensionMethodLookupSymbolsInfo(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder, NamedTypeSymbol appendThrough);
    public ImmutableArray`1<MethodSymbol> get_InstanceConstructors();
    public ImmutableArray`1<MethodSymbol> get_SharedConstructors();
    public ImmutableArray`1<MethodSymbol> get_Constructors();
    private ImmutableArray`1<TMethodSymbol> GetConstructors(bool includeInstance, bool includeShared);
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsValueType();
    internal abstract virtual bool get_CanConstruct();
    public NamedTypeSymbol Construct(TypeSymbol[] typeArguments);
    public NamedTypeSymbol Construct(IEnumerable`1<TypeSymbol> typeArguments);
    public abstract virtual NamedTypeSymbol Construct(ImmutableArray`1<TypeSymbol> typeArguments);
    protected void CheckCanConstructAndTypeArguments(ImmutableArray`1<TypeSymbol> typeArguments);
    internal NamedTypeSymbol Construct(TypeSubstitution substitution);
    public NamedTypeSymbol ConstructUnboundGenericType();
    internal abstract virtual string get_DefaultPropertyName();
    internal abstract virtual TypeSubstitution get_TypeSubstitution();
    public abstract virtual string get_Name();
    public abstract virtual IEnumerable`1<string> get_MemberNames();
    public virtual bool get_IsScriptClass();
    public bool get_IsSubmissionClass();
    internal SynthesizedConstructorBase GetScriptConstructor();
    internal SynthesizedInteractiveInitializerMethod GetScriptInitializer();
    internal SynthesizedEntryPointSymbol GetScriptEntryPoint();
    public virtual bool get_IsImplicitClass();
    public abstract virtual ImmutableArray`1<Symbol> GetMembers();
    public abstract virtual ImmutableArray`1<Symbol> GetMembers(string name);
    public abstract virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public abstract virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public abstract virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public abstract virtual Accessibility get_DeclaredAccessibility();
    internal virtual TResult Accept(VisualBasicSymbolVisitor`2<TArgument, TResult> visitor, TArgument arg);
    public virtual SymbolKind get_Kind();
    internal abstract virtual bool get_IsComImport();
    internal abstract virtual TypeSymbol get_CoClassType();
    internal abstract virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal bool get_IsConditional();
    internal virtual bool get_AreMembersImplicitlyDeclared();
    internal abstract virtual AttributeUsageInfo GetAttributeUsageInfo();
    internal abstract virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal abstract virtual bool get_HasDeclarativeSecurity();
    internal abstract virtual NamedTypeSymbol MakeDeclaredBase(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    internal abstract virtual ImmutableArray`1<NamedTypeSymbol> MakeDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    internal virtual NamedTypeSymbol GetDeclaredBase(ConsList`1<Symbol> basesBeingResolved);
    internal virtual ImmutableArray`1<Symbol> GetSimpleNonTypeMembers(string name);
    private void AtomicStoreReferenceAndDiagnostics(T& variable, T value, DiagnosticBag diagBag, T comparand);
    internal void AtomicStoreArrayAndDiagnostics(ImmutableArray`1& variable, ImmutableArray`1<T> value, DiagnosticBag diagBag);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetDeclaredInterfacesNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
    internal ImmutableArray`1<NamedTypeSymbol> GetDeclaredInterfacesWithDefinitionUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved, HashSet`1& useSiteDiagnostics);
    internal ImmutableArray`1<NamedTypeSymbol> GetDirectBaseInterfacesNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetDeclaredBaseInterfacesSafe(ConsList`1<Symbol> basesBeingResolved);
    internal abstract virtual NamedTypeSymbol MakeAcyclicBaseType(DiagnosticBag diagnostics);
    internal abstract virtual ImmutableArray`1<NamedTypeSymbol> MakeAcyclicInterfaces(DiagnosticBag diagnostics);
    internal sealed virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
    internal sealed virtual ImmutableArray`1<NamedTypeSymbol> get_InterfacesNoUseSiteDiagnostics();
    internal NamedTypeSymbol GetBestKnownBaseType();
    internal ImmutableArray`1<NamedTypeSymbol> GetBestKnownInterfacesNoUseSiteDiagnostics();
    public sealed virtual override bool get_IsGenericType();
    public virtual NamedTypeSymbol get_OriginalDefinition();
    protected sealed virtual TypeSymbol get_OriginalTypeSymbolDefinition();
    internal virtual string GetEmittedNamespaceName();
    internal bool ImplementsAllMembersOfInterface(NamedTypeSymbol iface);
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    private DiagnosticInfo DeriveUseSiteErrorInfoFromTypeArguments();
    public virtual bool get_IsUnboundGenericType();
    internal abstract virtual void GenerateDeclarationErrors(CancellationToken cancellationToken);
    internal virtual IEnumerable`1<INestedTypeDefinition> GetSynthesizedNestedTypes();
    internal abstract virtual bool get_IsWindowsRuntimeImport();
    internal abstract virtual bool get_ShouldAddWinRTMembers();
    internal abstract virtual bool get_IsInterface();
    private sealed virtual override int get_INamedTypeSymbol_Arity();
    private sealed virtual override INamedTypeSymbol get_INamedTypeSymbol_ConstructedFrom();
    private sealed virtual override IMethodSymbol get_INamedTypeSymbol_DelegateInvokeMethod();
    private sealed virtual override INamedTypeSymbol get_INamedTypeSymbol_EnumUnderlyingType();
    private sealed virtual override IEnumerable`1<string> get_INamedTypeSymbol_MemberNames();
    private sealed virtual override bool get_INamedTypeSymbol_IsUnboundGenericType();
    private sealed virtual override INamedTypeSymbol get_INamedTypeSymbol_OriginalDefinition();
    private sealed virtual override ImmutableArray`1<ITypeSymbol> get_INamedTypeSymbol_TypeArguments();
    private sealed virtual override ImmutableArray`1<ITypeParameterSymbol> get_INamedTypeSymbol_TypeParameters();
    private sealed virtual override bool get_INamedTypeSymbol_IsScriptClass();
    private sealed virtual override bool get_INamedTypeSymbol_IsImplicitClass();
    private sealed virtual override INamedTypeSymbol INamedTypeSymbol_Construct(ITypeSymbol[] arguments);
    private sealed virtual override INamedTypeSymbol INamedTypeSymbol_ConstructUnboundGenericType();
    private sealed virtual override ImmutableArray`1<IMethodSymbol> get_INamedTypeSymbol_InstanceConstructors();
    private sealed virtual override ImmutableArray`1<IMethodSymbol> get_INamedTypeSymbol_StaticConstructors();
    private sealed virtual override ImmutableArray`1<IMethodSymbol> get_INamedTypeSymbol_Constructors();
    private sealed virtual override ISymbol get_INamedTypeSymbol_AssociatedSymbol();
    protected virtual bool get_ISymbol_IsAbstract();
    protected virtual bool get_ISymbol_IsSealed();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSymbolVisitor visitor);
    public virtual TResult Accept(VisualBasicSymbolVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
private KeyValuePair`2<string, ImmutableArray`1<Symbol>> _Lambda$__165-0(string name);
    [CompilerGeneratedAttribute]
private KeyValuePair`2<string, ImmutableArray`1<Symbol>> _Lambda$__168-0(string name);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.NamedTypeSymbolExtensions : object {
    [ExtensionAttribute]
internal static bool IsOrInGenericType(NamedTypeSymbol toCheck);
    [ExtensionAttribute]
internal static Symbol FindMember(NamedTypeSymbol container, string symbolName, SymbolKind kind, TextSpan nameSpan, SyntaxTree tree);
    [ExtensionAttribute]
internal static Symbol FindFieldOrProperty(NamedTypeSymbol container, string symbolName, TextSpan nameSpan, SyntaxTree tree);
    [ExtensionAttribute]
public static NamedTypeSymbol AsUnboundGenericType(NamedTypeSymbol this);
    [ExtensionAttribute]
internal static bool HasVariance(NamedTypeSymbol this);
    [ExtensionAttribute]
internal static bool HaveVariance(ImmutableArray`1<TypeParameterSymbol> this);
    [ExtensionAttribute]
internal static bool AllowsExtensionMethods(NamedTypeSymbol container);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceExtent : ValueType {
    private NamespaceKind _kind;
    private object _symbolOrCompilation;
    public NamespaceKind Kind { get; }
    public ModuleSymbol Module { get; }
    public AssemblySymbol Assembly { get; }
    public VisualBasicCompilation Compilation { get; }
    internal NamespaceExtent(ModuleSymbol module);
    internal NamespaceExtent(AssemblySymbol assembly);
    internal NamespaceExtent(VisualBasicCompilation compilation);
    public NamespaceKind get_Kind();
    public ModuleSymbol get_Module();
    public AssemblySymbol get_Assembly();
    public VisualBasicCompilation get_Compilation();
    public virtual string ToString();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceOrTypeSymbol : Symbol {
    public bool IsNamespace { get; }
    public bool IsType { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public sealed virtual override bool get_IsNamespace();
    public sealed virtual override bool get_IsType();
    public abstract virtual ImmutableArray`1<Symbol> GetMembers();
    internal virtual ImmutableArray`1<Symbol> GetMembersUnordered();
    public abstract virtual ImmutableArray`1<Symbol> GetMembers(string name);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembersUnordered();
    public abstract virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public abstract virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public sealed virtual bool get_IsMustOverride();
    public sealed virtual bool get_IsNotOverridable();
    public sealed virtual bool get_IsOverridable();
    public sealed virtual bool get_IsOverrides();
    internal bool AddExtensionMethodLookupSymbolsInfo(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder, IEnumerable`1<KeyValuePair`2<string, ImmutableArray`1<Symbol>>> membersByName);
    internal virtual bool AddExtensionMethodLookupSymbolsInfoViabilityCheck(MethodSymbol method, LookupOptions options, Binder originalBinder);
    internal IEnumerable`1<NamespaceOrTypeSymbol> GetNamespaceOrTypeByQualifiedName(IEnumerable`1<string> qualifiedName);
    private sealed virtual override ImmutableArray`1<ISymbol> INamespaceOrTypeSymbol_GetMembers();
    private sealed virtual override ImmutableArray`1<ISymbol> INamespaceOrTypeSymbol_GetMembers(string name);
    private sealed virtual override ImmutableArray`1<INamedTypeSymbol> INamespaceOrTypeSymbol_GetTypeMembers();
    private sealed virtual override ImmutableArray`1<INamedTypeSymbol> INamespaceOrTypeSymbol_GetTypeMembers(string name);
    public sealed virtual override ImmutableArray`1<INamedTypeSymbol> INamespaceOrTypeSymbol_GetTypeMembers(string name, int arity);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.NamespaceSymbol : NamespaceOrTypeSymbol {
    private string INamedEntity_Name { get; }
    private INamespace INamespaceSymbol_ContainingNamespace { get; }
    public bool IsGlobalNamespace { get; }
    internal NamespaceExtent Extent { get; }
    public NamespaceKind NamespaceKind { get; }
    public VisualBasicCompilation ContainingCompilation { get; }
    public ImmutableArray`1<NamespaceSymbol> ConstituentNamespaces { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public NamedTypeSymbol ContainingType { get; }
    public ModuleSymbol ContainingModule { get; }
    public SymbolKind Kind { get; }
    public bool IsImplicitlyDeclared { get; }
    public Accessibility DeclaredAccessibility { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal Accessibility DeclaredAccessibilityOfMostAccessibleDescendantType { get; }
    public bool IsShared { get; }
    internal ImmutableArray`1<NamedTypeSymbol> TypesToCheckForExtensionMethods { get; }
    private ImmutableArray`1<INamespaceSymbol> INamespaceSymbol_ConstituentNamespaces { get; }
    private NamespaceKind INamespaceSymbol_NamespaceKind { get; }
    private Compilation INamespaceSymbol_ContainingCompilation { get; }
    private sealed virtual override string get_INamedEntity_Name();
    private sealed virtual override INamespace get_INamespaceSymbol_ContainingNamespace();
    public virtual IEnumerable`1<NamespaceSymbol> GetNamespaceMembers();
    public abstract virtual ImmutableArray`1<NamedTypeSymbol> GetModuleMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetModuleMembers(string name);
    public virtual override bool get_IsGlobalNamespace();
    internal abstract virtual NamespaceExtent get_Extent();
    public NamespaceKind get_NamespaceKind();
    public VisualBasicCompilation get_ContainingCompilation();
    public virtual ImmutableArray`1<NamespaceSymbol> get_ConstituentNamespaces();
    public abstract virtual AssemblySymbol get_ContainingAssembly();
    public sealed virtual NamedTypeSymbol get_ContainingType();
    public virtual ModuleSymbol get_ContainingModule();
    public sealed virtual SymbolKind get_Kind();
    public sealed virtual bool get_IsImplicitlyDeclared();
    internal virtual TResult Accept(VisualBasicSymbolVisitor`2<TArgument, TResult> visitor, TArgument arg);
    public sealed virtual Accessibility get_DeclaredAccessibility();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal abstract virtual Accessibility get_DeclaredAccessibilityOfMostAccessibleDescendantType();
    protected virtual Accessibility GetDeclaredAccessibilityOfMostAccessibleDescendantType();
    internal virtual bool ContainsTypesAccessibleFrom(AssemblySymbol fromAssembly);
    public sealed virtual bool get_IsShared();
    internal NamespaceSymbol LookupNestedNamespace(ImmutableArray`1<string> names);
    internal NamespaceSymbol LookupNestedNamespace(String[] names);
    internal virtual NamedTypeSymbol LookupMetadataType(MetadataTypeName& fullEmittedName);
    internal virtual bool IsDefinedInSourceTree(SyntaxTree tree, Nullable`1<TextSpan> definedWithinSpan, CancellationToken cancellationToken);
    internal NamespaceSymbol GetNestedNamespace(string name);
    internal NamespaceSymbol GetNestedNamespace(NameSyntax name);
    internal virtual bool IsDeclaredInSourceModule(ModuleSymbol module);
    internal abstract virtual void AppendProbableExtensionMethods(string name, ArrayBuilder`1<MethodSymbol> methods);
    internal virtual void AddExtensionMethodLookupSymbolsInfo(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
    internal abstract virtual void AddExtensionMethodLookupSymbolsInfo(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder, NamespaceSymbol appendThrough);
    internal virtual void BuildExtensionMethodsMap(Dictionary`2<string, ArrayBuilder`1<MethodSymbol>> map);
    internal virtual void GetExtensionMethods(ArrayBuilder`1<MethodSymbol> methods, string name);
    internal abstract virtual ImmutableArray`1<NamedTypeSymbol> get_TypesToCheckForExtensionMethods();
    internal bool BuildExtensionMethodsMap(Dictionary`2<string, ArrayBuilder`1<MethodSymbol>> map, IEnumerable`1<KeyValuePair`2<string, ImmutableArray`1<Symbol>>> membersByName);
    internal void AddMemberIfExtension(ArrayBuilder`1<MethodSymbol> bucket, Symbol member);
    internal virtual void BuildExtensionMethodsMapBucket(ArrayBuilder`1<MethodSymbol> bucket, MethodSymbol method);
    private sealed virtual override IEnumerable`1<INamespaceOrTypeSymbol> INamespaceSymbol_GetMembers();
    private sealed virtual override IEnumerable`1<INamespaceOrTypeSymbol> INamespaceSymbol_GetMembers(string name);
    private sealed virtual override IEnumerable`1<INamespaceSymbol> INamespaceSymbol_GetNamespaceMembers();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSymbolVisitor visitor);
    public virtual TResult Accept(VisualBasicSymbolVisitor`1<TResult> visitor);
    private sealed virtual override ImmutableArray`1<INamespaceSymbol> get_INamespaceSymbol_ConstituentNamespaces();
    private sealed virtual override NamespaceKind get_INamespaceSymbol_NamespaceKind();
    private sealed virtual override Compilation get_INamespaceSymbol_ContainingCompilation();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.NonMissingAssemblySymbol : AssemblySymbol {
    private ConcurrentDictionary`2<Key, NamedTypeSymbol> _emittedNameToTypeMap;
    private NamespaceSymbol _lazyGlobalNamespace;
    internal bool IsMissing { get; }
    public NamespaceSymbol GlobalNamespace { get; }
    internal int EmittedNameToTypeMapCount { get; }
    internal sealed virtual bool get_IsMissing();
    public sealed virtual NamespaceSymbol get_GlobalNamespace();
    internal sealed virtual NamedTypeSymbol LookupTopLevelMetadataTypeWithCycleDetection(MetadataTypeName& emittedName, ConsList`1<AssemblySymbol> visitedAssemblies, bool digThroughForwardedTypes);
    internal abstract virtual NamedTypeSymbol TryLookupForwardedMetadataTypeWithCycleDetection(MetadataTypeName& emittedName, ConsList`1<AssemblySymbol> visitedAssemblies, bool ignoreCase);
    internal NamedTypeSymbol CachedTypeByEmittedName(string emittedname);
    internal int get_EmittedNameToTypeMapCount();
    private NamedTypeSymbol LookupTopLevelMetadataTypeInCache(MetadataTypeName& emittedName);
    private void CacheTopLevelMetadataType(MetadataTypeName& emittedName, NamedTypeSymbol result);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.NonMissingModuleSymbol : ModuleSymbol {
    private ModuleReferences`1<AssemblySymbol> _moduleReferences;
    internal bool IsMissing { get; }
    internal bool HasUnifiedReferences { get; }
    internal bool MightContainExtensionMethods { get; }
    internal sealed virtual bool get_IsMissing();
    internal sealed virtual ImmutableArray`1<AssemblyIdentity> GetReferencedAssemblies();
    internal sealed virtual ImmutableArray`1<AssemblySymbol> GetReferencedAssemblySymbols();
    internal ImmutableArray`1<UnifiedAssembly`1<AssemblySymbol>> GetUnifiedAssemblies();
    internal virtual bool get_HasUnifiedReferences();
    internal virtual DiagnosticInfo GetUnificationUseSiteErrorInfo(TypeSymbol dependentType);
    internal virtual void SetReferences(ModuleReferences`1<AssemblySymbol> moduleReferences, SourceAssemblySymbol originatingSourceAssemblyDebugOnly);
    [ConditionalAttribute("DEBUG")]
internal void AssertReferencesUninitialized();
    [ConditionalAttribute("DEBUG")]
internal void AssertReferencesInitialized();
    internal sealed virtual NamedTypeSymbol LookupTopLevelMetadataType(MetadataTypeName& emittedName);
    internal virtual bool get_MightContainExtensionMethods();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.NoPiaAmbiguousCanonicalTypeSymbol : ErrorTypeSymbol {
    private AssemblySymbol _embeddingAssembly;
    private NamedTypeSymbol _firstCandidate;
    private NamedTypeSymbol _secondCandidate;
    internal bool MangleName { get; }
    public AssemblySymbol EmbeddingAssembly { get; }
    public NamedTypeSymbol FirstCandidate { get; }
    public NamedTypeSymbol SecondCandidate { get; }
    internal DiagnosticInfo ErrorInfo { get; }
    public NoPiaAmbiguousCanonicalTypeSymbol(AssemblySymbol embeddingAssembly, NamedTypeSymbol firstCandidate, NamedTypeSymbol secondCandidate);
    internal virtual bool get_MangleName();
    public AssemblySymbol get_EmbeddingAssembly();
    public NamedTypeSymbol get_FirstCandidate();
    public NamedTypeSymbol get_SecondCandidate();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    internal virtual DiagnosticInfo get_ErrorInfo();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.NoPiaIllegalGenericInstantiationSymbol : ErrorTypeSymbol {
    private NamedTypeSymbol _underlyingSymbol;
    public NamedTypeSymbol UnderlyingSymbol { get; }
    internal bool MangleName { get; }
    internal DiagnosticInfo ErrorInfo { get; }
    public NoPiaIllegalGenericInstantiationSymbol(NamedTypeSymbol underlyingSymbol);
    public NamedTypeSymbol get_UnderlyingSymbol();
    internal virtual bool get_MangleName();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    internal virtual DiagnosticInfo get_ErrorInfo();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.NoPiaMissingCanonicalTypeSymbol : ErrorTypeSymbol {
    private AssemblySymbol _embeddingAssembly;
    private string _guid;
    private string _scope;
    private string _identifier;
    private string _fullTypeName;
    public AssemblySymbol EmbeddingAssembly { get; }
    public string FullTypeName { get; }
    public string Name { get; }
    internal bool MangleName { get; }
    public string Guid { get; }
    public string Scope { get; }
    public string Identifier { get; }
    internal DiagnosticInfo ErrorInfo { get; }
    public NoPiaMissingCanonicalTypeSymbol(AssemblySymbol embeddingAssembly, string fullTypeName, string guid, string scope, string identifier);
    public AssemblySymbol get_EmbeddingAssembly();
    public string get_FullTypeName();
    public virtual string get_Name();
    internal virtual bool get_MangleName();
    public string get_Guid();
    public string get_Scope();
    public string get_Identifier();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    internal virtual DiagnosticInfo get_ErrorInfo();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.ObsoleteAttributeHelpers : object {
    internal static void InitializeObsoleteDataFromMetadata(ObsoleteAttributeData& data, EntityHandle token, PEModuleSymbol containingModule);
    internal static ObsoleteAttributeData GetObsoleteDataFromMetadata(EntityHandle token, PEModuleSymbol containingModule);
    internal static ThreeState GetObsoleteContextState(Symbol symbol, bool forceComplete);
    internal static DiagnosticInfo CreateObsoleteDiagnostic(Symbol symbol);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.OverloadingHelper : object {
    public static void SetMetadataNameForAllOverloads(string name, SymbolKind kind, NamedTypeSymbol container);
    private static void FindOverloads(string name, SymbolKind kind, NamedTypeSymbol container, ArrayBuilder`1<Symbol> overloadsMembers, Boolean& hasOverloadSpecifier, Boolean& hasOverrideSpecifier);
    private static string SetMetadataNamesOfOverrides(ArrayBuilder`1<Symbol> overloadedMembers, VisualBasicCompilation compilation);
    private static string NameOfFirstMember(ArrayBuilder`1<Symbol> overloadedMembers, VisualBasicCompilation compilation);
    private static string GetBaseMemberMetadataName(string name, SymbolKind kind, NamedTypeSymbol container);
    private static bool IsCandidateMember(Symbol member, SymbolKind kind);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.OverriddenMembersResult`1 : object {
    public static OverriddenMembersResult`1<TSymbol> Empty;
    private ImmutableArray`1<TSymbol> _overriddenMembers;
    private ImmutableArray`1<TSymbol> _inexactOverriddenMembers;
    private ImmutableArray`1<TSymbol> _inaccessibleMembers;
    public ImmutableArray`1<TSymbol> OverriddenMembers { get; }
    public ImmutableArray`1<TSymbol> InexactOverriddenMembers { get; }
    public ImmutableArray`1<TSymbol> InaccessibleMembers { get; }
    public TSymbol OverriddenMember { get; }
    private static OverriddenMembersResult`1();
    private OverriddenMembersResult`1(ImmutableArray`1<TSymbol> overriddenMembers, ImmutableArray`1<TSymbol> inexactOverriddenMembers, ImmutableArray`1<TSymbol> inaccessibleMembers);
    public ImmutableArray`1<TSymbol> get_OverriddenMembers();
    public ImmutableArray`1<TSymbol> get_InexactOverriddenMembers();
    public ImmutableArray`1<TSymbol> get_InaccessibleMembers();
    public static OverriddenMembersResult`1<TSymbol> Create(ImmutableArray`1<TSymbol> overriddenMembers, ImmutableArray`1<TSymbol> inexactOverriddenMembers, ImmutableArray`1<TSymbol> inaccessibleMembers);
    public static TSymbol GetOverriddenMember(TSymbol substitutedOverridingMember, TSymbol overriddenByDefinitionMember);
    public TSymbol get_OverriddenMember();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.OverrideHidingHelper : object {
    public static void CheckHidingAndOverridingForType(SourceMemberContainerTypeSymbol container, DiagnosticBag diagnostics);
    public static bool SignaturesMatch(Symbol sym1, Symbol sym2, Boolean& exactMatch, Boolean& exactMatchIgnoringCustomModifiers);
    internal static SymbolComparisonResults DetailedSignatureCompare(Symbol sym1, Symbol sym2, SymbolComparisonResults comparisons, SymbolComparisonResults stopIfAny);
    private static void CheckMembersAgainstBaseType(SourceMemberContainerTypeSymbol container, DiagnosticBag diagnostics);
    private static void CheckAllAbstractsAreOverriddenAndNotHidden(NamedTypeSymbol container, DiagnosticBag diagnostics);
    private static bool DoesHide(Symbol hidingMember, Symbol hiddenMember);
    protected static void CheckShadowing(SourceMemberContainerTypeSymbol container, Symbol member, DiagnosticBag diagnostics);
    private static void CheckShadowingInBaseType(SourceMemberContainerTypeSymbol container, Symbol member, bool memberIsOverloads, NamedTypeSymbol baseType, DiagnosticBag diagnostics, Boolean& warnForHiddenMember);
    private static void ReportShadowingDiagnostic(Symbol hidingMember, Symbol hiddenMember, DiagnosticBag diagnostics);
    public static string AssociatedSymbolName(Symbol associatedSymbol);
    private static void ReportShadowingMustOverrideError(Symbol hidingMember, Symbol hiddenMember, DiagnosticBag diagnostics);
    internal static bool CanOverrideOrHide(Symbol sym);
    protected static Symbol GetOverriddenMember(Symbol sym);
    public static bool RequiresExplicitOverride(MethodSymbol method);
    private static bool RequiresExplicitOverride(PropertySymbol prop);
    private static bool RequiresExplicitOverride(EventSymbol event);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.OverrideHidingHelper`1 : OverrideHidingHelper {
    private static IEqualityComparer`1<TSymbol> s_runtimeSignatureComparer;
    private static OverrideHidingHelper`1();
    internal static OverriddenMembersResult`1<TSymbol> MakeOverriddenMembers(TSymbol overridingSym);
    private static bool FindOverriddenMembersInType(TSymbol overridingSym, bool overridingIsFromSomeCompilation, NamedTypeSymbol overridingContainingType, NamedTypeSymbol currType, ArrayBuilder`1<TSymbol> overriddenBuilder, ArrayBuilder`1<TSymbol> inexactOverriddenMembers, ArrayBuilder`1<TSymbol> inaccessibleBuilder);
    private static void AddMemberToABuilder(TSymbol member, ArrayBuilder`1<TSymbol> builder);
    internal static void CheckOverrideMember(TSymbol member, OverriddenMembersResult`1<TSymbol> overriddenMembersResult, DiagnosticBag diagnostics);
    private static void RemoveMembersWithConflictingAccessibility(ArrayBuilder`1<TSymbol> members);
    internal static void CheckOverridePropertyAccessor(MethodSymbol overridingAccessor, MethodSymbol overriddenAccessor, DiagnosticBag diagnostics);
    private static void ReportBadOverriding(ERRID id, Symbol overridingMember, Symbol overriddenMember, DiagnosticBag diagnostics);
    private static bool ConsistentAccessibility(Symbol overriding, Symbol overridden, ERRID& errorId);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterEarlyWellKnownAttributeData : CommonParameterEarlyWellKnownAttributeData {
    private bool _hasMarshalAsAttribute;
    private bool _hasParamArrayAttribute;
    internal bool HasMarshalAsAttribute { get; internal set; }
    internal bool HasParamArrayAttribute { get; internal set; }
    internal bool get_HasMarshalAsAttribute();
    internal void set_HasMarshalAsAttribute(bool value);
    internal bool get_HasParamArrayAttribute();
    internal void set_HasParamArrayAttribute(bool value);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.ParameterSymbol : Symbol {
    private ImmutableArray`1<ICustomModifier> IParameterTypeInformationCustomModifiers { get; }
    private bool IParameterTypeInformationIsByReference { get; }
    private ushort IParameterTypeInformationCountOfCustomModifiersPrecedingByRef { get; }
    private ushort IParameterListEntryIndex { get; }
    internal bool HasMetadataConstantValue { get; }
    private bool IParameterDefinition_HasDefaultValue { get; }
    private bool IParameterDefinitionIsOptional { get; }
    internal bool IsMetadataOptional { get; }
    private bool IParameterDefinitionIsIn { get; }
    private bool IParameterDefinitionIsOut { get; }
    private bool IParameterDefinitionIsMarshalledExplicitly { get; }
    internal bool IsMarshalledExplicitly { get; }
    private IMarshallingInformation IParameterDefinitionMarshallingInformation { get; }
    private ImmutableArray`1<byte> IParameterDefinitionMarshallingDescriptor { get; }
    internal ImmutableArray`1<byte> MarshallingDescriptor { get; }
    private string INamedEntityName { get; }
    public ParameterSymbol OriginalDefinition { get; }
    protected Symbol OriginalSymbolDefinition { get; }
    public bool IsByRef { get; }
    internal bool IsExplicitByRef { get; }
    internal bool IsMetadataOut { get; }
    internal bool IsMetadataIn { get; }
    internal bool IsOut { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal UnmanagedType MarshallingType { get; }
    internal bool IsMarshalAsObject { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public int Ordinal { get; }
    public bool IsParamArray { get; }
    public bool IsOptional { get; }
    public bool HasExplicitDefaultValue { get; }
    public object ExplicitDefaultValue { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    internal bool HasOptionCompare { get; }
    public SymbolKind Kind { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public bool IsMe { get; }
    internal EmbeddedSymbolKind EmbeddedSymbolKind { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerMemberName { get; }
    internal bool IsCallerFilePath { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    protected int HighestPriorityUseSiteError { get; }
    public bool HasUnsupportedMetadata { get; }
    private RefKind IParameterSymbol_RefKind { get; }
    private ITypeSymbol IParameterSymbol_Type { get; }
    private bool IParameterSymbol_IsOptional { get; }
    private bool IParameterSymbol_IsThis { get; }
    private ImmutableArray`1<CustomModifier> IParameterSymbol_CustomModifiers { get; }
    private int IParameterSymbol_Ordinal { get; }
    private object IParameterSymbol_DefaultValue { get; }
    private IParameterSymbol IParameterSymbol_OriginalDefinition { get; }
    private sealed virtual override ImmutableArray`1<ICustomModifier> get_IParameterTypeInformationCustomModifiers();
    private sealed virtual override bool get_IParameterTypeInformationIsByReference();
    private sealed virtual override ITypeReference IParameterTypeInformationGetType(EmitContext context);
    private sealed virtual override ushort get_IParameterTypeInformationCountOfCustomModifiersPrecedingByRef();
    private sealed virtual override ushort get_IParameterListEntryIndex();
    private sealed virtual override IMetadataConstant IParameterDefinition_GetDefaultValue(EmitContext context);
    internal IMetadataConstant GetMetadataConstantValue(EmitContext context);
    internal virtual bool get_HasMetadataConstantValue();
    private sealed virtual override bool get_IParameterDefinition_HasDefaultValue();
    private sealed virtual override bool get_IParameterDefinitionIsOptional();
    internal virtual bool get_IsMetadataOptional();
    private sealed virtual override bool get_IParameterDefinitionIsIn();
    private sealed virtual override bool get_IParameterDefinitionIsOut();
    private sealed virtual override bool get_IParameterDefinitionIsMarshalledExplicitly();
    internal virtual bool get_IsMarshalledExplicitly();
    private sealed virtual override IMarshallingInformation get_IParameterDefinitionMarshallingInformation();
    private sealed virtual override ImmutableArray`1<byte> get_IParameterDefinitionMarshallingDescriptor();
    internal virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    internal sealed virtual void IReferenceDispatch(MetadataVisitor visitor);
    internal sealed virtual IDefinition IReferenceAsDefinition(EmitContext context);
    private sealed virtual override string get_INamedEntityName();
    public virtual ParameterSymbol get_OriginalDefinition();
    protected sealed virtual Symbol get_OriginalSymbolDefinition();
    public abstract virtual bool get_IsByRef();
    internal abstract virtual bool get_IsExplicitByRef();
    internal abstract virtual bool get_IsMetadataOut();
    internal abstract virtual bool get_IsMetadataIn();
    internal bool get_IsOut();
    internal abstract virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual UnmanagedType get_MarshallingType();
    internal bool get_IsMarshalAsObject();
    public abstract virtual TypeSymbol get_Type();
    public abstract virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public abstract virtual int get_Ordinal();
    public abstract virtual override bool get_IsParamArray();
    public abstract virtual bool get_IsOptional();
    public abstract virtual override bool get_HasExplicitDefaultValue();
    public object get_ExplicitDefaultValue();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal abstract virtual ConstantValue get_ExplicitDefaultConstantValue(SymbolsInProgress`1<ParameterSymbol> inProgress);
    internal ConstantValue get_ExplicitDefaultConstantValue();
    internal abstract virtual bool get_HasOptionCompare();
    public sealed virtual SymbolKind get_Kind();
    internal virtual TResult Accept(VisualBasicSymbolVisitor`2<TArgument, TResult> visitor, TArgument arg);
    public sealed virtual Accessibility get_DeclaredAccessibility();
    public sealed virtual bool get_IsMustOverride();
    public sealed virtual bool get_IsNotOverridable();
    public sealed virtual bool get_IsOverridable();
    public sealed virtual bool get_IsOverrides();
    public sealed virtual bool get_IsShared();
    public virtual bool get_IsMe();
    internal virtual ParameterSymbol ChangeOwner(Symbol newContainingSymbol);
    internal virtual EmbeddedSymbolKind get_EmbeddedSymbolKind();
    internal abstract virtual bool get_IsIDispatchConstant();
    internal abstract virtual bool get_IsIUnknownConstant();
    internal abstract virtual bool get_IsCallerLineNumber();
    internal abstract virtual bool get_IsCallerMemberName();
    internal abstract virtual bool get_IsCallerFilePath();
    internal abstract virtual ushort get_CountOfCustomModifiersPrecedingByRef();
    protected virtual int get_HighestPriorityUseSiteError();
    public sealed virtual bool get_HasUnsupportedMetadata();
    private sealed virtual override RefKind get_IParameterSymbol_RefKind();
    private sealed virtual override ITypeSymbol get_IParameterSymbol_Type();
    private sealed virtual override bool get_IParameterSymbol_IsOptional();
    private sealed virtual override bool get_IParameterSymbol_IsThis();
    private sealed virtual override ImmutableArray`1<CustomModifier> get_IParameterSymbol_CustomModifiers();
    private sealed virtual override int get_IParameterSymbol_Ordinal();
    private sealed virtual override object get_IParameterSymbol_DefaultValue();
    private sealed virtual override IParameterSymbol get_IParameterSymbol_OriginalDefinition();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSymbolVisitor visitor);
    public virtual TResult Accept(VisualBasicSymbolVisitor`1<TResult> visitor);
    [CompilerGeneratedAttribute]
private bool _Lambda$__18-0(VisualBasicAttributeData a);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.PEOrSourceOrMergedNamespaceSymbol : NamespaceSymbol {
    private Dictionary`2<string, ImmutableArray`1<Symbol>> _lazyExtensionMethodsMap;
    private int _extQueryCnt;
    private static Dictionary`2<string, ImmutableArray`1<Symbol>> s_emptyDictionary;
    private byte _lazyDeclaredAccessibilityOfMostAccessibleDescendantType;
    internal Accessibility RawLazyDeclaredAccessibilityOfMostAccessibleDescendantType { get; }
    internal EmbeddedSymbolKind EmbeddedSymbolKind { get; }
    internal Accessibility DeclaredAccessibilityOfMostAccessibleDescendantType { get; }
    private static PEOrSourceOrMergedNamespaceSymbol();
    internal Accessibility get_RawLazyDeclaredAccessibilityOfMostAccessibleDescendantType();
    internal abstract virtual EmbeddedSymbolKind get_EmbeddedSymbolKind();
    internal sealed virtual Accessibility get_DeclaredAccessibilityOfMostAccessibleDescendantType();
    internal virtual void AppendProbableExtensionMethods(string name, ArrayBuilder`1<MethodSymbol> methods);
    internal virtual void AddExtensionMethodLookupSymbolsInfo(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder, NamespaceSymbol appendThrough);
    private void EnsureExtensionMethodsAreCollected();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.PEPropertyOrEventHelpers : object {
    internal static ISet`1<PropertySymbol> GetPropertiesForExplicitlyImplementedAccessor(MethodSymbol accessor);
    internal static ISet`1<EventSymbol> GetEventsForExplicitlyImplementedAccessor(MethodSymbol accessor);
    private static ISet`1<T> GetSymbolsForExplicitlyImplementedAccessor(MethodSymbol accessor);
    internal static Accessibility GetDeclaredAccessibilityFromAccessors(MethodSymbol accessor1, MethodSymbol accessor2);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.PointerTypeSymbol : ErrorTypeSymbol {
    private TypeSymbol _pointedAtType;
    private ImmutableArray`1<CustomModifier> _customModifiers;
    internal bool MangleName { get; }
    internal DiagnosticInfo ErrorInfo { get; }
    public PointerTypeSymbol(TypeSymbol pointedAtType, ImmutableArray`1<CustomModifier> customModifiers);
    internal virtual bool get_MangleName();
    internal virtual DiagnosticInfo get_ErrorInfo();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.PreprocessingSymbol : Symbol {
    private string _name;
    public string Name { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public SymbolKind Kind { get; }
    public Symbol ContainingSymbol { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal PreprocessingSymbol(string name);
    public virtual string get_Name();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual SymbolKind get_Kind();
    public virtual Symbol get_ContainingSymbol();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsShared();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual void Accept(VisualBasicSymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual TResult Accept(VisualBasicSymbolVisitor`1<TResult> visitor);
    internal virtual TResult Accept(VisualBasicSymbolVisitor`2<TArgument, TResult> visitor, TArgument arg);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySignatureComparer : object {
    public static PropertySignatureComparer AllAspectsSignatureComparer;
    public static PropertySignatureComparer RuntimePropertySignatureComparer;
    public static PropertySignatureComparer RetargetedExplicitPropertyImplementationComparer;
    public static PropertySignatureComparer WinRTConflictComparer;
    private bool _considerName;
    private bool _considerType;
    private bool _considerReadWriteModifiers;
    private bool _considerOptionalParameters;
    private bool _considerCustomModifiers;
    private static PropertySignatureComparer();
    private PropertySignatureComparer(bool considerName, bool considerType, bool considerReadWriteModifiers, bool considerOptionalParameters, bool considerCustomModifiers);
    public sealed virtual override bool Equals(PropertySymbol prop1, PropertySymbol prop2);
    public sealed virtual override int GetHashCode(PropertySymbol prop);
    public static SymbolComparisonResults DetailedCompare(PropertySymbol prop1, PropertySymbol prop2, SymbolComparisonResults comparisons, SymbolComparisonResults stopIfAny);
    private static bool HaveSameTypes(PropertySymbol prop1, PropertySymbol prop2, bool considerCustomModifiers);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbol : Symbol {
    private IEnumerable`1<IMethodReference> IPropertyDefinitionAccessors { get; }
    private IMetadataConstant IPropertyDefinitionDefaultValue { get; }
    private IMethodReference IPropertyDefinitionGetter { get; }
    private bool IPropertyDefinitionHasDefaultValue { get; }
    private bool IPropertyDefinitionIsRuntimeSpecial { get; }
    internal bool HasRuntimeSpecialName { get; }
    private bool IPropertyDefinitionIsSpecialName { get; }
    private ImmutableArray`1<IParameterDefinition> IPropertyDefinitionParameters { get; }
    private IMethodReference IPropertyDefinitionSetter { get; }
    private CallingConvention ISignatureCallingConvention { get; }
    private ushort ISignatureParameterCount { get; }
    private ImmutableArray`1<ICustomModifier> ISignatureReturnValueCustomModifiers { get; }
    private bool ISignatureReturnValueIsByRef { get; }
    private ITypeDefinition ITypeDefinitionMemberContainingTypeDefinition { get; }
    private TypeMemberVisibility ITypeDefinitionMemberVisibility { get; }
    private string INamedEntityName { get; }
    public PropertySymbol OriginalDefinition { get; }
    protected Symbol OriginalSymbolDefinition { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public int ParameterCount { get; }
    internal bool HasSpecialName { get; }
    public bool IsDefault { get; }
    public bool IsReadOnly { get; }
    internal bool IsReadable { get; }
    public bool IsWriteOnly { get; }
    internal bool HasSet { get; }
    public MethodSymbol GetMethod { get; }
    public MethodSymbol SetMethod { get; }
    internal FieldSymbol AssociatedField { get; }
    public bool IsOverloads { get; }
    public PropertySymbol OverriddenProperty { get; }
    internal OverriddenMembersResult`1<PropertySymbol> OverriddenMembers { get; }
    public ImmutableArray`1<PropertySymbol> ExplicitInterfaceImplementations { get; }
    public SymbolKind Kind { get; }
    internal CallingConvention CallingConvention { get; }
    internal ParameterSymbol MeParameter { get; }
    internal PropertySymbol ReducedFrom { get; }
    internal PropertySymbol ReducedFromDefinition { get; }
    internal TypeSymbol ReceiverType { get; }
    protected int HighestPriorityUseSiteError { get; }
    public bool HasUnsupportedMetadata { get; }
    public bool IsWithEvents { get; }
    internal EmbeddedSymbolKind EmbeddedSymbolKind { get; }
    internal bool IsMyGroupCollectionProperty { get; }
    private ImmutableArray`1<IPropertySymbol> IPropertySymbol_ExplicitInterfaceImplementations { get; }
    private IMethodSymbol IPropertySymbol_GetMethod { get; }
    private IPropertySymbol IPropertySymbol_OriginalDefinition { get; }
    private IPropertySymbol IPropertySymbol_OverriddenProperty { get; }
    private ImmutableArray`1<IParameterSymbol> IPropertySymbol_Parameters { get; }
    private IMethodSymbol IPropertySymbol_SetMethod { get; }
    private ITypeSymbol IPropertySymbol_Type { get; }
    private ImmutableArray`1<CustomModifier> IPropertySymbol_TypeCustomModifiers { get; }
    private sealed virtual override IEnumerable`1<IMethodReference> get_IPropertyDefinitionAccessors();
    private sealed virtual override IMetadataConstant get_IPropertyDefinitionDefaultValue();
    private sealed virtual override IMethodReference get_IPropertyDefinitionGetter();
    private sealed virtual override bool get_IPropertyDefinitionHasDefaultValue();
    private sealed virtual override bool get_IPropertyDefinitionIsRuntimeSpecial();
    internal virtual bool get_HasRuntimeSpecialName();
    private sealed virtual override bool get_IPropertyDefinitionIsSpecialName();
    private sealed virtual override ImmutableArray`1<IParameterDefinition> get_IPropertyDefinitionParameters();
    private sealed virtual override IMethodReference get_IPropertyDefinitionSetter();
    private sealed virtual override CallingConvention get_ISignatureCallingConvention();
    private sealed virtual override ushort get_ISignatureParameterCount();
    private sealed virtual override ImmutableArray`1<IParameterTypeInformation> ISignatureGetParameters(EmitContext context);
    private sealed virtual override ImmutableArray`1<ICustomModifier> get_ISignatureReturnValueCustomModifiers();
    private sealed virtual override bool get_ISignatureReturnValueIsByRef();
    private sealed virtual override ITypeReference ISignatureGetType(EmitContext context);
    private sealed virtual override ITypeDefinition get_ITypeDefinitionMemberContainingTypeDefinition();
    private sealed virtual override TypeMemberVisibility get_ITypeDefinitionMemberVisibility();
    private sealed virtual override ITypeReference ITypeMemberReferenceGetContainingType(EmitContext context);
    internal sealed virtual void IReferenceDispatch(MetadataVisitor visitor);
    internal sealed virtual IDefinition IReferenceAsDefinition(EmitContext context);
    private sealed virtual override string get_INamedEntityName();
    public virtual PropertySymbol get_OriginalDefinition();
    protected sealed virtual Symbol get_OriginalSymbolDefinition();
    public abstract virtual TypeSymbol get_Type();
    public abstract virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
    public abstract virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual int get_ParameterCount();
    internal abstract virtual bool get_HasSpecialName();
    public abstract virtual override bool get_IsDefault();
    public virtual override bool get_IsReadOnly();
    internal bool get_IsReadable();
    public virtual override bool get_IsWriteOnly();
    internal bool get_HasSet();
    internal bool IsWritable(BoundExpression receiver, Binder containingBinder);
    public abstract virtual MethodSymbol get_GetMethod();
    internal MethodSymbol GetMostDerivedGetMethod();
    public abstract virtual MethodSymbol get_SetMethod();
    internal MethodSymbol GetMostDerivedSetMethod();
    internal abstract virtual FieldSymbol get_AssociatedField();
    public ImmutableArray`1<VisualBasicAttributeData> GetFieldAttributes();
    public abstract virtual bool get_IsOverloads();
    public PropertySymbol get_OverriddenProperty();
    internal MethodSymbol GetAccessorOverride(bool getter);
    internal virtual OverriddenMembersResult`1<PropertySymbol> get_OverriddenMembers();
    public abstract virtual ImmutableArray`1<PropertySymbol> get_ExplicitInterfaceImplementations();
    public sealed virtual SymbolKind get_Kind();
    internal abstract virtual CallingConvention get_CallingConvention();
    internal virtual TResult Accept(VisualBasicSymbolVisitor`2<TArgument, TResult> visitor, TArgument arg);
    internal virtual ParameterSymbol get_MeParameter();
    internal virtual PropertySymbol get_ReducedFrom();
    internal virtual PropertySymbol get_ReducedFromDefinition();
    internal virtual TypeSymbol get_ReceiverType();
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    internal DiagnosticInfo CalculateUseSiteErrorInfo();
    protected virtual int get_HighestPriorityUseSiteError();
    public sealed virtual bool get_HasUnsupportedMetadata();
    public virtual override bool get_IsWithEvents();
    internal virtual EmbeddedSymbolKind get_EmbeddedSymbolKind();
    internal void CloneParameters(MethodSymbol method, ArrayBuilder`1<ParameterSymbol> parameters);
    internal abstract virtual bool get_IsMyGroupCollectionProperty();
    private sealed virtual override ImmutableArray`1<IPropertySymbol> get_IPropertySymbol_ExplicitInterfaceImplementations();
    private sealed virtual override IMethodSymbol get_IPropertySymbol_GetMethod();
    private sealed virtual override IPropertySymbol get_IPropertySymbol_OriginalDefinition();
    private sealed virtual override IPropertySymbol get_IPropertySymbol_OverriddenProperty();
    private sealed virtual override ImmutableArray`1<IParameterSymbol> get_IPropertySymbol_Parameters();
    private sealed virtual override IMethodSymbol get_IPropertySymbol_SetMethod();
    private sealed virtual override ITypeSymbol get_IPropertySymbol_Type();
    private sealed virtual override ImmutableArray`1<CustomModifier> get_IPropertySymbol_TypeCustomModifiers();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSymbolVisitor visitor);
    public virtual TResult Accept(VisualBasicSymbolVisitor`1<TResult> visitor);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.PropertySymbolExtensions : object {
    [ExtensionAttribute]
internal static bool GetCanBeCalledWithNoParameters(PropertySymbol prop);
    [ExtensionAttribute]
public static TypeSymbol GetTypeFromGetMethod(PropertySymbol property);
    [ExtensionAttribute]
public static TypeSymbol GetTypeFromSetMethod(PropertySymbol property);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.QuickAttributeChecker : object {
    private Dictionary`2<string, QuickAttributes> _nameToAttributeMap;
    private bool _sealed;
    public QuickAttributeChecker(QuickAttributeChecker other);
    public void AddName(string name, QuickAttributes newAttributes);
    public void AddAlias(SimpleImportsClauseSyntax aliasSyntax);
    public void Seal();
    public QuickAttributes CheckAttributes(SyntaxList`1<AttributeListSyntax> attributeLists);
    public QuickAttributes CheckAttribute(AttributeSyntax attr);
    private string GetFinalName(TypeSyntax typeSyntax);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.VisualBasic.Symbols.QuickAttributes : Enum {
    public byte value__;
    public static QuickAttributes None;
    public static QuickAttributes Extension;
    public static QuickAttributes Obsolete;
    public static QuickAttributes MyGroupCollection;
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.RangeVariableSymbol : Symbol {
    internal Binder m_Binder;
    private TypeSymbol _type;
    public VisualBasicSyntaxNode Syntax { get; }
    public SymbolKind Kind { get; }
    public Symbol ContainingSymbol { get; }
    public TypeSymbol Type { get; }
    public string Name { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsShared { get; }
    public bool IsOverridable { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverrides { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    private RangeVariableSymbol(Binder binder, TypeSymbol type);
    public abstract virtual VisualBasicSyntaxNode get_Syntax();
    public virtual SymbolKind get_Kind();
    public virtual Symbol get_ContainingSymbol();
    public virtual TypeSymbol get_Type();
    public abstract virtual string get_Name();
    public abstract virtual ImmutableArray`1<Location> get_Locations();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsShared();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverrides();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual TResult Accept(VisualBasicSymbolVisitor`2<TArgument, TResult> visitor, TArgument arg);
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSymbolVisitor visitor);
    public virtual TResult Accept(VisualBasicSymbolVisitor`1<TResult> visitor);
    internal static RangeVariableSymbol Create(Binder binder, SyntaxToken declaringIdentifier, TypeSymbol type);
    internal static RangeVariableSymbol CreateForErrorRecovery(Binder binder, VisualBasicSyntaxNode syntax, TypeSymbol type);
    internal static RangeVariableSymbol CreateCompilerGenerated(Binder binder, VisualBasicSyntaxNode syntax, string name, TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.ReducedExtensionMethodSymbol : MethodSymbol {
    private TypeSymbol _receiverType;
    private MethodSymbol _curriedFromMethod;
    private ImmutableArray`1<KeyValuePair`2<TypeParameterSymbol, TypeSymbol>> _fixedTypeParameters;
    private int _proximity;
    private TypeSubstitution _curryTypeSubstitution;
    private ImmutableArray`1<ReducedTypeParameterSymbol> _curriedTypeParameters;
    private TypeSymbol _lazyReturnType;
    private ImmutableArray`1<ReducedParameterSymbol> _lazyParameters;
    public TypeSymbol ReceiverType { get; }
    internal ImmutableArray`1<KeyValuePair`2<TypeParameterSymbol, TypeSymbol>> FixedTypeParameters { get; }
    public MethodSymbol ReducedFrom { get; }
    internal MethodSymbol CallsiteReducedFromMethod { get; }
    internal bool MayBeReducibleExtensionMethod { get; }
    internal int Proximity { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public MethodKind MethodKind { get; }
    internal bool IsMethodKindBasedOnSyntax { get; }
    public int Arity { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    internal int ParameterCount { get; }
    public bool IsExtensionMethod { get; }
    public bool IsOverloads { get; }
    public bool IsShared { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public MethodSymbol OverriddenMethod { get; }
    internal bool ShadowsExplicitly { get; }
    public bool IsSub { get; }
    public bool IsAsync { get; }
    public bool IsIterator { get; }
    public bool IsVararg { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    public Symbol AssociatedSymbol { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public bool IsExternalMethod { get; }
    internal MarshalPseudoCustomAttributeData ReturnTypeMarshallingInformation { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal CallingConvention CallingConvention { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsImplicitlyDeclared { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    public string MetadataName { get; }
    internal bool GenerateDebugInfoImpl { get; }
    private ReducedExtensionMethodSymbol(TypeSymbol receiverType, MethodSymbol curriedFromMethod, ImmutableArray`1<KeyValuePair`2<TypeParameterSymbol, TypeSymbol>> fixedTypeParameters, int proximity);
    public static MethodSymbol Create(TypeSymbol instanceType, MethodSymbol possiblyExtensionMethod, int proximity);
    public virtual TypeSymbol get_ReceiverType();
    internal virtual ImmutableArray`1<KeyValuePair`2<TypeParameterSymbol, TypeSymbol>> get_FixedTypeParameters();
    public virtual TypeSymbol GetTypeInferredDuringReduction(TypeParameterSymbol reducedFromTypeParameter);
    public virtual MethodSymbol get_ReducedFrom();
    internal virtual MethodSymbol get_CallsiteReducedFromMethod();
    internal virtual bool get_MayBeReducibleExtensionMethod();
    internal virtual int get_Proximity();
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual MethodKind get_MethodKind();
    internal virtual bool get_IsMethodKindBasedOnSyntax();
    public virtual int get_Arity();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal virtual int get_ParameterCount();
    public virtual bool get_IsExtensionMethod();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsShared();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual MethodSymbol get_OverriddenMethod();
    internal virtual bool get_ShadowsExplicitly();
    public virtual bool get_IsSub();
    public virtual bool get_IsAsync();
    public virtual bool get_IsIterator();
    public virtual bool get_IsVararg();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetReturnTypeAttributes();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    internal virtual VisualBasicSyntaxNode get_Syntax();
    public virtual Symbol get_AssociatedSymbol();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual bool get_IsExternalMethod();
    public virtual DllImportData GetDllImportData();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnTypeMarshallingInformation();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual CallingConvention get_CallingConvention();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    public virtual bool get_IsImplicitlyDeclared();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    public virtual string get_MetadataName();
    internal virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_GenerateDebugInfoImpl();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.ReducedParameterSymbolBase : ParameterSymbol {
    protected ParameterSymbol m_CurriedFromParameter;
    public Symbol ContainingSymbol { get; }
    public TypeSymbol Type { get; }
    public bool IsByRef { get; }
    internal bool IsExplicitByRef { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public int Ordinal { get; }
    public bool IsParamArray { get; }
    public bool IsOptional { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    internal bool HasOptionCompare { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerMemberName { get; }
    internal bool IsCallerFilePath { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    public bool HasExplicitDefaultValue { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool IsMetadataOut { get; }
    internal bool IsMetadataIn { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    public string Name { get; }
    public string MetadataName { get; }
    protected ReducedParameterSymbolBase(ParameterSymbol curriedFromParameter);
    public abstract virtual Symbol get_ContainingSymbol();
    public abstract virtual TypeSymbol get_Type();
    public virtual bool get_IsByRef();
    internal virtual bool get_IsExplicitByRef();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual int get_Ordinal();
    public virtual bool get_IsParamArray();
    public virtual bool get_IsOptional();
    internal virtual ConstantValue get_ExplicitDefaultConstantValue(SymbolsInProgress`1<ParameterSymbol> inProgress);
    internal virtual bool get_HasOptionCompare();
    internal virtual bool get_IsIDispatchConstant();
    internal virtual bool get_IsIUnknownConstant();
    internal virtual bool get_IsCallerLineNumber();
    internal virtual bool get_IsCallerMemberName();
    internal virtual bool get_IsCallerFilePath();
    internal sealed virtual ushort get_CountOfCustomModifiersPrecedingByRef();
    public virtual bool get_HasExplicitDefaultValue();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    internal sealed virtual bool get_IsMetadataOut();
    internal sealed virtual bool get_IsMetadataIn();
    internal sealed virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    public virtual string get_Name();
    public virtual string get_MetadataName();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingAssemblySymbol : NonMissingAssemblySymbol {
    private SourceAssemblySymbol _underlyingAssembly;
    private ImmutableArray`1<ModuleSymbol> _modules;
    private ImmutableArray`1<AssemblySymbol> _noPiaResolutionAssemblies;
    private ImmutableArray`1<AssemblySymbol> _linkedReferencedAssemblies;
    internal ConcurrentDictionary`2<NamedTypeSymbol, NamedTypeSymbol> m_NoPiaUnificationMap;
    private bool _isLinked;
    private ImmutableArray`1<VisualBasicAttributeData> _lazyCustomAttributes;
    public SourceAssemblySymbol UnderlyingAssembly { get; }
    public AssemblyIdentity Identity { get; }
    public Version AssemblyVersionPattern { get; }
    internal ImmutableArray`1<byte> PublicKey { get; }
    internal RetargetingSymbolTranslator RetargetingTranslator { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<ModuleSymbol> Modules { get; }
    internal bool KeepLookingForDeclaredSpecialTypes { get; }
    internal bool IsLinked { get; }
    public ICollection`1<string> TypeNames { get; }
    public ICollection`1<string> NamespaceNames { get; }
    public bool MightContainExtensionMethods { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    public RetargetingAssemblySymbol(SourceAssemblySymbol underlyingAssembly, bool isLinked);
    public SourceAssemblySymbol get_UnderlyingAssembly();
    public virtual AssemblyIdentity get_Identity();
    public virtual Version get_AssemblyVersionPattern();
    internal virtual ImmutableArray`1<byte> get_PublicKey();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    internal RetargetingSymbolTranslator get_RetargetingTranslator();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<ModuleSymbol> get_Modules();
    internal virtual bool get_KeepLookingForDeclaredSpecialTypes();
    internal virtual NamedTypeSymbol GetDeclaredSpecialType(SpecialType type);
    internal virtual ImmutableArray`1<AssemblySymbol> GetNoPiaResolutionAssemblies();
    internal virtual void SetNoPiaResolutionAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal virtual void SetLinkedReferencedAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal virtual ImmutableArray`1<AssemblySymbol> GetLinkedReferencedAssemblies();
    internal virtual bool get_IsLinked();
    public virtual ICollection`1<string> get_TypeNames();
    public virtual ICollection`1<string> get_NamespaceNames();
    internal virtual IEnumerable`1<ImmutableArray`1<byte>> GetInternalsVisibleToPublicKeys(string simpleName);
    internal virtual bool AreInternalsVisibleToThisAssembly(AssemblySymbol potentialGiverOfAccess);
    public virtual bool get_MightContainExtensionMethods();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
    internal virtual bool GetGuidString(String& guidString);
    internal virtual NamedTypeSymbol TryLookupForwardedMetadataTypeWithCycleDetection(MetadataTypeName& emittedName, ConsList`1<AssemblySymbol> visitedAssemblies, bool ignoreCase);
    public virtual AssemblyMetadata GetMetadata();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingAttributeData : SourceAttributeData {
    internal RetargetingAttributeData(SyntaxReference applicationNode, NamedTypeSymbol attributeClass, MethodSymbol attributeConstructor, ImmutableArray`1<TypedConstant> constructorArguments, ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArguments, bool isConditionallyOmitted, bool hasErrors);
    internal virtual TypeSymbol GetSystemType(Symbol targetSymbol);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingEventSymbol : EventSymbol {
    private RetargetingModuleSymbol _retargetingModule;
    private EventSymbol _underlyingEvent;
    private ImmutableArray`1<CustomModifier> _lazyCustomModifiers;
    private ImmutableArray`1<VisualBasicAttributeData> _lazyCustomAttributes;
    private ImmutableArray`1<EventSymbol> _lazyExplicitInterfaceImplementations;
    private DiagnosticInfo _lazyUseSiteErrorInfo;
    private RetargetingSymbolTranslator RetargetingTranslator { get; }
    public EventSymbol UnderlyingEvent { get; }
    public RetargetingModuleSymbol RetargetingModule { get; }
    public Symbol ContainingSymbol { get; }
    public Accessibility DeclaredAccessibility { get; }
    public MethodSymbol AddMethod { get; }
    internal FieldSymbol AssociatedField { get; }
    public ImmutableArray`1<EventSymbol> ExplicitInterfaceImplementations { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public MethodSymbol RaiseMethod { get; }
    public MethodSymbol RemoveMethod { get; }
    public TypeSymbol Type { get; }
    public string Name { get; }
    public string MetadataName { get; }
    internal bool HasSpecialName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public bool IsWindowsRuntimeEvent { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    public RetargetingEventSymbol(RetargetingModuleSymbol retargetingModule, EventSymbol underlyingEvent);
    private RetargetingSymbolTranslator get_RetargetingTranslator();
    public EventSymbol get_UnderlyingEvent();
    public RetargetingModuleSymbol get_RetargetingModule();
    public virtual Symbol get_ContainingSymbol();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    internal virtual IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public virtual MethodSymbol get_AddMethod();
    internal virtual FieldSymbol get_AssociatedField();
    public virtual ImmutableArray`1<EventSymbol> get_ExplicitInterfaceImplementations();
    private ImmutableArray`1<EventSymbol> RetargetExplicitInterfaceImplementations();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsShared();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual MethodSymbol get_RaiseMethod();
    public virtual MethodSymbol get_RemoveMethod();
    public virtual TypeSymbol get_Type();
    public virtual string get_Name();
    public virtual string get_MetadataName();
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_HasRuntimeSpecialName();
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual bool get_IsWindowsRuntimeEvent();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingFieldSymbol : FieldSymbol {
    private RetargetingModuleSymbol _retargetingModule;
    private FieldSymbol _underlyingField;
    private ImmutableArray`1<CustomModifier> _lazyCustomModifiers;
    private ImmutableArray`1<VisualBasicAttributeData> _lazyCustomAttributes;
    private DiagnosticInfo _lazyUseSiteErrorInfo;
    private RetargetingSymbolTranslator RetargetingTranslator { get; }
    public FieldSymbol UnderlyingField { get; }
    public bool IsImplicitlyDeclared { get; }
    public RetargetingModuleSymbol RetargetingModule { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public Symbol ContainingSymbol { get; }
    public Accessibility DeclaredAccessibility { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public ModuleSymbol ContainingModule { get; }
    public string Name { get; }
    public string MetadataName { get; }
    internal bool HasSpecialName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal bool IsNotSerialized { get; }
    internal bool IsMarshalledExplicitly { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal ImmutableArray`1<byte> MarshallingDescriptor { get; }
    internal Nullable`1<int> TypeLayoutOffset { get; }
    public Symbol AssociatedSymbol { get; }
    public bool IsReadOnly { get; }
    public bool IsConst { get; }
    public object ConstantValue { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsShared { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    public RetargetingFieldSymbol(RetargetingModuleSymbol retargetingModule, FieldSymbol underlyingField);
    private RetargetingSymbolTranslator get_RetargetingTranslator();
    public FieldSymbol get_UnderlyingField();
    public virtual bool get_IsImplicitlyDeclared();
    public RetargetingModuleSymbol get_RetargetingModule();
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual Symbol get_ContainingSymbol();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    internal virtual IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual ModuleSymbol get_ContainingModule();
    public virtual string get_Name();
    public virtual string get_MetadataName();
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_HasRuntimeSpecialName();
    internal virtual bool get_IsNotSerialized();
    internal virtual bool get_IsMarshalledExplicitly();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    internal virtual Nullable`1<int> get_TypeLayoutOffset();
    public virtual Symbol get_AssociatedSymbol();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsConst();
    public virtual object get_ConstantValue();
    internal virtual ConstantValue GetConstantValue(SymbolsInProgress`1<FieldSymbol> inProgress);
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool get_IsShared();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingMethodSymbol : MethodSymbol {
    private RetargetingModuleSymbol _retargetingModule;
    private MethodSymbol _underlyingMethod;
    private ImmutableArray`1<TypeParameterSymbol> _lazyTypeParameters;
    private ImmutableArray`1<ParameterSymbol> _lazyParameters;
    private ImmutableArray`1<CustomModifier> _lazyCustomModifiers;
    private ImmutableArray`1<VisualBasicAttributeData> _lazyCustomAttributes;
    private ImmutableArray`1<VisualBasicAttributeData> _lazyReturnTypeCustomAttributes;
    private ImmutableArray`1<MethodSymbol> _lazyExplicitInterfaceImplementations;
    private DiagnosticInfo _lazyUseSiteErrorInfo;
    private RetargetingSymbolTranslator RetargetingTranslator { get; }
    public MethodSymbol UnderlyingMethod { get; }
    public RetargetingModuleSymbol RetargetingModule { get; }
    public bool IsVararg { get; }
    public bool IsGenericMethod { get; }
    public int Arity { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public bool IsSub { get; }
    public bool IsAsync { get; }
    public bool IsIterator { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    internal int ParameterCount { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public Symbol AssociatedSymbol { get; }
    public bool IsExtensionMethod { get; }
    internal bool MayBeReducibleExtensionMethod { get; }
    public bool IsOverloads { get; }
    internal bool IsHiddenBySignature { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsShared { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsExternalMethod { get; }
    internal bool ReturnValueIsMarshalledExplicitly { get; }
    internal MarshalPseudoCustomAttributeData ReturnTypeMarshallingInformation { get; }
    internal ImmutableArray`1<byte> ReturnValueMarshallingDescriptor { get; }
    internal bool IsAccessCheckedOnOverride { get; }
    internal bool IsExternal { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool HasDeclarativeSecurity { get; }
    public bool IsImplicitlyDeclared { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public ModuleSymbol ContainingModule { get; }
    public string Name { get; }
    public string MetadataName { get; }
    internal bool HasSpecialName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal bool IsMetadataFinal { get; }
    public MethodKind MethodKind { get; }
    internal bool IsMethodKindBasedOnSyntax { get; }
    internal CallingConvention CallingConvention { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    internal bool GenerateDebugInfoImpl { get; }
    public RetargetingMethodSymbol(RetargetingModuleSymbol retargetingModule, MethodSymbol underlyingMethod);
    private RetargetingSymbolTranslator get_RetargetingTranslator();
    public MethodSymbol get_UnderlyingMethod();
    public RetargetingModuleSymbol get_RetargetingModule();
    public virtual bool get_IsVararg();
    public virtual bool get_IsGenericMethod();
    public virtual int get_Arity();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual bool get_IsSub();
    public virtual bool get_IsAsync();
    public virtual bool get_IsIterator();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    internal virtual int get_ParameterCount();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    private ImmutableArray`1<ParameterSymbol> RetargetParameters();
    public virtual Symbol get_AssociatedSymbol();
    public virtual bool get_IsExtensionMethod();
    internal virtual bool get_MayBeReducibleExtensionMethod();
    public virtual bool get_IsOverloads();
    internal virtual bool get_IsHiddenBySignature();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsShared();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsExternalMethod();
    public virtual DllImportData GetDllImportData();
    internal virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_ReturnValueIsMarshalledExplicitly();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnTypeMarshallingInformation();
    internal virtual ImmutableArray`1<byte> get_ReturnValueMarshallingDescriptor();
    internal virtual bool get_IsAccessCheckedOnOverride();
    internal virtual bool get_IsExternal();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetReturnTypeAttributes();
    internal virtual IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual ModuleSymbol get_ContainingModule();
    public virtual string get_Name();
    public virtual string get_MetadataName();
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_HasRuntimeSpecialName();
    internal virtual bool get_IsMetadataFinal();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    public virtual MethodKind get_MethodKind();
    internal virtual bool get_IsMethodKindBasedOnSyntax();
    internal virtual CallingConvention get_CallingConvention();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    private ImmutableArray`1<MethodSymbol> RetargetExplicitInterfaceImplementations();
    internal virtual VisualBasicSyntaxNode get_Syntax();
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual bool get_GenerateDebugInfoImpl();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingModuleSymbol : NonMissingModuleSymbol {
    private RetargetingAssemblySymbol _retargetingAssembly;
    private SourceModuleSymbol _underlyingModule;
    private Dictionary`2<AssemblySymbol, DestinationData> _retargetingAssemblyMap;
    internal RetargetingSymbolTranslator RetargetingTranslator;
    private ImmutableArray`1<VisualBasicAttributeData> _lazyCustomAttributes;
    private ConcurrentDictionary`2<Symbol, Symbol> _symbolMap;
    private Func`2<Symbol, RetargetingMethodSymbol> _createRetargetingMethod;
    private Func`2<Symbol, RetargetingNamespaceSymbol> _createRetargetingNamespace;
    private Func`2<Symbol, RetargetingTypeParameterSymbol> _createRetargetingTypeParameter;
    private Func`2<Symbol, RetargetingNamedTypeSymbol> _createRetargetingNamedType;
    private Func`2<Symbol, RetargetingFieldSymbol> _createRetargetingField;
    private Func`2<Symbol, RetargetingPropertySymbol> _createRetargetingProperty;
    private Func`2<Symbol, RetargetingEventSymbol> _createRetargetingEvent;
    internal int Ordinal { get; }
    internal Machine Machine { get; }
    internal bool Bit32Required { get; }
    public SourceModuleSymbol UnderlyingModule { get; }
    public Symbol ContainingSymbol { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public string Name { get; }
    public string MetadataName { get; }
    public NamespaceSymbol GlobalNamespace { get; }
    public ImmutableArray`1<Location> Locations { get; }
    internal ICollection`1<string> TypeNames { get; }
    internal ICollection`1<string> NamespaceNames { get; }
    internal bool MightContainExtensionMethods { get; }
    internal bool HasAssemblyCompilationRelaxationsAttribute { get; }
    internal bool HasAssemblyRuntimeCompatibilityAttribute { get; }
    internal Nullable`1<CharSet> DefaultMarshallingCharSet { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    public RetargetingModuleSymbol(RetargetingAssemblySymbol retargetingAssembly, SourceModuleSymbol underlyingModule);
    internal virtual int get_Ordinal();
    internal virtual Machine get_Machine();
    internal virtual bool get_Bit32Required();
    public SourceModuleSymbol get_UnderlyingModule();
    public virtual Symbol get_ContainingSymbol();
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    public virtual string get_Name();
    public virtual string get_MetadataName();
    public virtual NamespaceSymbol get_GlobalNamespace();
    public virtual ImmutableArray`1<Location> get_Locations();
    internal virtual void SetReferences(ModuleReferences`1<AssemblySymbol> moduleReferences, SourceAssemblySymbol originatingSourceAssemblyDebugOnly);
    internal virtual ICollection`1<string> get_TypeNames();
    internal virtual ICollection`1<string> get_NamespaceNames();
    internal virtual bool get_MightContainExtensionMethods();
    internal virtual bool get_HasAssemblyCompilationRelaxationsAttribute();
    internal virtual bool get_HasAssemblyRuntimeCompatibilityAttribute();
    internal virtual Nullable`1<CharSet> get_DefaultMarshallingCharSet();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    public virtual ModuleMetadata GetMetadata();
    private RetargetingMethodSymbol CreateRetargetingMethod(Symbol symbol);
    private RetargetingNamespaceSymbol CreateRetargetingNamespace(Symbol symbol);
    private RetargetingNamedTypeSymbol CreateRetargetingNamedType(Symbol symbol);
    private RetargetingFieldSymbol CreateRetargetingField(Symbol symbol);
    private RetargetingPropertySymbol CreateRetargetingProperty(Symbol symbol);
    private RetargetingEventSymbol CreateRetargetingEvent(Symbol symbol);
    private RetargetingTypeParameterSymbol CreateRetargetingTypeParameter(Symbol symbol);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamedTypeSymbol : InstanceTypeSymbol {
    private RetargetingModuleSymbol _retargetingModule;
    private NamedTypeSymbol _underlyingType;
    private ImmutableArray`1<TypeParameterSymbol> _lazyTypeParameters;
    private TypeSymbol _lazyCoClass;
    private ImmutableArray`1<VisualBasicAttributeData> _lazyCustomAttributes;
    private DiagnosticInfo _lazyUseSiteErrorInfo;
    private RetargetingSymbolTranslator RetargetingTranslator { get; }
    public NamedTypeSymbol UnderlyingNamedType { get; }
    public bool IsImplicitlyDeclared { get; }
    public int Arity { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public NamedTypeSymbol ConstructedFrom { get; }
    public NamedTypeSymbol EnumUnderlyingType { get; }
    public bool MightContainExtensionMethods { get; }
    internal bool HasEmbeddedAttribute { get; }
    internal bool IsExtensibleInterfaceNoUseSiteDiagnostics { get; }
    internal bool IsWindowsRuntimeImport { get; }
    internal bool ShouldAddWinRTMembers { get; }
    internal bool IsComImport { get; }
    internal TypeSymbol CoClassType { get; }
    internal bool HasDeclarativeSecurity { get; }
    public string Name { get; }
    public string MetadataName { get; }
    internal bool MangleName { get; }
    internal bool HasSpecialName { get; }
    internal bool IsSerializable { get; }
    internal TypeLayout Layout { get; }
    internal CharSet MarshallingCharSet { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public Accessibility DeclaredAccessibility { get; }
    public TypeKind TypeKind { get; }
    internal bool IsInterface { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsMustInherit { get; }
    internal bool IsMetadataAbstract { get; }
    public bool IsNotInheritable { get; }
    internal bool IsMetadataSealed { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public ModuleSymbol ContainingModule { get; }
    internal string DefaultPropertyName { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    public RetargetingNamedTypeSymbol(RetargetingModuleSymbol retargetingModule, NamedTypeSymbol underlyingType);
    private RetargetingSymbolTranslator get_RetargetingTranslator();
    public NamedTypeSymbol get_UnderlyingNamedType();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual int get_Arity();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual NamedTypeSymbol get_ConstructedFrom();
    public virtual NamedTypeSymbol get_EnumUnderlyingType();
    public virtual bool get_MightContainExtensionMethods();
    internal virtual bool get_HasEmbeddedAttribute();
    internal virtual bool get_IsExtensibleInterfaceNoUseSiteDiagnostics();
    internal virtual bool get_IsWindowsRuntimeImport();
    internal virtual bool get_ShouldAddWinRTMembers();
    internal virtual bool get_IsComImport();
    internal virtual TypeSymbol get_CoClassType();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual AttributeUsageInfo GetAttributeUsageInfo();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual void AppendProbableExtensionMethods(string name, ArrayBuilder`1<MethodSymbol> methods);
    internal virtual void BuildExtensionMethodsMap(Dictionary`2<string, ArrayBuilder`1<MethodSymbol>> map, NamespaceSymbol appendThrough);
    internal virtual void GetExtensionMethods(ArrayBuilder`1<MethodSymbol> methods, NamespaceSymbol appendThrough, string Name);
    internal virtual void AddExtensionMethodLookupSymbolsInfo(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
    internal virtual bool AddExtensionMethodLookupSymbolsInfoViabilityCheck(MethodSymbol method, LookupOptions options, Binder originalBinder);
    internal virtual void AddExtensionMethodLookupSymbolsInfo(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder, NamedTypeSymbol appendThrough);
    public virtual string get_Name();
    public virtual string get_MetadataName();
    internal virtual bool get_MangleName();
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_IsSerializable();
    internal virtual TypeLayout get_Layout();
    internal virtual CharSet get_MarshallingCharSet();
    internal virtual string GetEmittedNamespaceName();
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    internal virtual ImmutableArray`1<Symbol> GetMembersUnordered();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamedTypeSymbol/VB$StateMachine_66_GetFieldsToEmit")]
internal virtual IEnumerable`1<FieldSymbol> GetFieldsToEmit();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamedTypeSymbol/VB$StateMachine_67_GetMethodsToEmit")]
internal virtual IEnumerable`1<MethodSymbol> GetMethodsToEmit();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamedTypeSymbol/VB$StateMachine_68_GetPropertiesToEmit")]
internal virtual IEnumerable`1<PropertySymbol> GetPropertiesToEmit();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamedTypeSymbol/VB$StateMachine_69_GetEventsToEmit")]
internal virtual IEnumerable`1<EventSymbol> GetEventsToEmit();
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembersUnordered();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public virtual Accessibility get_DeclaredAccessibility();
    internal virtual NamedTypeSymbol MakeDeclaredBase(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    internal virtual IEnumerable`1<NamedTypeSymbol> GetInterfacesToEmit();
    internal virtual ImmutableArray`1<NamedTypeSymbol> MakeDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    private static ErrorTypeSymbol CyclicInheritanceError(DiagnosticInfo diag);
    internal virtual NamedTypeSymbol MakeAcyclicBaseType(DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<NamedTypeSymbol> MakeAcyclicInterfaces(DiagnosticBag diagnostics);
    public virtual TypeKind get_TypeKind();
    internal virtual bool get_IsInterface();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool get_IsMustInherit();
    internal virtual bool get_IsMetadataAbstract();
    public virtual bool get_IsNotInheritable();
    internal virtual bool get_IsMetadataSealed();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    internal virtual IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual ModuleSymbol get_ContainingModule();
    internal virtual NamedTypeSymbol LookupMetadataType(MetadataTypeName& emittedTypeName);
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    internal virtual string get_DefaultPropertyName();
    internal virtual void GenerateDeclarationErrors(CancellationToken cancellationToken);
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
    internal virtual bool GetGuidString(String& guidString);
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private VB$AnonymousType_2`2<NamedTypeSymbol, DiagnosticInfo> _Lambda$__81-0(NamedTypeSymbol t);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingNamespaceSymbol : NamespaceSymbol {
    private RetargetingModuleSymbol _retargetingModule;
    private NamespaceSymbol _underlyingNamespace;
    private RetargetingSymbolTranslator RetargetingTranslator { get; }
    public NamespaceSymbol UnderlyingNamespace { get; }
    internal NamespaceExtent Extent { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public ModuleSymbol ContainingModule { get; }
    public bool IsGlobalNamespace { get; }
    public string Name { get; }
    public string MetadataName { get; }
    internal Accessibility DeclaredAccessibilityOfMostAccessibleDescendantType { get; }
    internal ImmutableArray`1<NamedTypeSymbol> TypesToCheckForExtensionMethods { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    public RetargetingNamespaceSymbol(RetargetingModuleSymbol retargetingModule, NamespaceSymbol underlyingNamespace);
    private RetargetingSymbolTranslator get_RetargetingTranslator();
    public NamespaceSymbol get_UnderlyingNamespace();
    internal virtual NamespaceExtent get_Extent();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    private ImmutableArray`1<Symbol> RetargetMembers(ImmutableArray`1<Symbol> underlyingMembers);
    internal virtual ImmutableArray`1<Symbol> GetMembersUnordered();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembersUnordered();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    private ImmutableArray`1<NamedTypeSymbol> RetargetTypeMembers(ImmutableArray`1<NamedTypeSymbol> underlyingMembers);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual ModuleSymbol get_ContainingModule();
    public virtual bool get_IsGlobalNamespace();
    public virtual string get_Name();
    public virtual string get_MetadataName();
    internal virtual NamedTypeSymbol LookupMetadataType(MetadataTypeName& fullEmittedName);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetModuleMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetModuleMembers(string name);
    protected virtual Accessibility GetDeclaredAccessibilityOfMostAccessibleDescendantType();
    internal virtual Accessibility get_DeclaredAccessibilityOfMostAccessibleDescendantType();
    internal virtual void AppendProbableExtensionMethods(string name, ArrayBuilder`1<MethodSymbol> methods);
    internal virtual ImmutableArray`1<NamedTypeSymbol> get_TypesToCheckForExtensionMethods();
    internal virtual void BuildExtensionMethodsMap(Dictionary`2<string, ArrayBuilder`1<MethodSymbol>> map);
    internal virtual void GetExtensionMethods(ArrayBuilder`1<MethodSymbol> methods, string name);
    internal virtual void BuildExtensionMethodsMapBucket(ArrayBuilder`1<MethodSymbol> bucket, MethodSymbol method);
    internal virtual void AddExtensionMethodLookupSymbolsInfo(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
    internal virtual bool AddExtensionMethodLookupSymbolsInfoViabilityCheck(MethodSymbol method, LookupOptions options, Binder originalBinder);
    internal virtual void AddExtensionMethodLookupSymbolsInfo(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder, NamespaceSymbol appendThrough);
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingParameterSymbol : ParameterSymbol {
    private ParameterSymbol _underlyingParameter;
    private ImmutableArray`1<CustomModifier> _lazyCustomModifiers;
    private ImmutableArray`1<VisualBasicAttributeData> _lazyCustomAttributes;
    public ParameterSymbol UnderlyingParameter { get; }
    protected RetargetingModuleSymbol RetargetingModule { get; }
    private RetargetingSymbolTranslator RetargetingTranslator { get; }
    public bool IsImplicitlyDeclared { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public bool IsParamArray { get; }
    public bool IsByRef { get; }
    internal bool IsExplicitByRef { get; }
    public int Ordinal { get; }
    public bool IsOptional { get; }
    internal bool IsMetadataOut { get; }
    internal bool IsMetadataIn { get; }
    public bool HasExplicitDefaultValue { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal bool HasOptionCompare { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerMemberName { get; }
    internal bool IsCallerFilePath { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public ModuleSymbol ContainingModule { get; }
    public string Name { get; }
    public string MetadataName { get; }
    internal bool HasMetadataConstantValue { get; }
    internal bool IsMetadataOptional { get; }
    internal bool IsMarshalledExplicitly { get; }
    internal ImmutableArray`1<byte> MarshallingDescriptor { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    protected RetargetingParameterSymbol(ParameterSymbol underlyingParameter);
    public static RetargetingParameterSymbol CreateMethodParameter(RetargetingMethodSymbol retargetingMethod, ParameterSymbol underlyingParameter);
    public static RetargetingParameterSymbol CreatePropertyParameter(RetargetingPropertySymbol retargetingProperty, ParameterSymbol underlyingParameter);
    public ParameterSymbol get_UnderlyingParameter();
    protected abstract virtual RetargetingModuleSymbol get_RetargetingModule();
    private RetargetingSymbolTranslator get_RetargetingTranslator();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual bool get_IsParamArray();
    public virtual bool get_IsByRef();
    internal virtual bool get_IsExplicitByRef();
    public virtual int get_Ordinal();
    public virtual bool get_IsOptional();
    internal virtual bool get_IsMetadataOut();
    internal virtual bool get_IsMetadataIn();
    public virtual bool get_HasExplicitDefaultValue();
    internal virtual ConstantValue get_ExplicitDefaultConstantValue(SymbolsInProgress`1<ParameterSymbol> inProgress);
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual bool get_HasOptionCompare();
    internal virtual bool get_IsIDispatchConstant();
    internal virtual bool get_IsIUnknownConstant();
    internal virtual bool get_IsCallerLineNumber();
    internal virtual bool get_IsCallerMemberName();
    internal virtual bool get_IsCallerFilePath();
    internal sealed virtual ushort get_CountOfCustomModifiersPrecedingByRef();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    internal virtual IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual ModuleSymbol get_ContainingModule();
    public virtual string get_Name();
    public virtual string get_MetadataName();
    internal virtual bool get_HasMetadataConstantValue();
    internal virtual bool get_IsMetadataOptional();
    internal virtual bool get_IsMarshalledExplicitly();
    internal virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    internal sealed virtual VisualBasicCompilation get_DeclaringCompilation();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingPropertySymbol : PropertySymbol {
    private RetargetingModuleSymbol _retargetingModule;
    private PropertySymbol _underlyingProperty;
    private ImmutableArray`1<ParameterSymbol> _lazyParameters;
    private ImmutableArray`1<CustomModifier> _lazyCustomModifiers;
    private ImmutableArray`1<VisualBasicAttributeData> _lazyCustomAttributes;
    private ImmutableArray`1<PropertySymbol> _lazyExplicitInterfaceImplementations;
    private DiagnosticInfo _lazyUseSiteErrorInfo;
    private RetargetingSymbolTranslator RetargetingTranslator { get; }
    public PropertySymbol UnderlyingProperty { get; }
    public RetargetingModuleSymbol RetargetingModule { get; }
    public bool IsImplicitlyDeclared { get; }
    public bool IsWithEvents { get; }
    public Symbol ContainingSymbol { get; }
    public Accessibility DeclaredAccessibility { get; }
    public MethodSymbol GetMethod { get; }
    public MethodSymbol SetMethod { get; }
    internal FieldSymbol AssociatedField { get; }
    public bool IsDefault { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsOverloads { get; }
    public bool IsShared { get; }
    public string Name { get; }
    public string MetadataName { get; }
    internal bool HasSpecialName { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public int ParameterCount { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    internal CallingConvention CallingConvention { get; }
    public ImmutableArray`1<PropertySymbol> ExplicitInterfaceImplementations { get; }
    internal bool IsMyGroupCollectionProperty { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    public RetargetingPropertySymbol(RetargetingModuleSymbol retargetingModule, PropertySymbol underlyingProperty);
    private RetargetingSymbolTranslator get_RetargetingTranslator();
    public PropertySymbol get_UnderlyingProperty();
    public RetargetingModuleSymbol get_RetargetingModule();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual bool get_IsWithEvents();
    public virtual Symbol get_ContainingSymbol();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    internal virtual IEnumerable`1<VisualBasicAttributeData> GetCustomAttributesToEmit(ModuleCompilationState compilationState);
    public virtual MethodSymbol get_GetMethod();
    public virtual MethodSymbol get_SetMethod();
    internal virtual FieldSymbol get_AssociatedField();
    public virtual bool get_IsDefault();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsShared();
    public virtual string get_Name();
    public virtual string get_MetadataName();
    internal virtual bool get_HasSpecialName();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual int get_ParameterCount();
    private ImmutableArray`1<ParameterSymbol> RetargetParameters();
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
    internal virtual CallingConvention get_CallingConvention();
    public virtual ImmutableArray`1<PropertySymbol> get_ExplicitInterfaceImplementations();
    private ImmutableArray`1<PropertySymbol> RetargetExplicitInterfaceImplementations();
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    internal virtual bool get_IsMyGroupCollectionProperty();
    internal virtual bool get_HasRuntimeSpecialName();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetingTypeParameterSymbol : TypeParameterSymbol {
    private RetargetingModuleSymbol _retargetingModule;
    private TypeParameterSymbol _underlyingTypeParameter;
    private RetargetingSymbolTranslator RetargetingTranslator { get; }
    public TypeParameterSymbol UnderlyingTypeParameter { get; }
    public TypeParameterKind TypeParameterKind { get; }
    public bool IsImplicitlyDeclared { get; }
    public int Ordinal { get; }
    internal ImmutableArray`1<TypeSymbol> ConstraintTypesNoUseSiteDiagnostics { get; }
    public bool HasConstructorConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public VarianceKind Variance { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public ModuleSymbol ContainingModule { get; }
    public string Name { get; }
    public string MetadataName { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    public RetargetingTypeParameterSymbol(RetargetingModuleSymbol retargetingModule, TypeParameterSymbol underlyingTypeParameter);
    private RetargetingSymbolTranslator get_RetargetingTranslator();
    public TypeParameterSymbol get_UnderlyingTypeParameter();
    public virtual TypeParameterKind get_TypeParameterKind();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual int get_Ordinal();
    internal virtual ImmutableArray`1<TypeSymbol> get_ConstraintTypesNoUseSiteDiagnostics();
    public virtual bool get_HasConstructorConstraint();
    public virtual bool get_HasReferenceTypeConstraint();
    public virtual bool get_HasValueTypeConstraint();
    public virtual VarianceKind get_Variance();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual ModuleSymbol get_ContainingModule();
    public virtual string get_Name();
    public virtual string get_MetadataName();
    internal virtual void EnsureAllConstraintsAreResolved();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.VisualBasic.Symbols.Retargeting.RetargetOptions : Enum {
    public byte value__;
    public static RetargetOptions RetargetPrimitiveTypesByName;
    public static RetargetOptions RetargetPrimitiveTypesByTypeCode;
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.RootSingleNamespaceDeclaration : GlobalNamespaceDeclaration {
    private ImmutableArray`1<ReferenceDirective> _referenceDirectives;
    private bool _hasAssemblyAttributes;
    public ImmutableArray`1<ReferenceDirective> ReferenceDirectives { get; }
    public bool HasAssemblyAttributes { get; }
    public RootSingleNamespaceDeclaration(bool hasImports, SyntaxReference treeNode, ImmutableArray`1<SingleNamespaceOrTypeDeclaration> children, ImmutableArray`1<ReferenceDirective> referenceDirectives, bool hasAssemblyAttributes);
    public ImmutableArray`1<ReferenceDirective> get_ReferenceDirectives();
    public bool get_HasAssemblyAttributes();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SignatureOnlyMethodSymbol : MethodSymbol {
    private string _name;
    private TypeSymbol _containingType;
    private MethodKind _methodKind;
    private CallingConvention _callingConvention;
    private ImmutableArray`1<TypeParameterSymbol> _typeParameters;
    private ImmutableArray`1<ParameterSymbol> _parameters;
    private TypeSymbol _returnType;
    private ImmutableArray`1<CustomModifier> _returnTypeCustomModifiers;
    private ImmutableArray`1<MethodSymbol> _explicitInterfaceImplementations;
    private bool _isOverrides;
    internal CallingConvention CallingConvention { get; }
    public bool IsVararg { get; }
    public bool IsGenericMethod { get; }
    public int Arity { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public Symbol ContainingSymbol { get; }
    public MethodKind MethodKind { get; }
    internal bool IsMethodKindBasedOnSyntax { get; }
    public string Name { get; }
    public bool IsSub { get; }
    public bool IsAsync { get; }
    public bool IsIterator { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool HasSpecialName { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public Symbol AssociatedSymbol { get; }
    public bool IsExtensionMethod { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public bool IsShared { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverrides { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    public bool IsOverloads { get; }
    public bool IsExternalMethod { get; }
    internal MarshalPseudoCustomAttributeData ReturnTypeMarshallingInformation { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool HasDeclarativeSecurity { get; }
    public bool IsMustOverride { get; }
    public bool IsOverridable { get; }
    internal OverriddenMembersResult`1<MethodSymbol> OverriddenMembers { get; }
    public MethodSymbol OverriddenMethod { get; }
    internal bool GenerateDebugInfoImpl { get; }
    public SignatureOnlyMethodSymbol(string name, TypeSymbol m_containingType, MethodKind methodKind, CallingConvention callingConvention, ImmutableArray`1<TypeParameterSymbol> typeParameters, ImmutableArray`1<ParameterSymbol> parameters, TypeSymbol returnType, ImmutableArray`1<CustomModifier> returnTypeCustomModifiers, ImmutableArray`1<MethodSymbol> explicitInterfaceImplementations, bool isOverrides);
    internal virtual CallingConvention get_CallingConvention();
    public virtual bool get_IsVararg();
    public virtual bool get_IsGenericMethod();
    public virtual int get_Arity();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual Symbol get_ContainingSymbol();
    public virtual MethodKind get_MethodKind();
    internal virtual bool get_IsMethodKindBasedOnSyntax();
    public virtual string get_Name();
    public virtual bool get_IsSub();
    public virtual bool get_IsAsync();
    public virtual bool get_IsIterator();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual bool get_HasSpecialName();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual Symbol get_AssociatedSymbol();
    public virtual bool get_IsExtensionMethod();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual bool get_IsShared();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverrides();
    internal virtual VisualBasicSyntaxNode get_Syntax();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsExternalMethod();
    public virtual DllImportData GetDllImportData();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnTypeMarshallingInformation();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsOverridable();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal virtual OverriddenMembersResult`1<MethodSymbol> get_OverriddenMembers();
    public virtual MethodSymbol get_OverriddenMethod();
    internal virtual bool get_GenerateDebugInfoImpl();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SignatureOnlyParameterSymbol : ParameterSymbol {
    private TypeSymbol _type;
    private ImmutableArray`1<CustomModifier> _customModifiers;
    private ConstantValue _defaultValue;
    private bool _isParamArray;
    private bool _isByRef;
    private bool _isOut;
    private bool _isOptional;
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public bool IsParamArray { get; }
    public string Name { get; }
    public bool IsByRef { get; }
    internal bool IsExplicitByRef { get; }
    internal bool IsMetadataOut { get; }
    internal bool IsMetadataIn { get; }
    public bool IsOptional { get; }
    public bool HasExplicitDefaultValue { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    internal bool HasOptionCompare { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    public int Ordinal { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public AssemblySymbol ContainingAssembly { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerMemberName { get; }
    internal bool IsCallerFilePath { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    public SignatureOnlyParameterSymbol(TypeSymbol type, ImmutableArray`1<CustomModifier> customModifiers, ConstantValue defaultConstantValue, bool isParamArray, bool isByRef, bool isOut, bool isOptional);
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual bool get_IsParamArray();
    public virtual string get_Name();
    public virtual bool get_IsByRef();
    internal virtual bool get_IsExplicitByRef();
    internal virtual bool get_IsMetadataOut();
    internal virtual bool get_IsMetadataIn();
    public virtual bool get_IsOptional();
    public virtual bool get_HasExplicitDefaultValue();
    internal virtual ConstantValue get_ExplicitDefaultConstantValue(SymbolsInProgress`1<ParameterSymbol> inProgress);
    internal virtual bool get_HasOptionCompare();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    public virtual int get_Ordinal();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual AssemblySymbol get_ContainingAssembly();
    internal virtual bool get_IsIDispatchConstant();
    internal virtual bool get_IsIUnknownConstant();
    internal virtual bool get_IsCallerLineNumber();
    internal virtual bool get_IsCallerMemberName();
    internal virtual bool get_IsCallerFilePath();
    internal virtual ushort get_CountOfCustomModifiersPrecedingByRef();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SignatureOnlyPropertySymbol : PropertySymbol {
    private string _name;
    private NamedTypeSymbol _containingType;
    private bool _isReadOnly;
    private bool _isWriteOnly;
    private ImmutableArray`1<ParameterSymbol> _parameters;
    private TypeSymbol _type;
    private ImmutableArray`1<CustomModifier> _typeCustomModifiers;
    private bool _isOverrides;
    private bool _isWithEvents;
    public string Name { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public bool IsReadOnly { get; }
    public bool IsWriteOnly { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool HasSpecialName { get; }
    internal CallingConvention CallingConvention { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<PropertySymbol> ExplicitInterfaceImplementations { get; }
    public MethodSymbol GetMethod { get; }
    public MethodSymbol SetMethod { get; }
    internal FieldSymbol AssociatedField { get; }
    public bool IsDefault { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverloads { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsWithEvents { get; }
    public bool IsShared { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal bool IsMyGroupCollectionProperty { get; }
    internal OverriddenMembersResult`1<PropertySymbol> OverriddenMembers { get; }
    public SignatureOnlyPropertySymbol(string name, NamedTypeSymbol containingType, bool isReadOnly, bool isWriteOnly, ImmutableArray`1<ParameterSymbol> parameters, TypeSymbol type, ImmutableArray`1<CustomModifier> typeCustomModifiers, bool isOverrides, bool isWithEvents);
    public virtual string get_Name();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsWriteOnly();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual bool get_HasSpecialName();
    internal virtual CallingConvention get_CallingConvention();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<PropertySymbol> get_ExplicitInterfaceImplementations();
    public virtual MethodSymbol get_GetMethod();
    public virtual MethodSymbol get_SetMethod();
    internal virtual FieldSymbol get_AssociatedField();
    public virtual bool get_IsDefault();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsWithEvents();
    public virtual bool get_IsShared();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual bool get_IsMyGroupCollectionProperty();
    internal virtual OverriddenMembersResult`1<PropertySymbol> get_OverriddenMembers();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SingleNamespaceDeclaration : SingleNamespaceOrTypeDeclaration {
    private ImmutableArray`1<SingleNamespaceOrTypeDeclaration> _children;
    [CompilerGeneratedAttribute]
private bool _HasImports;
    public bool IsPartOfRootNamespace;
    public static IEqualityComparer`1<SingleNamespaceDeclaration> EqualityComparer;
    public bool HasImports { get; public set; }
    public bool IsGlobalNamespace { get; }
    public DeclarationKind Kind { get; }
    private static SingleNamespaceDeclaration();
    public SingleNamespaceDeclaration(string name, bool hasImports, SyntaxReference syntaxReference, Location nameLocation, ImmutableArray`1<SingleNamespaceOrTypeDeclaration> children, bool isPartOfRootNamespace);
    [CompilerGeneratedAttribute]
public bool get_HasImports();
    [CompilerGeneratedAttribute]
public void set_HasImports(bool AutoPropertyValue);
    public virtual bool get_IsGlobalNamespace();
    public virtual DeclarationKind get_Kind();
    protected virtual ImmutableArray`1<SingleNamespaceOrTypeDeclaration> GetNamespaceOrTypeDeclarationChildren();
    public NamespaceBlockSyntax GetNamespaceBlockSyntax();
    public static string BestName(ImmutableArray`1<T> singleDeclarations, Boolean& multipleSpellings);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SingleNamespaceOrTypeDeclaration : Declaration {
    public SyntaxReference SyntaxReference;
    public Location NameLocation;
    public Location Location { get; }
    public ImmutableArray`1<SingleNamespaceOrTypeDeclaration> Children { get; }
    protected SingleNamespaceOrTypeDeclaration(string name, SyntaxReference syntaxReference, Location nameLocation);
    public Location get_Location();
    protected abstract virtual ImmutableArray`1<SingleNamespaceOrTypeDeclaration> GetNamespaceOrTypeDeclarationChildren();
    protected virtual ImmutableArray`1<Declaration> GetDeclarationChildren();
    public ImmutableArray`1<SingleNamespaceOrTypeDeclaration> get_Children();
    public static string BestName(ImmutableArray`1<T> singleDeclarations, Boolean& multipleSpellings);
    public static string BestName(ImmutableArray`1<T> singleDeclarations);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SingleTypeDeclaration : SingleNamespaceOrTypeDeclaration {
    private ImmutableArray`1<SingleTypeDeclaration> _children;
    private DeclarationKind _kind;
    private TypeDeclarationFlags _flags;
    private ushort _arity;
    private DeclarationModifiers _modifiers;
    private ICollection`1<string> _memberNames;
    public static IEqualityComparer`1<SingleTypeDeclaration> EqualityComparer;
    public DeclarationKind Kind { get; }
    public int Arity { get; }
    public bool HasAnyAttributes { get; }
    public bool HasBaseDeclarations { get; }
    public bool HasAnyNontypeMembers { get; }
    public bool AnyMemberHasAttributes { get; }
    public ImmutableArray`1<SingleTypeDeclaration> Children { get; }
    public DeclarationModifiers Modifiers { get; }
    public ICollection`1<string> MemberNames { get; }
    private static SingleTypeDeclaration();
    public SingleTypeDeclaration(DeclarationKind kind, string name, int arity, DeclarationModifiers modifiers, TypeDeclarationFlags declFlags, SyntaxReference syntaxReference, Location nameLocation, ICollection`1<string> memberNames, ImmutableArray`1<SingleTypeDeclaration> children);
    public virtual DeclarationKind get_Kind();
    public int get_Arity();
    public bool get_HasAnyAttributes();
    public bool get_HasBaseDeclarations();
    public bool get_HasAnyNontypeMembers();
    public bool get_AnyMemberHasAttributes();
    public ImmutableArray`1<SingleTypeDeclaration> get_Children();
    public DeclarationModifiers get_Modifiers();
    public ICollection`1<string> get_MemberNames();
    protected virtual ImmutableArray`1<SingleNamespaceOrTypeDeclaration> GetNamespaceOrTypeDeclarationChildren();
    private EmbeddedSymbolKind GetEmbeddedSymbolKind();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAssemblySymbol : MetadataOrSourceAssemblySymbol {
    private VisualBasicCompilation _compilation;
    private StrongNameKeys _lazyStrongNameKeys;
    internal AssemblyIdentity m_lazyIdentity;
    private ImmutableArray`1<ModuleSymbol> _modules;
    private CustomAttributesBag`1<VisualBasicAttributeData> _lazySourceAttributesBag;
    private CustomAttributesBag`1<VisualBasicAttributeData> _lazyNetModuleAttributesBag;
    private HashSet`1<int> _lazyDuplicateAttributeIndices;
    private byte _lazyEmitExtensionAttribute;
    private ThreeState _lazyIsVbRuntime;
    private ImmutableArray`1<Diagnostic> _lazyAssemblyLevelDeclarationErrors;
    private string _assemblySimpleName;
    private ConcurrentDictionary`2<string, ConcurrentDictionary`2<ImmutableArray`1<byte>, Tuple`2<Location, string>>> _lazyInternalsVisibleToMap;
    [ThreadStaticAttribute]
private static AssemblySymbol s_AssemblyForWhichCurrentThreadIsComputingKeys;
    private ConcurrentDictionary`2<AssemblySymbol, bool> _optimisticallyGrantedInternalsAccess;
    internal VisualBasicCompilation DeclaringCompilation { get; }
    public bool IsInteractive { get; }
    public AssemblyIdentity Identity { get; }
    public string Name { get; }
    public AttributeLocation DefaultAttributeLocation { get; }
    internal string FileVersion { get; }
    internal string Title { get; }
    internal string Description { get; }
    internal string Company { get; }
    internal string Product { get; }
    internal string InformationalVersion { get; }
    internal string Copyright { get; }
    internal string Trademark { get; }
    internal AssemblyNameFlags Flags { get; }
    private bool DelaySignAttributeSetting { get; }
    internal string AssemblySignatureKeyAttributeSetting { get; }
    private string AssemblyKeyContainerAttributeSetting { get; }
    private string AssemblyKeyFileAttributeSetting { get; }
    private string AssemblyCultureAttributeSetting { get; }
    private Version AssemblyVersionAttributeSetting { get; }
    public Version AssemblyVersionPattern { get; }
    internal AssemblyHashAlgorithm AssemblyHashAlgorithm { get; }
    internal Nullable`1<AssemblyHashAlgorithm> AssemblyAlgorithmIdAttributeSetting { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<ModuleSymbol> Modules { get; }
    internal bool IsLinked { get; }
    internal bool DeclaresTheObjectClass { get; }
    internal SourceModuleSymbol SourceModule { get; }
    public bool MightContainExtensionMethods { get; }
    internal bool IsDelaySigned { get; }
    private bool HasAssemblyOrModuleDebuggableAttribute { get; }
    internal ImmutableArray`1<byte> PublicKey { get; }
    internal StrongNameKeys StrongNameKeys { get; }
    internal bool IsVbRuntime { get; }
    private Compilation ISourceAssemblySymbol_Compilation { get; }
    internal SourceAssemblySymbol(VisualBasicCompilation compilation, string assemblySimpleName, string moduleName, ImmutableArray`1<PEModule> netModules);
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
    public virtual bool get_IsInteractive();
    internal bool MightContainNoPiaLocalTypes();
    public virtual AssemblyIdentity get_Identity();
    internal virtual Symbol GetSpecialTypeMember(SpecialMember member);
    public virtual string get_Name();
    private bool IsKnownAssemblyAttribute(VisualBasicAttributeData attribute);
    private HashSet`1<VisualBasicAttributeData> GetUniqueSourceAssemblyAttributes(HashSet`1& attributeIndicesToSkip);
    private static bool AddUniqueAssemblyAttribute(VisualBasicAttributeData attribute, HashSet`1& uniqueAttributes);
    private bool ValidateAttributeUsageForNetModuleAttribute(VisualBasicAttributeData attribute, string netModuleName, DiagnosticBag diagnostics, HashSet`1& uniqueAttributes);
    private ImmutableArray`1<VisualBasicAttributeData> GetNetModuleAttributes(ImmutableArray`1& netModuleNames);
    private WellKnownAttributeData ValidateAttributeUsageAndDecodeWellKnownNetModuleAttributes(ImmutableArray`1<VisualBasicAttributeData> attributesFromNetModules, ImmutableArray`1<string> netModuleNames, DiagnosticBag diagnostics, HashSet`1& attributeIndicesToSkip);
    private void LoadAndValidateNetModuleAttributes(CustomAttributesBag`1& lazyNetModuleAttributesBag);
    private void EnsureNetModuleAttributesAreBound();
    internal bool IsIndexOfDuplicateAssemblyAttribute(int index);
    public sealed virtual override AttributeLocation get_DefaultAttributeLocation();
    internal ImmutableArray`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    internal CustomAttributesBag`1<VisualBasicAttributeData> GetNetModuleAttributesBag();
    private ImmutableArray`1<VisualBasicAttributeData> GetNetModuleAttributes();
    internal CommonAssemblyWellKnownAttributeData`1<NamedTypeSymbol> GetNetModuleDecodedWellKnownAttributeData();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    internal CustomAttributesBag`1<VisualBasicAttributeData> GetSourceAttributesBag();
    internal CommonAssemblyWellKnownAttributeData`1<NamedTypeSymbol> GetSourceDecodedWellKnownAttributeData();
    private string GetWellKnownAttributeDataStringField(Func`2<CommonAssemblyWellKnownAttributeData`1<NamedTypeSymbol>, string> fieldGetter, string missingValue);
    internal IEnumerable`1<SecurityAttribute> GetSecurityAttributes();
    internal string get_FileVersion();
    internal string get_Title();
    internal string get_Description();
    internal string get_Company();
    internal string get_Product();
    internal string get_InformationalVersion();
    internal string get_Copyright();
    internal string get_Trademark();
    internal AssemblyNameFlags get_Flags();
    private bool get_DelaySignAttributeSetting();
    internal string get_AssemblySignatureKeyAttributeSetting();
    private string get_AssemblyKeyContainerAttributeSetting();
    private string get_AssemblyKeyFileAttributeSetting();
    private string get_AssemblyCultureAttributeSetting();
    private Version get_AssemblyVersionAttributeSetting();
    public virtual Version get_AssemblyVersionPattern();
    internal AssemblyHashAlgorithm get_AssemblyHashAlgorithm();
    internal Nullable`1<AssemblyHashAlgorithm> get_AssemblyAlgorithmIdAttributeSetting();
    private void EnsureAttributesAreBound();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<ModuleSymbol> get_Modules();
    internal virtual ImmutableArray`1<AssemblySymbol> GetNoPiaResolutionAssemblies();
    internal virtual void SetNoPiaResolutionAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal virtual ImmutableArray`1<AssemblySymbol> GetLinkedReferencedAssemblies();
    internal virtual void SetLinkedReferencedAssemblies(ImmutableArray`1<AssemblySymbol> assemblies);
    internal virtual bool get_IsLinked();
    private void CheckOptimisticIVTAccessGrants(DiagnosticBag bag);
    internal virtual IEnumerable`1<ImmutableArray`1<byte>> GetInternalsVisibleToPublicKeys(string simpleName);
    internal bool get_DeclaresTheObjectClass();
    internal SourceModuleSymbol get_SourceModule();
    public virtual bool get_MightContainExtensionMethods();
    private bool ProcessOneInternalsVisibleToAttribute(AttributeSyntax nodeOpt, VisualBasicAttributeData attrData, DiagnosticBag diagnostics);
    internal virtual void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    private static Location GetAssemblyAttributeFirstArgumentLocation(AttributeSyntax attributeSyntaxOpt);
    private void ValidateIntegralAttributeNonNegativeArguments(VisualBasicAttributeData attrData, AttributeSyntax nodeOpt, DiagnosticBag diagnostics);
    internal void AnErrorHasBeenReportedAboutExtensionAttribute();
    internal ImmutableArray`1<Diagnostic> GetAllDeclarationErrors(CancellationToken cancellationToken);
    private ImmutableArray`1<Diagnostic> GetAssemblyLevelDeclarationErrors(bool haveExtensionMethodsInSource);
    private void DetectAttributeAndOptionConflicts(DiagnosticBag diagnostics);
    private void ReportDiagnosticsForAddedModules(DiagnosticBag diagnostics);
    internal bool get_IsDelaySigned();
    protected void ValidateIVTPublicKeys(DiagnosticBag diagnostics);
    private static void ReportDiagnosticsForSynthesizedAttributes(VisualBasicCompilation compilation, DiagnosticBag diagnostics);
    private bool get_HasAssemblyOrModuleDebuggableAttribute();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal virtual ImmutableArray`1<byte> get_PublicKey();
    internal virtual bool AreInternalsVisibleToThisAssembly(AssemblySymbol potentialGiverOfAccess);
    internal StrongNameKeys get_StrongNameKeys();
    private void ComputeAndSetStrongNameKeys();
    private AssemblyIdentity ComputeIdentity();
    internal bool get_IsVbRuntime();
    private bool CheckForRuntime();
    internal virtual NamedTypeSymbol TryLookupForwardedMetadataTypeWithCycleDetection(MetadataTypeName& emittedName, ConsList`1<AssemblySymbol> visitedAssemblies, bool ignoreCase);
    public virtual AssemblyMetadata GetMetadata();
    private sealed virtual override Compilation get_ISourceAssemblySymbol_Compilation();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceAttributeData : VisualBasicAttributeData {
    private NamedTypeSymbol _attributeClass;
    private MethodSymbol _attributeConstructor;
    private ImmutableArray`1<TypedConstant> _constructorArguments;
    private ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> _namedArguments;
    private bool _isConditionallyOmitted;
    private bool _hasErrors;
    private SyntaxReference _applicationNode;
    public NamedTypeSymbol AttributeClass { get; }
    public MethodSymbol AttributeConstructor { get; }
    public SyntaxReference ApplicationSyntaxReference { get; }
    protected ImmutableArray`1<TypedConstant> CommonConstructorArguments { get; }
    protected ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> CommonNamedArguments { get; }
    internal bool IsConditionallyOmitted { get; }
    internal bool HasErrors { get; }
    internal SourceAttributeData(SyntaxReference applicationNode, NamedTypeSymbol attrClass, MethodSymbol attrMethod, ImmutableArray`1<TypedConstant> constructorArgs, ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArgs, bool isConditionallyOmitted, bool hasErrors);
    public virtual NamedTypeSymbol get_AttributeClass();
    public virtual MethodSymbol get_AttributeConstructor();
    public virtual SyntaxReference get_ApplicationSyntaxReference();
    protected virtual ImmutableArray`1<TypedConstant> get_CommonConstructorArguments();
    protected virtual ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> get_CommonNamedArguments();
    internal sealed virtual bool get_IsConditionallyOmitted();
    internal SourceAttributeData WithOmittedCondition(bool isConditionallyOmitted);
    internal sealed virtual bool get_HasErrors();
    internal virtual int GetTargetAttributeSignatureIndex(Symbol targetSymbol, AttributeDescription description);
    internal virtual TypeSymbol GetSystemType(Symbol targetSymbol);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceClonedParameterSymbol : SourceParameterSymbolBase {
    private SourceParameterSymbol _originalParam;
    public bool IsImplicitlyDeclared { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public TypeSymbol Type { get; }
    internal bool IsMetadataIn { get; }
    internal bool IsMetadataOut { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public string Name { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    internal bool HasParamArrayAttribute { get; }
    internal bool HasDefaultValueAttribute { get; }
    public bool HasExplicitDefaultValue { get; }
    internal bool HasOptionCompare { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerMemberName { get; }
    internal bool IsCallerFilePath { get; }
    public bool IsByRef { get; }
    internal bool IsExplicitByRef { get; }
    public bool IsOptional { get; }
    public bool IsParamArray { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal SourceClonedParameterSymbol(SourceParameterSymbol originalParam, MethodSymbol newOwner, int newOrdinal);
    public virtual bool get_IsImplicitlyDeclared();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual TypeSymbol get_Type();
    internal virtual bool get_IsMetadataIn();
    internal virtual bool get_IsMetadataOut();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    public virtual string get_Name();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    internal virtual ushort get_CountOfCustomModifiersPrecedingByRef();
    internal virtual ConstantValue get_ExplicitDefaultConstantValue(SymbolsInProgress`1<ParameterSymbol> inProgress);
    internal virtual bool get_HasParamArrayAttribute();
    internal virtual bool get_HasDefaultValueAttribute();
    public virtual bool get_HasExplicitDefaultValue();
    internal virtual bool get_HasOptionCompare();
    internal virtual bool get_IsIDispatchConstant();
    internal virtual bool get_IsIUnknownConstant();
    internal virtual bool get_IsCallerLineNumber();
    internal virtual bool get_IsCallerMemberName();
    internal virtual bool get_IsCallerFilePath();
    public virtual bool get_IsByRef();
    internal virtual bool get_IsExplicitByRef();
    public virtual bool get_IsOptional();
    public virtual bool get_IsParamArray();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual ParameterSymbol WithTypeAndCustomModifiers(TypeSymbol type, ImmutableArray`1<CustomModifier> customModifiers, ushort countOfCustomModifiersPrecedingByRef);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceComplexParameterSymbol : SourceParameterSymbol {
    private SyntaxReference _syntaxRef;
    private SourceParameterFlags _flags;
    private ConstantValue _lazyDefaultValue;
    private CustomAttributesBag`1<VisualBasicAttributeData> _lazyCustomAttributesBag;
    private SourceParameterSymbol BoundAttributesSource { get; }
    internal SyntaxList`1<AttributeListSyntax> AttributeDeclarationList { get; }
    public bool HasExplicitDefaultValue { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    internal ParameterSyntax SyntaxNode { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsOptional { get; }
    public bool IsParamArray { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerMemberName { get; }
    internal bool IsCallerFilePath { get; }
    internal bool IsExplicitByRef { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    private SourceComplexParameterSymbol(Symbol container, string name, int ordinal, TypeSymbol type, Location location, SyntaxReference syntaxRef, SourceParameterFlags flags, ConstantValue defaultValueOpt);
    private SourceParameterSymbol get_BoundAttributesSource();
    internal virtual SyntaxList`1<AttributeListSyntax> get_AttributeDeclarationList();
    private OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    internal virtual CustomAttributesBag`1<VisualBasicAttributeData> GetAttributesBag();
    internal virtual ParameterEarlyWellKnownAttributeData GetEarlyDecodedWellKnownAttributeData();
    internal virtual CommonParameterWellKnownAttributeData GetDecodedWellKnownAttributeData();
    public virtual bool get_HasExplicitDefaultValue();
    internal virtual ConstantValue get_ExplicitDefaultConstantValue(SymbolsInProgress`1<ParameterSymbol> inProgress);
    private ConstantValue BindDefaultValue(SymbolsInProgress`1<ParameterSymbol> inProgress, DiagnosticBag diagnostics);
    internal ParameterSyntax get_SyntaxNode();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal sealed virtual bool IsDefinedInSourceTree(SyntaxTree tree, Nullable`1<TextSpan> definedWithinSpan, CancellationToken cancellationToken);
    public virtual bool get_IsOptional();
    public virtual bool get_IsParamArray();
    internal virtual bool get_IsCallerLineNumber();
    internal virtual bool get_IsCallerMemberName();
    internal virtual bool get_IsCallerFilePath();
    internal virtual bool get_IsExplicitByRef();
    internal static ParameterSymbol Create(Symbol container, string name, int ordinal, TypeSymbol type, Location location, SyntaxReference syntaxRef, SourceParameterFlags flags, ConstantValue defaultValueOpt);
    internal virtual ParameterSymbol ChangeOwner(Symbol newContainingSymbol);
    internal static ParameterSymbol CreateFromSyntax(Symbol container, ParameterSyntax syntax, string name, SourceParameterFlags flags, int ordinal, Binder binder, CheckParameterModifierDelegate checkModifier, DiagnosticBag diagnostics);
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    internal virtual ushort get_CountOfCustomModifiersPrecedingByRef();
    internal virtual ParameterSymbol WithTypeAndCustomModifiers(TypeSymbol type, ImmutableArray`1<CustomModifier> customModifiers, ushort countOfCustomModifiersPrecedingByRef);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceDeclareMethodSymbol : SourceNonPropertyAccessorMethodSymbol {
    private string _name;
    private string _lazyMetadataName;
    private QuickAttributes _quickAttributes;
    private DllImportData _platformInvokeInfo;
    public string Name { get; }
    public string MetadataName { get; }
    public bool IsExternalMethod { get; }
    internal bool MayBeReducibleExtensionMethod { get; }
    public bool IsExtensionMethod { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    public SourceDeclareMethodSymbol(SourceMemberContainerTypeSymbol container, string name, SourceMemberFlags flags, Binder binder, MethodBaseSyntax syntax, DllImportData platformInvokeInfo);
    public virtual string get_Name();
    public virtual string get_MetadataName();
    internal virtual void SetMetadataName(string metadataName);
    public virtual bool get_IsExternalMethod();
    internal virtual bool get_MayBeReducibleExtensionMethod();
    public virtual bool get_IsExtensionMethod();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual DllImportData GetDllImportData();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceDelegateMethodSymbol : SourceMethodSymbol {
    private ImmutableArray`1<ParameterSymbol> _parameters;
    private TypeSymbol _returnType;
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    internal OverriddenMembersResult`1<MethodSymbol> OverriddenMembers { get; }
    public bool IsExtensionMethod { get; }
    internal bool MayBeReducibleExtensionMethod { get; }
    public bool IsExternalMethod { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool GenerateDebugInfoImpl { get; }
    internal bool HasSpecialName { get; }
    protected SourceDelegateMethodSymbol(NamedTypeSymbol delegateType, VisualBasicSyntaxNode syntax, Binder binder, SourceMemberFlags flags, TypeSymbol returnType);
    protected void InitializeParameters(ImmutableArray`1<ParameterSymbol> parameters);
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal virtual OverriddenMembersResult`1<MethodSymbol> get_OverriddenMembers();
    internal static void MakeDelegateMembers(NamedTypeSymbol delegateType, VisualBasicSyntaxNode syntax, ParameterListSyntax parameterListOpt, Binder binder, MethodSymbol& constructor, MethodSymbol& beginInvoke, MethodSymbol& endInvoke, MethodSymbol& invoke, DiagnosticBag diagnostics);
    private static TypeSymbol BindReturnType(VisualBasicSyntaxNode syntax, Binder binder, DiagnosticBag diagnostics);
    public sealed virtual bool get_IsExtensionMethod();
    internal virtual bool get_MayBeReducibleExtensionMethod();
    public sealed virtual bool get_IsExternalMethod();
    public sealed virtual DllImportData GetDllImportData();
    internal sealed virtual MethodImplAttributes get_ImplementationAttributes();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public sealed virtual bool get_IsImplicitlyDeclared();
    internal virtual bool get_GenerateDebugInfoImpl();
    internal sealed virtual bool get_HasSpecialName();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    protected sealed virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceEnumConstantSymbol : SourceFieldSymbol {
    private EvaluatedConstant _constantTuple;
    internal VisualBasicSyntaxNode DeclarationSyntax { get; }
    internal OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public TypeSymbol Type { get; }
    internal ParameterSymbol MeParameter { get; }
    protected SourceEnumConstantSymbol(SourceNamedTypeSymbol containingEnum, Binder bodyBinder, EnumMemberDeclarationSyntax syntax, DiagnosticBag diagnostics);
    public static SourceEnumConstantSymbol CreateExplicitValuedConstant(SourceNamedTypeSymbol containingEnum, Binder bodyBinder, EnumMemberDeclarationSyntax syntax, DiagnosticBag diagnostics);
    public static SourceEnumConstantSymbol CreateImplicitValuedConstant(SourceNamedTypeSymbol containingEnum, Binder bodyBinder, EnumMemberDeclarationSyntax syntax, SourceEnumConstantSymbol otherConstant, int otherConstantOffset, DiagnosticBag diagnostics);
    internal sealed virtual VisualBasicSyntaxNode get_DeclarationSyntax();
    internal sealed virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> get_GetAttributeDeclarations();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public sealed virtual TypeSymbol get_Type();
    internal virtual ConstantValue GetConstantValue(SymbolsInProgress`1<FieldSymbol> inProgress);
    internal virtual ParameterSymbol get_MeParameter();
    protected abstract virtual EvaluatedConstant MakeConstantTuple(SymbolsInProgress`1<FieldSymbol> inProgress, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceEventSymbol : EventSymbol {
    private SourceMemberContainerTypeSymbol _containingType;
    private string _name;
    private SyntaxReference _syntaxRef;
    private Location _location;
    private SourceMemberFlags _memberFlags;
    private MethodSymbol _addMethod;
    private MethodSymbol _removeMethod;
    private MethodSymbol _raiseMethod;
    private FieldSymbol _backingField;
    private int _lazyState;
    private TypeSymbol _lazyType;
    private ImmutableArray`1<EventSymbol> _lazyImplementedEvents;
    private ImmutableArray`1<ParameterSymbol> _lazyDelegateParameters;
    private string _lazyDocComment;
    private CustomAttributesBag`1<VisualBasicAttributeData> _lazyCustomAttributesBag;
    internal bool IsTypeInferred { get; }
    internal ImmutableArray`1<ParameterSymbol> DelegateParameters { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public SourceModuleSymbol ContainingSourceModule { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public TypeSymbol Type { get; }
    public string Name { get; }
    public MethodSymbol AddMethod { get; }
    public MethodSymbol RemoveMethod { get; }
    public MethodSymbol RaiseMethod { get; }
    internal FieldSymbol AssociatedField { get; }
    public ImmutableArray`1<EventSymbol> ExplicitInterfaceImplementations { get; }
    internal SyntaxReference SyntaxReference { get; }
    public bool IsShared { get; }
    public bool IsMustOverride { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsNotOverridable { get; }
    public Accessibility DeclaredAccessibility { get; }
    internal bool ShadowsExplicitly { get; }
    internal SyntaxList`1<AttributeListSyntax> AttributeDeclarationSyntaxList { get; }
    public AttributeLocation DefaultAttributeLocation { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool HasSpecialName { get; }
    public bool IsWindowsRuntimeEvent { get; }
    internal SourceEventSymbol(SourceMemberContainerTypeSymbol containingType, Binder binder, EventStatementSyntax syntax, EventBlockSyntax blockSyntaxOpt, DiagnosticBag diagnostics);
    internal bool get_IsTypeInferred();
    private TypeSymbol ComputeType(DiagnosticBag diagnostics, Boolean& isTypeInferred, Boolean& isDelegateFromImplements);
    private ImmutableArray`1<EventSymbol> ComputeImplementedEvents(DiagnosticBag diagnostics);
    private void CheckExplicitImplementationTypes();
    internal virtual ImmutableArray`1<ParameterSymbol> get_DelegateParameters();
    private CustomEventAccessorSymbol BindEventAccessor(AccessorBlockSyntax blockSyntax, Binder binder);
    private bool IsImplementing();
    internal ImmutableArray`1<MethodSymbol> GetAccessorImplementations(MethodKind kind);
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public SourceModuleSymbol get_ContainingSourceModule();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal sealed virtual bool IsDefinedInSourceTree(SyntaxTree tree, Nullable`1<TextSpan> definedWithinSpan, CancellationToken cancellationToken);
    public virtual TypeSymbol get_Type();
    public virtual string get_Name();
    public virtual MethodSymbol get_AddMethod();
    public virtual MethodSymbol get_RemoveMethod();
    public virtual MethodSymbol get_RaiseMethod();
    internal virtual FieldSymbol get_AssociatedField();
    public virtual ImmutableArray`1<EventSymbol> get_ExplicitInterfaceImplementations();
    internal SyntaxReference get_SyntaxReference();
    public virtual bool get_IsShared();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsNotOverridable();
    public virtual Accessibility get_DeclaredAccessibility();
    internal virtual bool get_ShadowsExplicitly();
    internal SyntaxList`1<AttributeListSyntax> get_AttributeDeclarationSyntaxList();
    public sealed virtual override AttributeLocation get_DefaultAttributeLocation();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public sealed virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    private CustomAttributesBag`1<VisualBasicAttributeData> GetAttributesBag();
    internal EventWellKnownAttributeData GetDecodedWellKnownAttributeData();
    internal virtual VisualBasicAttributeData EarlyDecodeWellKnownAttribute(EarlyDecodeWellKnownAttributeArguments`4& arguments);
    internal virtual void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    internal virtual bool get_HasSpecialName();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal static MemberModifiers DecodeModifiers(SyntaxTokenList modifiers, SourceMemberContainerTypeSymbol container, Binder binder, DiagnosticBag diagBag);
    internal Location GetImplementingLocation(EventSymbol implementedEvent);
    private Binder CreateBinderForTypeDeclaration();
    internal virtual void GenerateDeclarationErrors(CancellationToken cancellationToken);
    public virtual bool get_IsWindowsRuntimeEvent();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFieldSymbol : FieldSymbol {
    protected SourceMemberFlags m_memberFlags;
    private SourceMemberContainerTypeSymbol _containingType;
    private string _name;
    private SyntaxReference _syntaxRef;
    private string _lazyDocComment;
    private CustomAttributesBag`1<VisualBasicAttributeData> _lazyCustomAttributesBag;
    private int _eventProduced;
    internal SyntaxTree SyntaxTree { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    internal VisualBasicSyntaxNode DeclarationSyntax { get; }
    internal VisualBasicSyntaxNode EqualsValueOrAsNewInitOpt { get; }
    public string Name { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public SourceMemberContainerTypeSymbol ContainingSourceType { get; }
    internal bool HasDeclaredType { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public Symbol AssociatedSymbol { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsReadOnly { get; }
    public bool IsConst { get; }
    public bool IsShared { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool ShadowsExplicitly { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations { get; }
    public AttributeLocation DefaultAttributeLocation { get; }
    internal bool HasSpecialName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal bool IsNotSerialized { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal Nullable`1<int> TypeLayoutOffset { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    protected SourceFieldSymbol(SourceMemberContainerTypeSymbol container, SyntaxReference syntaxRef, string name, SourceMemberFlags memberFlags);
    internal virtual void GenerateDeclarationErrors(CancellationToken cancellationToken);
    internal SyntaxTree get_SyntaxTree();
    internal VisualBasicSyntaxNode get_Syntax();
    internal abstract virtual VisualBasicSyntaxNode get_DeclarationSyntax();
    internal virtual VisualBasicSyntaxNode get_EqualsValueOrAsNewInitOpt();
    public sealed virtual string get_Name();
    public sealed virtual Symbol get_ContainingSymbol();
    public sealed virtual NamedTypeSymbol get_ContainingType();
    public SourceMemberContainerTypeSymbol get_ContainingSourceType();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual bool get_HasDeclaredType();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual Symbol get_AssociatedSymbol();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsConst();
    internal virtual ConstantValue GetConstantValue(SymbolsInProgress`1<FieldSymbol> inProgress);
    public virtual bool get_IsShared();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual bool get_ShadowsExplicitly();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal abstract virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> get_GetAttributeDeclarations();
    public sealed virtual override AttributeLocation get_DefaultAttributeLocation();
    public sealed virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    private CustomAttributesBag`1<VisualBasicAttributeData> GetAttributesBag();
    private CommonFieldWellKnownAttributeData GetDecodedWellKnownAttributeData();
    internal void SetCustomAttributeData(CustomAttributesBag`1<VisualBasicAttributeData> attributeData);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal sealed virtual VisualBasicAttributeData EarlyDecodeWellKnownAttribute(EarlyDecodeWellKnownAttributeArguments`4& arguments);
    internal sealed virtual void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    private void VerifyConstantValueMatches(ConstantValue attrValue, DecodeWellKnownAttributeArguments`3& arguments);
    internal sealed virtual bool get_HasSpecialName();
    internal sealed virtual bool get_HasRuntimeSpecialName();
    internal sealed virtual bool get_IsNotSerialized();
    internal sealed virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal sealed virtual Nullable`1<int> get_TypeLayoutOffset();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    private static Location GetSymbolLocation(SyntaxReference syntaxRef);
    private static TextSpan GetFieldLocationFromSyntax(SyntaxToken node);
    internal static Symbol FindFieldOrWithEventsSymbolFromSyntax(SyntaxToken variableName, SyntaxTree tree, NamedTypeSymbol container);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceFile : object {
    private SourceModuleSymbol _sourceModule;
    private SyntaxTree _syntaxTree;
    private DiagnosticBag _diagnosticBagDeclare;
    private DiagnosticBag _diagnosticBagCompile;
    private DiagnosticBag _diagnosticBagEmit;
    private BoundFileInformation _lazyBoundInformation;
    private int _importsValidated;
    private QuickAttributeChecker _lazyQuickAttributeChecker;
    private ImmutableArray`1<UsedNamespaceOrType> _lazyTranslatedImports;
    public DiagnosticBag DeclarationErrors { get; }
    public QuickAttributeChecker QuickAttributeChecker { get; }
    private BoundFileInformation BoundInformation { get; }
    public ImmutableArray`1<NamespaceOrTypeAndImportsClausePosition> MemberImports { get; }
    public IReadOnlyDictionary`2<string, AliasAndImportsClausePosition> AliasImportsOpt { get; }
    public IReadOnlyDictionary`2<string, XmlNamespaceAndImportsClausePosition> XmlNamespacesOpt { get; }
    public Nullable`1<bool> OptionStrict { get; }
    public Nullable`1<bool> OptionInfer { get; }
    public Nullable`1<bool> OptionExplicit { get; }
    public Nullable`1<bool> OptionCompareText { get; }
    public IImportScope Parent { get; }
    public SourceFile(SourceModuleSymbol sourceModule, SyntaxTree tree);
    public DiagnosticBag get_DeclarationErrors();
    public void AddDiagnostic(Diagnostic d, CompilationStage stage);
    public QuickAttributeChecker get_QuickAttributeChecker();
    private QuickAttributeChecker CreateQuickAttributeChecker();
    private BoundFileInformation get_BoundInformation();
    private BoundFileInformation GetBoundInformation(CancellationToken cancellationToken);
    private void EnsureImportsValidated();
    private BoundFileInformation BindFileInformation(DiagnosticBag diagBag, CancellationToken cancellationToken, Nullable`1<TextSpan> filterSpan);
    private static void BindOptions(SyntaxList`1<OptionStatementSyntax> optionsSyntax, Binder binder, DiagnosticBag diagBag, Nullable`1& optionStrict, Nullable`1& optionInfer, Nullable`1& optionExplicit, Nullable`1& optionCompareText, Nullable`1<TextSpan> filterSpan);
    private static void BindImports(SyntaxList`1<ImportsStatementSyntax> importsListSyntax, Binder binder, DiagnosticBag diagBag, ImmutableArray`1& importMembersOf, ImmutableArray`1& importMembersOfSyntax, IReadOnlyDictionary`2& importAliasesOpt, IReadOnlyDictionary`2& xmlNamespacesOpt, CancellationToken cancellationToken, Nullable`1<TextSpan> filterSpan);
    private static void ValidateImports(ImmutableArray`1<NamespaceOrTypeAndImportsClausePosition> memberImports, ImmutableArray`1<SyntaxReference> memberImportsSyntax, IReadOnlyDictionary`2<string, AliasAndImportsClausePosition> aliasImportsOpt, DiagnosticBag diagnostics);
    public ImmutableArray`1<NamespaceOrTypeAndImportsClausePosition> get_MemberImports();
    public IReadOnlyDictionary`2<string, AliasAndImportsClausePosition> get_AliasImportsOpt();
    public IReadOnlyDictionary`2<string, XmlNamespaceAndImportsClausePosition> get_XmlNamespacesOpt();
    public Nullable`1<bool> get_OptionStrict();
    public Nullable`1<bool> get_OptionInfer();
    public Nullable`1<bool> get_OptionExplicit();
    public Nullable`1<bool> get_OptionCompareText();
    internal void GenerateAllDeclarationErrors();
    internal IEnumerable`1<Diagnostic> GetDeclarationErrorsInSpan(TextSpan filterSpan, CancellationToken cancellationToken);
    public sealed virtual override IImportScope get_Parent();
    public IImportScope Translate(PEModuleBuilder moduleBuilder, DiagnosticBag diagnostics);
    public sealed virtual override ImmutableArray`1<UsedNamespaceOrType> GetUsedNamespaces();
    private ImmutableArray`1<UsedNamespaceOrType> TranslateImports(PEModuleBuilder moduleBuilder, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceLabelSymbol : LabelSymbol {
    private SyntaxToken _labelName;
    private MethodSymbol _containingMethod;
    private Binder _binder;
    internal SyntaxToken LabelName { get; }
    public MethodSymbol ContainingMethod { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public SourceLabelSymbol(SyntaxToken labelNameToken, MethodSymbol containingMethod, Binder binder);
    internal virtual SyntaxToken get_LabelName();
    public virtual MethodSymbol get_ContainingMethod();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceLambdaSymbol : LambdaSymbol {
    private UnboundLambda _unboundLambda;
    private NamedTypeSymbol _lazyAnonymousDelegateSymbol;
    public UnboundLambda UnboundLambda { get; }
    public SynthesizedLambdaKind SynthesizedKind { get; }
    public bool IsAsync { get; }
    public bool IsIterator { get; }
    public NamedTypeSymbol AssociatedAnonymousDelegate { get; }
    public SourceLambdaSymbol(VisualBasicSyntaxNode syntaxNode, UnboundLambda unboundLambda, ImmutableArray`1<BoundLambdaParameterSymbol> parameters, TypeSymbol returnType, Binder binder);
    public UnboundLambda get_UnboundLambda();
    public virtual SynthesizedLambdaKind get_SynthesizedKind();
    public virtual bool get_IsAsync();
    public virtual bool get_IsIterator();
    public virtual NamedTypeSymbol get_AssociatedAnonymousDelegate();
    internal NamedTypeSymbol MakeAssociatedAnonymousDelegate();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol : InstanceTypeSymbol {
    private SourceTypeFlags _flags;
    protected int m_lazyState;
    private NamespaceOrTypeSymbol _containingSymbol;
    protected SourceModuleSymbol m_containingModule;
    private MergedTypeDeclaration _declaration;
    private string _name;
    private string _defaultPropertyName;
    private MembersAndInitializers _lazyMembersAndInitializers;
    private static Dictionary`2<string, ImmutableArray`1<NamedTypeSymbol>> s_emptyTypeMembers;
    private Dictionary`2<string, ImmutableArray`1<NamedTypeSymbol>> _lazyTypeMembers;
    private ImmutableArray`1<Symbol> _lazyMembersFlattened;
    private ImmutableArray`1<TypeParameterSymbol> _lazyTypeParameters;
    private ThreeState _lazyEmitExtensionAttribute;
    private ThreeState _lazyContainsExtensionMethods;
    private ThreeState _lazyAnyMemberHasAttributes;
    private int _lazyStructureCycle;
    private LexicalSortKey _lazyLexicalSortKey;
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public ModuleSymbol ContainingModule { get; }
    public SourceModuleSymbol ContainingSourceModule { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsMustInherit { get; }
    public bool IsNotInheritable { get; }
    internal bool ShadowsExplicitly { get; }
    public TypeKind TypeKind { get; }
    internal bool IsInterface { get; }
    internal bool IsPartial { get; }
    internal MergedTypeDeclaration TypeDeclaration { get; }
    public bool IsImplicitlyDeclared { get; }
    public bool IsScriptClass { get; }
    public bool IsImplicitClass { get; }
    public int Arity { get; }
    internal DeclarationKind DeclarationKind { get; }
    public string Name { get; }
    internal bool MangleName { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> SyntaxReferences { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal string DefaultPropertyName { get; }
    private MembersAndInitializers MemberAndInitializerLookup { get; }
    internal bool MembersHaveBeenCreated { get; }
    internal bool KnownCircularStruct { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public ImmutableArray`1<ImmutableArray`1<FieldOrPropertyInitializer>> StaticInitializers { get; }
    public ImmutableArray`1<ImmutableArray`1<FieldOrPropertyInitializer>> InstanceInitializers { get; }
    public bool MightContainExtensionMethods { get; }
    internal Dictionary`2<Symbol, Symbol> ExplicitInterfaceImplementationMap { get; }
    private bool EmitExtensionAttribute { get; }
    internal bool AnyMemberHasAttributes { get; }
    private static SourceMemberContainerTypeSymbol();
    protected SourceMemberContainerTypeSymbol(MergedTypeDeclaration declaration, NamespaceOrTypeSymbol containingSymbol, SourceModuleSymbol containingModule);
    private static string GetBestName(MergedTypeDeclaration declaration, VisualBasicCompilation compilation);
    private SourceTypeFlags ComputeTypeFlags(MergedTypeDeclaration declaration, bool isTopLevel);
    public static SourceMemberContainerTypeSymbol Create(MergedTypeDeclaration declaration, NamespaceOrTypeSymbol containingSymbol, SourceModuleSymbol containingModule);
    private NamedTypeSymbol CreateNestedType(MergedTypeDeclaration declaration);
    internal sealed virtual void GenerateDeclarationErrors(CancellationToken cancellationToken);
    protected virtual void GenerateAllDeclarationErrorsImpl(CancellationToken cancellationToken);
    private void GenerateVarianceDiagnostics();
    private void ReportNestingIntoVariantInterface(DiagnosticBag& diagnostics);
    private void GenerateVarianceDiagnosticsForInterface(DiagnosticBag& diagnostics, ArrayBuilder`1& infosBuffer);
    private Location GetImplementsLocation(NamedTypeSymbol implementedInterface, NamedTypeSymbol& directInterface);
    private Location GetImplementsLocation(NamedTypeSymbol implementedInterface);
    protected abstract virtual Location GetInheritsOrImplementsLocation(NamedTypeSymbol base, bool getInherits);
    private void GenerateVarianceDiagnosticsForDelegate(DiagnosticBag& diagnostics, ArrayBuilder`1& infosBuffer);
    private static void ReportDiagnostics(DiagnosticBag& diagnostics, Location location, ArrayBuilder`1<DiagnosticInfo> infos);
    private static bool HaveDiagnostics(ArrayBuilder`1<DiagnosticInfo> diagnostics);
    private void GenerateVarianceDiagnosticsForType(TypeSymbol type, VarianceKind requiredVariance, VarianceContext context, ArrayBuilder`1& diagnostics);
    private static void AppendVarianceDiagnosticInfo(ArrayBuilder`1& diagnostics, DiagnosticInfo info);
    private void GenerateVarianceDiagnosticsForTypeRecursively(TypeSymbol type, VarianceKind requiredVariance, VarianceContext context, VarianceDiagnosticsTargetTypeParameter typeParameterInfo, int constructionDepth, ArrayBuilder`1& diagnostics);
    private void GenerateVarianceDiagnosticsForMethod(MethodSymbol method, DiagnosticBag& diagnostics, ArrayBuilder`1& infosBuffer);
    private void GenerateVarianceDiagnosticsForParameters(ImmutableArray`1<ParameterSymbol> parameters, DiagnosticBag& diagnostics, ArrayBuilder`1& infosBuffer);
    private void GenerateVarianceDiagnosticsForConstraints(ImmutableArray`1<TypeParameterSymbol> parameters, DiagnosticBag& diagnostics, ArrayBuilder`1& infosBuffer);
    private void GenerateVarianceDiagnosticsForProperty(PropertySymbol property, DiagnosticBag& diagnostics, ArrayBuilder`1& infosBuffer);
    private void GenerateVarianceDiagnosticsForEvent(EventSymbol event, DiagnosticBag& diagnostics, ArrayBuilder`1& infosBuffer);
    private void BindAllMemberAttributes(CancellationToken cancellationToken);
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual ModuleSymbol get_ContainingModule();
    public SourceModuleSymbol get_ContainingSourceModule();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsMustInherit();
    public virtual bool get_IsNotInheritable();
    internal virtual bool get_ShadowsExplicitly();
    public virtual TypeKind get_TypeKind();
    internal virtual bool get_IsInterface();
    internal bool get_IsPartial();
    internal MergedTypeDeclaration get_TypeDeclaration();
    public virtual bool get_IsImplicitlyDeclared();
    public sealed virtual bool get_IsScriptClass();
    public sealed virtual bool get_IsImplicitClass();
    public sealed virtual int get_Arity();
    internal DeclarationKind get_DeclarationKind();
    public sealed virtual string get_Name();
    internal sealed virtual bool get_MangleName();
    internal virtual string GetEmittedNamespaceName();
    internal sealed virtual LexicalSortKey GetLexicalSortKey();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public ImmutableArray`1<SyntaxReference> get_SyntaxReferences();
    public sealed virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal static SourceNamedTypeSymbol FindSymbolFromSyntax(TypeStatementSyntax declarationSyntax, NamespaceOrTypeSymbol container, ModuleSymbol sourceModule);
    internal static SourceNamedTypeSymbol FindSymbolFromSyntax(EnumStatementSyntax declarationSyntax, NamespaceOrTypeSymbol container, ModuleSymbol sourceModule);
    internal static SourceNamedTypeSymbol FindSymbolFromSyntax(DelegateStatementSyntax declarationSyntax, NamespaceOrTypeSymbol container, ModuleSymbol sourceModule);
    private static SourceNamedTypeSymbol FindSymbolInContainer(string childName, int childArity, DeclarationKind childDeclKind, NamespaceOrTypeSymbol container, ModuleSymbol sourceModule);
    internal static void AddInitializer(ArrayBuilder`1& initializers, Func`2<int, FieldOrPropertyInitializer> computeInitializer, Int32& aggregateSyntaxLength);
    internal static void AddInitializers(ArrayBuilder`1& allInitializers, ArrayBuilder`1<FieldOrPropertyInitializer> siblings);
    protected Dictionary`2<string, ImmutableArray`1<NamedTypeSymbol>> GetTypeMembersDictionary();
    private Dictionary`2<string, ImmutableArray`1<NamedTypeSymbol>> MakeTypeMembers();
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembersUnordered();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    internal virtual string get_DefaultPropertyName();
    private MembersAndInitializers get_MemberAndInitializerLookup();
    private MembersAndInitializers GetMembersAndInitializers();
    internal bool get_MembersHaveBeenCreated();
    private MembersAndInitializers BuildMembersAndInitializers(DiagnosticBag diagBag);
    private HashSet`1<SourceMemberMethodSymbol> FindPartialMethodDeclarations(DiagnosticBag diagnostics, Dictionary`2<string, ImmutableArray`1<Symbol>> members);
    private void ProcessPartialMethodsIfAny(Dictionary`2<string, ImmutableArray`1<Symbol>> members, DiagnosticBag diagnostics);
    private void ReportErrorsOnPartialMethodImplementation(SourceMethodSymbol partialMethod, SourceMethodSymbol implMethod, Location implMethodLocation, DiagnosticBag diagnostics);
    private bool ComparePartialMethodSignatures(SourceMethodSymbol partialDeclaration, SourceMethodSymbol candidate);
    internal virtual bool get_KnownCircularStruct();
    private bool CheckStructureCircularity(DiagnosticBag diagnostics);
    internal bool DetectTypeCircularity_ShouldStepIntoType(NamedTypeSymbol typeToTest);
    private string DetermineDefaultPropertyName(Dictionary`2<string, ImmutableArray`1<Symbol>> membersByName, DiagnosticBag diagBag);
    private void CheckDefaultPropertyAgainstAllBases(NamedTypeSymbol namedType, string defaultPropertyName, Location location, DiagnosticBag diagBag);
    private void CheckDefaultPropertyAgainstBase(string defaultPropertyName, NamedTypeSymbol baseType, Location location, DiagnosticBag diagBag);
    internal bool AnyInitializerToBeInjectedIntoConstructor(IEnumerable`1<ImmutableArray`1<FieldOrPropertyInitializer>> initializerSet, bool includingNonMetadataConstants);
    private void CheckForOverloadOverridesShadowsClashesInSameType(MembersAndInitializers membersAndInitializers, DiagnosticBag diagBag);
    private bool GetExplicitSymbolFlags(Symbol symbol, Boolean& shadowsExplicitly, Boolean& overloadsExplicitly, Boolean& overridesExplicitly);
    private MembersAndInitializers BuildNonTypeMembers(DiagnosticBag diagnostics);
    protected virtual void AddEntryPointIfNeeded(MembersAndInitializersBuilder membersBuilder);
    protected abstract virtual void AddDeclaredNonTypeMembers(MembersAndInitializersBuilder membersBuilder, DiagnosticBag diagnostics);
    protected virtual void AddGroupClassMembersIfNeeded(MembersAndInitializersBuilder membersBuilder, DiagnosticBag diagnostics);
    protected void AddMember(StatementSyntax memberSyntax, Binder binder, DiagnosticBag diagBag, MembersAndInitializersBuilder members, ArrayBuilder`1& staticInitializers, ArrayBuilder`1& instanceInitializers, bool reportAsInvalid);
    private void CreateProperty(PropertyStatementSyntax syntax, PropertyBlockSyntax blockSyntaxOpt, Binder binder, DiagnosticBag diagBag, MembersAndInitializersBuilder members, ArrayBuilder`1& staticInitializers, ArrayBuilder`1& instanceInitializers);
    private void CreateEvent(EventStatementSyntax syntax, EventBlockSyntax blockSyntaxOpt, Binder binder, DiagnosticBag diagBag, MembersAndInitializersBuilder members);
    private SourceMethodSymbol CreateMethodMember(MethodBaseSyntax methodBaseSyntax, Binder binder, DiagnosticBag diagBag);
    private void AddDefaultConstructorIfNeeded(MembersAndInitializersBuilder members, bool isShared, ArrayBuilder`1<ImmutableArray`1<FieldOrPropertyInitializer>> initializers, DiagnosticBag diagnostics);
    private void EnsureCtor(MembersAndInitializersBuilder members, bool isShared, bool isDebuggable, DiagnosticBag diagBag);
    private void AddWithEventsHookupConstructorsIfNeeded(MembersAndInitializersBuilder members, DiagnosticBag diagBag);
    private void AddPropertyAndAccessors(SourcePropertySymbol propertySymbol, Binder binder, MembersAndInitializersBuilder members);
    private void AddEventAndAccessors(SourceEventSymbol eventSymbol, Binder binder, MembersAndInitializersBuilder members);
    private void CheckMemberDiagnostics(MembersAndInitializersBuilder members, DiagnosticBag diagBag);
    internal void AddMember(Symbol sym, Binder binder, MembersAndInitializersBuilder members, bool omitDiagnostics);
    internal void AddSymbolToMembers(Symbol memberSymbol, Dictionary`2<string, ArrayBuilder`1<Symbol>> members);
    private bool CheckIfMemberNameConflictsWithTypeMember(Symbol sym, MembersAndInitializersBuilder members, DiagnosticBag diagBag);
    private bool CheckIfMemberNameIsDuplicate(Symbol sym, DiagnosticBag diagBag, MembersAndInitializersBuilder members);
    private bool CheckIfMemberNameIsDuplicate(Symbol firstSymbol, Symbol secondSymbol, MembersAndInitializersBuilder members, DiagnosticBag diagBag, bool includeKind);
    public virtual IEnumerable`1<string> get_MemberNames();
    internal virtual ImmutableArray`1<Symbol> GetMembersUnordered();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    internal virtual ImmutableArray`1<Symbol> GetSimpleNonTypeMembers(string name);
    internal MethodSymbol CreateSharedConstructorsForConstFieldsIfRequired(Binder binder, DiagnosticBag diagnostics);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberContainerTypeSymbol/VB$StateMachine_156_GetFieldsToEmit")]
internal virtual IEnumerable`1<FieldSymbol> GetFieldsToEmit();
    public ImmutableArray`1<ImmutableArray`1<FieldOrPropertyInitializer>> get_StaticInitializers();
    public ImmutableArray`1<ImmutableArray`1<FieldOrPropertyInitializer>> get_InstanceInitializers();
    internal int CalculateSyntaxOffsetInSynthesizedConstructor(int position, SyntaxTree tree, bool isShared);
    internal bool TryCalculateSyntaxOffsetOfPositionInInitializer(int position, SyntaxTree tree, bool isShared, Int32& syntaxOffset);
    private static ImmutableArray`1<FieldOrPropertyInitializer> GetInitializersInSourceTree(SyntaxTree tree, ImmutableArray`1<ImmutableArray`1<FieldOrPropertyInitializer>> initializers);
    private static int IndexOfInitializerContainingPosition(ImmutableArray`1<FieldOrPropertyInitializer> initializers, int position);
    public virtual bool get_MightContainExtensionMethods();
    internal virtual void BuildExtensionMethodsMap(Dictionary`2<string, ArrayBuilder`1<MethodSymbol>> map, NamespaceSymbol appendThrough);
    internal virtual void AddExtensionMethodLookupSymbolsInfo(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder, NamedTypeSymbol appendThrough);
    private Dictionary`2<Symbol, Symbol> MakeExplicitInterfaceImplementationMap(DiagnosticBag diagnostics);
    private bool ShouldReportImplementationError(Symbol interfaceMember);
    internal virtual Dictionary`2<Symbol, Symbol> get_ExplicitInterfaceImplementationMap();
    private void CheckForOverloadsErrors(DiagnosticBag diagnostics);
    private bool CheckForOperatorOverloadingErrors(ImmutableArray`1<Symbol> memberList, int memberIndex, Enumerator<string, ImmutableArray`1<Symbol>> membersEnumerator, HashSet`1& operatorsKnownToHavePair, DiagnosticBag diagnostics);
    private bool IsConflictingOperatorOverloading(MethodSymbol method, SymbolComparisonResults significantDiff, ImmutableArray`1<Symbol> memberList, int memberIndex, DiagnosticBag diagnostics);
    private void CheckInterfaceUnificationAndVariance(DiagnosticBag diagnostics);
    private void ReportOverloadsErrors(SymbolComparisonResults comparisonResults, Symbol firstMember, Symbol secondMember, Location location, DiagnosticBag diagnostics);
    private void ReportInterfaceUnificationError(DiagnosticBag diagnostics, NamedTypeSymbol interface1, NamedTypeSymbol interface2);
    private void ReportVarianceAmbiguityWarning(DiagnosticBag diagnostics, NamedTypeSymbol interface1, NamedTypeSymbol interface2);
    protected void SuppressExtensionAttributeSynthesis();
    private bool get_EmitExtensionAttribute();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal bool get_AnyMemberHasAttributes();
    [CompilerGeneratedAttribute]
private NamedTypeSymbol _Lambda$__102-0(MergedTypeDeclaration decl);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberFieldSymbol : SourceFieldSymbol {
    private TypeSymbol _lazyType;
    private ParameterSymbol _lazyMeParameter;
    internal VisualBasicSyntaxNode DeclarationSyntax { get; }
    internal OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations { get; }
    internal ParameterSymbol MeParameter { get; }
    public TypeSymbol Type { get; }
    protected SourceMemberFieldSymbol(SourceMemberContainerTypeSymbol container, SyntaxReference syntaxRef, string name, SourceMemberFlags memberFlags);
    internal sealed virtual VisualBasicSyntaxNode get_DeclarationSyntax();
    internal sealed virtual bool IsDefinedInSourceTree(SyntaxTree tree, Nullable`1<TextSpan> definedWithinSpan, CancellationToken cancellationToken);
    internal sealed virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> get_GetAttributeDeclarations();
    internal virtual ParameterSymbol get_MeParameter();
    public virtual TypeSymbol get_Type();
    private TypeSymbol ComputeType(DiagnosticBag diagBag);
    private TypeSymbol GetDeclaredType(DiagnosticBag diagBag);
    private static TypeSymbol ComputeFieldType(ModifiedIdentifierSyntax modifiedIdentifierSyntax, Binder binder, DiagnosticBag diagnostics, bool isConst, bool isWithEvents, bool ignoreTypeSyntaxDiagnostics);
    internal static TypeSymbol ComputeWithEventsFieldType(PropertySymbol propertySymbol, ModifiedIdentifierSyntax modifiedIdentifier, Binder binder, bool ignoreTypeSyntaxDiagnostics, DiagnosticBag diagnostics);
    internal virtual TypeSymbol GetInferredType(SymbolsInProgress`1<FieldSymbol> inProgress);
    protected virtual TypeSymbol GetInferredConstantType();
    internal static void Create(SourceMemberContainerTypeSymbol container, FieldDeclarationSyntax syntax, Binder binder, MembersAndInitializersBuilder members, ArrayBuilder`1& staticInitializers, ArrayBuilder`1& instanceInitializers, DiagnosticBag diagBag);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMemberMethodSymbol : SourceNonPropertyAccessorMethodSymbol {
    private string _name;
    private int _arity;
    private QuickAttributes _quickAttributes;
    private string _lazyMetadataName;
    private ImmutableArray`1<MethodSymbol> _lazyImplementedMethods;
    private ImmutableArray`1<TypeParameterSymbol> _lazyTypeParameters;
    private ImmutableArray`1<HandledEvent> _lazyHandles;
    private SourceMemberMethodSymbol _otherPartOfPartial;
    private NamedTypeSymbol _asyncStateMachineType;
    private int _lazyState;
    public string Name { get; }
    protected SourceMethodSymbol BoundAttributesSource { get; }
    public string MetadataName { get; }
    internal bool GenerateDebugInfoImpl { get; }
    internal bool MayBeReducibleExtensionMethod { get; }
    public bool IsExtensionMethod { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public int Arity { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    internal bool HasEmptyBody { get; }
    internal bool IsPartialDefinition { get; }
    internal bool IsPartialImplementation { get; }
    public SourceMemberMethodSymbol SourcePartialDefinition { get; }
    public SourceMemberMethodSymbol SourcePartialImplementation { get; }
    public MethodSymbol PartialDefinitionPart { get; }
    public MethodSymbol PartialImplementationPart { get; }
    internal SourceMemberMethodSymbol OtherPartOfPartial { get; private set; }
    internal bool SuppressDuplicateProcDefDiagnostics { get; internal set; }
    public ImmutableArray`1<HandledEvent> HandledEvents { get; }
    internal SourceMemberMethodSymbol(SourceMemberContainerTypeSymbol containingType, string name, SourceMemberFlags flags, Binder binder, MethodBaseSyntax syntax, int arity, ImmutableArray`1<HandledEvent> handledEvents);
    public virtual string get_Name();
    protected virtual SourceMethodSymbol get_BoundAttributesSource();
    public virtual string get_MetadataName();
    internal virtual void SetMetadataName(string metadataName);
    internal virtual bool get_GenerateDebugInfoImpl();
    protected virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    private QuickAttributes GetQuickAttributes();
    internal virtual bool get_MayBeReducibleExtensionMethod();
    public virtual bool get_IsExtensionMethod();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual void GenerateDeclarationErrors(CancellationToken cancellationToken);
    public virtual int get_Arity();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    private ImmutableArray`1<TypeParameterSymbol> GetTypeParameters(SourceModuleSymbol sourceModule, DiagnosticBag diagBag);
    internal bool HasExplicitInterfaceImplementations();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    private ImmutableArray`1<MethodSymbol> GetExplicitInterfaceImplementations(SourceModuleSymbol sourceModule, DiagnosticBag diagBag);
    internal void ValidateImplementedMethodConstraints(DiagnosticBag diagnostics);
    internal virtual bool get_HasEmptyBody();
    internal bool get_IsPartialDefinition();
    internal bool get_IsPartialImplementation();
    public SourceMemberMethodSymbol get_SourcePartialDefinition();
    public SourceMemberMethodSymbol get_SourcePartialImplementation();
    public virtual MethodSymbol get_PartialDefinitionPart();
    public virtual MethodSymbol get_PartialImplementationPart();
    internal SourceMemberMethodSymbol get_OtherPartOfPartial();
    private void set_OtherPartOfPartial(SourceMemberMethodSymbol value);
    internal bool get_SuppressDuplicateProcDefDiagnostics();
    internal void set_SuppressDuplicateProcDefDiagnostics(bool value);
    internal static void InitializePartialMethodParts(SourceMemberMethodSymbol definition, SourceMemberMethodSymbol implementation);
    internal virtual BoundBlock GetBoundMethodBody(DiagnosticBag diagnostics, Binder& methodBodyBinder);
    public virtual ImmutableArray`1<HandledEvent> get_HandledEvents();
    private ImmutableArray`1<HandledEvent> GetHandles(SourceModuleSymbol sourceModule, DiagnosticBag diagBag);
    internal HandledEvent BindSingleHandlesClause(HandlesClauseItemSyntax singleHandleClause, Binder typeBinder, DiagnosticBag diagBag, ArrayBuilder`1<Symbol> candidateEventSymbols, ArrayBuilder`1<Symbol> candidateWithEventsSymbols, ArrayBuilder`1<Symbol> candidateWithEventsPropertySymbols, LookupResultKind& resultKind);
    internal static PropertySymbol FindWithEventsProperty(TypeSymbol containingType, Binder binder, string name, HashSet`1& useSiteDiagnostics, ArrayBuilder`1<Symbol> candidateEventSymbols, LookupResultKind& resultKind);
    internal static EventSymbol FindEvent(TypeSymbol containingType, Binder binder, string name, bool isThroughMyBase, HashSet`1& useSiteDiagnostics, ArrayBuilder`1<Symbol> candidateEventSymbols, LookupResultKind& resultKind);
    private static PropertySymbol FindProperty(TypeSymbol containingType, Binder binder, string name, HashSet`1& useSiteDiagnostics, ArrayBuilder`1<Symbol> candidatePropertySymbols, LookupResultKind& resultKind);
    private static bool ReturnsEventSource(PropertySymbol prop, VisualBasicCompilation compilation);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceMethodSymbol : MethodSymbol {
    protected SourceMemberFlags m_flags;
    protected NamedTypeSymbol m_containingType;
    private ParameterSymbol _lazyMeParameter;
    protected CustomAttributesBag`1<VisualBasicAttributeData> m_lazyCustomAttributesBag;
    protected CustomAttributesBag`1<VisualBasicAttributeData> m_lazyReturnTypeCustomAttributesBag;
    protected SyntaxReference m_syntaxReferenceOpt;
    private ImmutableArray`1<Location> _lazyLocations;
    private string _lazyDocComment;
    private ImmutableArray`1<Diagnostic> _cachedDiagnostics;
    internal ImmutableArray`1<Diagnostic> Diagnostics { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool GenerateDebugInfoImpl { get; }
    public MethodSymbol ConstructedFrom { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public SourceModuleSymbol ContainingSourceModule { get; }
    public Symbol AssociatedSymbol { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public MethodKind MethodKind { get; }
    internal bool IsMethodKindBasedOnSyntax { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverloads { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    internal bool IsPartial { get; }
    internal bool ShadowsExplicitly { get; }
    internal bool OverloadsExplicitly { get; }
    internal bool OverridesExplicitly { get; }
    internal bool HandlesEvents { get; }
    internal CallingConvention CallingConvention { get; }
    internal MethodBlockBaseSyntax BlockSyntax { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    public SyntaxTree SyntaxTree { get; }
    internal MethodBaseSyntax DeclarationSyntax { get; }
    internal bool HasEmptyBody { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal Location NonMergedLocation { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public bool IsVararg { get; }
    public bool IsGenericMethod { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public int Arity { get; }
    public bool IsSub { get; }
    public bool IsAsync { get; }
    public bool IsIterator { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    protected SourceMethodSymbol BoundAttributesSource { get; }
    protected SourcePropertySymbol BoundReturnTypeAttributesSource { get; }
    protected SyntaxList`1<AttributeListSyntax> AttributeDeclarationSyntaxList { get; }
    protected SyntaxList`1<AttributeListSyntax> ReturnTypeAttributeDeclarationSyntaxList { get; }
    public AttributeLocation DefaultAttributeLocation { get; }
    public bool IsExtensionMethod { get; }
    internal bool MayBeReducibleExtensionMethod { get; }
    public bool IsExternalMethod { get; }
    internal MarshalPseudoCustomAttributeData ReturnTypeMarshallingInformation { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal bool HasSpecialName { get; }
    private bool HasSTAThreadOrMTAThreadAttribute { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    internal OverriddenMembersResult`1<MethodSymbol> OverriddenMembers { get; }
    protected SourceMethodSymbol(NamedTypeSymbol containingType, SourceMemberFlags flags, SyntaxReference syntaxRef, ImmutableArray`1<Location> locations);
    internal static SourceMethodSymbol CreateRegularMethod(SourceMemberContainerTypeSymbol container, MethodStatementSyntax syntax, Binder binder, DiagnosticBag diagBag);
    internal static TypeParameterListSyntax GetTypeParameterListSyntax(MethodBaseSyntax methodSyntax);
    private static void ReportPartialMethodErrors(SyntaxTokenList modifiers, Binder binder, DiagnosticBag diagBag);
    internal static SourceMethodSymbol CreateDeclareMethod(SourceMemberContainerTypeSymbol container, DeclareStatementSyntax syntax, Binder binder, DiagnosticBag diagBag);
    private static PInvokeAttributes GetPInvokeAttributes(DeclareStatementSyntax syntax);
    internal static SourceMethodSymbol CreateOperator(SourceMemberContainerTypeSymbol container, OperatorStatementSyntax syntax, Binder binder, DiagnosticBag diagBag);
    internal static SourceMethodSymbol CreateConstructor(SourceMemberContainerTypeSymbol container, SubNewStatementSyntax syntax, Binder binder, DiagnosticBag diagBag);
    private static MemberModifiers DecodeMethodModifiers(SyntaxTokenList modifiers, SourceMemberContainerTypeSymbol container, Binder binder, DiagnosticBag diagBag);
    private static MemberModifiers DecodeOperatorModifiers(OperatorStatementSyntax syntax, Binder binder, DiagnosticBag diagBag);
    internal static MemberModifiers DecodeConstructorModifiers(SyntaxTokenList modifiers, SourceMemberContainerTypeSymbol container, Binder binder, DiagnosticBag diagBag);
    internal virtual void GenerateDeclarationErrors(CancellationToken cancellationToken);
    internal ImmutableArray`1<Diagnostic> get_Diagnostics();
    internal bool SetDiagnostics(ImmutableArray`1<Diagnostic> diags);
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual bool get_GenerateDebugInfoImpl();
    public sealed virtual MethodSymbol get_ConstructedFrom();
    public sealed virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public SourceModuleSymbol get_ContainingSourceModule();
    public virtual Symbol get_AssociatedSymbol();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual MethodKind get_MethodKind();
    internal sealed virtual bool get_IsMethodKindBasedOnSyntax();
    public virtual Accessibility get_DeclaredAccessibility();
    public sealed virtual bool get_IsMustOverride();
    public sealed virtual bool get_IsNotOverridable();
    public sealed virtual bool get_IsOverloads();
    public sealed virtual bool get_IsOverridable();
    public sealed virtual bool get_IsOverrides();
    public sealed virtual bool get_IsShared();
    internal bool get_IsPartial();
    internal virtual bool get_ShadowsExplicitly();
    internal bool get_OverloadsExplicitly();
    internal bool get_OverridesExplicitly();
    internal bool get_HandlesEvents();
    internal sealed virtual CallingConvention get_CallingConvention();
    internal MethodBlockBaseSyntax get_BlockSyntax();
    internal virtual VisualBasicSyntaxNode get_Syntax();
    public SyntaxTree get_SyntaxTree();
    internal MethodBaseSyntax get_DeclarationSyntax();
    internal virtual bool get_HasEmptyBody();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal sealed virtual bool IsDefinedInSourceTree(SyntaxTree tree, Nullable`1<TextSpan> definedWithinSpan, CancellationToken cancellationToken);
    public sealed virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal Location get_NonMergedLocation();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public virtual ImmutableArray`1<Location> get_Locations();
    private Location GetSymbolLocation(SyntaxReference syntaxRef);
    private static TextSpan GetMethodLocationFromSyntax(VisualBasicSyntaxNode node);
    internal ImmutableArray`1<TypeParameterConstraint> BindTypeParameterConstraints(TypeParameterSyntax syntax, DiagnosticBag diagnostics);
    internal static string GetMemberNameFromSyntax(MethodBaseSyntax node);
    internal static Symbol FindSymbolFromSyntax(MethodBaseSyntax syntax, SyntaxTree tree, NamedTypeSymbol container);
    internal Location GetImplementingLocation(MethodSymbol implementedMethod);
    internal virtual BoundBlock GetBoundMethodBody(DiagnosticBag diagnostics, Binder& methodBodyBinder);
    internal sealed virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    public sealed virtual bool get_IsVararg();
    public sealed virtual bool get_IsGenericMethod();
    public sealed virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual int get_Arity();
    public virtual bool get_IsSub();
    public sealed virtual bool get_IsAsync();
    public sealed virtual bool get_IsIterator();
    internal sealed virtual bool TryGetMeParameter(ParameterSymbol& meParameter);
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    protected virtual SourceMethodSymbol get_BoundAttributesSource();
    protected virtual SourcePropertySymbol get_BoundReturnTypeAttributesSource();
    protected SyntaxList`1<AttributeListSyntax> get_AttributeDeclarationSyntaxList();
    protected SyntaxList`1<AttributeListSyntax> get_ReturnTypeAttributeDeclarationSyntaxList();
    protected virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    protected virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetReturnTypeAttributeDeclarations();
    public sealed virtual override AttributeLocation get_DefaultAttributeLocation();
    private CustomAttributesBag`1<VisualBasicAttributeData> GetAttributesBag();
    private CustomAttributesBag`1<VisualBasicAttributeData> GetReturnTypeAttributesBag();
    private CustomAttributesBag`1<VisualBasicAttributeData> GetAttributesBag(CustomAttributesBag`1& lazyCustomAttributesBag, bool forReturnType);
    public sealed virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    protected MethodWellKnownAttributeData GetDecodedWellKnownAttributeData();
    public sealed virtual ImmutableArray`1<VisualBasicAttributeData> GetReturnTypeAttributes();
    private CommonReturnTypeWellKnownAttributeData GetDecodedReturnTypeWellKnownAttributeData();
    internal virtual VisualBasicAttributeData EarlyDecodeWellKnownAttribute(EarlyDecodeWellKnownAttributeArguments`4& arguments);
    private MethodEarlyWellKnownAttributeData GetEarlyDecodedWellKnownAttributeData();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    private void DecodeWellKnownAttributeAppliedToMethod(DecodeWellKnownAttributeArguments`3& arguments);
    private bool VerifyObsoleteAttributeAppliedToMethod(DecodeWellKnownAttributeArguments`3& arguments, AttributeDescription description);
    private void DecodeWellKnownAttributeAppliedToReturnValue(DecodeWellKnownAttributeArguments`3& arguments);
    private bool IsDllImportAttributeAllowed(AttributeSyntax syntax, DiagnosticBag diagnostics);
    internal virtual void PostDecodeWellKnownAttributes(ImmutableArray`1<VisualBasicAttributeData> boundAttributes, ImmutableArray`1<AttributeSyntax> allAttributeSyntaxNodes, DiagnosticBag diagnostics, AttributeLocation symbolPart, WellKnownAttributeData decodedData);
    public virtual bool get_IsExtensionMethod();
    internal abstract virtual bool get_MayBeReducibleExtensionMethod();
    public virtual bool get_IsExternalMethod();
    public virtual DllImportData GetDllImportData();
    internal sealed virtual MarshalPseudoCustomAttributeData get_ReturnTypeMarshallingInformation();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    internal sealed virtual bool get_HasDeclarativeSecurity();
    internal sealed virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual bool get_HasRuntimeSpecialName();
    private bool IsVtableGapInterfaceMethod();
    internal virtual bool get_HasSpecialName();
    private bool get_HasSTAThreadOrMTAThreadAttribute();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public abstract virtual TypeSymbol get_ReturnType();
    public abstract virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal abstract virtual OverriddenMembersResult`1<MethodSymbol> get_OverriddenMembers();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceModuleSymbol : NonMissingModuleSymbol {
    private SourceAssemblySymbol _assemblySymbol;
    private DeclarationTable _declarationTable;
    private VisualBasicCompilationOptions _options;
    private CustomAttributesBag`1<VisualBasicAttributeData> _lazyCustomAttributesBag;
    private byte _lazyContainsExtensionMethods;
    private ImmutableArray`1<AssemblySymbol> _lazyAssembliesToEmbedTypesFrom;
    private ThreeState _lazyContainsExplicitDefinitionOfNoPiaLocalTypes;
    private ImmutableArray`1<Location> _locations;
    private DiagnosticBag _diagnosticBagDeclare;
    private bool _hasBadAttributes;
    private ConcurrentDictionary`2<SyntaxTree, SourceFile> _sourceFileMap;
    private SourceNamespaceSymbol _lazyGlobalNamespace;
    private BoundImports _lazyBoundImports;
    private QuickAttributeChecker _lazyQuickAttributeChecker;
    private ImmutableArray`1<Diagnostic> _lazyLinkedAssemblyDiagnostics;
    private Dictionary`2<NamedTypeSymbol, SynthesizedMyGroupCollectionPropertySymbol> _lazyTypesWithDefaultInstanceAlias;
    private static Dictionary`2<NamedTypeSymbol, SynthesizedMyGroupCollectionPropertySymbol> s_noTypesWithDefaultInstanceAlias;
    private string _nameAndExtension;
    private object _diagnosticLock;
    internal VisualBasicCompilationOptions Options { get; }
    internal int Ordinal { get; }
    internal Machine Machine { get; }
    internal bool Bit32Required { get; }
    public Symbol ContainingSymbol { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public SourceAssemblySymbol ContainingSourceAssembly { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    public string Name { get; }
    public NamespaceSymbol GlobalNamespace { get; }
    internal NamespaceSymbol RootNamespace { get; }
    public ImmutableArray`1<Location> Locations { get; }
    internal IEnumerable`1<SyntaxTree> SyntaxTrees { get; }
    public AttributeLocation DefaultAttributeLocation { get; }
    public QuickAttributeChecker QuickAttributeChecker { get; }
    internal bool AnyReferencedAssembliesAreLinked { get; }
    internal bool ContainsExplicitDefinitionOfNoPiaLocalTypes { get; }
    internal ImmutableArray`1<NamespaceOrTypeAndImportsClausePosition> MemberImports { get; }
    internal ImmutableArray`1<AliasAndImportsClausePosition> AliasImports { get; }
    internal Dictionary`2<string, AliasAndImportsClausePosition> AliasImportsMap { get; }
    internal Dictionary`2<string, XmlNamespaceAndImportsClausePosition> XmlNamespaces { get; }
    internal bool HasBadAttributes { get; }
    internal ICollection`1<string> TypeNames { get; }
    internal ICollection`1<string> NamespaceNames { get; }
    internal bool MightContainExtensionMethods { get; }
    internal bool HasAssemblyCompilationRelaxationsAttribute { get; }
    internal bool HasAssemblyRuntimeCompatibilityAttribute { get; }
    internal Nullable`1<CharSet> DefaultMarshallingCharSet { get; }
    private static SourceModuleSymbol();
    internal SourceModuleSymbol(SourceAssemblySymbol assemblySymbol, DeclarationTable declarationTable, VisualBasicCompilationOptions options, string nameAndExtension);
    internal VisualBasicCompilationOptions get_Options();
    internal virtual int get_Ordinal();
    internal virtual Machine get_Machine();
    internal virtual bool get_Bit32Required();
    public virtual Symbol get_ContainingSymbol();
    public virtual AssemblySymbol get_ContainingAssembly();
    public SourceAssemblySymbol get_ContainingSourceAssembly();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
    public virtual string get_Name();
    internal SourceFile GetSourceFile(SyntaxTree tree);
    public virtual NamespaceSymbol get_GlobalNamespace();
    internal NamespaceSymbol get_RootNamespace();
    public virtual ImmutableArray`1<Location> get_Locations();
    internal IEnumerable`1<SyntaxTree> get_SyntaxTrees();
    public sealed virtual override AttributeLocation get_DefaultAttributeLocation();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    private CustomAttributesBag`1<VisualBasicAttributeData> GetAttributesBag();
    internal CommonModuleWellKnownAttributeData GetDecodedWellKnownAttributeData();
    public QuickAttributeChecker get_QuickAttributeChecker();
    internal bool get_AnyReferencedAssembliesAreLinked();
    internal bool MightContainNoPiaLocalTypes();
    internal ImmutableArray`1<AssemblySymbol> GetAssembliesToEmbedTypesFrom();
    internal bool get_ContainsExplicitDefinitionOfNoPiaLocalTypes();
    private static bool NamespaceContainsExplicitDefinitionOfNoPiaLocalTypes(NamespaceSymbol ns);
    private QuickAttributeChecker CreateQuickAttributeChecker();
    private void EnsureImportsAreBound(CancellationToken cancellationToken);
    private BoundImports BindImports(CancellationToken cancellationToken);
    private static void ValidateImports(ImmutableArray`1<NamespaceOrTypeAndImportsClausePosition> memberImports, ImmutableArray`1<GlobalImportInfo> memberImportsInfo, ImmutableArray`1<AliasAndImportsClausePosition> aliasImports, ImmutableArray`1<GlobalImportInfo> aliasImportsInfo, DiagnosticBag diagnostics);
    private static void ValidateImport(TypeSymbol type, GlobalImportInfo info, DiagnosticBag diagnostics);
    internal ImmutableArray`1<NamespaceOrTypeAndImportsClausePosition> get_MemberImports();
    internal ImmutableArray`1<AliasAndImportsClausePosition> get_AliasImports();
    internal Dictionary`2<string, AliasAndImportsClausePosition> get_AliasImportsMap();
    internal Dictionary`2<string, XmlNamespaceAndImportsClausePosition> get_XmlNamespaces();
    internal ImmutableArray`1<Diagnostic> GetDeclarationErrorsInTree(SyntaxTree tree, Nullable`1<TextSpan> filterSpanWithinTree, Func`4<IEnumerable`1<Diagnostic>, SyntaxTree, Nullable`1<TextSpan>, IEnumerable`1<Diagnostic>> locationFilter, CancellationToken cancellationToken);
    internal ImmutableArray`1<Diagnostic> GetAllDeclarationErrors(CancellationToken cancellationToken, Boolean& hasExtensionMethods);
    private void VisitAllSourceTypesAndNamespaces(Action`1<NamespaceOrTypeSymbol> visitor, ConcurrentStack`1<Task> tasks, CancellationToken cancellationToken);
    private void VisitTypesAndNamespacesWithin(NamespaceOrTypeSymbol ns, Action`1<NamespaceOrTypeSymbol> visitor, ConcurrentStack`1<Task> tasks, CancellationToken cancellationToken);
    private void EnsureLinkedAssembliesAreValidated(CancellationToken cancellationToken);
    private void ValidateLinkedAssemblies(DiagnosticBag diagnostics, CancellationToken cancellationToken);
    private static bool HasAllLazyDiagnostics(DiagnosticBag diagBag);
    internal bool AtomicStoreReferenceAndDiagnostics(T& variable, T value, DiagnosticBag diagBag, CompilationStage stage, T comparand);
    internal void AtomicStoreIntegerAndDiagnostics(Int32& variable, int value, int comparand, DiagnosticBag diagBag, CompilationStage stage);
    internal bool AtomicSetFlagAndStoreDiagnostics(Int32& variable, int mask, int comparand, DiagnosticBag diagBag, CompilationStage stage);
    internal bool AtomicSetFlagAndRaiseSymbolDeclaredEvent(Int32& variable, int mask, int comparand, Symbol symbol);
    internal bool AtomicStoreArrayAndDiagnostics(ImmutableArray`1& variable, ImmutableArray`1<T> value, DiagnosticBag diagBag, CompilationStage stage);
    internal void AtomicStoreAttributesAndDiagnostics(CustomAttributesBag`1<VisualBasicAttributeData> attributesBag, ImmutableArray`1<VisualBasicAttributeData> attributesToStore, DiagnosticBag diagBag);
    private void RecordPresenceOfBadAttributes(ImmutableArray`1<VisualBasicAttributeData> attributes);
    internal bool get_HasBadAttributes();
    internal void AddDiagnostics(DiagnosticBag diagBag, CompilationStage stage);
    private void StoreDiagnostics(DiagnosticBag diagBag, CompilationStage stage);
    private void AddDiagnostic(Diagnostic d, CompilationStage stage);
    internal virtual ICollection`1<string> get_TypeNames();
    internal virtual ICollection`1<string> get_NamespaceNames();
    internal virtual bool get_MightContainExtensionMethods();
    internal void RecordPresenceOfExtensionMethods();
    internal virtual void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    internal virtual bool get_HasAssemblyCompilationRelaxationsAttribute();
    internal virtual bool get_HasAssemblyRuntimeCompatibilityAttribute();
    internal virtual Nullable`1<CharSet> get_DefaultMarshallingCharSet();
    public SynthesizedMyGroupCollectionPropertySymbol GetMyGroupCollectionPropertyWithDefaultInstanceAlias(NamedTypeSymbol classType);
    private Dictionary`2<NamedTypeSymbol, SynthesizedMyGroupCollectionPropertySymbol> GetTypesWithDefaultInstanceAlias();
    private static void GetTypesWithDefaultInstanceAlias(NamespaceOrTypeSymbol namespaceOrType, Dictionary`2& result);
    public virtual ModuleMetadata GetMetadata();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamedTypeSymbol : SourceMemberContainerTypeSymbol {
    private ImmutableArray`1<TypeParameterSymbol> _lazyTypeParameters;
    protected CustomAttributesBag`1<VisualBasicAttributeData> m_lazyCustomAttributesBag;
    private SpecialType _corTypeId;
    private string _lazyDocComment;
    private NamedTypeSymbol _lazyEnumUnderlyingType;
    private ConcurrentDictionary`2<PropertySymbol, SynthesizedOverridingWithEventsProperty> _lazyWithEventsOverrides;
    internal static SourceMemberFlags DelegateConstructorMethodFlags;
    internal static SourceMemberFlags DelegateCommonMethodFlags;
    private LexicalSortKey _lazyLexicalSortKey;
    private ThreeState _lazyIsExtensibleInterface;
    private ThreeState _lazyIsExplicitDefinitionOfNoPiaLocalType;
    private ComClassData _comClassData;
    private TypeSymbol _lazyCoClassType;
    protected DiagnosticInfo m_baseCycleDiagnosticInfo;
    public SpecialType SpecialType { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public NamedTypeSymbol EnumUnderlyingType { get; }
    public AttributeLocation DefaultAttributeLocation { get; }
    internal bool HasEmbeddedAttribute { get; }
    internal bool IsExtensibleInterfaceNoUseSiteDiagnostics { get; }
    internal bool IsComImport { get; }
    internal TypeSymbol CoClassType { get; }
    internal bool IsWindowsRuntimeImport { get; }
    internal bool ShouldAddWinRTMembers { get; }
    internal bool HasSecurityCriticalAttributes { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal bool IsExplicitDefinitionOfNoPiaLocalType { get; }
    internal bool HasSpecialName { get; }
    internal bool IsSerializable { get; }
    internal TypeLayout Layout { get; }
    internal bool HasStructLayoutAttribute { get; }
    internal CharSet MarshallingCharSet { get; }
    internal SourceNamedTypeSymbol(MergedTypeDeclaration declaration, NamespaceOrTypeSymbol containingSymbol, SourceModuleSymbol containingModule);
    public virtual SpecialType get_SpecialType();
    protected virtual void GenerateAllDeclarationErrorsImpl(CancellationToken cancellationToken);
    internal SyntaxToken GetTypeIdentifierToken(VisualBasicSyntaxNode node);
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    private Binder CreateLocationSpecificBinderForType(SyntaxTree tree, BindingLocation location);
    protected virtual void AddDeclaredNonTypeMembers(MembersAndInitializersBuilder membersBuilder, DiagnosticBag diagnostics);
    private DeclarationModifiers AddMembersInPart(Binder binder, VisualBasicSyntaxNode node, DiagnosticBag diagBag, DeclarationModifiers accessModifiers, MembersAndInitializersBuilder members, ArrayBuilder`1& staticInitializers, ArrayBuilder`1& instanceInitializers, Boolean& nodeNameIsAlreadyDefined);
    private DeclarationModifiers CheckDeclarationModifiers(VisualBasicSyntaxNode node, Binder binder, DiagnosticBag diagBag, DeclarationModifiers accessModifiers);
    private DeclarationModifiers DecodeDeclarationModifiers(VisualBasicSyntaxNode node, Binder binder, DiagnosticBag diagBag, SyntaxTokenList& modifiers, SyntaxToken& id);
    private void CheckDeclarationNameAndTypeParameters(VisualBasicSyntaxNode node, Binder binder, DiagnosticBag diagBag, Boolean& nodeNameIsAlreadyDeclared);
    private void CheckDeclarationPart(SyntaxTree tree, VisualBasicSyntaxNode node, VisualBasicSyntaxNode firstNode, bool foundPartial, DiagnosticBag diagBag);
    private void AddEnumMembers(EnumBlockSyntax syntax, Binder bodyBinder, DiagnosticBag diagnostics, MembersAndInitializersBuilder members);
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal void BindTypeParameterConstraints(SourceTypeParameterOnTypeSymbol typeParameter, VarianceKind& variance, ImmutableArray`1& constraints, DiagnosticBag diagnostics);
    private void CreateTypeParameterInfoInPart(SyntaxTree tree, SourceTypeParameterOnTypeSymbol typeParameter, TypeParameterListSyntax typeParamListSyntax, bool allowVarianceSpecifier, TypeParameterInfo& info, DiagnosticBag diagBag);
    private static bool HaveSameConstraints(ImmutableArray`1<TypeParameterConstraint> constraints1, ImmutableArray`1<TypeParameterConstraint> constraints2);
    private static TypeParameterConstraintKind GetConstraintKind(ImmutableArray`1<TypeParameterConstraint> constraints);
    private ImmutableArray`1<TypeParameterSymbol> MakeTypeParameters();
    private static TypeParameterListSyntax GetTypeParameterListSyntax(VisualBasicSyntaxNode syntax);
    internal void CheckForDuplicateTypeParameters(ImmutableArray`1<TypeParameterSymbol> typeParameters, DiagnosticBag diagBag);
    private bool ShadowsTypeParameter(TypeParameterSymbol typeParameter);
    private void MakeDeclaredBaseInPart(SyntaxTree tree, VisualBasicSyntaxNode syntaxNode, NamedTypeSymbol& baseType, ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagBag);
    private void MakeDeclaredInterfacesInPart(SyntaxTree tree, VisualBasicSyntaxNode syntaxNode, SetWithInsertionOrder`1<NamedTypeSymbol> interfaces, ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagBag);
    private void CheckNoBase(SyntaxList`1<T> baseDeclList, ERRID errId, DiagnosticBag diagBag);
    private NamedTypeSymbol ValidateClassBase(SyntaxList`1<InheritsStatementSyntax> inheritsSyntax, NamedTypeSymbol baseInOtherPartial, ConsList`1<Symbol> basesBeingResolved, Binder binder, DiagnosticBag diagBag);
    private void ValidateInheritedInterfaces(SyntaxList`1<InheritsStatementSyntax> baseSyntax, SetWithInsertionOrder`1<NamedTypeSymbol> basesInOtherPartials, ConsList`1<Symbol> basesBeingResolved, Binder binder, DiagnosticBag diagBag);
    private void ValidateImplementedInterfaces(SyntaxList`1<ImplementsStatementSyntax> baseSyntax, SetWithInsertionOrder`1<NamedTypeSymbol> basesInOtherPartials, ConsList`1<Symbol> basesBeingResolved, Binder binder, DiagnosticBag diagBag);
    private bool IsRestrictedBaseClass(SpecialType type);
    private NamedTypeSymbol AsPeOrRetargetingType(TypeSymbol potentialBaseType);
    internal virtual NamedTypeSymbol MakeDeclaredBase(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<NamedTypeSymbol> MakeDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    private Location GetInheritsLocation(NamedTypeSymbol base);
    protected virtual Location GetInheritsOrImplementsLocation(NamedTypeSymbol base, bool getInherits);
    internal virtual NamedTypeSymbol MakeAcyclicBaseType(DiagnosticBag diagnostics);
    private NamedTypeSymbol GetSpecialType(SpecialType type);
    private void ReportUseSiteDiagnosticsForBaseType(NamedTypeSymbol baseType, NamedTypeSymbol declaredBase, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<NamedTypeSymbol> MakeAcyclicInterfaces(DiagnosticBag diagnostics);
    internal virtual NamedTypeSymbol GetDirectBaseTypeNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
    private NamedTypeSymbol GetDeclaredBaseSafe(ConsList`1<Symbol> basesBeingResolved);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetDeclaredBaseInterfacesSafe(ConsList`1<Symbol> basesBeingResolved);
    private void CheckBaseConstraints();
    private void CheckInterfacesConstraints();
    private SingleTypeDeclaration FirstDeclarationWithExplicitBases();
    private SingleTypeDeclaration FirstDeclarationWithExplicitInterfaces();
    public virtual NamedTypeSymbol get_EnumUnderlyingType();
    private NamedTypeSymbol BindEnumUnderlyingType(EnumBlockSyntax syntax, Binder bodyBinder, DiagnosticBag diagnostics);
    public sealed virtual override AttributeLocation get_DefaultAttributeLocation();
    private ImmutableArray`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    private CustomAttributesBag`1<VisualBasicAttributeData> GetAttributesBag();
    public sealed virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    private CommonTypeWellKnownAttributeData GetDecodedWellKnownAttributeData();
    internal virtual bool get_HasEmbeddedAttribute();
    internal virtual bool get_IsExtensibleInterfaceNoUseSiteDiagnostics();
    private bool DecodeIsExtensibleInterface();
    private TypeEarlyWellKnownAttributeData GetEarlyDecodedWellKnownAttributeData();
    internal virtual bool get_IsComImport();
    internal virtual TypeSymbol get_CoClassType();
    internal virtual bool get_IsWindowsRuntimeImport();
    internal virtual bool get_ShouldAddWinRTMembers();
    internal bool get_HasSecurityCriticalAttributes();
    internal bool HasGuidAttribute();
    internal bool HasClassInterfaceAttribute();
    internal bool HasComSourceInterfacesAttribute();
    internal virtual VisualBasicAttributeData EarlyDecodeWellKnownAttribute(EarlyDecodeWellKnownAttributeArguments`4& arguments);
    internal sealed virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal sealed virtual AttributeUsageInfo GetAttributeUsageInfo();
    internal sealed virtual bool get_HasDeclarativeSecurity();
    internal sealed virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal sealed virtual void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    internal virtual bool get_IsExplicitDefinitionOfNoPiaLocalType();
    private bool FindDefaultEvent(string eventName);
    internal virtual void PostDecodeWellKnownAttributes(ImmutableArray`1<VisualBasicAttributeData> boundAttributes, ImmutableArray`1<AttributeSyntax> allAttributeSyntaxNodes, DiagnosticBag diagnostics, AttributeLocation symbolPart, WellKnownAttributeData decodedData);
    private void ValidateStandardModuleAttribute(DiagnosticBag diagnostics);
    internal sealed virtual bool get_HasSpecialName();
    internal sealed virtual bool get_IsSerializable();
    private bool HasInstanceFields();
    internal sealed virtual TypeLayout get_Layout();
    internal bool get_HasStructLayoutAttribute();
    internal virtual CharSet get_MarshallingCharSet();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    private bool HasDefaultMemberAttribute();
    internal SynthesizedOverridingWithEventsProperty GetOrAddWithEventsOverride(PropertySymbol baseProperty);
    protected virtual void AddEntryPointIfNeeded(MembersAndInitializersBuilder membersBuilder);
    private void PerformComClassAnalysis();
    internal virtual IEnumerable`1<INestedTypeDefinition> GetSynthesizedNestedTypes();
    internal virtual IEnumerable`1<NamedTypeSymbol> GetSynthesizedImplements();
    internal MethodSymbol GetCorrespondingComClassInterfaceMethod(MethodSymbol method);
    protected virtual void AddGroupClassMembersIfNeeded(MembersAndInitializersBuilder membersBuilder, DiagnosticBag diagnostics);
    private VisualBasicAttributeData GetMyGroupCollectionAttributeData(DiagnosticBag diagnostics, Binder& binder, AttributeSyntax& attributeSyntax);
    private static void FindGroupClassBaseTypes(String[] nameParts, NamespaceOrTypeSymbol current, int nextPart, ArrayBuilder`1<NamedTypeSymbol> candidates);
    private static void GetMyGroupCollectionTypes(NamespaceSymbol ns, ArrayBuilder`1<NamedTypeSymbol> baseTypes, Binder binder, ArrayBuilder`1<KeyValuePair`2<NamedTypeSymbol, int>> collectionTypes);
    private static int FindBaseInMyGroupCollection(NamedTypeSymbol classType, ArrayBuilder`1<NamedTypeSymbol> bases);
    private static bool MyGroupCollectionCandidateHasPublicParameterlessConstructor(SourceNamedTypeSymbol candidate);
    internal bool InferFromSyntaxIfClassWillHavePublicParameterlessConstructor();
    private void AddSyntheticMyGroupCollectionProperty(NamedTypeSymbol targetType, bool mangleNames, string createMethod, string disposeMethod, string defaultInstanceAlias, MembersAndInitializersBuilder membersBuilder, Binder binder, AttributeSyntax attributeSyntax, DiagnosticBag diagnostics);
    private static bool ConflictsWithExistingMemberOrType(string name, MembersAndInitializersBuilder membersBuilder, Dictionary`2<string, ImmutableArray`1<NamedTypeSymbol>> nestedTypes, Symbol& conflictsWith);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNamespaceSymbol : PEOrSourceOrMergedNamespaceSymbol {
    private MergedNamespaceDeclaration _declaration;
    private SourceNamespaceSymbol _containingNamespace;
    private SourceModuleSymbol _containingModule;
    private Dictionary`2<string, ImmutableArray`1<NamespaceOrTypeSymbol>> _nameToMembersMap;
    private Dictionary`2<string, ImmutableArray`1<NamedTypeSymbol>> _nameToTypeMembersMap;
    private int _lazyEmbeddedKind;
    private int _lazyState;
    private ImmutableArray`1<NamedTypeSymbol> _lazyModuleMembers;
    private ImmutableArray`1<Symbol> _lazyAllMembers;
    private LexicalSortKey _lazyLexicalSortKey;
    public string Name { get; }
    internal EmbeddedSymbolKind EmbeddedSymbolKind { get; }
    public Symbol ContainingSymbol { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public ModuleSymbol ContainingModule { get; }
    internal NamespaceExtent Extent { get; }
    private Dictionary`2<string, ImmutableArray`1<NamespaceOrTypeSymbol>> NameToMembersMap { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal ImmutableArray`1<NamedTypeSymbol> TypesToCheckForExtensionMethods { get; }
    internal bool HasMultipleSpellings { get; }
    public MergedNamespaceDeclaration MergedDeclaration { get; }
    internal SourceNamespaceSymbol(MergedNamespaceDeclaration decl, SourceNamespaceSymbol containingNamespace, SourceModuleSymbol containingModule);
    private void RegisterDeclaredCorTypes();
    public virtual string get_Name();
    internal virtual EmbeddedSymbolKind get_EmbeddedSymbolKind();
    public virtual Symbol get_ContainingSymbol();
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual ModuleSymbol get_ContainingModule();
    internal virtual NamespaceExtent get_Extent();
    private Dictionary`2<string, ImmutableArray`1<NamespaceOrTypeSymbol>> get_NameToMembersMap();
    private Dictionary`2<string, ImmutableArray`1<NamespaceOrTypeSymbol>> GetNameToMembersMap();
    private Dictionary`2<string, ImmutableArray`1<NamespaceOrTypeSymbol>> MakeNameToMembersMap();
    private NamespaceOrTypeSymbol BuildSymbol(MergedNamespaceOrTypeDeclaration decl);
    private Dictionary`2<string, ImmutableArray`1<NamedTypeSymbol>> GetNameToTypeMembersMap();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    internal virtual ImmutableArray`1<Symbol> GetMembersUnordered();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembersUnordered();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetModuleMembers();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    private ImmutableArray`1<SyntaxReference> ComputeDeclaringReferencesCore();
    internal virtual bool IsDefinedInSourceTree(SyntaxTree tree, Nullable`1<TextSpan> definedWithinSpan, CancellationToken cancellationToken);
    internal virtual void GenerateDeclarationErrors(CancellationToken cancellationToken);
    internal void GenerateDeclarationErrorsInTree(SyntaxTree tree, Nullable`1<TextSpan> filterSpanWithinTree, CancellationToken cancellationToken);
    private void ValidateDeclaration(SyntaxTree tree, CancellationToken cancellationToken);
    private void ValidateNamespaceNameSyntax(SimpleNameSyntax node, DiagnosticBag diagnostics, Boolean& reportedNamespaceMismatch);
    private void ValidateNamespaceGlobalSyntax(GlobalNameSyntax node, DiagnosticBag diagnostics);
    private object GetSourcePathForDeclaration();
    internal virtual ImmutableArray`1<NamedTypeSymbol> get_TypesToCheckForExtensionMethods();
    internal bool get_HasMultipleSpellings();
    internal string GetDeclarationSpelling(SyntaxTree tree, int location);
    public MergedNamespaceDeclaration get_MergedDeclaration();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceNonPropertyAccessorMethodSymbol : SourceMethodSymbol {
    private ImmutableArray`1<ParameterSymbol> _lazyParameters;
    private TypeSymbol _lazyReturnType;
    private OverriddenMembersResult`1<MethodSymbol> _lazyOverriddenMethods;
    internal int ParameterCount { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public TypeSymbol ReturnType { get; }
    internal OverriddenMembersResult`1<MethodSymbol> OverriddenMembers { get; }
    protected SourceNonPropertyAccessorMethodSymbol(NamedTypeSymbol containingType, SourceMemberFlags flags, SyntaxReference syntaxRef, ImmutableArray`1<Location> locations);
    internal sealed virtual int get_ParameterCount();
    public sealed virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    private void EnsureSignature();
    private Binder CreateBinderForMethodDeclaration(SourceModuleSymbol sourceModule);
    protected virtual ImmutableArray`1<ParameterSymbol> GetParameters(SourceModuleSymbol sourceModule, DiagnosticBag diagBag);
    public sealed virtual TypeSymbol get_ReturnType();
    private static SyntaxToken GetNameToken(MethodBaseSyntax methodStatement);
    private TypeSymbol GetReturnType(SourceModuleSymbol sourceModule, SyntaxNodeOrToken& errorLocation, DiagnosticBag diagBag);
    internal sealed virtual OverriddenMembersResult`1<MethodSymbol> get_OverriddenMembers();
}
internal enum Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceParameterFlags : Enum {
    public byte value__;
    public static SourceParameterFlags ByVal;
    public static SourceParameterFlags ByRef;
    public static SourceParameterFlags Optional;
    public static SourceParameterFlags ParamArray;
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceParameterSymbol : SourceParameterSymbolBase {
    private Location _location;
    private string _name;
    private TypeSymbol _type;
    internal Location Location { get; }
    public string Name { get; }
    internal bool HasOptionCompare { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsImplicitlyDeclared { get; }
    internal SyntaxList`1<AttributeListSyntax> AttributeDeclarationList { get; }
    internal bool HasParamArrayAttribute { get; }
    internal bool HasDefaultValueAttribute { get; }
    public AttributeLocation DefaultAttributeLocation { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    public bool IsByRef { get; }
    internal bool IsMetadataOut { get; }
    internal bool IsMetadataIn { get; }
    internal SourceParameterSymbol(Symbol container, string name, int ordinal, TypeSymbol type, Location location);
    internal Location get_Location();
    public sealed virtual string get_Name();
    internal sealed virtual bool get_HasOptionCompare();
    internal virtual bool get_IsIDispatchConstant();
    internal virtual bool get_IsIUnknownConstant();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public sealed virtual TypeSymbol get_Type();
    public abstract virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    internal abstract virtual ushort get_CountOfCustomModifiersPrecedingByRef();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public sealed virtual bool get_IsImplicitlyDeclared();
    private ParameterSymbol GetMatchingPropertyParameter();
    internal abstract virtual CustomAttributesBag`1<VisualBasicAttributeData> GetAttributesBag();
    internal abstract virtual ParameterEarlyWellKnownAttributeData GetEarlyDecodedWellKnownAttributeData();
    internal abstract virtual CommonParameterWellKnownAttributeData GetDecodedWellKnownAttributeData();
    internal abstract virtual SyntaxList`1<AttributeListSyntax> get_AttributeDeclarationList();
    internal sealed virtual bool get_HasParamArrayAttribute();
    internal sealed virtual bool get_HasDefaultValueAttribute();
    public sealed virtual override AttributeLocation get_DefaultAttributeLocation();
    public sealed virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    internal virtual VisualBasicAttributeData EarlyDecodeWellKnownAttribute(EarlyDecodeWellKnownAttributeArguments`4& arguments);
    private VisualBasicAttributeData EarlyDecodeAttributeForDefaultParameterValue(AttributeDescription description, EarlyDecodeWellKnownAttributeArguments`4& arguments);
    internal virtual void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    private void DecodeDefaultParameterValueAttribute(AttributeDescription description, DecodeWellKnownAttributeArguments`3& arguments);
    protected void VerifyParamDefaultValueMatchesAttributeIfAny(ConstantValue value, VisualBasicSyntaxNode syntax, DiagnosticBag diagnostics);
    private ConstantValue DecodeDefaultParameterValueAttribute(AttributeDescription description, VisualBasicAttributeData attribute);
    private ConstantValue DecodeDefaultParameterValueAttribute(VisualBasicAttributeData attribute);
    internal sealed virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    public sealed virtual bool get_IsByRef();
    internal sealed virtual bool get_IsMetadataOut();
    internal sealed virtual bool get_IsMetadataIn();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceParameterSymbolBase : ParameterSymbol {
    private Symbol _containingSymbol;
    private ushort _ordinal;
    public int Ordinal { get; }
    public Symbol ContainingSymbol { get; }
    internal bool HasParamArrayAttribute { get; }
    internal bool HasDefaultValueAttribute { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    internal SourceParameterSymbolBase(Symbol containingSymbol, int ordinal);
    public sealed virtual int get_Ordinal();
    public sealed virtual Symbol get_ContainingSymbol();
    internal abstract virtual bool get_HasParamArrayAttribute();
    internal abstract virtual bool get_HasDefaultValueAttribute();
    internal sealed virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal virtual ushort get_CountOfCustomModifiersPrecedingByRef();
    internal abstract virtual ParameterSymbol WithTypeAndCustomModifiers(TypeSymbol type, ImmutableArray`1<CustomModifier> customModifiers, ushort countOfCustomModifiersPrecedingByRef);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourcePropertyAccessorSymbol : SourceMethodSymbol {
    protected SourcePropertySymbol m_property;
    private string _name;
    private string _lazyMetadataName;
    private ImmutableArray`1<MethodSymbol> _lazyExplicitImplementations;
    private ImmutableArray`1<ParameterSymbol> _lazyParameters;
    private TypeSymbol _lazyReturnType;
    private static CheckParameterModifierDelegate s_checkParameterModifierCallback;
    public MethodSymbol OverriddenMethod { get; }
    internal OverriddenMembersResult`1<MethodSymbol> OverriddenMembers { get; }
    public bool IsImplicitlyDeclared { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public string Name { get; }
    public string MetadataName { get; }
    public Accessibility DeclaredAccessibility { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public Symbol AssociatedSymbol { get; }
    internal bool ShadowsExplicitly { get; }
    public bool IsExtensionMethod { get; }
    internal bool MayBeReducibleExtensionMethod { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    protected SourcePropertySymbol BoundReturnTypeAttributesSource { get; }
    internal Accessibility LocalAccessibility { get; }
    internal bool HasDebuggerHiddenAttribute { get; }
    internal bool GenerateDebugInfoImpl { get; }
    private static SourcePropertyAccessorSymbol();
    internal SourcePropertyAccessorSymbol(SourcePropertySymbol propertySymbol, string name, SourceMemberFlags flags, SyntaxReference syntaxRef, ImmutableArray`1<Location> locations);
    private static ImmutableArray`1<ParameterSymbol> SynthesizeAutoGetterParameters(SourcePropertyAccessorSymbol getter, SourcePropertySymbol propertySymbol);
    private static ImmutableArray`1<ParameterSymbol> SynthesizeAutoSetterParameters(SourcePropertyAccessorSymbol setter, SourcePropertySymbol propertySymbol);
    internal static SourcePropertyAccessorSymbol CreatePropertyAccessor(SourcePropertySymbol propertySymbol, SourceMemberFlags kindFlags, SourceMemberFlags propertyFlags, Binder binder, AccessorBlockSyntax blockSyntax, DiagnosticBag diagnostics);
    public virtual MethodSymbol get_OverriddenMethod();
    internal virtual OverriddenMembersResult`1<MethodSymbol> get_OverriddenMembers();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual string get_Name();
    public virtual string get_MetadataName();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual TypeSymbol get_ReturnType();
    private TypeSymbol GetReturnType(SourceModuleSymbol sourceModule, SyntaxNodeOrToken& errorLocation, DiagnosticBag diagBag);
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    private ImmutableArray`1<ParameterSymbol> GetParameters(SourceModuleSymbol sourceModule, DiagnosticBag diagBag);
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual Symbol get_AssociatedSymbol();
    internal virtual bool get_ShadowsExplicitly();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public virtual bool get_IsExtensionMethod();
    internal virtual bool get_MayBeReducibleExtensionMethod();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    protected virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    protected virtual OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetReturnTypeAttributeDeclarations();
    protected virtual SourcePropertySymbol get_BoundReturnTypeAttributesSource();
    internal Accessibility get_LocalAccessibility();
    private static ImmutableArray`1<ParameterSymbol> BindParameters(SourcePropertySymbol propertySymbol, SourcePropertyAccessorSymbol method, Location location, Binder binder, ParameterListSyntax parameterListOpt, DiagnosticBag diagnostics);
    private static SourceParameterFlags CheckParameterModifier(Symbol container, SyntaxToken token, SourceParameterFlags flag, DiagnosticBag diagnostics);
    internal virtual BoundBlock GetBoundMethodBody(DiagnosticBag diagnostics, Binder& methodBodyBinder);
    internal virtual void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    internal bool get_HasDebuggerHiddenAttribute();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal virtual bool get_GenerateDebugInfoImpl();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourcePropertySymbol : PropertySymbol {
    private SourceMemberContainerTypeSymbol _containingType;
    private string _name;
    private string _lazyMetadataName;
    private SyntaxReference _syntaxRef;
    private SyntaxReference _blockRef;
    private Location _location;
    private SourceMemberFlags _flags;
    private TypeSymbol _lazyType;
    private ImmutableArray`1<ParameterSymbol> _lazyParameters;
    private MethodSymbol _getMethod;
    private MethodSymbol _setMethod;
    private FieldSymbol _backingField;
    private string _lazyDocComment;
    private ParameterSymbol _lazyMeParameter;
    private CustomAttributesBag`1<VisualBasicAttributeData> _lazyCustomAttributesBag;
    private CustomAttributesBag`1<VisualBasicAttributeData> _lazyReturnTypeCustomAttributesBag;
    private ImmutableArray`1<PropertySymbol> _lazyImplementedProperties;
    private OverriddenMembersResult`1<PropertySymbol> _lazyOverriddenProperties;
    private int _lazyState;
    private static SyntaxKind[] s_overridableModifierKinds;
    private static SyntaxKind[] s_accessibilityModifierKinds;
    internal DeclarationStatementSyntax DeclarationSyntax { get; }
    public TypeSymbol Type { get; }
    public string Name { get; }
    public string MetadataName { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public SourceMemberContainerTypeSymbol ContainingSourceType { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public AttributeLocation DefaultAttributeLocation { get; }
    internal bool HasSpecialName { get; }
    internal MarshalPseudoCustomAttributeData ReturnTypeMarshallingInformation { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public bool IsDefault { get; }
    public bool IsWriteOnly { get; }
    public bool IsReadOnly { get; }
    public MethodSymbol GetMethod { get; }
    public MethodSymbol SetMethod { get; }
    public bool IsOverloads { get; }
    public bool IsWithEvents { get; }
    internal bool ShadowsExplicitly { get; }
    internal bool OverloadsExplicitly { get; }
    internal bool OverridesExplicitly { get; }
    internal CallingConvention CallingConvention { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public int ParameterCount { get; }
    internal ParameterSymbol MeParameter { get; }
    public ImmutableArray`1<PropertySymbol> ExplicitInterfaceImplementations { get; }
    internal OverriddenMembersResult`1<PropertySymbol> OverriddenMembers { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool IsCustomProperty { get; }
    internal bool IsAutoProperty { get; }
    internal FieldSymbol AssociatedField { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    internal SyntaxReference SyntaxReference { get; }
    internal SyntaxReference BlockSyntaxReference { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal SyntaxTree SyntaxTree { get; }
    internal bool IsMyGroupCollectionProperty { get; }
    private static SourcePropertySymbol();
    private SourcePropertySymbol(SourceMemberContainerTypeSymbol container, string name, SourceMemberFlags flags, SyntaxReference syntaxRef, SyntaxReference blockRef, Location location);
    internal static SourcePropertySymbol Create(SourceMemberContainerTypeSymbol containingType, Binder bodyBinder, PropertyStatementSyntax syntax, PropertyBlockSyntax blockSyntaxOpt, DiagnosticBag diagnostics);
    internal static SourcePropertySymbol CreateWithEvents(SourceMemberContainerTypeSymbol containingType, Binder bodyBinder, SyntaxToken identifier, SyntaxReference syntaxRef, MemberModifiers modifiers, bool firstFieldDeclarationOfType, DiagnosticBag diagnostics);
    internal void CloneParametersForAccessor(MethodSymbol method, ArrayBuilder`1<ParameterSymbol> parameterBuilder);
    internal DeclarationStatementSyntax get_DeclarationSyntax();
    public virtual TypeSymbol get_Type();
    private TypeSymbol ComputeType(DiagnosticBag diagnostics);
    public virtual string get_Name();
    public virtual string get_MetadataName();
    internal virtual void SetMetadataName(string metadataName);
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public SourceMemberContainerTypeSymbol get_ContainingSourceType();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual bool IsDefinedInSourceTree(SyntaxTree tree, Nullable`1<TextSpan> definedWithinSpan, CancellationToken cancellationToken);
    public sealed virtual override AttributeLocation get_DefaultAttributeLocation();
    private OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetAttributeDeclarations();
    private OneOrMany`1<SyntaxList`1<AttributeListSyntax>> GetReturnTypeAttributeDeclarations();
    internal CustomAttributesBag`1<VisualBasicAttributeData> GetAttributesBag();
    internal CustomAttributesBag`1<VisualBasicAttributeData> GetReturnTypeAttributesBag();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    private CommonPropertyWellKnownAttributeData GetDecodedWellKnownAttributeData();
    private CommonReturnTypeWellKnownAttributeData GetDecodedReturnTypeWellKnownAttributeData();
    internal virtual VisualBasicAttributeData EarlyDecodeWellKnownAttribute(EarlyDecodeWellKnownAttributeArguments`4& arguments);
    internal virtual void DecodeWellKnownAttribute(DecodeWellKnownAttributeArguments`3& arguments);
    internal virtual bool get_HasSpecialName();
    internal MarshalPseudoCustomAttributeData get_ReturnTypeMarshallingInformation();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsShared();
    public virtual bool get_IsDefault();
    public virtual bool get_IsWriteOnly();
    public virtual bool get_IsReadOnly();
    public virtual MethodSymbol get_GetMethod();
    public virtual MethodSymbol get_SetMethod();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsWithEvents();
    internal virtual bool get_ShadowsExplicitly();
    internal bool get_OverloadsExplicitly();
    internal bool get_OverridesExplicitly();
    internal virtual CallingConvention get_CallingConvention();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    private void EnsureSignature();
    public virtual int get_ParameterCount();
    private ImmutableArray`1<ParameterSymbol> ComputeParameters(DiagnosticBag diagnostics);
    internal virtual ParameterSymbol get_MeParameter();
    public virtual ImmutableArray`1<PropertySymbol> get_ExplicitInterfaceImplementations();
    private ImmutableArray`1<PropertySymbol> ComputeExplicitInterfaceImplementations(DiagnosticBag diagnostics);
    internal ImmutableArray`1<MethodSymbol> GetAccessorImplementations(bool getter);
    internal virtual OverriddenMembersResult`1<PropertySymbol> get_OverriddenMembers();
    public virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsImplicitlyDeclared();
    internal bool get_IsCustomProperty();
    internal bool get_IsAutoProperty();
    internal virtual FieldSymbol get_AssociatedField();
    internal VisualBasicSyntaxNode get_Syntax();
    internal SyntaxReference get_SyntaxReference();
    internal SyntaxReference get_BlockSyntaxReference();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal Location GetImplementingLocation(PropertySymbol implementedProperty);
    private Binder CreateBinderForTypeDeclaration();
    private static SourcePropertyAccessorSymbol CreateAccessor(SourcePropertySymbol property, SourceMemberFlags kindFlags, SourceMemberFlags propertyFlags, Binder bodyBinder, AccessorBlockSyntax syntax, DiagnosticBag diagnostics);
    private static bool IsAccessibilityMoreRestrictive(Accessibility property, Accessibility accessor);
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    private void CopyPropertyCustomModifiers(PropertySymbol propertyWithCustomModifiers, TypeSymbol& type, ImmutableArray`1& typeCustomModifiers);
    private static MemberModifiers DecodeModifiers(SyntaxTokenList modifiers, SourceMemberContainerTypeSymbol container, Binder binder, DiagnosticBag diagBag);
    private static ImmutableArray`1<PropertySymbol> BindImplementsClause(SourceMemberContainerTypeSymbol containingType, Binder bodyBinder, SourcePropertySymbol prop, PropertyStatementSyntax syntax, DiagnosticBag diagnostics);
    private static Location GetAccessorBlockBeginLocation(SourcePropertyAccessorSymbol accessor);
    private static void ReportAccessorAccessibilityError(Binder binder, AccessorBlockSyntax syntax, ERRID errorId, DiagnosticBag diagnostics);
    private static bool HasRequiredParameters(ImmutableArray`1<ParameterSymbol> parameters);
    internal SyntaxTree get_SyntaxTree();
    private void SetCustomAttributeData(CustomAttributesBag`1<VisualBasicAttributeData> attributeData);
    internal virtual void GenerateDeclarationErrors(CancellationToken cancellationToken);
    internal virtual bool get_IsMyGroupCollectionProperty();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceSimpleParameterSymbol : SourceParameterSymbol {
    internal SyntaxList`1<AttributeListSyntax> AttributeDeclarationList { get; }
    public bool HasExplicitDefaultValue { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    public bool IsOptional { get; }
    public bool IsParamArray { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerMemberName { get; }
    internal bool IsCallerFilePath { get; }
    internal bool IsExplicitByRef { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    internal SourceSimpleParameterSymbol(Symbol container, string name, int ordinal, TypeSymbol type, Location location);
    internal virtual ParameterSymbol ChangeOwner(Symbol newContainingSymbol);
    private SourceComplexParameterSymbol GetCorrespondingPartialParameter();
    internal virtual SyntaxList`1<AttributeListSyntax> get_AttributeDeclarationList();
    internal virtual CustomAttributesBag`1<VisualBasicAttributeData> GetAttributesBag();
    internal virtual ParameterEarlyWellKnownAttributeData GetEarlyDecodedWellKnownAttributeData();
    internal virtual CommonParameterWellKnownAttributeData GetDecodedWellKnownAttributeData();
    public virtual bool get_HasExplicitDefaultValue();
    internal virtual ConstantValue get_ExplicitDefaultConstantValue(SymbolsInProgress`1<ParameterSymbol> inProgress);
    public virtual bool get_IsOptional();
    public virtual bool get_IsParamArray();
    internal virtual bool get_IsCallerLineNumber();
    internal virtual bool get_IsCallerMemberName();
    internal virtual bool get_IsCallerFilePath();
    internal virtual bool get_IsExplicitByRef();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    internal virtual ushort get_CountOfCustomModifiersPrecedingByRef();
    internal virtual ParameterSymbol WithTypeAndCustomModifiers(TypeSymbol type, ImmutableArray`1<CustomModifier> customModifiers, ushort countOfCustomModifiersPrecedingByRef);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceSymbolHelpers : object {
    public static SyntaxNodeOrToken GetAsClauseLocation(SyntaxToken identifier, AsClauseSyntax asClauseOpt);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceTypeParameterOnMethodSymbol : SourceTypeParameterSymbol {
    private SourceMemberMethodSymbol _container;
    private SyntaxReference _syntaxRef;
    public Symbol ContainingSymbol { get; }
    public TypeParameterKind TypeParameterKind { get; }
    public VarianceKind Variance { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    protected ImmutableArray`1<TypeParameterSymbol> ContainerTypeParameters { get; }
    public SourceTypeParameterOnMethodSymbol(SourceMemberMethodSymbol container, int ordinal, string name, SyntaxReference syntaxRef);
    public virtual Symbol get_ContainingSymbol();
    public virtual TypeParameterKind get_TypeParameterKind();
    public virtual VarianceKind get_Variance();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    protected virtual ImmutableArray`1<TypeParameterSymbol> get_ContainerTypeParameters();
    protected virtual ImmutableArray`1<TypeParameterConstraint> GetDeclaredConstraints(DiagnosticBag diagnostics);
    protected virtual bool ReportRedundantConstraints();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceTypeParameterOnTypeSymbol : SourceTypeParameterSymbol {
    private SourceNamedTypeSymbol _container;
    private ImmutableArray`1<SyntaxReference> _syntaxRefs;
    private VarianceKind _lazyVariance;
    public TypeParameterKind TypeParameterKind { get; }
    public VarianceKind Variance { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Symbol ContainingSymbol { get; }
    protected ImmutableArray`1<TypeParameterSymbol> ContainerTypeParameters { get; }
    public SourceTypeParameterOnTypeSymbol(SourceNamedTypeSymbol container, int ordinal, string name, ImmutableArray`1<SyntaxReference> syntaxRefs);
    public virtual TypeParameterKind get_TypeParameterKind();
    public virtual VarianceKind get_Variance();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual Symbol get_ContainingSymbol();
    protected virtual ImmutableArray`1<TypeParameterSymbol> get_ContainerTypeParameters();
    protected virtual ImmutableArray`1<TypeParameterConstraint> GetDeclaredConstraints(DiagnosticBag diagnostics);
    protected virtual bool ReportRedundantConstraints();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceTypeParameterSymbol : TypeParameterSymbol {
    private int _ordinal;
    private string _name;
    private ImmutableArray`1<TypeParameterConstraint> _lazyConstraints;
    private ImmutableArray`1<TypeSymbol> _lazyConstraintTypes;
    public int Ordinal { get; }
    public string Name { get; }
    public bool HasConstructorConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    internal ImmutableArray`1<TypeSymbol> ConstraintTypesNoUseSiteDiagnostics { get; }
    protected ImmutableArray`1<TypeParameterSymbol> ContainerTypeParameters { get; }
    public bool IsImplicitlyDeclared { get; }
    protected SourceTypeParameterSymbol(int ordinal, string name);
    public virtual int get_Ordinal();
    public virtual string get_Name();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    public virtual bool get_HasConstructorConstraint();
    public virtual bool get_HasReferenceTypeConstraint();
    public virtual bool get_HasValueTypeConstraint();
    internal virtual ImmutableArray`1<TypeSymbol> get_ConstraintTypesNoUseSiteDiagnostics();
    internal virtual ImmutableArray`1<TypeParameterConstraint> GetConstraints();
    internal virtual void ResolveConstraints(ConsList`1<TypeParameterSymbol> inProgress);
    internal virtual void EnsureAllConstraintsAreResolved();
    protected abstract virtual ImmutableArray`1<TypeParameterSymbol> get_ContainerTypeParameters();
    protected abstract virtual ImmutableArray`1<TypeParameterConstraint> GetDeclaredConstraints(DiagnosticBag diagnostics);
    protected abstract virtual bool ReportRedundantConstraints();
    protected static Location GetSymbolLocation(SyntaxReference syntaxRef);
    private static void CheckConstraintTypeConstraints(ImmutableArray`1<TypeParameterConstraint> constraints, DiagnosticBag diagnostics);
    private static Location GetLocation(TypeParameterDiagnosticInfo diagnostic);
    public virtual bool get_IsImplicitlyDeclared();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SourceWithEventsBackingFieldSymbol : SourceMemberFieldSymbol {
    private SourcePropertySymbol _property;
    public Symbol AssociatedSymbol { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsImplicitlyDeclared { get; }
    internal Symbol ImplicitlyDefinedBy { get; }
    public SourceWithEventsBackingFieldSymbol(SourcePropertySymbol property, SyntaxReference syntaxRef, string name);
    public virtual Symbol get_AssociatedSymbol();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual Symbol get_ImplicitlyDefinedBy(Dictionary`2<string, ArrayBuilder`1<Symbol>> membersInProgress);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SpecialTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsNumericType(SpecialType this);
    [ExtensionAttribute]
public static bool IsIntegralType(SpecialType this);
    [ExtensionAttribute]
public static bool IsUnsignedIntegralType(SpecialType this);
    [ExtensionAttribute]
public static bool IsSignedIntegralType(SpecialType this);
    [ExtensionAttribute]
public static bool IsFloatingType(SpecialType this);
    [ExtensionAttribute]
public static bool IsIntrinsicType(SpecialType this);
    [ExtensionAttribute]
public static bool IsIntrinsicValueType(SpecialType this);
    [ExtensionAttribute]
public static bool IsPrimitiveType(SpecialType this);
    [ExtensionAttribute]
public static bool IsStrictSupertypeOfConcreteDelegate(SpecialType this);
    [ExtensionAttribute]
public static bool IsRestrictedType(SpecialType this);
    [ExtensionAttribute]
public static bool IsValidTypeForAttributeArgument(SpecialType this);
    [ExtensionAttribute]
public static bool IsValidTypeForSwitchTable(SpecialType this);
    [ExtensionAttribute]
public static Nullable`1<int> TypeToIndex(SpecialType type);
    [ExtensionAttribute]
public static string GetNativeCompilerVType(SpecialType this);
    [ExtensionAttribute]
public static string GetDisplayName(SpecialType this);
    [ExtensionAttribute]
public static string TryGetKeywordText(SpecialType this);
    [ExtensionAttribute]
internal static ConstantValueTypeDiscriminator ToConstantValueDiscriminator(SpecialType this);
    [ExtensionAttribute]
internal static int GetShiftSizeMask(SpecialType this);
    [ExtensionAttribute]
public static Type ToRuntimeType(SpecialType this);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedErrorType : ErrorTypeSymbol {
    private InstanceErrorTypeSymbol _fullInstanceType;
    private TypeSubstitution _substitution;
    private Symbol _container;
    private bool IdentitySubstitutionOnMyTypeParameters { get; }
    public string Name { get; }
    internal bool MangleName { get; }
    public string MetadataName { get; }
    public bool IsImplicitlyDeclared { get; }
    public NamedTypeSymbol OriginalDefinition { get; }
    internal DiagnosticInfo ErrorInfo { get; }
    public NamedTypeSymbol ConstructedFrom { get; }
    internal TypeSubstitution TypeSubstitution { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public int Arity { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    internal ImmutableArray`1<TypeSymbol> TypeArgumentsNoUseSiteDiagnostics { get; }
    internal ImmutableArray`1<ImmutableArray`1<CustomModifier>> TypeArgumentsCustomModifiers { get; }
    internal bool HasTypeArgumentsCustomModifiers { get; }
    internal bool CanConstruct { get; }
    public Symbol ContainingSymbol { get; }
    public SubstitutedErrorType(Symbol container, InstanceErrorTypeSymbol fullInstanceType, TypeSubstitution substitution);
    private bool get_IdentitySubstitutionOnMyTypeParameters();
    public virtual string get_Name();
    internal virtual bool get_MangleName();
    public virtual string get_MetadataName();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual NamedTypeSymbol get_OriginalDefinition();
    internal virtual DiagnosticInfo get_ErrorInfo();
    public virtual NamedTypeSymbol get_ConstructedFrom();
    internal virtual TypeSubstitution get_TypeSubstitution();
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual int get_Arity();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal virtual ImmutableArray`1<TypeSymbol> get_TypeArgumentsNoUseSiteDiagnostics();
    internal virtual ImmutableArray`1<ImmutableArray`1<CustomModifier>> get_TypeArgumentsCustomModifiers();
    internal virtual bool get_HasTypeArgumentsCustomModifiers();
    internal virtual TypeWithModifiers InternalSubstituteTypeParameters(TypeSubstitution additionalSubstitution);
    private NamedTypeSymbol InternalSubstituteTypeParametersInSubstitutedErrorType(TypeSubstitution additionalSubstitution);
    internal virtual bool get_CanConstruct();
    public virtual NamedTypeSymbol Construct(ImmutableArray`1<TypeSymbol> typeArguments);
    public virtual Symbol get_ContainingSymbol();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedEventSymbol : EventSymbol {
    private EventSymbol _originalDefinition;
    private SubstitutedNamedType _containingType;
    private SubstitutedMethodSymbol _addMethod;
    private SubstitutedMethodSymbol _removeMethod;
    private SubstitutedMethodSymbol _raiseMethod;
    private SubstitutedFieldSymbol _associatedField;
    private TypeSymbol _lazyType;
    private ImmutableArray`1<EventSymbol> _lazyExplicitInterfaceImplementations;
    private OverriddenMembersResult`1<EventSymbol> _lazyOverriddenOrHiddenMembers;
    internal TypeSubstitution TypeSubstitution { get; }
    public TypeSymbol Type { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public EventSymbol OriginalDefinition { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsShared { get; }
    public bool IsNotOverridable { get; }
    public bool IsMustOverride { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsImplicitlyDeclared { get; }
    public MethodSymbol AddMethod { get; }
    public MethodSymbol RemoveMethod { get; }
    public MethodSymbol RaiseMethod { get; }
    internal FieldSymbol AssociatedField { get; }
    internal bool IsExplicitInterfaceImplementation { get; }
    public ImmutableArray`1<EventSymbol> ExplicitInterfaceImplementations { get; }
    public Accessibility DeclaredAccessibility { get; }
    internal OverriddenMembersResult`1<EventSymbol> OverriddenOrHiddenMembers { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public bool IsWindowsRuntimeEvent { get; }
    internal SubstitutedEventSymbol(SubstitutedNamedType containingType, EventSymbol originalDefinition, SubstitutedMethodSymbol addMethod, SubstitutedMethodSymbol removeMethod, SubstitutedMethodSymbol raiseMethod, SubstitutedFieldSymbol associatedField);
    internal TypeSubstitution get_TypeSubstitution();
    public virtual TypeSymbol get_Type();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual EventSymbol get_OriginalDefinition();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    public virtual bool get_IsShared();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual MethodSymbol get_AddMethod();
    public virtual MethodSymbol get_RemoveMethod();
    public virtual MethodSymbol get_RaiseMethod();
    internal virtual FieldSymbol get_AssociatedField();
    internal virtual bool get_IsExplicitInterfaceImplementation();
    public virtual ImmutableArray`1<EventSymbol> get_ExplicitInterfaceImplementations();
    public virtual Accessibility get_DeclaredAccessibility();
    internal virtual OverriddenMembersResult`1<EventSymbol> get_OverriddenOrHiddenMembers();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual bool get_IsWindowsRuntimeEvent();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedFieldSymbol : FieldSymbol {
    private SubstitutedNamedType _containingType;
    private FieldSymbol _originalDefinition;
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public string Name { get; }
    public string MetadataName { get; }
    internal bool HasSpecialName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal bool IsNotSerialized { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal Nullable`1<int> TypeLayoutOffset { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public FieldSymbol OriginalDefinition { get; }
    public bool IsConst { get; }
    public object ConstantValue { get; }
    public Symbol AssociatedSymbol { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsReadOnly { get; }
    public bool IsShared { get; }
    public bool IsImplicitlyDeclared { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public SubstitutedFieldSymbol(SubstitutedNamedType container, FieldSymbol originalDefinition);
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual string get_Name();
    public virtual string get_MetadataName();
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_HasRuntimeSpecialName();
    internal virtual bool get_IsNotSerialized();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual Nullable`1<int> get_TypeLayoutOffset();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual FieldSymbol get_OriginalDefinition();
    public virtual bool get_IsConst();
    public virtual object get_ConstantValue();
    internal virtual ConstantValue GetConstantValue(SymbolsInProgress`1<FieldSymbol> inProgress);
    public virtual Symbol get_AssociatedSymbol();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsShared();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedMethodSymbol : MethodSymbol {
    private Symbol _propertyOrEventSymbolOpt;
    private OverriddenMembersResult`1<MethodSymbol> _lazyOverriddenMethods;
    public MethodSymbol OriginalDefinition { get; }
    public string Name { get; }
    public string MetadataName { get; }
    public bool IsImplicitlyDeclared { get; }
    internal bool HasSpecialName { get; }
    internal MarshalPseudoCustomAttributeData ReturnTypeMarshallingInformation { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool HasDeclarativeSecurity { get; }
    public Symbol AssociatedSymbol { get; }
    public MethodSymbol ReducedFrom { get; }
    public TypeSymbol ReceiverType { get; }
    internal ImmutableArray`1<KeyValuePair`2<TypeParameterSymbol, TypeSymbol>> FixedTypeParameters { get; }
    internal int Proximity { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public MethodSymbol ConstructedFrom { get; }
    public Symbol ContainingSymbol { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsExtensionMethod { get; }
    internal bool MayBeReducibleExtensionMethod { get; }
    public bool IsExternalMethod { get; }
    public bool IsGenericMethod { get; }
    public TypeSubstitution TypeSubstitution { get; }
    public int Arity { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverloads { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public bool IsSub { get; }
    public bool IsAsync { get; }
    public bool IsIterator { get; }
    public bool IsVararg { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public MethodKind MethodKind { get; }
    internal bool IsMethodKindBasedOnSyntax { get; }
    internal int ParameterCount { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    internal CallingConvention CallingConvention { get; }
    internal bool CanConstruct { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    internal bool GenerateDebugInfoImpl { get; }
    protected virtual ImmutableArray`1<ParameterSymbol> SubstituteParameters();
    public abstract virtual MethodSymbol get_OriginalDefinition();
    public sealed virtual string get_Name();
    public sealed virtual string get_MetadataName();
    public sealed virtual bool get_IsImplicitlyDeclared();
    internal sealed virtual bool get_HasSpecialName();
    public sealed virtual DllImportData GetDllImportData();
    internal sealed virtual MarshalPseudoCustomAttributeData get_ReturnTypeMarshallingInformation();
    internal sealed virtual MethodImplAttributes get_ImplementationAttributes();
    internal sealed virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    public virtual Symbol get_AssociatedSymbol();
    public virtual MethodSymbol get_ReducedFrom();
    public virtual TypeSymbol get_ReceiverType();
    public virtual TypeSymbol GetTypeInferredDuringReduction(TypeParameterSymbol reducedFromTypeParameter);
    internal virtual bool CallsAreOmitted(SyntaxNodeOrToken atNode, SyntaxTree syntaxTree);
    internal virtual ImmutableArray`1<KeyValuePair`2<TypeParameterSymbol, TypeSymbol>> get_FixedTypeParameters();
    internal virtual int get_Proximity();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public abstract virtual MethodSymbol get_ConstructedFrom();
    public abstract virtual Symbol get_ContainingSymbol();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    public virtual bool get_IsExtensionMethod();
    internal virtual bool get_MayBeReducibleExtensionMethod();
    public virtual bool get_IsExternalMethod();
    public virtual bool get_IsGenericMethod();
    public abstract virtual TypeSubstitution get_TypeSubstitution();
    public virtual int get_Arity();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsShared();
    public virtual bool get_IsSub();
    public virtual bool get_IsAsync();
    public virtual bool get_IsIterator();
    public virtual bool get_IsVararg();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual MethodKind get_MethodKind();
    internal sealed virtual bool get_IsMethodKindBasedOnSyntax();
    internal sealed virtual int get_ParameterCount();
    public abstract virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public abstract virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public abstract virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    internal virtual CallingConvention get_CallingConvention();
    internal sealed virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal sealed virtual bool TryGetMeParameter(ParameterSymbol& meParameter);
    public virtual int GetHashCode();
    public abstract virtual bool Equals(object obj);
    private bool EqualsWithNoRegardToTypeArguments(T other);
    internal abstract virtual bool get_CanConstruct();
    public abstract virtual MethodSymbol Construct(ImmutableArray`1<TypeSymbol> typeArguments);
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal bool SetAssociatedPropertyOrEvent(Symbol propertyOrEventSymbol);
    internal virtual VisualBasicSyntaxNode get_Syntax();
    internal sealed virtual bool get_GenerateDebugInfoImpl();
    internal sealed virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedNamedType : NamedTypeSymbol {
    private TypeSubstitution _substitution;
    public string Name { get; }
    internal bool MangleName { get; }
    public string MetadataName { get; }
    internal string DefaultPropertyName { get; }
    internal bool HasSpecialName { get; }
    internal bool IsSerializable { get; }
    internal TypeLayout Layout { get; }
    internal CharSet MarshallingCharSet { get; }
    internal TypeSubstitution TypeSubstitution { get; }
    public NamedTypeSymbol OriginalDefinition { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public int Arity { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsMustInherit { get; }
    public bool IsNotInheritable { get; }
    public bool IsImplicitlyDeclared { get; }
    internal EmbeddedSymbolKind EmbeddedSymbolKind { get; }
    public bool MightContainExtensionMethods { get; }
    internal bool HasEmbeddedAttribute { get; }
    internal bool IsExtensibleInterfaceNoUseSiteDiagnostics { get; }
    internal bool IsWindowsRuntimeImport { get; }
    internal bool ShouldAddWinRTMembers { get; }
    internal bool IsComImport { get; }
    internal TypeSymbol CoClassType { get; }
    internal bool HasDeclarativeSecurity { get; }
    public TypeKind TypeKind { get; }
    internal bool IsInterface { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public NamedTypeSymbol EnumUnderlyingType { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public IEnumerable`1<string> MemberNames { get; }
    private SubstitutedNamedType(TypeSubstitution substitution);
    public sealed virtual string get_Name();
    internal sealed virtual bool get_MangleName();
    public sealed virtual string get_MetadataName();
    internal sealed virtual string get_DefaultPropertyName();
    internal sealed virtual bool get_HasSpecialName();
    internal sealed virtual bool get_IsSerializable();
    internal virtual TypeLayout get_Layout();
    internal virtual CharSet get_MarshallingCharSet();
    internal sealed virtual TypeSubstitution get_TypeSubstitution();
    public sealed virtual NamedTypeSymbol get_OriginalDefinition();
    public sealed virtual AssemblySymbol get_ContainingAssembly();
    public sealed virtual int get_Arity();
    public sealed virtual Accessibility get_DeclaredAccessibility();
    public sealed virtual bool get_IsMustInherit();
    public sealed virtual bool get_IsNotInheritable();
    public sealed virtual bool get_IsImplicitlyDeclared();
    internal sealed virtual EmbeddedSymbolKind get_EmbeddedSymbolKind();
    public sealed virtual bool get_MightContainExtensionMethods();
    internal sealed virtual bool get_HasEmbeddedAttribute();
    internal virtual bool get_IsExtensibleInterfaceNoUseSiteDiagnostics();
    internal sealed virtual bool get_IsWindowsRuntimeImport();
    internal sealed virtual bool get_ShouldAddWinRTMembers();
    internal sealed virtual bool get_IsComImport();
    internal virtual TypeSymbol get_CoClassType();
    internal sealed virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal sealed virtual AttributeUsageInfo GetAttributeUsageInfo();
    internal sealed virtual bool get_HasDeclarativeSecurity();
    internal sealed virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    public sealed virtual TypeKind get_TypeKind();
    internal virtual bool get_IsInterface();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public sealed virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public sealed virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    public sealed virtual NamedTypeSymbol get_EnumUnderlyingType();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal sealed virtual NamedTypeSymbol MakeDeclaredBase(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    internal sealed virtual ImmutableArray`1<NamedTypeSymbol> MakeDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    internal sealed virtual NamedTypeSymbol MakeAcyclicBaseType(DiagnosticBag diagnostics);
    internal sealed virtual ImmutableArray`1<NamedTypeSymbol> MakeAcyclicInterfaces(DiagnosticBag diagnostics);
    private NamedTypeSymbol SubstituteTypeParametersForMemberType(NamedTypeSymbol memberType);
    protected virtual SubstitutedMethodSymbol SubstituteTypeParametersForMemberMethod(MethodSymbol memberMethod);
    protected virtual SubstitutedFieldSymbol SubstituteTypeParametersForMemberField(FieldSymbol memberField);
    private SubstitutedPropertySymbol SubstituteTypeParametersForMemberProperty(PropertySymbol memberProperty);
    private SubstitutedEventSymbol SubstituteTypeParametersForMemberEvent(EventSymbol memberEvent);
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual ImmutableArray`1<Symbol> GetMembers();
    internal virtual ImmutableArray`1<Symbol> GetMembersUnordered();
    private ImmutableArray`1<Symbol> GetMembers_Worker(ImmutableArray`1<Symbol> members);
    protected virtual SubstitutedEventSymbol CreateSubstitutedEventSymbol(EventSymbol memberEvent, SubstitutedMethodSymbol addMethod, SubstitutedMethodSymbol removeMethod, SubstitutedMethodSymbol raiseMethod, SubstitutedFieldSymbol associatedField);
    private static SubstitutedMethodSymbol GetMethodSubstitute(Dictionary`2<MethodSymbol, SubstitutedMethodSymbol> methodSubstitutions, MethodSymbol method);
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembersUnordered();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    internal sealed virtual IEnumerable`1<FieldSymbol> GetFieldsToEmit();
    internal Symbol GetMemberForDefinition(Symbol member);
    private Symbol SubstituteTypeParametersInMember(Symbol member);
    public virtual int GetHashCode();
    public abstract virtual bool Equals(object obj);
    private bool EqualsWithNoRegardToTypeArguments(T other);
    internal virtual NamedTypeSymbol GetDirectBaseTypeNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal virtual void GenerateDeclarationErrors(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private SubstitutedMethodSymbol _Lambda$__81-1(MethodSymbol m);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedParameterSymbol : ParameterSymbol {
    private ParameterSymbol _originalDefinition;
    public string Name { get; }
    public string MetadataName { get; }
    public int Ordinal { get; }
    public Symbol ContainingSymbol { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    public bool HasExplicitDefaultValue { get; }
    public bool IsOptional { get; }
    public bool IsParamArray { get; }
    public bool IsImplicitlyDeclared { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public TypeSymbol Type { get; }
    public bool IsByRef { get; }
    internal bool IsMetadataOut { get; }
    internal bool IsMetadataIn { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal bool HasOptionCompare { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerMemberName { get; }
    internal bool IsCallerFilePath { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    internal bool IsExplicitByRef { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public ParameterSymbol OriginalDefinition { get; }
    protected TypeSubstitution TypeSubstitution { get; }
    protected SubstitutedParameterSymbol(ParameterSymbol originalDefinition);
    public static SubstitutedParameterSymbol CreateMethodParameter(SubstitutedMethodSymbol container, ParameterSymbol originalDefinition);
    public static SubstitutedParameterSymbol CreatePropertyParameter(SubstitutedPropertySymbol container, ParameterSymbol originalDefinition);
    public virtual string get_Name();
    public virtual string get_MetadataName();
    public virtual int get_Ordinal();
    public abstract virtual Symbol get_ContainingSymbol();
    internal virtual ConstantValue get_ExplicitDefaultConstantValue(SymbolsInProgress`1<ParameterSymbol> inProgress);
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    public virtual bool get_HasExplicitDefaultValue();
    public virtual bool get_IsOptional();
    public virtual bool get_IsParamArray();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual TypeSymbol get_Type();
    public virtual bool get_IsByRef();
    internal virtual bool get_IsMetadataOut();
    internal virtual bool get_IsMetadataIn();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual bool get_HasOptionCompare();
    internal virtual bool get_IsIDispatchConstant();
    internal virtual bool get_IsIUnknownConstant();
    internal virtual bool get_IsCallerLineNumber();
    internal virtual bool get_IsCallerMemberName();
    internal virtual bool get_IsCallerFilePath();
    internal sealed virtual ushort get_CountOfCustomModifiersPrecedingByRef();
    internal virtual bool get_IsExplicitByRef();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual ParameterSymbol get_OriginalDefinition();
    protected abstract virtual TypeSubstitution get_TypeSubstitution();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedPropertySymbol : PropertySymbol {
    private SubstitutedNamedType _containingType;
    private PropertySymbol _originalDefinition;
    private ImmutableArray`1<ParameterSymbol> _parameters;
    private SubstitutedMethodSymbol _getMethod;
    private SubstitutedMethodSymbol _setMethod;
    private SubstitutedFieldSymbol _associatedField;
    public string Name { get; }
    public string MetadataName { get; }
    internal bool HasSpecialName { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public PropertySymbol OriginalDefinition { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public bool IsWithEvents { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<PropertySymbol> ExplicitInterfaceImplementations { get; }
    public MethodSymbol GetMethod { get; }
    public MethodSymbol SetMethod { get; }
    internal FieldSymbol AssociatedField { get; }
    public bool IsDefault { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public bool IsOverloads { get; }
    public bool IsImplicitlyDeclared { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public int ParameterCount { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    internal CallingConvention CallingConvention { get; }
    internal TypeSubstitution TypeSubstitution { get; }
    internal bool IsMyGroupCollectionProperty { get; }
    public SubstitutedPropertySymbol(SubstitutedNamedType container, PropertySymbol originalDefinition, SubstitutedMethodSymbol getMethod, SubstitutedMethodSymbol setMethod, SubstitutedFieldSymbol associatedField);
    public virtual string get_Name();
    public virtual string get_MetadataName();
    internal virtual bool get_HasSpecialName();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual PropertySymbol get_OriginalDefinition();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual bool get_IsWithEvents();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<PropertySymbol> get_ExplicitInterfaceImplementations();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    public virtual MethodSymbol get_GetMethod();
    public virtual MethodSymbol get_SetMethod();
    internal virtual FieldSymbol get_AssociatedField();
    public virtual bool get_IsDefault();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsShared();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual int get_ParameterCount();
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
    internal virtual CallingConvention get_CallingConvention();
    internal TypeSubstitution get_TypeSubstitution();
    private ImmutableArray`1<ParameterSymbol> SubstituteParameters();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    internal virtual bool get_IsMyGroupCollectionProperty();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SubstitutedTypeParameterSymbol : TypeParameterSymbol {
    private Symbol _containingSymbol;
    private TypeParameterSymbol _originalDefinition;
    public TypeParameterKind TypeParameterKind { get; }
    public string Name { get; }
    public string MetadataName { get; }
    public TypeParameterSymbol OriginalDefinition { get; }
    public TypeParameterSymbol ReducedFrom { get; }
    private TypeSubstitution TypeSubstitution { get; }
    internal ImmutableArray`1<TypeSymbol> ConstraintTypesNoUseSiteDiagnostics { get; }
    public Symbol ContainingSymbol { get; }
    public bool HasConstructorConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public bool IsImplicitlyDeclared { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public int Ordinal { get; }
    public VarianceKind Variance { get; }
    public SubstitutedTypeParameterSymbol(TypeParameterSymbol originalDefinition);
    public virtual TypeParameterKind get_TypeParameterKind();
    public virtual string get_Name();
    public virtual string get_MetadataName();
    public void SetContainingSymbol(Symbol container);
    public virtual TypeParameterSymbol get_OriginalDefinition();
    public virtual TypeParameterSymbol get_ReducedFrom();
    private TypeSubstitution get_TypeSubstitution();
    internal virtual ImmutableArray`1<TypeSymbol> get_ConstraintTypesNoUseSiteDiagnostics();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    public virtual bool get_HasConstructorConstraint();
    public virtual bool get_HasReferenceTypeConstraint();
    public virtual bool get_HasValueTypeConstraint();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual int get_Ordinal();
    public virtual VarianceKind get_Variance();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    internal virtual TypeWithModifiers InternalSubstituteTypeParameters(TypeSubstitution substitution);
    internal virtual void EnsureAllConstraintsAreResolved();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolComparisonResults : Enum {
    public int value__;
    public static SymbolComparisonResults NameMismatch;
    public static SymbolComparisonResults ReturnTypeMismatch;
    public static SymbolComparisonResults ArityMismatch;
    public static SymbolComparisonResults ConstraintMismatch;
    public static SymbolComparisonResults CallingConventionMismatch;
    public static SymbolComparisonResults CustomModifierMismatch;
    public static SymbolComparisonResults RequiredExtraParameterMismatch;
    public static SymbolComparisonResults OptionalParameterMismatch;
    public static SymbolComparisonResults RequiredParameterTypeMismatch;
    public static SymbolComparisonResults OptionalParameterTypeMismatch;
    public static SymbolComparisonResults OptionalParameterValueMismatch;
    public static SymbolComparisonResults ParameterByrefMismatch;
    public static SymbolComparisonResults ParamArrayMismatch;
    public static SymbolComparisonResults PropertyAccessorMismatch;
    public static SymbolComparisonResults VarargMismatch;
    public static SymbolComparisonResults TotalParameterCountMismatch;
    public static SymbolComparisonResults AllParameterMismatches;
    public static SymbolComparisonResults AllMismatches;
    public static SymbolComparisonResults MismatchesForConflictingMethods;
    public static SymbolComparisonResults MismatchesForExplicitInterfaceImplementations;
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolExtensions : object {
    internal static NamespaceKind NamespaceKindNamespaceGroup;
    [ExtensionAttribute]
internal static bool IsCompilationOutputWinMdObj(Symbol symbol);
    [ExtensionAttribute]
internal static string GetKindText(Symbol target);
    [ExtensionAttribute]
internal static string GetPropertyKindText(PropertySymbol target);
    [ExtensionAttribute]
internal static object ToErrorMessageArgument(Symbol target, ERRID errorCode);
    [ExtensionAttribute]
internal static bool MatchesAnyName(ImmutableArray`1<TypeParameterSymbol> this, string name);
    [ExtensionAttribute]
public static bool IsOverloadable(Symbol symbol);
    [ExtensionAttribute]
public static bool IsOverloadable(PropertySymbol propertySymbol);
    [ExtensionAttribute]
internal static bool IsOverloads(Symbol sym);
    [ExtensionAttribute]
internal static bool IsShadows(Symbol sym);
    [ExtensionAttribute]
internal static bool IsInstanceMember(Symbol sym);
    [ExtensionAttribute]
internal static bool RequiresImplementation(Symbol sym);
    [ExtensionAttribute]
internal static bool IsMetadataVirtual(MethodSymbol method);
    [ExtensionAttribute]
public static bool IsAccessor(MethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsAccessor(Symbol symbol);
    [ExtensionAttribute]
public static bool IsWithEventsProperty(Symbol symbol);
    [ExtensionAttribute]
public static bool IsPropertyAndNotWithEvents(Symbol symbol);
    [ExtensionAttribute]
internal static bool IsAnyConstructor(MethodSymbol method);
    [ExtensionAttribute]
internal static bool IsDefaultValueTypeConstructor(MethodSymbol method);
    [ExtensionAttribute]
internal static bool IsReducedExtensionMethod(Symbol this);
    [ExtensionAttribute]
internal static Symbol OverriddenMember(Symbol sym);
    [ExtensionAttribute]
internal static int GetArity(Symbol symbol);
    [ExtensionAttribute]
internal static ParameterSymbol GetMeParameter(Symbol sym);
    [ExtensionAttribute]
internal static NamespaceOrTypeSymbol OfMinimalArity(IEnumerable`1<NamespaceOrTypeSymbol> symbols);
    [ExtensionAttribute]
internal static Symbol UnwrapAlias(Symbol symbol);
    [ExtensionAttribute]
internal static bool IsUserDefinedOperator(Symbol symbol);
    [ExtensionAttribute]
internal static bool IsHiddenByEmbeddedAttribute(Symbol symbol);
    [ExtensionAttribute]
internal static T GetDeclaringSyntaxNode(Symbol this);
    [ExtensionAttribute]
internal static T AsMember(T origMember, NamedTypeSymbol type);
    [ExtensionAttribute]
internal static TDestination EnsureVbSymbolOrNothing(TSource symbol, string paramName);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedAccessor`1 : SynthesizedMethodBase {
    protected T m_propertyOrEvent;
    private string _lazyMetadataName;
    public string Name { get; }
    public string MetadataName { get; }
    internal bool HasSpecialName { get; }
    public Symbol AssociatedSymbol { get; }
    public T PropertyOrEvent { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverloads { get; }
    internal bool ShadowsExplicitly { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public ImmutableArray`1<Location> Locations { get; }
    internal Symbol ImplicitlyDefinedBy { get; }
    protected SynthesizedAccessor`1(NamedTypeSymbol container, T propertyOrEvent);
    public sealed virtual string get_Name();
    public virtual string get_MetadataName();
    protected virtual string GenerateMetadataName();
    internal sealed virtual bool get_HasSpecialName();
    public sealed virtual Symbol get_AssociatedSymbol();
    public T get_PropertyOrEvent();
    public sealed virtual Accessibility get_DeclaredAccessibility();
    public sealed virtual bool get_IsMustOverride();
    public sealed virtual bool get_IsNotOverridable();
    public sealed virtual bool get_IsOverloads();
    internal sealed virtual bool get_ShadowsExplicitly();
    public sealed virtual bool get_IsOverridable();
    public sealed virtual bool get_IsOverrides();
    public sealed virtual bool get_IsShared();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    internal sealed virtual Symbol get_ImplicitlyDefinedBy(Dictionary`2<string, ArrayBuilder`1<Symbol>> membersInProgress);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedAddAccessorSymbol : SynthesizedEventAccessorSymbol {
    public MethodKind MethodKind { get; }
    public SynthesizedAddAccessorSymbol(SourceMemberContainerTypeSymbol container, SourceEventSymbol event);
    public virtual MethodKind get_MethodKind();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedAttributeData : SourceAttributeData {
    internal SynthesizedAttributeData(MethodSymbol wellKnownMember, ImmutableArray`1<TypedConstant> arguments, ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArgs);
    internal static SynthesizedAttributeData Create(MethodSymbol constructorSymbol, WellKnownMember constructor, ImmutableArray`1<TypedConstant> arguments, ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArguments);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedBackingFieldBase`1 : FieldSymbol {
    protected T _propertyOrEvent;
    protected string _name;
    protected bool _isShared;
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public Symbol AssociatedSymbol { get; }
    internal bool ShadowsExplicitly { get; }
    public bool IsReadOnly { get; }
    public bool IsConst { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsShared { get; }
    public bool IsImplicitlyDeclared { get; }
    internal Symbol ImplicitlyDefinedBy { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal bool IsNotSerialized { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal Nullable`1<int> TypeLayoutOffset { get; }
    public SynthesizedBackingFieldBase`1(T propertyOrEvent, string name, bool isShared);
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public sealed virtual Symbol get_AssociatedSymbol();
    internal sealed virtual bool get_ShadowsExplicitly();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsConst();
    internal virtual ConstantValue GetConstantValue(SymbolsInProgress`1<FieldSymbol> inProgress);
    public sealed virtual Symbol get_ContainingSymbol();
    public sealed virtual NamedTypeSymbol get_ContainingType();
    internal sealed virtual LexicalSortKey GetLexicalSortKey();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public sealed virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public sealed virtual Accessibility get_DeclaredAccessibility();
    public sealed virtual bool get_IsShared();
    public sealed virtual bool get_IsImplicitlyDeclared();
    internal sealed virtual Symbol get_ImplicitlyDefinedBy(Dictionary`2<string, ArrayBuilder`1<Symbol>> membersInProgress);
    public sealed virtual string get_Name();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_HasRuntimeSpecialName();
    internal virtual bool get_IsNotSerialized();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual Nullable`1<int> get_TypeLayoutOffset();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedClonedTypeParameterSymbol : TypeParameterSymbol {
    private Func`2<Symbol, TypeSubstitution> _typeMapFactory;
    private Symbol _container;
    private TypeParameterSymbol _correspondingMethodTypeParameter;
    private string _name;
    private ImmutableArray`1<TypeSymbol> _lazyConstraints;
    public TypeParameterKind TypeParameterKind { get; }
    private TypeSubstitution TypeMap { get; }
    internal ImmutableArray`1<TypeSymbol> ConstraintTypesNoUseSiteDiagnostics { get; }
    public Symbol ContainingSymbol { get; }
    public bool HasConstructorConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public int Ordinal { get; }
    public VarianceKind Variance { get; }
    public string Name { get; }
    internal SynthesizedClonedTypeParameterSymbol(TypeParameterSymbol correspondingMethodTypeParameter, Symbol container, string name, Func`2<Symbol, TypeSubstitution> typeMapFactory);
    internal static ImmutableArray`1<TypeParameterSymbol> MakeTypeParameters(ImmutableArray`1<TypeParameterSymbol> origParameters, Symbol container, Func`3<TypeParameterSymbol, Symbol, TypeParameterSymbol> mapFunction);
    public virtual TypeParameterKind get_TypeParameterKind();
    private TypeSubstitution get_TypeMap();
    internal virtual ImmutableArray`1<TypeSymbol> get_ConstraintTypesNoUseSiteDiagnostics();
    public virtual Symbol get_ContainingSymbol();
    public virtual bool get_HasConstructorConstraint();
    public virtual bool get_HasReferenceTypeConstraint();
    public virtual bool get_HasValueTypeConstraint();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual int get_Ordinal();
    public virtual VarianceKind get_Variance();
    public virtual string get_Name();
    internal virtual void EnsureAllConstraintsAreResolved();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorBase : SynthesizedMethodBase {
    protected bool m_isShared;
    protected SyntaxReference m_syntaxReference;
    protected TypeSymbol m_voidType;
    public string Name { get; }
    internal bool HasSpecialName { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverloads { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public bool IsSub { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public MethodKind MethodKind { get; }
    public TypeSymbol ReturnType { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    public bool IsExternalMethod { get; }
    protected SynthesizedConstructorBase(SyntaxReference syntaxReference, NamedTypeSymbol container, bool isShared, Binder binder, DiagnosticBag diagnostics);
    public sealed virtual string get_Name();
    internal sealed virtual bool get_HasSpecialName();
    public virtual Accessibility get_DeclaredAccessibility();
    public sealed virtual bool get_IsMustOverride();
    public sealed virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverloads();
    public sealed virtual bool get_IsOverridable();
    public sealed virtual bool get_IsOverrides();
    public sealed virtual bool get_IsShared();
    public sealed virtual bool get_IsSub();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public virtual ImmutableArray`1<Location> get_Locations();
    public sealed virtual MethodKind get_MethodKind();
    public sealed virtual TypeSymbol get_ReturnType();
    internal sealed virtual VisualBasicSyntaxNode get_Syntax();
    public virtual bool get_IsExternalMethod();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedConstructorSymbol : SynthesizedConstructorBase {
    private bool _debuggable;
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    internal bool GenerateDebugInfoImpl { get; }
    internal SynthesizedConstructorSymbol(SyntaxReference syntaxReference, NamedTypeSymbol container, bool isShared, bool isDebuggable, Binder binder, DiagnosticBag diagnostics);
    internal virtual BoundBlock GetBoundMethodBody(DiagnosticBag diagnostics, Binder& methodBodyBinder);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal virtual bool get_GenerateDebugInfoImpl();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedDelegateMethodSymbol : MethodSymbol {
    private string _name;
    private NamedTypeSymbol _containingType;
    private TypeSymbol _returnType;
    private SourceMemberFlags _flags;
    private ImmutableArray`1<ParameterSymbol> _parameters;
    public int Arity { get; }
    public Symbol AssociatedSymbol { get; }
    internal CallingConvention CallingConvention { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public bool IsExtensionMethod { get; }
    public bool IsExternalMethod { get; }
    internal MarshalPseudoCustomAttributeData ReturnTypeMarshallingInformation { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool HasDeclarativeSecurity { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverloads { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public bool IsSub { get; }
    public bool IsAsync { get; }
    public bool IsIterator { get; }
    public bool IsVararg { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public MethodKind MethodKind { get; }
    internal bool IsMethodKindBasedOnSyntax { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public bool IsImplicitlyDeclared { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool GenerateDebugInfoImpl { get; }
    public SynthesizedDelegateMethodSymbol(string name, NamedTypeSymbol containingSymbol, SourceMemberFlags flags, TypeSymbol returnType);
    internal void SetParameters(ImmutableArray`1<ParameterSymbol> parameters);
    public virtual int get_Arity();
    public virtual Symbol get_AssociatedSymbol();
    internal virtual CallingConvention get_CallingConvention();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual bool get_IsExtensionMethod();
    public virtual bool get_IsExternalMethod();
    public virtual DllImportData GetDllImportData();
    internal virtual MarshalPseudoCustomAttributeData get_ReturnTypeMarshallingInformation();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsShared();
    public virtual bool get_IsSub();
    public virtual bool get_IsAsync();
    public virtual bool get_IsIterator();
    public virtual bool get_IsVararg();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual MethodKind get_MethodKind();
    internal virtual bool get_IsMethodKindBasedOnSyntax();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetReturnTypeAttributes();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual VisualBasicSyntaxNode get_Syntax();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal virtual bool get_GenerateDebugInfoImpl();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedEntryPointSymbol : SynthesizedMethodBase {
    internal static string MainName;
    internal static string FactoryName;
    private NamedTypeSymbol _containingType;
    private TypeSymbol _returnType;
    public string Name { get; }
    internal bool HasSpecialName { get; }
    public bool IsSub { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    public bool IsOverloads { get; }
    public bool IsShared { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public Symbol AssociatedSymbol { get; }
    public MethodKind MethodKind { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    internal bool GenerateDebugInfoImpl { get; }
    private SynthesizedEntryPointSymbol(NamedTypeSymbol containingType, TypeSymbol returnType);
    internal static SynthesizedEntryPointSymbol Create(SynthesizedInteractiveInitializerMethod initializerMethod, DiagnosticBag diagnostics);
    internal abstract virtual BoundBlock CreateBody();
    public abstract virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    public virtual bool get_IsSub();
    internal virtual VisualBasicSyntaxNode get_Syntax();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsShared();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual Accessibility get_DeclaredAccessibility();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual Symbol get_AssociatedSymbol();
    public virtual MethodKind get_MethodKind();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    internal virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_GenerateDebugInfoImpl();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    private VisualBasicSyntaxNode GetSyntax();
    private static void ReportUseSiteDiagnostics(Symbol symbol, DiagnosticBag diagnostics);
    private static MethodSymbol GetRequiredMethod(TypeSymbol type, string methodName, DiagnosticBag diagnostics);
    private static BoundCall CreateParameterlessCall(VisualBasicSyntaxNode syntax, BoundExpression receiver, MethodSymbol method);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedEventAccessorSymbol : SynthesizedAccessor`1<SourceEventSymbol> {
    private TypeSymbol _lazyReturnType;
    private ImmutableArray`1<ParameterSymbol> _lazyParameters;
    private ImmutableArray`1<MethodSymbol> _lazyExplicitImplementations;
    private SourceEventSymbol SourceEvent { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public TypeSymbol ReturnType { get; }
    public bool IsSub { get; }
    internal bool GenerateDebugInfoImpl { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    protected SynthesizedEventAccessorSymbol(SourceMemberContainerTypeSymbol container, SourceEventSymbol event);
    private SourceEventSymbol get_SourceEvent();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual TypeSymbol get_ReturnType();
    public virtual bool get_IsSub();
    internal virtual BoundBlock GetBoundMethodBody(DiagnosticBag diagnostics, Binder& methodBodyBinder);
    protected static BoundBlock ConstructFieldLikeEventAccessorBody(SourceEventSymbol eventSymbol, bool isAddMethod, VisualBasicCompilation compilation, DiagnosticBag diagnostics);
    private static BoundBlock ConstructFieldLikeEventAccessorBody_WinRT(SourceEventSymbol eventSymbol, bool isAddMethod, VisualBasicCompilation compilation, DiagnosticBag diagnostics);
    private static BoundBlock ConstructFieldLikeEventAccessorBody_Regular(SourceEventSymbol eventSymbol, bool isAddMethod, VisualBasicCompilation compilation, DiagnosticBag diagnostics);
    internal virtual void GenerateDeclarationErrors(CancellationToken cancellationToken);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal sealed virtual bool get_GenerateDebugInfoImpl();
    internal sealed virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    internal virtual MethodImplAttributes get_ImplementationAttributes();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedEventBackingFieldSymbol : SynthesizedBackingFieldBase`1<SourceEventSymbol> {
    private TypeSymbol _lazyType;
    internal bool IsNotSerialized { get; }
    public TypeSymbol Type { get; }
    public SynthesizedEventBackingFieldSymbol(SourceEventSymbol propertyOrEvent, string name, bool isShared);
    internal virtual bool get_IsNotSerialized();
    public virtual TypeSymbol get_Type();
    internal virtual void GenerateDeclarationErrors(CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedEventDelegateSymbol : InstanceTypeSymbol {
    private string _eventName;
    private string _name;
    private NamedTypeSymbol _containingType;
    private SyntaxReference _syntaxRef;
    private ImmutableArray`1<Symbol> _lazyMembers;
    private EventSymbol _lazyEventSymbol;
    private int _reportedAllDeclarationErrors;
    private EventStatementSyntax EventSyntax { get; }
    public Symbol AssociatedSymbol { get; }
    internal Symbol ImplicitlyDefinedBy { get; }
    public int Arity { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public Accessibility DeclaredAccessibility { get; }
    internal string DefaultPropertyName { get; }
    public bool IsMustInherit { get; }
    public bool IsNotInheritable { get; }
    internal bool ShadowsExplicitly { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal bool MangleName { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public bool MightContainExtensionMethods { get; }
    internal bool HasEmbeddedAttribute { get; }
    internal bool IsExtensibleInterfaceNoUseSiteDiagnostics { get; }
    internal bool IsWindowsRuntimeImport { get; }
    internal bool ShouldAddWinRTMembers { get; }
    internal bool IsComImport { get; }
    internal TypeSymbol CoClassType { get; }
    internal bool HasDeclarativeSecurity { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal bool IsSerializable { get; }
    internal TypeLayout Layout { get; }
    internal CharSet MarshallingCharSet { get; }
    public TypeKind TypeKind { get; }
    internal bool IsInterface { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public bool IsImplicitlyDeclared { get; }
    internal EmbeddedSymbolKind EmbeddedSymbolKind { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal SynthesizedEventDelegateSymbol(SyntaxReference syntaxRef, NamedTypeSymbol containingSymbol);
    public virtual ImmutableArray`1<Symbol> GetMembers();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    internal virtual IEnumerable`1<FieldSymbol> GetFieldsToEmit();
    private EventStatementSyntax get_EventSyntax();
    public virtual Symbol get_AssociatedSymbol();
    internal virtual Symbol get_ImplicitlyDefinedBy(Dictionary`2<string, ArrayBuilder`1<Symbol>> membersInProgress);
    public virtual int get_Arity();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual Accessibility get_DeclaredAccessibility();
    internal virtual string get_DefaultPropertyName();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public virtual bool get_IsMustInherit();
    public virtual bool get_IsNotInheritable();
    internal virtual bool get_ShadowsExplicitly();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual NamedTypeSymbol MakeAcyclicBaseType(DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<NamedTypeSymbol> MakeAcyclicInterfaces(DiagnosticBag diagnostics);
    internal virtual NamedTypeSymbol MakeDeclaredBase(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<NamedTypeSymbol> MakeDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    internal virtual bool get_MangleName();
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual bool get_MightContainExtensionMethods();
    internal virtual bool get_HasEmbeddedAttribute();
    internal virtual bool get_IsExtensibleInterfaceNoUseSiteDiagnostics();
    internal virtual bool get_IsWindowsRuntimeImport();
    internal virtual bool get_ShouldAddWinRTMembers();
    internal virtual bool get_IsComImport();
    internal virtual TypeSymbol get_CoClassType();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual AttributeUsageInfo GetAttributeUsageInfo();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_IsSerializable();
    internal virtual TypeLayout get_Layout();
    internal virtual CharSet get_MarshallingCharSet();
    public virtual TypeKind get_TypeKind();
    internal virtual bool get_IsInterface();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    internal virtual void GenerateDeclarationErrors(CancellationToken cancellationToken);
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual EmbeddedSymbolKind get_EmbeddedSymbolKind();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedFieldSymbol : FieldSymbol {
    protected NamedTypeSymbol _containingType;
    protected Symbol _implicitlyDefinedBy;
    protected TypeSymbol _type;
    protected string _name;
    protected SourceMemberFlags _flags;
    protected bool _isSpecialNameAndRuntimeSpecial;
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public Symbol AssociatedSymbol { get; }
    public bool IsReadOnly { get; }
    public bool IsConst { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsShared { get; }
    public bool IsImplicitlyDeclared { get; }
    internal Symbol ImplicitlyDefinedBy { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    internal bool HasRuntimeSpecialName { get; }
    internal bool IsNotSerialized { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal Nullable`1<int> TypeLayoutOffset { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public SynthesizedFieldSymbol(NamedTypeSymbol containingType, Symbol implicitlyDefinedBy, TypeSymbol type, string name, Accessibility accessibility, bool isReadOnly, bool isShared, bool isSpecialNameAndRuntimeSpecial);
    public virtual TypeSymbol get_Type();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public virtual Symbol get_AssociatedSymbol();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsConst();
    internal virtual ConstantValue GetConstantValue(SymbolsInProgress`1<FieldSymbol> inProgress);
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsShared();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual Symbol get_ImplicitlyDefinedBy(Dictionary`2<string, ArrayBuilder`1<Symbol>> membersInProgress);
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    internal virtual bool get_HasRuntimeSpecialName();
    internal virtual bool get_IsNotSerialized();
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual Nullable`1<int> get_TypeLayoutOffset();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedGlobalMethodBase : MethodSymbol {
    protected PrivateImplementationDetails m_privateImplType;
    protected SourceModuleSymbol m_containingModule;
    protected string m_name;
    public bool IsImplicitlyDeclared { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverloads { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public MethodKind MethodKind { get; }
    internal bool IsMethodKindBasedOnSyntax { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public Accessibility DeclaredAccessibility { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    public int Arity { get; }
    public Symbol AssociatedSymbol { get; }
    internal CallingConvention CallingConvention { get; }
    public PrivateImplementationDetails ContainingPrivateImplementationDetailsType { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public ModuleSymbol ContainingModule { get; }
    public AssemblySymbol ContainingAssembly { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public MethodSymbol OverriddenMethod { get; }
    public bool IsExtensionMethod { get; }
    public bool IsExternalMethod { get; }
    internal MarshalPseudoCustomAttributeData ReturnTypeMarshallingInformation { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public bool IsVararg { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public bool IsAsync { get; }
    public bool IsIterator { get; }
    internal bool GenerateDebugInfoImpl { get; }
    protected SynthesizedGlobalMethodBase(SourceModuleSymbol containingModule, string name, PrivateImplementationDetails privateImplType);
    public sealed virtual bool get_IsImplicitlyDeclared();
    public sealed virtual string get_Name();
    internal sealed virtual bool get_HasSpecialName();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public sealed virtual bool get_IsShared();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public sealed virtual MethodKind get_MethodKind();
    internal sealed virtual bool get_IsMethodKindBasedOnSyntax();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual Accessibility get_DeclaredAccessibility();
    internal sealed virtual VisualBasicSyntaxNode get_Syntax();
    public sealed virtual int get_Arity();
    public virtual Symbol get_AssociatedSymbol();
    internal sealed virtual CallingConvention get_CallingConvention();
    public PrivateImplementationDetails get_ContainingPrivateImplementationDetailsType();
    public sealed virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual ModuleSymbol get_ContainingModule();
    public virtual AssemblySymbol get_ContainingAssembly();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual MethodSymbol get_OverriddenMethod();
    public sealed virtual bool get_IsExtensionMethod();
    public sealed virtual bool get_IsExternalMethod();
    public sealed virtual DllImportData GetDllImportData();
    internal sealed virtual MarshalPseudoCustomAttributeData get_ReturnTypeMarshallingInformation();
    internal sealed virtual MethodImplAttributes get_ImplementationAttributes();
    internal sealed virtual bool get_HasDeclarativeSecurity();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal sealed virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    public sealed virtual bool get_IsVararg();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetReturnTypeAttributes();
    public virtual bool get_IsAsync();
    public virtual bool get_IsIterator();
    internal virtual bool get_GenerateDebugInfoImpl();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedInteractiveInitializerMethod : SynthesizedMethodBase {
    internal static string InitializerName;
    internal TypeSymbol ResultType;
    internal LocalSymbol FunctionLocal;
    internal LabelSymbol ExitLabel;
    private SyntaxReference _syntaxReference;
    private TypeSymbol _returnType;
    public string Name { get; }
    internal bool IsScriptInitializer { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsAsync { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverloads { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public bool IsSub { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public MethodKind MethodKind { get; }
    public TypeSymbol ReturnType { get; }
    internal bool GenerateDebugInfoImpl { get; }
    internal bool HasSpecialName { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    internal SynthesizedInteractiveInitializerMethod(SyntaxReference syntaxReference, SourceMemberContainerTypeSymbol containingType, DiagnosticBag diagnostics);
    public virtual string get_Name();
    internal virtual bool get_IsScriptInitializer();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsAsync();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsShared();
    public virtual bool get_IsSub();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual MethodKind get_MethodKind();
    public virtual TypeSymbol get_ReturnType();
    internal virtual bool get_GenerateDebugInfoImpl();
    internal virtual bool get_HasSpecialName();
    internal virtual VisualBasicSyntaxNode get_Syntax();
    internal virtual BoundBlock GetBoundMethodBody(DiagnosticBag diagnostics, Binder& methodBodyBinder);
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    private static void CalculateReturnType(VisualBasicCompilation compilation, DiagnosticBag diagnostics, TypeSymbol& resultType, TypeSymbol& returnType);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedInterfaceImplementationStubSymbol : SynthesizedMethodBase {
    private string _name;
    private ImmutableArray`1<TypeParameterSymbol> _typeParameters;
    private TypeSubstitution _typeParametersSubstitution;
    private ImmutableArray`1<ParameterSymbol> _parameters;
    private TypeSymbol _returnType;
    private ImmutableArray`1<CustomModifier> _customModifiers;
    private ArrayBuilder`1<MethodSymbol> _explicitInterfaceImplementationsBuilder;
    private ImmutableArray`1<MethodSymbol> _explicitInterfaceImplementations;
    private static Func`2<Symbol, TypeSubstitution> s_typeParametersSubstitutionFactory;
    private static Func`3<TypeParameterSymbol, Symbol, TypeParameterSymbol> s_createTypeParameter;
    public string Name { get; }
    public int Arity { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public Accessibility DeclaredAccessibility { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverloads { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public bool IsSub { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public MethodKind MethodKind { get; }
    internal bool HasSpecialName { get; }
    internal bool GenerateDebugInfoImpl { get; }
    private static SynthesizedInterfaceImplementationStubSymbol();
    internal SynthesizedInterfaceImplementationStubSymbol(MethodSymbol implementingMethod, MethodSymbol implementedMethod);
    public virtual string get_Name();
    public virtual int get_Arity();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public void AddImplementedMethod(MethodSymbol implemented);
    public void Seal();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsShared();
    public virtual bool get_IsSub();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual MethodKind get_MethodKind();
    internal virtual bool get_HasSpecialName();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal virtual bool get_GenerateDebugInfoImpl();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedIntrinsicOperatorSymbol : SynthesizedMethodBase {
    private string _name;
    private ImmutableArray`1<ParameterSymbol> _parameters;
    private TypeSymbol _returnType;
    private bool _isCheckedBuiltin;
    public string Name { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public TypeSymbol ReturnType { get; }
    public Accessibility DeclaredAccessibility { get; }
    internal bool HasSpecialName { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverloads { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public bool IsSub { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public MethodKind MethodKind { get; }
    public bool IsCheckedBuiltin { get; }
    internal VisualBasicCompilation DeclaringCompilation { get; }
    internal bool GenerateDebugInfoImpl { get; }
    public SynthesizedIntrinsicOperatorSymbol(NamedTypeSymbol container, string name, TypeSymbol rightType, TypeSymbol returnType, bool isCheckedBuiltin);
    public SynthesizedIntrinsicOperatorSymbol(NamedTypeSymbol container, string name, TypeSymbol returnType, bool isCheckedBuiltin);
    public virtual string get_Name();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual TypeSymbol get_ReturnType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Accessibility get_DeclaredAccessibility();
    internal virtual bool get_HasSpecialName();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsShared();
    public virtual bool get_IsSub();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual MethodKind get_MethodKind();
    public virtual bool get_IsCheckedBuiltin();
    public virtual string GetDocumentationCommentId();
    internal virtual VisualBasicCompilation get_DeclaringCompilation();
    internal virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_GenerateDebugInfoImpl();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal enum Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaKind : Enum {
    public int value__;
    public static SynthesizedLambdaKind UserDefined;
    public static SynthesizedLambdaKind DelegateRelaxationStub;
    public static SynthesizedLambdaKind LateBoundAddressOfLambda;
    public static SynthesizedLambdaKind FilterConditionQueryLambda;
    public static SynthesizedLambdaKind OrderingQueryLambda;
    public static SynthesizedLambdaKind AggregationQueryLambda;
    public static SynthesizedLambdaKind AggregateQueryLambda;
    public static SynthesizedLambdaKind FromOrAggregateVariableQueryLambda;
    public static SynthesizedLambdaKind LetVariableQueryLambda;
    public static SynthesizedLambdaKind SelectQueryLambda;
    public static SynthesizedLambdaKind GroupByItemsQueryLambda;
    public static SynthesizedLambdaKind GroupByKeysQueryLambda;
    public static SynthesizedLambdaKind JoinLeftQueryLambda;
    public static SynthesizedLambdaKind JoinRightQueryLambda;
    public static SynthesizedLambdaKind JoinNonUserCodeQueryLambda;
    public static SynthesizedLambdaKind AggregateNonUserCodeQueryLambda;
    public static SynthesizedLambdaKind FromNonUserCodeQueryLambda;
    public static SynthesizedLambdaKind GroupNonUserCodeQueryLambda;
    public static SynthesizedLambdaKind ConversionNonUserCodeQueryLambda;
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaKindExtensions : object {
    [ExtensionAttribute]
internal static bool IsQueryLambda(SynthesizedLambdaKind kind);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLambdaSymbol : LambdaSymbol {
    private SynthesizedLambdaKind _kind;
    public SynthesizedLambdaKind SynthesizedKind { get; }
    public bool IsAsync { get; }
    public bool IsIterator { get; }
    public bool IsImplicitlyDeclared { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal bool GenerateDebugInfoImpl { get; }
    public SynthesizedLambdaSymbol(SynthesizedLambdaKind kind, VisualBasicSyntaxNode syntaxNode, ImmutableArray`1<BoundLambdaParameterSymbol> parameters, TypeSymbol returnType, Binder binder);
    public virtual SynthesizedLambdaKind get_SynthesizedKind();
    public virtual bool get_IsAsync();
    public virtual bool get_IsIterator();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual bool get_GenerateDebugInfoImpl();
    public void SetQueryLambdaReturnType(TypeSymbol returnType);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedLocal : LocalSymbol {
    private SynthesizedLocalKind _kind;
    private bool _isByRef;
    private SyntaxNode _syntaxOpt;
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal SyntaxToken IdentifierToken { get; }
    internal Location IdentifierLocation { get; }
    public string Name { get; }
    internal bool IsByRef { get; }
    internal SynthesizedLocalKind SynthesizedKind { get; }
    internal LocalDeclarationKind DeclarationKind { get; }
    public bool IsFunctionValue { get; }
    internal SynthesizedLocal(Symbol container, TypeSymbol type, SynthesizedLocalKind kind, SyntaxNode syntaxOpt, bool isByRef);
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual SyntaxNode GetDeclaratorSyntax();
    internal sealed virtual SyntaxToken get_IdentifierToken();
    internal sealed virtual Location get_IdentifierLocation();
    public virtual string get_Name();
    internal virtual bool get_IsByRef();
    internal virtual SynthesizedLocalKind get_SynthesizedKind();
    internal virtual LocalDeclarationKind get_DeclarationKind();
    public virtual bool get_IsFunctionValue();
    private string GetDebuggerDisplay();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedMainTypeEntryPoint : SynthesizedRegularMethodBase {
    public Accessibility DeclaredAccessibility { get; }
    public bool IsSub { get; }
    public TypeSymbol ReturnType { get; }
    internal bool GenerateDebugInfoImpl { get; }
    public SynthesizedMainTypeEntryPoint(VisualBasicSyntaxNode syntaxNode, SourceNamedTypeSymbol container);
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual bool get_IsSub();
    public virtual TypeSymbol get_ReturnType();
    internal virtual BoundBlock GetBoundMethodBody(DiagnosticBag diagnostics, Binder& methodBodyBinder);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal virtual bool get_GenerateDebugInfoImpl();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedMethod : SynthesizedMethodBase {
    private bool _isShared;
    private string _name;
    private VisualBasicSyntaxNode _syntaxNodeOpt;
    private static Func`2<Symbol, TypeSubstitution> s_typeSubstitutionFactory;
    internal static Func`3<TypeParameterSymbol, Symbol, TypeParameterSymbol> CreateTypeParameter;
    public string Name { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public TypeSymbol ReturnType { get; }
    public Accessibility DeclaredAccessibility { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverloads { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public bool IsSub { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public MethodKind MethodKind { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    internal TypeSubstitution TypeMap { get; }
    private static SynthesizedMethod();
    internal SynthesizedMethod(VisualBasicSyntaxNode syntaxNode, NamedTypeSymbol containingSymbol, string name, bool isShared);
    internal static ParameterSymbol WithNewContainerAndType(Symbol newContainer, TypeSymbol newType, ParameterSymbol origParameter);
    public virtual string get_Name();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual TypeSymbol get_ReturnType();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    public virtual Accessibility get_DeclaredAccessibility();
    internal sealed virtual MethodImplAttributes get_ImplementationAttributes();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsShared();
    public virtual bool get_IsSub();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual MethodKind get_MethodKind();
    internal virtual VisualBasicSyntaxNode get_Syntax();
    internal virtual TypeSubstitution get_TypeMap();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedMethodBase : MethodSymbol {
    protected NamedTypeSymbol m_containingType;
    private ParameterSymbol _lazyMeParameter;
    public int Arity { get; }
    public Symbol AssociatedSymbol { get; }
    internal CallingConvention CallingConvention { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public MethodSymbol OverriddenMethod { get; }
    public bool IsExtensionMethod { get; }
    public bool IsExternalMethod { get; }
    internal MarshalPseudoCustomAttributeData ReturnTypeMarshallingInformation { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    internal bool HasDeclarativeSecurity { get; }
    public bool IsVararg { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public bool IsImplicitlyDeclared { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public bool IsAsync { get; }
    public bool IsIterator { get; }
    internal bool IsMethodKindBasedOnSyntax { get; }
    protected SynthesizedMethodBase(NamedTypeSymbol container);
    public virtual int get_Arity();
    public virtual Symbol get_AssociatedSymbol();
    internal sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual Symbol get_ContainingSymbol();
    public sealed virtual NamedTypeSymbol get_ContainingType();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual MethodSymbol get_OverriddenMethod();
    public sealed virtual bool get_IsExtensionMethod();
    public virtual bool get_IsExternalMethod();
    public sealed virtual DllImportData GetDllImportData();
    internal sealed virtual MarshalPseudoCustomAttributeData get_ReturnTypeMarshallingInformation();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    public virtual bool get_IsVararg();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetReturnTypeAttributes();
    public sealed virtual bool get_IsImplicitlyDeclared();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    internal virtual VisualBasicSyntaxNode get_Syntax();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal sealed virtual bool TryGetMeParameter(ParameterSymbol& meParameter);
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    public virtual bool get_IsAsync();
    public virtual bool get_IsIterator();
    internal sealed virtual bool get_IsMethodKindBasedOnSyntax();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedMyGroupCollectionPropertyAccessorSymbol : SynthesizedPropertyAccessorBase`1<SynthesizedMyGroupCollectionPropertySymbol> {
    private string _createOrDisposeMethod;
    internal FieldSymbol BackingFieldSymbol { get; }
    internal bool GenerateDebugInfoImpl { get; }
    public SynthesizedMyGroupCollectionPropertyAccessorSymbol(SourceNamedTypeSymbol container, SynthesizedMyGroupCollectionPropertySymbol property, string createOrDisposeMethod);
    internal virtual FieldSymbol get_BackingFieldSymbol();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    private static string MakeSafeName(string name);
    internal virtual BoundBlock GetBoundMethodBody(DiagnosticBag diagnostics, Binder& methodBodyBinder);
    internal sealed virtual bool get_GenerateDebugInfoImpl();
    internal sealed virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    protected abstract virtual string GetMethodBlock(string fieldName, string createOrDisposeMethodName, string targetTypeName);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedMyGroupCollectionPropertyBackingFieldSymbol : SynthesizedFieldSymbol {
    public SynthesizedMyGroupCollectionPropertyBackingFieldSymbol(NamedTypeSymbol containingType, Symbol implicitlyDefinedBy, TypeSymbol type, string name);
    internal virtual LexicalSortKey GetLexicalSortKey();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedMyGroupCollectionPropertyGetAccessorSymbol : SynthesizedMyGroupCollectionPropertyAccessorSymbol {
    public bool IsSub { get; }
    public MethodKind MethodKind { get; }
    public TypeSymbol ReturnType { get; }
    public SynthesizedMyGroupCollectionPropertyGetAccessorSymbol(SourceNamedTypeSymbol container, SynthesizedMyGroupCollectionPropertySymbol property, string createMethod);
    public virtual bool get_IsSub();
    public virtual MethodKind get_MethodKind();
    public virtual TypeSymbol get_ReturnType();
    protected virtual string GetMethodBlock(string fieldName, string createMethodName, string targetTypeName);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedMyGroupCollectionPropertySetAccessorSymbol : SynthesizedMyGroupCollectionPropertyAccessorSymbol {
    private ImmutableArray`1<ParameterSymbol> _parameters;
    public bool IsSub { get; }
    public MethodKind MethodKind { get; }
    public TypeSymbol ReturnType { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public SynthesizedMyGroupCollectionPropertySetAccessorSymbol(SourceNamedTypeSymbol container, SynthesizedMyGroupCollectionPropertySymbol property, string disposeMethod);
    public virtual bool get_IsSub();
    public virtual MethodKind get_MethodKind();
    public virtual TypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    protected virtual string GetMethodBlock(string fieldName, string disposeMethodName, string targetTypeName);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedMyGroupCollectionPropertySymbol : SynthesizedPropertyBase {
    private string _name;
    private SynthesizedMyGroupCollectionPropertyBackingFieldSymbol _field;
    private SynthesizedMyGroupCollectionPropertyGetAccessorSymbol _getMethod;
    private SynthesizedMyGroupCollectionPropertySetAccessorSymbol _setMethodOpt;
    public SyntaxReference AttributeSyntax;
    public string DefaultInstanceAlias;
    public string Name { get; }
    public TypeSymbol Type { get; }
    public MethodSymbol GetMethod { get; }
    public MethodSymbol SetMethod { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    internal FieldSymbol AssociatedField { get; }
    public bool IsImplicitlyDeclared { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public ImmutableArray`1<Location> Locations { get; }
    internal bool IsMyGroupCollectionProperty { get; }
    public SynthesizedMyGroupCollectionPropertySymbol(SourceNamedTypeSymbol container, AttributeSyntax attributeSyntax, string propertyName, string fieldName, NamedTypeSymbol type, string createMethod, string disposeMethod, string defaultInstanceAlias);
    public virtual string get_Name();
    public virtual TypeSymbol get_Type();
    public virtual MethodSymbol get_GetMethod();
    public virtual MethodSymbol get_SetMethod();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    internal virtual FieldSymbol get_AssociatedField();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual ImmutableArray`1<Location> get_Locations();
    internal virtual bool get_IsMyGroupCollectionProperty();
    public void RelocateDiagnostics(DiagnosticBag source, DiagnosticBag destination);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedOverridingWithEventsProperty : PropertySymbol {
    private PropertySymbol _baseProperty;
    private SourceNamedTypeSymbol _containingType;
    private SynthesizedWithEventsAccessorSymbol _getter;
    private SynthesizedWithEventsAccessorSymbol _setter;
    public bool IsWithEvents { get; }
    internal bool ShadowsExplicitly { get; }
    internal CallingConvention CallingConvention { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<PropertySymbol> ExplicitInterfaceImplementations { get; }
    public MethodSymbol GetMethod { get; }
    public MethodSymbol SetMethod { get; }
    internal FieldSymbol AssociatedField { get; }
    public bool IsDefault { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverloads { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public int ParameterCount { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public string Name { get; }
    internal bool HasSpecialName { get; }
    public bool IsImplicitlyDeclared { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool IsMyGroupCollectionProperty { get; }
    internal SynthesizedOverridingWithEventsProperty(PropertySymbol baseProperty, SourceNamedTypeSymbol container);
    public virtual bool get_IsWithEvents();
    internal virtual bool get_ShadowsExplicitly();
    internal virtual CallingConvention get_CallingConvention();
    public virtual Symbol get_ContainingSymbol();
    public virtual NamedTypeSymbol get_ContainingType();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<PropertySymbol> get_ExplicitInterfaceImplementations();
    public virtual MethodSymbol get_GetMethod();
    public virtual MethodSymbol get_SetMethod();
    internal virtual FieldSymbol get_AssociatedField();
    public virtual bool get_IsDefault();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsShared();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual int get_ParameterCount();
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual string get_Name();
    internal virtual bool get_HasSpecialName();
    public virtual bool get_IsImplicitlyDeclared();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual bool get_IsMyGroupCollectionProperty();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSimpleSymbol : ParameterSymbol {
    protected MethodSymbol _container;
    protected TypeSymbol _type;
    protected int _ordinal;
    protected string _name;
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    public bool HasExplicitDefaultValue { get; }
    public bool IsByRef { get; }
    internal bool IsMetadataIn { get; }
    internal bool IsMetadataOut { get; }
    internal MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    internal bool IsExplicitByRef { get; }
    internal bool HasOptionCompare { get; }
    internal bool IsIDispatchConstant { get; }
    internal bool IsIUnknownConstant { get; }
    internal bool IsCallerLineNumber { get; }
    internal bool IsCallerMemberName { get; }
    internal bool IsCallerFilePath { get; }
    public bool IsOptional { get; }
    public bool IsParamArray { get; }
    public bool IsImplicitlyDeclared { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public int Ordinal { get; }
    public TypeSymbol Type { get; }
    public string Name { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    public SynthesizedParameterSimpleSymbol(MethodSymbol container, TypeSymbol type, int ordinal, string name);
    public sealed virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    internal virtual ConstantValue get_ExplicitDefaultConstantValue(SymbolsInProgress`1<ParameterSymbol> inProgress);
    public virtual bool get_HasExplicitDefaultValue();
    public virtual bool get_IsByRef();
    internal virtual bool get_IsMetadataIn();
    internal virtual bool get_IsMetadataOut();
    internal static bool IsMarshalAsAttributeApplicable(MethodSymbol propertySetter);
    internal virtual MarshalPseudoCustomAttributeData get_MarshallingInformation();
    internal virtual bool get_IsExplicitByRef();
    internal virtual bool get_HasOptionCompare();
    internal virtual bool get_IsIDispatchConstant();
    internal virtual bool get_IsIUnknownConstant();
    internal virtual bool get_IsCallerLineNumber();
    internal virtual bool get_IsCallerMemberName();
    internal virtual bool get_IsCallerFilePath();
    public virtual bool get_IsOptional();
    public virtual bool get_IsParamArray();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public sealed virtual int get_Ordinal();
    public sealed virtual TypeSymbol get_Type();
    public sealed virtual string get_Name();
    internal virtual ushort get_CountOfCustomModifiersPrecedingByRef();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSymbol : SynthesizedParameterSimpleSymbol {
    private bool _isByRef;
    private bool _isOptional;
    private ConstantValue _defaultValue;
    public bool IsByRef { get; }
    public bool IsOptional { get; }
    internal ConstantValue ExplicitDefaultConstantValue { get; }
    public bool HasExplicitDefaultValue { get; }
    public SynthesizedParameterSymbol(MethodSymbol container, TypeSymbol type, int ordinal, bool isByRef, string name);
    public SynthesizedParameterSymbol(MethodSymbol container, TypeSymbol type, int ordinal, bool isByRef, string name, bool isOptional, ConstantValue defaultValue);
    internal static ParameterSymbol CreateSetAccessorValueParameter(MethodSymbol setter, PropertySymbol propertySymbol, string parameterName);
    public sealed virtual bool get_IsByRef();
    public sealed virtual bool get_IsOptional();
    internal sealed virtual ConstantValue get_ExplicitDefaultConstantValue(SymbolsInProgress`1<ParameterSymbol> inProgress);
    public sealed virtual bool get_HasExplicitDefaultValue();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterSymbolWithCustomModifiers : SynthesizedParameterSymbol {
    private ImmutableArray`1<CustomModifier> _customModifiers;
    private ushort _countOfCustomModifiersPrecedingByRef;
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    internal ushort CountOfCustomModifiersPrecedingByRef { get; }
    public SynthesizedParameterSymbolWithCustomModifiers(MethodSymbol container, TypeSymbol type, int ordinal, bool isByRef, string name, ImmutableArray`1<CustomModifier> customModifiers, ushort countOfCustomModifiersPrecedingByRef);
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    internal virtual ushort get_CountOfCustomModifiersPrecedingByRef();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedParameterWithLocationSymbol : SynthesizedParameterSymbol {
    private ImmutableArray`1<Location> _locations;
    public ImmutableArray`1<Location> Locations { get; }
    public SynthesizedParameterWithLocationSymbol(MethodSymbol container, TypeSymbol type, int ordinal, bool isByRef, string name, Location location);
    public virtual ImmutableArray`1<Location> get_Locations();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedPropertyAccessorBase`1 : SynthesizedAccessor`1<T> {
    internal FieldSymbol BackingFieldSymbol { get; }
    protected SynthesizedPropertyAccessorBase`1(NamedTypeSymbol container, T property);
    internal virtual BoundBlock GetBoundMethodBody(DiagnosticBag diagnostics, Binder& methodBodyBinder);
    internal static BoundBlock GetBoundMethodBody(MethodSymbol accessor, FieldSymbol backingField, Binder& methodBodyBinder);
    internal abstract virtual FieldSymbol get_BackingFieldSymbol();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedPropertyBackingFieldSymbol : SynthesizedBackingFieldBase`1<SourcePropertySymbol> {
    public TypeSymbol Type { get; }
    public SynthesizedPropertyBackingFieldSymbol(SourcePropertySymbol property, string name, bool isShared);
    public virtual TypeSymbol get_Type();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedPropertyBase : PropertySymbol {
    internal FieldSymbol AssociatedField { get; }
    public bool IsDefault { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    internal bool HasSpecialName { get; }
    public Accessibility DeclaredAccessibility { get; }
    internal CallingConvention CallingConvention { get; }
    public ImmutableArray`1<PropertySymbol> ExplicitInterfaceImplementations { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverloads { get; }
    internal bool ShadowsExplicitly { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    public bool IsImplicitlyDeclared { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool IsMyGroupCollectionProperty { get; }
    internal virtual FieldSymbol get_AssociatedField();
    public virtual bool get_IsDefault();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
    internal virtual bool get_HasSpecialName();
    public virtual Accessibility get_DeclaredAccessibility();
    internal virtual CallingConvention get_CallingConvention();
    public virtual ImmutableArray`1<PropertySymbol> get_ExplicitInterfaceImplementations();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverloads();
    internal virtual bool get_ShadowsExplicitly();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public virtual bool get_IsShared();
    public abstract virtual bool get_IsImplicitlyDeclared();
    internal virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal virtual bool get_IsMyGroupCollectionProperty();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedRegularMethodBase : SynthesizedMethodBase {
    protected string m_name;
    protected bool m_isShared;
    protected VisualBasicSyntaxNode m_SyntaxNode;
    public string Name { get; }
    public bool IsMustOverride { get; }
    public bool IsNotOverridable { get; }
    public bool IsOverloads { get; }
    public bool IsOverridable { get; }
    public bool IsOverrides { get; }
    public bool IsShared { get; }
    internal bool HasSpecialName { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public MethodKind MethodKind { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    protected SynthesizedRegularMethodBase(VisualBasicSyntaxNode syntaxNode, NamedTypeSymbol container, string name, bool isShared);
    public sealed virtual string get_Name();
    public virtual bool get_IsMustOverride();
    public virtual bool get_IsNotOverridable();
    public virtual bool get_IsOverloads();
    public virtual bool get_IsOverridable();
    public virtual bool get_IsOverrides();
    public sealed virtual bool get_IsShared();
    internal sealed virtual bool get_HasSpecialName();
    internal virtual LexicalSortKey GetLexicalSortKey();
    public virtual ImmutableArray`1<Location> get_Locations();
    public sealed virtual MethodKind get_MethodKind();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal sealed virtual VisualBasicSyntaxNode get_Syntax();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedRemoveAccessorSymbol : SynthesizedEventAccessorSymbol {
    public MethodKind MethodKind { get; }
    public SynthesizedRemoveAccessorSymbol(SourceMemberContainerTypeSymbol container, SourceEventSymbol event);
    public virtual MethodKind get_MethodKind();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedSimpleConstructorSymbol : SynthesizedConstructorBase {
    private ImmutableArray`1<ParameterSymbol> _parameters;
    internal int ParameterCount { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public bool HasMethodBodyDependency { get; }
    public IMethodSymbol Method { get; }
    internal bool GenerateDebugInfoImpl { get; }
    public SynthesizedSimpleConstructorSymbol(NamedTypeSymbol container);
    internal void SetParameters(ImmutableArray`1<ParameterSymbol> parameters);
    internal sealed virtual int get_ParameterCount();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public sealed virtual override bool get_HasMethodBodyDependency();
    public sealed virtual override IMethodSymbol get_Method();
    internal sealed virtual bool get_GenerateDebugInfoImpl();
    internal sealed virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedSimpleMethodSymbol : SynthesizedRegularMethodBase {
    private ImmutableArray`1<ParameterSymbol> _parameters;
    private MethodSymbol _overriddenMethod;
    private ImmutableArray`1<MethodSymbol> _interfaceMethods;
    private bool _isOverloads;
    private TypeSymbol _returnType;
    public bool IsOverloads { get; }
    public bool IsOverrides { get; }
    public MethodSymbol OverriddenMethod { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public bool IsSub { get; }
    public TypeSymbol ReturnType { get; }
    internal int ParameterCount { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    internal bool GenerateDebugInfoImpl { get; }
    public SynthesizedSimpleMethodSymbol(NamedTypeSymbol container, string name, TypeSymbol returnType, MethodSymbol overriddenMethod, MethodSymbol interfaceMethod, bool isOverloads);
    public virtual bool get_IsOverloads();
    public virtual bool get_IsOverrides();
    public virtual MethodSymbol get_OverriddenMethod();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual bool get_IsSub();
    public virtual TypeSymbol get_ReturnType();
    internal void SetParameters(ImmutableArray`1<ParameterSymbol> parameters);
    internal virtual int get_ParameterCount();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal virtual bool get_GenerateDebugInfoImpl();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedStaticLocalBackingField : SynthesizedFieldSymbol {
    private MetadataWriter _metadataWriter;
    private string _nameToEmit;
    public bool IsValueField;
    private bool _reportErrorForLongNames;
    public string MetadataName { get; }
    internal bool IFieldReferenceIsContextualNamedEntity { get; }
    internal LocalSymbol ImplicitlyDefinedBy { get; }
    internal bool HasRuntimeSpecialName { get; }
    public SynthesizedStaticLocalBackingField(LocalSymbol implicitlyDefinedBy, bool isValueField, bool reportErrorForLongNames);
    public virtual string get_MetadataName();
    internal virtual bool get_IFieldReferenceIsContextualNamedEntity();
    private sealed virtual override void AssociateWithMetadataWriter(MetadataWriter metadataWriter);
    internal LocalSymbol get_ImplicitlyDefinedBy();
    internal virtual bool get_HasRuntimeSpecialName();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedStringSwitchHashMethod : SynthesizedGlobalMethodBase {
    private ImmutableArray`1<ParameterSymbol> _parameters;
    private TypeSymbol _returnType;
    internal int ParameterCount { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public bool IsSub { get; }
    public TypeSymbol ReturnType { get; }
    public SynthesizedStringSwitchHashMethod(SourceModuleSymbol container, PrivateImplementationDetails privateImplType);
    internal static UInt32 ComputeStringHash(string text);
    internal virtual BoundBlock GetBoundMethodBody(DiagnosticBag diagnostics, Binder& methodBodyBinder);
    internal virtual int get_ParameterCount();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual bool get_IsSub();
    public virtual TypeSymbol get_ReturnType();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedSubmissionConstructorSymbol : SynthesizedConstructorBase {
    private ImmutableArray`1<ParameterSymbol> _parameters;
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    internal bool GenerateDebugInfoImpl { get; }
    internal SynthesizedSubmissionConstructorSymbol(SyntaxReference syntaxReference, NamedTypeSymbol container, bool isShared, Binder binder, DiagnosticBag diagnostics);
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal virtual BoundBlock GetBoundMethodBody(DiagnosticBag diagnostics, Binder& methodBodyBinder);
    internal static ImmutableArray`1<BoundStatement> MakeSubmissionInitialization(VisualBasicSyntaxNode syntax, MethodSymbol constructor, SynthesizedSubmissionFields synthesizedFields, VisualBasicCompilation compilation, DiagnosticBag diagnostics);
    internal virtual bool get_GenerateDebugInfoImpl();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedWithEventsAccessorSymbol : SynthesizedPropertyAccessorBase`1<PropertySymbol> {
    private ImmutableArray`1<ParameterSymbol> _lazyParameters;
    private ImmutableArray`1<MethodSymbol> _lazyExplicitImplementations;
    protected PropertySymbol ContainingProperty { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public MethodSymbol OverriddenMethod { get; }
    internal VisualBasicSyntaxNode Syntax { get; }
    internal FieldSymbol BackingFieldSymbol { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    internal bool GenerateDebugInfoImpl { get; }
    protected SynthesizedWithEventsAccessorSymbol(SourceMemberContainerTypeSymbol container, PropertySymbol property);
    protected PropertySymbol get_ContainingProperty();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    private ImmutableArray`1<MethodSymbol> GetExplicitInterfaceImplementations();
    public virtual MethodSymbol get_OverriddenMethod();
    internal virtual VisualBasicSyntaxNode get_Syntax();
    internal virtual FieldSymbol get_BackingFieldSymbol();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    protected abstract virtual ImmutableArray`1<ParameterSymbol> GetParameters();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal sealed virtual bool get_GenerateDebugInfoImpl();
    internal sealed virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedWithEventsGetAccessorSymbol : SynthesizedWithEventsAccessorSymbol {
    public bool IsSub { get; }
    public MethodKind MethodKind { get; }
    public TypeSymbol ReturnType { get; }
    public SynthesizedWithEventsGetAccessorSymbol(SourceMemberContainerTypeSymbol container, PropertySymbol propertySymbol);
    public virtual bool get_IsSub();
    public virtual MethodKind get_MethodKind();
    protected virtual ImmutableArray`1<ParameterSymbol> GetParameters();
    public virtual TypeSymbol get_ReturnType();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.SynthesizedWithEventsSetAccessorSymbol : SynthesizedWithEventsAccessorSymbol {
    private TypeSymbol _returnType;
    private string _valueParameterName;
    public bool IsSub { get; }
    public MethodKind MethodKind { get; }
    public TypeSymbol ReturnType { get; }
    internal MethodImplAttributes ImplementationAttributes { get; }
    public SynthesizedWithEventsSetAccessorSymbol(SourceMemberContainerTypeSymbol container, PropertySymbol propertySymbol, TypeSymbol returnType, string valueParameterName);
    public virtual bool get_IsSub();
    public virtual MethodKind get_MethodKind();
    protected virtual ImmutableArray`1<ParameterSymbol> GetParameters();
    public virtual TypeSymbol get_ReturnType();
    internal virtual MethodImplAttributes get_ImplementationAttributes();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeEarlyWellKnownAttributeData : CommonTypeEarlyWellKnownAttributeData {
    private bool _hasEmbeddedAttribute;
    private bool _hasAttributeForExtensibleInterface;
    internal bool HasEmbeddedAttribute { get; internal set; }
    internal bool HasAttributeForExtensibleInterface { get; internal set; }
    internal bool get_HasEmbeddedAttribute();
    internal void set_HasEmbeddedAttribute(bool value);
    internal bool get_HasAttributeForExtensibleInterface();
    internal void set_HasAttributeForExtensibleInterface(bool value);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterConstraint : ValueType {
    public TypeParameterConstraintKind Kind;
    public TypeSymbol TypeConstraint;
    public Location LocationOpt;
    public bool IsConstructorConstraint { get; }
    public bool IsReferenceTypeConstraint { get; }
    public bool IsValueTypeConstraint { get; }
    public TypeParameterConstraint(TypeParameterConstraintKind kind, Location loc);
    public TypeParameterConstraint(TypeSymbol type, Location loc);
    private TypeParameterConstraint(TypeParameterConstraintKind kind, TypeSymbol type, Location loc);
    public TypeParameterConstraint AtLocation(Location loc);
    public bool get_IsConstructorConstraint();
    public bool get_IsReferenceTypeConstraint();
    public bool get_IsValueTypeConstraint();
    public object ToDisplayFormat();
    public virtual string ToString();
    private static SyntaxKind ToSyntaxKind(TypeParameterConstraintKind kind);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterConstraintKind : Enum {
    public int value__;
    public static TypeParameterConstraintKind None;
    public static TypeParameterConstraintKind ReferenceType;
    public static TypeParameterConstraintKind ValueType;
    public static TypeParameterConstraintKind Constructor;
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterDiagnosticInfo : ValueType {
    public TypeParameterSymbol TypeParameter;
    public TypeParameterConstraint Constraint;
    public DiagnosticInfo DiagnosticInfo;
    public TypeParameterDiagnosticInfo(TypeParameterSymbol typeParameter, DiagnosticInfo diagnostic);
    public TypeParameterDiagnosticInfo(TypeParameterSymbol typeParameter, TypeParameterConstraint constraint, DiagnosticInfo diagnostic);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol : TypeSymbol {
    private static Func`3<TypeSymbol, TypeSubstitution, TypeSymbol> s_substituteFunc;
    private bool ITypeReferenceIsEnum { get; }
    private bool ITypeReferenceIsValueType { get; }
    private TypeDefinitionHandle ITypeReferenceTypeDef { get; }
    private IGenericMethodParameter IGenericParameterAsGenericMethodParameter { get; }
    private IGenericMethodParameterReference ITypeReferenceAsGenericMethodParameterReference { get; }
    private IGenericTypeInstanceReference ITypeReferenceAsGenericTypeInstanceReference { get; }
    private IGenericTypeParameter IGenericParameterAsGenericTypeParameter { get; }
    private IGenericTypeParameterReference ITypeReferenceAsGenericTypeParameterReference { get; }
    private INamespaceTypeReference ITypeReferenceAsNamespaceTypeReference { get; }
    private INestedTypeReference ITypeReferenceAsNestedTypeReference { get; }
    private ISpecializedNestedTypeReference ITypeReferenceAsSpecializedNestedTypeReference { get; }
    private string INamedEntityName { get; }
    private ushort IParameterListEntryIndex { get; }
    private IMethodReference IGenericMethodParameterReferenceDefiningMethod { get; }
    private ITypeReference IGenericTypeParameterReferenceDefiningType { get; }
    private bool IGenericParameterMustBeReferenceType { get; }
    private bool IGenericParameterMustBeValueType { get; }
    private bool IGenericParameterMustHaveDefaultConstructor { get; }
    private TypeParameterVariance IGenericParameterVariance { get; }
    private IMethodDefinition IGenericMethodParameterDefiningMethod { get; }
    private ITypeDefinition IGenericTypeParameterDefiningType { get; }
    public TypeParameterSymbol OriginalDefinition { get; }
    protected TypeSymbol OriginalTypeSymbolDefinition { get; }
    public int Ordinal { get; }
    public ImmutableArray`1<TypeSymbol> ConstraintTypes { get; }
    internal ImmutableArray`1<TypeSymbol> ConstraintTypesNoUseSiteDiagnostics { get; }
    public bool HasConstructorConstraint { get; }
    public TypeParameterKind TypeParameterKind { get; }
    public MethodSymbol DeclaringMethod { get; }
    public NamedTypeSymbol DeclaringType { get; }
    public Accessibility DeclaredAccessibility { get; }
    public SymbolKind Kind { get; }
    public TypeKind TypeKind { get; }
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    internal ImmutableArray`1<NamedTypeSymbol> InterfacesNoUseSiteDiagnostics { get; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public VarianceKind Variance { get; }
    public TypeParameterSymbol ReducedFrom { get; }
    internal EmbeddedSymbolKind EmbeddedSymbolKind { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    private IMethodSymbol ITypeParameterSymbol_DeclaringMethod { get; }
    private INamedTypeSymbol ITypeParameterSymbol_DeclaringType { get; }
    private int ITypeParameterSymbol_Ordinal { get; }
    private ImmutableArray`1<ITypeSymbol> ITypeParameterSymbol_ConstraintTypes { get; }
    private ITypeParameterSymbol ITypeParameterSymbol_OriginalDefinition { get; }
    private ITypeParameterSymbol ITypeParameterSymbol_ReducedFrom { get; }
    private static TypeParameterSymbol();
    private sealed virtual override bool get_ITypeReferenceIsEnum();
    private sealed virtual override bool get_ITypeReferenceIsValueType();
    private sealed virtual override ITypeDefinition ITypeReferenceGetResolvedType(EmitContext context);
    private sealed virtual override PrimitiveTypeCode ITypeReferenceTypeCode(EmitContext context);
    private sealed virtual override TypeDefinitionHandle get_ITypeReferenceTypeDef();
    private sealed virtual override IGenericMethodParameter get_IGenericParameterAsGenericMethodParameter();
    private sealed virtual override IGenericMethodParameterReference get_ITypeReferenceAsGenericMethodParameterReference();
    private sealed virtual override IGenericTypeInstanceReference get_ITypeReferenceAsGenericTypeInstanceReference();
    private sealed virtual override IGenericTypeParameter get_IGenericParameterAsGenericTypeParameter();
    private sealed virtual override IGenericTypeParameterReference get_ITypeReferenceAsGenericTypeParameterReference();
    private sealed virtual override INamespaceTypeDefinition ITypeReferenceAsNamespaceTypeDefinition(EmitContext context);
    private sealed virtual override INamespaceTypeReference get_ITypeReferenceAsNamespaceTypeReference();
    private sealed virtual override INestedTypeDefinition ITypeReferenceAsNestedTypeDefinition(EmitContext context);
    private sealed virtual override INestedTypeReference get_ITypeReferenceAsNestedTypeReference();
    private sealed virtual override ISpecializedNestedTypeReference get_ITypeReferenceAsSpecializedNestedTypeReference();
    private sealed virtual override ITypeDefinition ITypeReferenceAsTypeDefinition(EmitContext context);
    internal sealed virtual void IReferenceDispatch(MetadataVisitor visitor);
    internal sealed virtual IDefinition IReferenceAsDefinition(EmitContext context);
    private sealed virtual override string get_INamedEntityName();
    private sealed virtual override ushort get_IParameterListEntryIndex();
    private sealed virtual override IMethodReference get_IGenericMethodParameterReferenceDefiningMethod();
    private sealed virtual override ITypeReference get_IGenericTypeParameterReferenceDefiningType();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeParameterSymbol/VB$StateMachine_38_IGenericParameterGetConstraints")]
private sealed virtual override IEnumerable`1<ITypeReference> IGenericParameterGetConstraints(EmitContext context);
    private sealed virtual override bool get_IGenericParameterMustBeReferenceType();
    private sealed virtual override bool get_IGenericParameterMustBeValueType();
    private sealed virtual override bool get_IGenericParameterMustHaveDefaultConstructor();
    private sealed virtual override TypeParameterVariance get_IGenericParameterVariance();
    private sealed virtual override IMethodDefinition get_IGenericMethodParameterDefiningMethod();
    private sealed virtual override ITypeDefinition get_IGenericTypeParameterDefiningType();
    internal virtual DiagnosticInfo GetUnificationUseSiteDiagnosticRecursive(Symbol owner, HashSet`1& checkedTypes);
    public virtual TypeParameterSymbol get_OriginalDefinition();
    protected sealed virtual TypeSymbol get_OriginalTypeSymbolDefinition();
    public abstract virtual int get_Ordinal();
    internal virtual DiagnosticInfo GetConstraintsUseSiteErrorInfo();
    public ImmutableArray`1<TypeSymbol> get_ConstraintTypes();
    internal abstract virtual ImmutableArray`1<TypeSymbol> get_ConstraintTypesNoUseSiteDiagnostics();
    internal ImmutableArray`1<TypeSymbol> ConstraintTypesWithDefinitionUseSiteDiagnostics(HashSet`1& useSiteDiagnostics);
    public abstract virtual override bool get_HasConstructorConstraint();
    public sealed virtual ImmutableArray`1<Symbol> GetMembers();
    public sealed virtual ImmutableArray`1<Symbol> GetMembers(string name);
    public abstract virtual override TypeParameterKind get_TypeParameterKind();
    public MethodSymbol get_DeclaringMethod();
    public NamedTypeSymbol get_DeclaringType();
    public sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    internal virtual TResult Accept(VisualBasicSymbolVisitor`2<TArgument, TResult> visitor, TArgument arg);
    public sealed virtual Accessibility get_DeclaredAccessibility();
    public sealed virtual SymbolKind get_Kind();
    public sealed virtual TypeKind get_TypeKind();
    internal sealed virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
    internal sealed virtual ImmutableArray`1<NamedTypeSymbol> get_InterfacesNoUseSiteDiagnostics();
    internal abstract virtual void EnsureAllConstraintsAreResolved();
    internal static void EnsureAllConstraintsAreResolved(ImmutableArray`1<TypeParameterSymbol> typeParameters);
    internal void GetConstraints(ArrayBuilder`1<TypeParameterConstraint> constraintsBuilder);
    internal virtual ImmutableArray`1<TypeParameterConstraint> GetConstraints();
    internal virtual void ResolveConstraints(ConsList`1<TypeParameterSymbol> inProgress);
    internal static ImmutableArray`1<TypeSymbol> GetConstraintTypesOnly(ImmutableArray`1<TypeParameterConstraint> constraints);
    public sealed virtual bool get_IsReferenceType();
    private bool IsReferenceTypeIgnoringIsClass();
    private static bool ConstraintImpliesReferenceType(TypeSymbol constraint);
    public virtual bool get_IsValueType();
    internal virtual TypeWithModifiers InternalSubstituteTypeParameters(TypeSubstitution substitution);
    public abstract virtual override bool get_HasReferenceTypeConstraint();
    public abstract virtual override bool get_HasValueTypeConstraint();
    public abstract virtual override VarianceKind get_Variance();
    public virtual TypeParameterSymbol get_ReducedFrom();
    internal static ImmutableArray`1<TypeSymbol> InternalSubstituteTypeParametersDistinct(TypeSubstitution substitution, ImmutableArray`1<TypeSymbol> types);
    internal virtual EmbeddedSymbolKind get_EmbeddedSymbolKind();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    private sealed virtual override IMethodSymbol get_ITypeParameterSymbol_DeclaringMethod();
    private sealed virtual override INamedTypeSymbol get_ITypeParameterSymbol_DeclaringType();
    private sealed virtual override int get_ITypeParameterSymbol_Ordinal();
    private sealed virtual override ImmutableArray`1<ITypeSymbol> get_ITypeParameterSymbol_ConstraintTypes();
    private sealed virtual override ITypeParameterSymbol get_ITypeParameterSymbol_OriginalDefinition();
    private sealed virtual override ITypeParameterSymbol get_ITypeParameterSymbol_ReducedFrom();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSymbolVisitor visitor);
    public virtual TResult Accept(VisualBasicSymbolVisitor`1<TResult> visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSubstitution : object {
    private ImmutableArray`1<KeyValuePair`2<TypeParameterSymbol, TypeWithModifiers>> _pairs;
    private Symbol _targetGenericDefinition;
    private TypeSubstitution _parent;
    private static Func`2<TypeSymbol, TypeWithModifiers> s_withoutModifiers;
    public ImmutableArray`1<KeyValuePair`2<TypeParameterSymbol, TypeWithModifiers>> Pairs { get; }
    public ImmutableArray`1<KeyValuePair`2<TypeParameterSymbol, TypeWithModifiers>> PairsIncludingParent { get; }
    public TypeSubstitution Parent { get; }
    public Symbol TargetGenericDefinition { get; }
    private static TypeSubstitution();
    private TypeSubstitution(Symbol targetGenericDefinition, ImmutableArray`1<KeyValuePair`2<TypeParameterSymbol, TypeWithModifiers>> pairs, TypeSubstitution parent);
    public ImmutableArray`1<KeyValuePair`2<TypeParameterSymbol, TypeWithModifiers>> get_Pairs();
    public ImmutableArray`1<KeyValuePair`2<TypeParameterSymbol, TypeWithModifiers>> get_PairsIncludingParent();
    private void AddPairsIncludingParentToBuilder(ArrayBuilder`1<KeyValuePair`2<TypeParameterSymbol, TypeWithModifiers>> pairBuilder);
    public TypeSubstitution get_Parent();
    public Symbol get_TargetGenericDefinition();
    public TypeWithModifiers GetSubstitutionFor(TypeParameterSymbol tp);
    public ImmutableArray`1<TypeSymbol> GetTypeArgumentsFor(NamedTypeSymbol originalDefinition, Boolean& hasTypeArgumentsCustomModifiers);
    public ImmutableArray`1<ImmutableArray`1<CustomModifier>> GetTypeArgumentsCustomModifiersFor(NamedTypeSymbol originalDefinition);
    public bool HasTypeArgumentsCustomModifiersFor(NamedTypeSymbol originalDefinition);
    public void ThrowIfSubstitutingToAlphaRenamedTypeParameter();
    public TypeSubstitution GetSubstitutionForGenericDefinition(Symbol targetGenericDefinition);
    public TypeSubstitution GetSubstitutionForGenericDefinitionOrContainers(Symbol targetGenericDefinition);
    public bool IsValidToApplyTo(Symbol genericDefinition);
    public static TypeSubstitution Concat(Symbol targetGenericDefinition, TypeSubstitution sub1, TypeSubstitution sub2);
    private static TypeSubstitution ConcatNotNulls(TypeSubstitution sub1, TypeSubstitution sub2);
    public static TypeSubstitution Create(Symbol targetGenericDefinition, TypeParameterSymbol[] params, TypeWithModifiers[] args, bool allowAlphaRenamedTypeParametersAsArguments);
    public static TypeSubstitution Create(Symbol targetGenericDefinition, TypeParameterSymbol[] params, TypeSymbol[] args, bool allowAlphaRenamedTypeParametersAsArguments);
    public static TypeSubstitution Create(Symbol targetGenericDefinition, ImmutableArray`1<TypeParameterSymbol> params, ImmutableArray`1<TypeWithModifiers> args, bool allowAlphaRenamedTypeParametersAsArguments);
    public static TypeSubstitution Create(Symbol targetGenericDefinition, ImmutableArray`1<TypeParameterSymbol> params, ImmutableArray`1<TypeSymbol> args, bool allowAlphaRenamedTypeParametersAsArguments);
    public static TypeSubstitution Create(TypeSubstitution parent, Symbol targetGenericDefinition, ImmutableArray`1<TypeSymbol> args, bool allowAlphaRenamedTypeParametersAsArguments);
    private static TypeSubstitution Concat(TypeSubstitution parent, Symbol targetGenericDefinition, ImmutableArray`1<KeyValuePair`2<TypeParameterSymbol, TypeWithModifiers>> pairs);
    public virtual string ToString();
    private void ToString(StringBuilder builder);
    public static TypeSubstitution CreateForAlphaRename(TypeSubstitution parent, ImmutableArray`1<TypeParameterSymbol> alphaRenamedTypeParameters);
    public static TypeSubstitution CreateAdditionalMethodTypeParameterSubstitution(MethodSymbol targetMethod, ImmutableArray`1<TypeWithModifiers> typeArguments);
    public static TypeSubstitution AdjustForConstruct(TypeSubstitution adjustedParent, TypeSubstitution oldConstructSubstitution, TypeSubstitution additionalSubstitution);
    private static bool PrivateAdjustForConstruct(ArrayBuilder`1<KeyValuePair`2<TypeParameterSymbol, TypeWithModifiers>> pairs, TypeSubstitution oldConstructSubstitution, TypeSubstitution additionalSubstitution);
    public static TypeSubstitution Create(TypeSubstitution parent, Symbol targetGenericDefinition, ImmutableArray`1<TypeWithModifiers> args, bool allowAlphaRenamedTypeParametersAsArguments);
    public ImmutableArray`1<CustomModifier> SubstituteCustomModifiers(TypeSymbol type, ImmutableArray`1<CustomModifier> customModifiers);
    public ImmutableArray`1<CustomModifier> SubstituteCustomModifiers(ImmutableArray`1<CustomModifier> customModifiers);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbol : NamespaceOrTypeSymbol {
    internal static string ImplicitTypeName;
    private static TypeSymbol[] s_EmptyTypeSymbols;
    private ImmutableArray`1<NamedTypeSymbol> _lazyAllInterfaces;
    private ImmutableHashSet`1<NamedTypeSymbol> _lazyInterfacesAndTheirBaseInterfaces;
    private ConcurrentDictionary`2<Symbol, Symbol> _lazyImplementationForInterfaceMemberMap;
    internal Dictionary`2<Symbol, Symbol> m_lazyExplicitInterfaceImplementationMap;
    internal static Dictionary`2<Symbol, Symbol> EmptyExplicitImplementationMap;
    public static IList`1<TypeSymbol> EmptyTypeSymbolsList { get; }
    public TypeSymbol OriginalDefinition { get; }
    protected TypeSymbol OriginalTypeSymbolDefinition { get; }
    protected Symbol OriginalSymbolDefinition { get; }
    public NamedTypeSymbol BaseType { get; }
    internal NamedTypeSymbol BaseTypeNoUseSiteDiagnostics { get; }
    public ImmutableArray`1<NamedTypeSymbol> Interfaces { get; }
    internal ImmutableArray`1<NamedTypeSymbol> InterfacesNoUseSiteDiagnostics { get; }
    public ImmutableArray`1<NamedTypeSymbol> AllInterfaces { get; }
    internal ImmutableArray`1<NamedTypeSymbol> AllInterfacesNoUseSiteDiagnostics { get; }
    internal ImmutableHashSet`1<NamedTypeSymbol> InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics { get; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    public bool IsAnonymousType { get; }
    public bool IsShared { get; }
    public TypeKind TypeKind { get; }
    public SpecialType SpecialType { get; }
    internal PrimitiveTypeCode PrimitiveTypeCode { get; }
    protected int HighestPriorityUseSiteError { get; }
    public bool HasUnsupportedMetadata { get; }
    private ImmutableArray`1<INamedTypeSymbol> ITypeSymbol_AllInterfaces { get; }
    private INamedTypeSymbol ITypeSymbol_BaseType { get; }
    private ImmutableArray`1<INamedTypeSymbol> ITypeSymbol_Interfaces { get; }
    private ITypeSymbol ITypeSymbol_OriginalDefinition { get; }
    private TypeKind ITypeSymbol_TypeKind { get; }
    private ConcurrentDictionary`2<Symbol, Symbol> ImplementationForInterfaceMemberMap { get; }
    internal Dictionary`2<Symbol, Symbol> ExplicitInterfaceImplementationMap { get; }
    private static TypeSymbol();
    public static IList`1<TypeSymbol> get_EmptyTypeSymbolsList();
    public TypeSymbol get_OriginalDefinition();
    protected virtual TypeSymbol get_OriginalTypeSymbolDefinition();
    protected sealed virtual Symbol get_OriginalSymbolDefinition();
    public NamedTypeSymbol get_BaseType();
    internal abstract virtual NamedTypeSymbol get_BaseTypeNoUseSiteDiagnostics();
    internal NamedTypeSymbol BaseTypeWithDefinitionUseSiteDiagnostics(HashSet`1& useSiteDiagnostics);
    internal NamedTypeSymbol BaseTypeOriginalDefinition(HashSet`1& useSiteDiagnostics);
    public ImmutableArray`1<NamedTypeSymbol> get_Interfaces();
    internal abstract virtual ImmutableArray`1<NamedTypeSymbol> get_InterfacesNoUseSiteDiagnostics();
    public ImmutableArray`1<NamedTypeSymbol> get_AllInterfaces();
    internal ImmutableArray`1<NamedTypeSymbol> get_AllInterfacesNoUseSiteDiagnostics();
    internal ImmutableArray`1<NamedTypeSymbol> AllInterfacesWithDefinitionUseSiteDiagnostics(HashSet`1& useSiteDiagnostics);
    protected virtual ImmutableArray`1<NamedTypeSymbol> MakeAllInterfaces();
    private static void MakeAllInterfacesInternal(NamedTypeSymbol i, HashSet`1<NamedTypeSymbol> visited, ArrayBuilder`1<NamedTypeSymbol> result);
    internal ImmutableHashSet`1<NamedTypeSymbol> get_InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics();
    private static ImmutableHashSet`1<NamedTypeSymbol> MakeInterfacesAndTheirBaseInterfaces(ImmutableArray`1<NamedTypeSymbol> declaredInterfaces);
    public abstract virtual override bool get_IsReferenceType();
    public abstract virtual override bool get_IsValueType();
    public virtual override bool get_IsAnonymousType();
    public sealed virtual bool get_IsShared();
    public abstract virtual TypeKind get_TypeKind();
    public virtual override SpecialType get_SpecialType();
    internal PrimitiveTypeCode get_PrimitiveTypeCode();
    internal abstract virtual TypeWithModifiers InternalSubstituteTypeParameters(TypeSubstitution substitution);
    [ObsoleteAttribute("Use TypeWithModifiers.Is method.", "True")]
internal bool Equals(TypeWithModifiers other);
    internal virtual NamedTypeSymbol LookupMetadataType(MetadataTypeName& emittedTypeName);
    internal virtual NamedTypeSymbol GetDirectBaseTypeNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
    internal virtual NamedTypeSymbol GetDirectBaseTypeWithDefinitionUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved, HashSet`1& useSiteDiagnostics);
    protected virtual int get_HighestPriorityUseSiteError();
    public sealed virtual bool get_HasUnsupportedMetadata();
    internal abstract virtual DiagnosticInfo GetUnificationUseSiteDiagnosticRecursive(Symbol owner, HashSet`1& checkedTypes);
    private sealed virtual override ISymbol ITypeSymbol_FindImplementationForInterfaceMember(ISymbol interfaceMember);
    private sealed virtual override ImmutableArray`1<INamedTypeSymbol> get_ITypeSymbol_AllInterfaces();
    private sealed virtual override INamedTypeSymbol get_ITypeSymbol_BaseType();
    private sealed virtual override ImmutableArray`1<INamedTypeSymbol> get_ITypeSymbol_Interfaces();
    private sealed virtual override ITypeSymbol get_ITypeSymbol_OriginalDefinition();
    private sealed virtual override TypeKind get_ITypeSymbol_TypeKind();
    public Symbol FindImplementationForInterfaceMember(Symbol interfaceMember);
    private ConcurrentDictionary`2<Symbol, Symbol> get_ImplementationForInterfaceMemberMap();
    private Symbol ComputeImplementationForInterfaceMember(Symbol interfaceMember);
    internal T GetExplicitImplementationForInterfaceMember(T interfaceMethod);
    internal virtual Dictionary`2<Symbol, Symbol> get_ExplicitInterfaceImplementationMap();
    private Dictionary`2<Symbol, Symbol> MakeExplicitInterfaceImplementationMap();
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeSymbolExtensions : object {
    private static Func`3<TypeSymbol, HashSet`1<TypeParameterSymbol>, bool> s_addIfTypeParameterFunc;
    private static Func`3<TypeSymbol, HashSet`1<TypeParameterSymbol>, bool> s_isTypeParameterNotInSetFunc;
    private static Func`3<TypeSymbol, MethodSymbol, bool> s_isMethodTypeParameterFunc;
    private static Func`3<TypeSymbol, object, bool> s_isTypeParameterFunc;
    private static TypeSymbolExtensions();
    [ExtensionAttribute]
public static bool IsNullableType(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsNullableOfBoolean(TypeSymbol this);
    [ExtensionAttribute]
public static TypeSymbol GetNullableUnderlyingType(TypeSymbol type);
    [ExtensionAttribute]
public static TypeSymbol GetNullableUnderlyingTypeOrSelf(TypeSymbol type);
    [ExtensionAttribute]
public static TypeSymbol GetEnumUnderlyingType(TypeSymbol type);
    [ExtensionAttribute]
public static TypeSymbol GetEnumUnderlyingTypeOrSelf(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsEnumType(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsValidEnumUnderlyingType(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsClassOrInterfaceType(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsInterfaceType(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsClassType(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsStructureType(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsModuleType(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsErrorType(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsArrayType(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsCharSZArray(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsDBNullType(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsMicrosoftVisualBasicCollection(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsTypeParameter(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsDelegateType(TypeSymbol type);
    [ExtensionAttribute]
internal static bool IsSameTypeIgnoringCustomModifiers(TypeSymbol t1, TypeSymbol t2);
    [ExtensionAttribute]
public static SpecialType GetSpecialTypeSafe(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsNumericType(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsIntegralType(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsUnsignedIntegralType(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsSignedIntegralType(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsFloatingType(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsSingleType(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsDoubleType(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsBooleanType(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsCharType(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsStringType(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsObjectType(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsStrictSupertypeOfConcreteDelegate(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsVoidType(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsDecimalType(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsDateTimeType(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsRestrictedType(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsRestrictedArrayType(TypeSymbol this, TypeSymbol& restrictedType);
    [ExtensionAttribute]
public static bool IsRestrictedTypeOrArrayType(TypeSymbol this, TypeSymbol& restrictedType);
    [ExtensionAttribute]
public static bool IsIntrinsicType(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsIntrinsicValueType(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsNotInheritable(TypeSymbol this);
    [ExtensionAttribute]
public static ConstantValueTypeDiscriminator GetConstantValueTypeDiscriminator(TypeSymbol this);
    [ExtensionAttribute]
public static bool IsValidForConstantValue(TypeSymbol this, ConstantValue value);
    [ExtensionAttribute]
public static bool AllowsCompileTimeConversions(TypeSymbol this);
    [ExtensionAttribute]
public static bool AllowsCompileTimeOperations(TypeSymbol this);
    [ExtensionAttribute]
public static bool CanContainUserDefinedOperators(TypeSymbol this, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
public static Nullable`1<int> TypeToIndex(TypeSymbol type);
    [ExtensionAttribute]
public static TypeSymbol DigThroughArrayType(TypeSymbol possiblyArrayType);
    [ExtensionAttribute]
public static bool IsSameOrNestedWithin(NamedTypeSymbol inner, NamedTypeSymbol outer);
    [ExtensionAttribute]
public static bool ImplementsInterface(TypeSymbol subType, TypeSymbol superInterface, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
public static void AddUseSiteDiagnostics(TypeSymbol type, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
public static void AddUseSiteDiagnosticsForBaseDefinitions(TypeSymbol source, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
public static void AddConstraintsUseSiteDiagnostics(TypeParameterSymbol type, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
public static bool IsBaseTypeOf(TypeSymbol superType, TypeSymbol subType, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
public static bool IsOrDerivedFrom(NamedTypeSymbol derivedType, TypeSymbol baseType, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
public static bool IsOrDerivedFrom(TypeSymbol derivedType, TypeSymbol baseType, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
public static bool IsOrDerivedFromWellKnownClass(TypeSymbol derivedType, WellKnownType wellKnownBaseType, VisualBasicCompilation compilation, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
public static bool IsCompatibleWithGenericIEnumerableOfType(TypeSymbol type, TypeSymbol typeArgument, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
public static bool IsOrImplementsIEnumerableOfXElement(TypeSymbol type, VisualBasicCompilation compilation, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
public static bool IsBaseTypeOrInterfaceOf(TypeSymbol superType, TypeSymbol subType, HashSet`1& useSiteDiagnostics);
    [ExtensionAttribute]
internal static bool IsValidTypeForConstField(TypeSymbol fieldType);
    [ExtensionAttribute]
internal static void CollectReferencedTypeParameters(TypeSymbol this, HashSet`1<TypeParameterSymbol> typeParameters);
    private static bool AddIfTypeParameter(TypeSymbol type, HashSet`1<TypeParameterSymbol> typeParameters);
    [ExtensionAttribute]
internal static bool ReferencesTypeParameterNotInTheSet(TypeSymbol this, HashSet`1<TypeParameterSymbol> typeParameters);
    private static bool IsTypeParameterNotInSet(TypeSymbol type, HashSet`1<TypeParameterSymbol> typeParameters);
    [ExtensionAttribute]
internal static bool ReferencesMethodsTypeParameter(TypeSymbol this, MethodSymbol method);
    private static bool IsMethodTypeParameter(TypeSymbol type, MethodSymbol method);
    [ExtensionAttribute]
public static bool IsUnboundGenericType(TypeSymbol this);
    [ExtensionAttribute]
internal static bool IsOrRefersToTypeParameter(TypeSymbol this);
    [ExtensionAttribute]
internal static TypeSymbol VisitType(TypeSymbol this, Func`3<TypeSymbol, T, bool> predicate, T arg);
    [ExtensionAttribute]
public static bool IsValidTypeForAttributeArgument(TypeSymbol type, VisualBasicCompilation compilation);
    [ExtensionAttribute]
public static bool IsValidTypeForSwitchTable(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsIntrinsicOrEnumType(TypeSymbol type);
    [ExtensionAttribute]
public static bool MarkCheckedIfNecessary(TypeSymbol type, HashSet`1& checkedTypes);
    [ExtensionAttribute]
internal static void CheckTypeArguments(ImmutableArray`1<TypeSymbol> typeArguments, int expectedCount);
    [ExtensionAttribute]
internal static ImmutableArray`1<TypeSymbol> TransformToCanonicalFormFor(ImmutableArray`1<TypeSymbol> typeArguments, SpecializedGenericType genericType);
    [ExtensionAttribute]
internal static ImmutableArray`1<TypeSymbol> TransformToCanonicalFormFor(ImmutableArray`1<TypeSymbol> typeArguments, SpecializedGenericMethod genericMethod);
    private static ImmutableArray`1<TypeSymbol> TransformToCanonicalFormFor(ImmutableArray`1<TypeSymbol> typeArguments, Symbol specializedGenericTypeOrMethod, ImmutableArray`1<TypeParameterSymbol> specializedTypeParameters);
    [ExtensionAttribute]
public static NamedTypeSymbol ExpressionTargetDelegate(TypeSymbol type, VisualBasicCompilation compilation);
    [ExtensionAttribute]
public static NamedTypeSymbol DelegateOrExpressionDelegate(TypeSymbol type, Binder binder);
    [ExtensionAttribute]
public static NamedTypeSymbol DelegateOrExpressionDelegate(TypeSymbol type, Binder binder, Boolean& wasExpression);
    [ExtensionAttribute]
public static bool IsExpressionTree(TypeSymbol type, Binder binder);
    [ExtensionAttribute]
public static bool IsExtensibleInterfaceNoUseSiteDiagnostics(TypeSymbol type);
    [ExtensionAttribute]
public static string GetNativeCompilerVType(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsVerifierReference(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsVerifierValue(TypeSymbol type);
    [ExtensionAttribute]
public static bool IsPrimitiveType(TypeSymbol t);
    [ExtensionAttribute]
public static bool IsTopLevelType(NamedTypeSymbol type);
    [ExtensionAttribute]
public static ImmutableArray`1<TypeParameterSymbol> GetAllTypeParameters(NamedTypeSymbol type);
    [ExtensionAttribute]
public static void GetAllTypeParameters(NamedTypeSymbol type, ArrayBuilder`1<TypeParameterSymbol> builder);
    [ExtensionAttribute]
public static ImmutableArray`1<TypeSymbol> GetAllTypeArguments(NamedTypeSymbol type);
    [ExtensionAttribute]
public static ImmutableArray`1<TypeWithModifiers> GetAllTypeArgumentsWithModifiers(NamedTypeSymbol type);
    [ExtensionAttribute]
internal static bool HasNameQualifier(NamedTypeSymbol type, string qualifiedName, StringComparison comparison);
    private static bool HasNamespaceName(NamespaceSymbol namespace, string namespaceName, StringComparison comparison, int length);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.TypeWithModifiers : ValueType {
    public TypeSymbol Type;
    public ImmutableArray`1<CustomModifier> CustomModifiers;
    public TypeWithModifiers(TypeSymbol type, ImmutableArray`1<CustomModifier> customModifiers);
    public TypeWithModifiers(TypeSymbol type);
    [ObsoleteAttribute("Use the strongly typed overload.", "True")]
public virtual bool Equals(object obj);
    public sealed virtual override bool Equals(TypeWithModifiers other);
    public static bool op_Equality(TypeWithModifiers x, TypeWithModifiers y);
    public static bool op_Inequality(TypeWithModifiers x, TypeWithModifiers y);
    public virtual int GetHashCode();
    public bool Is(TypeSymbol other);
    [ObsoleteAttribute("Use Is method.", "True")]
public bool Equals(TypeSymbol other);
    public TypeSymbol AsTypeSymbolOnly();
    public TypeWithModifiers InternalSubstituteTypeParameters(TypeSubstitution substitution);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.UnboundGenericType : NamedTypeSymbol {
    internal static ErrorTypeSymbol UnboundTypeArgument;
    public string Name { get; }
    internal bool MangleName { get; }
    internal bool HasSpecialName { get; }
    internal bool IsSerializable { get; }
    internal TypeLayout Layout { get; }
    internal CharSet MarshallingCharSet { get; }
    public bool IsUnboundGenericType { get; }
    public bool IsAnonymousType { get; }
    public NamedTypeSymbol OriginalDefinition { get; }
    public Symbol ContainingSymbol { get; }
    public int Arity { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public NamedTypeSymbol ConstructedFrom { get; }
    internal ImmutableArray`1<TypeSymbol> TypeArgumentsNoUseSiteDiagnostics { get; }
    internal ImmutableArray`1<ImmutableArray`1<CustomModifier>> TypeArgumentsCustomModifiers { get; }
    internal bool HasTypeArgumentsCustomModifiers { get; }
    public NamedTypeSymbol EnumUnderlyingType { get; }
    public bool MightContainExtensionMethods { get; }
    internal bool HasEmbeddedAttribute { get; }
    internal bool IsExtensibleInterfaceNoUseSiteDiagnostics { get; }
    internal bool IsWindowsRuntimeImport { get; }
    internal bool ShouldAddWinRTMembers { get; }
    internal bool IsComImport { get; }
    internal TypeSymbol CoClassType { get; }
    internal bool HasDeclarativeSecurity { get; }
    public Accessibility DeclaredAccessibility { get; }
    public TypeKind TypeKind { get; }
    internal bool IsInterface { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsMustInherit { get; }
    public bool IsNotInheritable { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    internal bool CanConstruct { get; }
    internal string DefaultPropertyName { get; }
    internal TypeSubstitution TypeSubstitution { get; }
    private static UnboundGenericType();
    internal static NamedTypeSymbol Create(NamedTypeSymbol type);
    public virtual string get_Name();
    internal virtual bool get_MangleName();
    public virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    internal sealed virtual bool get_HasSpecialName();
    internal sealed virtual bool get_IsSerializable();
    internal virtual TypeLayout get_Layout();
    internal virtual CharSet get_MarshallingCharSet();
    public abstract virtual bool get_IsUnboundGenericType();
    public virtual bool get_IsAnonymousType();
    public abstract virtual NamedTypeSymbol get_OriginalDefinition();
    public abstract virtual Symbol get_ContainingSymbol();
    public virtual int get_Arity();
    public abstract virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public abstract virtual NamedTypeSymbol get_ConstructedFrom();
    internal abstract virtual ImmutableArray`1<TypeSymbol> get_TypeArgumentsNoUseSiteDiagnostics();
    internal sealed virtual ImmutableArray`1<ImmutableArray`1<CustomModifier>> get_TypeArgumentsCustomModifiers();
    internal sealed virtual bool get_HasTypeArgumentsCustomModifiers();
    public virtual NamedTypeSymbol get_EnumUnderlyingType();
    public virtual bool get_MightContainExtensionMethods();
    internal virtual bool get_HasEmbeddedAttribute();
    internal virtual bool get_IsExtensibleInterfaceNoUseSiteDiagnostics();
    internal virtual bool get_IsWindowsRuntimeImport();
    internal virtual bool get_ShouldAddWinRTMembers();
    internal virtual bool get_IsComImport();
    internal virtual TypeSymbol get_CoClassType();
    internal virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal virtual AttributeUsageInfo GetAttributeUsageInfo();
    internal virtual bool get_HasDeclarativeSecurity();
    internal virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    public virtual Accessibility get_DeclaredAccessibility();
    public virtual TypeKind get_TypeKind();
    internal virtual bool get_IsInterface();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual bool get_IsMustInherit();
    public virtual bool get_IsNotInheritable();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
    internal virtual NamedTypeSymbol LookupMetadataType(MetadataTypeName& emittedTypeName);
    internal abstract virtual TypeWithModifiers InternalSubstituteTypeParameters(TypeSubstitution additionalSubstitution);
    internal virtual NamedTypeSymbol MakeDeclaredBase(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    internal virtual NamedTypeSymbol MakeAcyclicBaseType(DiagnosticBag diagnostics);
    internal virtual NamedTypeSymbol GetDirectBaseTypeNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
    internal virtual NamedTypeSymbol GetDeclaredBase(ConsList`1<Symbol> basesBeingResolved);
    internal virtual ImmutableArray`1<NamedTypeSymbol> MakeDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<NamedTypeSymbol> MakeAcyclicInterfaces(DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<NamedTypeSymbol> GetDeclaredInterfacesNoUseSiteDiagnostics(ConsList`1<Symbol> basesBeingResolved);
    internal virtual DiagnosticInfo GetUseSiteErrorInfo();
    public abstract virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual bool get_CanConstruct();
    public virtual NamedTypeSymbol Construct(ImmutableArray`1<TypeSymbol> typeArguments);
    internal virtual string get_DefaultPropertyName();
    internal abstract virtual TypeSubstitution get_TypeSubstitution();
    internal sealed virtual void GenerateDeclarationErrors(CancellationToken cancellationToken);
    internal sealed virtual DiagnosticInfo GetUnificationUseSiteDiagnosticRecursive(Symbol owner, HashSet`1& checkedTypes);
    internal sealed virtual IEnumerable`1<FieldSymbol> GetFieldsToEmit();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.UnboundLambdaParameterSymbol : LambdaParameterSymbol {
    private ModifiedIdentifierSyntax _identifierSyntax;
    private SyntaxNodeOrToken _typeSyntax;
    public SyntaxToken IdentifierSyntax { get; }
    public ModifiedIdentifierSyntax Syntax { get; }
    public SyntaxNodeOrToken TypeSyntax { get; }
    public Symbol ContainingSymbol { get; }
    private UnboundLambdaParameterSymbol(string name, int ordinal, TypeSymbol type, Location location, SourceParameterFlags flags, ModifiedIdentifierSyntax identifierSyntax, SyntaxNodeOrToken typeSyntax);
    public SyntaxToken get_IdentifierSyntax();
    public ModifiedIdentifierSyntax get_Syntax();
    public SyntaxNodeOrToken get_TypeSyntax();
    public virtual Symbol get_ContainingSymbol();
    internal static ParameterSymbol CreateFromSyntax(ParameterSyntax syntax, string name, SourceParameterFlags flags, int ordinal, Binder binder, DiagnosticBag diagBag);
    private static SyntaxToken GetModifierToken(SyntaxTokenList modifiers, SyntaxKind tokenKind);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Symbols.UnsupportedMetadataTypeSymbol : ErrorTypeSymbol {
    private BadImageFormatException _mrEx;
    internal bool MangleName { get; }
    internal DiagnosticInfo ErrorInfo { get; }
    public UnsupportedMetadataTypeSymbol(BadImageFormatException mrEx);
    public UnsupportedMetadataTypeSymbol(string explanation);
    internal virtual bool get_MangleName();
    internal virtual DiagnosticInfo get_ErrorInfo();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicAttributeData : AttributeData {
    private ThreeState _lazyIsSecurityAttribute;
    private int ArgumentCount { get; }
    private ushort NamedArgumentCount { get; }
    private bool AllowMultiple1 { get; }
    public NamedTypeSymbol AttributeClass { get; }
    public MethodSymbol AttributeConstructor { get; }
    public SyntaxReference ApplicationSyntaxReference { get; }
    public IEnumerable`1<TypedConstant> ConstructorArguments { get; }
    public IEnumerable`1<KeyValuePair`2<string, TypedConstant>> NamedArguments { get; }
    protected INamedTypeSymbol CommonAttributeClass { get; }
    protected IMethodSymbol CommonAttributeConstructor { get; }
    protected SyntaxReference CommonApplicationSyntaxReference { get; }
    private sealed virtual override ImmutableArray`1<IMetadataExpression> GetArguments1(EmitContext context);
    private sealed virtual override IMethodReference Constructor1(EmitContext context);
    private sealed virtual override ImmutableArray`1<IMetadataNamedArgument> GetNamedArguments1(EmitContext context);
    private sealed virtual override int get_ArgumentCount();
    private sealed virtual override ushort get_NamedArgumentCount();
    private sealed virtual override ITypeReference GetType1(EmitContext context);
    private sealed virtual override bool get_AllowMultiple1();
    private IMetadataExpression CreateMetadataExpression(TypedConstant argument, EmitContext context);
    private MetadataCreateArray CreateMetadataArray(TypedConstant argument, EmitContext context);
    private MetadataTypeOf CreateType(TypedConstant argument, EmitContext context);
    private MetadataConstant CreateMetadataConstant(ITypeSymbol type, object value, EmitContext context);
    private IMetadataNamedArgument CreateMetadataNamedArgument(string name, TypedConstant argument, EmitContext context);
    private Symbol LookupName(string name);
    public abstract virtual NamedTypeSymbol get_AttributeClass();
    public abstract virtual MethodSymbol get_AttributeConstructor();
    public abstract virtual SyntaxReference get_ApplicationSyntaxReference();
    public IEnumerable`1<TypedConstant> get_ConstructorArguments();
    public IEnumerable`1<KeyValuePair`2<string, TypedConstant>> get_NamedArguments();
    internal virtual bool IsTargetAttribute(string namespaceName, string typeName, bool ignoreCase);
    internal bool IsTargetAttribute(Symbol targetSymbol, AttributeDescription description);
    internal abstract virtual int GetTargetAttributeSignatureIndex(Symbol targetSymbol, AttributeDescription description);
    internal static bool IsTargetEarlyAttribute(NamedTypeSymbol attributeType, AttributeSyntax attributeSyntax, AttributeDescription description);
    public virtual string ToString();
    protected virtual INamedTypeSymbol get_CommonAttributeClass();
    protected virtual IMethodSymbol get_CommonAttributeConstructor();
    protected virtual SyntaxReference get_CommonApplicationSyntaxReference();
    internal bool IsSecurityAttribute(VisualBasicCompilation comp);
    internal void DecodeSecurityAttribute(Symbol targetSymbol, VisualBasicCompilation compilation, DecodeWellKnownAttributeArguments`3& arguments);
    private DeclarativeSecurityAction DecodeSecurityAttributeAction(Symbol targetSymbol, VisualBasicCompilation compilation, AttributeSyntax nodeOpt, Boolean& hasErrors, DiagnosticBag diagnostics);
    private DeclarativeSecurityAction ValidateSecurityAction(TypedConstant typedValue, Symbol targetSymbol, AttributeSyntax nodeOpt, DiagnosticBag diagnostics, Boolean& hasErrors);
    internal string DecodePermissionSetAttribute(VisualBasicCompilation compilation, DecodeWellKnownAttributeArguments`3& arguments);
    private static bool PermissionSetAttributeTypeHasRequiredProperty(NamedTypeSymbol permissionSetType, string propName);
    internal void DecodeClassInterfaceAttribute(AttributeSyntax nodeOpt, DiagnosticBag diagnostics);
    internal void DecodeInterfaceTypeAttribute(AttributeSyntax node, DiagnosticBag diagnostics);
    internal bool DecodeInterfaceTypeAttribute(ComInterfaceType& interfaceType);
    internal TypeLibTypeFlags DecodeTypeLibTypeAttribute();
    internal void DecodeGuidAttribute(AttributeSyntax nodeOpt, DiagnosticBag diagnostics);
    internal string DecodeDefaultMemberAttribute();
    internal bool ShouldEmitAttribute(Symbol target, bool isReturnType, bool emittingAssemblyAttributesInNetModule);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Symbols.VisualBasicCustomModifier : CustomModifier {
    protected NamedTypeSymbol m_Modifier;
    private bool CciIsOptional { get; }
    public INamedTypeSymbol Modifier { get; }
    private VisualBasicCustomModifier(NamedTypeSymbol modifier);
    private sealed virtual override bool get_CciIsOptional();
    private sealed virtual override ITypeReference CciGetModifier(EmitContext context);
    public virtual INamedTypeSymbol get_Modifier();
    public abstract virtual int GetHashCode();
    public abstract virtual bool Equals(object obj);
    internal static CustomModifier CreateOptional(NamedTypeSymbol modifier);
    internal static CustomModifier CreateRequired(NamedTypeSymbol modifier);
    internal static ImmutableArray`1<CustomModifier> Convert(ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers);
    private static CustomModifier Convert(ModifierInfo`1<TypeSymbol> customModifier);
}
internal class Microsoft.CodeAnalysis.VisualBasic.SymbolsInProgress`1 : object {
    private ImmutableSetWithInsertionOrder`1<T> _symbols;
    internal static SymbolsInProgress`1<T> Empty;
    private static SymbolsInProgress`1();
    private SymbolsInProgress`1(ImmutableSetWithInsertionOrder`1<T> fields);
    internal SymbolsInProgress`1<T> Add(T symbol);
    internal bool Contains(T symbol);
    internal T GetStartOfCycleIfAny(T symbol);
    private static bool IsBetterErrorLocation(T errorSymbol, T symbol);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.SymbolsInProgressBinder`1 : Binder {
    protected SymbolsInProgress`1<T> inProgress;
    protected SymbolsInProgressBinder`1(SymbolsInProgress`1<T> inProgress, Binder next);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorBlockSyntax : MethodBlockBaseSyntax {
    internal AccessorStatementSyntax _accessorStatement;
    internal EndBlockStatementSyntax _endAccessorStatement;
    public MethodBaseSyntax BlockStatement { get; }
    public EndBlockStatementSyntax EndBlockStatement { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use AccessorStatement instead.", "True")]
public AccessorStatementSyntax Begin { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use EndAccessorStatement instead.", "True")]
public EndBlockStatementSyntax End { get; }
    public AccessorStatementSyntax AccessorStatement { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    public EndBlockStatementSyntax EndAccessorStatement { get; }
    internal AccessorBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal AccessorBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, AccessorStatementSyntax accessorStatement, SyntaxNode statements, EndBlockStatementSyntax endAccessorStatement);
    public virtual MethodBaseSyntax get_BlockStatement();
    public virtual EndBlockStatementSyntax get_EndBlockStatement();
    public virtual MethodBlockBaseSyntax WithBlockStatement(MethodBaseSyntax blockStatement);
    public virtual MethodBlockBaseSyntax WithEndBlockStatement(EndBlockStatementSyntax endBlockStatement);
    public AccessorStatementSyntax get_Begin();
    public EndBlockStatementSyntax get_End();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use WithAccessorStatement instead.", "True")]
public AccessorBlockSyntax WithBegin(AccessorStatementSyntax begin);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use WithEndAccessorStatement instead.", "True")]
public AccessorBlockSyntax WithEnd(EndBlockStatementSyntax end);
    public AccessorStatementSyntax get_AccessorStatement();
    public AccessorBlockSyntax WithAccessorStatement(AccessorStatementSyntax accessorStatement);
    public SyntaxList`1<StatementSyntax> get_Statements();
    internal virtual SyntaxList`1<StatementSyntax> GetStatementsCore();
    public AccessorBlockSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public AccessorBlockSyntax AddStatements(StatementSyntax[] items);
    public EndBlockStatementSyntax get_EndAccessorStatement();
    public AccessorBlockSyntax WithEndAccessorStatement(EndBlockStatementSyntax endAccessorStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public AccessorBlockSyntax Update(SyntaxKind kind, AccessorStatementSyntax accessorStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endAccessorStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.AccessorStatementSyntax : MethodBaseSyntax {
    public SyntaxToken DeclarationKeyword { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public SyntaxToken Keyword { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken AccessorKeyword { get; }
    public ParameterListSyntax ParameterList { get; }
    internal AccessorStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal AccessorStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode attributeLists, GreenNode modifiers, KeywordSyntax accessorKeyword, ParameterListSyntax parameterList);
    public virtual SyntaxToken get_DeclarationKeyword();
    public virtual MethodBaseSyntax WithDeclarationKeyword(SyntaxToken keyword);
    public SyntaxToken get_Keyword();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public AccessorStatementSyntax WithKeyword(SyntaxToken keyword);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual SyntaxList`1<AttributeListSyntax> GetAttributeListsCore();
    public AccessorStatementSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public AccessorStatementSyntax AddAttributeLists(AttributeListSyntax[] items);
    public SyntaxTokenList get_Modifiers();
    internal virtual SyntaxTokenList GetModifiersCore();
    public AccessorStatementSyntax WithModifiers(SyntaxTokenList modifiers);
    public AccessorStatementSyntax AddModifiers(SyntaxToken[] items);
    public SyntaxToken get_AccessorKeyword();
    public AccessorStatementSyntax WithAccessorKeyword(SyntaxToken accessorKeyword);
    public ParameterListSyntax get_ParameterList();
    internal virtual ParameterListSyntax GetParameterListCore();
    public AccessorStatementSyntax WithParameterList(ParameterListSyntax parameterList);
    public AccessorStatementSyntax AddParameterListParameters(ParameterSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public AccessorStatementSyntax Update(SyntaxKind kind, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken accessorKeyword, ParameterListSyntax parameterList);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.AddRemoveHandlerStatementSyntax : ExecutableStatementSyntax {
    internal ExpressionSyntax _eventExpression;
    internal ExpressionSyntax _delegateExpression;
    public SyntaxToken AddHandlerOrRemoveHandlerKeyword { get; }
    public ExpressionSyntax EventExpression { get; }
    public SyntaxToken CommaToken { get; }
    public ExpressionSyntax DelegateExpression { get; }
    internal AddRemoveHandlerStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal AddRemoveHandlerStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax addHandlerOrRemoveHandlerKeyword, ExpressionSyntax eventExpression, PunctuationSyntax commaToken, ExpressionSyntax delegateExpression);
    public SyntaxToken get_AddHandlerOrRemoveHandlerKeyword();
    public AddRemoveHandlerStatementSyntax WithAddHandlerOrRemoveHandlerKeyword(SyntaxToken addHandlerOrRemoveHandlerKeyword);
    public ExpressionSyntax get_EventExpression();
    public AddRemoveHandlerStatementSyntax WithEventExpression(ExpressionSyntax eventExpression);
    public SyntaxToken get_CommaToken();
    public AddRemoveHandlerStatementSyntax WithCommaToken(SyntaxToken commaToken);
    public ExpressionSyntax get_DelegateExpression();
    public AddRemoveHandlerStatementSyntax WithDelegateExpression(ExpressionSyntax delegateExpression);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public AddRemoveHandlerStatementSyntax Update(SyntaxKind kind, SyntaxToken addHandlerOrRemoveHandlerKeyword, ExpressionSyntax eventExpression, SyntaxToken commaToken, ExpressionSyntax delegateExpression);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregateClauseSyntax : QueryClauseSyntax {
    internal SyntaxNode _variables;
    internal SyntaxNode _additionalQueryOperators;
    internal SyntaxNode _aggregationVariables;
    public SyntaxToken AggregateKeyword { get; }
    public SeparatedSyntaxList`1<CollectionRangeVariableSyntax> Variables { get; }
    public SyntaxList`1<QueryClauseSyntax> AdditionalQueryOperators { get; }
    public SyntaxToken IntoKeyword { get; }
    public SeparatedSyntaxList`1<AggregationRangeVariableSyntax> AggregationVariables { get; }
    internal AggregateClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal AggregateClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax aggregateKeyword, SyntaxNode variables, SyntaxNode additionalQueryOperators, KeywordSyntax intoKeyword, SyntaxNode aggregationVariables);
    public SyntaxToken get_AggregateKeyword();
    public AggregateClauseSyntax WithAggregateKeyword(SyntaxToken aggregateKeyword);
    public SeparatedSyntaxList`1<CollectionRangeVariableSyntax> get_Variables();
    public AggregateClauseSyntax WithVariables(SeparatedSyntaxList`1<CollectionRangeVariableSyntax> variables);
    public AggregateClauseSyntax AddVariables(CollectionRangeVariableSyntax[] items);
    public SyntaxList`1<QueryClauseSyntax> get_AdditionalQueryOperators();
    public AggregateClauseSyntax WithAdditionalQueryOperators(SyntaxList`1<QueryClauseSyntax> additionalQueryOperators);
    public AggregateClauseSyntax AddAdditionalQueryOperators(QueryClauseSyntax[] items);
    public SyntaxToken get_IntoKeyword();
    public AggregateClauseSyntax WithIntoKeyword(SyntaxToken intoKeyword);
    public SeparatedSyntaxList`1<AggregationRangeVariableSyntax> get_AggregationVariables();
    public AggregateClauseSyntax WithAggregationVariables(SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
    public AggregateClauseSyntax AddAggregationVariables(AggregationRangeVariableSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public AggregateClauseSyntax Update(SyntaxToken aggregateKeyword, SeparatedSyntaxList`1<CollectionRangeVariableSyntax> variables, SyntaxList`1<QueryClauseSyntax> additionalQueryOperators, SyntaxToken intoKeyword, SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationRangeVariableSyntax : VisualBasicSyntaxNode {
    internal VariableNameEqualsSyntax _nameEquals;
    internal AggregationSyntax _aggregation;
    public VariableNameEqualsSyntax NameEquals { get; }
    public AggregationSyntax Aggregation { get; }
    internal AggregationRangeVariableSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal AggregationRangeVariableSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, VariableNameEqualsSyntax nameEquals, AggregationSyntax aggregation);
    public VariableNameEqualsSyntax get_NameEquals();
    public AggregationRangeVariableSyntax WithNameEquals(VariableNameEqualsSyntax nameEquals);
    public AggregationSyntax get_Aggregation();
    public AggregationRangeVariableSyntax WithAggregation(AggregationSyntax aggregation);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public AggregationRangeVariableSyntax Update(VariableNameEqualsSyntax nameEquals, AggregationSyntax aggregation);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.AggregationSyntax : ExpressionSyntax {
    internal AggregationSyntax(GreenNode green, SyntaxNode parent, int startLocation);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.AnonymousObjectCreationExpressionSyntax : NewExpressionSyntax {
    internal ObjectMemberInitializerSyntax _initializer;
    public SyntaxToken NewKeyword { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public ObjectMemberInitializerSyntax Initializer { get; }
    internal AnonymousObjectCreationExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax newKeyword, SyntaxNode attributeLists, ObjectMemberInitializerSyntax initializer);
    public SyntaxToken get_NewKeyword();
    internal virtual SyntaxToken GetNewKeywordCore();
    public AnonymousObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual SyntaxList`1<AttributeListSyntax> GetAttributeListsCore();
    public AnonymousObjectCreationExpressionSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public AnonymousObjectCreationExpressionSyntax AddAttributeLists(AttributeListSyntax[] items);
    public ObjectMemberInitializerSyntax get_Initializer();
    public AnonymousObjectCreationExpressionSyntax WithInitializer(ObjectMemberInitializerSyntax initializer);
    public AnonymousObjectCreationExpressionSyntax AddInitializerInitializers(FieldInitializerSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public AnonymousObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxList`1<AttributeListSyntax> attributeLists, ObjectMemberInitializerSyntax initializer);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentListSyntax : VisualBasicSyntaxNode {
    internal SyntaxNode _arguments;
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxList`1<ArgumentSyntax> Arguments { get; }
    public SyntaxToken CloseParenToken { get; }
    internal ArgumentListSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ArgumentListSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax openParenToken, SyntaxNode arguments, PunctuationSyntax closeParenToken);
    public SyntaxToken get_OpenParenToken();
    public ArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public SeparatedSyntaxList`1<ArgumentSyntax> get_Arguments();
    public ArgumentListSyntax WithArguments(SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    public ArgumentListSyntax AddArguments(ArgumentSyntax[] items);
    public SyntaxToken get_CloseParenToken();
    public ArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList`1<ArgumentSyntax> arguments, SyntaxToken closeParenToken);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.ArgumentSyntax : VisualBasicSyntaxNode {
    public bool IsNamed { get; }
    public bool IsOmitted { get; }
    internal ArgumentSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    public abstract virtual bool get_IsNamed();
    public bool get_IsOmitted();
    public abstract virtual ExpressionSyntax GetExpression();
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayCreationExpressionSyntax : NewExpressionSyntax {
    internal TypeSyntax _type;
    internal ArgumentListSyntax _arrayBounds;
    internal SyntaxNode _rankSpecifiers;
    internal CollectionInitializerSyntax _initializer;
    public SyntaxToken NewKeyword { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public TypeSyntax Type { get; }
    public ArgumentListSyntax ArrayBounds { get; }
    public SyntaxList`1<ArrayRankSpecifierSyntax> RankSpecifiers { get; }
    public CollectionInitializerSyntax Initializer { get; }
    internal ArrayCreationExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ArrayCreationExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax newKeyword, SyntaxNode attributeLists, TypeSyntax type, ArgumentListSyntax arrayBounds, SyntaxNode rankSpecifiers, CollectionInitializerSyntax initializer);
    public SyntaxToken get_NewKeyword();
    internal virtual SyntaxToken GetNewKeywordCore();
    public ArrayCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual SyntaxList`1<AttributeListSyntax> GetAttributeListsCore();
    public ArrayCreationExpressionSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public ArrayCreationExpressionSyntax AddAttributeLists(AttributeListSyntax[] items);
    public TypeSyntax get_Type();
    public ArrayCreationExpressionSyntax WithType(TypeSyntax type);
    public ArgumentListSyntax get_ArrayBounds();
    public ArrayCreationExpressionSyntax WithArrayBounds(ArgumentListSyntax arrayBounds);
    public ArrayCreationExpressionSyntax AddArrayBoundsArguments(ArgumentSyntax[] items);
    public SyntaxList`1<ArrayRankSpecifierSyntax> get_RankSpecifiers();
    public ArrayCreationExpressionSyntax WithRankSpecifiers(SyntaxList`1<ArrayRankSpecifierSyntax> rankSpecifiers);
    public ArrayCreationExpressionSyntax AddRankSpecifiers(ArrayRankSpecifierSyntax[] items);
    public CollectionInitializerSyntax get_Initializer();
    public ArrayCreationExpressionSyntax WithInitializer(CollectionInitializerSyntax initializer);
    public ArrayCreationExpressionSyntax AddInitializerInitializers(ExpressionSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxList`1<AttributeListSyntax> attributeLists, TypeSyntax type, ArgumentListSyntax arrayBounds, SyntaxList`1<ArrayRankSpecifierSyntax> rankSpecifiers, CollectionInitializerSyntax initializer);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayRankSpecifierSyntax : VisualBasicSyntaxNode {
    public int Rank { get; }
    public SyntaxToken OpenParenToken { get; }
    public SyntaxTokenList CommaTokens { get; }
    public SyntaxToken CloseParenToken { get; }
    internal ArrayRankSpecifierSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ArrayRankSpecifierSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax openParenToken, GreenNode commaTokens, PunctuationSyntax closeParenToken);
    public int get_Rank();
    public SyntaxToken get_OpenParenToken();
    public ArrayRankSpecifierSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public SyntaxTokenList get_CommaTokens();
    public ArrayRankSpecifierSyntax WithCommaTokens(SyntaxTokenList commaTokens);
    public ArrayRankSpecifierSyntax AddCommaTokens(SyntaxToken[] items);
    public SyntaxToken get_CloseParenToken();
    public ArrayRankSpecifierSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ArrayRankSpecifierSyntax Update(SyntaxToken openParenToken, SyntaxTokenList commaTokens, SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ArrayTypeSyntax : TypeSyntax {
    internal TypeSyntax _elementType;
    internal SyntaxNode _rankSpecifiers;
    public TypeSyntax ElementType { get; }
    public SyntaxList`1<ArrayRankSpecifierSyntax> RankSpecifiers { get; }
    internal ArrayTypeSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ArrayTypeSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, TypeSyntax elementType, SyntaxNode rankSpecifiers);
    public TypeSyntax get_ElementType();
    public ArrayTypeSyntax WithElementType(TypeSyntax elementType);
    public SyntaxList`1<ArrayRankSpecifierSyntax> get_RankSpecifiers();
    public ArrayTypeSyntax WithRankSpecifiers(SyntaxList`1<ArrayRankSpecifierSyntax> rankSpecifiers);
    public ArrayTypeSyntax AddRankSpecifiers(ArrayRankSpecifierSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ArrayTypeSyntax Update(TypeSyntax elementType, SyntaxList`1<ArrayRankSpecifierSyntax> rankSpecifiers);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.AsClauseSyntax : VisualBasicSyntaxNode {
    public SyntaxToken AsKeyword { get; }
    internal AsClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    public SyntaxToken get_AsKeyword();
    internal virtual SyntaxToken GetAsKeywordCore();
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.AsNewClauseSyntax : AsClauseSyntax {
    internal NewExpressionSyntax _newExpression;
    public SyntaxToken AsKeyword { get; }
    public NewExpressionSyntax NewExpression { get; }
    internal AsNewClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal AsNewClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax asKeyword, NewExpressionSyntax newExpression);
    public SyntaxToken get_AsKeyword();
    internal virtual SyntaxToken GetAsKeywordCore();
    public AsNewClauseSyntax WithAsKeyword(SyntaxToken asKeyword);
    public NewExpressionSyntax get_NewExpression();
    public AsNewClauseSyntax WithNewExpression(NewExpressionSyntax newExpression);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public AsNewClauseSyntax Update(SyntaxToken asKeyword, NewExpressionSyntax newExpression);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.AssignmentStatementSyntax : ExecutableStatementSyntax {
    internal ExpressionSyntax _left;
    internal ExpressionSyntax _right;
    public ExpressionSyntax Left { get; }
    public SyntaxToken OperatorToken { get; }
    public ExpressionSyntax Right { get; }
    internal AssignmentStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal AssignmentStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    public ExpressionSyntax get_Left();
    public AssignmentStatementSyntax WithLeft(ExpressionSyntax left);
    public SyntaxToken get_OperatorToken();
    public AssignmentStatementSyntax WithOperatorToken(SyntaxToken operatorToken);
    public ExpressionSyntax get_Right();
    public AssignmentStatementSyntax WithRight(ExpressionSyntax right);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public AssignmentStatementSyntax Update(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeListSyntax : VisualBasicSyntaxNode {
    internal SyntaxNode _attributes;
    public SyntaxToken LessThanToken { get; }
    public SeparatedSyntaxList`1<AttributeSyntax> Attributes { get; }
    public SyntaxToken GreaterThanToken { get; }
    internal AttributeListSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal AttributeListSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanToken, SyntaxNode attributes, PunctuationSyntax greaterThanToken);
    public SyntaxToken get_LessThanToken();
    public AttributeListSyntax WithLessThanToken(SyntaxToken lessThanToken);
    public SeparatedSyntaxList`1<AttributeSyntax> get_Attributes();
    public AttributeListSyntax WithAttributes(SeparatedSyntaxList`1<AttributeSyntax> attributes);
    public AttributeListSyntax AddAttributes(AttributeSyntax[] items);
    public SyntaxToken get_GreaterThanToken();
    public AttributeListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public AttributeListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList`1<AttributeSyntax> attributes, SyntaxToken greaterThanToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributesStatementSyntax : DeclarationStatementSyntax {
    internal SyntaxNode _attributeLists;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    internal AttributesStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal AttributesStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode attributeLists);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public AttributesStatementSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public AttributesStatementSyntax AddAttributeLists(AttributeListSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public AttributesStatementSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeSyntax : VisualBasicSyntaxNode {
    internal AttributeTargetSyntax _target;
    internal TypeSyntax _name;
    internal ArgumentListSyntax _argumentList;
    public AttributeTargetSyntax Target { get; }
    public TypeSyntax Name { get; }
    public ArgumentListSyntax ArgumentList { get; }
    internal AttributeSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal AttributeSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, AttributeTargetSyntax target, TypeSyntax name, ArgumentListSyntax argumentList);
    public AttributeTargetSyntax get_Target();
    public AttributeSyntax WithTarget(AttributeTargetSyntax target);
    public TypeSyntax get_Name();
    public AttributeSyntax WithName(TypeSyntax name);
    public ArgumentListSyntax get_ArgumentList();
    public AttributeSyntax WithArgumentList(ArgumentListSyntax argumentList);
    public AttributeSyntax AddArgumentListArguments(ArgumentSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public AttributeSyntax Update(AttributeTargetSyntax target, TypeSyntax name, ArgumentListSyntax argumentList);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.AttributeTargetSyntax : VisualBasicSyntaxNode {
    public SyntaxToken AttributeModifier { get; }
    public SyntaxToken ColonToken { get; }
    internal AttributeTargetSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal AttributeTargetSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax attributeModifier, PunctuationSyntax colonToken);
    public SyntaxToken get_AttributeModifier();
    public AttributeTargetSyntax WithAttributeModifier(SyntaxToken attributeModifier);
    public SyntaxToken get_ColonToken();
    public AttributeTargetSyntax WithColonToken(SyntaxToken colonToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public AttributeTargetSyntax Update(SyntaxToken attributeModifier, SyntaxToken colonToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.AwaitExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax _expression;
    public SyntaxToken AwaitKeyword { get; }
    public ExpressionSyntax Expression { get; }
    internal AwaitExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal AwaitExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax awaitKeyword, ExpressionSyntax expression);
    public SyntaxToken get_AwaitKeyword();
    public AwaitExpressionSyntax WithAwaitKeyword(SyntaxToken awaitKeyword);
    public ExpressionSyntax get_Expression();
    public AwaitExpressionSyntax WithExpression(ExpressionSyntax expression);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public AwaitExpressionSyntax Update(SyntaxToken awaitKeyword, ExpressionSyntax expression);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.BadDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    internal BadDirectiveTriviaSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal BadDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken);
    public SyntaxToken get_HashToken();
    internal virtual SyntaxToken GetHashTokenCore();
    public BadDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public BadDirectiveTriviaSyntax Update(SyntaxToken hashToken);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.BaseSyntaxExtensions : object {
    [ExtensionAttribute]
internal static VisualBasicSyntaxNode ToGreen(VisualBasicSyntaxNode node);
    [ExtensionAttribute]
internal static VisualBasicSyntaxNode ToGreen(VisualBasicSyntaxNode node);
    [ExtensionAttribute]
internal static SyntaxNode ToRed(VisualBasicSyntaxNode node);
    [ExtensionAttribute]
internal static VisualBasicSyntaxNode ToRed(VisualBasicSyntaxNode node);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.BaseXmlAttributeSyntax : XmlNodeSyntax {
    internal BaseXmlAttributeSyntax(GreenNode green, SyntaxNode parent, int startLocation);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryConditionalExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax _firstExpression;
    internal ExpressionSyntax _secondExpression;
    public SyntaxToken IfKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax FirstExpression { get; }
    public SyntaxToken CommaToken { get; }
    public ExpressionSyntax SecondExpression { get; }
    public SyntaxToken CloseParenToken { get; }
    internal BinaryConditionalExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal BinaryConditionalExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax ifKeyword, PunctuationSyntax openParenToken, ExpressionSyntax firstExpression, PunctuationSyntax commaToken, ExpressionSyntax secondExpression, PunctuationSyntax closeParenToken);
    public SyntaxToken get_IfKeyword();
    public BinaryConditionalExpressionSyntax WithIfKeyword(SyntaxToken ifKeyword);
    public SyntaxToken get_OpenParenToken();
    public BinaryConditionalExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public ExpressionSyntax get_FirstExpression();
    public BinaryConditionalExpressionSyntax WithFirstExpression(ExpressionSyntax firstExpression);
    public SyntaxToken get_CommaToken();
    public BinaryConditionalExpressionSyntax WithCommaToken(SyntaxToken commaToken);
    public ExpressionSyntax get_SecondExpression();
    public BinaryConditionalExpressionSyntax WithSecondExpression(ExpressionSyntax secondExpression);
    public SyntaxToken get_CloseParenToken();
    public BinaryConditionalExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public BinaryConditionalExpressionSyntax Update(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax firstExpression, SyntaxToken commaToken, ExpressionSyntax secondExpression, SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.BinaryExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax _left;
    internal ExpressionSyntax _right;
    public ExpressionSyntax Left { get; }
    public SyntaxToken OperatorToken { get; }
    public ExpressionSyntax Right { get; }
    internal BinaryExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal BinaryExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public ExpressionSyntax get_Left();
    public BinaryExpressionSyntax WithLeft(ExpressionSyntax left);
    public SyntaxToken get_OperatorToken();
    public BinaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken);
    public ExpressionSyntax get_Right();
    public BinaryExpressionSyntax WithRight(ExpressionSyntax right);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public BinaryExpressionSyntax Update(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.CallStatementSyntax : ExecutableStatementSyntax {
    internal ExpressionSyntax _invocation;
    public SyntaxToken CallKeyword { get; }
    public ExpressionSyntax Invocation { get; }
    internal CallStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal CallStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax callKeyword, ExpressionSyntax invocation);
    public SyntaxToken get_CallKeyword();
    public CallStatementSyntax WithCallKeyword(SyntaxToken callKeyword);
    public ExpressionSyntax get_Invocation();
    public CallStatementSyntax WithInvocation(ExpressionSyntax invocation);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public CallStatementSyntax Update(SyntaxToken callKeyword, ExpressionSyntax invocation);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseBlockSyntax : VisualBasicSyntaxNode {
    internal CaseStatementSyntax _caseStatement;
    internal SyntaxNode _statements;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use CaseStatement instead.", "True")]
public CaseStatementSyntax Begin { get; }
    public CaseStatementSyntax CaseStatement { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    internal CaseBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal CaseBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, CaseStatementSyntax caseStatement, SyntaxNode statements);
    public CaseStatementSyntax get_Begin();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use WithCaseStatement instead.", "True")]
public CaseBlockSyntax WithBegin(CaseStatementSyntax begin);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use AddCaseStatementCases instead.", "True")]
public CaseBlockSyntax AddBeginCases(CaseClauseSyntax[] items);
    public CaseStatementSyntax get_CaseStatement();
    public CaseBlockSyntax WithCaseStatement(CaseStatementSyntax caseStatement);
    public CaseBlockSyntax AddCaseStatementCases(CaseClauseSyntax[] items);
    public SyntaxList`1<StatementSyntax> get_Statements();
    public CaseBlockSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public CaseBlockSyntax AddStatements(StatementSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public CaseBlockSyntax Update(SyntaxKind kind, CaseStatementSyntax caseStatement, SyntaxList`1<StatementSyntax> statements);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseClauseSyntax : VisualBasicSyntaxNode {
    internal CaseClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.CaseStatementSyntax : StatementSyntax {
    internal SyntaxNode _cases;
    public SyntaxToken CaseKeyword { get; }
    public SeparatedSyntaxList`1<CaseClauseSyntax> Cases { get; }
    internal CaseStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal CaseStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax caseKeyword, SyntaxNode cases);
    public SyntaxToken get_CaseKeyword();
    public CaseStatementSyntax WithCaseKeyword(SyntaxToken caseKeyword);
    public SeparatedSyntaxList`1<CaseClauseSyntax> get_Cases();
    public CaseStatementSyntax WithCases(SeparatedSyntaxList`1<CaseClauseSyntax> cases);
    public CaseStatementSyntax AddCases(CaseClauseSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public CaseStatementSyntax Update(SyntaxKind kind, SyntaxToken caseKeyword, SeparatedSyntaxList`1<CaseClauseSyntax> cases);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.CastExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax _expression;
    internal TypeSyntax _type;
    public SyntaxToken Keyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CommaToken { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken CloseParenToken { get; }
    internal CastExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    public SyntaxToken get_Keyword();
    internal virtual SyntaxToken GetKeywordCore();
    public SyntaxToken get_OpenParenToken();
    internal virtual SyntaxToken GetOpenParenTokenCore();
    public ExpressionSyntax get_Expression();
    internal virtual ExpressionSyntax GetExpressionCore();
    public SyntaxToken get_CommaToken();
    internal virtual SyntaxToken GetCommaTokenCore();
    public TypeSyntax get_Type();
    internal virtual TypeSyntax GetTypeCore();
    public SyntaxToken get_CloseParenToken();
    internal virtual SyntaxToken GetCloseParenTokenCore();
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchBlockSyntax : VisualBasicSyntaxNode {
    internal CatchStatementSyntax _catchStatement;
    internal SyntaxNode _statements;
    public CatchStatementSyntax CatchStatement { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    internal CatchBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal CatchBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, CatchStatementSyntax catchStatement, SyntaxNode statements);
    public CatchStatementSyntax get_CatchStatement();
    public CatchBlockSyntax WithCatchStatement(CatchStatementSyntax catchStatement);
    public SyntaxList`1<StatementSyntax> get_Statements();
    public CatchBlockSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public CatchBlockSyntax AddStatements(StatementSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public CatchBlockSyntax Update(CatchStatementSyntax catchStatement, SyntaxList`1<StatementSyntax> statements);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchFilterClauseSyntax : VisualBasicSyntaxNode {
    internal ExpressionSyntax _filter;
    public SyntaxToken WhenKeyword { get; }
    public ExpressionSyntax Filter { get; }
    internal CatchFilterClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal CatchFilterClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax whenKeyword, ExpressionSyntax filter);
    public SyntaxToken get_WhenKeyword();
    public CatchFilterClauseSyntax WithWhenKeyword(SyntaxToken whenKeyword);
    public ExpressionSyntax get_Filter();
    public CatchFilterClauseSyntax WithFilter(ExpressionSyntax filter);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public CatchFilterClauseSyntax Update(SyntaxToken whenKeyword, ExpressionSyntax filter);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.CatchStatementSyntax : StatementSyntax {
    internal IdentifierNameSyntax _identifierName;
    internal SimpleAsClauseSyntax _asClause;
    internal CatchFilterClauseSyntax _whenClause;
    public SyntaxToken CatchKeyword { get; }
    public IdentifierNameSyntax IdentifierName { get; }
    public SimpleAsClauseSyntax AsClause { get; }
    public CatchFilterClauseSyntax WhenClause { get; }
    internal CatchStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal CatchStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax catchKeyword, IdentifierNameSyntax identifierName, SimpleAsClauseSyntax asClause, CatchFilterClauseSyntax whenClause);
    public SyntaxToken get_CatchKeyword();
    public CatchStatementSyntax WithCatchKeyword(SyntaxToken catchKeyword);
    public IdentifierNameSyntax get_IdentifierName();
    public CatchStatementSyntax WithIdentifierName(IdentifierNameSyntax identifierName);
    public SimpleAsClauseSyntax get_AsClause();
    public CatchStatementSyntax WithAsClause(SimpleAsClauseSyntax asClause);
    public CatchFilterClauseSyntax get_WhenClause();
    public CatchStatementSyntax WithWhenClause(CatchFilterClauseSyntax whenClause);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public CatchStatementSyntax Update(SyntaxToken catchKeyword, IdentifierNameSyntax identifierName, SimpleAsClauseSyntax asClause, CatchFilterClauseSyntax whenClause);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassBlockSyntax : TypeBlockSyntax {
    internal ClassStatementSyntax _classStatement;
    internal EndBlockStatementSyntax _endClassStatement;
    public TypeStatementSyntax BlockStatement { get; }
    public EndBlockStatementSyntax EndBlockStatement { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public ClassStatementSyntax Begin { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public EndBlockStatementSyntax End { get; }
    public ClassStatementSyntax ClassStatement { get; }
    public SyntaxList`1<InheritsStatementSyntax> Inherits { get; }
    public SyntaxList`1<ImplementsStatementSyntax> Implements { get; }
    public SyntaxList`1<StatementSyntax> Members { get; }
    public EndBlockStatementSyntax EndClassStatement { get; }
    internal ClassBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ClassBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ClassStatementSyntax classStatement, SyntaxNode inherits, SyntaxNode implements, SyntaxNode members, EndBlockStatementSyntax endClassStatement);
    public virtual TypeStatementSyntax get_BlockStatement();
    public virtual EndBlockStatementSyntax get_EndBlockStatement();
    public virtual TypeBlockSyntax WithBlockStatement(TypeStatementSyntax blockStatement);
    public virtual TypeBlockSyntax WithEndBlockStatement(EndBlockStatementSyntax endBlockStatement);
    public ClassStatementSyntax get_Begin();
    public EndBlockStatementSyntax get_End();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public ClassBlockSyntax WithBegin(ClassStatementSyntax begin);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public ClassBlockSyntax WithEnd(EndBlockStatementSyntax end);
    public ClassStatementSyntax get_ClassStatement();
    public ClassBlockSyntax WithClassStatement(ClassStatementSyntax classStatement);
    public SyntaxList`1<InheritsStatementSyntax> get_Inherits();
    internal virtual SyntaxList`1<InheritsStatementSyntax> GetInheritsCore();
    public ClassBlockSyntax WithInherits(SyntaxList`1<InheritsStatementSyntax> inherits);
    public ClassBlockSyntax AddInherits(InheritsStatementSyntax[] items);
    public SyntaxList`1<ImplementsStatementSyntax> get_Implements();
    internal virtual SyntaxList`1<ImplementsStatementSyntax> GetImplementsCore();
    public ClassBlockSyntax WithImplements(SyntaxList`1<ImplementsStatementSyntax> implements);
    public ClassBlockSyntax AddImplements(ImplementsStatementSyntax[] items);
    public SyntaxList`1<StatementSyntax> get_Members();
    internal virtual SyntaxList`1<StatementSyntax> GetMembersCore();
    public ClassBlockSyntax WithMembers(SyntaxList`1<StatementSyntax> members);
    public ClassBlockSyntax AddMembers(StatementSyntax[] items);
    public EndBlockStatementSyntax get_EndClassStatement();
    public ClassBlockSyntax WithEndClassStatement(EndBlockStatementSyntax endClassStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ClassBlockSyntax Update(ClassStatementSyntax classStatement, SyntaxList`1<InheritsStatementSyntax> inherits, SyntaxList`1<ImplementsStatementSyntax> implements, SyntaxList`1<StatementSyntax> members, EndBlockStatementSyntax endClassStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ClassStatementSyntax : TypeStatementSyntax {
    public SyntaxToken DeclarationKeyword { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public SyntaxToken Keyword { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken ClassKeyword { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    internal ClassStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ClassStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode attributeLists, GreenNode modifiers, KeywordSyntax classKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    public virtual SyntaxToken get_DeclarationKeyword();
    public virtual TypeStatementSyntax WithDeclarationKeyword(SyntaxToken keyword);
    public SyntaxToken get_Keyword();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public ClassStatementSyntax WithKeyword(SyntaxToken keyword);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual SyntaxList`1<AttributeListSyntax> GetAttributeListsCore();
    public ClassStatementSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public ClassStatementSyntax AddAttributeLists(AttributeListSyntax[] items);
    public SyntaxTokenList get_Modifiers();
    internal virtual SyntaxTokenList GetModifiersCore();
    public ClassStatementSyntax WithModifiers(SyntaxTokenList modifiers);
    public ClassStatementSyntax AddModifiers(SyntaxToken[] items);
    public SyntaxToken get_ClassKeyword();
    public ClassStatementSyntax WithClassKeyword(SyntaxToken classKeyword);
    public SyntaxToken get_Identifier();
    internal virtual SyntaxToken GetIdentifierCore();
    public ClassStatementSyntax WithIdentifier(SyntaxToken identifier);
    public TypeParameterListSyntax get_TypeParameterList();
    internal virtual TypeParameterListSyntax GetTypeParameterListCore();
    public ClassStatementSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList);
    public ClassStatementSyntax AddTypeParameterListParameters(TypeParameterSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ClassStatementSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken classKeyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionInitializerSyntax : ExpressionSyntax {
    internal SyntaxNode _initializers;
    public SyntaxToken OpenBraceToken { get; }
    public SeparatedSyntaxList`1<ExpressionSyntax> Initializers { get; }
    public SyntaxToken CloseBraceToken { get; }
    internal CollectionInitializerSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal CollectionInitializerSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax openBraceToken, SyntaxNode initializers, PunctuationSyntax closeBraceToken);
    public SyntaxToken get_OpenBraceToken();
    public CollectionInitializerSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
    public SeparatedSyntaxList`1<ExpressionSyntax> get_Initializers();
    public CollectionInitializerSyntax WithInitializers(SeparatedSyntaxList`1<ExpressionSyntax> initializers);
    public CollectionInitializerSyntax AddInitializers(ExpressionSyntax[] items);
    public SyntaxToken get_CloseBraceToken();
    public CollectionInitializerSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public CollectionInitializerSyntax Update(SyntaxToken openBraceToken, SeparatedSyntaxList`1<ExpressionSyntax> initializers, SyntaxToken closeBraceToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.CollectionRangeVariableSyntax : VisualBasicSyntaxNode {
    internal ModifiedIdentifierSyntax _identifier;
    internal SimpleAsClauseSyntax _asClause;
    internal ExpressionSyntax _expression;
    public ModifiedIdentifierSyntax Identifier { get; }
    public SimpleAsClauseSyntax AsClause { get; }
    public SyntaxToken InKeyword { get; }
    public ExpressionSyntax Expression { get; }
    internal CollectionRangeVariableSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal CollectionRangeVariableSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, KeywordSyntax inKeyword, ExpressionSyntax expression);
    public ModifiedIdentifierSyntax get_Identifier();
    public CollectionRangeVariableSyntax WithIdentifier(ModifiedIdentifierSyntax identifier);
    public SimpleAsClauseSyntax get_AsClause();
    public CollectionRangeVariableSyntax WithAsClause(SimpleAsClauseSyntax asClause);
    public SyntaxToken get_InKeyword();
    public CollectionRangeVariableSyntax WithInKeyword(SyntaxToken inKeyword);
    public ExpressionSyntax get_Expression();
    public CollectionRangeVariableSyntax WithExpression(ExpressionSyntax expression);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public CollectionRangeVariableSyntax Update(ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, SyntaxToken inKeyword, ExpressionSyntax expression);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax : VisualBasicSyntaxNode {
    internal SyntaxNode _options;
    internal SyntaxNode _imports;
    internal SyntaxNode _attributes;
    internal SyntaxNode _members;
    private SyntaxToken ICompilationUnitSyntax_EndOfFileToken { get; }
    public SyntaxList`1<OptionStatementSyntax> Options { get; }
    public SyntaxList`1<ImportsStatementSyntax> Imports { get; }
    public SyntaxList`1<AttributesStatementSyntax> Attributes { get; }
    public SyntaxList`1<StatementSyntax> Members { get; }
    public SyntaxToken EndOfFileToken { get; }
    internal CompilationUnitSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal CompilationUnitSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode options, SyntaxNode imports, SyntaxNode attributes, SyntaxNode members, PunctuationSyntax endOfFileToken);
    private sealed virtual override SyntaxToken get_ICompilationUnitSyntax_EndOfFileToken();
    public IList`1<ReferenceDirectiveTriviaSyntax> GetReferenceDirectives();
    internal IList`1<ReferenceDirectiveTriviaSyntax> GetReferenceDirectives(Func`2<ReferenceDirectiveTriviaSyntax, bool> filter);
    public SyntaxList`1<OptionStatementSyntax> get_Options();
    public CompilationUnitSyntax WithOptions(SyntaxList`1<OptionStatementSyntax> options);
    public CompilationUnitSyntax AddOptions(OptionStatementSyntax[] items);
    public SyntaxList`1<ImportsStatementSyntax> get_Imports();
    public CompilationUnitSyntax WithImports(SyntaxList`1<ImportsStatementSyntax> imports);
    public CompilationUnitSyntax AddImports(ImportsStatementSyntax[] items);
    public SyntaxList`1<AttributesStatementSyntax> get_Attributes();
    public CompilationUnitSyntax WithAttributes(SyntaxList`1<AttributesStatementSyntax> attributes);
    public CompilationUnitSyntax AddAttributes(AttributesStatementSyntax[] items);
    public SyntaxList`1<StatementSyntax> get_Members();
    public CompilationUnitSyntax WithMembers(SyntaxList`1<StatementSyntax> members);
    public CompilationUnitSyntax AddMembers(StatementSyntax[] items);
    public SyntaxToken get_EndOfFileToken();
    public CompilationUnitSyntax WithEndOfFileToken(SyntaxToken endOfFileToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public CompilationUnitSyntax Update(SyntaxList`1<OptionStatementSyntax> options, SyntaxList`1<ImportsStatementSyntax> imports, SyntaxList`1<AttributesStatementSyntax> attributes, SyntaxList`1<StatementSyntax> members, SyntaxToken endOfFileToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ConditionalAccessExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax _expression;
    internal ExpressionSyntax _whenNotNull;
    public ExpressionSyntax Expression { get; }
    public SyntaxToken QuestionMarkToken { get; }
    public ExpressionSyntax WhenNotNull { get; }
    internal ConditionalAccessExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ConditionalAccessExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax expression, PunctuationSyntax questionMarkToken, ExpressionSyntax whenNotNull);
    public ExpressionSyntax get_Expression();
    public ConditionalAccessExpressionSyntax WithExpression(ExpressionSyntax expression);
    public SyntaxToken get_QuestionMarkToken();
    public ConditionalAccessExpressionSyntax WithQuestionMarkToken(SyntaxToken questionMarkToken);
    public ExpressionSyntax get_WhenNotNull();
    public ConditionalAccessExpressionSyntax WithWhenNotNull(ExpressionSyntax whenNotNull);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ConditionalAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken questionMarkToken, ExpressionSyntax whenNotNull);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal ExpressionSyntax _value;
    public SyntaxToken HashToken { get; }
    public SyntaxToken ConstKeyword { get; }
    public SyntaxToken Name { get; }
    public SyntaxToken EqualsToken { get; }
    public ExpressionSyntax Value { get; }
    internal ConstDirectiveTriviaSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ConstDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax constKeyword, IdentifierTokenSyntax name, PunctuationSyntax equalsToken, ExpressionSyntax value);
    public SyntaxToken get_HashToken();
    internal virtual SyntaxToken GetHashTokenCore();
    public ConstDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public SyntaxToken get_ConstKeyword();
    public ConstDirectiveTriviaSyntax WithConstKeyword(SyntaxToken constKeyword);
    public SyntaxToken get_Name();
    public ConstDirectiveTriviaSyntax WithName(SyntaxToken name);
    public SyntaxToken get_EqualsToken();
    public ConstDirectiveTriviaSyntax WithEqualsToken(SyntaxToken equalsToken);
    public ExpressionSyntax get_Value();
    public ConstDirectiveTriviaSyntax WithValue(ExpressionSyntax value);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ConstDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken constKeyword, SyntaxToken name, SyntaxToken equalsToken, ExpressionSyntax value);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstraintSyntax : VisualBasicSyntaxNode {
    internal ConstraintSyntax(GreenNode green, SyntaxNode parent, int startLocation);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ConstructorBlockSyntax : MethodBlockBaseSyntax {
    internal SubNewStatementSyntax _subNewStatement;
    internal EndBlockStatementSyntax _endSubStatement;
    public MethodBaseSyntax BlockStatement { get; }
    public EndBlockStatementSyntax EndBlockStatement { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public SubNewStatementSyntax Begin { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public EndBlockStatementSyntax End { get; }
    public SubNewStatementSyntax SubNewStatement { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    public EndBlockStatementSyntax EndSubStatement { get; }
    internal ConstructorBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ConstructorBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SubNewStatementSyntax subNewStatement, SyntaxNode statements, EndBlockStatementSyntax endSubStatement);
    public virtual MethodBaseSyntax get_BlockStatement();
    public virtual EndBlockStatementSyntax get_EndBlockStatement();
    public virtual MethodBlockBaseSyntax WithBlockStatement(MethodBaseSyntax blockStatement);
    public virtual MethodBlockBaseSyntax WithEndBlockStatement(EndBlockStatementSyntax endBlockStatement);
    public SubNewStatementSyntax get_Begin();
    public EndBlockStatementSyntax get_End();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public ConstructorBlockSyntax WithBegin(SubNewStatementSyntax begin);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public ConstructorBlockSyntax WithEnd(EndBlockStatementSyntax end);
    public SubNewStatementSyntax get_SubNewStatement();
    public ConstructorBlockSyntax WithSubNewStatement(SubNewStatementSyntax subNewStatement);
    public SyntaxList`1<StatementSyntax> get_Statements();
    internal virtual SyntaxList`1<StatementSyntax> GetStatementsCore();
    public ConstructorBlockSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public ConstructorBlockSyntax AddStatements(StatementSyntax[] items);
    public EndBlockStatementSyntax get_EndSubStatement();
    public ConstructorBlockSyntax WithEndSubStatement(EndBlockStatementSyntax endSubStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ConstructorBlockSyntax Update(SubNewStatementSyntax subNewStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endSubStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ContinueStatementSyntax : ExecutableStatementSyntax {
    public SyntaxToken ContinueKeyword { get; }
    public SyntaxToken BlockKeyword { get; }
    internal ContinueStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ContinueStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax continueKeyword, KeywordSyntax blockKeyword);
    public SyntaxToken get_ContinueKeyword();
    public ContinueStatementSyntax WithContinueKeyword(SyntaxToken continueKeyword);
    public SyntaxToken get_BlockKeyword();
    public ContinueStatementSyntax WithBlockKeyword(SyntaxToken blockKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ContinueStatementSyntax Update(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken blockKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefOperatorReferenceSyntax : NameSyntax {
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use OperatorKeyword or a more specific property (e.g. OperatorKeyword) instead.", "True")]
public SyntaxToken Keyword { get; }
    public SyntaxToken OperatorKeyword { get; }
    public SyntaxToken OperatorToken { get; }
    internal CrefOperatorReferenceSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal CrefOperatorReferenceSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax operatorKeyword, SyntaxToken operatorToken);
    public SyntaxToken get_Keyword();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use OperatorKeyword or a more specific property (e.g. WithOperatorKeyword) instead.", "True")]
public CrefOperatorReferenceSyntax WithKeyword(SyntaxToken keyword);
    public SyntaxToken get_OperatorKeyword();
    public CrefOperatorReferenceSyntax WithOperatorKeyword(SyntaxToken operatorKeyword);
    public SyntaxToken get_OperatorToken();
    public CrefOperatorReferenceSyntax WithOperatorToken(SyntaxToken operatorToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public CrefOperatorReferenceSyntax Update(SyntaxToken operatorKeyword, SyntaxToken operatorToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefReferenceSyntax : VisualBasicSyntaxNode {
    internal TypeSyntax _name;
    internal CrefSignatureSyntax _signature;
    internal SimpleAsClauseSyntax _asClause;
    public TypeSyntax Name { get; }
    public CrefSignatureSyntax Signature { get; }
    public SimpleAsClauseSyntax AsClause { get; }
    internal CrefReferenceSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal CrefReferenceSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, TypeSyntax name, CrefSignatureSyntax signature, SimpleAsClauseSyntax asClause);
    public TypeSyntax get_Name();
    public CrefReferenceSyntax WithName(TypeSyntax name);
    public CrefSignatureSyntax get_Signature();
    public CrefReferenceSyntax WithSignature(CrefSignatureSyntax signature);
    public CrefReferenceSyntax AddSignatureArgumentTypes(CrefSignaturePartSyntax[] items);
    public SimpleAsClauseSyntax get_AsClause();
    public CrefReferenceSyntax WithAsClause(SimpleAsClauseSyntax asClause);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public CrefReferenceSyntax Update(TypeSyntax name, CrefSignatureSyntax signature, SimpleAsClauseSyntax asClause);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignaturePartSyntax : VisualBasicSyntaxNode {
    internal TypeSyntax _type;
    public SyntaxToken Modifier { get; }
    public TypeSyntax Type { get; }
    internal CrefSignaturePartSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal CrefSignaturePartSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax modifier, TypeSyntax type);
    public SyntaxToken get_Modifier();
    public CrefSignaturePartSyntax WithModifier(SyntaxToken modifier);
    public TypeSyntax get_Type();
    public CrefSignaturePartSyntax WithType(TypeSyntax type);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public CrefSignaturePartSyntax Update(SyntaxToken modifier, TypeSyntax type);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.CrefSignatureSyntax : VisualBasicSyntaxNode {
    internal SyntaxNode _argumentTypes;
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxList`1<CrefSignaturePartSyntax> ArgumentTypes { get; }
    public SyntaxToken CloseParenToken { get; }
    internal CrefSignatureSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal CrefSignatureSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax openParenToken, SyntaxNode argumentTypes, PunctuationSyntax closeParenToken);
    public SyntaxToken get_OpenParenToken();
    public CrefSignatureSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public SeparatedSyntaxList`1<CrefSignaturePartSyntax> get_ArgumentTypes();
    public CrefSignatureSyntax WithArgumentTypes(SeparatedSyntaxList`1<CrefSignaturePartSyntax> argumentTypes);
    public CrefSignatureSyntax AddArgumentTypes(CrefSignaturePartSyntax[] items);
    public SyntaxToken get_CloseParenToken();
    public CrefSignatureSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public CrefSignatureSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList`1<CrefSignaturePartSyntax> argumentTypes, SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.CTypeExpressionSyntax : CastExpressionSyntax {
    public SyntaxToken Keyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CommaToken { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken CloseParenToken { get; }
    internal CTypeExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal CTypeExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    public SyntaxToken get_Keyword();
    internal virtual SyntaxToken GetKeywordCore();
    public CTypeExpressionSyntax WithKeyword(SyntaxToken keyword);
    public SyntaxToken get_OpenParenToken();
    internal virtual SyntaxToken GetOpenParenTokenCore();
    public CTypeExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public ExpressionSyntax get_Expression();
    internal virtual ExpressionSyntax GetExpressionCore();
    public CTypeExpressionSyntax WithExpression(ExpressionSyntax expression);
    public SyntaxToken get_CommaToken();
    internal virtual SyntaxToken GetCommaTokenCore();
    public CTypeExpressionSyntax WithCommaToken(SyntaxToken commaToken);
    public TypeSyntax get_Type();
    internal virtual TypeSyntax GetTypeCore();
    public CTypeExpressionSyntax WithType(TypeSyntax type);
    public SyntaxToken get_CloseParenToken();
    internal virtual SyntaxToken GetCloseParenTokenCore();
    public CTypeExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public CTypeExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken commaToken, TypeSyntax type, SyntaxToken closeParenToken);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclarationStatementSyntax : StatementSyntax {
    internal DeclarationStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.DeclareStatementSyntax : MethodBaseSyntax {
    internal LiteralExpressionSyntax _libraryName;
    internal LiteralExpressionSyntax _aliasName;
    internal SimpleAsClauseSyntax _asClause;
    public SyntaxToken DeclarationKeyword { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public SyntaxToken Keyword { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken DeclareKeyword { get; }
    public SyntaxToken CharsetKeyword { get; }
    public SyntaxToken SubOrFunctionKeyword { get; }
    public SyntaxToken Identifier { get; }
    public SyntaxToken LibKeyword { get; }
    public LiteralExpressionSyntax LibraryName { get; }
    public SyntaxToken AliasKeyword { get; }
    public LiteralExpressionSyntax AliasName { get; }
    public ParameterListSyntax ParameterList { get; }
    public SimpleAsClauseSyntax AsClause { get; }
    internal DeclareStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal DeclareStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode attributeLists, GreenNode modifiers, KeywordSyntax declareKeyword, KeywordSyntax charsetKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, KeywordSyntax libKeyword, LiteralExpressionSyntax libraryName, KeywordSyntax aliasKeyword, LiteralExpressionSyntax aliasName, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public virtual SyntaxToken get_DeclarationKeyword();
    public virtual MethodBaseSyntax WithDeclarationKeyword(SyntaxToken keyword);
    public SyntaxToken get_Keyword();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public DeclareStatementSyntax WithKeyword(SyntaxToken keyword);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual SyntaxList`1<AttributeListSyntax> GetAttributeListsCore();
    public DeclareStatementSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public DeclareStatementSyntax AddAttributeLists(AttributeListSyntax[] items);
    public SyntaxTokenList get_Modifiers();
    internal virtual SyntaxTokenList GetModifiersCore();
    public DeclareStatementSyntax WithModifiers(SyntaxTokenList modifiers);
    public DeclareStatementSyntax AddModifiers(SyntaxToken[] items);
    public SyntaxToken get_DeclareKeyword();
    public DeclareStatementSyntax WithDeclareKeyword(SyntaxToken declareKeyword);
    public SyntaxToken get_CharsetKeyword();
    public DeclareStatementSyntax WithCharsetKeyword(SyntaxToken charsetKeyword);
    public SyntaxToken get_SubOrFunctionKeyword();
    public DeclareStatementSyntax WithSubOrFunctionKeyword(SyntaxToken subOrFunctionKeyword);
    public SyntaxToken get_Identifier();
    public DeclareStatementSyntax WithIdentifier(SyntaxToken identifier);
    public SyntaxToken get_LibKeyword();
    public DeclareStatementSyntax WithLibKeyword(SyntaxToken libKeyword);
    public LiteralExpressionSyntax get_LibraryName();
    public DeclareStatementSyntax WithLibraryName(LiteralExpressionSyntax libraryName);
    public SyntaxToken get_AliasKeyword();
    public DeclareStatementSyntax WithAliasKeyword(SyntaxToken aliasKeyword);
    public LiteralExpressionSyntax get_AliasName();
    public DeclareStatementSyntax WithAliasName(LiteralExpressionSyntax aliasName);
    public ParameterListSyntax get_ParameterList();
    internal virtual ParameterListSyntax GetParameterListCore();
    public DeclareStatementSyntax WithParameterList(ParameterListSyntax parameterList);
    public DeclareStatementSyntax AddParameterListParameters(ParameterSyntax[] items);
    public SimpleAsClauseSyntax get_AsClause();
    public DeclareStatementSyntax WithAsClause(SimpleAsClauseSyntax asClause);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public DeclareStatementSyntax Update(SyntaxKind kind, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken declareKeyword, SyntaxToken charsetKeyword, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, SyntaxToken libKeyword, LiteralExpressionSyntax libraryName, SyntaxToken aliasKeyword, LiteralExpressionSyntax aliasName, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.DelegateStatementSyntax : MethodBaseSyntax {
    internal TypeParameterListSyntax _typeParameterList;
    internal SimpleAsClauseSyntax _asClause;
    public SyntaxToken DeclarationKeyword { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public SyntaxToken Keyword { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken DelegateKeyword { get; }
    public SyntaxToken SubOrFunctionKeyword { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public ParameterListSyntax ParameterList { get; }
    public SimpleAsClauseSyntax AsClause { get; }
    internal DelegateStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal DelegateStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode attributeLists, GreenNode modifiers, KeywordSyntax delegateKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public virtual SyntaxToken get_DeclarationKeyword();
    public virtual MethodBaseSyntax WithDeclarationKeyword(SyntaxToken keyword);
    public SyntaxToken get_Keyword();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public DelegateStatementSyntax WithKeyword(SyntaxToken keyword);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual SyntaxList`1<AttributeListSyntax> GetAttributeListsCore();
    public DelegateStatementSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public DelegateStatementSyntax AddAttributeLists(AttributeListSyntax[] items);
    public SyntaxTokenList get_Modifiers();
    internal virtual SyntaxTokenList GetModifiersCore();
    public DelegateStatementSyntax WithModifiers(SyntaxTokenList modifiers);
    public DelegateStatementSyntax AddModifiers(SyntaxToken[] items);
    public SyntaxToken get_DelegateKeyword();
    public DelegateStatementSyntax WithDelegateKeyword(SyntaxToken delegateKeyword);
    public SyntaxToken get_SubOrFunctionKeyword();
    public DelegateStatementSyntax WithSubOrFunctionKeyword(SyntaxToken subOrFunctionKeyword);
    public SyntaxToken get_Identifier();
    public DelegateStatementSyntax WithIdentifier(SyntaxToken identifier);
    public TypeParameterListSyntax get_TypeParameterList();
    public DelegateStatementSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList);
    public DelegateStatementSyntax AddTypeParameterListParameters(TypeParameterSyntax[] items);
    public ParameterListSyntax get_ParameterList();
    internal virtual ParameterListSyntax GetParameterListCore();
    public DelegateStatementSyntax WithParameterList(ParameterListSyntax parameterList);
    public DelegateStatementSyntax AddParameterListParameters(ParameterSyntax[] items);
    public SimpleAsClauseSyntax get_AsClause();
    public DelegateStatementSyntax WithAsClause(SimpleAsClauseSyntax asClause);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public DelegateStatementSyntax Update(SyntaxKind kind, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectCastExpressionSyntax : CastExpressionSyntax {
    public SyntaxToken Keyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CommaToken { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken CloseParenToken { get; }
    internal DirectCastExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal DirectCastExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    public SyntaxToken get_Keyword();
    internal virtual SyntaxToken GetKeywordCore();
    public DirectCastExpressionSyntax WithKeyword(SyntaxToken keyword);
    public SyntaxToken get_OpenParenToken();
    internal virtual SyntaxToken GetOpenParenTokenCore();
    public DirectCastExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public ExpressionSyntax get_Expression();
    internal virtual ExpressionSyntax GetExpressionCore();
    public DirectCastExpressionSyntax WithExpression(ExpressionSyntax expression);
    public SyntaxToken get_CommaToken();
    internal virtual SyntaxToken GetCommaTokenCore();
    public DirectCastExpressionSyntax WithCommaToken(SyntaxToken commaToken);
    public TypeSyntax get_Type();
    internal virtual TypeSyntax GetTypeCore();
    public DirectCastExpressionSyntax WithType(TypeSyntax type);
    public SyntaxToken get_CloseParenToken();
    internal virtual SyntaxToken GetCloseParenTokenCore();
    public DirectCastExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public DirectCastExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken commaToken, TypeSyntax type, SyntaxToken closeParenToken);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.DirectiveTriviaSyntax : StructuredTriviaSyntax {
    private static Func`2<SyntaxToken, bool> s_hasDirectivesFunction;
    public SyntaxToken HashToken { get; }
    private static DirectiveTriviaSyntax();
    internal DirectiveTriviaSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    public List`1<DirectiveTriviaSyntax> GetRelatedDirectives();
    private void GetRelatedDirectives(List`1<DirectiveTriviaSyntax> list);
    private DirectiveTriviaSyntax GetNextRelatedDirective();
    private DirectiveTriviaSyntax GetNextPossiblyRelatedDirective();
    private DirectiveTriviaSyntax GetPreviousRelatedDirective();
    private DirectiveTriviaSyntax GetPreviousPossiblyRelatedDirective();
    public DirectiveTriviaSyntax GetNextDirective(Func`2<DirectiveTriviaSyntax, bool> predicate);
    public DirectiveTriviaSyntax GetPreviousDirective(Func`2<DirectiveTriviaSyntax, bool> predicate);
    public SyntaxToken get_HashToken();
    internal virtual SyntaxToken GetHashTokenCore();
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.DisableWarningDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal SyntaxNode _errorCodes;
    public SyntaxToken HashToken { get; }
    public SyntaxToken DisableKeyword { get; }
    public SyntaxToken WarningKeyword { get; }
    public SeparatedSyntaxList`1<IdentifierNameSyntax> ErrorCodes { get; }
    internal DisableWarningDirectiveTriviaSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal DisableWarningDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax disableKeyword, KeywordSyntax warningKeyword, SyntaxNode errorCodes);
    public SyntaxToken get_HashToken();
    internal virtual SyntaxToken GetHashTokenCore();
    public DisableWarningDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public SyntaxToken get_DisableKeyword();
    public DisableWarningDirectiveTriviaSyntax WithDisableKeyword(SyntaxToken disableKeyword);
    public SyntaxToken get_WarningKeyword();
    public DisableWarningDirectiveTriviaSyntax WithWarningKeyword(SyntaxToken warningKeyword);
    public SeparatedSyntaxList`1<IdentifierNameSyntax> get_ErrorCodes();
    public DisableWarningDirectiveTriviaSyntax WithErrorCodes(SeparatedSyntaxList`1<IdentifierNameSyntax> errorCodes);
    public DisableWarningDirectiveTriviaSyntax AddErrorCodes(IdentifierNameSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public DisableWarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken disableKeyword, SyntaxToken warningKeyword, SeparatedSyntaxList`1<IdentifierNameSyntax> errorCodes);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.DistinctClauseSyntax : QueryClauseSyntax {
    public SyntaxToken DistinctKeyword { get; }
    internal DistinctClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal DistinctClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax distinctKeyword);
    public SyntaxToken get_DistinctKeyword();
    public DistinctClauseSyntax WithDistinctKeyword(SyntaxToken distinctKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public DistinctClauseSyntax Update(SyntaxToken distinctKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.DocumentationCommentTriviaSyntax : StructuredTriviaSyntax {
    internal SyntaxNode _content;
    public SyntaxList`1<XmlNodeSyntax> Content { get; }
    internal DocumentationCommentTriviaSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal DocumentationCommentTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode content);
    internal string GetInteriorXml();
    public SyntaxList`1<XmlNodeSyntax> get_Content();
    public DocumentationCommentTriviaSyntax WithContent(SyntaxList`1<XmlNodeSyntax> content);
    public DocumentationCommentTriviaSyntax AddContent(XmlNodeSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public DocumentationCommentTriviaSyntax Update(SyntaxList`1<XmlNodeSyntax> content);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.DoLoopBlockSyntax : ExecutableStatementSyntax {
    internal DoStatementSyntax _doStatement;
    internal SyntaxNode _statements;
    internal LoopStatementSyntax _loopStatement;
    public DoStatementSyntax DoStatement { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    public LoopStatementSyntax LoopStatement { get; }
    internal DoLoopBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal DoLoopBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, DoStatementSyntax doStatement, SyntaxNode statements, LoopStatementSyntax loopStatement);
    public DoStatementSyntax get_DoStatement();
    public DoLoopBlockSyntax WithDoStatement(DoStatementSyntax doStatement);
    public SyntaxList`1<StatementSyntax> get_Statements();
    public DoLoopBlockSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public DoLoopBlockSyntax AddStatements(StatementSyntax[] items);
    public LoopStatementSyntax get_LoopStatement();
    public DoLoopBlockSyntax WithLoopStatement(LoopStatementSyntax loopStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public DoLoopBlockSyntax Update(SyntaxKind kind, DoStatementSyntax doStatement, SyntaxList`1<StatementSyntax> statements, LoopStatementSyntax loopStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.DoStatementSyntax : StatementSyntax {
    internal WhileOrUntilClauseSyntax _whileOrUntilClause;
    public SyntaxToken DoKeyword { get; }
    public WhileOrUntilClauseSyntax WhileOrUntilClause { get; }
    internal DoStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal DoStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax doKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    public SyntaxToken get_DoKeyword();
    public DoStatementSyntax WithDoKeyword(SyntaxToken doKeyword);
    public WhileOrUntilClauseSyntax get_WhileOrUntilClause();
    public DoStatementSyntax WithWhileOrUntilClause(WhileOrUntilClauseSyntax whileOrUntilClause);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public DoStatementSyntax Update(SyntaxKind kind, SyntaxToken doKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseBlockSyntax : VisualBasicSyntaxNode {
    internal ElseStatementSyntax _elseStatement;
    internal SyntaxNode _statements;
    public ElseStatementSyntax ElseStatement { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    internal ElseBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ElseBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ElseStatementSyntax elseStatement, SyntaxNode statements);
    public ElseStatementSyntax get_ElseStatement();
    public ElseBlockSyntax WithElseStatement(ElseStatementSyntax elseStatement);
    public SyntaxList`1<StatementSyntax> get_Statements();
    public ElseBlockSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public ElseBlockSyntax AddStatements(StatementSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ElseBlockSyntax Update(ElseStatementSyntax elseStatement, SyntaxList`1<StatementSyntax> statements);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseCaseClauseSyntax : CaseClauseSyntax {
    public SyntaxToken ElseKeyword { get; }
    internal ElseCaseClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ElseCaseClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax elseKeyword);
    public SyntaxToken get_ElseKeyword();
    public ElseCaseClauseSyntax WithElseKeyword(SyntaxToken elseKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ElseCaseClauseSyntax Update(SyntaxToken elseKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken ElseKeyword { get; }
    internal ElseDirectiveTriviaSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ElseDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax elseKeyword);
    public SyntaxToken get_HashToken();
    internal virtual SyntaxToken GetHashTokenCore();
    public ElseDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public SyntaxToken get_ElseKeyword();
    public ElseDirectiveTriviaSyntax WithElseKeyword(SyntaxToken elseKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ElseDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elseKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfBlockSyntax : VisualBasicSyntaxNode {
    internal ElseIfStatementSyntax _elseIfStatement;
    internal SyntaxNode _statements;
    public ElseIfStatementSyntax ElseIfStatement { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    internal ElseIfBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ElseIfBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ElseIfStatementSyntax elseIfStatement, SyntaxNode statements);
    public ElseIfStatementSyntax get_ElseIfStatement();
    public ElseIfBlockSyntax WithElseIfStatement(ElseIfStatementSyntax elseIfStatement);
    public SyntaxList`1<StatementSyntax> get_Statements();
    public ElseIfBlockSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public ElseIfBlockSyntax AddStatements(StatementSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ElseIfBlockSyntax Update(ElseIfStatementSyntax elseIfStatement, SyntaxList`1<StatementSyntax> statements);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseIfStatementSyntax : StatementSyntax {
    internal ExpressionSyntax _condition;
    public SyntaxToken ElseIfKeyword { get; }
    public ExpressionSyntax Condition { get; }
    public SyntaxToken ThenKeyword { get; }
    internal ElseIfStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ElseIfStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax elseIfKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    public SyntaxToken get_ElseIfKeyword();
    public ElseIfStatementSyntax WithElseIfKeyword(SyntaxToken elseIfKeyword);
    public ExpressionSyntax get_Condition();
    public ElseIfStatementSyntax WithCondition(ExpressionSyntax condition);
    public SyntaxToken get_ThenKeyword();
    public ElseIfStatementSyntax WithThenKeyword(SyntaxToken thenKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ElseIfStatementSyntax Update(SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ElseStatementSyntax : StatementSyntax {
    public SyntaxToken ElseKeyword { get; }
    internal ElseStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ElseStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax elseKeyword);
    public SyntaxToken get_ElseKeyword();
    public ElseStatementSyntax WithElseKeyword(SyntaxToken elseKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ElseStatementSyntax Update(SyntaxToken elseKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.EmptyStatementSyntax : StatementSyntax {
    public SyntaxToken Empty { get; }
    internal EmptyStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal EmptyStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax empty);
    public SyntaxToken get_Empty();
    public EmptyStatementSyntax WithEmpty(SyntaxToken empty);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public EmptyStatementSyntax Update(SyntaxToken empty);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.EnableWarningDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal SyntaxNode _errorCodes;
    public SyntaxToken HashToken { get; }
    public SyntaxToken EnableKeyword { get; }
    public SyntaxToken WarningKeyword { get; }
    public SeparatedSyntaxList`1<IdentifierNameSyntax> ErrorCodes { get; }
    internal EnableWarningDirectiveTriviaSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal EnableWarningDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax enableKeyword, KeywordSyntax warningKeyword, SyntaxNode errorCodes);
    public SyntaxToken get_HashToken();
    internal virtual SyntaxToken GetHashTokenCore();
    public EnableWarningDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public SyntaxToken get_EnableKeyword();
    public EnableWarningDirectiveTriviaSyntax WithEnableKeyword(SyntaxToken enableKeyword);
    public SyntaxToken get_WarningKeyword();
    public EnableWarningDirectiveTriviaSyntax WithWarningKeyword(SyntaxToken warningKeyword);
    public SeparatedSyntaxList`1<IdentifierNameSyntax> get_ErrorCodes();
    public EnableWarningDirectiveTriviaSyntax WithErrorCodes(SeparatedSyntaxList`1<IdentifierNameSyntax> errorCodes);
    public EnableWarningDirectiveTriviaSyntax AddErrorCodes(IdentifierNameSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public EnableWarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken enableKeyword, SyntaxToken warningKeyword, SeparatedSyntaxList`1<IdentifierNameSyntax> errorCodes);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.EndBlockStatementSyntax : DeclarationStatementSyntax {
    public SyntaxToken EndKeyword { get; }
    public SyntaxToken BlockKeyword { get; }
    internal EndBlockStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal EndBlockStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    public SyntaxToken get_EndKeyword();
    public EndBlockStatementSyntax WithEndKeyword(SyntaxToken endKeyword);
    public SyntaxToken get_BlockKeyword();
    public EndBlockStatementSyntax WithBlockKeyword(SyntaxToken blockKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public EndBlockStatementSyntax Update(SyntaxKind kind, SyntaxToken endKeyword, SyntaxToken blockKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.EndExternalSourceDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken EndKeyword { get; }
    public SyntaxToken ExternalSourceKeyword { get; }
    internal EndExternalSourceDirectiveTriviaSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal EndExternalSourceDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax endKeyword, KeywordSyntax externalSourceKeyword);
    public SyntaxToken get_HashToken();
    internal virtual SyntaxToken GetHashTokenCore();
    public EndExternalSourceDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public SyntaxToken get_EndKeyword();
    public EndExternalSourceDirectiveTriviaSyntax WithEndKeyword(SyntaxToken endKeyword);
    public SyntaxToken get_ExternalSourceKeyword();
    public EndExternalSourceDirectiveTriviaSyntax WithExternalSourceKeyword(SyntaxToken externalSourceKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public EndExternalSourceDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endKeyword, SyntaxToken externalSourceKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.EndIfDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken EndKeyword { get; }
    public SyntaxToken IfKeyword { get; }
    internal EndIfDirectiveTriviaSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal EndIfDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax endKeyword, KeywordSyntax ifKeyword);
    public SyntaxToken get_HashToken();
    internal virtual SyntaxToken GetHashTokenCore();
    public EndIfDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public SyntaxToken get_EndKeyword();
    public EndIfDirectiveTriviaSyntax WithEndKeyword(SyntaxToken endKeyword);
    public SyntaxToken get_IfKeyword();
    public EndIfDirectiveTriviaSyntax WithIfKeyword(SyntaxToken ifKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public EndIfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endKeyword, SyntaxToken ifKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.EndRegionDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken EndKeyword { get; }
    public SyntaxToken RegionKeyword { get; }
    internal EndRegionDirectiveTriviaSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal EndRegionDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax endKeyword, KeywordSyntax regionKeyword);
    public SyntaxToken get_HashToken();
    internal virtual SyntaxToken GetHashTokenCore();
    public EndRegionDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public SyntaxToken get_EndKeyword();
    public EndRegionDirectiveTriviaSyntax WithEndKeyword(SyntaxToken endKeyword);
    public SyntaxToken get_RegionKeyword();
    public EndRegionDirectiveTriviaSyntax WithRegionKeyword(SyntaxToken regionKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public EndRegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endKeyword, SyntaxToken regionKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumBlockSyntax : DeclarationStatementSyntax {
    internal EnumStatementSyntax _enumStatement;
    internal SyntaxNode _members;
    internal EndBlockStatementSyntax _endEnumStatement;
    public EnumStatementSyntax EnumStatement { get; }
    public SyntaxList`1<StatementSyntax> Members { get; }
    public EndBlockStatementSyntax EndEnumStatement { get; }
    internal EnumBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal EnumBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, EnumStatementSyntax enumStatement, SyntaxNode members, EndBlockStatementSyntax endEnumStatement);
    public EnumStatementSyntax get_EnumStatement();
    public EnumBlockSyntax WithEnumStatement(EnumStatementSyntax enumStatement);
    public SyntaxList`1<StatementSyntax> get_Members();
    public EnumBlockSyntax WithMembers(SyntaxList`1<StatementSyntax> members);
    public EnumBlockSyntax AddMembers(StatementSyntax[] items);
    public EndBlockStatementSyntax get_EndEnumStatement();
    public EnumBlockSyntax WithEndEnumStatement(EndBlockStatementSyntax endEnumStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public EnumBlockSyntax Update(EnumStatementSyntax enumStatement, SyntaxList`1<StatementSyntax> members, EndBlockStatementSyntax endEnumStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumMemberDeclarationSyntax : DeclarationStatementSyntax {
    internal SyntaxNode _attributeLists;
    internal EqualsValueSyntax _initializer;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxToken Identifier { get; }
    public EqualsValueSyntax Initializer { get; }
    internal EnumMemberDeclarationSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal EnumMemberDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode attributeLists, IdentifierTokenSyntax identifier, EqualsValueSyntax initializer);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public EnumMemberDeclarationSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public EnumMemberDeclarationSyntax AddAttributeLists(AttributeListSyntax[] items);
    public SyntaxToken get_Identifier();
    public EnumMemberDeclarationSyntax WithIdentifier(SyntaxToken identifier);
    public EqualsValueSyntax get_Initializer();
    public EnumMemberDeclarationSyntax WithInitializer(EqualsValueSyntax initializer);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public EnumMemberDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueSyntax initializer);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.EnumStatementSyntax : DeclarationStatementSyntax {
    internal SyntaxNode _attributeLists;
    internal AsClauseSyntax _underlyingType;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken EnumKeyword { get; }
    public SyntaxToken Identifier { get; }
    public AsClauseSyntax UnderlyingType { get; }
    internal EnumStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal EnumStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode attributeLists, GreenNode modifiers, KeywordSyntax enumKeyword, IdentifierTokenSyntax identifier, AsClauseSyntax underlyingType);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public EnumStatementSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public EnumStatementSyntax AddAttributeLists(AttributeListSyntax[] items);
    public SyntaxTokenList get_Modifiers();
    public EnumStatementSyntax WithModifiers(SyntaxTokenList modifiers);
    public EnumStatementSyntax AddModifiers(SyntaxToken[] items);
    public SyntaxToken get_EnumKeyword();
    public EnumStatementSyntax WithEnumKeyword(SyntaxToken enumKeyword);
    public SyntaxToken get_Identifier();
    public EnumStatementSyntax WithIdentifier(SyntaxToken identifier);
    public AsClauseSyntax get_UnderlyingType();
    public EnumStatementSyntax WithUnderlyingType(AsClauseSyntax underlyingType);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public EnumStatementSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, AsClauseSyntax underlyingType);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.EqualsValueSyntax : VisualBasicSyntaxNode {
    internal ExpressionSyntax _value;
    public SyntaxToken EqualsToken { get; }
    public ExpressionSyntax Value { get; }
    internal EqualsValueSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal EqualsValueSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax equalsToken, ExpressionSyntax value);
    public SyntaxToken get_EqualsToken();
    public EqualsValueSyntax WithEqualsToken(SyntaxToken equalsToken);
    public ExpressionSyntax get_Value();
    public EqualsValueSyntax WithValue(ExpressionSyntax value);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public EqualsValueSyntax Update(SyntaxToken equalsToken, ExpressionSyntax value);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.EraseStatementSyntax : ExecutableStatementSyntax {
    internal SyntaxNode _expressions;
    public SyntaxToken EraseKeyword { get; }
    public SeparatedSyntaxList`1<ExpressionSyntax> Expressions { get; }
    internal EraseStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal EraseStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax eraseKeyword, SyntaxNode expressions);
    public SyntaxToken get_EraseKeyword();
    public EraseStatementSyntax WithEraseKeyword(SyntaxToken eraseKeyword);
    public SeparatedSyntaxList`1<ExpressionSyntax> get_Expressions();
    public EraseStatementSyntax WithExpressions(SeparatedSyntaxList`1<ExpressionSyntax> expressions);
    public EraseStatementSyntax AddExpressions(ExpressionSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public EraseStatementSyntax Update(SyntaxToken eraseKeyword, SeparatedSyntaxList`1<ExpressionSyntax> expressions);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ErrorStatementSyntax : ExecutableStatementSyntax {
    internal ExpressionSyntax _errorNumber;
    public SyntaxToken ErrorKeyword { get; }
    public ExpressionSyntax ErrorNumber { get; }
    internal ErrorStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ErrorStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax errorKeyword, ExpressionSyntax errorNumber);
    public SyntaxToken get_ErrorKeyword();
    public ErrorStatementSyntax WithErrorKeyword(SyntaxToken errorKeyword);
    public ExpressionSyntax get_ErrorNumber();
    public ErrorStatementSyntax WithErrorNumber(ExpressionSyntax errorNumber);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ErrorStatementSyntax Update(SyntaxToken errorKeyword, ExpressionSyntax errorNumber);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.EventBlockSyntax : DeclarationStatementSyntax {
    internal EventStatementSyntax _eventStatement;
    internal SyntaxNode _accessors;
    internal EndBlockStatementSyntax _endEventStatement;
    public EventStatementSyntax EventStatement { get; }
    public SyntaxList`1<AccessorBlockSyntax> Accessors { get; }
    public EndBlockStatementSyntax EndEventStatement { get; }
    internal EventBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal EventBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, EventStatementSyntax eventStatement, SyntaxNode accessors, EndBlockStatementSyntax endEventStatement);
    public EventStatementSyntax get_EventStatement();
    public EventBlockSyntax WithEventStatement(EventStatementSyntax eventStatement);
    public SyntaxList`1<AccessorBlockSyntax> get_Accessors();
    public EventBlockSyntax WithAccessors(SyntaxList`1<AccessorBlockSyntax> accessors);
    public EventBlockSyntax AddAccessors(AccessorBlockSyntax[] items);
    public EndBlockStatementSyntax get_EndEventStatement();
    public EventBlockSyntax WithEndEventStatement(EndBlockStatementSyntax endEventStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public EventBlockSyntax Update(EventStatementSyntax eventStatement, SyntaxList`1<AccessorBlockSyntax> accessors, EndBlockStatementSyntax endEventStatement);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.EventContainerSyntax : ExpressionSyntax {
    internal EventContainerSyntax(GreenNode green, SyntaxNode parent, int startLocation);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.EventStatementSyntax : MethodBaseSyntax {
    internal SimpleAsClauseSyntax _asClause;
    internal ImplementsClauseSyntax _implementsClause;
    public SyntaxToken DeclarationKeyword { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public SyntaxToken Keyword { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken CustomKeyword { get; }
    public SyntaxToken EventKeyword { get; }
    public SyntaxToken Identifier { get; }
    public ParameterListSyntax ParameterList { get; }
    public SimpleAsClauseSyntax AsClause { get; }
    public ImplementsClauseSyntax ImplementsClause { get; }
    internal EventStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal EventStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode attributeLists, GreenNode modifiers, KeywordSyntax customKeyword, KeywordSyntax eventKeyword, IdentifierTokenSyntax identifier, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, ImplementsClauseSyntax implementsClause);
    public virtual SyntaxToken get_DeclarationKeyword();
    public virtual MethodBaseSyntax WithDeclarationKeyword(SyntaxToken keyword);
    public SyntaxToken get_Keyword();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public EventStatementSyntax WithKeyword(SyntaxToken keyword);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual SyntaxList`1<AttributeListSyntax> GetAttributeListsCore();
    public EventStatementSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public EventStatementSyntax AddAttributeLists(AttributeListSyntax[] items);
    public SyntaxTokenList get_Modifiers();
    internal virtual SyntaxTokenList GetModifiersCore();
    public EventStatementSyntax WithModifiers(SyntaxTokenList modifiers);
    public EventStatementSyntax AddModifiers(SyntaxToken[] items);
    public SyntaxToken get_CustomKeyword();
    public EventStatementSyntax WithCustomKeyword(SyntaxToken customKeyword);
    public SyntaxToken get_EventKeyword();
    public EventStatementSyntax WithEventKeyword(SyntaxToken eventKeyword);
    public SyntaxToken get_Identifier();
    public EventStatementSyntax WithIdentifier(SyntaxToken identifier);
    public ParameterListSyntax get_ParameterList();
    internal virtual ParameterListSyntax GetParameterListCore();
    public EventStatementSyntax WithParameterList(ParameterListSyntax parameterList);
    public EventStatementSyntax AddParameterListParameters(ParameterSyntax[] items);
    public SimpleAsClauseSyntax get_AsClause();
    public EventStatementSyntax WithAsClause(SimpleAsClauseSyntax asClause);
    public ImplementsClauseSyntax get_ImplementsClause();
    public EventStatementSyntax WithImplementsClause(ImplementsClauseSyntax implementsClause);
    public EventStatementSyntax AddImplementsClauseInterfaceMembers(QualifiedNameSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public EventStatementSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken customKeyword, SyntaxToken eventKeyword, SyntaxToken identifier, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, ImplementsClauseSyntax implementsClause);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExecutableStatementSyntax : StatementSyntax {
    internal ExecutableStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExitStatementSyntax : ExecutableStatementSyntax {
    public SyntaxToken ExitKeyword { get; }
    public SyntaxToken BlockKeyword { get; }
    internal ExitStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ExitStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    public SyntaxToken get_ExitKeyword();
    public ExitStatementSyntax WithExitKeyword(SyntaxToken exitKeyword);
    public SyntaxToken get_BlockKeyword();
    public ExitStatementSyntax WithBlockKeyword(SyntaxToken blockKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ExitStatementSyntax Update(SyntaxKind kind, SyntaxToken exitKeyword, SyntaxToken blockKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionRangeVariableSyntax : VisualBasicSyntaxNode {
    internal VariableNameEqualsSyntax _nameEquals;
    internal ExpressionSyntax _expression;
    public VariableNameEqualsSyntax NameEquals { get; }
    public ExpressionSyntax Expression { get; }
    internal ExpressionRangeVariableSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ExpressionRangeVariableSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, VariableNameEqualsSyntax nameEquals, ExpressionSyntax expression);
    public VariableNameEqualsSyntax get_NameEquals();
    public ExpressionRangeVariableSyntax WithNameEquals(VariableNameEqualsSyntax nameEquals);
    public ExpressionSyntax get_Expression();
    public ExpressionRangeVariableSyntax WithExpression(ExpressionSyntax expression);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ExpressionRangeVariableSyntax Update(VariableNameEqualsSyntax nameEquals, ExpressionSyntax expression);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionStatementSyntax : ExecutableStatementSyntax {
    internal ExpressionSyntax _expression;
    public ExpressionSyntax Expression { get; }
    internal ExpressionStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ExpressionStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax expression);
    public ExpressionSyntax get_Expression();
    public ExpressionStatementSyntax WithExpression(ExpressionSyntax expression);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ExpressionStatementSyntax Update(ExpressionSyntax expression);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExpressionSyntax : VisualBasicSyntaxNode {
    internal ExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalChecksumDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken ExternalChecksumKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public SyntaxToken ExternalSource { get; }
    public SyntaxToken FirstCommaToken { get; }
    public SyntaxToken Guid { get; }
    public SyntaxToken SecondCommaToken { get; }
    public SyntaxToken Checksum { get; }
    public SyntaxToken CloseParenToken { get; }
    internal ExternalChecksumDirectiveTriviaSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ExternalChecksumDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax externalChecksumKeyword, PunctuationSyntax openParenToken, StringLiteralTokenSyntax externalSource, PunctuationSyntax firstCommaToken, StringLiteralTokenSyntax guid, PunctuationSyntax secondCommaToken, StringLiteralTokenSyntax checksum, PunctuationSyntax closeParenToken);
    public SyntaxToken get_HashToken();
    internal virtual SyntaxToken GetHashTokenCore();
    public ExternalChecksumDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public SyntaxToken get_ExternalChecksumKeyword();
    public ExternalChecksumDirectiveTriviaSyntax WithExternalChecksumKeyword(SyntaxToken externalChecksumKeyword);
    public SyntaxToken get_OpenParenToken();
    public ExternalChecksumDirectiveTriviaSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public SyntaxToken get_ExternalSource();
    public ExternalChecksumDirectiveTriviaSyntax WithExternalSource(SyntaxToken externalSource);
    public SyntaxToken get_FirstCommaToken();
    public ExternalChecksumDirectiveTriviaSyntax WithFirstCommaToken(SyntaxToken firstCommaToken);
    public SyntaxToken get_Guid();
    public ExternalChecksumDirectiveTriviaSyntax WithGuid(SyntaxToken guid);
    public SyntaxToken get_SecondCommaToken();
    public ExternalChecksumDirectiveTriviaSyntax WithSecondCommaToken(SyntaxToken secondCommaToken);
    public SyntaxToken get_Checksum();
    public ExternalChecksumDirectiveTriviaSyntax WithChecksum(SyntaxToken checksum);
    public SyntaxToken get_CloseParenToken();
    public ExternalChecksumDirectiveTriviaSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ExternalChecksumDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken externalChecksumKeyword, SyntaxToken openParenToken, SyntaxToken externalSource, SyntaxToken firstCommaToken, SyntaxToken guid, SyntaxToken secondCommaToken, SyntaxToken checksum, SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ExternalSourceDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken ExternalSourceKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public SyntaxToken ExternalSource { get; }
    public SyntaxToken CommaToken { get; }
    public SyntaxToken LineStart { get; }
    public SyntaxToken CloseParenToken { get; }
    internal ExternalSourceDirectiveTriviaSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ExternalSourceDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax externalSourceKeyword, PunctuationSyntax openParenToken, StringLiteralTokenSyntax externalSource, PunctuationSyntax commaToken, IntegerLiteralTokenSyntax lineStart, PunctuationSyntax closeParenToken);
    public SyntaxToken get_HashToken();
    internal virtual SyntaxToken GetHashTokenCore();
    public ExternalSourceDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public SyntaxToken get_ExternalSourceKeyword();
    public ExternalSourceDirectiveTriviaSyntax WithExternalSourceKeyword(SyntaxToken externalSourceKeyword);
    public SyntaxToken get_OpenParenToken();
    public ExternalSourceDirectiveTriviaSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public SyntaxToken get_ExternalSource();
    public ExternalSourceDirectiveTriviaSyntax WithExternalSource(SyntaxToken externalSource);
    public SyntaxToken get_CommaToken();
    public ExternalSourceDirectiveTriviaSyntax WithCommaToken(SyntaxToken commaToken);
    public SyntaxToken get_LineStart();
    public ExternalSourceDirectiveTriviaSyntax WithLineStart(SyntaxToken lineStart);
    public SyntaxToken get_CloseParenToken();
    public ExternalSourceDirectiveTriviaSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ExternalSourceDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken externalSourceKeyword, SyntaxToken openParenToken, SyntaxToken externalSource, SyntaxToken commaToken, SyntaxToken lineStart, SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldDeclarationSyntax : DeclarationStatementSyntax {
    internal SyntaxNode _attributeLists;
    internal SyntaxNode _declarators;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SeparatedSyntaxList`1<VariableDeclaratorSyntax> Declarators { get; }
    internal FieldDeclarationSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal FieldDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode attributeLists, GreenNode modifiers, SyntaxNode declarators);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public FieldDeclarationSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public FieldDeclarationSyntax AddAttributeLists(AttributeListSyntax[] items);
    public SyntaxTokenList get_Modifiers();
    public FieldDeclarationSyntax WithModifiers(SyntaxTokenList modifiers);
    public FieldDeclarationSyntax AddModifiers(SyntaxToken[] items);
    public SeparatedSyntaxList`1<VariableDeclaratorSyntax> get_Declarators();
    public FieldDeclarationSyntax WithDeclarators(SeparatedSyntaxList`1<VariableDeclaratorSyntax> declarators);
    public FieldDeclarationSyntax AddDeclarators(VariableDeclaratorSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public FieldDeclarationSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SeparatedSyntaxList`1<VariableDeclaratorSyntax> declarators);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.FieldInitializerSyntax : VisualBasicSyntaxNode {
    public SyntaxToken KeyKeyword { get; }
    internal FieldInitializerSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    public SyntaxToken get_KeyKeyword();
    internal virtual SyntaxToken GetKeyKeywordCore();
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyBlockSyntax : VisualBasicSyntaxNode {
    internal FinallyStatementSyntax _finallyStatement;
    internal SyntaxNode _statements;
    public FinallyStatementSyntax FinallyStatement { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    internal FinallyBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal FinallyBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, FinallyStatementSyntax finallyStatement, SyntaxNode statements);
    public FinallyStatementSyntax get_FinallyStatement();
    public FinallyBlockSyntax WithFinallyStatement(FinallyStatementSyntax finallyStatement);
    public SyntaxList`1<StatementSyntax> get_Statements();
    public FinallyBlockSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public FinallyBlockSyntax AddStatements(StatementSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public FinallyBlockSyntax Update(FinallyStatementSyntax finallyStatement, SyntaxList`1<StatementSyntax> statements);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.FinallyStatementSyntax : StatementSyntax {
    public SyntaxToken FinallyKeyword { get; }
    internal FinallyStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal FinallyStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax finallyKeyword);
    public SyntaxToken get_FinallyKeyword();
    public FinallyStatementSyntax WithFinallyKeyword(SyntaxToken finallyKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public FinallyStatementSyntax Update(SyntaxToken finallyKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ForBlockSyntax : ForOrForEachBlockSyntax {
    internal ForStatementSyntax _forStatement;
    [EditorBrowsableAttribute("1")]
public ForOrForEachStatementSyntax ForOrForEachStatement { get; }
    public ForStatementSyntax ForStatement { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    public NextStatementSyntax NextStatement { get; }
    internal ForBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ForBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ForStatementSyntax forStatement, SyntaxNode statements, NextStatementSyntax nextStatement);
    public virtual ForOrForEachStatementSyntax get_ForOrForEachStatement();
    public ForStatementSyntax get_ForStatement();
    public ForBlockSyntax WithForStatement(ForStatementSyntax forStatement);
    public SyntaxList`1<StatementSyntax> get_Statements();
    internal virtual SyntaxList`1<StatementSyntax> GetStatementsCore();
    public ForBlockSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public ForBlockSyntax AddStatements(StatementSyntax[] items);
    public NextStatementSyntax get_NextStatement();
    internal virtual NextStatementSyntax GetNextStatementCore();
    public ForBlockSyntax WithNextStatement(NextStatementSyntax nextStatement);
    public ForBlockSyntax AddNextStatementControlVariables(ExpressionSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ForBlockSyntax Update(ForStatementSyntax forStatement, SyntaxList`1<StatementSyntax> statements, NextStatementSyntax nextStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachBlockSyntax : ForOrForEachBlockSyntax {
    internal ForEachStatementSyntax _forEachStatement;
    [EditorBrowsableAttribute("1")]
public ForOrForEachStatementSyntax ForOrForEachStatement { get; }
    public ForEachStatementSyntax ForEachStatement { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    public NextStatementSyntax NextStatement { get; }
    internal ForEachBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ForEachBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ForEachStatementSyntax forEachStatement, SyntaxNode statements, NextStatementSyntax nextStatement);
    public virtual ForOrForEachStatementSyntax get_ForOrForEachStatement();
    public ForEachStatementSyntax get_ForEachStatement();
    public ForEachBlockSyntax WithForEachStatement(ForEachStatementSyntax forEachStatement);
    public SyntaxList`1<StatementSyntax> get_Statements();
    internal virtual SyntaxList`1<StatementSyntax> GetStatementsCore();
    public ForEachBlockSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public ForEachBlockSyntax AddStatements(StatementSyntax[] items);
    public NextStatementSyntax get_NextStatement();
    internal virtual NextStatementSyntax GetNextStatementCore();
    public ForEachBlockSyntax WithNextStatement(NextStatementSyntax nextStatement);
    public ForEachBlockSyntax AddNextStatementControlVariables(ExpressionSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ForEachBlockSyntax Update(ForEachStatementSyntax forEachStatement, SyntaxList`1<StatementSyntax> statements, NextStatementSyntax nextStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ForEachStatementSyntax : ForOrForEachStatementSyntax {
    internal ExpressionSyntax _expression;
    public SyntaxToken ForKeyword { get; }
    public SyntaxToken EachKeyword { get; }
    public VisualBasicSyntaxNode ControlVariable { get; }
    public SyntaxToken InKeyword { get; }
    public ExpressionSyntax Expression { get; }
    internal ForEachStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ForEachStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax forKeyword, KeywordSyntax eachKeyword, VisualBasicSyntaxNode controlVariable, KeywordSyntax inKeyword, ExpressionSyntax expression);
    public SyntaxToken get_ForKeyword();
    internal virtual SyntaxToken GetForKeywordCore();
    public ForEachStatementSyntax WithForKeyword(SyntaxToken forKeyword);
    public SyntaxToken get_EachKeyword();
    public ForEachStatementSyntax WithEachKeyword(SyntaxToken eachKeyword);
    public VisualBasicSyntaxNode get_ControlVariable();
    internal virtual VisualBasicSyntaxNode GetControlVariableCore();
    public ForEachStatementSyntax WithControlVariable(VisualBasicSyntaxNode controlVariable);
    public SyntaxToken get_InKeyword();
    public ForEachStatementSyntax WithInKeyword(SyntaxToken inKeyword);
    public ExpressionSyntax get_Expression();
    public ForEachStatementSyntax WithExpression(ExpressionSyntax expression);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ForEachStatementSyntax Update(SyntaxToken forKeyword, SyntaxToken eachKeyword, VisualBasicSyntaxNode controlVariable, SyntaxToken inKeyword, ExpressionSyntax expression);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachBlockSyntax : ExecutableStatementSyntax {
    internal SyntaxNode _statements;
    internal NextStatementSyntax _nextStatement;
    public ForOrForEachStatementSyntax ForOrForEachStatement { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    public NextStatementSyntax NextStatement { get; }
    internal ForOrForEachBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    public abstract virtual ForOrForEachStatementSyntax get_ForOrForEachStatement();
    public SyntaxList`1<StatementSyntax> get_Statements();
    internal virtual SyntaxList`1<StatementSyntax> GetStatementsCore();
    public NextStatementSyntax get_NextStatement();
    internal virtual NextStatementSyntax GetNextStatementCore();
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.ForOrForEachStatementSyntax : StatementSyntax {
    internal VisualBasicSyntaxNode _controlVariable;
    public SyntaxToken ForKeyword { get; }
    public VisualBasicSyntaxNode ControlVariable { get; }
    internal ForOrForEachStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    public SyntaxToken get_ForKeyword();
    internal virtual SyntaxToken GetForKeywordCore();
    public VisualBasicSyntaxNode get_ControlVariable();
    internal virtual VisualBasicSyntaxNode GetControlVariableCore();
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStatementSyntax : ForOrForEachStatementSyntax {
    internal ExpressionSyntax _fromValue;
    internal ExpressionSyntax _toValue;
    internal ForStepClauseSyntax _stepClause;
    public SyntaxToken ForKeyword { get; }
    public VisualBasicSyntaxNode ControlVariable { get; }
    public SyntaxToken EqualsToken { get; }
    public ExpressionSyntax FromValue { get; }
    public SyntaxToken ToKeyword { get; }
    public ExpressionSyntax ToValue { get; }
    public ForStepClauseSyntax StepClause { get; }
    internal ForStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ForStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax forKeyword, VisualBasicSyntaxNode controlVariable, PunctuationSyntax equalsToken, ExpressionSyntax fromValue, KeywordSyntax toKeyword, ExpressionSyntax toValue, ForStepClauseSyntax stepClause);
    public SyntaxToken get_ForKeyword();
    internal virtual SyntaxToken GetForKeywordCore();
    public ForStatementSyntax WithForKeyword(SyntaxToken forKeyword);
    public VisualBasicSyntaxNode get_ControlVariable();
    internal virtual VisualBasicSyntaxNode GetControlVariableCore();
    public ForStatementSyntax WithControlVariable(VisualBasicSyntaxNode controlVariable);
    public SyntaxToken get_EqualsToken();
    public ForStatementSyntax WithEqualsToken(SyntaxToken equalsToken);
    public ExpressionSyntax get_FromValue();
    public ForStatementSyntax WithFromValue(ExpressionSyntax fromValue);
    public SyntaxToken get_ToKeyword();
    public ForStatementSyntax WithToKeyword(SyntaxToken toKeyword);
    public ExpressionSyntax get_ToValue();
    public ForStatementSyntax WithToValue(ExpressionSyntax toValue);
    public ForStepClauseSyntax get_StepClause();
    public ForStatementSyntax WithStepClause(ForStepClauseSyntax stepClause);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ForStatementSyntax Update(SyntaxToken forKeyword, VisualBasicSyntaxNode controlVariable, SyntaxToken equalsToken, ExpressionSyntax fromValue, SyntaxToken toKeyword, ExpressionSyntax toValue, ForStepClauseSyntax stepClause);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ForStepClauseSyntax : VisualBasicSyntaxNode {
    internal ExpressionSyntax _stepValue;
    public SyntaxToken StepKeyword { get; }
    public ExpressionSyntax StepValue { get; }
    internal ForStepClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ForStepClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax stepKeyword, ExpressionSyntax stepValue);
    public SyntaxToken get_StepKeyword();
    public ForStepClauseSyntax WithStepKeyword(SyntaxToken stepKeyword);
    public ExpressionSyntax get_StepValue();
    public ForStepClauseSyntax WithStepValue(ExpressionSyntax stepValue);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ForStepClauseSyntax Update(SyntaxToken stepKeyword, ExpressionSyntax stepValue);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.FromClauseSyntax : QueryClauseSyntax {
    internal SyntaxNode _variables;
    public SyntaxToken FromKeyword { get; }
    public SeparatedSyntaxList`1<CollectionRangeVariableSyntax> Variables { get; }
    internal FromClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal FromClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax fromKeyword, SyntaxNode variables);
    public SyntaxToken get_FromKeyword();
    public FromClauseSyntax WithFromKeyword(SyntaxToken fromKeyword);
    public SeparatedSyntaxList`1<CollectionRangeVariableSyntax> get_Variables();
    public FromClauseSyntax WithVariables(SeparatedSyntaxList`1<CollectionRangeVariableSyntax> variables);
    public FromClauseSyntax AddVariables(CollectionRangeVariableSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public FromClauseSyntax Update(SyntaxToken fromKeyword, SeparatedSyntaxList`1<CollectionRangeVariableSyntax> variables);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.FunctionAggregationSyntax : AggregationSyntax {
    internal ExpressionSyntax _argument;
    public SyntaxToken FunctionName { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Argument { get; }
    public SyntaxToken CloseParenToken { get; }
    internal FunctionAggregationSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal FunctionAggregationSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, IdentifierTokenSyntax functionName, PunctuationSyntax openParenToken, ExpressionSyntax argument, PunctuationSyntax closeParenToken);
    public SyntaxToken get_FunctionName();
    public FunctionAggregationSyntax WithFunctionName(SyntaxToken functionName);
    public SyntaxToken get_OpenParenToken();
    public FunctionAggregationSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public ExpressionSyntax get_Argument();
    public FunctionAggregationSyntax WithArgument(ExpressionSyntax argument);
    public SyntaxToken get_CloseParenToken();
    public FunctionAggregationSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public FunctionAggregationSyntax Update(SyntaxToken functionName, SyntaxToken openParenToken, ExpressionSyntax argument, SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.GenericNameSyntax : SimpleNameSyntax {
    internal TypeArgumentListSyntax _typeArgumentList;
    public SyntaxToken Identifier { get; }
    public TypeArgumentListSyntax TypeArgumentList { get; }
    internal GenericNameSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal GenericNameSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, IdentifierTokenSyntax identifier, TypeArgumentListSyntax typeArgumentList);
    public SyntaxToken get_Identifier();
    internal virtual SyntaxToken GetIdentifierCore();
    public GenericNameSyntax WithIdentifier(SyntaxToken identifier);
    public TypeArgumentListSyntax get_TypeArgumentList();
    public GenericNameSyntax WithTypeArgumentList(TypeArgumentListSyntax typeArgumentList);
    public GenericNameSyntax AddTypeArgumentListArguments(TypeSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public GenericNameSyntax Update(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.GetTypeExpressionSyntax : ExpressionSyntax {
    internal TypeSyntax _type;
    public SyntaxToken GetTypeKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken CloseParenToken { get; }
    internal GetTypeExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal GetTypeExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax getTypeKeyword, PunctuationSyntax openParenToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    public SyntaxToken get_GetTypeKeyword();
    public GetTypeExpressionSyntax WithGetTypeKeyword(SyntaxToken getTypeKeyword);
    public SyntaxToken get_OpenParenToken();
    public GetTypeExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public TypeSyntax get_Type();
    public GetTypeExpressionSyntax WithType(TypeSyntax type);
    public SyntaxToken get_CloseParenToken();
    public GetTypeExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public GetTypeExpressionSyntax Update(SyntaxToken getTypeKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.GetXmlNamespaceExpressionSyntax : ExpressionSyntax {
    internal XmlPrefixNameSyntax _name;
    public SyntaxToken GetXmlNamespaceKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public XmlPrefixNameSyntax Name { get; }
    public SyntaxToken CloseParenToken { get; }
    internal GetXmlNamespaceExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal GetXmlNamespaceExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax getXmlNamespaceKeyword, PunctuationSyntax openParenToken, XmlPrefixNameSyntax name, PunctuationSyntax closeParenToken);
    public SyntaxToken get_GetXmlNamespaceKeyword();
    public GetXmlNamespaceExpressionSyntax WithGetXmlNamespaceKeyword(SyntaxToken getXmlNamespaceKeyword);
    public SyntaxToken get_OpenParenToken();
    public GetXmlNamespaceExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public XmlPrefixNameSyntax get_Name();
    public GetXmlNamespaceExpressionSyntax WithName(XmlPrefixNameSyntax name);
    public SyntaxToken get_CloseParenToken();
    public GetXmlNamespaceExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public GetXmlNamespaceExpressionSyntax Update(SyntaxToken getXmlNamespaceKeyword, SyntaxToken openParenToken, XmlPrefixNameSyntax name, SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.GlobalNameSyntax : NameSyntax {
    public SyntaxToken GlobalKeyword { get; }
    internal GlobalNameSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal GlobalNameSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax globalKeyword);
    public SyntaxToken get_GlobalKeyword();
    public GlobalNameSyntax WithGlobalKeyword(SyntaxToken globalKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public GlobalNameSyntax Update(SyntaxToken globalKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.GoToStatementSyntax : ExecutableStatementSyntax {
    internal LabelSyntax _label;
    public SyntaxToken GoToKeyword { get; }
    public LabelSyntax Label { get; }
    internal GoToStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal GoToStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax goToKeyword, LabelSyntax label);
    public SyntaxToken get_GoToKeyword();
    public GoToStatementSyntax WithGoToKeyword(SyntaxToken goToKeyword);
    public LabelSyntax get_Label();
    public GoToStatementSyntax WithLabel(LabelSyntax label);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public GoToStatementSyntax Update(SyntaxToken goToKeyword, LabelSyntax label);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupAggregationSyntax : AggregationSyntax {
    public SyntaxToken GroupKeyword { get; }
    internal GroupAggregationSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal GroupAggregationSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax groupKeyword);
    public SyntaxToken get_GroupKeyword();
    public GroupAggregationSyntax WithGroupKeyword(SyntaxToken groupKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public GroupAggregationSyntax Update(SyntaxToken groupKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupByClauseSyntax : QueryClauseSyntax {
    internal SyntaxNode _items;
    internal SyntaxNode _keys;
    internal SyntaxNode _aggregationVariables;
    public SyntaxToken GroupKeyword { get; }
    public SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> Items { get; }
    public SyntaxToken ByKeyword { get; }
    public SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> Keys { get; }
    public SyntaxToken IntoKeyword { get; }
    public SeparatedSyntaxList`1<AggregationRangeVariableSyntax> AggregationVariables { get; }
    internal GroupByClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal GroupByClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax groupKeyword, SyntaxNode items, KeywordSyntax byKeyword, SyntaxNode keys, KeywordSyntax intoKeyword, SyntaxNode aggregationVariables);
    public SyntaxToken get_GroupKeyword();
    public GroupByClauseSyntax WithGroupKeyword(SyntaxToken groupKeyword);
    public SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> get_Items();
    public GroupByClauseSyntax WithItems(SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> items);
    public GroupByClauseSyntax AddItems(ExpressionRangeVariableSyntax[] items);
    public SyntaxToken get_ByKeyword();
    public GroupByClauseSyntax WithByKeyword(SyntaxToken byKeyword);
    public SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> get_Keys();
    public GroupByClauseSyntax WithKeys(SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> keys);
    public GroupByClauseSyntax AddKeys(ExpressionRangeVariableSyntax[] items);
    public SyntaxToken get_IntoKeyword();
    public GroupByClauseSyntax WithIntoKeyword(SyntaxToken intoKeyword);
    public SeparatedSyntaxList`1<AggregationRangeVariableSyntax> get_AggregationVariables();
    public GroupByClauseSyntax WithAggregationVariables(SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
    public GroupByClauseSyntax AddAggregationVariables(AggregationRangeVariableSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public GroupByClauseSyntax Update(SyntaxToken groupKeyword, SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> items, SyntaxToken byKeyword, SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> keys, SyntaxToken intoKeyword, SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.GroupJoinClauseSyntax : JoinClauseSyntax {
    internal SyntaxNode _aggregationVariables;
    public SyntaxToken GroupKeyword { get; }
    public SyntaxToken JoinKeyword { get; }
    public SeparatedSyntaxList`1<CollectionRangeVariableSyntax> JoinedVariables { get; }
    public SyntaxList`1<JoinClauseSyntax> AdditionalJoins { get; }
    public SyntaxToken OnKeyword { get; }
    public SeparatedSyntaxList`1<JoinConditionSyntax> JoinConditions { get; }
    public SyntaxToken IntoKeyword { get; }
    public SeparatedSyntaxList`1<AggregationRangeVariableSyntax> AggregationVariables { get; }
    internal GroupJoinClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal GroupJoinClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax groupKeyword, KeywordSyntax joinKeyword, SyntaxNode joinedVariables, SyntaxNode additionalJoins, KeywordSyntax onKeyword, SyntaxNode joinConditions, KeywordSyntax intoKeyword, SyntaxNode aggregationVariables);
    public SyntaxToken get_GroupKeyword();
    public GroupJoinClauseSyntax WithGroupKeyword(SyntaxToken groupKeyword);
    public SyntaxToken get_JoinKeyword();
    internal virtual SyntaxToken GetJoinKeywordCore();
    public GroupJoinClauseSyntax WithJoinKeyword(SyntaxToken joinKeyword);
    public virtual SeparatedSyntaxList`1<CollectionRangeVariableSyntax> get_JoinedVariables();
    public GroupJoinClauseSyntax WithJoinedVariables(SeparatedSyntaxList`1<CollectionRangeVariableSyntax> joinedVariables);
    public GroupJoinClauseSyntax AddJoinedVariables(CollectionRangeVariableSyntax[] items);
    public SyntaxList`1<JoinClauseSyntax> get_AdditionalJoins();
    internal virtual SyntaxList`1<JoinClauseSyntax> GetAdditionalJoinsCore();
    public GroupJoinClauseSyntax WithAdditionalJoins(SyntaxList`1<JoinClauseSyntax> additionalJoins);
    public GroupJoinClauseSyntax AddAdditionalJoins(JoinClauseSyntax[] items);
    public SyntaxToken get_OnKeyword();
    internal virtual SyntaxToken GetOnKeywordCore();
    public GroupJoinClauseSyntax WithOnKeyword(SyntaxToken onKeyword);
    public virtual SeparatedSyntaxList`1<JoinConditionSyntax> get_JoinConditions();
    public GroupJoinClauseSyntax WithJoinConditions(SeparatedSyntaxList`1<JoinConditionSyntax> joinConditions);
    public GroupJoinClauseSyntax AddJoinConditions(JoinConditionSyntax[] items);
    public SyntaxToken get_IntoKeyword();
    public GroupJoinClauseSyntax WithIntoKeyword(SyntaxToken intoKeyword);
    public SeparatedSyntaxList`1<AggregationRangeVariableSyntax> get_AggregationVariables();
    public GroupJoinClauseSyntax WithAggregationVariables(SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
    public GroupJoinClauseSyntax AddAggregationVariables(AggregationRangeVariableSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public GroupJoinClauseSyntax Update(SyntaxToken groupKeyword, SyntaxToken joinKeyword, SeparatedSyntaxList`1<CollectionRangeVariableSyntax> joinedVariables, SyntaxList`1<JoinClauseSyntax> additionalJoins, SyntaxToken onKeyword, SeparatedSyntaxList`1<JoinConditionSyntax> joinConditions, SyntaxToken intoKeyword, SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseItemSyntax : VisualBasicSyntaxNode {
    internal EventContainerSyntax _eventContainer;
    internal IdentifierNameSyntax _eventMember;
    public EventContainerSyntax EventContainer { get; }
    public SyntaxToken DotToken { get; }
    public IdentifierNameSyntax EventMember { get; }
    internal HandlesClauseItemSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal HandlesClauseItemSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, EventContainerSyntax eventContainer, PunctuationSyntax dotToken, IdentifierNameSyntax eventMember);
    public EventContainerSyntax get_EventContainer();
    public HandlesClauseItemSyntax WithEventContainer(EventContainerSyntax eventContainer);
    public SyntaxToken get_DotToken();
    public HandlesClauseItemSyntax WithDotToken(SyntaxToken dotToken);
    public IdentifierNameSyntax get_EventMember();
    public HandlesClauseItemSyntax WithEventMember(IdentifierNameSyntax eventMember);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public HandlesClauseItemSyntax Update(EventContainerSyntax eventContainer, SyntaxToken dotToken, IdentifierNameSyntax eventMember);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.HandlesClauseSyntax : VisualBasicSyntaxNode {
    internal SyntaxNode _events;
    public SyntaxToken HandlesKeyword { get; }
    public SeparatedSyntaxList`1<HandlesClauseItemSyntax> Events { get; }
    internal HandlesClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal HandlesClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax handlesKeyword, SyntaxNode events);
    public SyntaxToken get_HandlesKeyword();
    public HandlesClauseSyntax WithHandlesKeyword(SyntaxToken handlesKeyword);
    public SeparatedSyntaxList`1<HandlesClauseItemSyntax> get_Events();
    public HandlesClauseSyntax WithEvents(SeparatedSyntaxList`1<HandlesClauseItemSyntax> events);
    public HandlesClauseSyntax AddEvents(HandlesClauseItemSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public HandlesClauseSyntax Update(SyntaxToken handlesKeyword, SeparatedSyntaxList`1<HandlesClauseItemSyntax> events);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.IdentifierNameSyntax : SimpleNameSyntax {
    public SyntaxToken Identifier { get; }
    internal IdentifierNameSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal IdentifierNameSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, IdentifierTokenSyntax identifier);
    public SyntaxToken get_Identifier();
    internal virtual SyntaxToken GetIdentifierCore();
    public IdentifierNameSyntax WithIdentifier(SyntaxToken identifier);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public IdentifierNameSyntax Update(SyntaxToken identifier);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.IfDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal ExpressionSyntax _condition;
    public SyntaxToken HashToken { get; }
    public SyntaxToken ElseKeyword { get; }
    public SyntaxToken IfOrElseIfKeyword { get; }
    public ExpressionSyntax Condition { get; }
    public SyntaxToken ThenKeyword { get; }
    internal IfDirectiveTriviaSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal IfDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax elseKeyword, KeywordSyntax ifOrElseIfKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    public SyntaxToken get_HashToken();
    internal virtual SyntaxToken GetHashTokenCore();
    public IfDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public SyntaxToken get_ElseKeyword();
    public IfDirectiveTriviaSyntax WithElseKeyword(SyntaxToken elseKeyword);
    public SyntaxToken get_IfOrElseIfKeyword();
    public IfDirectiveTriviaSyntax WithIfOrElseIfKeyword(SyntaxToken ifOrElseIfKeyword);
    public ExpressionSyntax get_Condition();
    public IfDirectiveTriviaSyntax WithCondition(ExpressionSyntax condition);
    public SyntaxToken get_ThenKeyword();
    public IfDirectiveTriviaSyntax WithThenKeyword(SyntaxToken thenKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public IfDirectiveTriviaSyntax Update(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken ifOrElseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.IfStatementSyntax : StatementSyntax {
    internal ExpressionSyntax _condition;
    public SyntaxToken IfKeyword { get; }
    public ExpressionSyntax Condition { get; }
    public SyntaxToken ThenKeyword { get; }
    internal IfStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal IfStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax ifKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    public SyntaxToken get_IfKeyword();
    public IfStatementSyntax WithIfKeyword(SyntaxToken ifKeyword);
    public ExpressionSyntax get_Condition();
    public IfStatementSyntax WithCondition(ExpressionSyntax condition);
    public SyntaxToken get_ThenKeyword();
    public IfStatementSyntax WithThenKeyword(SyntaxToken thenKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public IfStatementSyntax Update(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsClauseSyntax : VisualBasicSyntaxNode {
    internal SyntaxNode _interfaceMembers;
    public SyntaxToken ImplementsKeyword { get; }
    public SeparatedSyntaxList`1<QualifiedNameSyntax> InterfaceMembers { get; }
    internal ImplementsClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ImplementsClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax implementsKeyword, SyntaxNode interfaceMembers);
    public SyntaxToken get_ImplementsKeyword();
    public ImplementsClauseSyntax WithImplementsKeyword(SyntaxToken implementsKeyword);
    public SeparatedSyntaxList`1<QualifiedNameSyntax> get_InterfaceMembers();
    public ImplementsClauseSyntax WithInterfaceMembers(SeparatedSyntaxList`1<QualifiedNameSyntax> interfaceMembers);
    public ImplementsClauseSyntax AddInterfaceMembers(QualifiedNameSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ImplementsClauseSyntax Update(SyntaxToken implementsKeyword, SeparatedSyntaxList`1<QualifiedNameSyntax> interfaceMembers);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ImplementsStatementSyntax : InheritsOrImplementsStatementSyntax {
    internal SyntaxNode _types;
    public SyntaxToken ImplementsKeyword { get; }
    public SeparatedSyntaxList`1<TypeSyntax> Types { get; }
    internal ImplementsStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ImplementsStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax implementsKeyword, SyntaxNode types);
    public SyntaxToken get_ImplementsKeyword();
    public ImplementsStatementSyntax WithImplementsKeyword(SyntaxToken implementsKeyword);
    public SeparatedSyntaxList`1<TypeSyntax> get_Types();
    public ImplementsStatementSyntax WithTypes(SeparatedSyntaxList`1<TypeSyntax> types);
    public ImplementsStatementSyntax AddTypes(TypeSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ImplementsStatementSyntax Update(SyntaxToken implementsKeyword, SeparatedSyntaxList`1<TypeSyntax> types);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportAliasClauseSyntax : VisualBasicSyntaxNode {
    public SyntaxToken Identifier { get; }
    public SyntaxToken EqualsToken { get; }
    internal ImportAliasClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ImportAliasClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, IdentifierTokenSyntax identifier, PunctuationSyntax equalsToken);
    public SyntaxToken get_Identifier();
    public ImportAliasClauseSyntax WithIdentifier(SyntaxToken identifier);
    public SyntaxToken get_EqualsToken();
    public ImportAliasClauseSyntax WithEqualsToken(SyntaxToken equalsToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ImportAliasClauseSyntax Update(SyntaxToken identifier, SyntaxToken equalsToken);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsClauseSyntax : VisualBasicSyntaxNode {
    internal ImportsClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ImportsStatementSyntax : DeclarationStatementSyntax {
    internal SyntaxNode _importsClauses;
    public SyntaxToken ImportsKeyword { get; }
    public SeparatedSyntaxList`1<ImportsClauseSyntax> ImportsClauses { get; }
    internal ImportsStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ImportsStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax importsKeyword, SyntaxNode importsClauses);
    public SyntaxToken get_ImportsKeyword();
    public ImportsStatementSyntax WithImportsKeyword(SyntaxToken importsKeyword);
    public SeparatedSyntaxList`1<ImportsClauseSyntax> get_ImportsClauses();
    public ImportsStatementSyntax WithImportsClauses(SeparatedSyntaxList`1<ImportsClauseSyntax> importsClauses);
    public ImportsStatementSyntax AddImportsClauses(ImportsClauseSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ImportsStatementSyntax Update(SyntaxToken importsKeyword, SeparatedSyntaxList`1<ImportsClauseSyntax> importsClauses);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.IncompleteMemberSyntax : DeclarationStatementSyntax {
    internal SyntaxNode _attributeLists;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken MissingIdentifier { get; }
    internal IncompleteMemberSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal IncompleteMemberSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode attributeLists, GreenNode modifiers, IdentifierTokenSyntax missingIdentifier);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public IncompleteMemberSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public IncompleteMemberSyntax AddAttributeLists(AttributeListSyntax[] items);
    public SyntaxTokenList get_Modifiers();
    public IncompleteMemberSyntax WithModifiers(SyntaxTokenList modifiers);
    public IncompleteMemberSyntax AddModifiers(SyntaxToken[] items);
    public SyntaxToken get_MissingIdentifier();
    public IncompleteMemberSyntax WithMissingIdentifier(SyntaxToken missingIdentifier);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public IncompleteMemberSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken missingIdentifier);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.InferredFieldInitializerSyntax : FieldInitializerSyntax {
    internal ExpressionSyntax _expression;
    public SyntaxToken KeyKeyword { get; }
    public ExpressionSyntax Expression { get; }
    internal InferredFieldInitializerSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal InferredFieldInitializerSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyKeyword, ExpressionSyntax expression);
    public SyntaxToken get_KeyKeyword();
    internal virtual SyntaxToken GetKeyKeywordCore();
    public InferredFieldInitializerSyntax WithKeyKeyword(SyntaxToken keyKeyword);
    public ExpressionSyntax get_Expression();
    public InferredFieldInitializerSyntax WithExpression(ExpressionSyntax expression);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public InferredFieldInitializerSyntax Update(SyntaxToken keyKeyword, ExpressionSyntax expression);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsOrImplementsStatementSyntax : DeclarationStatementSyntax {
    internal InheritsOrImplementsStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.InheritsStatementSyntax : InheritsOrImplementsStatementSyntax {
    internal SyntaxNode _types;
    public SyntaxToken InheritsKeyword { get; }
    public SeparatedSyntaxList`1<TypeSyntax> Types { get; }
    internal InheritsStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal InheritsStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax inheritsKeyword, SyntaxNode types);
    public SyntaxToken get_InheritsKeyword();
    public InheritsStatementSyntax WithInheritsKeyword(SyntaxToken inheritsKeyword);
    public SeparatedSyntaxList`1<TypeSyntax> get_Types();
    public InheritsStatementSyntax WithTypes(SeparatedSyntaxList`1<TypeSyntax> types);
    public InheritsStatementSyntax AddTypes(TypeSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public InheritsStatementSyntax Update(SyntaxToken inheritsKeyword, SeparatedSyntaxList`1<TypeSyntax> types);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InstanceExpressionSyntax : ExpressionSyntax {
    public SyntaxToken Keyword { get; }
    internal InstanceExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    public SyntaxToken get_Keyword();
    internal virtual SyntaxToken GetKeywordCore();
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceBlockSyntax : TypeBlockSyntax {
    internal InterfaceStatementSyntax _interfaceStatement;
    internal EndBlockStatementSyntax _endInterfaceStatement;
    public TypeStatementSyntax BlockStatement { get; }
    public EndBlockStatementSyntax EndBlockStatement { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public InterfaceStatementSyntax Begin { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public EndBlockStatementSyntax End { get; }
    public InterfaceStatementSyntax InterfaceStatement { get; }
    public SyntaxList`1<InheritsStatementSyntax> Inherits { get; }
    public SyntaxList`1<ImplementsStatementSyntax> Implements { get; }
    public SyntaxList`1<StatementSyntax> Members { get; }
    public EndBlockStatementSyntax EndInterfaceStatement { get; }
    internal InterfaceBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal InterfaceBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, InterfaceStatementSyntax interfaceStatement, SyntaxNode inherits, SyntaxNode implements, SyntaxNode members, EndBlockStatementSyntax endInterfaceStatement);
    public virtual TypeStatementSyntax get_BlockStatement();
    public virtual EndBlockStatementSyntax get_EndBlockStatement();
    public virtual TypeBlockSyntax WithBlockStatement(TypeStatementSyntax blockStatement);
    public virtual TypeBlockSyntax WithEndBlockStatement(EndBlockStatementSyntax endBlockStatement);
    public InterfaceStatementSyntax get_Begin();
    public EndBlockStatementSyntax get_End();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public InterfaceBlockSyntax WithBegin(InterfaceStatementSyntax begin);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public InterfaceBlockSyntax WithEnd(EndBlockStatementSyntax end);
    public InterfaceStatementSyntax get_InterfaceStatement();
    public InterfaceBlockSyntax WithInterfaceStatement(InterfaceStatementSyntax interfaceStatement);
    public SyntaxList`1<InheritsStatementSyntax> get_Inherits();
    internal virtual SyntaxList`1<InheritsStatementSyntax> GetInheritsCore();
    public InterfaceBlockSyntax WithInherits(SyntaxList`1<InheritsStatementSyntax> inherits);
    public InterfaceBlockSyntax AddInherits(InheritsStatementSyntax[] items);
    public SyntaxList`1<ImplementsStatementSyntax> get_Implements();
    internal virtual SyntaxList`1<ImplementsStatementSyntax> GetImplementsCore();
    public InterfaceBlockSyntax WithImplements(SyntaxList`1<ImplementsStatementSyntax> implements);
    public InterfaceBlockSyntax AddImplements(ImplementsStatementSyntax[] items);
    public SyntaxList`1<StatementSyntax> get_Members();
    internal virtual SyntaxList`1<StatementSyntax> GetMembersCore();
    public InterfaceBlockSyntax WithMembers(SyntaxList`1<StatementSyntax> members);
    public InterfaceBlockSyntax AddMembers(StatementSyntax[] items);
    public EndBlockStatementSyntax get_EndInterfaceStatement();
    public InterfaceBlockSyntax WithEndInterfaceStatement(EndBlockStatementSyntax endInterfaceStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public InterfaceBlockSyntax Update(InterfaceStatementSyntax interfaceStatement, SyntaxList`1<InheritsStatementSyntax> inherits, SyntaxList`1<ImplementsStatementSyntax> implements, SyntaxList`1<StatementSyntax> members, EndBlockStatementSyntax endInterfaceStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.InterfaceStatementSyntax : TypeStatementSyntax {
    public SyntaxToken DeclarationKeyword { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public SyntaxToken Keyword { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken InterfaceKeyword { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    internal InterfaceStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal InterfaceStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode attributeLists, GreenNode modifiers, KeywordSyntax interfaceKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    public virtual SyntaxToken get_DeclarationKeyword();
    public virtual TypeStatementSyntax WithDeclarationKeyword(SyntaxToken keyword);
    public SyntaxToken get_Keyword();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public InterfaceStatementSyntax WithKeyword(SyntaxToken keyword);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual SyntaxList`1<AttributeListSyntax> GetAttributeListsCore();
    public InterfaceStatementSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public InterfaceStatementSyntax AddAttributeLists(AttributeListSyntax[] items);
    public SyntaxTokenList get_Modifiers();
    internal virtual SyntaxTokenList GetModifiersCore();
    public InterfaceStatementSyntax WithModifiers(SyntaxTokenList modifiers);
    public InterfaceStatementSyntax AddModifiers(SyntaxToken[] items);
    public SyntaxToken get_InterfaceKeyword();
    public InterfaceStatementSyntax WithInterfaceKeyword(SyntaxToken interfaceKeyword);
    public SyntaxToken get_Identifier();
    internal virtual SyntaxToken GetIdentifierCore();
    public InterfaceStatementSyntax WithIdentifier(SyntaxToken identifier);
    public TypeParameterListSyntax get_TypeParameterList();
    internal virtual TypeParameterListSyntax GetTypeParameterListCore();
    public InterfaceStatementSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList);
    public InterfaceStatementSyntax AddTypeParameterListParameters(TypeParameterSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public InterfaceStatementSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken interfaceKeyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AccessorBlockSyntax : MethodBlockBaseSyntax {
    internal AccessorStatementSyntax _accessorStatement;
    internal EndBlockStatementSyntax _endAccessorStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    public MethodBaseSyntax Begin { get; }
    public EndBlockStatementSyntax End { get; }
    internal AccessorStatementSyntax AccessorStatement { get; }
    internal EndBlockStatementSyntax EndAccessorStatement { get; }
    private static AccessorBlockSyntax();
    internal AccessorBlockSyntax(SyntaxKind kind, AccessorStatementSyntax accessorStatement, GreenNode statements, EndBlockStatementSyntax endAccessorStatement);
    internal AccessorBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, AccessorStatementSyntax accessorStatement, GreenNode statements, EndBlockStatementSyntax endAccessorStatement);
    internal AccessorBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, AccessorStatementSyntax accessorStatement, GreenNode statements, EndBlockStatementSyntax endAccessorStatement);
    internal AccessorBlockSyntax(ObjectReader reader);
    public virtual MethodBaseSyntax get_Begin();
    public virtual EndBlockStatementSyntax get_End();
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal AccessorStatementSyntax get_AccessorStatement();
    internal EndBlockStatementSyntax get_EndAccessorStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AccessorStatementSyntax : MethodBaseSyntax {
    internal KeywordSyntax _accessorKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax AccessorKeyword { get; }
    private static AccessorStatementSyntax();
    internal AccessorStatementSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax accessorKeyword, ParameterListSyntax parameterList);
    internal AccessorStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax accessorKeyword, ParameterListSyntax parameterList);
    internal AccessorStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax accessorKeyword, ParameterListSyntax parameterList);
    internal AccessorStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_AccessorKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AddRemoveHandlerStatementSyntax : ExecutableStatementSyntax {
    internal KeywordSyntax _addHandlerOrRemoveHandlerKeyword;
    internal ExpressionSyntax _eventExpression;
    internal PunctuationSyntax _commaToken;
    internal ExpressionSyntax _delegateExpression;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax AddHandlerOrRemoveHandlerKeyword { get; }
    internal ExpressionSyntax EventExpression { get; }
    internal PunctuationSyntax CommaToken { get; }
    internal ExpressionSyntax DelegateExpression { get; }
    private static AddRemoveHandlerStatementSyntax();
    internal AddRemoveHandlerStatementSyntax(SyntaxKind kind, KeywordSyntax addHandlerOrRemoveHandlerKeyword, ExpressionSyntax eventExpression, PunctuationSyntax commaToken, ExpressionSyntax delegateExpression);
    internal AddRemoveHandlerStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax addHandlerOrRemoveHandlerKeyword, ExpressionSyntax eventExpression, PunctuationSyntax commaToken, ExpressionSyntax delegateExpression);
    internal AddRemoveHandlerStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax addHandlerOrRemoveHandlerKeyword, ExpressionSyntax eventExpression, PunctuationSyntax commaToken, ExpressionSyntax delegateExpression);
    internal AddRemoveHandlerStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_AddHandlerOrRemoveHandlerKeyword();
    internal ExpressionSyntax get_EventExpression();
    internal PunctuationSyntax get_CommaToken();
    internal ExpressionSyntax get_DelegateExpression();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregateClauseSyntax : QueryClauseSyntax {
    internal KeywordSyntax _aggregateKeyword;
    internal GreenNode _variables;
    internal GreenNode _additionalQueryOperators;
    internal KeywordSyntax _intoKeyword;
    internal GreenNode _aggregationVariables;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax AggregateKeyword { get; }
    internal SeparatedSyntaxList`1<CollectionRangeVariableSyntax> Variables { get; }
    internal SyntaxList`1<QueryClauseSyntax> AdditionalQueryOperators { get; }
    internal KeywordSyntax IntoKeyword { get; }
    internal SeparatedSyntaxList`1<AggregationRangeVariableSyntax> AggregationVariables { get; }
    private static AggregateClauseSyntax();
    internal AggregateClauseSyntax(SyntaxKind kind, KeywordSyntax aggregateKeyword, GreenNode variables, GreenNode additionalQueryOperators, KeywordSyntax intoKeyword, GreenNode aggregationVariables);
    internal AggregateClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax aggregateKeyword, GreenNode variables, GreenNode additionalQueryOperators, KeywordSyntax intoKeyword, GreenNode aggregationVariables);
    internal AggregateClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax aggregateKeyword, GreenNode variables, GreenNode additionalQueryOperators, KeywordSyntax intoKeyword, GreenNode aggregationVariables);
    internal AggregateClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_AggregateKeyword();
    internal SeparatedSyntaxList`1<CollectionRangeVariableSyntax> get_Variables();
    internal SyntaxList`1<QueryClauseSyntax> get_AdditionalQueryOperators();
    internal KeywordSyntax get_IntoKeyword();
    internal SeparatedSyntaxList`1<AggregationRangeVariableSyntax> get_AggregationVariables();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregationRangeVariableSyntax : VisualBasicSyntaxNode {
    internal VariableNameEqualsSyntax _nameEquals;
    internal AggregationSyntax _aggregation;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal VariableNameEqualsSyntax NameEquals { get; }
    internal AggregationSyntax Aggregation { get; }
    private static AggregationRangeVariableSyntax();
    internal AggregationRangeVariableSyntax(SyntaxKind kind, VariableNameEqualsSyntax nameEquals, AggregationSyntax aggregation);
    internal AggregationRangeVariableSyntax(SyntaxKind kind, ISyntaxFactoryContext context, VariableNameEqualsSyntax nameEquals, AggregationSyntax aggregation);
    internal AggregationRangeVariableSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, VariableNameEqualsSyntax nameEquals, AggregationSyntax aggregation);
    internal AggregationRangeVariableSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal VariableNameEqualsSyntax get_NameEquals();
    internal AggregationSyntax get_Aggregation();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AggregationSyntax : ExpressionSyntax {
    internal AggregationSyntax(SyntaxKind kind);
    internal AggregationSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal AggregationSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal AggregationSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax : NewExpressionSyntax {
    internal ObjectMemberInitializerSyntax _initializer;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ObjectMemberInitializerSyntax Initializer { get; }
    private static AnonymousObjectCreationExpressionSyntax();
    internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, KeywordSyntax newKeyword, GreenNode attributeLists, ObjectMemberInitializerSyntax initializer);
    internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax newKeyword, GreenNode attributeLists, ObjectMemberInitializerSyntax initializer);
    internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax newKeyword, GreenNode attributeLists, ObjectMemberInitializerSyntax initializer);
    internal AnonymousObjectCreationExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ObjectMemberInitializerSyntax get_Initializer();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentListSyntax : VisualBasicSyntaxNode {
    internal PunctuationSyntax _openParenToken;
    internal GreenNode _arguments;
    internal PunctuationSyntax _closeParenToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax OpenParenToken { get; }
    internal SeparatedSyntaxList`1<ArgumentSyntax> Arguments { get; }
    internal PunctuationSyntax CloseParenToken { get; }
    private static ArgumentListSyntax();
    internal ArgumentListSyntax(SyntaxKind kind, PunctuationSyntax openParenToken, GreenNode arguments, PunctuationSyntax closeParenToken);
    internal ArgumentListSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax openParenToken, GreenNode arguments, PunctuationSyntax closeParenToken);
    internal ArgumentListSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax openParenToken, GreenNode arguments, PunctuationSyntax closeParenToken);
    internal ArgumentListSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_OpenParenToken();
    internal SeparatedSyntaxList`1<ArgumentSyntax> get_Arguments();
    internal PunctuationSyntax get_CloseParenToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArgumentSyntax : VisualBasicSyntaxNode {
    internal ArgumentSyntax(SyntaxKind kind);
    internal ArgumentSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal ArgumentSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal ArgumentSyntax(ObjectReader reader);
    public ExpressionSyntax GetExpression();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArrayCreationExpressionSyntax : NewExpressionSyntax {
    internal TypeSyntax _type;
    internal ArgumentListSyntax _arrayBounds;
    internal GreenNode _rankSpecifiers;
    internal CollectionInitializerSyntax _initializer;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal TypeSyntax Type { get; }
    internal ArgumentListSyntax ArrayBounds { get; }
    internal SyntaxList`1<ArrayRankSpecifierSyntax> RankSpecifiers { get; }
    internal CollectionInitializerSyntax Initializer { get; }
    private static ArrayCreationExpressionSyntax();
    internal ArrayCreationExpressionSyntax(SyntaxKind kind, KeywordSyntax newKeyword, GreenNode attributeLists, TypeSyntax type, ArgumentListSyntax arrayBounds, GreenNode rankSpecifiers, CollectionInitializerSyntax initializer);
    internal ArrayCreationExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax newKeyword, GreenNode attributeLists, TypeSyntax type, ArgumentListSyntax arrayBounds, GreenNode rankSpecifiers, CollectionInitializerSyntax initializer);
    internal ArrayCreationExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax newKeyword, GreenNode attributeLists, TypeSyntax type, ArgumentListSyntax arrayBounds, GreenNode rankSpecifiers, CollectionInitializerSyntax initializer);
    internal ArrayCreationExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal TypeSyntax get_Type();
    internal ArgumentListSyntax get_ArrayBounds();
    internal SyntaxList`1<ArrayRankSpecifierSyntax> get_RankSpecifiers();
    internal CollectionInitializerSyntax get_Initializer();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArrayRankSpecifierSyntax : VisualBasicSyntaxNode {
    internal PunctuationSyntax _openParenToken;
    internal GreenNode _commaTokens;
    internal PunctuationSyntax _closeParenToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax OpenParenToken { get; }
    internal SyntaxList`1<PunctuationSyntax> CommaTokens { get; }
    internal PunctuationSyntax CloseParenToken { get; }
    private static ArrayRankSpecifierSyntax();
    internal ArrayRankSpecifierSyntax(SyntaxKind kind, PunctuationSyntax openParenToken, GreenNode commaTokens, PunctuationSyntax closeParenToken);
    internal ArrayRankSpecifierSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax openParenToken, GreenNode commaTokens, PunctuationSyntax closeParenToken);
    internal ArrayRankSpecifierSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax openParenToken, GreenNode commaTokens, PunctuationSyntax closeParenToken);
    internal ArrayRankSpecifierSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_OpenParenToken();
    internal SyntaxList`1<PunctuationSyntax> get_CommaTokens();
    internal PunctuationSyntax get_CloseParenToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ArrayTypeSyntax : TypeSyntax {
    internal TypeSyntax _elementType;
    internal GreenNode _rankSpecifiers;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal TypeSyntax ElementType { get; }
    internal SyntaxList`1<ArrayRankSpecifierSyntax> RankSpecifiers { get; }
    private static ArrayTypeSyntax();
    internal ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, GreenNode rankSpecifiers);
    internal ArrayTypeSyntax(SyntaxKind kind, ISyntaxFactoryContext context, TypeSyntax elementType, GreenNode rankSpecifiers);
    internal ArrayTypeSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, TypeSyntax elementType, GreenNode rankSpecifiers);
    internal ArrayTypeSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal TypeSyntax get_ElementType();
    internal SyntaxList`1<ArrayRankSpecifierSyntax> get_RankSpecifiers();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AsClauseSyntax : VisualBasicSyntaxNode {
    internal KeywordSyntax _asKeyword;
    internal KeywordSyntax AsKeyword { get; }
    internal AsClauseSyntax(SyntaxKind kind, KeywordSyntax asKeyword);
    internal AsClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax asKeyword);
    internal AsClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax asKeyword);
    internal AsClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal KeywordSyntax get_AsKeyword();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AsNewClauseSyntax : AsClauseSyntax {
    internal NewExpressionSyntax _newExpression;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal NewExpressionSyntax NewExpression { get; }
    private static AsNewClauseSyntax();
    internal AsNewClauseSyntax(SyntaxKind kind, KeywordSyntax asKeyword, NewExpressionSyntax newExpression);
    internal AsNewClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax asKeyword, NewExpressionSyntax newExpression);
    internal AsNewClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax asKeyword, NewExpressionSyntax newExpression);
    internal AsNewClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal NewExpressionSyntax get_NewExpression();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AssignmentStatementSyntax : ExecutableStatementSyntax {
    internal ExpressionSyntax _left;
    internal PunctuationSyntax _operatorToken;
    internal ExpressionSyntax _right;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ExpressionSyntax Left { get; }
    internal PunctuationSyntax OperatorToken { get; }
    internal ExpressionSyntax Right { get; }
    private static AssignmentStatementSyntax();
    internal AssignmentStatementSyntax(SyntaxKind kind, ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal AssignmentStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal AssignmentStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal AssignmentStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ExpressionSyntax get_Left();
    internal PunctuationSyntax get_OperatorToken();
    internal ExpressionSyntax get_Right();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeListSyntax : VisualBasicSyntaxNode {
    internal PunctuationSyntax _lessThanToken;
    internal GreenNode _attributes;
    internal PunctuationSyntax _greaterThanToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax LessThanToken { get; }
    internal SeparatedSyntaxList`1<AttributeSyntax> Attributes { get; }
    internal PunctuationSyntax GreaterThanToken { get; }
    private static AttributeListSyntax();
    internal AttributeListSyntax(SyntaxKind kind, PunctuationSyntax lessThanToken, GreenNode attributes, PunctuationSyntax greaterThanToken);
    internal AttributeListSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax lessThanToken, GreenNode attributes, PunctuationSyntax greaterThanToken);
    internal AttributeListSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanToken, GreenNode attributes, PunctuationSyntax greaterThanToken);
    internal AttributeListSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_LessThanToken();
    internal SeparatedSyntaxList`1<AttributeSyntax> get_Attributes();
    internal PunctuationSyntax get_GreaterThanToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributesStatementSyntax : DeclarationStatementSyntax {
    internal GreenNode _attributeLists;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    private static AttributesStatementSyntax();
    internal AttributesStatementSyntax(SyntaxKind kind, GreenNode attributeLists);
    internal AttributesStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists);
    internal AttributesStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists);
    internal AttributesStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeSyntax : VisualBasicSyntaxNode {
    internal AttributeTargetSyntax _target;
    internal TypeSyntax _name;
    internal ArgumentListSyntax _argumentList;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal AttributeTargetSyntax Target { get; }
    internal TypeSyntax Name { get; }
    internal ArgumentListSyntax ArgumentList { get; }
    private static AttributeSyntax();
    internal AttributeSyntax(SyntaxKind kind, AttributeTargetSyntax target, TypeSyntax name, ArgumentListSyntax argumentList);
    internal AttributeSyntax(SyntaxKind kind, ISyntaxFactoryContext context, AttributeTargetSyntax target, TypeSyntax name, ArgumentListSyntax argumentList);
    internal AttributeSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, AttributeTargetSyntax target, TypeSyntax name, ArgumentListSyntax argumentList);
    internal AttributeSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal AttributeTargetSyntax get_Target();
    internal TypeSyntax get_Name();
    internal ArgumentListSyntax get_ArgumentList();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AttributeTargetSyntax : VisualBasicSyntaxNode {
    internal KeywordSyntax _attributeModifier;
    internal PunctuationSyntax _colonToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax AttributeModifier { get; }
    internal PunctuationSyntax ColonToken { get; }
    private static AttributeTargetSyntax();
    internal AttributeTargetSyntax(SyntaxKind kind, KeywordSyntax attributeModifier, PunctuationSyntax colonToken);
    internal AttributeTargetSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax attributeModifier, PunctuationSyntax colonToken);
    internal AttributeTargetSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax attributeModifier, PunctuationSyntax colonToken);
    internal AttributeTargetSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_AttributeModifier();
    internal PunctuationSyntax get_ColonToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.AwaitExpressionSyntax : ExpressionSyntax {
    internal KeywordSyntax _awaitKeyword;
    internal ExpressionSyntax _expression;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax AwaitKeyword { get; }
    internal ExpressionSyntax Expression { get; }
    private static AwaitExpressionSyntax();
    internal AwaitExpressionSyntax(SyntaxKind kind, KeywordSyntax awaitKeyword, ExpressionSyntax expression);
    internal AwaitExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax awaitKeyword, ExpressionSyntax expression);
    internal AwaitExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax awaitKeyword, ExpressionSyntax expression);
    internal AwaitExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_AwaitKeyword();
    internal ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BadCConst : CConst {
    public SpecialType SpecialType { get; }
    public object ValueAsObject { get; }
    public BadCConst(ERRID id, Object[] args);
    public virtual SpecialType get_SpecialType();
    public virtual object get_ValueAsObject();
    public virtual CConst WithError(ERRID id);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BadDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal static Func`2<ObjectReader, object> CreateInstance;
    private static BadDirectiveTriviaSyntax();
    internal BadDirectiveTriviaSyntax(SyntaxKind kind, PunctuationSyntax hashToken);
    internal BadDirectiveTriviaSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax hashToken);
    internal BadDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken);
    internal BadDirectiveTriviaSyntax(ObjectReader reader);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BadTokenSyntax : PunctuationSyntax {
    private SyntaxSubKind _subKind;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxSubKind SubKind { get; }
    private static BadTokenSyntax();
    internal BadTokenSyntax(SyntaxKind kind, SyntaxSubKind subKind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal BadTokenSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal SyntaxSubKind get_SubKind();
    public virtual GreenNode WithLeadingTrivia(GreenNode trivia);
    public virtual GreenNode WithTrailingTrivia(GreenNode trivia);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BaseXmlAttributeSyntax : XmlNodeSyntax {
    internal BaseXmlAttributeSyntax(SyntaxKind kind);
    internal BaseXmlAttributeSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal BaseXmlAttributeSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal BaseXmlAttributeSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BinaryConditionalExpressionSyntax : ExpressionSyntax {
    internal KeywordSyntax _ifKeyword;
    internal PunctuationSyntax _openParenToken;
    internal ExpressionSyntax _firstExpression;
    internal PunctuationSyntax _commaToken;
    internal ExpressionSyntax _secondExpression;
    internal PunctuationSyntax _closeParenToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax IfKeyword { get; }
    internal PunctuationSyntax OpenParenToken { get; }
    internal ExpressionSyntax FirstExpression { get; }
    internal PunctuationSyntax CommaToken { get; }
    internal ExpressionSyntax SecondExpression { get; }
    internal PunctuationSyntax CloseParenToken { get; }
    private static BinaryConditionalExpressionSyntax();
    internal BinaryConditionalExpressionSyntax(SyntaxKind kind, KeywordSyntax ifKeyword, PunctuationSyntax openParenToken, ExpressionSyntax firstExpression, PunctuationSyntax commaToken, ExpressionSyntax secondExpression, PunctuationSyntax closeParenToken);
    internal BinaryConditionalExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax ifKeyword, PunctuationSyntax openParenToken, ExpressionSyntax firstExpression, PunctuationSyntax commaToken, ExpressionSyntax secondExpression, PunctuationSyntax closeParenToken);
    internal BinaryConditionalExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax ifKeyword, PunctuationSyntax openParenToken, ExpressionSyntax firstExpression, PunctuationSyntax commaToken, ExpressionSyntax secondExpression, PunctuationSyntax closeParenToken);
    internal BinaryConditionalExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_IfKeyword();
    internal PunctuationSyntax get_OpenParenToken();
    internal ExpressionSyntax get_FirstExpression();
    internal PunctuationSyntax get_CommaToken();
    internal ExpressionSyntax get_SecondExpression();
    internal PunctuationSyntax get_CloseParenToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BinaryExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax _left;
    internal SyntaxToken _operatorToken;
    internal ExpressionSyntax _right;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ExpressionSyntax Left { get; }
    internal SyntaxToken OperatorToken { get; }
    internal ExpressionSyntax Right { get; }
    private static BinaryExpressionSyntax();
    internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ExpressionSyntax get_Left();
    internal SyntaxToken get_OperatorToken();
    internal ExpressionSyntax get_Right();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Blender : Scanner {
    private Stack`1<GreenNode> _nodeStack;
    private TextChangeRange _change;
    private TextChangeRange _affectedRange;
    private VisualBasicSyntaxNode _currentNode;
    private int _curNodeStart;
    private int _curNodeLength;
    private VisualBasicSyntaxNode _baseTreeRoot;
    private PreprocessorState _currentPreprocessorState;
    private NextPreprocessorStateGetter _nextPreprocessorStateGetter;
    internal Blender(SourceText newText, TextChangeRange[] changes, SyntaxTree baseTreeRoot, VisualBasicParseOptions options);
    private static void PushReverseNonterminal(Stack`1<GreenNode> stack, GreenNode nonterminal);
    private static void PushReverseTerminal(Stack`1<GreenNode> stack, SyntaxToken tk);
    private static void PushChildReverse(Stack`1<GreenNode> stack, GreenNode child);
    private static TextSpan ExpandToNearestStatements(VisualBasicSyntaxNode root, TextSpan span);
    private static TextSpan NearestStatementThatContainsPosition(SyntaxNode node, int position, TextSpan rootFullSpan);
    private static bool IsStatementLike(SyntaxNode node);
    private static TextSpan ExpandByLookAheadAndBehind(VisualBasicSyntaxNode root, TextSpan span);
    private int MapNewPositionToOldTree(int position);
    private bool TryPopNode();
    internal virtual bool TryCrumbleOnce();
    private static bool ShouldCrumble(VisualBasicSyntaxNode node);
    private VisualBasicSyntaxNode GetCurrentNode(int position);
    internal virtual VisualBasicSyntaxNode GetCurrentSyntaxNode();
    private bool CanReuseNode(VisualBasicSyntaxNode node);
    private bool ContainsLeadingLineBreaks(VisualBasicSyntaxNode node);
    internal virtual void MoveToNextSyntaxNode();
    internal virtual void MoveToNextSyntaxNodeInTrivia();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BlockContext : object {
    private StatementSyntax _beginStatement;
    protected Parser _parser;
    protected SyntaxListBuilder`1<StatementSyntax> _statements;
    private SyntaxKind _kind;
    private SyntaxKind _endKind;
    private BlockContext _prev;
    private bool _isWithinMultiLineLambda;
    private bool _isWithinSingleLineLambda;
    private bool _isWithinAsyncMethodOrLambda;
    private bool _isWithinIteratorMethodOrLambdaOrProperty;
    private int _level;
    private ContextAwareSyntaxFactory _syntaxFactory;
    internal StatementSyntax BeginStatement { get; }
    internal bool IsLineIf { get; }
    internal bool IsWithinLambda { get; }
    internal bool IsWithinSingleLineLambda { get; }
    internal bool IsWithinAsyncMethodOrLambda { get; }
    internal bool IsWithinIteratorContext { get; }
    internal bool IsWithinIteratorMethodOrLambdaOrProperty { get; }
    internal Parser Parser { get; internal set; }
    internal ContextAwareSyntaxFactory SyntaxFactory { get; }
    internal SyntaxKind BlockKind { get; }
    internal BlockContext PrevBlock { get; }
    internal int Level { get; }
    internal SyntaxListBuilder`1<StatementSyntax> Statements { get; }
    internal bool IsSingleLine { get; }
    internal bool IsLambda { get; }
    protected BlockContext(SyntaxKind kind, StatementSyntax statement, BlockContext prev);
    internal StatementSyntax get_BeginStatement();
    internal void GetBeginEndStatements(T1& beginStmt, T2& endStmt);
    internal virtual bool KindEndsBlock(SyntaxKind kind);
    internal bool get_IsLineIf();
    internal bool get_IsWithinLambda();
    internal bool get_IsWithinSingleLineLambda();
    internal virtual override bool get_IsWithinAsyncMethodOrLambda();
    internal virtual override bool get_IsWithinIteratorContext();
    internal bool get_IsWithinIteratorMethodOrLambdaOrProperty();
    internal Parser get_Parser();
    internal void set_Parser(Parser value);
    internal ContextAwareSyntaxFactory get_SyntaxFactory();
    internal SyntaxKind get_BlockKind();
    internal BlockContext get_PrevBlock();
    internal int get_Level();
    internal void Add(VisualBasicSyntaxNode node);
    internal SyntaxListBuilder`1<StatementSyntax> get_Statements();
    internal void FreeStatements();
    internal SyntaxList`1<StatementSyntax> Body();
    internal StatementSyntax SingleStatementOrDefault();
    internal SyntaxList`1<StatementSyntax> OptionalBody();
    internal SyntaxList`1<T> Body();
    internal SyntaxList`1<StatementSyntax> BodyWithWeakChildren();
    private static bool IsLargeEnoughNonEmptyStatementList(SyntaxListBuilder`1<StatementSyntax> statements);
    internal SyntaxList`1<T> BaseDeclarations();
    internal abstract virtual StatementSyntax Parse();
    internal abstract virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode syntax);
    internal abstract virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax statement);
    internal abstract virtual BlockContext EndBlock(StatementSyntax statement);
    internal abstract virtual BlockContext RecoverFromMismatchedEnd(StatementSyntax statement);
    internal virtual BlockContext ResyncAndProcessStatementTerminator(StatementSyntax statement, BlockContext lambdaContext);
    internal abstract virtual BlockContext ProcessStatementTerminator(BlockContext lambdaContext);
    internal virtual BlockContext ProcessElseAsStatementTerminator();
    internal virtual BlockContext ProcessOtherAsStatementTerminator();
    internal abstract virtual bool get_IsSingleLine();
    internal virtual bool get_IsLambda();
    private void HandleAnyUnexpectedTokens(StatementSyntax currentStmt, SyntaxList`1<SyntaxToken> unexpected);
    internal abstract virtual LinkResult TryLinkSyntax(VisualBasicSyntaxNode node, BlockContext& newContext);
    internal BlockContext LinkSyntax(VisualBasicSyntaxNode node);
    internal LinkResult UseSyntax(VisualBasicSyntaxNode node, BlockContext& newContext, bool AddMissingTerminator);
    internal LinkResult TryUseStatement(VisualBasicSyntaxNode node, BlockContext& newContext);
    internal BlockContext TryProcessExecutableStatement(VisualBasicSyntaxNode node);
    internal LinkResult TryLinkStatement(VisualBasicSyntaxNode node, BlockContext& newContext);
    private StatementSyntax CreateMissingEnd(ERRID& errorId);
    private StatementSyntax CreateMissingEnd(SyntaxKind kind, ERRID& errorId);
    private static SyntaxKind GetEndKind(SyntaxKind kind);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.BlockContextExtensions : object {
    [ExtensionAttribute]
internal static BlockContext EndLambda(BlockContext context);
    [ExtensionAttribute]
internal static void RecoverFromMissingEnd(BlockContext context, BlockContext lastContext);
    [ExtensionAttribute]
internal static bool IsWithin(BlockContext context, SyntaxKind[] kinds);
    [ExtensionAttribute]
internal static BlockContext FindNearest(BlockContext context, Func`2<BlockContext, bool> conditionIsTrue);
    [ExtensionAttribute]
internal static BlockContext FindNearest(BlockContext context, Func`2<SyntaxKind, bool> conditionIsTrue);
    [ExtensionAttribute]
internal static BlockContext FindNearest(BlockContext context, SyntaxKind[] kinds);
    [ExtensionAttribute]
internal static BlockContext FindNearestInSameMethodScope(BlockContext context, SyntaxKind[] kinds);
    [ExtensionAttribute]
internal static BlockContext FindNearestLambdaOrSingleLineIf(BlockContext context, BlockContext lastContext);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CallStatementSyntax : ExecutableStatementSyntax {
    internal KeywordSyntax _callKeyword;
    internal ExpressionSyntax _invocation;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax CallKeyword { get; }
    internal ExpressionSyntax Invocation { get; }
    private static CallStatementSyntax();
    internal CallStatementSyntax(SyntaxKind kind, KeywordSyntax callKeyword, ExpressionSyntax invocation);
    internal CallStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax callKeyword, ExpressionSyntax invocation);
    internal CallStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax callKeyword, ExpressionSyntax invocation);
    internal CallStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_CallKeyword();
    internal ExpressionSyntax get_Invocation();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CaseBlockContext : ExecutableStatementContext {
    internal CaseBlockContext(SyntaxKind contextKind, StatementSyntax statement, BlockContext prevContext);
    internal virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode node);
    internal virtual LinkResult TryLinkSyntax(VisualBasicSyntaxNode node, BlockContext& newContext);
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax endStmt);
    internal virtual BlockContext EndBlock(StatementSyntax endStmt);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CaseBlockSyntax : VisualBasicSyntaxNode {
    internal CaseStatementSyntax _caseStatement;
    internal GreenNode _statements;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal CaseStatementSyntax CaseStatement { get; }
    internal SyntaxList`1<StatementSyntax> Statements { get; }
    private static CaseBlockSyntax();
    internal CaseBlockSyntax(SyntaxKind kind, CaseStatementSyntax caseStatement, GreenNode statements);
    internal CaseBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, CaseStatementSyntax caseStatement, GreenNode statements);
    internal CaseBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, CaseStatementSyntax caseStatement, GreenNode statements);
    internal CaseBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal CaseStatementSyntax get_CaseStatement();
    internal SyntaxList`1<StatementSyntax> get_Statements();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CaseClauseSyntax : VisualBasicSyntaxNode {
    internal CaseClauseSyntax(SyntaxKind kind);
    internal CaseClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal CaseClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal CaseClauseSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CaseStatementSyntax : StatementSyntax {
    internal KeywordSyntax _caseKeyword;
    internal GreenNode _cases;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax CaseKeyword { get; }
    internal SeparatedSyntaxList`1<CaseClauseSyntax> Cases { get; }
    private static CaseStatementSyntax();
    internal CaseStatementSyntax(SyntaxKind kind, KeywordSyntax caseKeyword, GreenNode cases);
    internal CaseStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax caseKeyword, GreenNode cases);
    internal CaseStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax caseKeyword, GreenNode cases);
    internal CaseStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_CaseKeyword();
    internal SeparatedSyntaxList`1<CaseClauseSyntax> get_Cases();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CastExpressionSyntax : ExpressionSyntax {
    internal KeywordSyntax _keyword;
    internal PunctuationSyntax _openParenToken;
    internal ExpressionSyntax _expression;
    internal PunctuationSyntax _commaToken;
    internal TypeSyntax _type;
    internal PunctuationSyntax _closeParenToken;
    internal KeywordSyntax Keyword { get; }
    internal PunctuationSyntax OpenParenToken { get; }
    internal ExpressionSyntax Expression { get; }
    internal PunctuationSyntax CommaToken { get; }
    internal TypeSyntax Type { get; }
    internal PunctuationSyntax CloseParenToken { get; }
    internal CastExpressionSyntax(SyntaxKind kind, KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal CastExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal CastExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal CastExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal KeywordSyntax get_Keyword();
    internal PunctuationSyntax get_OpenParenToken();
    internal ExpressionSyntax get_Expression();
    internal PunctuationSyntax get_CommaToken();
    internal TypeSyntax get_Type();
    internal PunctuationSyntax get_CloseParenToken();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CatchBlockSyntax : VisualBasicSyntaxNode {
    internal CatchStatementSyntax _catchStatement;
    internal GreenNode _statements;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal CatchStatementSyntax CatchStatement { get; }
    internal SyntaxList`1<StatementSyntax> Statements { get; }
    private static CatchBlockSyntax();
    internal CatchBlockSyntax(SyntaxKind kind, CatchStatementSyntax catchStatement, GreenNode statements);
    internal CatchBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, CatchStatementSyntax catchStatement, GreenNode statements);
    internal CatchBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, CatchStatementSyntax catchStatement, GreenNode statements);
    internal CatchBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal CatchStatementSyntax get_CatchStatement();
    internal SyntaxList`1<StatementSyntax> get_Statements();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CatchFilterClauseSyntax : VisualBasicSyntaxNode {
    internal KeywordSyntax _whenKeyword;
    internal ExpressionSyntax _filter;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax WhenKeyword { get; }
    internal ExpressionSyntax Filter { get; }
    private static CatchFilterClauseSyntax();
    internal CatchFilterClauseSyntax(SyntaxKind kind, KeywordSyntax whenKeyword, ExpressionSyntax filter);
    internal CatchFilterClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax whenKeyword, ExpressionSyntax filter);
    internal CatchFilterClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax whenKeyword, ExpressionSyntax filter);
    internal CatchFilterClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_WhenKeyword();
    internal ExpressionSyntax get_Filter();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CatchPartContext : ExecutableStatementContext {
    internal CatchPartContext(StatementSyntax statement, BlockContext prevContext);
    internal virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode node);
    internal virtual LinkResult TryLinkSyntax(VisualBasicSyntaxNode node, BlockContext& newContext);
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax statement);
    internal virtual BlockContext EndBlock(StatementSyntax statement);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CatchStatementSyntax : StatementSyntax {
    internal KeywordSyntax _catchKeyword;
    internal IdentifierNameSyntax _identifierName;
    internal SimpleAsClauseSyntax _asClause;
    internal CatchFilterClauseSyntax _whenClause;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax CatchKeyword { get; }
    internal IdentifierNameSyntax IdentifierName { get; }
    internal SimpleAsClauseSyntax AsClause { get; }
    internal CatchFilterClauseSyntax WhenClause { get; }
    private static CatchStatementSyntax();
    internal CatchStatementSyntax(SyntaxKind kind, KeywordSyntax catchKeyword, IdentifierNameSyntax identifierName, SimpleAsClauseSyntax asClause, CatchFilterClauseSyntax whenClause);
    internal CatchStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax catchKeyword, IdentifierNameSyntax identifierName, SimpleAsClauseSyntax asClause, CatchFilterClauseSyntax whenClause);
    internal CatchStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax catchKeyword, IdentifierNameSyntax identifierName, SimpleAsClauseSyntax asClause, CatchFilterClauseSyntax whenClause);
    internal CatchStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_CatchKeyword();
    internal IdentifierNameSyntax get_IdentifierName();
    internal SimpleAsClauseSyntax get_AsClause();
    internal CatchFilterClauseSyntax get_WhenClause();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CConst : object {
    protected ERRID _errid;
    protected Object[] _diagnosticArguments;
    public SpecialType SpecialType { get; }
    public object ValueAsObject { get; }
    public bool IsBad { get; }
    public bool IsBooleanTrue { get; }
    public ERRID ErrorId { get; }
    public Object[] ErrorArgs { get; }
    public CConst(ERRID id, Object[] diagnosticArguments);
    public abstract virtual SpecialType get_SpecialType();
    public abstract virtual object get_ValueAsObject();
    public abstract virtual CConst WithError(ERRID id);
    internal static CConst CreateChecked(object value);
    internal static CConst TryCreate(object value);
    internal static CConst`1<object> CreateNothing();
    internal static CConst`1<bool> Create(bool value);
    internal static CConst`1<byte> Create(byte value);
    internal static CConst`1<sbyte> Create(sbyte value);
    internal static CConst`1<char> Create(char value);
    internal static CConst`1<short> Create(short value);
    internal static CConst`1<ushort> Create(ushort value);
    internal static CConst`1<int> Create(int value);
    internal static CConst`1<UInt32> Create(UInt32 value);
    internal static CConst`1<long> Create(long value);
    internal static CConst`1<ulong> Create(ulong value);
    internal static CConst`1<decimal> Create(decimal value);
    internal static CConst`1<string> Create(string value);
    internal static CConst`1<float> Create(float value);
    internal static CConst`1<double> Create(double value);
    internal static CConst`1<DateTime> Create(DateTime value);
    public bool get_IsBad();
    public bool get_IsBooleanTrue();
    public ERRID get_ErrorId();
    public Object[] get_ErrorArgs();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CConst`1 : CConst {
    private SpecialType _specialType;
    private T _value;
    public SpecialType SpecialType { get; }
    public object ValueAsObject { get; }
    public T Value { get; }
    internal CConst`1(T value, SpecialType specialType);
    private CConst`1(T value, SpecialType specialType, ERRID id);
    public virtual SpecialType get_SpecialType();
    public virtual object get_ValueAsObject();
    public T get_Value();
    public virtual CConst WithError(ERRID id);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CharacterLiteralTokenSyntax : SyntaxToken {
    internal char _value;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal object ObjectValue { get; }
    internal char Value { get; }
    private static CharacterLiteralTokenSyntax();
    internal CharacterLiteralTokenSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, char value);
    internal CharacterLiteralTokenSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, ISyntaxFactoryContext context, char value);
    internal CharacterLiteralTokenSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, char value);
    internal CharacterLiteralTokenSyntax(ObjectReader reader);
    internal sealed virtual object get_ObjectValue();
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal char get_Value();
    public virtual GreenNode WithLeadingTrivia(GreenNode trivia);
    public virtual GreenNode WithTrailingTrivia(GreenNode trivia);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ChildSyntaxList : ValueType {
    private VisualBasicSyntaxNode _node;
    internal ChildSyntaxList(VisualBasicSyntaxNode node);
    public Enumerator GetEnumerator();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ClassBlockSyntax : TypeBlockSyntax {
    internal ClassStatementSyntax _classStatement;
    internal EndBlockStatementSyntax _endClassStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    public TypeStatementSyntax BlockStatement { get; }
    public EndBlockStatementSyntax EndBlockStatement { get; }
    internal ClassStatementSyntax ClassStatement { get; }
    internal EndBlockStatementSyntax EndClassStatement { get; }
    private static ClassBlockSyntax();
    internal ClassBlockSyntax(SyntaxKind kind, ClassStatementSyntax classStatement, GreenNode inherits, GreenNode implements, GreenNode members, EndBlockStatementSyntax endClassStatement);
    internal ClassBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ClassStatementSyntax classStatement, GreenNode inherits, GreenNode implements, GreenNode members, EndBlockStatementSyntax endClassStatement);
    internal ClassBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ClassStatementSyntax classStatement, GreenNode inherits, GreenNode implements, GreenNode members, EndBlockStatementSyntax endClassStatement);
    internal ClassBlockSyntax(ObjectReader reader);
    public virtual TypeStatementSyntax get_BlockStatement();
    public virtual EndBlockStatementSyntax get_EndBlockStatement();
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ClassStatementSyntax get_ClassStatement();
    internal EndBlockStatementSyntax get_EndClassStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ClassStatementSyntax : TypeStatementSyntax {
    internal KeywordSyntax _classKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ClassKeyword { get; }
    private static ClassStatementSyntax();
    internal ClassStatementSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax classKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal ClassStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax classKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal ClassStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax classKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal ClassStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ClassKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionInitializerSyntax : ExpressionSyntax {
    internal PunctuationSyntax _openBraceToken;
    internal GreenNode _initializers;
    internal PunctuationSyntax _closeBraceToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax OpenBraceToken { get; }
    internal SeparatedSyntaxList`1<ExpressionSyntax> Initializers { get; }
    internal PunctuationSyntax CloseBraceToken { get; }
    private static CollectionInitializerSyntax();
    internal CollectionInitializerSyntax(SyntaxKind kind, PunctuationSyntax openBraceToken, GreenNode initializers, PunctuationSyntax closeBraceToken);
    internal CollectionInitializerSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax openBraceToken, GreenNode initializers, PunctuationSyntax closeBraceToken);
    internal CollectionInitializerSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax openBraceToken, GreenNode initializers, PunctuationSyntax closeBraceToken);
    internal CollectionInitializerSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_OpenBraceToken();
    internal SeparatedSyntaxList`1<ExpressionSyntax> get_Initializers();
    internal PunctuationSyntax get_CloseBraceToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CollectionRangeVariableSyntax : VisualBasicSyntaxNode {
    internal ModifiedIdentifierSyntax _identifier;
    internal SimpleAsClauseSyntax _asClause;
    internal KeywordSyntax _inKeyword;
    internal ExpressionSyntax _expression;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ModifiedIdentifierSyntax Identifier { get; }
    internal SimpleAsClauseSyntax AsClause { get; }
    internal KeywordSyntax InKeyword { get; }
    internal ExpressionSyntax Expression { get; }
    private static CollectionRangeVariableSyntax();
    internal CollectionRangeVariableSyntax(SyntaxKind kind, ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, KeywordSyntax inKeyword, ExpressionSyntax expression);
    internal CollectionRangeVariableSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, KeywordSyntax inKeyword, ExpressionSyntax expression);
    internal CollectionRangeVariableSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, KeywordSyntax inKeyword, ExpressionSyntax expression);
    internal CollectionRangeVariableSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ModifiedIdentifierSyntax get_Identifier();
    internal SimpleAsClauseSyntax get_AsClause();
    internal KeywordSyntax get_InKeyword();
    internal ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CompilationUnitContext : NamespaceBlockContext {
    private SyntaxList`1<OptionStatementSyntax> _optionStmts;
    private SyntaxList`1<ImportsStatementSyntax> _importsStmts;
    private SyntaxList`1<AttributesStatementSyntax> _attributeStmts;
    private SyntaxKind _state;
    internal bool IsWithinAsyncMethodOrLambda { get; }
    internal CompilationUnitContext(Parser parser);
    internal virtual bool get_IsWithinAsyncMethodOrLambda();
    internal virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode node);
    internal virtual LinkResult TryLinkSyntax(VisualBasicSyntaxNode node, BlockContext& newContext);
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax endStmt);
    internal CompilationUnitSyntax CreateCompilationUnit(PunctuationSyntax optionalTerminator, ArrayBuilder`1<IfDirectiveTriviaSyntax> notClosedIfDirectives, ArrayBuilder`1<RegionDirectiveTriviaSyntax> notClosedRegionDirectives, bool haveRegionDirectives, ExternalSourceDirectiveTriviaSyntax notClosedExternalSourceDirective);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CompilationUnitSyntax : VisualBasicSyntaxNode {
    internal GreenNode _options;
    internal GreenNode _imports;
    internal GreenNode _attributes;
    internal GreenNode _members;
    internal PunctuationSyntax _endOfFileToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxList`1<OptionStatementSyntax> Options { get; }
    internal SyntaxList`1<ImportsStatementSyntax> Imports { get; }
    internal SyntaxList`1<AttributesStatementSyntax> Attributes { get; }
    internal SyntaxList`1<StatementSyntax> Members { get; }
    internal PunctuationSyntax EndOfFileToken { get; }
    private static CompilationUnitSyntax();
    internal CompilationUnitSyntax(SyntaxKind kind, GreenNode options, GreenNode imports, GreenNode attributes, GreenNode members, PunctuationSyntax endOfFileToken);
    internal CompilationUnitSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode options, GreenNode imports, GreenNode attributes, GreenNode members, PunctuationSyntax endOfFileToken);
    internal CompilationUnitSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode options, GreenNode imports, GreenNode attributes, GreenNode members, PunctuationSyntax endOfFileToken);
    internal CompilationUnitSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SyntaxList`1<OptionStatementSyntax> get_Options();
    internal SyntaxList`1<ImportsStatementSyntax> get_Imports();
    internal SyntaxList`1<AttributesStatementSyntax> get_Attributes();
    internal SyntaxList`1<StatementSyntax> get_Members();
    internal PunctuationSyntax get_EndOfFileToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ComplexIdentifierSyntax : IdentifierTokenSyntax {
    private SyntaxKind _possibleKeywordKind;
    private bool _isBracketed;
    private string _identifierText;
    private TypeCharacter _typeCharacter;
    internal SyntaxKind PossibleKeywordKind { get; }
    public int RawContextualKind { get; }
    internal bool IsBracketed { get; }
    internal string IdentifierText { get; }
    internal TypeCharacter TypeCharacter { get; }
    internal ComplexIdentifierSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, string text, VisualBasicSyntaxNode precedingTrivia, VisualBasicSyntaxNode followingTrivia, SyntaxKind possibleKeywordKind, bool isBracketed, string identifierText, TypeCharacter typeCharacter);
    internal ComplexIdentifierSyntax(ObjectReader reader);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual SyntaxKind get_PossibleKeywordKind();
    public virtual int get_RawContextualKind();
    internal virtual bool get_IsBracketed();
    internal virtual string get_IdentifierText();
    internal virtual TypeCharacter get_TypeCharacter();
    public virtual GreenNode WithLeadingTrivia(GreenNode trivia);
    public virtual GreenNode WithTrailingTrivia(GreenNode trivia);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConditionalAccessExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax _expression;
    internal PunctuationSyntax _questionMarkToken;
    internal ExpressionSyntax _whenNotNull;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ExpressionSyntax Expression { get; }
    internal PunctuationSyntax QuestionMarkToken { get; }
    internal ExpressionSyntax WhenNotNull { get; }
    private static ConditionalAccessExpressionSyntax();
    internal ConditionalAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, PunctuationSyntax questionMarkToken, ExpressionSyntax whenNotNull);
    internal ConditionalAccessExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ExpressionSyntax expression, PunctuationSyntax questionMarkToken, ExpressionSyntax whenNotNull);
    internal ConditionalAccessExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax expression, PunctuationSyntax questionMarkToken, ExpressionSyntax whenNotNull);
    internal ConditionalAccessExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ExpressionSyntax get_Expression();
    internal PunctuationSyntax get_QuestionMarkToken();
    internal ExpressionSyntax get_WhenNotNull();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConstDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal KeywordSyntax _constKeyword;
    internal IdentifierTokenSyntax _name;
    internal PunctuationSyntax _equalsToken;
    internal ExpressionSyntax _value;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ConstKeyword { get; }
    internal IdentifierTokenSyntax Name { get; }
    internal PunctuationSyntax EqualsToken { get; }
    internal ExpressionSyntax Value { get; }
    private static ConstDirectiveTriviaSyntax();
    internal ConstDirectiveTriviaSyntax(SyntaxKind kind, PunctuationSyntax hashToken, KeywordSyntax constKeyword, IdentifierTokenSyntax name, PunctuationSyntax equalsToken, ExpressionSyntax value);
    internal ConstDirectiveTriviaSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax hashToken, KeywordSyntax constKeyword, IdentifierTokenSyntax name, PunctuationSyntax equalsToken, ExpressionSyntax value);
    internal ConstDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax constKeyword, IdentifierTokenSyntax name, PunctuationSyntax equalsToken, ExpressionSyntax value);
    internal ConstDirectiveTriviaSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ConstKeyword();
    internal IdentifierTokenSyntax get_Name();
    internal PunctuationSyntax get_EqualsToken();
    internal ExpressionSyntax get_Value();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConstraintSyntax : VisualBasicSyntaxNode {
    internal ConstraintSyntax(SyntaxKind kind);
    internal ConstraintSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal ConstraintSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal ConstraintSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ConstructorBlockSyntax : MethodBlockBaseSyntax {
    internal SubNewStatementSyntax _subNewStatement;
    internal EndBlockStatementSyntax _endSubStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    public MethodBaseSyntax Begin { get; }
    public EndBlockStatementSyntax End { get; }
    internal SubNewStatementSyntax SubNewStatement { get; }
    internal EndBlockStatementSyntax EndSubStatement { get; }
    private static ConstructorBlockSyntax();
    internal ConstructorBlockSyntax(SyntaxKind kind, SubNewStatementSyntax subNewStatement, GreenNode statements, EndBlockStatementSyntax endSubStatement);
    internal ConstructorBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, SubNewStatementSyntax subNewStatement, GreenNode statements, EndBlockStatementSyntax endSubStatement);
    internal ConstructorBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SubNewStatementSyntax subNewStatement, GreenNode statements, EndBlockStatementSyntax endSubStatement);
    internal ConstructorBlockSyntax(ObjectReader reader);
    public virtual MethodBaseSyntax get_Begin();
    public virtual EndBlockStatementSyntax get_End();
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SubNewStatementSyntax get_SubNewStatement();
    internal EndBlockStatementSyntax get_EndSubStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContextAwareSyntaxFactory : object {
    private ISyntaxFactoryContext _factoryContext;
    public ContextAwareSyntaxFactory(ISyntaxFactoryContext factoryContext);
    internal EmptyStatementSyntax EmptyStatement(PunctuationSyntax empty);
    internal EndBlockStatementSyntax EndIfStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndUsingStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndWithStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndSelectStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndStructureStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndEnumStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndInterfaceStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndClassStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndModuleStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndNamespaceStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndSubStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndFunctionStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndGetStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndSetStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndPropertyStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndOperatorStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndEventStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndAddHandlerStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndRemoveHandlerStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndRaiseEventStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndWhileStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndTryStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndSyncLockStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax EndBlockStatement(SyntaxKind kind, KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal CompilationUnitSyntax CompilationUnit(SyntaxList`1<VisualBasicSyntaxNode> options, SyntaxList`1<VisualBasicSyntaxNode> imports, SyntaxList`1<VisualBasicSyntaxNode> attributes, SyntaxList`1<VisualBasicSyntaxNode> members, PunctuationSyntax endOfFileToken);
    internal OptionStatementSyntax OptionStatement(KeywordSyntax optionKeyword, KeywordSyntax nameKeyword, KeywordSyntax valueKeyword);
    internal ImportsStatementSyntax ImportsStatement(KeywordSyntax importsKeyword, SeparatedSyntaxList`1<ImportsClauseSyntax> importsClauses);
    internal SimpleImportsClauseSyntax SimpleImportsClause(ImportAliasClauseSyntax alias, NameSyntax name);
    internal ImportAliasClauseSyntax ImportAliasClause(IdentifierTokenSyntax identifier, PunctuationSyntax equalsToken);
    internal XmlNamespaceImportsClauseSyntax XmlNamespaceImportsClause(PunctuationSyntax lessThanToken, XmlAttributeSyntax xmlNamespace, PunctuationSyntax greaterThanToken);
    internal NamespaceBlockSyntax NamespaceBlock(NamespaceStatementSyntax namespaceStatement, SyntaxList`1<VisualBasicSyntaxNode> members, EndBlockStatementSyntax endNamespaceStatement);
    internal NamespaceStatementSyntax NamespaceStatement(KeywordSyntax namespaceKeyword, NameSyntax name);
    internal ModuleBlockSyntax ModuleBlock(ModuleStatementSyntax moduleStatement, SyntaxList`1<VisualBasicSyntaxNode> inherits, SyntaxList`1<VisualBasicSyntaxNode> implements, SyntaxList`1<VisualBasicSyntaxNode> members, EndBlockStatementSyntax endModuleStatement);
    internal StructureBlockSyntax StructureBlock(StructureStatementSyntax structureStatement, SyntaxList`1<VisualBasicSyntaxNode> inherits, SyntaxList`1<VisualBasicSyntaxNode> implements, SyntaxList`1<VisualBasicSyntaxNode> members, EndBlockStatementSyntax endStructureStatement);
    internal InterfaceBlockSyntax InterfaceBlock(InterfaceStatementSyntax interfaceStatement, SyntaxList`1<VisualBasicSyntaxNode> inherits, SyntaxList`1<VisualBasicSyntaxNode> implements, SyntaxList`1<VisualBasicSyntaxNode> members, EndBlockStatementSyntax endInterfaceStatement);
    internal ClassBlockSyntax ClassBlock(ClassStatementSyntax classStatement, SyntaxList`1<VisualBasicSyntaxNode> inherits, SyntaxList`1<VisualBasicSyntaxNode> implements, SyntaxList`1<VisualBasicSyntaxNode> members, EndBlockStatementSyntax endClassStatement);
    internal EnumBlockSyntax EnumBlock(EnumStatementSyntax enumStatement, SyntaxList`1<VisualBasicSyntaxNode> members, EndBlockStatementSyntax endEnumStatement);
    internal InheritsStatementSyntax InheritsStatement(KeywordSyntax inheritsKeyword, SeparatedSyntaxList`1<TypeSyntax> types);
    internal ImplementsStatementSyntax ImplementsStatement(KeywordSyntax implementsKeyword, SeparatedSyntaxList`1<TypeSyntax> types);
    internal ModuleStatementSyntax ModuleStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax moduleKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal StructureStatementSyntax StructureStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax structureKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal InterfaceStatementSyntax InterfaceStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax interfaceKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal ClassStatementSyntax ClassStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax classKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal EnumStatementSyntax EnumStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax enumKeyword, IdentifierTokenSyntax identifier, AsClauseSyntax underlyingType);
    internal TypeParameterListSyntax TypeParameterList(PunctuationSyntax openParenToken, KeywordSyntax ofKeyword, SeparatedSyntaxList`1<TypeParameterSyntax> parameters, PunctuationSyntax closeParenToken);
    internal TypeParameterSyntax TypeParameter(KeywordSyntax varianceKeyword, IdentifierTokenSyntax identifier, TypeParameterConstraintClauseSyntax typeParameterConstraintClause);
    internal TypeParameterSingleConstraintClauseSyntax TypeParameterSingleConstraintClause(KeywordSyntax asKeyword, ConstraintSyntax constraint);
    internal TypeParameterMultipleConstraintClauseSyntax TypeParameterMultipleConstraintClause(KeywordSyntax asKeyword, PunctuationSyntax openBraceToken, SeparatedSyntaxList`1<ConstraintSyntax> constraints, PunctuationSyntax closeBraceToken);
    internal SpecialConstraintSyntax NewConstraint(KeywordSyntax constraintKeyword);
    internal SpecialConstraintSyntax ClassConstraint(KeywordSyntax constraintKeyword);
    internal SpecialConstraintSyntax StructureConstraint(KeywordSyntax constraintKeyword);
    internal SpecialConstraintSyntax SpecialConstraint(SyntaxKind kind, KeywordSyntax constraintKeyword);
    internal TypeConstraintSyntax TypeConstraint(TypeSyntax type);
    internal EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, IdentifierTokenSyntax identifier, EqualsValueSyntax initializer);
    internal MethodBlockSyntax SubBlock(MethodStatementSyntax subOrFunctionStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    internal MethodBlockSyntax FunctionBlock(MethodStatementSyntax subOrFunctionStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    internal MethodBlockSyntax MethodBlock(SyntaxKind kind, MethodStatementSyntax subOrFunctionStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    internal ConstructorBlockSyntax ConstructorBlock(SubNewStatementSyntax subNewStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endSubStatement);
    internal OperatorBlockSyntax OperatorBlock(OperatorStatementSyntax operatorStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endOperatorStatement);
    internal AccessorBlockSyntax GetAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endAccessorStatement);
    internal AccessorBlockSyntax SetAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endAccessorStatement);
    internal AccessorBlockSyntax AddHandlerAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endAccessorStatement);
    internal AccessorBlockSyntax RemoveHandlerAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endAccessorStatement);
    internal AccessorBlockSyntax RaiseEventAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endAccessorStatement);
    internal AccessorBlockSyntax AccessorBlock(SyntaxKind kind, AccessorStatementSyntax accessorStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endAccessorStatement);
    internal PropertyBlockSyntax PropertyBlock(PropertyStatementSyntax propertyStatement, SyntaxList`1<VisualBasicSyntaxNode> accessors, EndBlockStatementSyntax endPropertyStatement);
    internal EventBlockSyntax EventBlock(EventStatementSyntax eventStatement, SyntaxList`1<VisualBasicSyntaxNode> accessors, EndBlockStatementSyntax endEventStatement);
    internal ParameterListSyntax ParameterList(PunctuationSyntax openParenToken, SeparatedSyntaxList`1<ParameterSyntax> parameters, PunctuationSyntax closeParenToken);
    internal MethodStatementSyntax SubStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, HandlesClauseSyntax handlesClause, ImplementsClauseSyntax implementsClause);
    internal MethodStatementSyntax FunctionStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, HandlesClauseSyntax handlesClause, ImplementsClauseSyntax implementsClause);
    internal MethodStatementSyntax MethodStatement(SyntaxKind kind, SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, HandlesClauseSyntax handlesClause, ImplementsClauseSyntax implementsClause);
    internal SubNewStatementSyntax SubNewStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax subKeyword, KeywordSyntax newKeyword, ParameterListSyntax parameterList);
    internal DeclareStatementSyntax DeclareSubStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax declareKeyword, KeywordSyntax charsetKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, KeywordSyntax libKeyword, LiteralExpressionSyntax libraryName, KeywordSyntax aliasKeyword, LiteralExpressionSyntax aliasName, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal DeclareStatementSyntax DeclareFunctionStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax declareKeyword, KeywordSyntax charsetKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, KeywordSyntax libKeyword, LiteralExpressionSyntax libraryName, KeywordSyntax aliasKeyword, LiteralExpressionSyntax aliasName, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal DeclareStatementSyntax DeclareStatement(SyntaxKind kind, SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax declareKeyword, KeywordSyntax charsetKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, KeywordSyntax libKeyword, LiteralExpressionSyntax libraryName, KeywordSyntax aliasKeyword, LiteralExpressionSyntax aliasName, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal DelegateStatementSyntax DelegateSubStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax delegateKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal DelegateStatementSyntax DelegateFunctionStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax delegateKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal DelegateStatementSyntax DelegateStatement(SyntaxKind kind, SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax delegateKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal EventStatementSyntax EventStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax customKeyword, KeywordSyntax eventKeyword, IdentifierTokenSyntax identifier, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, ImplementsClauseSyntax implementsClause);
    internal OperatorStatementSyntax OperatorStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal PropertyStatementSyntax PropertyStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax propertyKeyword, IdentifierTokenSyntax identifier, ParameterListSyntax parameterList, AsClauseSyntax asClause, EqualsValueSyntax initializer, ImplementsClauseSyntax implementsClause);
    internal AccessorStatementSyntax GetAccessorStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax accessorKeyword, ParameterListSyntax parameterList);
    internal AccessorStatementSyntax SetAccessorStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax accessorKeyword, ParameterListSyntax parameterList);
    internal AccessorStatementSyntax AddHandlerAccessorStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax accessorKeyword, ParameterListSyntax parameterList);
    internal AccessorStatementSyntax RemoveHandlerAccessorStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax accessorKeyword, ParameterListSyntax parameterList);
    internal AccessorStatementSyntax RaiseEventAccessorStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax accessorKeyword, ParameterListSyntax parameterList);
    internal AccessorStatementSyntax AccessorStatement(SyntaxKind kind, SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax accessorKeyword, ParameterListSyntax parameterList);
    internal ImplementsClauseSyntax ImplementsClause(KeywordSyntax implementsKeyword, SeparatedSyntaxList`1<QualifiedNameSyntax> interfaceMembers);
    internal HandlesClauseSyntax HandlesClause(KeywordSyntax handlesKeyword, SeparatedSyntaxList`1<HandlesClauseItemSyntax> events);
    internal KeywordEventContainerSyntax KeywordEventContainer(KeywordSyntax keyword);
    internal WithEventsEventContainerSyntax WithEventsEventContainer(IdentifierTokenSyntax identifier);
    internal WithEventsPropertyEventContainerSyntax WithEventsPropertyEventContainer(WithEventsEventContainerSyntax withEventsContainer, PunctuationSyntax dotToken, IdentifierNameSyntax property);
    internal HandlesClauseItemSyntax HandlesClauseItem(EventContainerSyntax eventContainer, PunctuationSyntax dotToken, IdentifierNameSyntax eventMember);
    internal IncompleteMemberSyntax IncompleteMember(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, IdentifierTokenSyntax missingIdentifier);
    internal FieldDeclarationSyntax FieldDeclaration(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, SeparatedSyntaxList`1<VariableDeclaratorSyntax> declarators);
    internal VariableDeclaratorSyntax VariableDeclarator(SeparatedSyntaxList`1<ModifiedIdentifierSyntax> names, AsClauseSyntax asClause, EqualsValueSyntax initializer);
    internal SimpleAsClauseSyntax SimpleAsClause(KeywordSyntax asKeyword, SyntaxList`1<VisualBasicSyntaxNode> attributeLists, TypeSyntax type);
    internal AsNewClauseSyntax AsNewClause(KeywordSyntax asKeyword, NewExpressionSyntax newExpression);
    internal ObjectMemberInitializerSyntax ObjectMemberInitializer(KeywordSyntax withKeyword, PunctuationSyntax openBraceToken, SeparatedSyntaxList`1<FieldInitializerSyntax> initializers, PunctuationSyntax closeBraceToken);
    internal ObjectCollectionInitializerSyntax ObjectCollectionInitializer(KeywordSyntax fromKeyword, CollectionInitializerSyntax initializer);
    internal InferredFieldInitializerSyntax InferredFieldInitializer(KeywordSyntax keyKeyword, ExpressionSyntax expression);
    internal NamedFieldInitializerSyntax NamedFieldInitializer(KeywordSyntax keyKeyword, PunctuationSyntax dotToken, IdentifierNameSyntax name, PunctuationSyntax equalsToken, ExpressionSyntax expression);
    internal EqualsValueSyntax EqualsValue(PunctuationSyntax equalsToken, ExpressionSyntax value);
    internal ParameterSyntax Parameter(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, EqualsValueSyntax default);
    internal ModifiedIdentifierSyntax ModifiedIdentifier(IdentifierTokenSyntax identifier, PunctuationSyntax nullable, ArgumentListSyntax arrayBounds, SyntaxList`1<VisualBasicSyntaxNode> arrayRankSpecifiers);
    internal ArrayRankSpecifierSyntax ArrayRankSpecifier(PunctuationSyntax openParenToken, SyntaxList`1<VisualBasicSyntaxNode> commaTokens, PunctuationSyntax closeParenToken);
    internal AttributeListSyntax AttributeList(PunctuationSyntax lessThanToken, SeparatedSyntaxList`1<AttributeSyntax> attributes, PunctuationSyntax greaterThanToken);
    internal AttributeSyntax Attribute(AttributeTargetSyntax target, TypeSyntax name, ArgumentListSyntax argumentList);
    internal AttributeTargetSyntax AttributeTarget(KeywordSyntax attributeModifier, PunctuationSyntax colonToken);
    internal AttributesStatementSyntax AttributesStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists);
    internal ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression);
    internal PrintStatementSyntax PrintStatement(PunctuationSyntax questionToken, ExpressionSyntax expression);
    internal WhileBlockSyntax WhileBlock(WhileStatementSyntax whileStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endWhileStatement);
    internal UsingBlockSyntax UsingBlock(UsingStatementSyntax usingStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endUsingStatement);
    internal SyncLockBlockSyntax SyncLockBlock(SyncLockStatementSyntax syncLockStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endSyncLockStatement);
    internal WithBlockSyntax WithBlock(WithStatementSyntax withStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endWithStatement);
    internal LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxList`1<VisualBasicSyntaxNode> modifiers, SeparatedSyntaxList`1<VariableDeclaratorSyntax> declarators);
    internal LabelStatementSyntax LabelStatement(SyntaxToken labelToken, PunctuationSyntax colonToken);
    internal GoToStatementSyntax GoToStatement(KeywordSyntax goToKeyword, LabelSyntax label);
    internal LabelSyntax IdentifierLabel(SyntaxToken labelToken);
    internal LabelSyntax NumericLabel(SyntaxToken labelToken);
    internal LabelSyntax NextLabel(SyntaxToken labelToken);
    internal LabelSyntax Label(SyntaxKind kind, SyntaxToken labelToken);
    internal StopOrEndStatementSyntax StopStatement(KeywordSyntax stopOrEndKeyword);
    internal StopOrEndStatementSyntax EndStatement(KeywordSyntax stopOrEndKeyword);
    internal StopOrEndStatementSyntax StopOrEndStatement(SyntaxKind kind, KeywordSyntax stopOrEndKeyword);
    internal ExitStatementSyntax ExitDoStatement(KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal ExitStatementSyntax ExitForStatement(KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal ExitStatementSyntax ExitSubStatement(KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal ExitStatementSyntax ExitFunctionStatement(KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal ExitStatementSyntax ExitOperatorStatement(KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal ExitStatementSyntax ExitPropertyStatement(KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal ExitStatementSyntax ExitTryStatement(KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal ExitStatementSyntax ExitSelectStatement(KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal ExitStatementSyntax ExitWhileStatement(KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal ExitStatementSyntax ExitStatement(SyntaxKind kind, KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal ContinueStatementSyntax ContinueWhileStatement(KeywordSyntax continueKeyword, KeywordSyntax blockKeyword);
    internal ContinueStatementSyntax ContinueDoStatement(KeywordSyntax continueKeyword, KeywordSyntax blockKeyword);
    internal ContinueStatementSyntax ContinueForStatement(KeywordSyntax continueKeyword, KeywordSyntax blockKeyword);
    internal ContinueStatementSyntax ContinueStatement(SyntaxKind kind, KeywordSyntax continueKeyword, KeywordSyntax blockKeyword);
    internal ReturnStatementSyntax ReturnStatement(KeywordSyntax returnKeyword, ExpressionSyntax expression);
    internal SingleLineIfStatementSyntax SingleLineIfStatement(KeywordSyntax ifKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword, SyntaxList`1<VisualBasicSyntaxNode> statements, SingleLineElseClauseSyntax elseClause);
    internal SingleLineElseClauseSyntax SingleLineElseClause(KeywordSyntax elseKeyword, SyntaxList`1<VisualBasicSyntaxNode> statements);
    internal MultiLineIfBlockSyntax MultiLineIfBlock(IfStatementSyntax ifStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, SyntaxList`1<VisualBasicSyntaxNode> elseIfBlocks, ElseBlockSyntax elseBlock, EndBlockStatementSyntax endIfStatement);
    internal IfStatementSyntax IfStatement(KeywordSyntax ifKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    internal ElseIfBlockSyntax ElseIfBlock(ElseIfStatementSyntax elseIfStatement, SyntaxList`1<VisualBasicSyntaxNode> statements);
    internal ElseIfStatementSyntax ElseIfStatement(KeywordSyntax elseIfKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    internal ElseBlockSyntax ElseBlock(ElseStatementSyntax elseStatement, SyntaxList`1<VisualBasicSyntaxNode> statements);
    internal ElseStatementSyntax ElseStatement(KeywordSyntax elseKeyword);
    internal TryBlockSyntax TryBlock(TryStatementSyntax tryStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, SyntaxList`1<VisualBasicSyntaxNode> catchBlocks, FinallyBlockSyntax finallyBlock, EndBlockStatementSyntax endTryStatement);
    internal TryStatementSyntax TryStatement(KeywordSyntax tryKeyword);
    internal CatchBlockSyntax CatchBlock(CatchStatementSyntax catchStatement, SyntaxList`1<VisualBasicSyntaxNode> statements);
    internal CatchStatementSyntax CatchStatement(KeywordSyntax catchKeyword, IdentifierNameSyntax identifierName, SimpleAsClauseSyntax asClause, CatchFilterClauseSyntax whenClause);
    internal CatchFilterClauseSyntax CatchFilterClause(KeywordSyntax whenKeyword, ExpressionSyntax filter);
    internal FinallyBlockSyntax FinallyBlock(FinallyStatementSyntax finallyStatement, SyntaxList`1<VisualBasicSyntaxNode> statements);
    internal FinallyStatementSyntax FinallyStatement(KeywordSyntax finallyKeyword);
    internal ErrorStatementSyntax ErrorStatement(KeywordSyntax errorKeyword, ExpressionSyntax errorNumber);
    internal OnErrorGoToStatementSyntax OnErrorGoToZeroStatement(KeywordSyntax onKeyword, KeywordSyntax errorKeyword, KeywordSyntax goToKeyword, PunctuationSyntax minus, LabelSyntax label);
    internal OnErrorGoToStatementSyntax OnErrorGoToMinusOneStatement(KeywordSyntax onKeyword, KeywordSyntax errorKeyword, KeywordSyntax goToKeyword, PunctuationSyntax minus, LabelSyntax label);
    internal OnErrorGoToStatementSyntax OnErrorGoToLabelStatement(KeywordSyntax onKeyword, KeywordSyntax errorKeyword, KeywordSyntax goToKeyword, PunctuationSyntax minus, LabelSyntax label);
    internal OnErrorGoToStatementSyntax OnErrorGoToStatement(SyntaxKind kind, KeywordSyntax onKeyword, KeywordSyntax errorKeyword, KeywordSyntax goToKeyword, PunctuationSyntax minus, LabelSyntax label);
    internal OnErrorResumeNextStatementSyntax OnErrorResumeNextStatement(KeywordSyntax onKeyword, KeywordSyntax errorKeyword, KeywordSyntax resumeKeyword, KeywordSyntax nextKeyword);
    internal ResumeStatementSyntax ResumeStatement(KeywordSyntax resumeKeyword, LabelSyntax label);
    internal ResumeStatementSyntax ResumeLabelStatement(KeywordSyntax resumeKeyword, LabelSyntax label);
    internal ResumeStatementSyntax ResumeNextStatement(KeywordSyntax resumeKeyword, LabelSyntax label);
    internal SelectBlockSyntax SelectBlock(SelectStatementSyntax selectStatement, SyntaxList`1<VisualBasicSyntaxNode> caseBlocks, EndBlockStatementSyntax endSelectStatement);
    internal SelectStatementSyntax SelectStatement(KeywordSyntax selectKeyword, KeywordSyntax caseKeyword, ExpressionSyntax expression);
    internal CaseBlockSyntax CaseBlock(CaseStatementSyntax caseStatement, SyntaxList`1<VisualBasicSyntaxNode> statements);
    internal CaseBlockSyntax CaseElseBlock(CaseStatementSyntax caseStatement, SyntaxList`1<VisualBasicSyntaxNode> statements);
    internal CaseStatementSyntax CaseStatement(KeywordSyntax caseKeyword, SeparatedSyntaxList`1<CaseClauseSyntax> cases);
    internal CaseStatementSyntax CaseElseStatement(KeywordSyntax caseKeyword, SeparatedSyntaxList`1<CaseClauseSyntax> cases);
    internal ElseCaseClauseSyntax ElseCaseClause(KeywordSyntax elseKeyword);
    internal SimpleCaseClauseSyntax SimpleCaseClause(ExpressionSyntax value);
    internal RangeCaseClauseSyntax RangeCaseClause(ExpressionSyntax lowerBound, KeywordSyntax toKeyword, ExpressionSyntax upperBound);
    internal RelationalCaseClauseSyntax CaseEqualsClause(KeywordSyntax isKeyword, PunctuationSyntax operatorToken, ExpressionSyntax value);
    internal RelationalCaseClauseSyntax CaseNotEqualsClause(KeywordSyntax isKeyword, PunctuationSyntax operatorToken, ExpressionSyntax value);
    internal RelationalCaseClauseSyntax CaseLessThanClause(KeywordSyntax isKeyword, PunctuationSyntax operatorToken, ExpressionSyntax value);
    internal RelationalCaseClauseSyntax CaseLessThanOrEqualClause(KeywordSyntax isKeyword, PunctuationSyntax operatorToken, ExpressionSyntax value);
    internal RelationalCaseClauseSyntax CaseGreaterThanOrEqualClause(KeywordSyntax isKeyword, PunctuationSyntax operatorToken, ExpressionSyntax value);
    internal RelationalCaseClauseSyntax CaseGreaterThanClause(KeywordSyntax isKeyword, PunctuationSyntax operatorToken, ExpressionSyntax value);
    internal RelationalCaseClauseSyntax RelationalCaseClause(SyntaxKind kind, KeywordSyntax isKeyword, PunctuationSyntax operatorToken, ExpressionSyntax value);
    internal SyncLockStatementSyntax SyncLockStatement(KeywordSyntax syncLockKeyword, ExpressionSyntax expression);
    internal DoLoopBlockSyntax SimpleDoLoopBlock(DoStatementSyntax doStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, LoopStatementSyntax loopStatement);
    internal DoLoopBlockSyntax DoWhileLoopBlock(DoStatementSyntax doStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, LoopStatementSyntax loopStatement);
    internal DoLoopBlockSyntax DoUntilLoopBlock(DoStatementSyntax doStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, LoopStatementSyntax loopStatement);
    internal DoLoopBlockSyntax DoLoopWhileBlock(DoStatementSyntax doStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, LoopStatementSyntax loopStatement);
    internal DoLoopBlockSyntax DoLoopUntilBlock(DoStatementSyntax doStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, LoopStatementSyntax loopStatement);
    internal DoLoopBlockSyntax DoLoopBlock(SyntaxKind kind, DoStatementSyntax doStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, LoopStatementSyntax loopStatement);
    internal DoStatementSyntax SimpleDoStatement(KeywordSyntax doKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal DoStatementSyntax DoWhileStatement(KeywordSyntax doKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal DoStatementSyntax DoUntilStatement(KeywordSyntax doKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal DoStatementSyntax DoStatement(SyntaxKind kind, KeywordSyntax doKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal LoopStatementSyntax SimpleLoopStatement(KeywordSyntax loopKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal LoopStatementSyntax LoopWhileStatement(KeywordSyntax loopKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal LoopStatementSyntax LoopUntilStatement(KeywordSyntax loopKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal LoopStatementSyntax LoopStatement(SyntaxKind kind, KeywordSyntax loopKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal WhileOrUntilClauseSyntax WhileClause(KeywordSyntax whileOrUntilKeyword, ExpressionSyntax condition);
    internal WhileOrUntilClauseSyntax UntilClause(KeywordSyntax whileOrUntilKeyword, ExpressionSyntax condition);
    internal WhileOrUntilClauseSyntax WhileOrUntilClause(SyntaxKind kind, KeywordSyntax whileOrUntilKeyword, ExpressionSyntax condition);
    internal WhileStatementSyntax WhileStatement(KeywordSyntax whileKeyword, ExpressionSyntax condition);
    internal ForBlockSyntax ForBlock(ForStatementSyntax forStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, NextStatementSyntax nextStatement);
    internal ForEachBlockSyntax ForEachBlock(ForEachStatementSyntax forEachStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, NextStatementSyntax nextStatement);
    internal ForStatementSyntax ForStatement(KeywordSyntax forKeyword, VisualBasicSyntaxNode controlVariable, PunctuationSyntax equalsToken, ExpressionSyntax fromValue, KeywordSyntax toKeyword, ExpressionSyntax toValue, ForStepClauseSyntax stepClause);
    internal ForStepClauseSyntax ForStepClause(KeywordSyntax stepKeyword, ExpressionSyntax stepValue);
    internal ForEachStatementSyntax ForEachStatement(KeywordSyntax forKeyword, KeywordSyntax eachKeyword, VisualBasicSyntaxNode controlVariable, KeywordSyntax inKeyword, ExpressionSyntax expression);
    internal NextStatementSyntax NextStatement(KeywordSyntax nextKeyword, SeparatedSyntaxList`1<ExpressionSyntax> controlVariables);
    internal UsingStatementSyntax UsingStatement(KeywordSyntax usingKeyword, ExpressionSyntax expression, SeparatedSyntaxList`1<VariableDeclaratorSyntax> variables);
    internal ThrowStatementSyntax ThrowStatement(KeywordSyntax throwKeyword, ExpressionSyntax expression);
    internal AssignmentStatementSyntax SimpleAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal AssignmentStatementSyntax MidAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal AssignmentStatementSyntax AddAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal AssignmentStatementSyntax SubtractAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal AssignmentStatementSyntax MultiplyAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal AssignmentStatementSyntax DivideAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal AssignmentStatementSyntax IntegerDivideAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal AssignmentStatementSyntax ExponentiateAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal AssignmentStatementSyntax LeftShiftAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal AssignmentStatementSyntax RightShiftAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal AssignmentStatementSyntax ConcatenateAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal AssignmentStatementSyntax AssignmentStatement(SyntaxKind kind, ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal MidExpressionSyntax MidExpression(IdentifierTokenSyntax mid, ArgumentListSyntax argumentList);
    internal CallStatementSyntax CallStatement(KeywordSyntax callKeyword, ExpressionSyntax invocation);
    internal AddRemoveHandlerStatementSyntax AddHandlerStatement(KeywordSyntax addHandlerOrRemoveHandlerKeyword, ExpressionSyntax eventExpression, PunctuationSyntax commaToken, ExpressionSyntax delegateExpression);
    internal AddRemoveHandlerStatementSyntax RemoveHandlerStatement(KeywordSyntax addHandlerOrRemoveHandlerKeyword, ExpressionSyntax eventExpression, PunctuationSyntax commaToken, ExpressionSyntax delegateExpression);
    internal AddRemoveHandlerStatementSyntax AddRemoveHandlerStatement(SyntaxKind kind, KeywordSyntax addHandlerOrRemoveHandlerKeyword, ExpressionSyntax eventExpression, PunctuationSyntax commaToken, ExpressionSyntax delegateExpression);
    internal RaiseEventStatementSyntax RaiseEventStatement(KeywordSyntax raiseEventKeyword, IdentifierNameSyntax name, ArgumentListSyntax argumentList);
    internal WithStatementSyntax WithStatement(KeywordSyntax withKeyword, ExpressionSyntax expression);
    internal ReDimStatementSyntax ReDimStatement(KeywordSyntax reDimKeyword, KeywordSyntax preserveKeyword, SeparatedSyntaxList`1<RedimClauseSyntax> clauses);
    internal ReDimStatementSyntax ReDimPreserveStatement(KeywordSyntax reDimKeyword, KeywordSyntax preserveKeyword, SeparatedSyntaxList`1<RedimClauseSyntax> clauses);
    internal RedimClauseSyntax RedimClause(ExpressionSyntax expression, ArgumentListSyntax arrayBounds);
    internal EraseStatementSyntax EraseStatement(KeywordSyntax eraseKeyword, SeparatedSyntaxList`1<ExpressionSyntax> expressions);
    internal LiteralExpressionSyntax CharacterLiteralExpression(SyntaxToken token);
    internal LiteralExpressionSyntax TrueLiteralExpression(SyntaxToken token);
    internal LiteralExpressionSyntax FalseLiteralExpression(SyntaxToken token);
    internal LiteralExpressionSyntax NumericLiteralExpression(SyntaxToken token);
    internal LiteralExpressionSyntax DateLiteralExpression(SyntaxToken token);
    internal LiteralExpressionSyntax StringLiteralExpression(SyntaxToken token);
    internal LiteralExpressionSyntax NothingLiteralExpression(SyntaxToken token);
    internal LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token);
    internal ParenthesizedExpressionSyntax ParenthesizedExpression(PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax closeParenToken);
    internal MeExpressionSyntax MeExpression(KeywordSyntax keyword);
    internal MyBaseExpressionSyntax MyBaseExpression(KeywordSyntax keyword);
    internal MyClassExpressionSyntax MyClassExpression(KeywordSyntax keyword);
    internal GetTypeExpressionSyntax GetTypeExpression(KeywordSyntax getTypeKeyword, PunctuationSyntax openParenToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal TypeOfExpressionSyntax TypeOfIsExpression(KeywordSyntax typeOfKeyword, ExpressionSyntax expression, KeywordSyntax operatorToken, TypeSyntax type);
    internal TypeOfExpressionSyntax TypeOfIsNotExpression(KeywordSyntax typeOfKeyword, ExpressionSyntax expression, KeywordSyntax operatorToken, TypeSyntax type);
    internal TypeOfExpressionSyntax TypeOfExpression(SyntaxKind kind, KeywordSyntax typeOfKeyword, ExpressionSyntax expression, KeywordSyntax operatorToken, TypeSyntax type);
    internal GetXmlNamespaceExpressionSyntax GetXmlNamespaceExpression(KeywordSyntax getXmlNamespaceKeyword, PunctuationSyntax openParenToken, XmlPrefixNameSyntax name, PunctuationSyntax closeParenToken);
    internal MemberAccessExpressionSyntax SimpleMemberAccessExpression(ExpressionSyntax expression, PunctuationSyntax operatorToken, SimpleNameSyntax name);
    internal MemberAccessExpressionSyntax DictionaryAccessExpression(ExpressionSyntax expression, PunctuationSyntax operatorToken, SimpleNameSyntax name);
    internal MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, PunctuationSyntax operatorToken, SimpleNameSyntax name);
    internal XmlMemberAccessExpressionSyntax XmlElementAccessExpression(ExpressionSyntax base, PunctuationSyntax token1, PunctuationSyntax token2, PunctuationSyntax token3, XmlNodeSyntax name);
    internal XmlMemberAccessExpressionSyntax XmlDescendantAccessExpression(ExpressionSyntax base, PunctuationSyntax token1, PunctuationSyntax token2, PunctuationSyntax token3, XmlNodeSyntax name);
    internal XmlMemberAccessExpressionSyntax XmlAttributeAccessExpression(ExpressionSyntax base, PunctuationSyntax token1, PunctuationSyntax token2, PunctuationSyntax token3, XmlNodeSyntax name);
    internal XmlMemberAccessExpressionSyntax XmlMemberAccessExpression(SyntaxKind kind, ExpressionSyntax base, PunctuationSyntax token1, PunctuationSyntax token2, PunctuationSyntax token3, XmlNodeSyntax name);
    internal InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList);
    internal ObjectCreationExpressionSyntax ObjectCreationExpression(KeywordSyntax newKeyword, SyntaxList`1<VisualBasicSyntaxNode> attributeLists, TypeSyntax type, ArgumentListSyntax argumentList, ObjectCreationInitializerSyntax initializer);
    internal AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(KeywordSyntax newKeyword, SyntaxList`1<VisualBasicSyntaxNode> attributeLists, ObjectMemberInitializerSyntax initializer);
    internal ArrayCreationExpressionSyntax ArrayCreationExpression(KeywordSyntax newKeyword, SyntaxList`1<VisualBasicSyntaxNode> attributeLists, TypeSyntax type, ArgumentListSyntax arrayBounds, SyntaxList`1<VisualBasicSyntaxNode> rankSpecifiers, CollectionInitializerSyntax initializer);
    internal CollectionInitializerSyntax CollectionInitializer(PunctuationSyntax openBraceToken, SeparatedSyntaxList`1<ExpressionSyntax> initializers, PunctuationSyntax closeBraceToken);
    internal CTypeExpressionSyntax CTypeExpression(KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal DirectCastExpressionSyntax DirectCastExpression(KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal TryCastExpressionSyntax TryCastExpression(KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal PredefinedCastExpressionSyntax PredefinedCastExpression(KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax closeParenToken);
    internal BinaryExpressionSyntax AddExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax SubtractExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax MultiplyExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax DivideExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax IntegerDivideExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax ExponentiateExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax LeftShiftExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax RightShiftExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax ConcatenateExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax ModuloExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax EqualsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax NotEqualsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax LessThanExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax LessThanOrEqualExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax GreaterThanOrEqualExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax GreaterThanExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax IsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax IsNotExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax LikeExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax OrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax ExclusiveOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax AndExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax OrElseExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax AndAlsoExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal UnaryExpressionSyntax UnaryPlusExpression(SyntaxToken operatorToken, ExpressionSyntax operand);
    internal UnaryExpressionSyntax UnaryMinusExpression(SyntaxToken operatorToken, ExpressionSyntax operand);
    internal UnaryExpressionSyntax NotExpression(SyntaxToken operatorToken, ExpressionSyntax operand);
    internal UnaryExpressionSyntax AddressOfExpression(SyntaxToken operatorToken, ExpressionSyntax operand);
    internal UnaryExpressionSyntax UnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand);
    internal BinaryConditionalExpressionSyntax BinaryConditionalExpression(KeywordSyntax ifKeyword, PunctuationSyntax openParenToken, ExpressionSyntax firstExpression, PunctuationSyntax commaToken, ExpressionSyntax secondExpression, PunctuationSyntax closeParenToken);
    internal TernaryConditionalExpressionSyntax TernaryConditionalExpression(KeywordSyntax ifKeyword, PunctuationSyntax openParenToken, ExpressionSyntax condition, PunctuationSyntax firstCommaToken, ExpressionSyntax whenTrue, PunctuationSyntax secondCommaToken, ExpressionSyntax whenFalse, PunctuationSyntax closeParenToken);
    internal SingleLineLambdaExpressionSyntax SingleLineFunctionLambdaExpression(LambdaHeaderSyntax subOrFunctionHeader, VisualBasicSyntaxNode body);
    internal SingleLineLambdaExpressionSyntax SingleLineSubLambdaExpression(LambdaHeaderSyntax subOrFunctionHeader, VisualBasicSyntaxNode body);
    internal SingleLineLambdaExpressionSyntax SingleLineLambdaExpression(SyntaxKind kind, LambdaHeaderSyntax subOrFunctionHeader, VisualBasicSyntaxNode body);
    internal MultiLineLambdaExpressionSyntax MultiLineFunctionLambdaExpression(LambdaHeaderSyntax subOrFunctionHeader, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    internal MultiLineLambdaExpressionSyntax MultiLineSubLambdaExpression(LambdaHeaderSyntax subOrFunctionHeader, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    internal MultiLineLambdaExpressionSyntax MultiLineLambdaExpression(SyntaxKind kind, LambdaHeaderSyntax subOrFunctionHeader, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    internal LambdaHeaderSyntax SubLambdaHeader(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax subOrFunctionKeyword, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal LambdaHeaderSyntax FunctionLambdaHeader(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax subOrFunctionKeyword, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal LambdaHeaderSyntax LambdaHeader(SyntaxKind kind, SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax subOrFunctionKeyword, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal ArgumentListSyntax ArgumentList(PunctuationSyntax openParenToken, SeparatedSyntaxList`1<ArgumentSyntax> arguments, PunctuationSyntax closeParenToken);
    internal OmittedArgumentSyntax OmittedArgument(PunctuationSyntax empty);
    internal SimpleArgumentSyntax SimpleArgument(NameColonEqualsSyntax nameColonEquals, ExpressionSyntax expression);
    internal NameColonEqualsSyntax NameColonEquals(IdentifierNameSyntax name, PunctuationSyntax colonEqualsToken);
    internal RangeArgumentSyntax RangeArgument(ExpressionSyntax lowerBound, KeywordSyntax toKeyword, ExpressionSyntax upperBound);
    internal QueryExpressionSyntax QueryExpression(SyntaxList`1<VisualBasicSyntaxNode> clauses);
    internal CollectionRangeVariableSyntax CollectionRangeVariable(ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, KeywordSyntax inKeyword, ExpressionSyntax expression);
    internal ExpressionRangeVariableSyntax ExpressionRangeVariable(VariableNameEqualsSyntax nameEquals, ExpressionSyntax expression);
    internal AggregationRangeVariableSyntax AggregationRangeVariable(VariableNameEqualsSyntax nameEquals, AggregationSyntax aggregation);
    internal VariableNameEqualsSyntax VariableNameEquals(ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, PunctuationSyntax equalsToken);
    internal FunctionAggregationSyntax FunctionAggregation(IdentifierTokenSyntax functionName, PunctuationSyntax openParenToken, ExpressionSyntax argument, PunctuationSyntax closeParenToken);
    internal GroupAggregationSyntax GroupAggregation(KeywordSyntax groupKeyword);
    internal FromClauseSyntax FromClause(KeywordSyntax fromKeyword, SeparatedSyntaxList`1<CollectionRangeVariableSyntax> variables);
    internal LetClauseSyntax LetClause(KeywordSyntax letKeyword, SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> variables);
    internal AggregateClauseSyntax AggregateClause(KeywordSyntax aggregateKeyword, SeparatedSyntaxList`1<CollectionRangeVariableSyntax> variables, SyntaxList`1<VisualBasicSyntaxNode> additionalQueryOperators, KeywordSyntax intoKeyword, SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
    internal DistinctClauseSyntax DistinctClause(KeywordSyntax distinctKeyword);
    internal WhereClauseSyntax WhereClause(KeywordSyntax whereKeyword, ExpressionSyntax condition);
    internal PartitionWhileClauseSyntax SkipWhileClause(KeywordSyntax skipOrTakeKeyword, KeywordSyntax whileKeyword, ExpressionSyntax condition);
    internal PartitionWhileClauseSyntax TakeWhileClause(KeywordSyntax skipOrTakeKeyword, KeywordSyntax whileKeyword, ExpressionSyntax condition);
    internal PartitionWhileClauseSyntax PartitionWhileClause(SyntaxKind kind, KeywordSyntax skipOrTakeKeyword, KeywordSyntax whileKeyword, ExpressionSyntax condition);
    internal PartitionClauseSyntax SkipClause(KeywordSyntax skipOrTakeKeyword, ExpressionSyntax count);
    internal PartitionClauseSyntax TakeClause(KeywordSyntax skipOrTakeKeyword, ExpressionSyntax count);
    internal PartitionClauseSyntax PartitionClause(SyntaxKind kind, KeywordSyntax skipOrTakeKeyword, ExpressionSyntax count);
    internal GroupByClauseSyntax GroupByClause(KeywordSyntax groupKeyword, SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> items, KeywordSyntax byKeyword, SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> keys, KeywordSyntax intoKeyword, SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
    internal JoinConditionSyntax JoinCondition(ExpressionSyntax left, KeywordSyntax equalsKeyword, ExpressionSyntax right);
    internal SimpleJoinClauseSyntax SimpleJoinClause(KeywordSyntax joinKeyword, SeparatedSyntaxList`1<CollectionRangeVariableSyntax> joinedVariables, SyntaxList`1<VisualBasicSyntaxNode> additionalJoins, KeywordSyntax onKeyword, SeparatedSyntaxList`1<JoinConditionSyntax> joinConditions);
    internal GroupJoinClauseSyntax GroupJoinClause(KeywordSyntax groupKeyword, KeywordSyntax joinKeyword, SeparatedSyntaxList`1<CollectionRangeVariableSyntax> joinedVariables, SyntaxList`1<VisualBasicSyntaxNode> additionalJoins, KeywordSyntax onKeyword, SeparatedSyntaxList`1<JoinConditionSyntax> joinConditions, KeywordSyntax intoKeyword, SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
    internal OrderByClauseSyntax OrderByClause(KeywordSyntax orderKeyword, KeywordSyntax byKeyword, SeparatedSyntaxList`1<OrderingSyntax> orderings);
    internal OrderingSyntax AscendingOrdering(ExpressionSyntax expression, KeywordSyntax ascendingOrDescendingKeyword);
    internal OrderingSyntax DescendingOrdering(ExpressionSyntax expression, KeywordSyntax ascendingOrDescendingKeyword);
    internal OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, KeywordSyntax ascendingOrDescendingKeyword);
    internal SelectClauseSyntax SelectClause(KeywordSyntax selectKeyword, SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> variables);
    internal XmlDocumentSyntax XmlDocument(XmlDeclarationSyntax declaration, SyntaxList`1<VisualBasicSyntaxNode> precedingMisc, XmlNodeSyntax root, SyntaxList`1<VisualBasicSyntaxNode> followingMisc);
    internal XmlDeclarationSyntax XmlDeclaration(PunctuationSyntax lessThanQuestionToken, KeywordSyntax xmlKeyword, XmlDeclarationOptionSyntax version, XmlDeclarationOptionSyntax encoding, XmlDeclarationOptionSyntax standalone, PunctuationSyntax questionGreaterThanToken);
    internal XmlDeclarationOptionSyntax XmlDeclarationOption(XmlNameTokenSyntax name, PunctuationSyntax equals, XmlStringSyntax value);
    internal XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, SyntaxList`1<VisualBasicSyntaxNode> content, XmlElementEndTagSyntax endTag);
    internal XmlTextSyntax XmlText(SyntaxList`1<VisualBasicSyntaxNode> textTokens);
    internal XmlElementStartTagSyntax XmlElementStartTag(PunctuationSyntax lessThanToken, XmlNodeSyntax name, SyntaxList`1<VisualBasicSyntaxNode> attributes, PunctuationSyntax greaterThanToken);
    internal XmlElementEndTagSyntax XmlElementEndTag(PunctuationSyntax lessThanSlashToken, XmlNameSyntax name, PunctuationSyntax greaterThanToken);
    internal XmlEmptyElementSyntax XmlEmptyElement(PunctuationSyntax lessThanToken, XmlNodeSyntax name, SyntaxList`1<VisualBasicSyntaxNode> attributes, PunctuationSyntax slashGreaterThanToken);
    internal XmlAttributeSyntax XmlAttribute(XmlNodeSyntax name, PunctuationSyntax equalsToken, XmlNodeSyntax value);
    internal XmlStringSyntax XmlString(PunctuationSyntax startQuoteToken, SyntaxList`1<VisualBasicSyntaxNode> textTokens, PunctuationSyntax endQuoteToken);
    internal XmlPrefixNameSyntax XmlPrefixName(XmlNameTokenSyntax name);
    internal XmlNameSyntax XmlName(XmlPrefixSyntax prefix, XmlNameTokenSyntax localName);
    internal XmlBracketedNameSyntax XmlBracketedName(PunctuationSyntax lessThanToken, XmlNameSyntax name, PunctuationSyntax greaterThanToken);
    internal XmlPrefixSyntax XmlPrefix(XmlNameTokenSyntax name, PunctuationSyntax colonToken);
    internal XmlCommentSyntax XmlComment(PunctuationSyntax lessThanExclamationMinusMinusToken, SyntaxList`1<VisualBasicSyntaxNode> textTokens, PunctuationSyntax minusMinusGreaterThanToken);
    internal XmlProcessingInstructionSyntax XmlProcessingInstruction(PunctuationSyntax lessThanQuestionToken, XmlNameTokenSyntax name, SyntaxList`1<VisualBasicSyntaxNode> textTokens, PunctuationSyntax questionGreaterThanToken);
    internal XmlCDataSectionSyntax XmlCDataSection(PunctuationSyntax beginCDataToken, SyntaxList`1<VisualBasicSyntaxNode> textTokens, PunctuationSyntax endCDataToken);
    internal XmlEmbeddedExpressionSyntax XmlEmbeddedExpression(PunctuationSyntax lessThanPercentEqualsToken, ExpressionSyntax expression, PunctuationSyntax percentGreaterThanToken);
    internal ArrayTypeSyntax ArrayType(TypeSyntax elementType, SyntaxList`1<VisualBasicSyntaxNode> rankSpecifiers);
    internal NullableTypeSyntax NullableType(TypeSyntax elementType, PunctuationSyntax questionMarkToken);
    internal PredefinedTypeSyntax PredefinedType(KeywordSyntax keyword);
    internal IdentifierNameSyntax IdentifierName(IdentifierTokenSyntax identifier);
    internal GenericNameSyntax GenericName(IdentifierTokenSyntax identifier, TypeArgumentListSyntax typeArgumentList);
    internal QualifiedNameSyntax QualifiedName(NameSyntax left, PunctuationSyntax dotToken, SimpleNameSyntax right);
    internal GlobalNameSyntax GlobalName(KeywordSyntax globalKeyword);
    internal TypeArgumentListSyntax TypeArgumentList(PunctuationSyntax openParenToken, KeywordSyntax ofKeyword, SeparatedSyntaxList`1<TypeSyntax> arguments, PunctuationSyntax closeParenToken);
    internal CrefReferenceSyntax CrefReference(TypeSyntax name, CrefSignatureSyntax signature, SimpleAsClauseSyntax asClause);
    internal CrefSignatureSyntax CrefSignature(PunctuationSyntax openParenToken, SeparatedSyntaxList`1<CrefSignaturePartSyntax> argumentTypes, PunctuationSyntax closeParenToken);
    internal CrefSignaturePartSyntax CrefSignaturePart(KeywordSyntax modifier, TypeSyntax type);
    internal CrefOperatorReferenceSyntax CrefOperatorReference(KeywordSyntax operatorKeyword, SyntaxToken operatorToken);
    internal QualifiedCrefOperatorReferenceSyntax QualifiedCrefOperatorReference(NameSyntax left, PunctuationSyntax dotToken, CrefOperatorReferenceSyntax right);
    internal YieldStatementSyntax YieldStatement(KeywordSyntax yieldKeyword, ExpressionSyntax expression);
    internal AwaitExpressionSyntax AwaitExpression(KeywordSyntax awaitKeyword, ExpressionSyntax expression);
    internal XmlNameTokenSyntax XmlNameToken(string text, SyntaxKind possibleKeywordKind, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal XmlTextTokenSyntax XmlTextLiteralToken(string text, string value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal XmlTextTokenSyntax XmlEntityLiteralToken(string text, string value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal XmlTextTokenSyntax DocumentationCommentLineBreakToken(string text, string value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal XmlTextTokenSyntax XmlTextToken(SyntaxKind kind, string text, string value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal InterpolatedStringTextTokenSyntax InterpolatedStringTextToken(string text, string value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal DecimalLiteralTokenSyntax DecimalLiteralToken(string text, TypeCharacter typeSuffix, decimal value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal DateLiteralTokenSyntax DateLiteralToken(string text, DateTime value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal StringLiteralTokenSyntax StringLiteralToken(string text, string value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal CharacterLiteralTokenSyntax CharacterLiteralToken(string text, char value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxList`1<VisualBasicSyntaxNode> tokens);
    internal DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxList`1<VisualBasicSyntaxNode> content);
    internal XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, PunctuationSyntax equalsToken, PunctuationSyntax startQuoteToken, CrefReferenceSyntax reference, PunctuationSyntax endQuoteToken);
    internal XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, PunctuationSyntax equalsToken, PunctuationSyntax startQuoteToken, IdentifierNameSyntax reference, PunctuationSyntax endQuoteToken);
    internal ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, PunctuationSyntax questionMarkToken, ExpressionSyntax whenNotNull);
    internal NameOfExpressionSyntax NameOfExpression(KeywordSyntax nameOfKeyword, PunctuationSyntax openParenToken, ExpressionSyntax argument, PunctuationSyntax closeParenToken);
    internal InterpolatedStringExpressionSyntax InterpolatedStringExpression(PunctuationSyntax dollarSignDoubleQuoteToken, SyntaxList`1<VisualBasicSyntaxNode> contents, PunctuationSyntax doubleQuoteToken);
    internal InterpolatedStringTextSyntax InterpolatedStringText(InterpolatedStringTextTokenSyntax textToken);
    internal InterpolationSyntax Interpolation(PunctuationSyntax openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, PunctuationSyntax closeBraceToken);
    internal InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(PunctuationSyntax commaToken, ExpressionSyntax value);
    internal InterpolationFormatClauseSyntax InterpolationFormatClause(PunctuationSyntax colonToken, InterpolatedStringTextTokenSyntax formatStringToken);
    internal SyntaxTrivia WhitespaceTrivia(string text);
    internal SyntaxTrivia EndOfLineTrivia(string text);
    internal SyntaxTrivia ColonTrivia(string text);
    internal SyntaxTrivia CommentTrivia(string text);
    internal SyntaxTrivia LineContinuationTrivia(string text);
    internal SyntaxTrivia DocumentationCommentExteriorTrivia(string text);
    internal SyntaxTrivia DisabledTextTrivia(string text);
    internal SyntaxTrivia SyntaxTrivia(SyntaxKind kind, string text);
    internal ConstDirectiveTriviaSyntax ConstDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax constKeyword, IdentifierTokenSyntax name, PunctuationSyntax equalsToken, ExpressionSyntax value);
    internal IfDirectiveTriviaSyntax IfDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax elseKeyword, KeywordSyntax ifOrElseIfKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    internal IfDirectiveTriviaSyntax ElseIfDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax elseKeyword, KeywordSyntax ifOrElseIfKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    internal ElseDirectiveTriviaSyntax ElseDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax elseKeyword);
    internal EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax endKeyword, KeywordSyntax ifKeyword);
    internal RegionDirectiveTriviaSyntax RegionDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax regionKeyword, StringLiteralTokenSyntax name);
    internal EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax endKeyword, KeywordSyntax regionKeyword);
    internal ExternalSourceDirectiveTriviaSyntax ExternalSourceDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax externalSourceKeyword, PunctuationSyntax openParenToken, StringLiteralTokenSyntax externalSource, PunctuationSyntax commaToken, IntegerLiteralTokenSyntax lineStart, PunctuationSyntax closeParenToken);
    internal EndExternalSourceDirectiveTriviaSyntax EndExternalSourceDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax endKeyword, KeywordSyntax externalSourceKeyword);
    internal ExternalChecksumDirectiveTriviaSyntax ExternalChecksumDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax externalChecksumKeyword, PunctuationSyntax openParenToken, StringLiteralTokenSyntax externalSource, PunctuationSyntax firstCommaToken, StringLiteralTokenSyntax guid, PunctuationSyntax secondCommaToken, StringLiteralTokenSyntax checksum, PunctuationSyntax closeParenToken);
    internal EnableWarningDirectiveTriviaSyntax EnableWarningDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax enableKeyword, KeywordSyntax warningKeyword, SeparatedSyntaxList`1<IdentifierNameSyntax> errorCodes);
    internal DisableWarningDirectiveTriviaSyntax DisableWarningDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax disableKeyword, KeywordSyntax warningKeyword, SeparatedSyntaxList`1<IdentifierNameSyntax> errorCodes);
    internal ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax referenceKeyword, StringLiteralTokenSyntax file);
    internal BadDirectiveTriviaSyntax BadDirectiveTrivia(PunctuationSyntax hashToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ContinueStatementSyntax : ExecutableStatementSyntax {
    internal KeywordSyntax _continueKeyword;
    internal KeywordSyntax _blockKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ContinueKeyword { get; }
    internal KeywordSyntax BlockKeyword { get; }
    private static ContinueStatementSyntax();
    internal ContinueStatementSyntax(SyntaxKind kind, KeywordSyntax continueKeyword, KeywordSyntax blockKeyword);
    internal ContinueStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax continueKeyword, KeywordSyntax blockKeyword);
    internal ContinueStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax continueKeyword, KeywordSyntax blockKeyword);
    internal ContinueStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ContinueKeyword();
    internal KeywordSyntax get_BlockKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CrefOperatorReferenceSyntax : NameSyntax {
    internal KeywordSyntax _operatorKeyword;
    internal SyntaxToken _operatorToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax OperatorKeyword { get; }
    internal SyntaxToken OperatorToken { get; }
    private static CrefOperatorReferenceSyntax();
    internal CrefOperatorReferenceSyntax(SyntaxKind kind, KeywordSyntax operatorKeyword, SyntaxToken operatorToken);
    internal CrefOperatorReferenceSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax operatorKeyword, SyntaxToken operatorToken);
    internal CrefOperatorReferenceSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax operatorKeyword, SyntaxToken operatorToken);
    internal CrefOperatorReferenceSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_OperatorKeyword();
    internal SyntaxToken get_OperatorToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CrefReferenceSyntax : VisualBasicSyntaxNode {
    internal TypeSyntax _name;
    internal CrefSignatureSyntax _signature;
    internal SimpleAsClauseSyntax _asClause;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal TypeSyntax Name { get; }
    internal CrefSignatureSyntax Signature { get; }
    internal SimpleAsClauseSyntax AsClause { get; }
    private static CrefReferenceSyntax();
    internal CrefReferenceSyntax(SyntaxKind kind, TypeSyntax name, CrefSignatureSyntax signature, SimpleAsClauseSyntax asClause);
    internal CrefReferenceSyntax(SyntaxKind kind, ISyntaxFactoryContext context, TypeSyntax name, CrefSignatureSyntax signature, SimpleAsClauseSyntax asClause);
    internal CrefReferenceSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, TypeSyntax name, CrefSignatureSyntax signature, SimpleAsClauseSyntax asClause);
    internal CrefReferenceSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal TypeSyntax get_Name();
    internal CrefSignatureSyntax get_Signature();
    internal SimpleAsClauseSyntax get_AsClause();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CrefSignaturePartSyntax : VisualBasicSyntaxNode {
    internal KeywordSyntax _modifier;
    internal TypeSyntax _type;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax Modifier { get; }
    internal TypeSyntax Type { get; }
    private static CrefSignaturePartSyntax();
    internal CrefSignaturePartSyntax(SyntaxKind kind, KeywordSyntax modifier, TypeSyntax type);
    internal CrefSignaturePartSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax modifier, TypeSyntax type);
    internal CrefSignaturePartSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax modifier, TypeSyntax type);
    internal CrefSignaturePartSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_Modifier();
    internal TypeSyntax get_Type();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CrefSignatureSyntax : VisualBasicSyntaxNode {
    internal PunctuationSyntax _openParenToken;
    internal GreenNode _argumentTypes;
    internal PunctuationSyntax _closeParenToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax OpenParenToken { get; }
    internal SeparatedSyntaxList`1<CrefSignaturePartSyntax> ArgumentTypes { get; }
    internal PunctuationSyntax CloseParenToken { get; }
    private static CrefSignatureSyntax();
    internal CrefSignatureSyntax(SyntaxKind kind, PunctuationSyntax openParenToken, GreenNode argumentTypes, PunctuationSyntax closeParenToken);
    internal CrefSignatureSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax openParenToken, GreenNode argumentTypes, PunctuationSyntax closeParenToken);
    internal CrefSignatureSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax openParenToken, GreenNode argumentTypes, PunctuationSyntax closeParenToken);
    internal CrefSignatureSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_OpenParenToken();
    internal SeparatedSyntaxList`1<CrefSignaturePartSyntax> get_ArgumentTypes();
    internal PunctuationSyntax get_CloseParenToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.CTypeExpressionSyntax : CastExpressionSyntax {
    internal static Func`2<ObjectReader, object> CreateInstance;
    private static CTypeExpressionSyntax();
    internal CTypeExpressionSyntax(SyntaxKind kind, KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal CTypeExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal CTypeExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal CTypeExpressionSyntax(ObjectReader reader);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DateLiteralTokenSyntax : SyntaxToken {
    internal DateTime _value;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal object ObjectValue { get; }
    internal DateTime Value { get; }
    private static DateLiteralTokenSyntax();
    internal DateLiteralTokenSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, DateTime value);
    internal DateLiteralTokenSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, ISyntaxFactoryContext context, DateTime value);
    internal DateLiteralTokenSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, DateTime value);
    internal DateLiteralTokenSyntax(ObjectReader reader);
    internal sealed virtual object get_ObjectValue();
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal DateTime get_Value();
    public virtual GreenNode WithLeadingTrivia(GreenNode trivia);
    public virtual GreenNode WithTrailingTrivia(GreenNode trivia);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DecimalLiteralTokenSyntax : SyntaxToken {
    internal TypeCharacter _typeSuffix;
    internal decimal _value;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal object ObjectValue { get; }
    internal TypeCharacter TypeSuffix { get; }
    internal decimal Value { get; }
    private static DecimalLiteralTokenSyntax();
    internal DecimalLiteralTokenSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, TypeCharacter typeSuffix, decimal value);
    internal DecimalLiteralTokenSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, ISyntaxFactoryContext context, TypeCharacter typeSuffix, decimal value);
    internal DecimalLiteralTokenSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, TypeCharacter typeSuffix, decimal value);
    internal DecimalLiteralTokenSyntax(ObjectReader reader);
    internal sealed virtual object get_ObjectValue();
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal TypeCharacter get_TypeSuffix();
    internal decimal get_Value();
    public virtual GreenNode WithLeadingTrivia(GreenNode trivia);
    public virtual GreenNode WithTrailingTrivia(GreenNode trivia);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DeclarationContext : BlockContext {
    internal bool IsSingleLine { get; }
    internal DeclarationContext(SyntaxKind kind, StatementSyntax statement, BlockContext context);
    internal virtual StatementSyntax Parse();
    internal virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode node);
    internal virtual LinkResult TryLinkSyntax(VisualBasicSyntaxNode node, BlockContext& newContext);
    internal virtual BlockContext RecoverFromMismatchedEnd(StatementSyntax statement);
    internal virtual BlockContext EndBlock(StatementSyntax endStmt);
    internal virtual BlockContext ProcessStatementTerminator(BlockContext lambdaContext);
    internal virtual bool get_IsSingleLine();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DeclarationStatementSyntax : StatementSyntax {
    internal DeclarationStatementSyntax(SyntaxKind kind);
    internal DeclarationStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal DeclarationStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal DeclarationStatementSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DeclareStatementSyntax : MethodBaseSyntax {
    internal KeywordSyntax _declareKeyword;
    internal KeywordSyntax _charsetKeyword;
    internal KeywordSyntax _subOrFunctionKeyword;
    internal IdentifierTokenSyntax _identifier;
    internal KeywordSyntax _libKeyword;
    internal LiteralExpressionSyntax _libraryName;
    internal KeywordSyntax _aliasKeyword;
    internal LiteralExpressionSyntax _aliasName;
    internal SimpleAsClauseSyntax _asClause;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax DeclareKeyword { get; }
    internal KeywordSyntax CharsetKeyword { get; }
    internal KeywordSyntax SubOrFunctionKeyword { get; }
    internal IdentifierTokenSyntax Identifier { get; }
    internal KeywordSyntax LibKeyword { get; }
    internal LiteralExpressionSyntax LibraryName { get; }
    internal KeywordSyntax AliasKeyword { get; }
    internal LiteralExpressionSyntax AliasName { get; }
    internal SimpleAsClauseSyntax AsClause { get; }
    private static DeclareStatementSyntax();
    internal DeclareStatementSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax declareKeyword, KeywordSyntax charsetKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, KeywordSyntax libKeyword, LiteralExpressionSyntax libraryName, KeywordSyntax aliasKeyword, LiteralExpressionSyntax aliasName, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal DeclareStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax declareKeyword, KeywordSyntax charsetKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, KeywordSyntax libKeyword, LiteralExpressionSyntax libraryName, KeywordSyntax aliasKeyword, LiteralExpressionSyntax aliasName, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal DeclareStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax declareKeyword, KeywordSyntax charsetKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, KeywordSyntax libKeyword, LiteralExpressionSyntax libraryName, KeywordSyntax aliasKeyword, LiteralExpressionSyntax aliasName, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal DeclareStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_DeclareKeyword();
    internal KeywordSyntax get_CharsetKeyword();
    internal KeywordSyntax get_SubOrFunctionKeyword();
    internal IdentifierTokenSyntax get_Identifier();
    internal KeywordSyntax get_LibKeyword();
    internal LiteralExpressionSyntax get_LibraryName();
    internal KeywordSyntax get_AliasKeyword();
    internal LiteralExpressionSyntax get_AliasName();
    internal SimpleAsClauseSyntax get_AsClause();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DelegateStatementSyntax : MethodBaseSyntax {
    internal KeywordSyntax _delegateKeyword;
    internal KeywordSyntax _subOrFunctionKeyword;
    internal IdentifierTokenSyntax _identifier;
    internal TypeParameterListSyntax _typeParameterList;
    internal SimpleAsClauseSyntax _asClause;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax DelegateKeyword { get; }
    internal KeywordSyntax SubOrFunctionKeyword { get; }
    internal IdentifierTokenSyntax Identifier { get; }
    internal TypeParameterListSyntax TypeParameterList { get; }
    internal SimpleAsClauseSyntax AsClause { get; }
    private static DelegateStatementSyntax();
    internal DelegateStatementSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax delegateKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal DelegateStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax delegateKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal DelegateStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax delegateKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal DelegateStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_DelegateKeyword();
    internal KeywordSyntax get_SubOrFunctionKeyword();
    internal IdentifierTokenSyntax get_Identifier();
    internal TypeParameterListSyntax get_TypeParameterList();
    internal SimpleAsClauseSyntax get_AsClause();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DirectCastExpressionSyntax : CastExpressionSyntax {
    internal static Func`2<ObjectReader, object> CreateInstance;
    private static DirectCastExpressionSyntax();
    internal DirectCastExpressionSyntax(SyntaxKind kind, KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal DirectCastExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal DirectCastExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal DirectCastExpressionSyntax(ObjectReader reader);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DirectiveTriviaSyntax : StructuredTriviaSyntax {
    internal PunctuationSyntax _hashToken;
    internal PunctuationSyntax HashToken { get; }
    internal DirectiveTriviaSyntax(SyntaxKind kind, PunctuationSyntax hashToken);
    internal DirectiveTriviaSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax hashToken);
    internal DirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken);
    internal DirectiveTriviaSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal PunctuationSyntax get_HashToken();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DisableWarningDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal KeywordSyntax _disableKeyword;
    internal KeywordSyntax _warningKeyword;
    internal GreenNode _errorCodes;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax DisableKeyword { get; }
    internal KeywordSyntax WarningKeyword { get; }
    internal SeparatedSyntaxList`1<IdentifierNameSyntax> ErrorCodes { get; }
    private static DisableWarningDirectiveTriviaSyntax();
    internal DisableWarningDirectiveTriviaSyntax(SyntaxKind kind, PunctuationSyntax hashToken, KeywordSyntax disableKeyword, KeywordSyntax warningKeyword, GreenNode errorCodes);
    internal DisableWarningDirectiveTriviaSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax hashToken, KeywordSyntax disableKeyword, KeywordSyntax warningKeyword, GreenNode errorCodes);
    internal DisableWarningDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax disableKeyword, KeywordSyntax warningKeyword, GreenNode errorCodes);
    internal DisableWarningDirectiveTriviaSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_DisableKeyword();
    internal KeywordSyntax get_WarningKeyword();
    internal SeparatedSyntaxList`1<IdentifierNameSyntax> get_ErrorCodes();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DistinctClauseSyntax : QueryClauseSyntax {
    internal KeywordSyntax _distinctKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax DistinctKeyword { get; }
    private static DistinctClauseSyntax();
    internal DistinctClauseSyntax(SyntaxKind kind, KeywordSyntax distinctKeyword);
    internal DistinctClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax distinctKeyword);
    internal DistinctClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax distinctKeyword);
    internal DistinctClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_DistinctKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DocumentationCommentTriviaSyntax : StructuredTriviaSyntax {
    internal GreenNode _content;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxList`1<XmlNodeSyntax> Content { get; }
    private static DocumentationCommentTriviaSyntax();
    internal DocumentationCommentTriviaSyntax(SyntaxKind kind, GreenNode content);
    internal DocumentationCommentTriviaSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode content);
    internal DocumentationCommentTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode content);
    internal DocumentationCommentTriviaSyntax(ObjectReader reader);
    internal string GetInteriorXml();
    private static void WriteInteriorXml(VisualBasicSyntaxNode node, StringBuilder sb);
    private static void WriteInteriorXml(SyntaxToken node, StringBuilder sb);
    private static void WriteInteriorXml(SyntaxList`1<VisualBasicSyntaxNode> node, StringBuilder sb);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SyntaxList`1<XmlNodeSyntax> get_Content();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoLoopBlockContext : ExecutableStatementContext {
    internal DoLoopBlockContext(StatementSyntax statement, BlockContext prevContext);
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax statement);
    internal virtual bool KindEndsBlock(SyntaxKind kind);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoLoopBlockSyntax : ExecutableStatementSyntax {
    internal DoStatementSyntax _doStatement;
    internal GreenNode _statements;
    internal LoopStatementSyntax _loopStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal DoStatementSyntax DoStatement { get; }
    internal SyntaxList`1<StatementSyntax> Statements { get; }
    internal LoopStatementSyntax LoopStatement { get; }
    private static DoLoopBlockSyntax();
    internal DoLoopBlockSyntax(SyntaxKind kind, DoStatementSyntax doStatement, GreenNode statements, LoopStatementSyntax loopStatement);
    internal DoLoopBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, DoStatementSyntax doStatement, GreenNode statements, LoopStatementSyntax loopStatement);
    internal DoLoopBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, DoStatementSyntax doStatement, GreenNode statements, LoopStatementSyntax loopStatement);
    internal DoLoopBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal DoStatementSyntax get_DoStatement();
    internal SyntaxList`1<StatementSyntax> get_Statements();
    internal LoopStatementSyntax get_LoopStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.DoStatementSyntax : StatementSyntax {
    internal KeywordSyntax _doKeyword;
    internal WhileOrUntilClauseSyntax _whileOrUntilClause;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax DoKeyword { get; }
    internal WhileOrUntilClauseSyntax WhileOrUntilClause { get; }
    private static DoStatementSyntax();
    internal DoStatementSyntax(SyntaxKind kind, KeywordSyntax doKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal DoStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax doKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal DoStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax doKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal DoStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_DoKeyword();
    internal WhileOrUntilClauseSyntax get_WhileOrUntilClause();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseBlockSyntax : VisualBasicSyntaxNode {
    internal ElseStatementSyntax _elseStatement;
    internal GreenNode _statements;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ElseStatementSyntax ElseStatement { get; }
    internal SyntaxList`1<StatementSyntax> Statements { get; }
    private static ElseBlockSyntax();
    internal ElseBlockSyntax(SyntaxKind kind, ElseStatementSyntax elseStatement, GreenNode statements);
    internal ElseBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ElseStatementSyntax elseStatement, GreenNode statements);
    internal ElseBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ElseStatementSyntax elseStatement, GreenNode statements);
    internal ElseBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ElseStatementSyntax get_ElseStatement();
    internal SyntaxList`1<StatementSyntax> get_Statements();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseCaseClauseSyntax : CaseClauseSyntax {
    internal KeywordSyntax _elseKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ElseKeyword { get; }
    private static ElseCaseClauseSyntax();
    internal ElseCaseClauseSyntax(SyntaxKind kind, KeywordSyntax elseKeyword);
    internal ElseCaseClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax elseKeyword);
    internal ElseCaseClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax elseKeyword);
    internal ElseCaseClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ElseKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal KeywordSyntax _elseKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ElseKeyword { get; }
    private static ElseDirectiveTriviaSyntax();
    internal ElseDirectiveTriviaSyntax(SyntaxKind kind, PunctuationSyntax hashToken, KeywordSyntax elseKeyword);
    internal ElseDirectiveTriviaSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax hashToken, KeywordSyntax elseKeyword);
    internal ElseDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax elseKeyword);
    internal ElseDirectiveTriviaSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ElseKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseIfBlockSyntax : VisualBasicSyntaxNode {
    internal ElseIfStatementSyntax _elseIfStatement;
    internal GreenNode _statements;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ElseIfStatementSyntax ElseIfStatement { get; }
    internal SyntaxList`1<StatementSyntax> Statements { get; }
    private static ElseIfBlockSyntax();
    internal ElseIfBlockSyntax(SyntaxKind kind, ElseIfStatementSyntax elseIfStatement, GreenNode statements);
    internal ElseIfBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ElseIfStatementSyntax elseIfStatement, GreenNode statements);
    internal ElseIfBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ElseIfStatementSyntax elseIfStatement, GreenNode statements);
    internal ElseIfBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ElseIfStatementSyntax get_ElseIfStatement();
    internal SyntaxList`1<StatementSyntax> get_Statements();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseIfStatementSyntax : StatementSyntax {
    internal KeywordSyntax _elseIfKeyword;
    internal ExpressionSyntax _condition;
    internal KeywordSyntax _thenKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ElseIfKeyword { get; }
    internal ExpressionSyntax Condition { get; }
    internal KeywordSyntax ThenKeyword { get; }
    private static ElseIfStatementSyntax();
    internal ElseIfStatementSyntax(SyntaxKind kind, KeywordSyntax elseIfKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    internal ElseIfStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax elseIfKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    internal ElseIfStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax elseIfKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    internal ElseIfStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ElseIfKeyword();
    internal ExpressionSyntax get_Condition();
    internal KeywordSyntax get_ThenKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ElseStatementSyntax : StatementSyntax {
    internal KeywordSyntax _elseKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ElseKeyword { get; }
    private static ElseStatementSyntax();
    internal ElseStatementSyntax(SyntaxKind kind, KeywordSyntax elseKeyword);
    internal ElseStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax elseKeyword);
    internal ElseStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax elseKeyword);
    internal ElseStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ElseKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EmptyStatementSyntax : StatementSyntax {
    internal PunctuationSyntax _empty;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax Empty { get; }
    private static EmptyStatementSyntax();
    internal EmptyStatementSyntax(SyntaxKind kind, PunctuationSyntax empty);
    internal EmptyStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax empty);
    internal EmptyStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax empty);
    internal EmptyStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_Empty();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnableWarningDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal KeywordSyntax _enableKeyword;
    internal KeywordSyntax _warningKeyword;
    internal GreenNode _errorCodes;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax EnableKeyword { get; }
    internal KeywordSyntax WarningKeyword { get; }
    internal SeparatedSyntaxList`1<IdentifierNameSyntax> ErrorCodes { get; }
    private static EnableWarningDirectiveTriviaSyntax();
    internal EnableWarningDirectiveTriviaSyntax(SyntaxKind kind, PunctuationSyntax hashToken, KeywordSyntax enableKeyword, KeywordSyntax warningKeyword, GreenNode errorCodes);
    internal EnableWarningDirectiveTriviaSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax hashToken, KeywordSyntax enableKeyword, KeywordSyntax warningKeyword, GreenNode errorCodes);
    internal EnableWarningDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax enableKeyword, KeywordSyntax warningKeyword, GreenNode errorCodes);
    internal EnableWarningDirectiveTriviaSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_EnableKeyword();
    internal KeywordSyntax get_WarningKeyword();
    internal SeparatedSyntaxList`1<IdentifierNameSyntax> get_ErrorCodes();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndBlockStatementSyntax : DeclarationStatementSyntax {
    internal KeywordSyntax _endKeyword;
    internal KeywordSyntax _blockKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax EndKeyword { get; }
    internal KeywordSyntax BlockKeyword { get; }
    private static EndBlockStatementSyntax();
    internal EndBlockStatementSyntax(SyntaxKind kind, KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal EndBlockStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_EndKeyword();
    internal KeywordSyntax get_BlockKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndExternalSourceDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal KeywordSyntax _endKeyword;
    internal KeywordSyntax _externalSourceKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax EndKeyword { get; }
    internal KeywordSyntax ExternalSourceKeyword { get; }
    private static EndExternalSourceDirectiveTriviaSyntax();
    internal EndExternalSourceDirectiveTriviaSyntax(SyntaxKind kind, PunctuationSyntax hashToken, KeywordSyntax endKeyword, KeywordSyntax externalSourceKeyword);
    internal EndExternalSourceDirectiveTriviaSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax hashToken, KeywordSyntax endKeyword, KeywordSyntax externalSourceKeyword);
    internal EndExternalSourceDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax endKeyword, KeywordSyntax externalSourceKeyword);
    internal EndExternalSourceDirectiveTriviaSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_EndKeyword();
    internal KeywordSyntax get_ExternalSourceKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndIfDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal KeywordSyntax _endKeyword;
    internal KeywordSyntax _ifKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax EndKeyword { get; }
    internal KeywordSyntax IfKeyword { get; }
    private static EndIfDirectiveTriviaSyntax();
    internal EndIfDirectiveTriviaSyntax(SyntaxKind kind, PunctuationSyntax hashToken, KeywordSyntax endKeyword, KeywordSyntax ifKeyword);
    internal EndIfDirectiveTriviaSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax hashToken, KeywordSyntax endKeyword, KeywordSyntax ifKeyword);
    internal EndIfDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax endKeyword, KeywordSyntax ifKeyword);
    internal EndIfDirectiveTriviaSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_EndKeyword();
    internal KeywordSyntax get_IfKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EndRegionDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal KeywordSyntax _endKeyword;
    internal KeywordSyntax _regionKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax EndKeyword { get; }
    internal KeywordSyntax RegionKeyword { get; }
    private static EndRegionDirectiveTriviaSyntax();
    internal EndRegionDirectiveTriviaSyntax(SyntaxKind kind, PunctuationSyntax hashToken, KeywordSyntax endKeyword, KeywordSyntax regionKeyword);
    internal EndRegionDirectiveTriviaSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax hashToken, KeywordSyntax endKeyword, KeywordSyntax regionKeyword);
    internal EndRegionDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax endKeyword, KeywordSyntax regionKeyword);
    internal EndRegionDirectiveTriviaSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_EndKeyword();
    internal KeywordSyntax get_RegionKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnumBlockSyntax : DeclarationStatementSyntax {
    internal EnumStatementSyntax _enumStatement;
    internal GreenNode _members;
    internal EndBlockStatementSyntax _endEnumStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal EnumStatementSyntax EnumStatement { get; }
    internal SyntaxList`1<StatementSyntax> Members { get; }
    internal EndBlockStatementSyntax EndEnumStatement { get; }
    private static EnumBlockSyntax();
    internal EnumBlockSyntax(SyntaxKind kind, EnumStatementSyntax enumStatement, GreenNode members, EndBlockStatementSyntax endEnumStatement);
    internal EnumBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, EnumStatementSyntax enumStatement, GreenNode members, EndBlockStatementSyntax endEnumStatement);
    internal EnumBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, EnumStatementSyntax enumStatement, GreenNode members, EndBlockStatementSyntax endEnumStatement);
    internal EnumBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal EnumStatementSyntax get_EnumStatement();
    internal SyntaxList`1<StatementSyntax> get_Members();
    internal EndBlockStatementSyntax get_EndEnumStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnumDeclarationBlockContext : DeclarationContext {
    internal EnumDeclarationBlockContext(StatementSyntax statement, BlockContext prevContext);
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax endStmt);
    internal virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode node);
    internal virtual LinkResult TryLinkSyntax(VisualBasicSyntaxNode node, BlockContext& newContext);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnumMemberDeclarationSyntax : DeclarationStatementSyntax {
    internal GreenNode _attributeLists;
    internal IdentifierTokenSyntax _identifier;
    internal EqualsValueSyntax _initializer;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    internal IdentifierTokenSyntax Identifier { get; }
    internal EqualsValueSyntax Initializer { get; }
    private static EnumMemberDeclarationSyntax();
    internal EnumMemberDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, IdentifierTokenSyntax identifier, EqualsValueSyntax initializer);
    internal EnumMemberDeclarationSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, IdentifierTokenSyntax identifier, EqualsValueSyntax initializer);
    internal EnumMemberDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, IdentifierTokenSyntax identifier, EqualsValueSyntax initializer);
    internal EnumMemberDeclarationSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal IdentifierTokenSyntax get_Identifier();
    internal EqualsValueSyntax get_Initializer();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EnumStatementSyntax : DeclarationStatementSyntax {
    internal GreenNode _attributeLists;
    internal GreenNode _modifiers;
    internal KeywordSyntax _enumKeyword;
    internal IdentifierTokenSyntax _identifier;
    internal AsClauseSyntax _underlyingType;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    internal SyntaxList`1<KeywordSyntax> Modifiers { get; }
    internal KeywordSyntax EnumKeyword { get; }
    internal IdentifierTokenSyntax Identifier { get; }
    internal AsClauseSyntax UnderlyingType { get; }
    private static EnumStatementSyntax();
    internal EnumStatementSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax enumKeyword, IdentifierTokenSyntax identifier, AsClauseSyntax underlyingType);
    internal EnumStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax enumKeyword, IdentifierTokenSyntax identifier, AsClauseSyntax underlyingType);
    internal EnumStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax enumKeyword, IdentifierTokenSyntax identifier, AsClauseSyntax underlyingType);
    internal EnumStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal SyntaxList`1<KeywordSyntax> get_Modifiers();
    internal KeywordSyntax get_EnumKeyword();
    internal IdentifierTokenSyntax get_Identifier();
    internal AsClauseSyntax get_UnderlyingType();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EqualsValueSyntax : VisualBasicSyntaxNode {
    internal PunctuationSyntax _equalsToken;
    internal ExpressionSyntax _value;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax EqualsToken { get; }
    internal ExpressionSyntax Value { get; }
    private static EqualsValueSyntax();
    internal EqualsValueSyntax(SyntaxKind kind, PunctuationSyntax equalsToken, ExpressionSyntax value);
    internal EqualsValueSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax equalsToken, ExpressionSyntax value);
    internal EqualsValueSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax equalsToken, ExpressionSyntax value);
    internal EqualsValueSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_EqualsToken();
    internal ExpressionSyntax get_Value();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EraseStatementSyntax : ExecutableStatementSyntax {
    internal KeywordSyntax _eraseKeyword;
    internal GreenNode _expressions;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax EraseKeyword { get; }
    internal SeparatedSyntaxList`1<ExpressionSyntax> Expressions { get; }
    private static EraseStatementSyntax();
    internal EraseStatementSyntax(SyntaxKind kind, KeywordSyntax eraseKeyword, GreenNode expressions);
    internal EraseStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax eraseKeyword, GreenNode expressions);
    internal EraseStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax eraseKeyword, GreenNode expressions);
    internal EraseStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_EraseKeyword();
    internal SeparatedSyntaxList`1<ExpressionSyntax> get_Expressions();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ErrorStatementSyntax : ExecutableStatementSyntax {
    internal KeywordSyntax _errorKeyword;
    internal ExpressionSyntax _errorNumber;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ErrorKeyword { get; }
    internal ExpressionSyntax ErrorNumber { get; }
    private static ErrorStatementSyntax();
    internal ErrorStatementSyntax(SyntaxKind kind, KeywordSyntax errorKeyword, ExpressionSyntax errorNumber);
    internal ErrorStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax errorKeyword, ExpressionSyntax errorNumber);
    internal ErrorStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax errorKeyword, ExpressionSyntax errorNumber);
    internal ErrorStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ErrorKeyword();
    internal ExpressionSyntax get_ErrorNumber();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EventBlockContext : DeclarationContext {
    internal EventBlockContext(StatementSyntax statement, BlockContext prevContext);
    internal virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode node);
    internal virtual LinkResult TryLinkSyntax(VisualBasicSyntaxNode node, BlockContext& newContext);
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax statement);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EventBlockSyntax : DeclarationStatementSyntax {
    internal EventStatementSyntax _eventStatement;
    internal GreenNode _accessors;
    internal EndBlockStatementSyntax _endEventStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal EventStatementSyntax EventStatement { get; }
    internal SyntaxList`1<AccessorBlockSyntax> Accessors { get; }
    internal EndBlockStatementSyntax EndEventStatement { get; }
    private static EventBlockSyntax();
    internal EventBlockSyntax(SyntaxKind kind, EventStatementSyntax eventStatement, GreenNode accessors, EndBlockStatementSyntax endEventStatement);
    internal EventBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, EventStatementSyntax eventStatement, GreenNode accessors, EndBlockStatementSyntax endEventStatement);
    internal EventBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, EventStatementSyntax eventStatement, GreenNode accessors, EndBlockStatementSyntax endEventStatement);
    internal EventBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal EventStatementSyntax get_EventStatement();
    internal SyntaxList`1<AccessorBlockSyntax> get_Accessors();
    internal EndBlockStatementSyntax get_EndEventStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EventContainerSyntax : ExpressionSyntax {
    internal EventContainerSyntax(SyntaxKind kind);
    internal EventContainerSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal EventContainerSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal EventContainerSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.EventStatementSyntax : MethodBaseSyntax {
    internal KeywordSyntax _customKeyword;
    internal KeywordSyntax _eventKeyword;
    internal IdentifierTokenSyntax _identifier;
    internal SimpleAsClauseSyntax _asClause;
    internal ImplementsClauseSyntax _implementsClause;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax CustomKeyword { get; }
    internal KeywordSyntax EventKeyword { get; }
    internal IdentifierTokenSyntax Identifier { get; }
    internal SimpleAsClauseSyntax AsClause { get; }
    internal ImplementsClauseSyntax ImplementsClause { get; }
    private static EventStatementSyntax();
    internal EventStatementSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax customKeyword, KeywordSyntax eventKeyword, IdentifierTokenSyntax identifier, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, ImplementsClauseSyntax implementsClause);
    internal EventStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax customKeyword, KeywordSyntax eventKeyword, IdentifierTokenSyntax identifier, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, ImplementsClauseSyntax implementsClause);
    internal EventStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax customKeyword, KeywordSyntax eventKeyword, IdentifierTokenSyntax identifier, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, ImplementsClauseSyntax implementsClause);
    internal EventStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_CustomKeyword();
    internal KeywordSyntax get_EventKeyword();
    internal IdentifierTokenSyntax get_Identifier();
    internal SimpleAsClauseSyntax get_AsClause();
    internal ImplementsClauseSyntax get_ImplementsClause();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExecutableStatementContext : DeclarationContext {
    internal bool IsSingleLine { get; }
    internal ExecutableStatementContext(SyntaxKind contextKind, StatementSyntax statement, BlockContext prevContext);
    internal sealed virtual StatementSyntax Parse();
    internal virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode node);
    internal virtual LinkResult TryLinkSyntax(VisualBasicSyntaxNode node, BlockContext& newContext);
    internal virtual BlockContext ProcessStatementTerminator(BlockContext lambdaContext);
    internal virtual bool get_IsSingleLine();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExecutableStatementSyntax : StatementSyntax {
    internal ExecutableStatementSyntax(SyntaxKind kind);
    internal ExecutableStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal ExecutableStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal ExecutableStatementSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExitStatementSyntax : ExecutableStatementSyntax {
    internal KeywordSyntax _exitKeyword;
    internal KeywordSyntax _blockKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ExitKeyword { get; }
    internal KeywordSyntax BlockKeyword { get; }
    private static ExitStatementSyntax();
    internal ExitStatementSyntax(SyntaxKind kind, KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal ExitStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal ExitStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal ExitStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ExitKeyword();
    internal KeywordSyntax get_BlockKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionEvaluator : ValueType {
    private ImmutableDictionary`2<string, CConst> _symbols;
    private static Byte[0...,0...] s_dominantType;
    private static ExpressionEvaluator();
    private ExpressionEvaluator(ImmutableDictionary`2<string, CConst> symbols);
    private static int TypeCodeToDominantTypeIndex(SpecialType specialType);
    public static CConst EvaluateCondition(ExpressionSyntax expr, ImmutableDictionary`2<string, CConst> symbols);
    public static CConst EvaluateExpression(ExpressionSyntax expr, ImmutableDictionary`2<string, CConst> symbols);
    private CConst EvaluateExpressionInternal(ExpressionSyntax expr);
    private static BadCConst ReportSemanticError(ERRID id, VisualBasicSyntaxNode node);
    private static BadCConst ReportSemanticError(ERRID id, VisualBasicSyntaxNode node, Object[] args);
    private static CConst EvaluateLiteralExpression(LiteralExpressionSyntax expr);
    private CConst EvaluateParenthesizedExpression(ParenthesizedExpressionSyntax expr);
    private CConst EvaluateIdentifierNameExpression(IdentifierNameSyntax expr);
    private static string GetDisplayString(TypeCharacter typeChar);
    private static TypeCharacter AsTypeCharacter(SpecialType specialType);
    private static SpecialType GetSpecialType(PredefinedTypeSyntax predefinedType);
    private CConst EvaluateTryCastExpression(CastExpressionSyntax expr);
    private CConst EvaluateDirectCastExpression(CastExpressionSyntax expr);
    private CConst EvaluateCTypeExpression(CastExpressionSyntax expr);
    private CConst EvaluatePredefinedCastExpression(PredefinedCastExpressionSyntax expr);
    private CConst EvaluateBinaryIfExpression(BinaryConditionalExpressionSyntax expr);
    private CConst EvaluateTernaryIfExpression(TernaryConditionalExpressionSyntax expr);
    private static CConst ConvertToBool(CConst value, ExpressionSyntax expr);
    private static CConst ConvertToNumeric(CConst value, SpecialType toSpecialType, ExpressionSyntax expr);
    private static CConst ConvertNumericToNumeric(CConst value, SpecialType toSpecialType, ExpressionSyntax expr);
    private static CConst Convert(CConst value, SpecialType toSpecialType, ExpressionSyntax expr);
    private static CConst ConvertToChar(CConst value, ExpressionSyntax expr);
    private static CConst ConvertToDate(CConst value, ExpressionSyntax expr);
    private static CConst ConvertToString(CConst value, ExpressionSyntax expr);
    private static CConst ConvertToObject(CConst value, ExpressionSyntax expr);
    private CConst EvaluateUnaryExpression(UnaryExpressionSyntax expr);
    private static bool IsNothing(CConst val);
    private CConst EvaluateBinaryExpression(BinaryExpressionSyntax expr);
    private static CConst PerformCompileTimeBinaryOperation(SyntaxKind opcode, SpecialType resultType, CConst left, CConst right, ExpressionSyntax expr);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionRangeVariableSyntax : VisualBasicSyntaxNode {
    internal VariableNameEqualsSyntax _nameEquals;
    internal ExpressionSyntax _expression;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal VariableNameEqualsSyntax NameEquals { get; }
    internal ExpressionSyntax Expression { get; }
    private static ExpressionRangeVariableSyntax();
    internal ExpressionRangeVariableSyntax(SyntaxKind kind, VariableNameEqualsSyntax nameEquals, ExpressionSyntax expression);
    internal ExpressionRangeVariableSyntax(SyntaxKind kind, ISyntaxFactoryContext context, VariableNameEqualsSyntax nameEquals, ExpressionSyntax expression);
    internal ExpressionRangeVariableSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, VariableNameEqualsSyntax nameEquals, ExpressionSyntax expression);
    internal ExpressionRangeVariableSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal VariableNameEqualsSyntax get_NameEquals();
    internal ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionStatementSyntax : ExecutableStatementSyntax {
    internal ExpressionSyntax _expression;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ExpressionSyntax Expression { get; }
    private static ExpressionStatementSyntax();
    internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression);
    internal ExpressionStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ExpressionSyntax expression);
    internal ExpressionStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax expression);
    internal ExpressionStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExpressionSyntax : VisualBasicSyntaxNode {
    internal ExpressionSyntax(SyntaxKind kind);
    internal ExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal ExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal ExpressionSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExternalChecksumDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal KeywordSyntax _externalChecksumKeyword;
    internal PunctuationSyntax _openParenToken;
    internal StringLiteralTokenSyntax _externalSource;
    internal PunctuationSyntax _firstCommaToken;
    internal StringLiteralTokenSyntax _guid;
    internal PunctuationSyntax _secondCommaToken;
    internal StringLiteralTokenSyntax _checksum;
    internal PunctuationSyntax _closeParenToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ExternalChecksumKeyword { get; }
    internal PunctuationSyntax OpenParenToken { get; }
    internal StringLiteralTokenSyntax ExternalSource { get; }
    internal PunctuationSyntax FirstCommaToken { get; }
    internal StringLiteralTokenSyntax Guid { get; }
    internal PunctuationSyntax SecondCommaToken { get; }
    internal StringLiteralTokenSyntax Checksum { get; }
    internal PunctuationSyntax CloseParenToken { get; }
    private static ExternalChecksumDirectiveTriviaSyntax();
    internal ExternalChecksumDirectiveTriviaSyntax(SyntaxKind kind, PunctuationSyntax hashToken, KeywordSyntax externalChecksumKeyword, PunctuationSyntax openParenToken, StringLiteralTokenSyntax externalSource, PunctuationSyntax firstCommaToken, StringLiteralTokenSyntax guid, PunctuationSyntax secondCommaToken, StringLiteralTokenSyntax checksum, PunctuationSyntax closeParenToken);
    internal ExternalChecksumDirectiveTriviaSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax hashToken, KeywordSyntax externalChecksumKeyword, PunctuationSyntax openParenToken, StringLiteralTokenSyntax externalSource, PunctuationSyntax firstCommaToken, StringLiteralTokenSyntax guid, PunctuationSyntax secondCommaToken, StringLiteralTokenSyntax checksum, PunctuationSyntax closeParenToken);
    internal ExternalChecksumDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax externalChecksumKeyword, PunctuationSyntax openParenToken, StringLiteralTokenSyntax externalSource, PunctuationSyntax firstCommaToken, StringLiteralTokenSyntax guid, PunctuationSyntax secondCommaToken, StringLiteralTokenSyntax checksum, PunctuationSyntax closeParenToken);
    internal ExternalChecksumDirectiveTriviaSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ExternalChecksumKeyword();
    internal PunctuationSyntax get_OpenParenToken();
    internal StringLiteralTokenSyntax get_ExternalSource();
    internal PunctuationSyntax get_FirstCommaToken();
    internal StringLiteralTokenSyntax get_Guid();
    internal PunctuationSyntax get_SecondCommaToken();
    internal StringLiteralTokenSyntax get_Checksum();
    internal PunctuationSyntax get_CloseParenToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ExternalSourceDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal KeywordSyntax _externalSourceKeyword;
    internal PunctuationSyntax _openParenToken;
    internal StringLiteralTokenSyntax _externalSource;
    internal PunctuationSyntax _commaToken;
    internal IntegerLiteralTokenSyntax _lineStart;
    internal PunctuationSyntax _closeParenToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ExternalSourceKeyword { get; }
    internal PunctuationSyntax OpenParenToken { get; }
    internal StringLiteralTokenSyntax ExternalSource { get; }
    internal PunctuationSyntax CommaToken { get; }
    internal IntegerLiteralTokenSyntax LineStart { get; }
    internal PunctuationSyntax CloseParenToken { get; }
    private static ExternalSourceDirectiveTriviaSyntax();
    internal ExternalSourceDirectiveTriviaSyntax(SyntaxKind kind, PunctuationSyntax hashToken, KeywordSyntax externalSourceKeyword, PunctuationSyntax openParenToken, StringLiteralTokenSyntax externalSource, PunctuationSyntax commaToken, IntegerLiteralTokenSyntax lineStart, PunctuationSyntax closeParenToken);
    internal ExternalSourceDirectiveTriviaSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax hashToken, KeywordSyntax externalSourceKeyword, PunctuationSyntax openParenToken, StringLiteralTokenSyntax externalSource, PunctuationSyntax commaToken, IntegerLiteralTokenSyntax lineStart, PunctuationSyntax closeParenToken);
    internal ExternalSourceDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax externalSourceKeyword, PunctuationSyntax openParenToken, StringLiteralTokenSyntax externalSource, PunctuationSyntax commaToken, IntegerLiteralTokenSyntax lineStart, PunctuationSyntax closeParenToken);
    internal ExternalSourceDirectiveTriviaSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ExternalSourceKeyword();
    internal PunctuationSyntax get_OpenParenToken();
    internal StringLiteralTokenSyntax get_ExternalSource();
    internal PunctuationSyntax get_CommaToken();
    internal IntegerLiteralTokenSyntax get_LineStart();
    internal PunctuationSyntax get_CloseParenToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal enum Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Feature : Enum {
    public int value__;
    public static Feature AutoProperties;
    public static Feature LineContinuation;
    public static Feature StatementLambdas;
    public static Feature CoContraVariance;
    public static Feature CollectionInitializers;
    public static Feature SubLambdas;
    public static Feature ArrayLiterals;
    public static Feature AsyncExpressions;
    public static Feature Iterators;
    public static Feature GlobalNamespace;
    public static Feature NullPropagatingOperator;
    public static Feature NameOfExpressions;
    public static Feature InterpolatedStrings;
    public static Feature ReadonlyAutoProperties;
    public static Feature RegionsEverywhere;
    public static Feature MultilineStringLiterals;
    public static Feature CObjInAttributeArguments;
    public static Feature LineContinuationComments;
    public static Feature TypeOfIsNot;
    public static Feature YearFirstDateLiterals;
    public static Feature WarningDirectives;
    public static Feature PartialModules;
    public static Feature PartialInterfaces;
    public static Feature ImplementingReadonlyOrWriteonlyPropertyWithReadwrite;
    public static Feature IOperation;
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FeatureExtensions : object {
    [ExtensionAttribute]
internal static string GetFeatureFlag(Feature feature);
    [ExtensionAttribute]
internal static LanguageVersion GetLanguageVersion(Feature feature);
    [ExtensionAttribute]
internal static ERRID GetResourceId(Feature feature);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FieldDeclarationSyntax : DeclarationStatementSyntax {
    internal GreenNode _attributeLists;
    internal GreenNode _modifiers;
    internal GreenNode _declarators;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    internal SyntaxList`1<KeywordSyntax> Modifiers { get; }
    internal SeparatedSyntaxList`1<VariableDeclaratorSyntax> Declarators { get; }
    private static FieldDeclarationSyntax();
    internal FieldDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, GreenNode declarators);
    internal FieldDeclarationSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, GreenNode modifiers, GreenNode declarators);
    internal FieldDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, GreenNode modifiers, GreenNode declarators);
    internal FieldDeclarationSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal SyntaxList`1<KeywordSyntax> get_Modifiers();
    internal SeparatedSyntaxList`1<VariableDeclaratorSyntax> get_Declarators();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FieldInitializerSyntax : VisualBasicSyntaxNode {
    internal KeywordSyntax _keyKeyword;
    internal KeywordSyntax KeyKeyword { get; }
    internal FieldInitializerSyntax(SyntaxKind kind, KeywordSyntax keyKeyword);
    internal FieldInitializerSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax keyKeyword);
    internal FieldInitializerSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyKeyword);
    internal FieldInitializerSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal KeywordSyntax get_KeyKeyword();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FinallyBlockSyntax : VisualBasicSyntaxNode {
    internal FinallyStatementSyntax _finallyStatement;
    internal GreenNode _statements;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal FinallyStatementSyntax FinallyStatement { get; }
    internal SyntaxList`1<StatementSyntax> Statements { get; }
    private static FinallyBlockSyntax();
    internal FinallyBlockSyntax(SyntaxKind kind, FinallyStatementSyntax finallyStatement, GreenNode statements);
    internal FinallyBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, FinallyStatementSyntax finallyStatement, GreenNode statements);
    internal FinallyBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, FinallyStatementSyntax finallyStatement, GreenNode statements);
    internal FinallyBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal FinallyStatementSyntax get_FinallyStatement();
    internal SyntaxList`1<StatementSyntax> get_Statements();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FinallyPartContext : ExecutableStatementContext {
    internal FinallyPartContext(StatementSyntax statement, BlockContext prevContext);
    internal virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode node);
    internal virtual LinkResult TryLinkSyntax(VisualBasicSyntaxNode node, BlockContext& newContext);
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax statement);
    internal virtual BlockContext EndBlock(StatementSyntax statement);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FinallyStatementSyntax : StatementSyntax {
    internal KeywordSyntax _finallyKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax FinallyKeyword { get; }
    private static FinallyStatementSyntax();
    internal FinallyStatementSyntax(SyntaxKind kind, KeywordSyntax finallyKeyword);
    internal FinallyStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax finallyKeyword);
    internal FinallyStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax finallyKeyword);
    internal FinallyStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_FinallyKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FirstTokenReplacer : VisualBasicSyntaxRewriter {
    private Func`2<SyntaxToken, SyntaxToken> _newItem;
    private bool _isFirst;
    private FirstTokenReplacer(Func`2<SyntaxToken, SyntaxToken> newItem);
    internal static TTree Replace(TTree root, Func`2<SyntaxToken, SyntaxToken> newItem);
    public virtual VisualBasicSyntaxNode Visit(VisualBasicSyntaxNode node);
    public virtual SyntaxToken VisitSyntaxToken(SyntaxToken token);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FloatingLiteralTokenSyntax : SyntaxToken {
    internal TypeCharacter _typeSuffix;
    internal TypeCharacter TypeSuffix { get; }
    internal FloatingLiteralTokenSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, TypeCharacter typeSuffix);
    internal FloatingLiteralTokenSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, TypeCharacter typeSuffix);
    internal FloatingLiteralTokenSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal TypeCharacter get_TypeSuffix();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FloatingLiteralTokenSyntax`1 : FloatingLiteralTokenSyntax {
    internal T _value;
    internal T Value { get; }
    internal string ValueText { get; }
    internal object ObjectValue { get; }
    internal FloatingLiteralTokenSyntax`1(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, TypeCharacter typeSuffix, T value);
    internal FloatingLiteralTokenSyntax`1(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, TypeCharacter typeSuffix, T value);
    internal FloatingLiteralTokenSyntax`1(ObjectReader reader);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual void WriteTo(ObjectWriter writer);
    internal T get_Value();
    internal virtual string get_ValueText();
    internal virtual object get_ObjectValue();
    public virtual GreenNode WithLeadingTrivia(GreenNode trivia);
    public virtual GreenNode WithTrailingTrivia(GreenNode trivia);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForBlockContext : ExecutableStatementContext {
    private static NextStatementSyntax s_emptyNextStatement;
    private static ForBlockContext();
    internal ForBlockContext(StatementSyntax statement, BlockContext prevContext);
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax endStmt);
    internal virtual BlockContext EndBlock(StatementSyntax endStmt);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForBlockSyntax : ForOrForEachBlockSyntax {
    internal ForStatementSyntax _forStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ForStatementSyntax ForStatement { get; }
    private static ForBlockSyntax();
    internal ForBlockSyntax(SyntaxKind kind, ForStatementSyntax forStatement, GreenNode statements, NextStatementSyntax nextStatement);
    internal ForBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ForStatementSyntax forStatement, GreenNode statements, NextStatementSyntax nextStatement);
    internal ForBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ForStatementSyntax forStatement, GreenNode statements, NextStatementSyntax nextStatement);
    internal ForBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ForStatementSyntax get_ForStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForEachBlockSyntax : ForOrForEachBlockSyntax {
    internal ForEachStatementSyntax _forEachStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ForEachStatementSyntax ForEachStatement { get; }
    private static ForEachBlockSyntax();
    internal ForEachBlockSyntax(SyntaxKind kind, ForEachStatementSyntax forEachStatement, GreenNode statements, NextStatementSyntax nextStatement);
    internal ForEachBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ForEachStatementSyntax forEachStatement, GreenNode statements, NextStatementSyntax nextStatement);
    internal ForEachBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ForEachStatementSyntax forEachStatement, GreenNode statements, NextStatementSyntax nextStatement);
    internal ForEachBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ForEachStatementSyntax get_ForEachStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForEachStatementSyntax : ForOrForEachStatementSyntax {
    internal KeywordSyntax _eachKeyword;
    internal KeywordSyntax _inKeyword;
    internal ExpressionSyntax _expression;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax EachKeyword { get; }
    internal KeywordSyntax InKeyword { get; }
    internal ExpressionSyntax Expression { get; }
    private static ForEachStatementSyntax();
    internal ForEachStatementSyntax(SyntaxKind kind, KeywordSyntax forKeyword, KeywordSyntax eachKeyword, VisualBasicSyntaxNode controlVariable, KeywordSyntax inKeyword, ExpressionSyntax expression);
    internal ForEachStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax forKeyword, KeywordSyntax eachKeyword, VisualBasicSyntaxNode controlVariable, KeywordSyntax inKeyword, ExpressionSyntax expression);
    internal ForEachStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax forKeyword, KeywordSyntax eachKeyword, VisualBasicSyntaxNode controlVariable, KeywordSyntax inKeyword, ExpressionSyntax expression);
    internal ForEachStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_EachKeyword();
    internal KeywordSyntax get_InKeyword();
    internal ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForOrForEachBlockSyntax : ExecutableStatementSyntax {
    internal GreenNode _statements;
    internal NextStatementSyntax _nextStatement;
    internal SyntaxList`1<StatementSyntax> Statements { get; }
    internal NextStatementSyntax NextStatement { get; }
    internal ForOrForEachBlockSyntax(SyntaxKind kind, GreenNode statements, NextStatementSyntax nextStatement);
    internal ForOrForEachBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode statements, NextStatementSyntax nextStatement);
    internal ForOrForEachBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode statements, NextStatementSyntax nextStatement);
    internal ForOrForEachBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal SyntaxList`1<StatementSyntax> get_Statements();
    internal NextStatementSyntax get_NextStatement();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForOrForEachStatementSyntax : StatementSyntax {
    internal KeywordSyntax _forKeyword;
    internal VisualBasicSyntaxNode _controlVariable;
    internal KeywordSyntax ForKeyword { get; }
    internal VisualBasicSyntaxNode ControlVariable { get; }
    internal ForOrForEachStatementSyntax(SyntaxKind kind, KeywordSyntax forKeyword, VisualBasicSyntaxNode controlVariable);
    internal ForOrForEachStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax forKeyword, VisualBasicSyntaxNode controlVariable);
    internal ForOrForEachStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax forKeyword, VisualBasicSyntaxNode controlVariable);
    internal ForOrForEachStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal KeywordSyntax get_ForKeyword();
    internal VisualBasicSyntaxNode get_ControlVariable();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForStatementSyntax : ForOrForEachStatementSyntax {
    internal PunctuationSyntax _equalsToken;
    internal ExpressionSyntax _fromValue;
    internal KeywordSyntax _toKeyword;
    internal ExpressionSyntax _toValue;
    internal ForStepClauseSyntax _stepClause;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax EqualsToken { get; }
    internal ExpressionSyntax FromValue { get; }
    internal KeywordSyntax ToKeyword { get; }
    internal ExpressionSyntax ToValue { get; }
    internal ForStepClauseSyntax StepClause { get; }
    private static ForStatementSyntax();
    internal ForStatementSyntax(SyntaxKind kind, KeywordSyntax forKeyword, VisualBasicSyntaxNode controlVariable, PunctuationSyntax equalsToken, ExpressionSyntax fromValue, KeywordSyntax toKeyword, ExpressionSyntax toValue, ForStepClauseSyntax stepClause);
    internal ForStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax forKeyword, VisualBasicSyntaxNode controlVariable, PunctuationSyntax equalsToken, ExpressionSyntax fromValue, KeywordSyntax toKeyword, ExpressionSyntax toValue, ForStepClauseSyntax stepClause);
    internal ForStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax forKeyword, VisualBasicSyntaxNode controlVariable, PunctuationSyntax equalsToken, ExpressionSyntax fromValue, KeywordSyntax toKeyword, ExpressionSyntax toValue, ForStepClauseSyntax stepClause);
    internal ForStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_EqualsToken();
    internal ExpressionSyntax get_FromValue();
    internal KeywordSyntax get_ToKeyword();
    internal ExpressionSyntax get_ToValue();
    internal ForStepClauseSyntax get_StepClause();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ForStepClauseSyntax : VisualBasicSyntaxNode {
    internal KeywordSyntax _stepKeyword;
    internal ExpressionSyntax _stepValue;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax StepKeyword { get; }
    internal ExpressionSyntax StepValue { get; }
    private static ForStepClauseSyntax();
    internal ForStepClauseSyntax(SyntaxKind kind, KeywordSyntax stepKeyword, ExpressionSyntax stepValue);
    internal ForStepClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax stepKeyword, ExpressionSyntax stepValue);
    internal ForStepClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax stepKeyword, ExpressionSyntax stepValue);
    internal ForStepClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_StepKeyword();
    internal ExpressionSyntax get_StepValue();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FromClauseSyntax : QueryClauseSyntax {
    internal KeywordSyntax _fromKeyword;
    internal GreenNode _variables;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax FromKeyword { get; }
    internal SeparatedSyntaxList`1<CollectionRangeVariableSyntax> Variables { get; }
    private static FromClauseSyntax();
    internal FromClauseSyntax(SyntaxKind kind, KeywordSyntax fromKeyword, GreenNode variables);
    internal FromClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax fromKeyword, GreenNode variables);
    internal FromClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax fromKeyword, GreenNode variables);
    internal FromClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_FromKeyword();
    internal SeparatedSyntaxList`1<CollectionRangeVariableSyntax> get_Variables();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.FunctionAggregationSyntax : AggregationSyntax {
    internal IdentifierTokenSyntax _functionName;
    internal PunctuationSyntax _openParenToken;
    internal ExpressionSyntax _argument;
    internal PunctuationSyntax _closeParenToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal IdentifierTokenSyntax FunctionName { get; }
    internal PunctuationSyntax OpenParenToken { get; }
    internal ExpressionSyntax Argument { get; }
    internal PunctuationSyntax CloseParenToken { get; }
    private static FunctionAggregationSyntax();
    internal FunctionAggregationSyntax(SyntaxKind kind, IdentifierTokenSyntax functionName, PunctuationSyntax openParenToken, ExpressionSyntax argument, PunctuationSyntax closeParenToken);
    internal FunctionAggregationSyntax(SyntaxKind kind, ISyntaxFactoryContext context, IdentifierTokenSyntax functionName, PunctuationSyntax openParenToken, ExpressionSyntax argument, PunctuationSyntax closeParenToken);
    internal FunctionAggregationSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, IdentifierTokenSyntax functionName, PunctuationSyntax openParenToken, ExpressionSyntax argument, PunctuationSyntax closeParenToken);
    internal FunctionAggregationSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal IdentifierTokenSyntax get_FunctionName();
    internal PunctuationSyntax get_OpenParenToken();
    internal ExpressionSyntax get_Argument();
    internal PunctuationSyntax get_CloseParenToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GenericNameSyntax : SimpleNameSyntax {
    internal TypeArgumentListSyntax _typeArgumentList;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal TypeArgumentListSyntax TypeArgumentList { get; }
    private static GenericNameSyntax();
    internal GenericNameSyntax(SyntaxKind kind, IdentifierTokenSyntax identifier, TypeArgumentListSyntax typeArgumentList);
    internal GenericNameSyntax(SyntaxKind kind, ISyntaxFactoryContext context, IdentifierTokenSyntax identifier, TypeArgumentListSyntax typeArgumentList);
    internal GenericNameSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, IdentifierTokenSyntax identifier, TypeArgumentListSyntax typeArgumentList);
    internal GenericNameSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal TypeArgumentListSyntax get_TypeArgumentList();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GetTypeExpressionSyntax : ExpressionSyntax {
    internal KeywordSyntax _getTypeKeyword;
    internal PunctuationSyntax _openParenToken;
    internal TypeSyntax _type;
    internal PunctuationSyntax _closeParenToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax GetTypeKeyword { get; }
    internal PunctuationSyntax OpenParenToken { get; }
    internal TypeSyntax Type { get; }
    internal PunctuationSyntax CloseParenToken { get; }
    private static GetTypeExpressionSyntax();
    internal GetTypeExpressionSyntax(SyntaxKind kind, KeywordSyntax getTypeKeyword, PunctuationSyntax openParenToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal GetTypeExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax getTypeKeyword, PunctuationSyntax openParenToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal GetTypeExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax getTypeKeyword, PunctuationSyntax openParenToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal GetTypeExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_GetTypeKeyword();
    internal PunctuationSyntax get_OpenParenToken();
    internal TypeSyntax get_Type();
    internal PunctuationSyntax get_CloseParenToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GetXmlNamespaceExpressionSyntax : ExpressionSyntax {
    internal KeywordSyntax _getXmlNamespaceKeyword;
    internal PunctuationSyntax _openParenToken;
    internal XmlPrefixNameSyntax _name;
    internal PunctuationSyntax _closeParenToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax GetXmlNamespaceKeyword { get; }
    internal PunctuationSyntax OpenParenToken { get; }
    internal XmlPrefixNameSyntax Name { get; }
    internal PunctuationSyntax CloseParenToken { get; }
    private static GetXmlNamespaceExpressionSyntax();
    internal GetXmlNamespaceExpressionSyntax(SyntaxKind kind, KeywordSyntax getXmlNamespaceKeyword, PunctuationSyntax openParenToken, XmlPrefixNameSyntax name, PunctuationSyntax closeParenToken);
    internal GetXmlNamespaceExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax getXmlNamespaceKeyword, PunctuationSyntax openParenToken, XmlPrefixNameSyntax name, PunctuationSyntax closeParenToken);
    internal GetXmlNamespaceExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax getXmlNamespaceKeyword, PunctuationSyntax openParenToken, XmlPrefixNameSyntax name, PunctuationSyntax closeParenToken);
    internal GetXmlNamespaceExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_GetXmlNamespaceKeyword();
    internal PunctuationSyntax get_OpenParenToken();
    internal XmlPrefixNameSyntax get_Name();
    internal PunctuationSyntax get_CloseParenToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GlobalNameSyntax : NameSyntax {
    internal KeywordSyntax _globalKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax GlobalKeyword { get; }
    private static GlobalNameSyntax();
    internal GlobalNameSyntax(SyntaxKind kind, KeywordSyntax globalKeyword);
    internal GlobalNameSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax globalKeyword);
    internal GlobalNameSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax globalKeyword);
    internal GlobalNameSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_GlobalKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GoToStatementSyntax : ExecutableStatementSyntax {
    internal KeywordSyntax _goToKeyword;
    internal LabelSyntax _label;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax GoToKeyword { get; }
    internal LabelSyntax Label { get; }
    private static GoToStatementSyntax();
    internal GoToStatementSyntax(SyntaxKind kind, KeywordSyntax goToKeyword, LabelSyntax label);
    internal GoToStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax goToKeyword, LabelSyntax label);
    internal GoToStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax goToKeyword, LabelSyntax label);
    internal GoToStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_GoToKeyword();
    internal LabelSyntax get_Label();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GreenStats : object {
    private static GreenStats s_stats;
    private static GreenStats();
    internal static void NoteGreen(GreenNode node);
    [ConditionalAttribute("DEBUG")]
internal static void ItemAdded();
    [ConditionalAttribute("DEBUG")]
internal static void ItemCacheable();
    [ConditionalAttribute("DEBUG")]
internal static void CacheHit();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GroupAggregationSyntax : AggregationSyntax {
    internal KeywordSyntax _groupKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax GroupKeyword { get; }
    private static GroupAggregationSyntax();
    internal GroupAggregationSyntax(SyntaxKind kind, KeywordSyntax groupKeyword);
    internal GroupAggregationSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax groupKeyword);
    internal GroupAggregationSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax groupKeyword);
    internal GroupAggregationSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_GroupKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GroupByClauseSyntax : QueryClauseSyntax {
    internal KeywordSyntax _groupKeyword;
    internal GreenNode _items;
    internal KeywordSyntax _byKeyword;
    internal GreenNode _keys;
    internal KeywordSyntax _intoKeyword;
    internal GreenNode _aggregationVariables;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax GroupKeyword { get; }
    internal SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> Items { get; }
    internal KeywordSyntax ByKeyword { get; }
    internal SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> Keys { get; }
    internal KeywordSyntax IntoKeyword { get; }
    internal SeparatedSyntaxList`1<AggregationRangeVariableSyntax> AggregationVariables { get; }
    private static GroupByClauseSyntax();
    internal GroupByClauseSyntax(SyntaxKind kind, KeywordSyntax groupKeyword, GreenNode items, KeywordSyntax byKeyword, GreenNode keys, KeywordSyntax intoKeyword, GreenNode aggregationVariables);
    internal GroupByClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax groupKeyword, GreenNode items, KeywordSyntax byKeyword, GreenNode keys, KeywordSyntax intoKeyword, GreenNode aggregationVariables);
    internal GroupByClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax groupKeyword, GreenNode items, KeywordSyntax byKeyword, GreenNode keys, KeywordSyntax intoKeyword, GreenNode aggregationVariables);
    internal GroupByClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_GroupKeyword();
    internal SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> get_Items();
    internal KeywordSyntax get_ByKeyword();
    internal SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> get_Keys();
    internal KeywordSyntax get_IntoKeyword();
    internal SeparatedSyntaxList`1<AggregationRangeVariableSyntax> get_AggregationVariables();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.GroupJoinClauseSyntax : JoinClauseSyntax {
    internal KeywordSyntax _groupKeyword;
    internal KeywordSyntax _intoKeyword;
    internal GreenNode _aggregationVariables;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax GroupKeyword { get; }
    internal KeywordSyntax IntoKeyword { get; }
    internal SeparatedSyntaxList`1<AggregationRangeVariableSyntax> AggregationVariables { get; }
    private static GroupJoinClauseSyntax();
    internal GroupJoinClauseSyntax(SyntaxKind kind, KeywordSyntax groupKeyword, KeywordSyntax joinKeyword, GreenNode joinedVariables, GreenNode additionalJoins, KeywordSyntax onKeyword, GreenNode joinConditions, KeywordSyntax intoKeyword, GreenNode aggregationVariables);
    internal GroupJoinClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax groupKeyword, KeywordSyntax joinKeyword, GreenNode joinedVariables, GreenNode additionalJoins, KeywordSyntax onKeyword, GreenNode joinConditions, KeywordSyntax intoKeyword, GreenNode aggregationVariables);
    internal GroupJoinClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax groupKeyword, KeywordSyntax joinKeyword, GreenNode joinedVariables, GreenNode additionalJoins, KeywordSyntax onKeyword, GreenNode joinConditions, KeywordSyntax intoKeyword, GreenNode aggregationVariables);
    internal GroupJoinClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_GroupKeyword();
    internal KeywordSyntax get_IntoKeyword();
    internal SeparatedSyntaxList`1<AggregationRangeVariableSyntax> get_AggregationVariables();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.HandlesClauseItemSyntax : VisualBasicSyntaxNode {
    internal EventContainerSyntax _eventContainer;
    internal PunctuationSyntax _dotToken;
    internal IdentifierNameSyntax _eventMember;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal EventContainerSyntax EventContainer { get; }
    internal PunctuationSyntax DotToken { get; }
    internal IdentifierNameSyntax EventMember { get; }
    private static HandlesClauseItemSyntax();
    internal HandlesClauseItemSyntax(SyntaxKind kind, EventContainerSyntax eventContainer, PunctuationSyntax dotToken, IdentifierNameSyntax eventMember);
    internal HandlesClauseItemSyntax(SyntaxKind kind, ISyntaxFactoryContext context, EventContainerSyntax eventContainer, PunctuationSyntax dotToken, IdentifierNameSyntax eventMember);
    internal HandlesClauseItemSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, EventContainerSyntax eventContainer, PunctuationSyntax dotToken, IdentifierNameSyntax eventMember);
    internal HandlesClauseItemSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal EventContainerSyntax get_EventContainer();
    internal PunctuationSyntax get_DotToken();
    internal IdentifierNameSyntax get_EventMember();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.HandlesClauseSyntax : VisualBasicSyntaxNode {
    internal KeywordSyntax _handlesKeyword;
    internal GreenNode _events;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax HandlesKeyword { get; }
    internal SeparatedSyntaxList`1<HandlesClauseItemSyntax> Events { get; }
    private static HandlesClauseSyntax();
    internal HandlesClauseSyntax(SyntaxKind kind, KeywordSyntax handlesKeyword, GreenNode events);
    internal HandlesClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax handlesKeyword, GreenNode events);
    internal HandlesClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax handlesKeyword, GreenNode events);
    internal HandlesClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_HandlesKeyword();
    internal SeparatedSyntaxList`1<HandlesClauseItemSyntax> get_Events();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierNameSyntax : SimpleNameSyntax {
    internal static Func`2<ObjectReader, object> CreateInstance;
    private static IdentifierNameSyntax();
    internal IdentifierNameSyntax(SyntaxKind kind, IdentifierTokenSyntax identifier);
    internal IdentifierNameSyntax(SyntaxKind kind, ISyntaxFactoryContext context, IdentifierTokenSyntax identifier);
    internal IdentifierNameSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, IdentifierTokenSyntax identifier);
    internal IdentifierNameSyntax(ObjectReader reader);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IdentifierTokenSyntax : SyntaxToken {
    internal SyntaxKind PossibleKeywordKind { get; }
    internal bool IsBracketed { get; }
    internal string IdentifierText { get; }
    internal string ValueText { get; }
    public int RawContextualKind { get; }
    internal TypeCharacter TypeCharacter { get; }
    internal IdentifierTokenSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, string text, VisualBasicSyntaxNode precedingTrivia, VisualBasicSyntaxNode followingTrivia);
    internal IdentifierTokenSyntax(ObjectReader reader);
    internal abstract virtual SyntaxKind get_PossibleKeywordKind();
    internal abstract virtual bool get_IsBracketed();
    internal abstract virtual string get_IdentifierText();
    internal virtual string get_ValueText();
    public virtual int get_RawContextualKind();
    internal abstract virtual TypeCharacter get_TypeCharacter();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IfBlockContext : ExecutableStatementContext {
    private SyntaxListBuilder`1<ElseIfBlockSyntax> _elseIfBlocks;
    private ElseBlockSyntax _optionalElseBlock;
    internal IfBlockContext(StatementSyntax statement, BlockContext prevContext);
    internal virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode node);
    internal virtual LinkResult TryLinkSyntax(VisualBasicSyntaxNode node, BlockContext& newContext);
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax endStmt);
    internal virtual BlockContext EndBlock(StatementSyntax statement);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IfDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal KeywordSyntax _elseKeyword;
    internal KeywordSyntax _ifOrElseIfKeyword;
    internal ExpressionSyntax _condition;
    internal KeywordSyntax _thenKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ElseKeyword { get; }
    internal KeywordSyntax IfOrElseIfKeyword { get; }
    internal ExpressionSyntax Condition { get; }
    internal KeywordSyntax ThenKeyword { get; }
    private static IfDirectiveTriviaSyntax();
    internal IfDirectiveTriviaSyntax(SyntaxKind kind, PunctuationSyntax hashToken, KeywordSyntax elseKeyword, KeywordSyntax ifOrElseIfKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    internal IfDirectiveTriviaSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax hashToken, KeywordSyntax elseKeyword, KeywordSyntax ifOrElseIfKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    internal IfDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax elseKeyword, KeywordSyntax ifOrElseIfKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    internal IfDirectiveTriviaSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ElseKeyword();
    internal KeywordSyntax get_IfOrElseIfKeyword();
    internal ExpressionSyntax get_Condition();
    internal KeywordSyntax get_ThenKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IfPartContext : ExecutableStatementContext {
    internal IfPartContext(SyntaxKind kind, StatementSyntax statement, BlockContext prevContext);
    internal virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode node);
    internal virtual LinkResult TryLinkSyntax(VisualBasicSyntaxNode node, BlockContext& newContext);
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax statement);
    internal virtual BlockContext EndBlock(StatementSyntax statement);
    internal virtual BlockContext ResyncAndProcessStatementTerminator(StatementSyntax statement, BlockContext lambdaContext);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IfStatementSyntax : StatementSyntax {
    internal KeywordSyntax _ifKeyword;
    internal ExpressionSyntax _condition;
    internal KeywordSyntax _thenKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax IfKeyword { get; }
    internal ExpressionSyntax Condition { get; }
    internal KeywordSyntax ThenKeyword { get; }
    private static IfStatementSyntax();
    internal IfStatementSyntax(SyntaxKind kind, KeywordSyntax ifKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    internal IfStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax ifKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    internal IfStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax ifKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    internal IfStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_IfKeyword();
    internal ExpressionSyntax get_Condition();
    internal KeywordSyntax get_ThenKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImplementsClauseSyntax : VisualBasicSyntaxNode {
    internal KeywordSyntax _implementsKeyword;
    internal GreenNode _interfaceMembers;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ImplementsKeyword { get; }
    internal SeparatedSyntaxList`1<QualifiedNameSyntax> InterfaceMembers { get; }
    private static ImplementsClauseSyntax();
    internal ImplementsClauseSyntax(SyntaxKind kind, KeywordSyntax implementsKeyword, GreenNode interfaceMembers);
    internal ImplementsClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax implementsKeyword, GreenNode interfaceMembers);
    internal ImplementsClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax implementsKeyword, GreenNode interfaceMembers);
    internal ImplementsClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ImplementsKeyword();
    internal SeparatedSyntaxList`1<QualifiedNameSyntax> get_InterfaceMembers();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImplementsStatementSyntax : InheritsOrImplementsStatementSyntax {
    internal KeywordSyntax _implementsKeyword;
    internal GreenNode _types;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ImplementsKeyword { get; }
    internal SeparatedSyntaxList`1<TypeSyntax> Types { get; }
    private static ImplementsStatementSyntax();
    internal ImplementsStatementSyntax(SyntaxKind kind, KeywordSyntax implementsKeyword, GreenNode types);
    internal ImplementsStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax implementsKeyword, GreenNode types);
    internal ImplementsStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax implementsKeyword, GreenNode types);
    internal ImplementsStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ImplementsKeyword();
    internal SeparatedSyntaxList`1<TypeSyntax> get_Types();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImportAliasClauseSyntax : VisualBasicSyntaxNode {
    internal IdentifierTokenSyntax _identifier;
    internal PunctuationSyntax _equalsToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal IdentifierTokenSyntax Identifier { get; }
    internal PunctuationSyntax EqualsToken { get; }
    private static ImportAliasClauseSyntax();
    internal ImportAliasClauseSyntax(SyntaxKind kind, IdentifierTokenSyntax identifier, PunctuationSyntax equalsToken);
    internal ImportAliasClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, IdentifierTokenSyntax identifier, PunctuationSyntax equalsToken);
    internal ImportAliasClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, IdentifierTokenSyntax identifier, PunctuationSyntax equalsToken);
    internal ImportAliasClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal IdentifierTokenSyntax get_Identifier();
    internal PunctuationSyntax get_EqualsToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImportsClauseSyntax : VisualBasicSyntaxNode {
    internal ImportsClauseSyntax(SyntaxKind kind);
    internal ImportsClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal ImportsClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal ImportsClauseSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ImportsStatementSyntax : DeclarationStatementSyntax {
    internal KeywordSyntax _importsKeyword;
    internal GreenNode _importsClauses;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ImportsKeyword { get; }
    internal SeparatedSyntaxList`1<ImportsClauseSyntax> ImportsClauses { get; }
    private static ImportsStatementSyntax();
    internal ImportsStatementSyntax(SyntaxKind kind, KeywordSyntax importsKeyword, GreenNode importsClauses);
    internal ImportsStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax importsKeyword, GreenNode importsClauses);
    internal ImportsStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax importsKeyword, GreenNode importsClauses);
    internal ImportsStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ImportsKeyword();
    internal SeparatedSyntaxList`1<ImportsClauseSyntax> get_ImportsClauses();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IncompleteMemberSyntax : DeclarationStatementSyntax {
    internal GreenNode _attributeLists;
    internal GreenNode _modifiers;
    internal IdentifierTokenSyntax _missingIdentifier;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    internal SyntaxList`1<KeywordSyntax> Modifiers { get; }
    internal IdentifierTokenSyntax MissingIdentifier { get; }
    private static IncompleteMemberSyntax();
    internal IncompleteMemberSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, IdentifierTokenSyntax missingIdentifier);
    internal IncompleteMemberSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, GreenNode modifiers, IdentifierTokenSyntax missingIdentifier);
    internal IncompleteMemberSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, GreenNode modifiers, IdentifierTokenSyntax missingIdentifier);
    internal IncompleteMemberSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal SyntaxList`1<KeywordSyntax> get_Modifiers();
    internal IdentifierTokenSyntax get_MissingIdentifier();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InferredFieldInitializerSyntax : FieldInitializerSyntax {
    internal ExpressionSyntax _expression;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ExpressionSyntax Expression { get; }
    private static InferredFieldInitializerSyntax();
    internal InferredFieldInitializerSyntax(SyntaxKind kind, KeywordSyntax keyKeyword, ExpressionSyntax expression);
    internal InferredFieldInitializerSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax keyKeyword, ExpressionSyntax expression);
    internal InferredFieldInitializerSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyKeyword, ExpressionSyntax expression);
    internal InferredFieldInitializerSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InheritsOrImplementsStatementSyntax : DeclarationStatementSyntax {
    internal InheritsOrImplementsStatementSyntax(SyntaxKind kind);
    internal InheritsOrImplementsStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal InheritsOrImplementsStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal InheritsOrImplementsStatementSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InheritsStatementSyntax : InheritsOrImplementsStatementSyntax {
    internal KeywordSyntax _inheritsKeyword;
    internal GreenNode _types;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax InheritsKeyword { get; }
    internal SeparatedSyntaxList`1<TypeSyntax> Types { get; }
    private static InheritsStatementSyntax();
    internal InheritsStatementSyntax(SyntaxKind kind, KeywordSyntax inheritsKeyword, GreenNode types);
    internal InheritsStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax inheritsKeyword, GreenNode types);
    internal InheritsStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax inheritsKeyword, GreenNode types);
    internal InheritsStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_InheritsKeyword();
    internal SeparatedSyntaxList`1<TypeSyntax> get_Types();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InstanceExpressionSyntax : ExpressionSyntax {
    internal KeywordSyntax _keyword;
    internal KeywordSyntax Keyword { get; }
    internal InstanceExpressionSyntax(SyntaxKind kind, KeywordSyntax keyword);
    internal InstanceExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax keyword);
    internal InstanceExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword);
    internal InstanceExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal KeywordSyntax get_Keyword();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IntegerLiteralTokenSyntax : SyntaxToken {
    internal LiteralBase _base;
    internal TypeCharacter _typeSuffix;
    internal LiteralBase Base { get; }
    internal TypeCharacter TypeSuffix { get; }
    internal IntegerLiteralTokenSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, LiteralBase base, TypeCharacter typeSuffix);
    internal IntegerLiteralTokenSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, LiteralBase base, TypeCharacter typeSuffix);
    internal IntegerLiteralTokenSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal LiteralBase get_Base();
    internal TypeCharacter get_TypeSuffix();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.IntegerLiteralTokenSyntax`1 : IntegerLiteralTokenSyntax {
    internal T _value;
    internal T Value { get; }
    internal string ValueText { get; }
    internal object ObjectValue { get; }
    internal IntegerLiteralTokenSyntax`1(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, LiteralBase base, TypeCharacter typeSuffix, T value);
    internal IntegerLiteralTokenSyntax`1(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, LiteralBase base, TypeCharacter typeSuffix, T value);
    internal IntegerLiteralTokenSyntax`1(ObjectReader reader);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual void WriteTo(ObjectWriter writer);
    internal T get_Value();
    internal virtual string get_ValueText();
    internal virtual object get_ObjectValue();
    public virtual GreenNode WithLeadingTrivia(GreenNode trivia);
    public virtual GreenNode WithTrailingTrivia(GreenNode trivia);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterfaceBlockSyntax : TypeBlockSyntax {
    internal InterfaceStatementSyntax _interfaceStatement;
    internal EndBlockStatementSyntax _endInterfaceStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    public TypeStatementSyntax BlockStatement { get; }
    public EndBlockStatementSyntax EndBlockStatement { get; }
    internal InterfaceStatementSyntax InterfaceStatement { get; }
    internal EndBlockStatementSyntax EndInterfaceStatement { get; }
    private static InterfaceBlockSyntax();
    internal InterfaceBlockSyntax(SyntaxKind kind, InterfaceStatementSyntax interfaceStatement, GreenNode inherits, GreenNode implements, GreenNode members, EndBlockStatementSyntax endInterfaceStatement);
    internal InterfaceBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, InterfaceStatementSyntax interfaceStatement, GreenNode inherits, GreenNode implements, GreenNode members, EndBlockStatementSyntax endInterfaceStatement);
    internal InterfaceBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, InterfaceStatementSyntax interfaceStatement, GreenNode inherits, GreenNode implements, GreenNode members, EndBlockStatementSyntax endInterfaceStatement);
    internal InterfaceBlockSyntax(ObjectReader reader);
    public virtual TypeStatementSyntax get_BlockStatement();
    public virtual EndBlockStatementSyntax get_EndBlockStatement();
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal InterfaceStatementSyntax get_InterfaceStatement();
    internal EndBlockStatementSyntax get_EndInterfaceStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterfaceDeclarationBlockContext : TypeBlockContext {
    internal InterfaceDeclarationBlockContext(StatementSyntax statement, BlockContext prevContext);
    internal virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode node);
    internal virtual LinkResult TryLinkSyntax(VisualBasicSyntaxNode node, BlockContext& newContext);
    internal virtual BlockContext RecoverFromMismatchedEnd(StatementSyntax statement);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterfaceStatementSyntax : TypeStatementSyntax {
    internal KeywordSyntax _interfaceKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax InterfaceKeyword { get; }
    private static InterfaceStatementSyntax();
    internal InterfaceStatementSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax interfaceKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal InterfaceStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax interfaceKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal InterfaceStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax interfaceKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal InterfaceStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_InterfaceKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolatedStringContentSyntax : VisualBasicSyntaxNode {
    internal InterpolatedStringContentSyntax(SyntaxKind kind);
    internal InterpolatedStringContentSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal InterpolatedStringContentSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal InterpolatedStringContentSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolatedStringExpressionSyntax : ExpressionSyntax {
    internal PunctuationSyntax _dollarSignDoubleQuoteToken;
    internal GreenNode _contents;
    internal PunctuationSyntax _doubleQuoteToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax DollarSignDoubleQuoteToken { get; }
    internal SyntaxList`1<InterpolatedStringContentSyntax> Contents { get; }
    internal PunctuationSyntax DoubleQuoteToken { get; }
    private static InterpolatedStringExpressionSyntax();
    internal InterpolatedStringExpressionSyntax(SyntaxKind kind, PunctuationSyntax dollarSignDoubleQuoteToken, GreenNode contents, PunctuationSyntax doubleQuoteToken);
    internal InterpolatedStringExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax dollarSignDoubleQuoteToken, GreenNode contents, PunctuationSyntax doubleQuoteToken);
    internal InterpolatedStringExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax dollarSignDoubleQuoteToken, GreenNode contents, PunctuationSyntax doubleQuoteToken);
    internal InterpolatedStringExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_DollarSignDoubleQuoteToken();
    internal SyntaxList`1<InterpolatedStringContentSyntax> get_Contents();
    internal PunctuationSyntax get_DoubleQuoteToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolatedStringTextSyntax : InterpolatedStringContentSyntax {
    internal InterpolatedStringTextTokenSyntax _textToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal InterpolatedStringTextTokenSyntax TextToken { get; }
    private static InterpolatedStringTextSyntax();
    internal InterpolatedStringTextSyntax(SyntaxKind kind, InterpolatedStringTextTokenSyntax textToken);
    internal InterpolatedStringTextSyntax(SyntaxKind kind, ISyntaxFactoryContext context, InterpolatedStringTextTokenSyntax textToken);
    internal InterpolatedStringTextSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, InterpolatedStringTextTokenSyntax textToken);
    internal InterpolatedStringTextSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal InterpolatedStringTextTokenSyntax get_TextToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolatedStringTextTokenSyntax : SyntaxToken {
    internal string _value;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal string ValueText { get; }
    internal string Value { get; }
    private static InterpolatedStringTextTokenSyntax();
    internal InterpolatedStringTextTokenSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, string value);
    internal InterpolatedStringTextTokenSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, ISyntaxFactoryContext context, string value);
    internal InterpolatedStringTextTokenSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, string value);
    internal InterpolatedStringTextTokenSyntax(ObjectReader reader);
    internal sealed virtual string get_ValueText();
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal string get_Value();
    public virtual GreenNode WithLeadingTrivia(GreenNode trivia);
    public virtual GreenNode WithTrailingTrivia(GreenNode trivia);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolationAlignmentClauseSyntax : VisualBasicSyntaxNode {
    internal PunctuationSyntax _commaToken;
    internal ExpressionSyntax _value;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax CommaToken { get; }
    internal ExpressionSyntax Value { get; }
    private static InterpolationAlignmentClauseSyntax();
    internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, PunctuationSyntax commaToken, ExpressionSyntax value);
    internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax commaToken, ExpressionSyntax value);
    internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax commaToken, ExpressionSyntax value);
    internal InterpolationAlignmentClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_CommaToken();
    internal ExpressionSyntax get_Value();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolationFormatClauseSyntax : VisualBasicSyntaxNode {
    internal PunctuationSyntax _colonToken;
    internal InterpolatedStringTextTokenSyntax _formatStringToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax ColonToken { get; }
    internal InterpolatedStringTextTokenSyntax FormatStringToken { get; }
    private static InterpolationFormatClauseSyntax();
    internal InterpolationFormatClauseSyntax(SyntaxKind kind, PunctuationSyntax colonToken, InterpolatedStringTextTokenSyntax formatStringToken);
    internal InterpolationFormatClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax colonToken, InterpolatedStringTextTokenSyntax formatStringToken);
    internal InterpolationFormatClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax colonToken, InterpolatedStringTextTokenSyntax formatStringToken);
    internal InterpolationFormatClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_ColonToken();
    internal InterpolatedStringTextTokenSyntax get_FormatStringToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InterpolationSyntax : InterpolatedStringContentSyntax {
    internal PunctuationSyntax _openBraceToken;
    internal ExpressionSyntax _expression;
    internal InterpolationAlignmentClauseSyntax _alignmentClause;
    internal InterpolationFormatClauseSyntax _formatClause;
    internal PunctuationSyntax _closeBraceToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax OpenBraceToken { get; }
    internal ExpressionSyntax Expression { get; }
    internal InterpolationAlignmentClauseSyntax AlignmentClause { get; }
    internal InterpolationFormatClauseSyntax FormatClause { get; }
    internal PunctuationSyntax CloseBraceToken { get; }
    private static InterpolationSyntax();
    internal InterpolationSyntax(SyntaxKind kind, PunctuationSyntax openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, PunctuationSyntax closeBraceToken);
    internal InterpolationSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, PunctuationSyntax closeBraceToken);
    internal InterpolationSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, PunctuationSyntax closeBraceToken);
    internal InterpolationSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_OpenBraceToken();
    internal ExpressionSyntax get_Expression();
    internal InterpolationAlignmentClauseSyntax get_AlignmentClause();
    internal InterpolationFormatClauseSyntax get_FormatClause();
    internal PunctuationSyntax get_CloseBraceToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.InvocationExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax _expression;
    internal ArgumentListSyntax _argumentList;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ExpressionSyntax Expression { get; }
    internal ArgumentListSyntax ArgumentList { get; }
    private static InvocationExpressionSyntax();
    internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList);
    internal InvocationExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ExpressionSyntax expression, ArgumentListSyntax argumentList);
    internal InvocationExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax expression, ArgumentListSyntax argumentList);
    internal InvocationExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ExpressionSyntax get_Expression();
    internal ArgumentListSyntax get_ArgumentList();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal interface Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ISyntaxFactoryContext {
    public bool IsWithinAsyncMethodOrLambda { get; }
    public bool IsWithinIteratorContext { get; }
    public abstract virtual bool get_IsWithinAsyncMethodOrLambda();
    public abstract virtual bool get_IsWithinIteratorContext();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.JoinClauseSyntax : QueryClauseSyntax {
    internal KeywordSyntax _joinKeyword;
    internal GreenNode _joinedVariables;
    internal GreenNode _additionalJoins;
    internal KeywordSyntax _onKeyword;
    internal GreenNode _joinConditions;
    internal KeywordSyntax JoinKeyword { get; }
    internal SeparatedSyntaxList`1<CollectionRangeVariableSyntax> JoinedVariables { get; }
    internal SyntaxList`1<JoinClauseSyntax> AdditionalJoins { get; }
    internal KeywordSyntax OnKeyword { get; }
    internal SeparatedSyntaxList`1<JoinConditionSyntax> JoinConditions { get; }
    internal JoinClauseSyntax(SyntaxKind kind, KeywordSyntax joinKeyword, GreenNode joinedVariables, GreenNode additionalJoins, KeywordSyntax onKeyword, GreenNode joinConditions);
    internal JoinClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax joinKeyword, GreenNode joinedVariables, GreenNode additionalJoins, KeywordSyntax onKeyword, GreenNode joinConditions);
    internal JoinClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax joinKeyword, GreenNode joinedVariables, GreenNode additionalJoins, KeywordSyntax onKeyword, GreenNode joinConditions);
    internal JoinClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal KeywordSyntax get_JoinKeyword();
    internal SeparatedSyntaxList`1<CollectionRangeVariableSyntax> get_JoinedVariables();
    internal SyntaxList`1<JoinClauseSyntax> get_AdditionalJoins();
    internal KeywordSyntax get_OnKeyword();
    internal SeparatedSyntaxList`1<JoinConditionSyntax> get_JoinConditions();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.JoinConditionSyntax : VisualBasicSyntaxNode {
    internal ExpressionSyntax _left;
    internal KeywordSyntax _equalsKeyword;
    internal ExpressionSyntax _right;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ExpressionSyntax Left { get; }
    internal KeywordSyntax EqualsKeyword { get; }
    internal ExpressionSyntax Right { get; }
    private static JoinConditionSyntax();
    internal JoinConditionSyntax(SyntaxKind kind, ExpressionSyntax left, KeywordSyntax equalsKeyword, ExpressionSyntax right);
    internal JoinConditionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ExpressionSyntax left, KeywordSyntax equalsKeyword, ExpressionSyntax right);
    internal JoinConditionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax left, KeywordSyntax equalsKeyword, ExpressionSyntax right);
    internal JoinConditionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ExpressionSyntax get_Left();
    internal KeywordSyntax get_EqualsKeyword();
    internal ExpressionSyntax get_Right();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordEventContainerSyntax : EventContainerSyntax {
    internal KeywordSyntax _keyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax Keyword { get; }
    private static KeywordEventContainerSyntax();
    internal KeywordEventContainerSyntax(SyntaxKind kind, KeywordSyntax keyword);
    internal KeywordEventContainerSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax keyword);
    internal KeywordEventContainerSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword);
    internal KeywordEventContainerSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_Keyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.KeywordSyntax : SyntaxToken {
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal object ObjectValue { get; }
    internal bool IsKeyword { get; }
    private static KeywordSyntax();
    internal KeywordSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal KeywordSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, ISyntaxFactoryContext context);
    internal KeywordSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal KeywordSyntax(ObjectReader reader);
    internal sealed virtual object get_ObjectValue();
    internal sealed virtual bool get_IsKeyword();
    internal virtual Func`2<ObjectReader, object> GetReader();
    public virtual GreenNode WithLeadingTrivia(GreenNode trivia);
    public virtual GreenNode WithTrailingTrivia(GreenNode trivia);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelStatementSyntax : ExecutableStatementSyntax {
    internal SyntaxToken _labelToken;
    internal PunctuationSyntax _colonToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxToken LabelToken { get; }
    internal PunctuationSyntax ColonToken { get; }
    private static LabelStatementSyntax();
    internal LabelStatementSyntax(SyntaxKind kind, SyntaxToken labelToken, PunctuationSyntax colonToken);
    internal LabelStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, SyntaxToken labelToken, PunctuationSyntax colonToken);
    internal LabelStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxToken labelToken, PunctuationSyntax colonToken);
    internal LabelStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SyntaxToken get_LabelToken();
    internal PunctuationSyntax get_ColonToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LabelSyntax : ExpressionSyntax {
    internal SyntaxToken _labelToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxToken LabelToken { get; }
    private static LabelSyntax();
    internal LabelSyntax(SyntaxKind kind, SyntaxToken labelToken);
    internal LabelSyntax(SyntaxKind kind, ISyntaxFactoryContext context, SyntaxToken labelToken);
    internal LabelSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxToken labelToken);
    internal LabelSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SyntaxToken get_LabelToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaContext : MethodBlockContext {
    internal bool IsLambda { get; }
    internal bool IsSingleLine { get; }
    internal LambdaContext(StatementSyntax statement, BlockContext prevContext);
    internal virtual bool get_IsLambda();
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax endStmt);
    internal virtual BlockContext EndBlock(StatementSyntax endStmt);
    internal virtual bool get_IsSingleLine();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaExpressionSyntax : ExpressionSyntax {
    internal LambdaHeaderSyntax _subOrFunctionHeader;
    internal LambdaHeaderSyntax SubOrFunctionHeader { get; }
    internal LambdaExpressionSyntax(SyntaxKind kind, LambdaHeaderSyntax subOrFunctionHeader);
    internal LambdaExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, LambdaHeaderSyntax subOrFunctionHeader);
    internal LambdaExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, LambdaHeaderSyntax subOrFunctionHeader);
    internal LambdaExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal LambdaHeaderSyntax get_SubOrFunctionHeader();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LambdaHeaderSyntax : MethodBaseSyntax {
    internal KeywordSyntax _subOrFunctionKeyword;
    internal SimpleAsClauseSyntax _asClause;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax SubOrFunctionKeyword { get; }
    internal SimpleAsClauseSyntax AsClause { get; }
    private static LambdaHeaderSyntax();
    internal LambdaHeaderSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax subOrFunctionKeyword, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal LambdaHeaderSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax subOrFunctionKeyword, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal LambdaHeaderSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax subOrFunctionKeyword, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal LambdaHeaderSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_SubOrFunctionKeyword();
    internal SimpleAsClauseSyntax get_AsClause();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LastTokenReplacer : VisualBasicSyntaxRewriter {
    private Func`2<SyntaxToken, SyntaxToken> _newItem;
    private int _skipCnt;
    private LastTokenReplacer(Func`2<SyntaxToken, SyntaxToken> newItem);
    internal static TTree Replace(TTree root, Func`2<SyntaxToken, SyntaxToken> newItem);
    public virtual VisualBasicSyntaxNode Visit(VisualBasicSyntaxNode node);
    public virtual SyntaxToken VisitSyntaxToken(SyntaxToken token);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LetClauseSyntax : QueryClauseSyntax {
    internal KeywordSyntax _letKeyword;
    internal GreenNode _variables;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax LetKeyword { get; }
    internal SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> Variables { get; }
    private static LetClauseSyntax();
    internal LetClauseSyntax(SyntaxKind kind, KeywordSyntax letKeyword, GreenNode variables);
    internal LetClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax letKeyword, GreenNode variables);
    internal LetClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax letKeyword, GreenNode variables);
    internal LetClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_LetKeyword();
    internal SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> get_Variables();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LiteralExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken _token;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxToken Token { get; }
    private static LiteralExpressionSyntax();
    internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token);
    internal LiteralExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, SyntaxToken token);
    internal LiteralExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxToken token);
    internal LiteralExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SyntaxToken get_Token();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LocalDeclarationStatementSyntax : ExecutableStatementSyntax {
    internal GreenNode _modifiers;
    internal GreenNode _declarators;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxList`1<KeywordSyntax> Modifiers { get; }
    internal SeparatedSyntaxList`1<VariableDeclaratorSyntax> Declarators { get; }
    private static LocalDeclarationStatementSyntax();
    internal LocalDeclarationStatementSyntax(SyntaxKind kind, GreenNode modifiers, GreenNode declarators);
    internal LocalDeclarationStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode modifiers, GreenNode declarators);
    internal LocalDeclarationStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode modifiers, GreenNode declarators);
    internal LocalDeclarationStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SyntaxList`1<KeywordSyntax> get_Modifiers();
    internal SeparatedSyntaxList`1<VariableDeclaratorSyntax> get_Declarators();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.LoopStatementSyntax : StatementSyntax {
    internal KeywordSyntax _loopKeyword;
    internal WhileOrUntilClauseSyntax _whileOrUntilClause;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax LoopKeyword { get; }
    internal WhileOrUntilClauseSyntax WhileOrUntilClause { get; }
    private static LoopStatementSyntax();
    internal LoopStatementSyntax(SyntaxKind kind, KeywordSyntax loopKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal LoopStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax loopKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal LoopStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax loopKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal LoopStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_LoopKeyword();
    internal WhileOrUntilClauseSyntax get_WhileOrUntilClause();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MeExpressionSyntax : InstanceExpressionSyntax {
    internal static Func`2<ObjectReader, object> CreateInstance;
    private static MeExpressionSyntax();
    internal MeExpressionSyntax(SyntaxKind kind, KeywordSyntax keyword);
    internal MeExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax keyword);
    internal MeExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword);
    internal MeExpressionSyntax(ObjectReader reader);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MemberAccessExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax _expression;
    internal PunctuationSyntax _operatorToken;
    internal SimpleNameSyntax _name;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ExpressionSyntax Expression { get; }
    internal PunctuationSyntax OperatorToken { get; }
    internal SimpleNameSyntax Name { get; }
    private static MemberAccessExpressionSyntax();
    internal MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, PunctuationSyntax operatorToken, SimpleNameSyntax name);
    internal MemberAccessExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ExpressionSyntax expression, PunctuationSyntax operatorToken, SimpleNameSyntax name);
    internal MemberAccessExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax expression, PunctuationSyntax operatorToken, SimpleNameSyntax name);
    internal MemberAccessExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ExpressionSyntax get_Expression();
    internal PunctuationSyntax get_OperatorToken();
    internal SimpleNameSyntax get_Name();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodBaseSyntax : DeclarationStatementSyntax {
    internal GreenNode _attributeLists;
    internal GreenNode _modifiers;
    internal ParameterListSyntax _parameterList;
    internal SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    internal SyntaxList`1<KeywordSyntax> Modifiers { get; }
    internal ParameterListSyntax ParameterList { get; }
    internal MethodBaseSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, ParameterListSyntax parameterList);
    internal MethodBaseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, GreenNode modifiers, ParameterListSyntax parameterList);
    internal MethodBaseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, GreenNode modifiers, ParameterListSyntax parameterList);
    internal MethodBaseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal SyntaxList`1<KeywordSyntax> get_Modifiers();
    internal ParameterListSyntax get_ParameterList();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodBlockBaseSyntax : DeclarationStatementSyntax {
    internal GreenNode _statements;
    public MethodBaseSyntax Begin { get; }
    public EndBlockStatementSyntax End { get; }
    internal SyntaxList`1<StatementSyntax> Statements { get; }
    internal MethodBlockBaseSyntax(SyntaxKind kind, GreenNode statements);
    internal MethodBlockBaseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode statements);
    internal MethodBlockBaseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode statements);
    internal MethodBlockBaseSyntax(ObjectReader reader);
    public abstract virtual MethodBaseSyntax get_Begin();
    public abstract virtual EndBlockStatementSyntax get_End();
    internal virtual void WriteTo(ObjectWriter writer);
    internal SyntaxList`1<StatementSyntax> get_Statements();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodBlockContext : ExecutableStatementContext {
    internal MethodBlockContext(SyntaxKind contextKind, StatementSyntax statement, BlockContext prevContext);
    internal virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode node);
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax endStmt);
    internal virtual LinkResult TryLinkSyntax(VisualBasicSyntaxNode node, BlockContext& newContext);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodBlockSyntax : MethodBlockBaseSyntax {
    internal MethodStatementSyntax _subOrFunctionStatement;
    internal EndBlockStatementSyntax _endSubOrFunctionStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    public MethodBaseSyntax Begin { get; }
    public EndBlockStatementSyntax End { get; }
    internal MethodStatementSyntax SubOrFunctionStatement { get; }
    internal EndBlockStatementSyntax EndSubOrFunctionStatement { get; }
    private static MethodBlockSyntax();
    internal MethodBlockSyntax(SyntaxKind kind, MethodStatementSyntax subOrFunctionStatement, GreenNode statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    internal MethodBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, MethodStatementSyntax subOrFunctionStatement, GreenNode statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    internal MethodBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, MethodStatementSyntax subOrFunctionStatement, GreenNode statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    internal MethodBlockSyntax(ObjectReader reader);
    public virtual MethodBaseSyntax get_Begin();
    public virtual EndBlockStatementSyntax get_End();
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal MethodStatementSyntax get_SubOrFunctionStatement();
    internal EndBlockStatementSyntax get_EndSubOrFunctionStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MethodStatementSyntax : MethodBaseSyntax {
    internal KeywordSyntax _subOrFunctionKeyword;
    internal IdentifierTokenSyntax _identifier;
    internal TypeParameterListSyntax _typeParameterList;
    internal SimpleAsClauseSyntax _asClause;
    internal HandlesClauseSyntax _handlesClause;
    internal ImplementsClauseSyntax _implementsClause;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax SubOrFunctionKeyword { get; }
    internal IdentifierTokenSyntax Identifier { get; }
    internal TypeParameterListSyntax TypeParameterList { get; }
    internal SimpleAsClauseSyntax AsClause { get; }
    internal HandlesClauseSyntax HandlesClause { get; }
    internal ImplementsClauseSyntax ImplementsClause { get; }
    private static MethodStatementSyntax();
    internal MethodStatementSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, HandlesClauseSyntax handlesClause, ImplementsClauseSyntax implementsClause);
    internal MethodStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, HandlesClauseSyntax handlesClause, ImplementsClauseSyntax implementsClause);
    internal MethodStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, HandlesClauseSyntax handlesClause, ImplementsClauseSyntax implementsClause);
    internal MethodStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_SubOrFunctionKeyword();
    internal IdentifierTokenSyntax get_Identifier();
    internal TypeParameterListSyntax get_TypeParameterList();
    internal SimpleAsClauseSyntax get_AsClause();
    internal HandlesClauseSyntax get_HandlesClause();
    internal ImplementsClauseSyntax get_ImplementsClause();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MidExpressionSyntax : ExpressionSyntax {
    internal IdentifierTokenSyntax _mid;
    internal ArgumentListSyntax _argumentList;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal IdentifierTokenSyntax Mid { get; }
    internal ArgumentListSyntax ArgumentList { get; }
    private static MidExpressionSyntax();
    internal MidExpressionSyntax(SyntaxKind kind, IdentifierTokenSyntax mid, ArgumentListSyntax argumentList);
    internal MidExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, IdentifierTokenSyntax mid, ArgumentListSyntax argumentList);
    internal MidExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, IdentifierTokenSyntax mid, ArgumentListSyntax argumentList);
    internal MidExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal IdentifierTokenSyntax get_Mid();
    internal ArgumentListSyntax get_ArgumentList();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModifiedIdentifierSyntax : VisualBasicSyntaxNode {
    internal IdentifierTokenSyntax _identifier;
    internal PunctuationSyntax _nullable;
    internal ArgumentListSyntax _arrayBounds;
    internal GreenNode _arrayRankSpecifiers;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal IdentifierTokenSyntax Identifier { get; }
    internal PunctuationSyntax Nullable { get; }
    internal ArgumentListSyntax ArrayBounds { get; }
    internal SyntaxList`1<ArrayRankSpecifierSyntax> ArrayRankSpecifiers { get; }
    private static ModifiedIdentifierSyntax();
    internal ModifiedIdentifierSyntax(SyntaxKind kind, IdentifierTokenSyntax identifier, PunctuationSyntax nullable, ArgumentListSyntax arrayBounds, GreenNode arrayRankSpecifiers);
    internal ModifiedIdentifierSyntax(SyntaxKind kind, ISyntaxFactoryContext context, IdentifierTokenSyntax identifier, PunctuationSyntax nullable, ArgumentListSyntax arrayBounds, GreenNode arrayRankSpecifiers);
    internal ModifiedIdentifierSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, IdentifierTokenSyntax identifier, PunctuationSyntax nullable, ArgumentListSyntax arrayBounds, GreenNode arrayRankSpecifiers);
    internal ModifiedIdentifierSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal IdentifierTokenSyntax get_Identifier();
    internal PunctuationSyntax get_Nullable();
    internal ArgumentListSyntax get_ArrayBounds();
    internal SyntaxList`1<ArrayRankSpecifierSyntax> get_ArrayRankSpecifiers();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModuleBlockSyntax : TypeBlockSyntax {
    internal ModuleStatementSyntax _moduleStatement;
    internal EndBlockStatementSyntax _endModuleStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    public TypeStatementSyntax BlockStatement { get; }
    public EndBlockStatementSyntax EndBlockStatement { get; }
    internal ModuleStatementSyntax ModuleStatement { get; }
    internal EndBlockStatementSyntax EndModuleStatement { get; }
    private static ModuleBlockSyntax();
    internal ModuleBlockSyntax(SyntaxKind kind, ModuleStatementSyntax moduleStatement, GreenNode inherits, GreenNode implements, GreenNode members, EndBlockStatementSyntax endModuleStatement);
    internal ModuleBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ModuleStatementSyntax moduleStatement, GreenNode inherits, GreenNode implements, GreenNode members, EndBlockStatementSyntax endModuleStatement);
    internal ModuleBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ModuleStatementSyntax moduleStatement, GreenNode inherits, GreenNode implements, GreenNode members, EndBlockStatementSyntax endModuleStatement);
    internal ModuleBlockSyntax(ObjectReader reader);
    public virtual TypeStatementSyntax get_BlockStatement();
    public virtual EndBlockStatementSyntax get_EndBlockStatement();
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ModuleStatementSyntax get_ModuleStatement();
    internal EndBlockStatementSyntax get_EndModuleStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ModuleStatementSyntax : TypeStatementSyntax {
    internal KeywordSyntax _moduleKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ModuleKeyword { get; }
    private static ModuleStatementSyntax();
    internal ModuleStatementSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax moduleKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal ModuleStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax moduleKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal ModuleStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax moduleKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal ModuleStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ModuleKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MultiLineIfBlockSyntax : ExecutableStatementSyntax {
    internal IfStatementSyntax _ifStatement;
    internal GreenNode _statements;
    internal GreenNode _elseIfBlocks;
    internal ElseBlockSyntax _elseBlock;
    internal EndBlockStatementSyntax _endIfStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal IfStatementSyntax IfStatement { get; }
    internal SyntaxList`1<StatementSyntax> Statements { get; }
    internal SyntaxList`1<ElseIfBlockSyntax> ElseIfBlocks { get; }
    internal ElseBlockSyntax ElseBlock { get; }
    internal EndBlockStatementSyntax EndIfStatement { get; }
    private static MultiLineIfBlockSyntax();
    internal MultiLineIfBlockSyntax(SyntaxKind kind, IfStatementSyntax ifStatement, GreenNode statements, GreenNode elseIfBlocks, ElseBlockSyntax elseBlock, EndBlockStatementSyntax endIfStatement);
    internal MultiLineIfBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, IfStatementSyntax ifStatement, GreenNode statements, GreenNode elseIfBlocks, ElseBlockSyntax elseBlock, EndBlockStatementSyntax endIfStatement);
    internal MultiLineIfBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, IfStatementSyntax ifStatement, GreenNode statements, GreenNode elseIfBlocks, ElseBlockSyntax elseBlock, EndBlockStatementSyntax endIfStatement);
    internal MultiLineIfBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal IfStatementSyntax get_IfStatement();
    internal SyntaxList`1<StatementSyntax> get_Statements();
    internal SyntaxList`1<ElseIfBlockSyntax> get_ElseIfBlocks();
    internal ElseBlockSyntax get_ElseBlock();
    internal EndBlockStatementSyntax get_EndIfStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MultiLineLambdaExpressionSyntax : LambdaExpressionSyntax {
    internal GreenNode _statements;
    internal EndBlockStatementSyntax _endSubOrFunctionStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxList`1<StatementSyntax> Statements { get; }
    internal EndBlockStatementSyntax EndSubOrFunctionStatement { get; }
    private static MultiLineLambdaExpressionSyntax();
    internal MultiLineLambdaExpressionSyntax(SyntaxKind kind, LambdaHeaderSyntax subOrFunctionHeader, GreenNode statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    internal MultiLineLambdaExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, LambdaHeaderSyntax subOrFunctionHeader, GreenNode statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    internal MultiLineLambdaExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, LambdaHeaderSyntax subOrFunctionHeader, GreenNode statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    internal MultiLineLambdaExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SyntaxList`1<StatementSyntax> get_Statements();
    internal EndBlockStatementSyntax get_EndSubOrFunctionStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MyBaseExpressionSyntax : InstanceExpressionSyntax {
    internal static Func`2<ObjectReader, object> CreateInstance;
    private static MyBaseExpressionSyntax();
    internal MyBaseExpressionSyntax(SyntaxKind kind, KeywordSyntax keyword);
    internal MyBaseExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax keyword);
    internal MyBaseExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword);
    internal MyBaseExpressionSyntax(ObjectReader reader);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.MyClassExpressionSyntax : InstanceExpressionSyntax {
    internal static Func`2<ObjectReader, object> CreateInstance;
    private static MyClassExpressionSyntax();
    internal MyClassExpressionSyntax(SyntaxKind kind, KeywordSyntax keyword);
    internal MyClassExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax keyword);
    internal MyClassExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword);
    internal MyClassExpressionSyntax(ObjectReader reader);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameColonEqualsSyntax : VisualBasicSyntaxNode {
    internal IdentifierNameSyntax _name;
    internal PunctuationSyntax _colonEqualsToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal IdentifierNameSyntax Name { get; }
    internal PunctuationSyntax ColonEqualsToken { get; }
    private static NameColonEqualsSyntax();
    internal NameColonEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax name, PunctuationSyntax colonEqualsToken);
    internal NameColonEqualsSyntax(SyntaxKind kind, ISyntaxFactoryContext context, IdentifierNameSyntax name, PunctuationSyntax colonEqualsToken);
    internal NameColonEqualsSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, IdentifierNameSyntax name, PunctuationSyntax colonEqualsToken);
    internal NameColonEqualsSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal IdentifierNameSyntax get_Name();
    internal PunctuationSyntax get_ColonEqualsToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NamedFieldInitializerSyntax : FieldInitializerSyntax {
    internal PunctuationSyntax _dotToken;
    internal IdentifierNameSyntax _name;
    internal PunctuationSyntax _equalsToken;
    internal ExpressionSyntax _expression;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax DotToken { get; }
    internal IdentifierNameSyntax Name { get; }
    internal PunctuationSyntax EqualsToken { get; }
    internal ExpressionSyntax Expression { get; }
    private static NamedFieldInitializerSyntax();
    internal NamedFieldInitializerSyntax(SyntaxKind kind, KeywordSyntax keyKeyword, PunctuationSyntax dotToken, IdentifierNameSyntax name, PunctuationSyntax equalsToken, ExpressionSyntax expression);
    internal NamedFieldInitializerSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax keyKeyword, PunctuationSyntax dotToken, IdentifierNameSyntax name, PunctuationSyntax equalsToken, ExpressionSyntax expression);
    internal NamedFieldInitializerSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyKeyword, PunctuationSyntax dotToken, IdentifierNameSyntax name, PunctuationSyntax equalsToken, ExpressionSyntax expression);
    internal NamedFieldInitializerSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_DotToken();
    internal IdentifierNameSyntax get_Name();
    internal PunctuationSyntax get_EqualsToken();
    internal ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameOfExpressionSyntax : ExpressionSyntax {
    internal KeywordSyntax _nameOfKeyword;
    internal PunctuationSyntax _openParenToken;
    internal ExpressionSyntax _argument;
    internal PunctuationSyntax _closeParenToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax NameOfKeyword { get; }
    internal PunctuationSyntax OpenParenToken { get; }
    internal ExpressionSyntax Argument { get; }
    internal PunctuationSyntax CloseParenToken { get; }
    private static NameOfExpressionSyntax();
    internal NameOfExpressionSyntax(SyntaxKind kind, KeywordSyntax nameOfKeyword, PunctuationSyntax openParenToken, ExpressionSyntax argument, PunctuationSyntax closeParenToken);
    internal NameOfExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax nameOfKeyword, PunctuationSyntax openParenToken, ExpressionSyntax argument, PunctuationSyntax closeParenToken);
    internal NameOfExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax nameOfKeyword, PunctuationSyntax openParenToken, ExpressionSyntax argument, PunctuationSyntax closeParenToken);
    internal NameOfExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_NameOfKeyword();
    internal PunctuationSyntax get_OpenParenToken();
    internal ExpressionSyntax get_Argument();
    internal PunctuationSyntax get_CloseParenToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NamespaceBlockContext : DeclarationContext {
    internal NamespaceBlockContext(StatementSyntax statement, BlockContext prevContext);
    internal NamespaceBlockContext(SyntaxKind kind, StatementSyntax statement, BlockContext prevContext);
    internal virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode node);
    internal virtual LinkResult TryLinkSyntax(VisualBasicSyntaxNode node, BlockContext& newContext);
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax endStmt);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NamespaceBlockSyntax : DeclarationStatementSyntax {
    internal NamespaceStatementSyntax _namespaceStatement;
    internal GreenNode _members;
    internal EndBlockStatementSyntax _endNamespaceStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal NamespaceStatementSyntax NamespaceStatement { get; }
    internal SyntaxList`1<StatementSyntax> Members { get; }
    internal EndBlockStatementSyntax EndNamespaceStatement { get; }
    private static NamespaceBlockSyntax();
    internal NamespaceBlockSyntax(SyntaxKind kind, NamespaceStatementSyntax namespaceStatement, GreenNode members, EndBlockStatementSyntax endNamespaceStatement);
    internal NamespaceBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, NamespaceStatementSyntax namespaceStatement, GreenNode members, EndBlockStatementSyntax endNamespaceStatement);
    internal NamespaceBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, NamespaceStatementSyntax namespaceStatement, GreenNode members, EndBlockStatementSyntax endNamespaceStatement);
    internal NamespaceBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal NamespaceStatementSyntax get_NamespaceStatement();
    internal SyntaxList`1<StatementSyntax> get_Members();
    internal EndBlockStatementSyntax get_EndNamespaceStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NamespaceStatementSyntax : DeclarationStatementSyntax {
    internal KeywordSyntax _namespaceKeyword;
    internal NameSyntax _name;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax NamespaceKeyword { get; }
    internal NameSyntax Name { get; }
    private static NamespaceStatementSyntax();
    internal NamespaceStatementSyntax(SyntaxKind kind, KeywordSyntax namespaceKeyword, NameSyntax name);
    internal NamespaceStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax namespaceKeyword, NameSyntax name);
    internal NamespaceStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax namespaceKeyword, NameSyntax name);
    internal NamespaceStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_NamespaceKeyword();
    internal NameSyntax get_Name();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NameSyntax : TypeSyntax {
    internal NameSyntax(SyntaxKind kind);
    internal NameSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal NameSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal NameSyntax(ObjectReader reader);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NewExpressionSyntax : ExpressionSyntax {
    internal KeywordSyntax _newKeyword;
    internal GreenNode _attributeLists;
    internal KeywordSyntax NewKeyword { get; }
    internal SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    internal NewExpressionSyntax(SyntaxKind kind, KeywordSyntax newKeyword, GreenNode attributeLists);
    internal NewExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax newKeyword, GreenNode attributeLists);
    internal NewExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax newKeyword, GreenNode attributeLists);
    internal NewExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal KeywordSyntax get_NewKeyword();
    internal SyntaxList`1<AttributeListSyntax> get_AttributeLists();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NextStatementSyntax : StatementSyntax {
    internal KeywordSyntax _nextKeyword;
    internal GreenNode _controlVariables;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax NextKeyword { get; }
    internal SeparatedSyntaxList`1<ExpressionSyntax> ControlVariables { get; }
    private static NextStatementSyntax();
    internal NextStatementSyntax(SyntaxKind kind, KeywordSyntax nextKeyword, GreenNode controlVariables);
    internal NextStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax nextKeyword, GreenNode controlVariables);
    internal NextStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax nextKeyword, GreenNode controlVariables);
    internal NextStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_NextKeyword();
    internal SeparatedSyntaxList`1<ExpressionSyntax> get_ControlVariables();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.NullableTypeSyntax : TypeSyntax {
    internal TypeSyntax _elementType;
    internal PunctuationSyntax _questionMarkToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal TypeSyntax ElementType { get; }
    internal PunctuationSyntax QuestionMarkToken { get; }
    private static NullableTypeSyntax();
    internal NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, PunctuationSyntax questionMarkToken);
    internal NullableTypeSyntax(SyntaxKind kind, ISyntaxFactoryContext context, TypeSyntax elementType, PunctuationSyntax questionMarkToken);
    internal NullableTypeSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, TypeSyntax elementType, PunctuationSyntax questionMarkToken);
    internal NullableTypeSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal TypeSyntax get_ElementType();
    internal PunctuationSyntax get_QuestionMarkToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectCollectionInitializerSyntax : ObjectCreationInitializerSyntax {
    internal KeywordSyntax _fromKeyword;
    internal CollectionInitializerSyntax _initializer;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax FromKeyword { get; }
    internal CollectionInitializerSyntax Initializer { get; }
    private static ObjectCollectionInitializerSyntax();
    internal ObjectCollectionInitializerSyntax(SyntaxKind kind, KeywordSyntax fromKeyword, CollectionInitializerSyntax initializer);
    internal ObjectCollectionInitializerSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax fromKeyword, CollectionInitializerSyntax initializer);
    internal ObjectCollectionInitializerSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax fromKeyword, CollectionInitializerSyntax initializer);
    internal ObjectCollectionInitializerSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_FromKeyword();
    internal CollectionInitializerSyntax get_Initializer();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectCreationExpressionSyntax : NewExpressionSyntax {
    internal TypeSyntax _type;
    internal ArgumentListSyntax _argumentList;
    internal ObjectCreationInitializerSyntax _initializer;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal TypeSyntax Type { get; }
    internal ArgumentListSyntax ArgumentList { get; }
    internal ObjectCreationInitializerSyntax Initializer { get; }
    private static ObjectCreationExpressionSyntax();
    internal ObjectCreationExpressionSyntax(SyntaxKind kind, KeywordSyntax newKeyword, GreenNode attributeLists, TypeSyntax type, ArgumentListSyntax argumentList, ObjectCreationInitializerSyntax initializer);
    internal ObjectCreationExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax newKeyword, GreenNode attributeLists, TypeSyntax type, ArgumentListSyntax argumentList, ObjectCreationInitializerSyntax initializer);
    internal ObjectCreationExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax newKeyword, GreenNode attributeLists, TypeSyntax type, ArgumentListSyntax argumentList, ObjectCreationInitializerSyntax initializer);
    internal ObjectCreationExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal TypeSyntax get_Type();
    internal ArgumentListSyntax get_ArgumentList();
    internal ObjectCreationInitializerSyntax get_Initializer();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectCreationInitializerSyntax : VisualBasicSyntaxNode {
    internal ObjectCreationInitializerSyntax(SyntaxKind kind);
    internal ObjectCreationInitializerSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal ObjectCreationInitializerSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal ObjectCreationInitializerSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ObjectMemberInitializerSyntax : ObjectCreationInitializerSyntax {
    internal KeywordSyntax _withKeyword;
    internal PunctuationSyntax _openBraceToken;
    internal GreenNode _initializers;
    internal PunctuationSyntax _closeBraceToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax WithKeyword { get; }
    internal PunctuationSyntax OpenBraceToken { get; }
    internal SeparatedSyntaxList`1<FieldInitializerSyntax> Initializers { get; }
    internal PunctuationSyntax CloseBraceToken { get; }
    private static ObjectMemberInitializerSyntax();
    internal ObjectMemberInitializerSyntax(SyntaxKind kind, KeywordSyntax withKeyword, PunctuationSyntax openBraceToken, GreenNode initializers, PunctuationSyntax closeBraceToken);
    internal ObjectMemberInitializerSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax withKeyword, PunctuationSyntax openBraceToken, GreenNode initializers, PunctuationSyntax closeBraceToken);
    internal ObjectMemberInitializerSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax withKeyword, PunctuationSyntax openBraceToken, GreenNode initializers, PunctuationSyntax closeBraceToken);
    internal ObjectMemberInitializerSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_WithKeyword();
    internal PunctuationSyntax get_OpenBraceToken();
    internal SeparatedSyntaxList`1<FieldInitializerSyntax> get_Initializers();
    internal PunctuationSyntax get_CloseBraceToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OmittedArgumentSyntax : ArgumentSyntax {
    internal PunctuationSyntax _empty;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax Empty { get; }
    private static OmittedArgumentSyntax();
    internal OmittedArgumentSyntax(SyntaxKind kind, PunctuationSyntax empty);
    internal OmittedArgumentSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax empty);
    internal OmittedArgumentSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax empty);
    internal OmittedArgumentSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_Empty();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OnErrorGoToStatementSyntax : ExecutableStatementSyntax {
    internal KeywordSyntax _onKeyword;
    internal KeywordSyntax _errorKeyword;
    internal KeywordSyntax _goToKeyword;
    internal PunctuationSyntax _minus;
    internal LabelSyntax _label;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax OnKeyword { get; }
    internal KeywordSyntax ErrorKeyword { get; }
    internal KeywordSyntax GoToKeyword { get; }
    internal PunctuationSyntax Minus { get; }
    internal LabelSyntax Label { get; }
    private static OnErrorGoToStatementSyntax();
    internal OnErrorGoToStatementSyntax(SyntaxKind kind, KeywordSyntax onKeyword, KeywordSyntax errorKeyword, KeywordSyntax goToKeyword, PunctuationSyntax minus, LabelSyntax label);
    internal OnErrorGoToStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax onKeyword, KeywordSyntax errorKeyword, KeywordSyntax goToKeyword, PunctuationSyntax minus, LabelSyntax label);
    internal OnErrorGoToStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax onKeyword, KeywordSyntax errorKeyword, KeywordSyntax goToKeyword, PunctuationSyntax minus, LabelSyntax label);
    internal OnErrorGoToStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_OnKeyword();
    internal KeywordSyntax get_ErrorKeyword();
    internal KeywordSyntax get_GoToKeyword();
    internal PunctuationSyntax get_Minus();
    internal LabelSyntax get_Label();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OnErrorResumeNextStatementSyntax : ExecutableStatementSyntax {
    internal KeywordSyntax _onKeyword;
    internal KeywordSyntax _errorKeyword;
    internal KeywordSyntax _resumeKeyword;
    internal KeywordSyntax _nextKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax OnKeyword { get; }
    internal KeywordSyntax ErrorKeyword { get; }
    internal KeywordSyntax ResumeKeyword { get; }
    internal KeywordSyntax NextKeyword { get; }
    private static OnErrorResumeNextStatementSyntax();
    internal OnErrorResumeNextStatementSyntax(SyntaxKind kind, KeywordSyntax onKeyword, KeywordSyntax errorKeyword, KeywordSyntax resumeKeyword, KeywordSyntax nextKeyword);
    internal OnErrorResumeNextStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax onKeyword, KeywordSyntax errorKeyword, KeywordSyntax resumeKeyword, KeywordSyntax nextKeyword);
    internal OnErrorResumeNextStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax onKeyword, KeywordSyntax errorKeyword, KeywordSyntax resumeKeyword, KeywordSyntax nextKeyword);
    internal OnErrorResumeNextStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_OnKeyword();
    internal KeywordSyntax get_ErrorKeyword();
    internal KeywordSyntax get_ResumeKeyword();
    internal KeywordSyntax get_NextKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OperatorBlockSyntax : MethodBlockBaseSyntax {
    internal OperatorStatementSyntax _operatorStatement;
    internal EndBlockStatementSyntax _endOperatorStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    public MethodBaseSyntax Begin { get; }
    public EndBlockStatementSyntax End { get; }
    internal OperatorStatementSyntax OperatorStatement { get; }
    internal EndBlockStatementSyntax EndOperatorStatement { get; }
    private static OperatorBlockSyntax();
    internal OperatorBlockSyntax(SyntaxKind kind, OperatorStatementSyntax operatorStatement, GreenNode statements, EndBlockStatementSyntax endOperatorStatement);
    internal OperatorBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, OperatorStatementSyntax operatorStatement, GreenNode statements, EndBlockStatementSyntax endOperatorStatement);
    internal OperatorBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, OperatorStatementSyntax operatorStatement, GreenNode statements, EndBlockStatementSyntax endOperatorStatement);
    internal OperatorBlockSyntax(ObjectReader reader);
    public virtual MethodBaseSyntax get_Begin();
    public virtual EndBlockStatementSyntax get_End();
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal OperatorStatementSyntax get_OperatorStatement();
    internal EndBlockStatementSyntax get_EndOperatorStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OperatorResolution : object {
    private static Byte[0...,0...,0...] s_table;
    private static OperatorResolution();
    private static int TypeCodeToIndex(SpecialType specialType);
    internal static SpecialType LookupInOperatorTables(SyntaxKind opcode, SpecialType left, SpecialType right);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OperatorStatementSyntax : MethodBaseSyntax {
    internal KeywordSyntax _operatorKeyword;
    internal SyntaxToken _operatorToken;
    internal SimpleAsClauseSyntax _asClause;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax OperatorKeyword { get; }
    internal SyntaxToken OperatorToken { get; }
    internal SimpleAsClauseSyntax AsClause { get; }
    private static OperatorStatementSyntax();
    internal OperatorStatementSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal OperatorStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal OperatorStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal OperatorStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_OperatorKeyword();
    internal SyntaxToken get_OperatorToken();
    internal SimpleAsClauseSyntax get_AsClause();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OptionStatementSyntax : DeclarationStatementSyntax {
    internal KeywordSyntax _optionKeyword;
    internal KeywordSyntax _nameKeyword;
    internal KeywordSyntax _valueKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax OptionKeyword { get; }
    internal KeywordSyntax NameKeyword { get; }
    internal KeywordSyntax ValueKeyword { get; }
    private static OptionStatementSyntax();
    internal OptionStatementSyntax(SyntaxKind kind, KeywordSyntax optionKeyword, KeywordSyntax nameKeyword, KeywordSyntax valueKeyword);
    internal OptionStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax optionKeyword, KeywordSyntax nameKeyword, KeywordSyntax valueKeyword);
    internal OptionStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax optionKeyword, KeywordSyntax nameKeyword, KeywordSyntax valueKeyword);
    internal OptionStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_OptionKeyword();
    internal KeywordSyntax get_NameKeyword();
    internal KeywordSyntax get_ValueKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OrderByClauseSyntax : QueryClauseSyntax {
    internal KeywordSyntax _orderKeyword;
    internal KeywordSyntax _byKeyword;
    internal GreenNode _orderings;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax OrderKeyword { get; }
    internal KeywordSyntax ByKeyword { get; }
    internal SeparatedSyntaxList`1<OrderingSyntax> Orderings { get; }
    private static OrderByClauseSyntax();
    internal OrderByClauseSyntax(SyntaxKind kind, KeywordSyntax orderKeyword, KeywordSyntax byKeyword, GreenNode orderings);
    internal OrderByClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax orderKeyword, KeywordSyntax byKeyword, GreenNode orderings);
    internal OrderByClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax orderKeyword, KeywordSyntax byKeyword, GreenNode orderings);
    internal OrderByClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_OrderKeyword();
    internal KeywordSyntax get_ByKeyword();
    internal SeparatedSyntaxList`1<OrderingSyntax> get_Orderings();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.OrderingSyntax : VisualBasicSyntaxNode {
    internal ExpressionSyntax _expression;
    internal KeywordSyntax _ascendingOrDescendingKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ExpressionSyntax Expression { get; }
    internal KeywordSyntax AscendingOrDescendingKeyword { get; }
    private static OrderingSyntax();
    internal OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, KeywordSyntax ascendingOrDescendingKeyword);
    internal OrderingSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ExpressionSyntax expression, KeywordSyntax ascendingOrDescendingKeyword);
    internal OrderingSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax expression, KeywordSyntax ascendingOrDescendingKeyword);
    internal OrderingSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ExpressionSyntax get_Expression();
    internal KeywordSyntax get_AscendingOrDescendingKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterListSyntax : VisualBasicSyntaxNode {
    internal PunctuationSyntax _openParenToken;
    internal GreenNode _parameters;
    internal PunctuationSyntax _closeParenToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax OpenParenToken { get; }
    internal SeparatedSyntaxList`1<ParameterSyntax> Parameters { get; }
    internal PunctuationSyntax CloseParenToken { get; }
    private static ParameterListSyntax();
    internal ParameterListSyntax(SyntaxKind kind, PunctuationSyntax openParenToken, GreenNode parameters, PunctuationSyntax closeParenToken);
    internal ParameterListSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax openParenToken, GreenNode parameters, PunctuationSyntax closeParenToken);
    internal ParameterListSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax openParenToken, GreenNode parameters, PunctuationSyntax closeParenToken);
    internal ParameterListSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_OpenParenToken();
    internal SeparatedSyntaxList`1<ParameterSyntax> get_Parameters();
    internal PunctuationSyntax get_CloseParenToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterSpecifiers : Enum {
    public int value__;
    public static ParameterSpecifiers ByRef;
    public static ParameterSpecifiers ByVal;
    public static ParameterSpecifiers Optional;
    public static ParameterSpecifiers ParamArray;
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParameterSyntax : VisualBasicSyntaxNode {
    internal GreenNode _attributeLists;
    internal GreenNode _modifiers;
    internal ModifiedIdentifierSyntax _identifier;
    internal SimpleAsClauseSyntax _asClause;
    internal EqualsValueSyntax _default;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    internal SyntaxList`1<KeywordSyntax> Modifiers { get; }
    internal ModifiedIdentifierSyntax Identifier { get; }
    internal SimpleAsClauseSyntax AsClause { get; }
    internal EqualsValueSyntax Default { get; }
    private static ParameterSyntax();
    internal ParameterSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, EqualsValueSyntax default);
    internal ParameterSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, GreenNode modifiers, ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, EqualsValueSyntax default);
    internal ParameterSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, GreenNode modifiers, ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, EqualsValueSyntax default);
    internal ParameterSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal SyntaxList`1<KeywordSyntax> get_Modifiers();
    internal ModifiedIdentifierSyntax get_Identifier();
    internal SimpleAsClauseSyntax get_AsClause();
    internal EqualsValueSyntax get_Default();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParenthesizedExpressionSyntax : ExpressionSyntax {
    internal PunctuationSyntax _openParenToken;
    internal ExpressionSyntax _expression;
    internal PunctuationSyntax _closeParenToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax OpenParenToken { get; }
    internal ExpressionSyntax Expression { get; }
    internal PunctuationSyntax CloseParenToken { get; }
    private static ParenthesizedExpressionSyntax();
    internal ParenthesizedExpressionSyntax(SyntaxKind kind, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax closeParenToken);
    internal ParenthesizedExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax closeParenToken);
    internal ParenthesizedExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax closeParenToken);
    internal ParenthesizedExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_OpenParenToken();
    internal ExpressionSyntax get_Expression();
    internal PunctuationSyntax get_CloseParenToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Parser : object {
    private bool _allowLeadingMultilineTrivia;
    private bool _hadImplicitLineContinuation;
    private bool _hadLineContinuationComment;
    private PossibleFirstStatementKind _possibleFirstStatementOnLine;
    private int _recursionDepth;
    private bool _evaluatingConditionCompilationExpression;
    private Scanner _scanner;
    private CancellationToken _cancellationToken;
    internal SyntaxListPool _pool;
    private ContextAwareSyntaxFactory _syntaxFactory;
    private bool _disposeScanner;
    private BlockContext _context;
    private bool _isInMethodDeclarationHeader;
    private bool _isInAsyncMethodDeclarationHeader;
    private bool _isInIteratorMethodDeclarationHeader;
    private SyntaxToken _currentToken;
    private static Func`3<SyntaxToken, SyntaxKind[], bool> s_isTokenOrKeywordFunc;
    internal bool IsScript { get; }
    public bool IsWithinAsyncMethodOrLambda { get; }
    public bool IsWithinIteratorContext { get; }
    internal BlockContext Context { get; }
    internal ContextAwareSyntaxFactory SyntaxFactory { get; }
    private SyntaxToken PrevToken { get; }
    internal SyntaxToken CurrentToken { get; }
    private static Parser();
    internal Parser(SourceText text, VisualBasicParseOptions options, CancellationToken cancellationToken);
    internal Parser(Scanner scanner);
    internal DirectiveTriviaSyntax ParseConditionalCompilationStatement();
    internal ExpressionSyntax ParseConditionalCompilationExpression();
    private DirectiveTriviaSyntax ParseElseDirective(PunctuationSyntax hashToken);
    private DirectiveTriviaSyntax ParseElseIfDirective(PunctuationSyntax hashToken);
    private IfDirectiveTriviaSyntax ParseIfDirective(PunctuationSyntax hashToken, KeywordSyntax elseKeyword);
    private DirectiveTriviaSyntax ParseEndDirective(PunctuationSyntax hashToken);
    private DirectiveTriviaSyntax ParseAnachronisticEndIfDirective(PunctuationSyntax hashToken);
    private ConstDirectiveTriviaSyntax ParseConstDirective(PunctuationSyntax hashToken);
    private RegionDirectiveTriviaSyntax ParseRegionDirective(PunctuationSyntax hashToken);
    private ExternalSourceDirectiveTriviaSyntax ParseExternalSourceDirective(PunctuationSyntax hashToken);
    private ExternalChecksumDirectiveTriviaSyntax ParseExternalChecksumDirective(PunctuationSyntax hashToken);
    private DirectiveTriviaSyntax ParseWarningDirective(PunctuationSyntax hashToken);
    private DirectiveTriviaSyntax ParseReferenceDirective(PunctuationSyntax hashToken);
    private static BadDirectiveTriviaSyntax ParseBadDirective(PunctuationSyntax hashToken);
    internal ExpressionSyntax ParseExpression(OperatorPrecedence pendingPrecedence, bool bailIfFirstTokenRejected);
    private ExpressionSyntax ParseExpressionCore(OperatorPrecedence pendingPrecedence, bool bailIfFirstTokenRejected);
    private ExpressionSyntax ParseTerm(bool BailIfFirstTokenRejected, bool RedimOrNewParent);
    private ExpressionSyntax ParsePostFixExpression(bool RedimOrNewParent, ExpressionSyntax term);
    private bool CanStartConsequenceExpression(SyntaxKind kind, bool qualified);
    private static bool TokenContainsFullWidthChars(SyntaxToken tk);
    private static ExpressionSyntax GetArgumentAsExpression(ArgumentSyntax arg);
    private ExpressionSyntax ParseIfExpression();
    private GetTypeExpressionSyntax ParseGetType();
    private NameOfExpressionSyntax ParseNameOf();
    private ExpressionSyntax ValidateNameOfArgument(ExpressionSyntax argument, bool isTopLevel);
    private ExpressionSyntax ParseGetXmlNamespace();
    private ExpressionSyntax ParseCastExpression();
    private ExpressionSyntax ParseNewExpression();
    private TypeOfExpressionSyntax ParseTypeOf();
    private ExpressionSyntax ParseVariable();
    private ExpressionSyntax ParseQualifiedExpr(ExpressionSyntax Term);
    private void RescanTrailingColonAsToken(SyntaxToken& prevToken, SyntaxToken& currentToken);
    private T TransitionFromXmlToVB(T node);
    private T TransitionFromVBToXml(ScannerState state, T node);
    private XmlBracketedNameSyntax ParseBracketedXmlQualifiedName();
    private XmlBracketedNameSyntax ReportExpectedXmlBracketedName();
    private XmlNameSyntax ReportExpectedXmlName();
    private ParenthesizedExpressionSyntax ParseParenthesizedExpression();
    internal ArgumentListSyntax ParseParenthesizedArguments(bool RedimOrNewParent);
    private ExpressionSyntax ParseParenthesizedQualifier(ExpressionSyntax Term, bool RedimOrNewParent);
    private SeparatedSyntaxList`1<ArgumentSyntax> ParseArguments(VisualBasicSyntaxNode& unexpected, bool RedimOrNewParent);
    private void ParseNamedArguments(SeparatedSyntaxListBuilder`1<ArgumentSyntax> arguments);
    private ArgumentSyntax ParseArgument(bool RedimOrNewParent);
    private CastExpressionSyntax ParseCast();
    private LambdaHeaderSyntax ParseFunctionOrSubLambdaHeader(Boolean& isMultiLine, bool parseModifiers);
    private ExpressionSyntax ParseLambda(bool parseModifiers);
    internal static bool IsDeclarationStatement(SyntaxKind kind);
    private SeparatedSyntaxList`1<ExpressionSyntax> ParseVariableList();
    private AwaitExpressionSyntax ParseAwaitExpression(KeywordSyntax awaitKeyword);
    private ExpressionRangeVariableSyntax ParseSelectListInitializer();
    private SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> ParseSelectList();
    private AggregationSyntax ParseAggregationExpression();
    private bool CheckForEndOfExpression(T& syntax);
    private ModifiedIdentifierSyntax ParseSimpleIdentifierAsModifiedIdentifier();
    private AggregationRangeVariableSyntax ParseAggregateListInitializer(bool AllowGroupName);
    private SeparatedSyntaxList`1<AggregationRangeVariableSyntax> ParseAggregateList(bool AllowGroupName, bool IsGroupJoinProjection);
    private SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> ParseLetList();
    private SeparatedSyntaxList`1<CollectionRangeVariableSyntax> ParseFromControlVars();
    private ExpressionSyntax ParsePotentialQuery(KeywordSyntax contextualKeyword);
    private GroupByClauseSyntax ParseGroupByExpression(KeywordSyntax groupKw);
    private SeparatedSyntaxList`1<AggregationRangeVariableSyntax> MissingAggregationRangeVariables();
    private JoinClauseSyntax ParseInnerJoinOrGroupJoinExpression(KeywordSyntax groupKw, KeywordSyntax joinKw);
    private JoinClauseSyntax ParseOptionalJoinOperator();
    private CollectionRangeVariableSyntax ParseJoinControlVar();
    private SeparatedSyntaxList`1<JoinConditionSyntax> ParseJoinPredicateExpression();
    private FromClauseSyntax ParseFromOperator(KeywordSyntax FromKw);
    private LetClauseSyntax ParseLetOperator(KeywordSyntax LetKw);
    private SeparatedSyntaxList`1<OrderingSyntax> ParseOrderByList();
    private void ParseMoreQueryOperators(SyntaxListBuilder`1& operators);
    private QueryClauseSyntax ParseNextQueryOperator();
    private QueryExpressionSyntax ParseFromQueryExpression(KeywordSyntax fromKw);
    private QueryExpressionSyntax ParseAggregateQueryExpression(KeywordSyntax AggregateKw);
    private AggregateClauseSyntax ParseAggregateClause(KeywordSyntax AggregateKw);
    private bool IsContinuableQueryOperator(SyntaxToken pToken);
    internal sealed virtual override void Dispose();
    internal bool get_IsScript();
    private SimpleNameSyntax ParseSimpleName(bool allowGenericArguments, bool allowGenericsWithoutOf, bool disallowGenericArgumentsOnLastQualifiedName, bool nonArrayName, bool allowKeyword, Boolean& allowEmptyGenericArguments, Boolean& allowNonEmptyGenericArguments);
    public sealed virtual override bool get_IsWithinAsyncMethodOrLambda();
    public sealed virtual override bool get_IsWithinIteratorContext();
    internal NameSyntax ParseName(bool requireQualification, bool allowGlobalNameSpace, bool allowGenericArguments, bool allowGenericsWithoutOf, bool nonArrayName, bool disallowGenericArgumentsOnLastQualifiedName, bool allowEmptyGenericArguments, Boolean& allowedEmptyGenericArguments, bool isNameInNamespaceDeclaration);
    private static SyntaxToken GetLastNZWToken(SyntaxNode node);
    private static SyntaxToken GetLastToken(SyntaxNode node);
    private static T AdjustTriviaForMissingTokens(T node);
    private static T AdjustTriviaForMissingTokensCore(T node);
    private static string MergeTokenText(SyntaxToken firstToken, SyntaxToken secondToken);
    private static string MergeTokenText(SyntaxToken firstToken, SyntaxToken secondToken, SyntaxToken thirdToken);
    private BlockContext GetCurrentSyntaxNodeIfApplicable(VisualBasicSyntaxNode& curSyntaxNode);
    internal CompilationUnitSyntax ParseCompilationUnit();
    internal CompilationUnitSyntax ParseCompilationUnitCore();
    private TNode ParseWithStackGuard(Func`1<TNode> parseFunc, Func`1<TNode> defaultFunc);
    private TNode CreateForInsufficientStack(RestorePoint& restorePoint, TNode result);
    internal StatementSyntax ParseExecutableStatement();
    private StatementSyntax ParseExecutableStatementCore();
    private SyntaxToken ParseBinaryOperator();
    internal StatementSyntax ParseDeclarationStatement();
    internal StatementSyntax ParseDeclarationStatementInternal();
    private StatementSyntax ParsePossibleDeclarationStatement();
    internal StatementSyntax ParseStatementInMethodBody();
    internal StatementSyntax ParseStatementInMethodBodyInternal();
    private StatementSyntax ParseStatementInMethodBodyCore();
    private EmptyStatementSyntax ParseEmptyStatement();
    private StatementSyntax ParseSpecifierDeclaration();
    private StatementSyntax ParseSpecifierDeclaration(SyntaxList`1<AttributeListSyntax> attributes);
    private StatementSyntax ParseSpecifierDeclaration(SyntaxList`1<AttributeListSyntax> attributes, SyntaxList`1<KeywordSyntax> modifiers);
    private EnumStatementSyntax ParseEnumStatement(SyntaxList`1<AttributeListSyntax> attributes, SyntaxList`1<KeywordSyntax> modifiers);
    private StatementSyntax ParseEnumMemberOrLabel(SyntaxList`1<AttributeListSyntax> attributes);
    private TypeStatementSyntax ParseTypeStatement(SyntaxList`1<AttributeListSyntax> attributes, SyntaxList`1<KeywordSyntax> modifiers);
    private TypeParameterListSyntax ReportGenericParamsDisallowedError(ERRID errid);
    private TypeArgumentListSyntax ReportGenericArgumentsDisallowedError(ERRID errid);
    private bool TryRejectGenericParametersForMemberDecl(TypeParameterListSyntax& genericParams);
    private NamespaceStatementSyntax ParseNamespaceStatement(SyntaxList`1<AttributeListSyntax> Attributes, SyntaxList`1<KeywordSyntax> Specifiers);
    private StatementSyntax ParseEndStatement();
    private StatementSyntax ParseGroupEndStatement();
    private SyntaxKind PeekEndStatement(int i);
    private static SyntaxKind GetEndStatementKindFromKeyword(SyntaxKind kind);
    private bool PeekDeclarationStatement(int i);
    private SyntaxList`1<KeywordSyntax> ParseSpecifiers();
    private StatementSyntax ParseVarDeclStatement(SyntaxList`1<AttributeListSyntax> attributes, SyntaxList`1<KeywordSyntax> modifiers);
    private SeparatedSyntaxList`1<VariableDeclaratorSyntax> ParseVariableDeclaration(bool allowAsNewWith);
    private void ParseFieldOrPropertyAsClauseAndInitializer(bool isProperty, bool allowAsNewWith, AsClauseSyntax& optionalAsClause, EqualsValueSyntax& optionalInitializer);
    private CollectionInitializerSyntax ParseCollectionInitializer();
    private PunctuationSyntax GetClosingRightBrace();
    private ObjectMemberInitializerSyntax ParseObjectInitializerList(bool anonymousTypeInitializer, bool anonymousTypesAllowedHere);
    private ObjectCollectionInitializerSyntax ParseObjectCollectionInitializer(KeywordSyntax fromKeyword);
    private FieldInitializerSyntax ParseAssignmentInitializer(bool anonymousTypeInitializer);
    private ModifiedIdentifierSyntax ParseModifiedIdentifier(bool AllowExplicitArraySizes, bool checkForCustom);
    private ModifiedIdentifierSyntax ParseNullableModifiedIdentifier();
    private static bool CanTokenStartTypeName(SyntaxToken Token);
    internal TypeSyntax ParseTypeName(bool nonArrayName, bool allowEmptyGenericArguments, Boolean& allowedEmptyGenericArguments);
    private TypeSyntax ReportUnrecognizedTypeInGeneric(TypeSyntax typeName);
    private GenericNameSyntax ReportUnrecognizedTypeInGeneric(GenericNameSyntax genericName);
    internal TypeSyntax ParseGeneralType(bool allowEmptyGenericArguments);
    private TypeArgumentListSyntax ParseGenericArguments(Boolean& allowEmptyGenericArguments, Boolean& AllowNonEmptyGenericArguments);
    private SyntaxList`1<ArrayRankSpecifierSyntax> ParseArrayRankSpecifiers(ERRID errorForExplicitArraySizes);
    private ModifiedIdentifierSyntax ParseArrayModifiedIdentifier(IdentifierTokenSyntax elementType, PunctuationSyntax optionalNullable, bool allowExplicitSizes);
    private bool TryReinterpretAsArraySpecifier(ArgumentListSyntax argumentList, SyntaxList`1& arrayModifiers);
    private SyntaxList`1<PunctuationSyntax> ParseSeparators(SyntaxKind kind);
    private SeparatedSyntaxList`1<ArgumentSyntax> ParseArgumentList();
    private AccessorStatementSyntax ParsePropertyOrEventAccessor(SyntaxKind accessorKind, SyntaxList`1<AttributeListSyntax> attributes, SyntaxList`1<KeywordSyntax> modifiers);
    private ImplementsClauseSyntax ParseImplementsList();
    private HandlesClauseSyntax ParseHandlesList();
    private MethodBaseSyntax ParseSubStatement(SyntaxList`1<AttributeListSyntax> attributes, SyntaxList`1<KeywordSyntax> modifiers);
    private void ParseSubOrDelegateStatement(SyntaxKind kind, IdentifierTokenSyntax& ident, TypeParameterListSyntax& optionalGenericParams, ParameterListSyntax& optionalParameters, HandlesClauseSyntax& handlesClause, ImplementsClauseSyntax& implementsClause);
    internal ParameterListSyntax ParseParameterList();
    private MethodStatementSyntax ParseFunctionStatement(SyntaxList`1<AttributeListSyntax> attributes, SyntaxList`1<KeywordSyntax> modifiers);
    private void ParseFunctionOrDelegateStatement(SyntaxKind kind, IdentifierTokenSyntax& ident, TypeParameterListSyntax& optionalGenericParams, ParameterListSyntax& optionalParameters, SimpleAsClauseSyntax& asClause, HandlesClauseSyntax& handlesClause, ImplementsClauseSyntax& implementsClause);
    private OperatorStatementSyntax ParseOperatorStatement(SyntaxList`1<AttributeListSyntax> attributes, SyntaxList`1<KeywordSyntax> modifiers);
    private PropertyStatementSyntax ParsePropertyDefinition(SyntaxList`1<AttributeListSyntax> attributes, SyntaxList`1<KeywordSyntax> modifiers);
    private DelegateStatementSyntax ParseDelegateStatement(SyntaxList`1<AttributeListSyntax> attributes, SyntaxList`1<KeywordSyntax> modifiers);
    private TypeParameterListSyntax ParseGenericParameters();
    private ConstraintSyntax ParseConstraintSyntax();
    private SeparatedSyntaxList`1<ParameterSyntax> ParseParameters(PunctuationSyntax& openParen, PunctuationSyntax& closeParen);
    private SyntaxList`1<KeywordSyntax> ParseParameterSpecifiers(ParameterSpecifiers& specifiers);
    private ParameterSyntax ParseParameter(SyntaxList`1<AttributeListSyntax> attributes, SyntaxList`1<KeywordSyntax> modifiers);
    private ImportsStatementSyntax ParseImportsStatement(SyntaxList`1<AttributeListSyntax> Attributes, SyntaxList`1<KeywordSyntax> Specifiers);
    private ImportsClauseSyntax ParseOneImportsDirective();
    private XmlStringSyntax CreateMissingXmlString();
    private XmlAttributeSyntax CreateMissingXmlAttribute();
    private InheritsOrImplementsStatementSyntax ParseInheritsImplementsStatement(SyntaxList`1<AttributeListSyntax> Attributes, SyntaxList`1<KeywordSyntax> Specifiers);
    private StatementSyntax ParseOptionStatement(SyntaxList`1<AttributeListSyntax> Attributes, SyntaxList`1<KeywordSyntax> Specifiers);
    private DeclareStatementSyntax ParseProcDeclareStatement(SyntaxList`1<AttributeListSyntax> attributes, SyntaxList`1<KeywordSyntax> modifiers);
    private void ParseDeclareLibClause(KeywordSyntax& libKeyword, LiteralExpressionSyntax& libraryName, KeywordSyntax& optionalAliasKeyword, LiteralExpressionSyntax& optionalAliasName);
    private StatementSyntax ParseCustomEventDefinition(SyntaxList`1<AttributeListSyntax> attributes, SyntaxList`1<KeywordSyntax> modifiers);
    private EventStatementSyntax ParseEventDefinition(SyntaxList`1<AttributeListSyntax> attributes, SyntaxList`1<KeywordSyntax> modifiers);
    private SyntaxList`1<AttributeListSyntax> ParseEmptyAttributeLists();
    private SyntaxList`1<AttributeListSyntax> ParseAttributeLists(bool allowFileLevelAttributes);
    private KeywordSyntax GetTokenAsAssemblyOrModuleKeyword(SyntaxToken token);
    internal static SyntaxKind GetBinaryOperatorHelper(SyntaxToken t);
    private static bool StartsValidConditionalCompilationExpr(SyntaxToken t);
    private static bool IsValidOperatorForConditionalCompilationExpr(SyntaxToken t);
    internal BlockContext get_Context();
    internal ContextAwareSyntaxFactory get_SyntaxFactory();
    internal bool IsFirstStatementOnLine(VisualBasicSyntaxNode node);
    internal DirectiveTriviaSyntax ConsumeStatementTerminatorAfterDirective(DirectiveTriviaSyntax& stmt);
    internal void ConsumedStatementTerminator(bool allowLeadingMultilineTrivia);
    private void ConsumedStatementTerminator(bool allowLeadingMultilineTrivia, PossibleFirstStatementKind possibleFirstStatementOnLine);
    internal void ConsumeColonInSingleLineExpression();
    internal void ConsumeStatementTerminator(bool colonAsSeparator);
    internal bool IsNextStatementInsideLambda(BlockContext context, BlockContext lambdaContext, bool allowLeadingMultilineTrivia);
    private bool TryGetToken(SyntaxKind kind, T& token);
    private bool TryGetContextualKeyword(SyntaxKind kind, KeywordSyntax& keyword, bool createIfMissing);
    private bool TryGetContextualKeywordAndEatNewLine(SyntaxKind kind, KeywordSyntax& keyword, bool createIfMissing);
    private bool TryEatNewLineAndGetContextualKeyword(SyntaxKind kind, KeywordSyntax& keyword, bool createIfMissing);
    private bool TryGetTokenAndEatNewLine(SyntaxKind kind, T& token, bool createIfMissing, ScannerState state);
    private bool TryEatNewLineAndGetToken(SyntaxKind kind, T& token, bool createIfMissing, ScannerState state);
    private SyntaxToken PeekToken(int offset);
    internal SyntaxToken PeekNextToken(ScannerState state);
    private SyntaxToken get_PrevToken();
    internal SyntaxToken get_CurrentToken();
    private void ResetCurrentToken(ScannerState state);
    internal void GetNextToken(ScannerState state);
    internal void GetNextSyntaxNode();
    private bool AssertLanguageFeature(ERRID feature);
    private static bool TryIdentifierAsContextualKeyword(SyntaxToken id, SyntaxKind& kind);
    private bool TryIdentifierAsContextualKeyword(SyntaxToken id, KeywordSyntax& k);
    private bool TryTokenAsContextualKeyword(SyntaxToken t, SyntaxKind kind, KeywordSyntax& k);
    private bool TryTokenAsContextualKeyword(SyntaxToken t, KeywordSyntax& k);
    private static bool TryTokenAsKeyword(SyntaxToken t, SyntaxKind& kind);
    private static bool IsTokenOrKeyword(SyntaxToken token, SyntaxKind[] kinds);
    private static bool IsToken(SyntaxToken token, SyntaxKind[] kinds);
    internal TNode ConsumeUnexpectedTokens(TNode node);
    private TNode CheckFeatureAvailability(Feature feature, TNode node);
    internal static TNode CheckFeatureAvailability(Feature feature, TNode node, LanguageVersion languageVersion);
    private static TNode ReportFeatureUnavailable(Feature feature, TNode node, LanguageVersion languageVersion);
    internal TNode ReportFeatureUnavailable(Feature feature, TNode node);
    internal bool CheckFeatureAvailability(Feature feature);
    internal static bool CheckFeatureAvailability(LanguageVersion languageVersion, Feature feature);
    internal static void CheckFeatureAvailability(DiagnosticBag diagnostics, Location location, LanguageVersion languageVersion, Feature feature);
    internal static T ReportSyntaxError(T syntax, ERRID ErrorId);
    internal static T ReportSyntaxError(T syntax, ERRID ErrorId, Object[] args);
    private StatementSyntax ReportUnrecognizedStatementError(ERRID ErrorId);
    private StatementSyntax ReportUnrecognizedStatementError(ERRID ErrorId, SyntaxList`1<AttributeListSyntax> attributes, SyntaxList`1<KeywordSyntax> modifiers, bool createMissingIdentifier, bool forceErrorOnFirstToken);
    private KeywordSyntax ReportModifiersOnStatementError(SyntaxList`1<AttributeListSyntax> attributes, SyntaxList`1<KeywordSyntax> modifiers, KeywordSyntax keyword);
    private KeywordSyntax ReportModifiersOnStatementError(ERRID errorId, SyntaxList`1<AttributeListSyntax> attributes, SyntaxList`1<KeywordSyntax> modifiers, KeywordSyntax keyword);
    private void ReportSyntaxErrorForLanguageFeature(ERRID Errid, SyntaxToken Start, UInt32 Feature, string wszVersion);
    private bool IsContinuableEOL(int i);
    private SyntaxToken PeekPastStatementTerminator();
    internal bool IsValidStatementTerminator(SyntaxToken t);
    private bool CanFollowStatement(SyntaxToken T);
    internal bool CanFollowStatementButIsNotSelectFollowingExpression(SyntaxToken nextToken);
    private bool CanEndExecutableStatement(SyntaxToken t);
    private bool CanFollowExpression(SyntaxToken t);
    private bool BeginsGeneric(bool nonArrayName, bool allowGenericsWithoutOf);
    private bool MustEndStatement(SyntaxToken t);
    private SyntaxKind PeekAheadFor(SyntaxKind[] kinds);
    private int PeekAheadForToken(SyntaxKind[] kinds);
    private int PeekAheadFor(Func`3<SyntaxToken, TArg, bool> predicate, TArg arg, SyntaxToken& token);
    private void ResyncAt(SyntaxListBuilder`1<SyntaxToken> skippedTokens, ScannerState state, SyntaxKind[] resyncTokens);
    private SyntaxList`1<SyntaxToken> ResyncAt(ScannerState state, SyntaxKind[] resyncTokens);
    private SyntaxList`1<SyntaxToken> ResyncAndConsumeStatementTerminator();
    internal SyntaxList`1<SyntaxToken> ResyncAt();
    internal SyntaxList`1<SyntaxToken> ResyncAt(SyntaxKind[] resyncTokens);
    private T ResyncAt(T syntax, ScannerState state, SyntaxKind[] resyncTokens);
    private T ResyncAt(T syntax);
    private T ResyncAt(T syntax, SyntaxKind[] resyncTokens);
    private bool TryEatNewLine(ScannerState state);
    private bool TryEatNewLineIfFollowedBy(SyntaxKind kind);
    private bool TryEatNewLineIfNotFollowedBy(SyntaxKind kind);
    private bool NextLineStartsWith(SyntaxKind kind);
    private bool NextLineStartsWithStatementTerminator(int offset);
    private static bool CanUseInTryGetToken(SyntaxKind kind);
    private ContinueStatementSyntax ParseContinueStatement();
    private StatementSyntax ParseExitStatement();
    private CaseStatementSyntax ParseCaseStatement();
    private static SyntaxKind RelationalOperatorKindToCaseKind(SyntaxKind kind);
    private SelectStatementSyntax ParseSelectStatement();
    private IfStatementSyntax ParseIfStatement();
    private ElseStatementSyntax ParseElseStatement();
    private StatementSyntax ParseElseIfStatement();
    private StatementSyntax ParseAnachronisticStatement();
    private DoStatementSyntax ParseDoStatement();
    private LoopStatementSyntax ParseLoopStatement();
    private StatementSyntax ParseForStatement();
    private ForEachStatementSyntax ParseForEachStatement(KeywordSyntax forKeyword, KeywordSyntax eachKeyword);
    private ForStatementSyntax ParseForStatement(KeywordSyntax forKeyword);
    private NextStatementSyntax ParseNextStatement();
    private VisualBasicSyntaxNode ParseForLoopControlVariable();
    private VariableDeclaratorSyntax ParseForLoopVariableDeclaration();
    private SyntaxToken ParseLabelReference();
    private StatementSyntax ParseGotoStatement();
    private LabelSyntax GetLabelSyntaxForIdentifierOrLineNumber(SyntaxToken labelName);
    private StatementSyntax ParseOnErrorStatement();
    private OnErrorResumeNextStatementSyntax ParseOnErrorResumeNext(KeywordSyntax onKeyword, KeywordSyntax errorKeyword);
    private OnErrorGoToStatementSyntax ParseOnErrorGoto(KeywordSyntax onKeyword, KeywordSyntax errorKeyword);
    private ResumeStatementSyntax ParseResumeStatement();
    private StatementSyntax ParseAssignmentOrInvocationStatement();
    private ExpressionSyntax MakeInvocationExpression(ExpressionSyntax target);
    private AssignmentStatementSyntax MakeAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    private CallStatementSyntax ParseCallStatement();
    private ExpressionSyntax MakeCallStatementExpression(ExpressionSyntax expr);
    private RaiseEventStatementSyntax ParseRaiseEventStatement();
    private StatementSyntax ParseRedimStatement();
    private AddRemoveHandlerStatementSyntax ParseHandlerStatement();
    private StatementSyntax ParseExpressionBlockStatement();
    private StatementSyntax ParseAssignmentStatement();
    private TryStatementSyntax ParseTry();
    private CatchStatementSyntax ParseCatch();
    private FinallyStatementSyntax ParseFinally();
    private ThrowStatementSyntax ParseThrowStatement();
    private ErrorStatementSyntax ParseError();
    private EraseStatementSyntax ParseErase();
    private bool ShouldParseAsLabel();
    private LabelStatementSyntax ParseLabel();
    private AssignmentStatementSyntax ParseMid();
    private bool TryParseOptionalWhileOrUntilClause(KeywordSyntax precedingKeyword, WhileOrUntilClauseSyntax& optionalWhileOrUntilClause);
    private ReturnStatementSyntax ParseReturnStatement();
    private StopOrEndStatementSyntax ParseStopOrEndStatement();
    private UsingStatementSyntax ParseUsingStatement();
    private ExpressionStatementSyntax ParseAwaitStatement();
    private YieldStatementSyntax ParseYieldStatement();
    private PrintStatementSyntax ParsePrintStatement();
    private IdentifierTokenSyntax ParseIdentifier();
    private IdentifierTokenSyntax ParseNullableIdentifier(PunctuationSyntax& optionalNullable);
    private IdentifierTokenSyntax ParseIdentifierAllowingKeyword();
    private IdentifierNameSyntax ParseIdentifierNameAllowingKeyword();
    private SimpleNameSyntax ParseSimpleNameExpressionAllowingKeywordAndTypeArguments();
    private LiteralExpressionSyntax ParseIntLiteral();
    private LiteralExpressionSyntax ParseCharLiteral();
    private LiteralExpressionSyntax ParseDecLiteral();
    private LiteralExpressionSyntax ParseStringLiteral();
    private LiteralExpressionSyntax ParseFltLiteral();
    private LiteralExpressionSyntax ParseDateLiteral();
    private static SyntaxToken HandleUnexpectedToken(SyntaxKind kind);
    private static KeywordSyntax HandleUnexpectedKeyword(SyntaxKind kind);
    private static ERRID GetUnexpectedTokenErrorId(SyntaxKind kind);
    private bool VerifyExpectedToken(SyntaxKind kind, T& token, ScannerState state);
    private InterpolatedStringExpressionSyntax ParseInterpolatedStringExpression();
    private InterpolationSyntax ParseInterpolatedStringInterpolation();
    private static SyntaxToken RemoveTrailingColonTriviaAndConvertToColonToken(SyntaxToken token, PunctuationSyntax& colonToken, String& excessText);
    private VisualBasicSyntaxNode RemoveTrailingColonTriviaAndConvertToColonToken(VisualBasicSyntaxNode node, PunctuationSyntax& colonToken, String& excessText);
    private XmlNodeSyntax ParseXmlExpression();
    private XmlNodeSyntax ParseXmlDocument();
    private XmlDeclarationSyntax ParseXmlDeclaration();
    private XmlDeclarationOptionSyntax ParseXmlDeclarationOption();
    private SyntaxList`1<XmlNodeSyntax> ParseXmlMisc(bool IsProlog, XmlWhitespaceChecker whitespaceChecker, VisualBasicSyntaxNode& outerNode);
    private VisualBasicSyntaxNode ParseXmlDocType(ScannerState enclosingState);
    private void ParseExternalID(SyntaxListBuilder`1<VisualBasicSyntaxNode> builder);
    private void ParseInternalSubSet(SyntaxListBuilder`1<VisualBasicSyntaxNode> builder);
    private void ParseXmlMarkupDecl(SyntaxListBuilder`1<VisualBasicSyntaxNode> builder);
    private XmlNodeSyntax ParseXmlElementStartTag(ScannerState enclosingState);
    private XmlNodeSyntax ParseXmlElement(ScannerState enclosingState);
    private XmlNodeSyntax CreateXmlElement(List`1<XmlContext> contexts, XmlElementEndTagSyntax endElement);
    private XmlNodeSyntax ResyncXmlElement(ScannerState state, PunctuationSyntax lessThan, XmlNodeSyntax Name, SyntaxList`1<XmlNodeSyntax> attributes);
    private XmlNodeSyntax ResyncXmlContent();
    private XmlElementEndTagSyntax ParseXmlElementEndTag(ScannerState nextState);
    private SyntaxList`1<XmlNodeSyntax> ParseXmlAttributes(bool requireLeadingWhitespace, XmlNodeSyntax xmlElementName);
    internal XmlNodeSyntax ParseXmlAttribute(bool requireLeadingWhitespace, bool AllowNameAsExpression, XmlNodeSyntax xmlElementName);
    private bool ElementNameIsOneFromTheList(XmlNodeSyntax xmlElementName, String[] names);
    private bool TryParseXmlCrefAttributeValue(XmlNodeSyntax name, PunctuationSyntax equals, XmlNodeSyntax& crefAttribute);
    internal CrefReferenceSyntax TryParseCrefReference();
    internal CrefSignatureSyntax TryParseCrefReferenceSignature();
    internal CrefOperatorReferenceSyntax TryParseCrefOperatorName();
    internal TypeSyntax TryParseCrefOptionallyQualifiedName();
    private bool TryParseXmlNameAttributeValue(XmlNodeSyntax name, PunctuationSyntax equals, XmlNodeSyntax& nameAttribute, XmlNodeSyntax xmlElementName);
    private XmlNodeSyntax ParseXmlQualifiedName(bool requireLeadingWhitespace, bool allowExpr, ScannerState stateForName, ScannerState nextState);
    private XmlNodeSyntax ParseXmlQualifiedName(bool requireLeadingWhitespace, ScannerState stateForName, ScannerState nextState);
    private static bool IsAsciiColonTrivia(VisualBasicSyntaxNode node);
    private XmlNameSyntax ParseXmlQualifiedNameVB();
    private static bool IsValidXmlQualifiedNameToken(SyntaxToken token);
    private XmlNameTokenSyntax ToXmlNameToken(SyntaxToken token);
    private static XmlNameTokenSyntax VerifyXmlNameToken(XmlNameTokenSyntax tk);
    internal SyntaxList`1<VisualBasicSyntaxNode> ParseRestOfDocCommentContent(SyntaxList`1<VisualBasicSyntaxNode> nodesSoFar);
    internal SyntaxList`1<VisualBasicSyntaxNode> ParseXmlContent(ScannerState state);
    private XmlProcessingInstructionSyntax ParseXmlProcessingInstruction(ScannerState nextState, XmlWhitespaceChecker whitespaceChecker);
    private XmlCDataSectionSyntax ParseXmlCData(ScannerState nextState);
    private XmlNodeSyntax ParseXmlComment(ScannerState nextState);
    internal XmlStringSyntax ParseXmlString(ScannerState nextState);
    private XmlEmbeddedExpressionSyntax ParseXmlEmbedded(ScannerState enclosingState);
    [CompilerGeneratedAttribute]
private SyntaxToken _Lambda$__33-0(SyntaxToken token);
    [CompilerGeneratedAttribute]
private CompilationUnitSyntax _Lambda$__109-0();
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ParserExtensions : object {
    [ExtensionAttribute]
internal static bool Any(SyntaxList`1<T> this, SyntaxKind[] kinds);
    [ExtensionAttribute]
internal static bool AnyAndOnly(SyntaxList`1<T> this, SyntaxKind[] kinds);
    [ExtensionAttribute]
internal static bool ContainsDiagnostics(SyntaxList`1<T> this);
    [ExtensionAttribute]
internal static bool ContainsDiagnostics(SyntaxListBuilder`1<T> this);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PartitionClauseSyntax : QueryClauseSyntax {
    internal KeywordSyntax _skipOrTakeKeyword;
    internal ExpressionSyntax _count;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax SkipOrTakeKeyword { get; }
    internal ExpressionSyntax Count { get; }
    private static PartitionClauseSyntax();
    internal PartitionClauseSyntax(SyntaxKind kind, KeywordSyntax skipOrTakeKeyword, ExpressionSyntax count);
    internal PartitionClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax skipOrTakeKeyword, ExpressionSyntax count);
    internal PartitionClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax skipOrTakeKeyword, ExpressionSyntax count);
    internal PartitionClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_SkipOrTakeKeyword();
    internal ExpressionSyntax get_Count();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PartitionWhileClauseSyntax : QueryClauseSyntax {
    internal KeywordSyntax _skipOrTakeKeyword;
    internal KeywordSyntax _whileKeyword;
    internal ExpressionSyntax _condition;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax SkipOrTakeKeyword { get; }
    internal KeywordSyntax WhileKeyword { get; }
    internal ExpressionSyntax Condition { get; }
    private static PartitionWhileClauseSyntax();
    internal PartitionWhileClauseSyntax(SyntaxKind kind, KeywordSyntax skipOrTakeKeyword, KeywordSyntax whileKeyword, ExpressionSyntax condition);
    internal PartitionWhileClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax skipOrTakeKeyword, KeywordSyntax whileKeyword, ExpressionSyntax condition);
    internal PartitionWhileClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax skipOrTakeKeyword, KeywordSyntax whileKeyword, ExpressionSyntax condition);
    internal PartitionWhileClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_SkipOrTakeKeyword();
    internal KeywordSyntax get_WhileKeyword();
    internal ExpressionSyntax get_Condition();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PredefinedCastExpressionSyntax : ExpressionSyntax {
    internal KeywordSyntax _keyword;
    internal PunctuationSyntax _openParenToken;
    internal ExpressionSyntax _expression;
    internal PunctuationSyntax _closeParenToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax Keyword { get; }
    internal PunctuationSyntax OpenParenToken { get; }
    internal ExpressionSyntax Expression { get; }
    internal PunctuationSyntax CloseParenToken { get; }
    private static PredefinedCastExpressionSyntax();
    internal PredefinedCastExpressionSyntax(SyntaxKind kind, KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax closeParenToken);
    internal PredefinedCastExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax closeParenToken);
    internal PredefinedCastExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax closeParenToken);
    internal PredefinedCastExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_Keyword();
    internal PunctuationSyntax get_OpenParenToken();
    internal ExpressionSyntax get_Expression();
    internal PunctuationSyntax get_CloseParenToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PredefinedTypeSyntax : TypeSyntax {
    internal KeywordSyntax _keyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax Keyword { get; }
    private static PredefinedTypeSyntax();
    internal PredefinedTypeSyntax(SyntaxKind kind, KeywordSyntax keyword);
    internal PredefinedTypeSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax keyword);
    internal PredefinedTypeSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword);
    internal PredefinedTypeSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_Keyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PrintStatementSyntax : ExecutableStatementSyntax {
    internal PunctuationSyntax _questionToken;
    internal ExpressionSyntax _expression;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax QuestionToken { get; }
    internal ExpressionSyntax Expression { get; }
    private static PrintStatementSyntax();
    internal PrintStatementSyntax(SyntaxKind kind, PunctuationSyntax questionToken, ExpressionSyntax expression);
    internal PrintStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax questionToken, ExpressionSyntax expression);
    internal PrintStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax questionToken, ExpressionSyntax expression);
    internal PrintStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_QuestionToken();
    internal ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PropertyBlockContext : DeclarationContext {
    private bool _isPropertyBlock;
    private bool IsPropertyBlock { get; }
    internal PropertyBlockContext(StatementSyntax statement, BlockContext prevContext, bool isPropertyBlock);
    private bool get_IsPropertyBlock();
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax endStmt);
    internal virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode node);
    internal virtual LinkResult TryLinkSyntax(VisualBasicSyntaxNode node, BlockContext& newContext);
    internal virtual BlockContext EndBlock(StatementSyntax endStmt);
    internal static PropertyStatementSyntax ReportErrorIfHasInitializer(PropertyStatementSyntax propertyStatement);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PropertyBlockSyntax : DeclarationStatementSyntax {
    internal PropertyStatementSyntax _propertyStatement;
    internal GreenNode _accessors;
    internal EndBlockStatementSyntax _endPropertyStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PropertyStatementSyntax PropertyStatement { get; }
    internal SyntaxList`1<AccessorBlockSyntax> Accessors { get; }
    internal EndBlockStatementSyntax EndPropertyStatement { get; }
    private static PropertyBlockSyntax();
    internal PropertyBlockSyntax(SyntaxKind kind, PropertyStatementSyntax propertyStatement, GreenNode accessors, EndBlockStatementSyntax endPropertyStatement);
    internal PropertyBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PropertyStatementSyntax propertyStatement, GreenNode accessors, EndBlockStatementSyntax endPropertyStatement);
    internal PropertyBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PropertyStatementSyntax propertyStatement, GreenNode accessors, EndBlockStatementSyntax endPropertyStatement);
    internal PropertyBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PropertyStatementSyntax get_PropertyStatement();
    internal SyntaxList`1<AccessorBlockSyntax> get_Accessors();
    internal EndBlockStatementSyntax get_EndPropertyStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PropertyStatementSyntax : MethodBaseSyntax {
    internal KeywordSyntax _propertyKeyword;
    internal IdentifierTokenSyntax _identifier;
    internal AsClauseSyntax _asClause;
    internal EqualsValueSyntax _initializer;
    internal ImplementsClauseSyntax _implementsClause;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax PropertyKeyword { get; }
    internal IdentifierTokenSyntax Identifier { get; }
    internal AsClauseSyntax AsClause { get; }
    internal EqualsValueSyntax Initializer { get; }
    internal ImplementsClauseSyntax ImplementsClause { get; }
    private static PropertyStatementSyntax();
    internal PropertyStatementSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax propertyKeyword, IdentifierTokenSyntax identifier, ParameterListSyntax parameterList, AsClauseSyntax asClause, EqualsValueSyntax initializer, ImplementsClauseSyntax implementsClause);
    internal PropertyStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax propertyKeyword, IdentifierTokenSyntax identifier, ParameterListSyntax parameterList, AsClauseSyntax asClause, EqualsValueSyntax initializer, ImplementsClauseSyntax implementsClause);
    internal PropertyStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax propertyKeyword, IdentifierTokenSyntax identifier, ParameterListSyntax parameterList, AsClauseSyntax asClause, EqualsValueSyntax initializer, ImplementsClauseSyntax implementsClause);
    internal PropertyStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_PropertyKeyword();
    internal IdentifierTokenSyntax get_Identifier();
    internal AsClauseSyntax get_AsClause();
    internal EqualsValueSyntax get_Initializer();
    internal ImplementsClauseSyntax get_ImplementsClause();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.PunctuationSyntax : SyntaxToken {
    internal static Func`2<ObjectReader, object> CreateInstance;
    private static PunctuationSyntax();
    internal PunctuationSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal PunctuationSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, ISyntaxFactoryContext context);
    internal PunctuationSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal PunctuationSyntax(ObjectReader reader);
    internal virtual Func`2<ObjectReader, object> GetReader();
    public virtual GreenNode WithLeadingTrivia(GreenNode trivia);
    public virtual GreenNode WithTrailingTrivia(GreenNode trivia);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.QualifiedCrefOperatorReferenceSyntax : NameSyntax {
    internal NameSyntax _left;
    internal PunctuationSyntax _dotToken;
    internal CrefOperatorReferenceSyntax _right;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal NameSyntax Left { get; }
    internal PunctuationSyntax DotToken { get; }
    internal CrefOperatorReferenceSyntax Right { get; }
    private static QualifiedCrefOperatorReferenceSyntax();
    internal QualifiedCrefOperatorReferenceSyntax(SyntaxKind kind, NameSyntax left, PunctuationSyntax dotToken, CrefOperatorReferenceSyntax right);
    internal QualifiedCrefOperatorReferenceSyntax(SyntaxKind kind, ISyntaxFactoryContext context, NameSyntax left, PunctuationSyntax dotToken, CrefOperatorReferenceSyntax right);
    internal QualifiedCrefOperatorReferenceSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, NameSyntax left, PunctuationSyntax dotToken, CrefOperatorReferenceSyntax right);
    internal QualifiedCrefOperatorReferenceSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal NameSyntax get_Left();
    internal PunctuationSyntax get_DotToken();
    internal CrefOperatorReferenceSyntax get_Right();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.QualifiedNameSyntax : NameSyntax {
    internal NameSyntax _left;
    internal PunctuationSyntax _dotToken;
    internal SimpleNameSyntax _right;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal NameSyntax Left { get; }
    internal PunctuationSyntax DotToken { get; }
    internal SimpleNameSyntax Right { get; }
    private static QualifiedNameSyntax();
    internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, PunctuationSyntax dotToken, SimpleNameSyntax right);
    internal QualifiedNameSyntax(SyntaxKind kind, ISyntaxFactoryContext context, NameSyntax left, PunctuationSyntax dotToken, SimpleNameSyntax right);
    internal QualifiedNameSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, NameSyntax left, PunctuationSyntax dotToken, SimpleNameSyntax right);
    internal QualifiedNameSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal NameSyntax get_Left();
    internal PunctuationSyntax get_DotToken();
    internal SimpleNameSyntax get_Right();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.QueryClauseSyntax : VisualBasicSyntaxNode {
    internal QueryClauseSyntax(SyntaxKind kind);
    internal QueryClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal QueryClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal QueryClauseSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.QueryExpressionSyntax : ExpressionSyntax {
    internal GreenNode _clauses;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxList`1<QueryClauseSyntax> Clauses { get; }
    private static QueryExpressionSyntax();
    internal QueryExpressionSyntax(SyntaxKind kind, GreenNode clauses);
    internal QueryExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode clauses);
    internal QueryExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode clauses);
    internal QueryExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SyntaxList`1<QueryClauseSyntax> get_Clauses();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RaiseEventStatementSyntax : ExecutableStatementSyntax {
    internal KeywordSyntax _raiseEventKeyword;
    internal IdentifierNameSyntax _name;
    internal ArgumentListSyntax _argumentList;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax RaiseEventKeyword { get; }
    internal IdentifierNameSyntax Name { get; }
    internal ArgumentListSyntax ArgumentList { get; }
    private static RaiseEventStatementSyntax();
    internal RaiseEventStatementSyntax(SyntaxKind kind, KeywordSyntax raiseEventKeyword, IdentifierNameSyntax name, ArgumentListSyntax argumentList);
    internal RaiseEventStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax raiseEventKeyword, IdentifierNameSyntax name, ArgumentListSyntax argumentList);
    internal RaiseEventStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax raiseEventKeyword, IdentifierNameSyntax name, ArgumentListSyntax argumentList);
    internal RaiseEventStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_RaiseEventKeyword();
    internal IdentifierNameSyntax get_Name();
    internal ArgumentListSyntax get_ArgumentList();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RangeArgumentSyntax : ArgumentSyntax {
    internal ExpressionSyntax _lowerBound;
    internal KeywordSyntax _toKeyword;
    internal ExpressionSyntax _upperBound;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ExpressionSyntax LowerBound { get; }
    internal KeywordSyntax ToKeyword { get; }
    internal ExpressionSyntax UpperBound { get; }
    private static RangeArgumentSyntax();
    internal RangeArgumentSyntax(SyntaxKind kind, ExpressionSyntax lowerBound, KeywordSyntax toKeyword, ExpressionSyntax upperBound);
    internal RangeArgumentSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ExpressionSyntax lowerBound, KeywordSyntax toKeyword, ExpressionSyntax upperBound);
    internal RangeArgumentSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax lowerBound, KeywordSyntax toKeyword, ExpressionSyntax upperBound);
    internal RangeArgumentSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ExpressionSyntax get_LowerBound();
    internal KeywordSyntax get_ToKeyword();
    internal ExpressionSyntax get_UpperBound();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RangeCaseClauseSyntax : CaseClauseSyntax {
    internal ExpressionSyntax _lowerBound;
    internal KeywordSyntax _toKeyword;
    internal ExpressionSyntax _upperBound;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ExpressionSyntax LowerBound { get; }
    internal KeywordSyntax ToKeyword { get; }
    internal ExpressionSyntax UpperBound { get; }
    private static RangeCaseClauseSyntax();
    internal RangeCaseClauseSyntax(SyntaxKind kind, ExpressionSyntax lowerBound, KeywordSyntax toKeyword, ExpressionSyntax upperBound);
    internal RangeCaseClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ExpressionSyntax lowerBound, KeywordSyntax toKeyword, ExpressionSyntax upperBound);
    internal RangeCaseClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax lowerBound, KeywordSyntax toKeyword, ExpressionSyntax upperBound);
    internal RangeCaseClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ExpressionSyntax get_LowerBound();
    internal KeywordSyntax get_ToKeyword();
    internal ExpressionSyntax get_UpperBound();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RedimClauseSyntax : VisualBasicSyntaxNode {
    internal ExpressionSyntax _expression;
    internal ArgumentListSyntax _arrayBounds;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ExpressionSyntax Expression { get; }
    internal ArgumentListSyntax ArrayBounds { get; }
    private static RedimClauseSyntax();
    internal RedimClauseSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax arrayBounds);
    internal RedimClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ExpressionSyntax expression, ArgumentListSyntax arrayBounds);
    internal RedimClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax expression, ArgumentListSyntax arrayBounds);
    internal RedimClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ExpressionSyntax get_Expression();
    internal ArgumentListSyntax get_ArrayBounds();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ReDimStatementSyntax : ExecutableStatementSyntax {
    internal KeywordSyntax _reDimKeyword;
    internal KeywordSyntax _preserveKeyword;
    internal GreenNode _clauses;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ReDimKeyword { get; }
    internal KeywordSyntax PreserveKeyword { get; }
    internal SeparatedSyntaxList`1<RedimClauseSyntax> Clauses { get; }
    private static ReDimStatementSyntax();
    internal ReDimStatementSyntax(SyntaxKind kind, KeywordSyntax reDimKeyword, KeywordSyntax preserveKeyword, GreenNode clauses);
    internal ReDimStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax reDimKeyword, KeywordSyntax preserveKeyword, GreenNode clauses);
    internal ReDimStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax reDimKeyword, KeywordSyntax preserveKeyword, GreenNode clauses);
    internal ReDimStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ReDimKeyword();
    internal KeywordSyntax get_PreserveKeyword();
    internal SeparatedSyntaxList`1<RedimClauseSyntax> get_Clauses();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ReferenceDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal KeywordSyntax _referenceKeyword;
    internal StringLiteralTokenSyntax _file;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ReferenceKeyword { get; }
    internal StringLiteralTokenSyntax File { get; }
    private static ReferenceDirectiveTriviaSyntax();
    internal ReferenceDirectiveTriviaSyntax(SyntaxKind kind, PunctuationSyntax hashToken, KeywordSyntax referenceKeyword, StringLiteralTokenSyntax file);
    internal ReferenceDirectiveTriviaSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax hashToken, KeywordSyntax referenceKeyword, StringLiteralTokenSyntax file);
    internal ReferenceDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax referenceKeyword, StringLiteralTokenSyntax file);
    internal ReferenceDirectiveTriviaSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ReferenceKeyword();
    internal StringLiteralTokenSyntax get_File();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RegionDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    internal KeywordSyntax _regionKeyword;
    internal StringLiteralTokenSyntax _name;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax RegionKeyword { get; }
    internal StringLiteralTokenSyntax Name { get; }
    private static RegionDirectiveTriviaSyntax();
    internal RegionDirectiveTriviaSyntax(SyntaxKind kind, PunctuationSyntax hashToken, KeywordSyntax regionKeyword, StringLiteralTokenSyntax name);
    internal RegionDirectiveTriviaSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax hashToken, KeywordSyntax regionKeyword, StringLiteralTokenSyntax name);
    internal RegionDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax regionKeyword, StringLiteralTokenSyntax name);
    internal RegionDirectiveTriviaSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_RegionKeyword();
    internal StringLiteralTokenSyntax get_Name();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.RelationalCaseClauseSyntax : CaseClauseSyntax {
    internal KeywordSyntax _isKeyword;
    internal PunctuationSyntax _operatorToken;
    internal ExpressionSyntax _value;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax IsKeyword { get; }
    internal PunctuationSyntax OperatorToken { get; }
    internal ExpressionSyntax Value { get; }
    private static RelationalCaseClauseSyntax();
    internal RelationalCaseClauseSyntax(SyntaxKind kind, KeywordSyntax isKeyword, PunctuationSyntax operatorToken, ExpressionSyntax value);
    internal RelationalCaseClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax isKeyword, PunctuationSyntax operatorToken, ExpressionSyntax value);
    internal RelationalCaseClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax isKeyword, PunctuationSyntax operatorToken, ExpressionSyntax value);
    internal RelationalCaseClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_IsKeyword();
    internal PunctuationSyntax get_OperatorToken();
    internal ExpressionSyntax get_Value();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ResumeStatementSyntax : ExecutableStatementSyntax {
    internal KeywordSyntax _resumeKeyword;
    internal LabelSyntax _label;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ResumeKeyword { get; }
    internal LabelSyntax Label { get; }
    private static ResumeStatementSyntax();
    internal ResumeStatementSyntax(SyntaxKind kind, KeywordSyntax resumeKeyword, LabelSyntax label);
    internal ResumeStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax resumeKeyword, LabelSyntax label);
    internal ResumeStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax resumeKeyword, LabelSyntax label);
    internal ResumeStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ResumeKeyword();
    internal LabelSyntax get_Label();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ReturnStatementSyntax : ExecutableStatementSyntax {
    internal KeywordSyntax _returnKeyword;
    internal ExpressionSyntax _expression;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ReturnKeyword { get; }
    internal ExpressionSyntax Expression { get; }
    private static ReturnStatementSyntax();
    internal ReturnStatementSyntax(SyntaxKind kind, KeywordSyntax returnKeyword, ExpressionSyntax expression);
    internal ReturnStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax returnKeyword, ExpressionSyntax expression);
    internal ReturnStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax returnKeyword, ExpressionSyntax expression);
    internal ReturnStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ReturnKeyword();
    internal ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.Scanner : object {
    private bool _isScanningDirective;
    protected PreprocessorState _scannerPreprocessorState;
    private static UInt16[] s_charProperties;
    private static int s_CHARPROP_LENGTH;
    internal static int MAXTOKENSIZE;
    private static ScanTriviaFunc s_scanNoTriviaFunc;
    private ScanTriviaFunc _scanSingleLineTriviaFunc;
    protected int _lineBufferOffset;
    private int _endOfTerminatorTrivia;
    internal static int BadTokenCountLimit;
    private int _badTokenCount;
    private PooledStringBuilder _sbPooled;
    private StringBuilder _sb;
    private SyntaxListPool _triviaListPool;
    private VisualBasicParseOptions _options;
    private StringTable _stringTable;
    private TextKeyedCache`1<SyntaxToken> _quickTokenTable;
    public static int TABLE_LIMIT;
    private static Func`2<string, SyntaxKind> s_keywordKindFactory;
    private static ObjectPool`1<CachingIdentityFactory`2<string, SyntaxKind>> s_keywordsObjsPool;
    private CachingIdentityFactory`2<string, SyntaxKind> _KeywordsObjs;
    private static ObjectPool`1<CachingFactory`2<TokenParts, IdentifierTokenSyntax>> s_idTablePool;
    private CachingFactory`2<TokenParts, IdentifierTokenSyntax> _idTable;
    private static ObjectPool`1<CachingFactory`2<TokenParts, KeywordSyntax>> s_kwTablePool;
    private CachingFactory`2<TokenParts, KeywordSyntax> _kwTable;
    private static ObjectPool`1<CachingFactory`2<TokenParts, PunctuationSyntax>> s_punctTablePool;
    private CachingFactory`2<TokenParts, PunctuationSyntax> _punctTable;
    private static ObjectPool`1<CachingFactory`2<TokenParts, SyntaxToken>> s_literalTablePool;
    private CachingFactory`2<TokenParts, SyntaxToken> _literalTable;
    private static ObjectPool`1<CachingFactory`2<SyntaxListBuilder, SyntaxList`1<VisualBasicSyntaxNode>>> s_wslTablePool;
    private CachingFactory`2<SyntaxListBuilder, SyntaxList`1<VisualBasicSyntaxNode>> _wslTable;
    private static ObjectPool`1<CachingFactory`2<TriviaKey, SyntaxTrivia>> s_wsTablePool;
    private CachingFactory`2<TriviaKey, SyntaxTrivia> _wsTable;
    private bool _isScanningForExpressionCompiler;
    private bool _isDisposed;
    private Page _curPage;
    private Page[] _pages;
    private static int s_PAGE_NUM_SHIFT;
    private static int s_PAGE_NUM;
    private static int s_PAGE_NUM_MASK;
    private static int s_PAGE_SHIFT;
    private static int s_PAGE_SIZE;
    private static int s_PAGE_MASK;
    private static int s_NOT_PAGE_MASK;
    private SourceText _buffer;
    private int _bufferLen;
    private StringBuilder _builder;
    private static Func`2<TriviaKey, int> s_triviaKeyHasher;
    private static Func`3<TriviaKey, SyntaxTrivia, bool> s_triviaKeyEquality;
    private static SyntaxTrivia s_singleSpaceWhitespaceTrivia;
    private static SyntaxTrivia s_fourSpacesWhitespaceTrivia;
    private static SyntaxTrivia s_eightSpacesWhitespaceTrivia;
    private static SyntaxTrivia s_twelveSpacesWhitespaceTrivia;
    private static SyntaxTrivia s_sixteenSpacesWhitespaceTrivia;
    private static Func`2<SyntaxListBuilder, int> s_wsListKeyHasher;
    private static Func`3<SyntaxListBuilder, SyntaxList`1<VisualBasicSyntaxNode>, bool> s_wsListKeyEquality;
    private static Func`2<SyntaxListBuilder, SyntaxList`1<VisualBasicSyntaxNode>> s_wsListFactory;
    private static Func`2<TokenParts, int> s_tokenKeyHasher;
    private static Func`3<TokenParts, SyntaxToken, bool> s_tokenKeyEquality;
    private static SyntaxTrivia s_crLfTrivia;
    private SyntaxToken _simpleEof;
    public static int MaxTokensLookAheadBeyondEOL;
    public static int MaxCharsLookBehind;
    private ScannerToken _prevToken;
    protected ScannerToken _currentToken;
    private List`1<ScannerToken> _tokens;
    private bool _IsScanningXmlDoc;
    private bool _endOfXmlInsteadOfLastDocCommentLineBreak;
    private bool _isStartingFirstXmlDocLine;
    private bool _doNotRequireXmlDocCommentPrefix;
    private static XmlTextTokenSyntax s_xmlAmpToken;
    private static XmlTextTokenSyntax s_xmlAposToken;
    private static XmlTextTokenSyntax s_xmlGtToken;
    private static XmlTextTokenSyntax s_xmlLtToken;
    private static XmlTextTokenSyntax s_xmlQuotToken;
    private static XmlTextTokenSyntax s_docCommentCrLfToken;
    internal VisualBasicParseOptions Options { get; }
    internal SyntaxToken LastToken { get; }
    internal SyntaxToken PrevToken { get; }
    internal bool IsScanningXmlDoc { get; private set; }
    private bool ShouldReportXmlError { get; }
    private static Scanner();
    internal Scanner(SourceText textToScan, VisualBasicParseOptions options, bool isScanningForExpressionCompiler);
    private bool TryScanDirective(SyntaxListBuilder tList);
    private void ProcessDirective(DirectiveTriviaSyntax directiveTrivia, SyntaxListBuilder tList);
    protected static PreprocessorState ApplyDirectives(PreprocessorState preprocessorState, VisualBasicSyntaxNode node);
    private static PreprocessorState ApplyDirectivesRecursive(PreprocessorState preprocessorState, VisualBasicSyntaxNode node);
    internal static PreprocessorState ApplyDirective(PreprocessorState preprocessorState, DirectiveTriviaSyntax& statement);
    private SyntaxList`1<VisualBasicSyntaxNode> SkipConditionalCompilationSection();
    internal PunctuationSyntax RecoverFromMissingConditionalEnds(PunctuationSyntax eof, ArrayBuilder`1& notClosedIfDirectives, ArrayBuilder`1& notClosedRegionDirectives, Boolean& haveRegionDirectives, ExternalSourceDirectiveTriviaSyntax& notClosedExternalSourceDirective);
    public QuickScanResult QuickScanToken(bool allowLeadingMultilineTrivia);
    private StringBuilder GetScratch();
    internal sealed virtual override void Dispose();
    internal VisualBasicParseOptions get_Options();
    internal static ImmutableDictionary`2<string, CConst> GetPreprocessorConstants(VisualBasicParseOptions options);
    private SyntaxToken GetNextToken(bool allowLeadingMultilineTrivia);
    private SyntaxToken ScanNextToken(bool allowLeadingMultilineTrivia);
    private SyntaxToken ScanNextCharAsToken(SyntaxList`1<VisualBasicSyntaxNode> leadingTrivia);
    public TextSpan SkipToNextConditionalLine();
    private void EatThroughLine();
    internal SyntaxTrivia GetDisabledTextAt(TextSpan span);
    internal string GetScratchTextInterned(StringBuilder sb);
    internal static string GetScratchText(StringBuilder sb);
    private static string GetScratchText(StringBuilder sb, string text);
    internal string Intern(string s, int start, int length);
    internal string Intern(Char[] s, int start, int length);
    internal string Intern(char ch);
    internal string Intern(Char[] arr);
    private bool NextAre(string chars);
    private bool NextAre(int offset, string chars);
    private bool NextIs(int offset, char c);
    private bool CanGet();
    private bool CanGet(int num);
    private int RemainingLength();
    private string GetText(int length);
    private string GetTextNotInterned(int length);
    private void AdvanceChar(int howFar);
    private string GetNextChar();
    private void EatThroughLineBreak(char StartCharacter);
    private int SkipLineBreak(char StartCharacter, int index);
    private int LengthOfLineBreak(char StartCharacter, int here);
    private SyntaxToken ScanNewlineAsStatementTerminator(char startCharacter, SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private SyntaxToken ScanColonAsStatementTerminator(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private SyntaxTrivia ScanNewlineAsTrivia(char StartCharacter);
    private bool ScanLineContinuation(SyntaxListBuilder tList);
    internal SyntaxList`1<VisualBasicSyntaxNode> ScanMultilineTrivia();
    private bool TryScanSinglePieceOfMultilineTrivia(SyntaxListBuilder tList);
    private bool StartsXmlDoc(int Here);
    private bool StartsDirective(int Here);
    private bool IsAtNewLine();
    private bool IsAfterWhitespace();
    internal SyntaxList`1<VisualBasicSyntaxNode> ScanSingleLineTrivia();
    private void ScanSingleLineTrivia(SyntaxListBuilder tList);
    private void ScanSingleLineTriviaInXmlDoc(SyntaxListBuilder tList);
    private SyntaxList`1<VisualBasicSyntaxNode> ScanLeadingTrivia();
    private void ScanWhitespaceAndLineContinuations(SyntaxListBuilder tList);
    private SyntaxList`1<VisualBasicSyntaxNode> ScanSingleLineTrivia(bool includeFollowingBlankLines);
    private static bool IsBlankLine(SyntaxListBuilder tList);
    private void ScanTerminatorTrivia(SyntaxListBuilder tList);
    private bool ScanCommentIfAny(SyntaxListBuilder tList);
    private int GetWhitespaceLength(int len);
    private int GetXmlWhitespaceLength(int len);
    private VisualBasicSyntaxNode ScanWhitespace(int len);
    private VisualBasicSyntaxNode ScanXmlWhitespace(int len);
    private void EatWhitespace();
    private int PeekStartComment(int i);
    private SyntaxTrivia ScanComment();
    private bool IsColonAndNotColonEquals(char ch, int offset);
    private SyntaxTrivia ScanColonAsTrivia();
    private SyntaxToken ScanTokenCommon(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, char ch, bool fullWidth);
    private SyntaxToken TryScanToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private SyntaxToken ScanTokenFullWidth(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, char ch);
    private bool TrySkipFollowingEquals(Int32& Index);
    private SyntaxToken ScanRightAngleBracket(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private SyntaxToken ScanLeftAngleBracket(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth, ScanTriviaFunc scanTrailingTrivia);
    internal static bool IsIdentifier(string spelling);
    private SyntaxToken ScanIdentifierOrKeyword(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private SyntaxKind TokenOfStringCached(string spelling);
    private SyntaxToken ScanBracketedIdentifier(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private SyntaxToken ScanNumericLiteral(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private static bool GetDecimalValue(string text, Decimal& value);
    private bool ScanIntLiteral(Int32& ReturnValue, Int32& Here);
    private SyntaxToken ScanDateLiteral(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private SyntaxToken ScanStringLiteral(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    internal static bool TryIdentifierAsContextualKeyword(IdentifierTokenSyntax id, SyntaxKind& k);
    internal bool TryIdentifierAsContextualKeyword(IdentifierTokenSyntax id, KeywordSyntax& k);
    internal bool TryTokenAsContextualKeyword(SyntaxToken t, KeywordSyntax& k);
    internal static bool TryTokenAsKeyword(SyntaxToken t, SyntaxKind& kind);
    internal static bool IsContextualKeyword(SyntaxToken t, SyntaxKind[] kinds);
    private bool IsIdentifierStartCharacter(char c);
    private Page GetPage(int position);
    private char Peek(int skip);
    internal char Peek();
    internal string GetChar();
    internal string GetText(int start, int length);
    internal string GetTextNotInterned(int start, int length);
    private string GetTextSlow(int start, int length, bool suppressInterning);
    private SyntaxToken ScanInterpolatedStringPunctuation();
    private SyntaxToken ScanInterpolatedStringContent();
    private SyntaxToken ScanInterpolatedStringFormatString();
    private bool IsInterpolatedStringPunctuation(int offset);
    private SyntaxToken ScanInterpolatedStringText(bool scanTrailingWhitespaceAsTrivia);
    private SyntaxToken MakeEndOfInterpolatedStringToken();
    private SyntaxList`1<VisualBasicSyntaxNode> ScanXmlTrivia(char c);
    internal SyntaxToken ScanXmlElement(ScannerState state);
    private bool ScanXmlForPossibleStatement(ScannerState state);
    internal SyntaxToken ScanXmlContent();
    internal SyntaxToken ScanXmlComment();
    internal SyntaxToken ScanXmlCData();
    internal SyntaxToken ScanXmlPIData(ScannerState state);
    internal SyntaxToken ScanXmlMisc();
    internal SyntaxToken ScanXmlStringUnQuoted();
    internal SyntaxToken ScanXmlStringSingle();
    internal SyntaxToken ScanXmlStringDouble();
    internal SyntaxToken ScanXmlStringSmartSingle();
    internal SyntaxToken ScanXmlStringSmartDouble();
    internal SyntaxToken ScanXmlString(char terminatingChar, char altTerminatingChar, bool isSingle);
    private XmlCharResult ScanSurrogatePair(char c1, int Here);
    private XmlCharResult ScanXmlChar(int Here);
    private SyntaxToken ScanXmlNcName(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private XmlTextTokenSyntax ScanXmlReference(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private XmlCharResult ScanXmlCharRef(Int32& index);
    private static CachingFactory`2<TriviaKey, SyntaxTrivia> CreateWsTable();
    private static bool CanCache(SyntaxListBuilder trivia);
    internal SyntaxTrivia MakeWhiteSpaceTrivia(string text);
    internal SyntaxTrivia MakeEndOfLineTrivia(string text);
    internal SyntaxTrivia MakeColonTrivia(string text);
    internal SyntaxTrivia MakeEndOfLineTriviaCRLF();
    internal SyntaxTrivia MakeLineContinuationTrivia(string text);
    internal SyntaxTrivia MakeDocumentationCommentExteriorTrivia(string text);
    internal static SyntaxTrivia MakeCommentTrivia(string text);
    internal SyntaxList`1<VisualBasicSyntaxNode> MakeTriviaArray(SyntaxListBuilder builder);
    private IdentifierTokenSyntax MakeIdentifier(string spelling, SyntaxKind contextualKind, bool isBracketed, string BaseSpelling, TypeCharacter TypeCharacter, SyntaxList`1<VisualBasicSyntaxNode> leadingTrivia);
    internal IdentifierTokenSyntax MakeIdentifier(KeywordSyntax keyword);
    private IdentifierTokenSyntax MakeIdentifier(string spelling, SyntaxKind contextualKind, bool isBracketed, string BaseSpelling, TypeCharacter TypeCharacter, SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, SyntaxList`1<VisualBasicSyntaxNode> followingTrivia);
    private KeywordSyntax MakeKeyword(SyntaxKind tokenType, string spelling, SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    internal KeywordSyntax MakeKeyword(IdentifierTokenSyntax identifier);
    internal KeywordSyntax MakeKeyword(XmlNameTokenSyntax xmlName);
    private KeywordSyntax MakeKeyword(SyntaxKind tokenType, string spelling, SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, SyntaxList`1<VisualBasicSyntaxNode> followingTrivia);
    internal PunctuationSyntax MakePunctuationToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, string spelling, SyntaxKind kind);
    private PunctuationSyntax MakePunctuationToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int length, SyntaxKind kind);
    internal PunctuationSyntax MakePunctuationToken(SyntaxKind kind, string spelling, SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, SyntaxList`1<VisualBasicSyntaxNode> followingTrivia);
    private PunctuationSyntax MakeOpenParenToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeCloseParenToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeDotToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeCommaToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeEqualsToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeHashToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeAmpersandToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeOpenBraceToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeCloseBraceToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeColonToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeEmptyToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private PunctuationSyntax MakePlusToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeMinusToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeAsteriskToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeSlashToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeBackslashToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeCaretToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeExclamationToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeQuestionToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeGreaterThanToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeLessThanToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private PunctuationSyntax MakeStatementTerminatorToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int width);
    private PunctuationSyntax MakeAmpersandEqualsToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int length);
    private PunctuationSyntax MakeColonEqualsToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int length);
    private PunctuationSyntax MakePlusEqualsToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int length);
    private PunctuationSyntax MakeMinusEqualsToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int length);
    private PunctuationSyntax MakeAsteriskEqualsToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int length);
    private PunctuationSyntax MakeSlashEqualsToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int length);
    private PunctuationSyntax MakeBackSlashEqualsToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int length);
    private PunctuationSyntax MakeCaretEqualsToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int length);
    private PunctuationSyntax MakeGreaterThanEqualsToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int length);
    private PunctuationSyntax MakeLessThanEqualsToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int length);
    private PunctuationSyntax MakeLessThanGreaterThanToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int length);
    private PunctuationSyntax MakeLessThanLessThanToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int length);
    private PunctuationSyntax MakeGreaterThanGreaterThanToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int length);
    private PunctuationSyntax MakeLessThanLessThanEqualsToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int length);
    private PunctuationSyntax MakeGreaterThanGreaterThanEqualsToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int length);
    private PunctuationSyntax MakeAtToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, bool charIsFullWidth);
    private SyntaxToken MakeIntegerLiteralToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, LiteralBase base, TypeCharacter typeCharacter, ulong integralValue, int length);
    private SyntaxToken MakeCharacterLiteralToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, char value, int length);
    private SyntaxToken MakeDateLiteralToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, DateTime value, int length);
    private SyntaxToken MakeFloatingLiteralToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, TypeCharacter typeCharacter, double floatingValue, int length);
    private SyntaxToken MakeDecimalLiteralToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, TypeCharacter typeCharacter, decimal decimalValue, int length);
    private SyntaxToken MakeBadToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int length, ERRID errId);
    private static SyntaxToken MakeEofToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private SyntaxToken MakeEofToken();
    internal virtual bool TryCrumbleOnce();
    internal virtual VisualBasicSyntaxNode GetCurrentSyntaxNode();
    internal virtual void MoveToNextSyntaxNode();
    internal virtual void MoveToNextSyntaxNodeInTrivia();
    internal SyntaxToken get_LastToken();
    internal SyntaxToken get_PrevToken();
    internal SyntaxToken GetCurrentToken();
    internal void ResetCurrentToken(ScannerState state);
    internal void RescanTrailingColonAsToken(SyntaxToken& prevToken, SyntaxToken& currentToken);
    internal void TransitionFromXmlToVB(SyntaxList`1<VisualBasicSyntaxNode> toCompare, SyntaxList`1& toRemove, SyntaxList`1& toAdd);
    internal void TransitionFromVBToXml(ScannerState state, SyntaxList`1<VisualBasicSyntaxNode> toCompare, SyntaxList`1& toRemove, SyntaxList`1& toAdd);
    private static int GetFullWidth(ScannerToken token, SyntaxToken tk);
    internal void GetNextTokenInState(ScannerState state);
    internal SyntaxToken PeekNextToken(ScannerState state);
    internal SyntaxToken PeekToken(int tokenOffset, ScannerState state);
    private SyntaxToken GetTokenAndAddToQueue(ScannerState state);
    private void AbandonAllTokens();
    private void ResetTokens();
    private void AbandonPeekedTokens();
    internal RestorePoint CreateRestorePoint();
    private ScannerToken[] SaveAndClearTokens();
    private void RestoreTokens(ScannerToken[] tokens);
    private LineBufferAndEndOfTerminatorOffsets CreateOffsetRestorePoint();
    private void ResetLineBufferOffset();
    private void RevertState(ScannerToken revertTo);
    private SyntaxToken GetScannerToken(ScannerState state);
    internal bool get_IsScanningXmlDoc();
    private void set_IsScanningXmlDoc(bool value);
    private bool get_ShouldReportXmlError();
    internal void ForceScanningXmlDocMode();
    private bool TryScanXmlDocComment(SyntaxListBuilder tList);
    private bool TrySkipXmlDocMarker(Int32& len);
    private VisualBasicSyntaxNode ScanXmlDocTrivia();
    private bool ScanXmlTriviaInXmlDoc(char c, SyntaxListBuilder`1<VisualBasicSyntaxNode> triviaList);
    private SyntaxToken ScanXmlContentInXmlDoc();
    internal SyntaxToken ScanXmlPIDataInXmlDoc(ScannerState state);
    private SyntaxToken ScanXmlElementInXmlDoc(ScannerState state);
    private static SyntaxToken MakeMissingToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, SyntaxKind kind);
    private PunctuationSyntax XmlMakeLeftParenToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private PunctuationSyntax XmlMakeRightParenToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private PunctuationSyntax XmlMakeEqualsToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private PunctuationSyntax XmlMakeDivToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private PunctuationSyntax XmlMakeColonToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private PunctuationSyntax XmlMakeGreaterToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private PunctuationSyntax XmlMakeLessToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private BadTokenSyntax XmlMakeBadToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int length, ERRID id);
    private BadTokenSyntax XmlMakeBadToken(SyntaxSubKind subkind, SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int length, ERRID id);
    private PunctuationSyntax XmlMakeSingleQuoteToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, char spelling, bool isOpening);
    private PunctuationSyntax XmlMakeDoubleQuoteToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, char spelling, bool isOpening);
    private XmlNameTokenSyntax XmlMakeXmlNCNameToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int TokenWidth);
    private XmlTextTokenSyntax XmlMakeAttributeDataToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int TokenWidth, string Value);
    private XmlTextTokenSyntax XmlMakeAttributeDataToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int TokenWidth, StringBuilder Scratch);
    private XmlTextTokenSyntax XmlMakeEntityLiteralToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int TokenWidth, string Value);
    private XmlTextTokenSyntax XmlMakeAmpLiteralToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private XmlTextTokenSyntax XmlMakeAposLiteralToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private XmlTextTokenSyntax XmlMakeGtLiteralToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private XmlTextTokenSyntax XmlMakeLtLiteralToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private XmlTextTokenSyntax XmlMakeQuotLiteralToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private XmlTextTokenSyntax XmlMakeTextLiteralToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int TokenWidth, StringBuilder Scratch);
    private XmlTextTokenSyntax MakeDocCommentLineBreakToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int TokenWidth);
    private XmlTextTokenSyntax XmlMakeTextLiteralToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int TokenWidth, ERRID err);
    private PunctuationSyntax XmlMakeBeginEndElementToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, ScanTriviaFunc scanTrailingTrivia);
    private PunctuationSyntax XmlMakeEndEmptyElementToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private PunctuationSyntax XmlMakeBeginEmbeddedToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private PunctuationSyntax XmlMakeEndEmbeddedToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, ScanTriviaFunc scanTrailingTrivia);
    private BadTokenSyntax XmlMakeBeginDTDToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private BadTokenSyntax XmlLessThanExclamationToken(ScannerState state, SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private BadTokenSyntax XmlMakeOpenBracketToken(ScannerState state, SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private BadTokenSyntax XmlMakeCloseBracketToken(ScannerState state, SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private PunctuationSyntax XmlMakeBeginProcessingInstructionToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, ScanTriviaFunc scanTrailingTrivia);
    private XmlTextTokenSyntax XmlMakeProcessingInstructionToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int TokenWidth);
    private PunctuationSyntax XmlMakeEndProcessingInstructionToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private PunctuationSyntax XmlMakeBeginCommentToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, ScanTriviaFunc scanTrailingTrivia);
    private XmlTextTokenSyntax XmlMakeCommentToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int TokenWidth);
    private PunctuationSyntax XmlMakeEndCommentToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
    private PunctuationSyntax XmlMakeBeginCDataToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, ScanTriviaFunc scanTrailingTrivia);
    private XmlTextTokenSyntax XmlMakeCDataToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia, int TokenWidth, StringBuilder scratch);
    private PunctuationSyntax XmlMakeEndCDataToken(SyntaxList`1<VisualBasicSyntaxNode> precedingTrivia);
}
internal enum Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerState : Enum {
    public int value__;
    public static ScannerState VB;
    public static ScannerState VBAllowLeadingMultilineTrivia;
    public static ScannerState Misc;
    public static ScannerState DocType;
    public static ScannerState Element;
    public static ScannerState EndElement;
    public static ScannerState SingleQuotedString;
    public static ScannerState SmartSingleQuotedString;
    public static ScannerState QuotedString;
    public static ScannerState SmartQuotedString;
    public static ScannerState UnQuotedString;
    public static ScannerState Content;
    public static ScannerState CData;
    public static ScannerState StartProcessingInstruction;
    public static ScannerState ProcessingInstruction;
    public static ScannerState Comment;
    public static ScannerState InterpolatedStringPunctuation;
    public static ScannerState InterpolatedStringContent;
    public static ScannerState InterpolatedStringFormatString;
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ScannerStateExtensions : object {
    [ExtensionAttribute]
internal static bool IsVBState(ScannerState state);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SelectBlockContext : ExecutableStatementContext {
    private SyntaxListBuilder`1<CaseBlockSyntax> _caseBlocks;
    internal SelectBlockContext(StatementSyntax statement, BlockContext prevContext);
    internal virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode node);
    internal virtual LinkResult TryLinkSyntax(VisualBasicSyntaxNode node, BlockContext& newContext);
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax endStmt);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SelectBlockSyntax : ExecutableStatementSyntax {
    internal SelectStatementSyntax _selectStatement;
    internal GreenNode _caseBlocks;
    internal EndBlockStatementSyntax _endSelectStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SelectStatementSyntax SelectStatement { get; }
    internal SyntaxList`1<CaseBlockSyntax> CaseBlocks { get; }
    internal EndBlockStatementSyntax EndSelectStatement { get; }
    private static SelectBlockSyntax();
    internal SelectBlockSyntax(SyntaxKind kind, SelectStatementSyntax selectStatement, GreenNode caseBlocks, EndBlockStatementSyntax endSelectStatement);
    internal SelectBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, SelectStatementSyntax selectStatement, GreenNode caseBlocks, EndBlockStatementSyntax endSelectStatement);
    internal SelectBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SelectStatementSyntax selectStatement, GreenNode caseBlocks, EndBlockStatementSyntax endSelectStatement);
    internal SelectBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SelectStatementSyntax get_SelectStatement();
    internal SyntaxList`1<CaseBlockSyntax> get_CaseBlocks();
    internal EndBlockStatementSyntax get_EndSelectStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SelectClauseSyntax : QueryClauseSyntax {
    internal KeywordSyntax _selectKeyword;
    internal GreenNode _variables;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax SelectKeyword { get; }
    internal SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> Variables { get; }
    private static SelectClauseSyntax();
    internal SelectClauseSyntax(SyntaxKind kind, KeywordSyntax selectKeyword, GreenNode variables);
    internal SelectClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax selectKeyword, GreenNode variables);
    internal SelectClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax selectKeyword, GreenNode variables);
    internal SelectClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_SelectKeyword();
    internal SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> get_Variables();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SelectStatementSyntax : StatementSyntax {
    internal KeywordSyntax _selectKeyword;
    internal KeywordSyntax _caseKeyword;
    internal ExpressionSyntax _expression;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax SelectKeyword { get; }
    internal KeywordSyntax CaseKeyword { get; }
    internal ExpressionSyntax Expression { get; }
    private static SelectStatementSyntax();
    internal SelectStatementSyntax(SyntaxKind kind, KeywordSyntax selectKeyword, KeywordSyntax caseKeyword, ExpressionSyntax expression);
    internal SelectStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax selectKeyword, KeywordSyntax caseKeyword, ExpressionSyntax expression);
    internal SelectStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax selectKeyword, KeywordSyntax caseKeyword, ExpressionSyntax expression);
    internal SelectStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_SelectKeyword();
    internal KeywordSyntax get_CaseKeyword();
    internal ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxList`1 : ValueType {
    private SyntaxList`1<VisualBasicSyntaxNode> _list;
    internal VisualBasicSyntaxNode Node { get; }
    public int Count { get; }
    public int SeparatorCount { get; }
    public TNode Item { get; }
    private TNode[] Nodes { get; }
    internal SeparatedSyntaxList`1(SyntaxList`1<VisualBasicSyntaxNode> list);
    internal VisualBasicSyntaxNode get_Node();
    public int get_Count();
    public int get_SeparatorCount();
    public TNode get_Item(int index);
    public SyntaxToken GetSeparator(int index);
    public bool Any();
    public bool Any(SyntaxKind kind);
    internal SyntaxList`1<VisualBasicSyntaxNode> GetWithSeparators();
    private TNode[] get_Nodes();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SeparatedSyntaxListBuilder`1 : ValueType {
    private SyntaxListBuilder _builder;
    public bool IsNull { get; }
    public int Count { get; }
    public VisualBasicSyntaxNode Item { get; public set; }
    public SeparatedSyntaxListBuilder`1(int size);
    internal SeparatedSyntaxListBuilder`1(SyntaxListBuilder builder);
    public bool get_IsNull();
    public int get_Count();
    public VisualBasicSyntaxNode get_Item(int index);
    public void set_Item(int index, VisualBasicSyntaxNode value);
    public void Clear();
    public void Add(TNode node);
    internal void AddSeparator(SyntaxToken separatorToken);
    internal void AddRange(SeparatedSyntaxList`1<TNode> nodes, int count);
    internal void RemoveLast();
    public bool Any(SyntaxKind kind);
    public SeparatedSyntaxList`1<TNode> ToList();
    public SeparatedSyntaxList`1<TDerivedNode> ToList();
    public static SyntaxListBuilder op_Implicit(SeparatedSyntaxListBuilder`1<TNode> builder);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleArgumentSyntax : ArgumentSyntax {
    internal NameColonEqualsSyntax _nameColonEquals;
    internal ExpressionSyntax _expression;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal NameColonEqualsSyntax NameColonEquals { get; }
    internal ExpressionSyntax Expression { get; }
    private static SimpleArgumentSyntax();
    internal SimpleArgumentSyntax(SyntaxKind kind, NameColonEqualsSyntax nameColonEquals, ExpressionSyntax expression);
    internal SimpleArgumentSyntax(SyntaxKind kind, ISyntaxFactoryContext context, NameColonEqualsSyntax nameColonEquals, ExpressionSyntax expression);
    internal SimpleArgumentSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, NameColonEqualsSyntax nameColonEquals, ExpressionSyntax expression);
    internal SimpleArgumentSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal NameColonEqualsSyntax get_NameColonEquals();
    internal ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleAsClauseSyntax : AsClauseSyntax {
    internal GreenNode _attributeLists;
    internal TypeSyntax _type;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    internal TypeSyntax Type { get; }
    private static SimpleAsClauseSyntax();
    internal SimpleAsClauseSyntax(SyntaxKind kind, KeywordSyntax asKeyword, GreenNode attributeLists, TypeSyntax type);
    internal SimpleAsClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax asKeyword, GreenNode attributeLists, TypeSyntax type);
    internal SimpleAsClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax asKeyword, GreenNode attributeLists, TypeSyntax type);
    internal SimpleAsClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal TypeSyntax get_Type();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleCaseClauseSyntax : CaseClauseSyntax {
    internal ExpressionSyntax _value;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ExpressionSyntax Value { get; }
    private static SimpleCaseClauseSyntax();
    internal SimpleCaseClauseSyntax(SyntaxKind kind, ExpressionSyntax value);
    internal SimpleCaseClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ExpressionSyntax value);
    internal SimpleCaseClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax value);
    internal SimpleCaseClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ExpressionSyntax get_Value();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleIdentifierSyntax : IdentifierTokenSyntax {
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxKind PossibleKeywordKind { get; }
    internal bool IsBracketed { get; }
    internal string IdentifierText { get; }
    internal TypeCharacter TypeCharacter { get; }
    private static SimpleIdentifierSyntax();
    internal SimpleIdentifierSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, string text, VisualBasicSyntaxNode precedingTrivia, VisualBasicSyntaxNode followingTrivia);
    internal SimpleIdentifierSyntax(ObjectReader reader);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxKind get_PossibleKeywordKind();
    internal virtual bool get_IsBracketed();
    internal virtual string get_IdentifierText();
    internal virtual TypeCharacter get_TypeCharacter();
    public virtual GreenNode WithLeadingTrivia(GreenNode trivia);
    public virtual GreenNode WithTrailingTrivia(GreenNode trivia);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleImportsClauseSyntax : ImportsClauseSyntax {
    internal ImportAliasClauseSyntax _alias;
    internal NameSyntax _name;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ImportAliasClauseSyntax Alias { get; }
    internal NameSyntax Name { get; }
    private static SimpleImportsClauseSyntax();
    internal SimpleImportsClauseSyntax(SyntaxKind kind, ImportAliasClauseSyntax alias, NameSyntax name);
    internal SimpleImportsClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ImportAliasClauseSyntax alias, NameSyntax name);
    internal SimpleImportsClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ImportAliasClauseSyntax alias, NameSyntax name);
    internal SimpleImportsClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ImportAliasClauseSyntax get_Alias();
    internal NameSyntax get_Name();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleJoinClauseSyntax : JoinClauseSyntax {
    internal static Func`2<ObjectReader, object> CreateInstance;
    private static SimpleJoinClauseSyntax();
    internal SimpleJoinClauseSyntax(SyntaxKind kind, KeywordSyntax joinKeyword, GreenNode joinedVariables, GreenNode additionalJoins, KeywordSyntax onKeyword, GreenNode joinConditions);
    internal SimpleJoinClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax joinKeyword, GreenNode joinedVariables, GreenNode additionalJoins, KeywordSyntax onKeyword, GreenNode joinConditions);
    internal SimpleJoinClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax joinKeyword, GreenNode joinedVariables, GreenNode additionalJoins, KeywordSyntax onKeyword, GreenNode joinConditions);
    internal SimpleJoinClauseSyntax(ObjectReader reader);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SimpleNameSyntax : NameSyntax {
    internal IdentifierTokenSyntax _identifier;
    internal IdentifierTokenSyntax Identifier { get; }
    internal SimpleNameSyntax(SyntaxKind kind, IdentifierTokenSyntax identifier);
    internal SimpleNameSyntax(SyntaxKind kind, ISyntaxFactoryContext context, IdentifierTokenSyntax identifier);
    internal SimpleNameSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, IdentifierTokenSyntax identifier);
    internal SimpleNameSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal IdentifierTokenSyntax get_Identifier();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineElseClauseSyntax : VisualBasicSyntaxNode {
    internal KeywordSyntax _elseKeyword;
    internal GreenNode _statements;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ElseKeyword { get; }
    internal SyntaxList`1<StatementSyntax> Statements { get; }
    private static SingleLineElseClauseSyntax();
    internal SingleLineElseClauseSyntax(SyntaxKind kind, KeywordSyntax elseKeyword, GreenNode statements);
    internal SingleLineElseClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax elseKeyword, GreenNode statements);
    internal SingleLineElseClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax elseKeyword, GreenNode statements);
    internal SingleLineElseClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ElseKeyword();
    internal SyntaxList`1<StatementSyntax> get_Statements();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineElseContext : SingleLineIfOrElseBlockContext {
    internal SingleLineElseContext(SyntaxKind kind, StatementSyntax statement, BlockContext prevContext);
    internal virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode node);
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax endStmt);
    private SingleLineElseClauseSyntax CreateElseBlockSyntax();
    internal virtual BlockContext EndBlock(StatementSyntax statement);
    internal virtual BlockContext ProcessStatementTerminator(BlockContext lambdaContext);
    internal virtual BlockContext ProcessElseAsStatementTerminator();
    internal virtual BlockContext ProcessOtherAsStatementTerminator();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineIfBlockContext : SingleLineIfOrElseBlockContext {
    private SingleLineElseClauseSyntax _optionalElseClause;
    internal SingleLineIfBlockContext(StatementSyntax statement, BlockContext prevContext);
    internal virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode node);
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax endStmt);
    private SingleLineIfStatementSyntax CreateIfBlockSyntax();
    internal virtual BlockContext EndBlock(StatementSyntax statement);
    internal virtual BlockContext ProcessStatementTerminator(BlockContext lambdaContext);
    internal virtual BlockContext ProcessOtherAsStatementTerminator();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineIfOrElseBlockContext : ExecutableStatementContext {
    internal bool IsSingleLine { get; }
    protected SingleLineIfOrElseBlockContext(SyntaxKind kind, StatementSyntax statement, BlockContext prevContext);
    internal virtual BlockContext ResyncAndProcessStatementTerminator(StatementSyntax statement, BlockContext lambdaContext);
    internal virtual bool get_IsSingleLine();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineIfStatementSyntax : ExecutableStatementSyntax {
    internal KeywordSyntax _ifKeyword;
    internal ExpressionSyntax _condition;
    internal KeywordSyntax _thenKeyword;
    internal GreenNode _statements;
    internal SingleLineElseClauseSyntax _elseClause;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax IfKeyword { get; }
    internal ExpressionSyntax Condition { get; }
    internal KeywordSyntax ThenKeyword { get; }
    internal SyntaxList`1<StatementSyntax> Statements { get; }
    internal SingleLineElseClauseSyntax ElseClause { get; }
    private static SingleLineIfStatementSyntax();
    internal SingleLineIfStatementSyntax(SyntaxKind kind, KeywordSyntax ifKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword, GreenNode statements, SingleLineElseClauseSyntax elseClause);
    internal SingleLineIfStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax ifKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword, GreenNode statements, SingleLineElseClauseSyntax elseClause);
    internal SingleLineIfStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax ifKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword, GreenNode statements, SingleLineElseClauseSyntax elseClause);
    internal SingleLineIfStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_IfKeyword();
    internal ExpressionSyntax get_Condition();
    internal KeywordSyntax get_ThenKeyword();
    internal SyntaxList`1<StatementSyntax> get_Statements();
    internal SingleLineElseClauseSyntax get_ElseClause();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineLambdaContext : MethodBlockContext {
    internal bool IsLambda { get; }
    internal bool IsSingleLine { get; }
    internal SingleLineLambdaContext(StatementSyntax statement, BlockContext prevContext);
    internal virtual bool get_IsLambda();
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax endStmt);
    internal virtual BlockContext EndBlock(StatementSyntax endStmt);
    internal virtual BlockContext ResyncAndProcessStatementTerminator(StatementSyntax statement, BlockContext lambdaContext);
    internal virtual BlockContext ProcessStatementTerminator(BlockContext lambdaContext);
    internal virtual BlockContext ProcessElseAsStatementTerminator();
    internal virtual BlockContext ProcessOtherAsStatementTerminator();
    internal virtual bool get_IsSingleLine();
    private static bool IsSingleStatement(VisualBasicSyntaxNode statement);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SingleLineLambdaExpressionSyntax : LambdaExpressionSyntax {
    internal VisualBasicSyntaxNode _body;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal VisualBasicSyntaxNode Body { get; }
    private static SingleLineLambdaExpressionSyntax();
    internal SingleLineLambdaExpressionSyntax(SyntaxKind kind, LambdaHeaderSyntax subOrFunctionHeader, VisualBasicSyntaxNode body);
    internal SingleLineLambdaExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, LambdaHeaderSyntax subOrFunctionHeader, VisualBasicSyntaxNode body);
    internal SingleLineLambdaExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, LambdaHeaderSyntax subOrFunctionHeader, VisualBasicSyntaxNode body);
    internal SingleLineLambdaExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal VisualBasicSyntaxNode get_Body();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SkippedTokensTriviaSyntax : StructuredTriviaSyntax {
    internal GreenNode _tokens;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxList`1<SyntaxToken> Tokens { get; }
    private static SkippedTokensTriviaSyntax();
    internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode tokens);
    internal SkippedTokensTriviaSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode tokens);
    internal SkippedTokensTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode tokens);
    internal SkippedTokensTriviaSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SyntaxList`1<SyntaxToken> get_Tokens();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SpecialConstraintSyntax : ConstraintSyntax {
    internal KeywordSyntax _constraintKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ConstraintKeyword { get; }
    private static SpecialConstraintSyntax();
    internal SpecialConstraintSyntax(SyntaxKind kind, KeywordSyntax constraintKeyword);
    internal SpecialConstraintSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax constraintKeyword);
    internal SpecialConstraintSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax constraintKeyword);
    internal SpecialConstraintSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ConstraintKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StatementBlockContext : ExecutableStatementContext {
    internal StatementBlockContext(SyntaxKind kind, StatementSyntax statement, BlockContext prevContext);
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax statement);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StatementSyntax : VisualBasicSyntaxNode {
    internal StatementSyntax(SyntaxKind kind);
    internal StatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal StatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal StatementSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StopOrEndStatementSyntax : ExecutableStatementSyntax {
    internal KeywordSyntax _stopOrEndKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax StopOrEndKeyword { get; }
    private static StopOrEndStatementSyntax();
    internal StopOrEndStatementSyntax(SyntaxKind kind, KeywordSyntax stopOrEndKeyword);
    internal StopOrEndStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax stopOrEndKeyword);
    internal StopOrEndStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax stopOrEndKeyword);
    internal StopOrEndStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_StopOrEndKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StringLiteralTokenSyntax : SyntaxToken {
    internal string _value;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal object ObjectValue { get; }
    internal string ValueText { get; }
    internal string Value { get; }
    private static StringLiteralTokenSyntax();
    internal StringLiteralTokenSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, string value);
    internal StringLiteralTokenSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, ISyntaxFactoryContext context, string value);
    internal StringLiteralTokenSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, string value);
    internal StringLiteralTokenSyntax(ObjectReader reader);
    internal sealed virtual object get_ObjectValue();
    internal sealed virtual string get_ValueText();
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal string get_Value();
    public virtual GreenNode WithLeadingTrivia(GreenNode trivia);
    public virtual GreenNode WithTrailingTrivia(GreenNode trivia);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StructureBlockSyntax : TypeBlockSyntax {
    internal StructureStatementSyntax _structureStatement;
    internal EndBlockStatementSyntax _endStructureStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    public TypeStatementSyntax BlockStatement { get; }
    public EndBlockStatementSyntax EndBlockStatement { get; }
    internal StructureStatementSyntax StructureStatement { get; }
    internal EndBlockStatementSyntax EndStructureStatement { get; }
    private static StructureBlockSyntax();
    internal StructureBlockSyntax(SyntaxKind kind, StructureStatementSyntax structureStatement, GreenNode inherits, GreenNode implements, GreenNode members, EndBlockStatementSyntax endStructureStatement);
    internal StructureBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, StructureStatementSyntax structureStatement, GreenNode inherits, GreenNode implements, GreenNode members, EndBlockStatementSyntax endStructureStatement);
    internal StructureBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, StructureStatementSyntax structureStatement, GreenNode inherits, GreenNode implements, GreenNode members, EndBlockStatementSyntax endStructureStatement);
    internal StructureBlockSyntax(ObjectReader reader);
    public virtual TypeStatementSyntax get_BlockStatement();
    public virtual EndBlockStatementSyntax get_EndBlockStatement();
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal StructureStatementSyntax get_StructureStatement();
    internal EndBlockStatementSyntax get_EndStructureStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StructuredTriviaSyntax : VisualBasicSyntaxNode {
    internal StructuredTriviaSyntax(ObjectReader reader);
    internal StructuredTriviaSyntax(SyntaxKind kind);
    internal StructuredTriviaSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal StructuredTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    private void Initialize();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.StructureStatementSyntax : TypeStatementSyntax {
    internal KeywordSyntax _structureKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax StructureKeyword { get; }
    private static StructureStatementSyntax();
    internal StructureStatementSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax structureKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal StructureStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax structureKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal StructureStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax structureKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal StructureStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_StructureKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SubNewStatementSyntax : MethodBaseSyntax {
    internal KeywordSyntax _subKeyword;
    internal KeywordSyntax _newKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax SubKeyword { get; }
    internal KeywordSyntax NewKeyword { get; }
    private static SubNewStatementSyntax();
    internal SubNewStatementSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax subKeyword, KeywordSyntax newKeyword, ParameterListSyntax parameterList);
    internal SubNewStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax subKeyword, KeywordSyntax newKeyword, ParameterListSyntax parameterList);
    internal SubNewStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, GreenNode modifiers, KeywordSyntax subKeyword, KeywordSyntax newKeyword, ParameterListSyntax parameterList);
    internal SubNewStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_SubKeyword();
    internal KeywordSyntax get_NewKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyncLockBlockSyntax : ExecutableStatementSyntax {
    internal SyncLockStatementSyntax _syncLockStatement;
    internal GreenNode _statements;
    internal EndBlockStatementSyntax _endSyncLockStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyncLockStatementSyntax SyncLockStatement { get; }
    internal SyntaxList`1<StatementSyntax> Statements { get; }
    internal EndBlockStatementSyntax EndSyncLockStatement { get; }
    private static SyncLockBlockSyntax();
    internal SyncLockBlockSyntax(SyntaxKind kind, SyncLockStatementSyntax syncLockStatement, GreenNode statements, EndBlockStatementSyntax endSyncLockStatement);
    internal SyncLockBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, SyncLockStatementSyntax syncLockStatement, GreenNode statements, EndBlockStatementSyntax endSyncLockStatement);
    internal SyncLockBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyncLockStatementSyntax syncLockStatement, GreenNode statements, EndBlockStatementSyntax endSyncLockStatement);
    internal SyncLockBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SyncLockStatementSyntax get_SyncLockStatement();
    internal SyntaxList`1<StatementSyntax> get_Statements();
    internal EndBlockStatementSyntax get_EndSyncLockStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyncLockStatementSyntax : StatementSyntax {
    internal KeywordSyntax _syncLockKeyword;
    internal ExpressionSyntax _expression;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax SyncLockKeyword { get; }
    internal ExpressionSyntax Expression { get; }
    private static SyncLockStatementSyntax();
    internal SyncLockStatementSyntax(SyntaxKind kind, KeywordSyntax syncLockKeyword, ExpressionSyntax expression);
    internal SyncLockStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax syncLockKeyword, ExpressionSyntax expression);
    internal SyncLockStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax syncLockKeyword, ExpressionSyntax expression);
    internal SyncLockStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_SyncLockKeyword();
    internal ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxDiagnosticInfoList : ValueType {
    private VisualBasicSyntaxNode _node;
    private int _count;
    private List`1<DiagnosticInfo> _list;
    public int Count { get; }
    public DiagnosticInfo Item { get; }
    private DiagnosticInfo[] Nodes { get; }
    internal SyntaxDiagnosticInfoList(VisualBasicSyntaxNode node);
    public int get_Count();
    private static int CountDiagnostics(GreenNode _node);
    public DiagnosticInfo get_Item(int index);
    private DiagnosticInfo[] get_Nodes();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<DiagnosticInfo> GetEnumerator1();
    private sealed virtual override IEnumerator GetEnumerator2();
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxExtensions : object {
    [ExtensionAttribute]
public static TNode WithAnnotations(TNode node, SyntaxAnnotation[] annotations);
    [ExtensionAttribute]
public static TNode WithAdditionalAnnotations(TNode node, SyntaxAnnotation[] annotations);
    [ExtensionAttribute]
public static TNode WithoutAnnotations(TNode node, SyntaxAnnotation[] removalAnnotations);
    [ExtensionAttribute]
public static TNode WithAdditionalDiagnostics(TNode node, DiagnosticInfo[] diagnostics);
    [ExtensionAttribute]
public static TNode WithDiagnostics(TNode node, DiagnosticInfo[] diagnostics);
    [ExtensionAttribute]
public static TNode WithoutDiagnostics(TNode node);
    [ExtensionAttribute]
public static VisualBasicSyntaxNode LastTriviaIfAny(VisualBasicSyntaxNode node);
    [ExtensionAttribute]
public static bool EndsWithEndOfLineOrColonTrivia(VisualBasicSyntaxNode node);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxFactory : object {
    internal static SyntaxTrivia CarriageReturnLineFeed;
    internal static SyntaxTrivia LineFeed;
    internal static SyntaxTrivia CarriageReturn;
    internal static SyntaxTrivia Space;
    internal static SyntaxTrivia Tab;
    internal static SyntaxTrivia ElasticCarriageReturnLineFeed;
    internal static SyntaxTrivia ElasticLineFeed;
    internal static SyntaxTrivia ElasticCarriageReturn;
    internal static SyntaxTrivia ElasticSpace;
    internal static SyntaxTrivia ElasticTab;
    internal static SyntaxTrivia ElasticZeroSpace;
    private static PunctuationSyntax s_notMissingEmptyToken;
    private static PunctuationSyntax s_missingEmptyToken;
    private static PunctuationSyntax s_statementTerminatorToken;
    private static PunctuationSyntax s_colonToken;
    private static ExpressionSyntax s_missingExpr;
    private static EmptyStatementSyntax s_emptyStatement;
    private static OmittedArgumentSyntax s_omittedArgument;
    internal static PunctuationSyntax NotMissingEmptyToken { get; }
    internal static PunctuationSyntax MissingEmptyToken { get; }
    internal static PunctuationSyntax StatementTerminatorToken { get; }
    internal static PunctuationSyntax ColonToken { get; }
    private static SyntaxFactory();
    internal static SyntaxTrivia EndOfLine(string text, bool elastic);
    internal static SyntaxTrivia Whitespace(string text, bool elastic);
    internal static SyntaxToken Token(VisualBasicSyntaxNode leading, SyntaxKind kind, VisualBasicSyntaxNode trailing, string text);
    internal static IEnumerable`1<SyntaxTrivia> GetWellKnownTrivia();
    internal static IntegerLiteralTokenSyntax IntegerLiteralToken(string text, LiteralBase base, TypeCharacter typeSuffix, ulong value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal static FloatingLiteralTokenSyntax FloatingLiteralToken(string text, TypeCharacter typeSuffix, double value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal static IdentifierTokenSyntax Identifier(string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal static IdentifierTokenSyntax Identifier(string text, SyntaxKind possibleKeywordKind, bool isBracketed, string identifierText, TypeCharacter typeCharacter, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal static IdentifierTokenSyntax Identifier(string text);
    internal static IdentifierTokenSyntax MissingIdentifier();
    internal static IdentifierTokenSyntax MissingIdentifier(SyntaxKind kind);
    internal static KeywordSyntax MissingKeyword(SyntaxKind kind);
    internal static PunctuationSyntax MissingPunctuation(SyntaxKind kind);
    internal static StringLiteralTokenSyntax MissingStringLiteral();
    internal static CharacterLiteralTokenSyntax MissingCharacterLiteralToken();
    internal static IntegerLiteralTokenSyntax MissingIntegerLiteralToken();
    internal static SyntaxToken MissingToken(SyntaxKind kind);
    internal static BadTokenSyntax BadToken(SyntaxSubKind SubKind, string text, VisualBasicSyntaxNode precedingTrivia, VisualBasicSyntaxNode followingTrivia);
    internal static PunctuationSyntax EndOfFileToken(SyntaxTrivia precedingTrivia);
    internal static PunctuationSyntax EndOfFileToken();
    internal static IdentifierTokenSyntax Identifier(string text, bool isBracketed, string baseText, TypeCharacter typeCharacter, VisualBasicSyntaxNode precedingTrivia, VisualBasicSyntaxNode followingTrivia);
    internal static PunctuationSyntax get_NotMissingEmptyToken();
    internal static PunctuationSyntax get_MissingEmptyToken();
    internal static PunctuationSyntax get_StatementTerminatorToken();
    internal static PunctuationSyntax get_ColonToken();
    internal static ExpressionSyntax MissingExpression();
    internal static EmptyStatementSyntax EmptyStatement();
    internal static OmittedArgumentSyntax OmittedArgument();
    public static TypeBlockSyntax TypeBlock(SyntaxKind blockKind, TypeStatementSyntax begin, SyntaxList`1<InheritsStatementSyntax> inherits, SyntaxList`1<ImplementsStatementSyntax> implements, SyntaxList`1<StatementSyntax> members, EndBlockStatementSyntax end);
    public static TypeStatementSyntax TypeStatement(SyntaxKind statementKind, SyntaxList`1<VisualBasicSyntaxNode> attributes, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax keyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal static IEnumerable`1<object> GetNodeTypes();
    internal static EmptyStatementSyntax EmptyStatement(PunctuationSyntax empty);
    internal static EndBlockStatementSyntax EndIfStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndUsingStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndWithStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndSelectStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndStructureStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndEnumStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndInterfaceStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndClassStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndModuleStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndNamespaceStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndSubStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndFunctionStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndGetStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndSetStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndPropertyStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndOperatorStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndEventStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndAddHandlerStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndRemoveHandlerStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndRaiseEventStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndWhileStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndTryStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndSyncLockStatement(KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static EndBlockStatementSyntax EndBlockStatement(SyntaxKind kind, KeywordSyntax endKeyword, KeywordSyntax blockKeyword);
    internal static CompilationUnitSyntax CompilationUnit(SyntaxList`1<VisualBasicSyntaxNode> options, SyntaxList`1<VisualBasicSyntaxNode> imports, SyntaxList`1<VisualBasicSyntaxNode> attributes, SyntaxList`1<VisualBasicSyntaxNode> members, PunctuationSyntax endOfFileToken);
    internal static OptionStatementSyntax OptionStatement(KeywordSyntax optionKeyword, KeywordSyntax nameKeyword, KeywordSyntax valueKeyword);
    internal static ImportsStatementSyntax ImportsStatement(KeywordSyntax importsKeyword, SeparatedSyntaxList`1<ImportsClauseSyntax> importsClauses);
    internal static SimpleImportsClauseSyntax SimpleImportsClause(ImportAliasClauseSyntax alias, NameSyntax name);
    internal static ImportAliasClauseSyntax ImportAliasClause(IdentifierTokenSyntax identifier, PunctuationSyntax equalsToken);
    internal static XmlNamespaceImportsClauseSyntax XmlNamespaceImportsClause(PunctuationSyntax lessThanToken, XmlAttributeSyntax xmlNamespace, PunctuationSyntax greaterThanToken);
    internal static NamespaceBlockSyntax NamespaceBlock(NamespaceStatementSyntax namespaceStatement, SyntaxList`1<VisualBasicSyntaxNode> members, EndBlockStatementSyntax endNamespaceStatement);
    internal static NamespaceStatementSyntax NamespaceStatement(KeywordSyntax namespaceKeyword, NameSyntax name);
    internal static ModuleBlockSyntax ModuleBlock(ModuleStatementSyntax moduleStatement, SyntaxList`1<VisualBasicSyntaxNode> inherits, SyntaxList`1<VisualBasicSyntaxNode> implements, SyntaxList`1<VisualBasicSyntaxNode> members, EndBlockStatementSyntax endModuleStatement);
    internal static StructureBlockSyntax StructureBlock(StructureStatementSyntax structureStatement, SyntaxList`1<VisualBasicSyntaxNode> inherits, SyntaxList`1<VisualBasicSyntaxNode> implements, SyntaxList`1<VisualBasicSyntaxNode> members, EndBlockStatementSyntax endStructureStatement);
    internal static InterfaceBlockSyntax InterfaceBlock(InterfaceStatementSyntax interfaceStatement, SyntaxList`1<VisualBasicSyntaxNode> inherits, SyntaxList`1<VisualBasicSyntaxNode> implements, SyntaxList`1<VisualBasicSyntaxNode> members, EndBlockStatementSyntax endInterfaceStatement);
    internal static ClassBlockSyntax ClassBlock(ClassStatementSyntax classStatement, SyntaxList`1<VisualBasicSyntaxNode> inherits, SyntaxList`1<VisualBasicSyntaxNode> implements, SyntaxList`1<VisualBasicSyntaxNode> members, EndBlockStatementSyntax endClassStatement);
    internal static EnumBlockSyntax EnumBlock(EnumStatementSyntax enumStatement, SyntaxList`1<VisualBasicSyntaxNode> members, EndBlockStatementSyntax endEnumStatement);
    internal static InheritsStatementSyntax InheritsStatement(KeywordSyntax inheritsKeyword, SeparatedSyntaxList`1<TypeSyntax> types);
    internal static ImplementsStatementSyntax ImplementsStatement(KeywordSyntax implementsKeyword, SeparatedSyntaxList`1<TypeSyntax> types);
    internal static ModuleStatementSyntax ModuleStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax moduleKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal static StructureStatementSyntax StructureStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax structureKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal static InterfaceStatementSyntax InterfaceStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax interfaceKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal static ClassStatementSyntax ClassStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax classKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal static EnumStatementSyntax EnumStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax enumKeyword, IdentifierTokenSyntax identifier, AsClauseSyntax underlyingType);
    internal static TypeParameterListSyntax TypeParameterList(PunctuationSyntax openParenToken, KeywordSyntax ofKeyword, SeparatedSyntaxList`1<TypeParameterSyntax> parameters, PunctuationSyntax closeParenToken);
    internal static TypeParameterSyntax TypeParameter(KeywordSyntax varianceKeyword, IdentifierTokenSyntax identifier, TypeParameterConstraintClauseSyntax typeParameterConstraintClause);
    internal static TypeParameterSingleConstraintClauseSyntax TypeParameterSingleConstraintClause(KeywordSyntax asKeyword, ConstraintSyntax constraint);
    internal static TypeParameterMultipleConstraintClauseSyntax TypeParameterMultipleConstraintClause(KeywordSyntax asKeyword, PunctuationSyntax openBraceToken, SeparatedSyntaxList`1<ConstraintSyntax> constraints, PunctuationSyntax closeBraceToken);
    internal static SpecialConstraintSyntax NewConstraint(KeywordSyntax constraintKeyword);
    internal static SpecialConstraintSyntax ClassConstraint(KeywordSyntax constraintKeyword);
    internal static SpecialConstraintSyntax StructureConstraint(KeywordSyntax constraintKeyword);
    internal static SpecialConstraintSyntax SpecialConstraint(SyntaxKind kind, KeywordSyntax constraintKeyword);
    internal static TypeConstraintSyntax TypeConstraint(TypeSyntax type);
    internal static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, IdentifierTokenSyntax identifier, EqualsValueSyntax initializer);
    internal static MethodBlockSyntax SubBlock(MethodStatementSyntax subOrFunctionStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    internal static MethodBlockSyntax FunctionBlock(MethodStatementSyntax subOrFunctionStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    internal static MethodBlockSyntax MethodBlock(SyntaxKind kind, MethodStatementSyntax subOrFunctionStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    internal static ConstructorBlockSyntax ConstructorBlock(SubNewStatementSyntax subNewStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endSubStatement);
    internal static OperatorBlockSyntax OperatorBlock(OperatorStatementSyntax operatorStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endOperatorStatement);
    internal static AccessorBlockSyntax GetAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endAccessorStatement);
    internal static AccessorBlockSyntax SetAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endAccessorStatement);
    internal static AccessorBlockSyntax AddHandlerAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endAccessorStatement);
    internal static AccessorBlockSyntax RemoveHandlerAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endAccessorStatement);
    internal static AccessorBlockSyntax RaiseEventAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endAccessorStatement);
    internal static AccessorBlockSyntax AccessorBlock(SyntaxKind kind, AccessorStatementSyntax accessorStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endAccessorStatement);
    internal static PropertyBlockSyntax PropertyBlock(PropertyStatementSyntax propertyStatement, SyntaxList`1<VisualBasicSyntaxNode> accessors, EndBlockStatementSyntax endPropertyStatement);
    internal static EventBlockSyntax EventBlock(EventStatementSyntax eventStatement, SyntaxList`1<VisualBasicSyntaxNode> accessors, EndBlockStatementSyntax endEventStatement);
    internal static ParameterListSyntax ParameterList(PunctuationSyntax openParenToken, SeparatedSyntaxList`1<ParameterSyntax> parameters, PunctuationSyntax closeParenToken);
    internal static MethodStatementSyntax SubStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, HandlesClauseSyntax handlesClause, ImplementsClauseSyntax implementsClause);
    internal static MethodStatementSyntax FunctionStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, HandlesClauseSyntax handlesClause, ImplementsClauseSyntax implementsClause);
    internal static MethodStatementSyntax MethodStatement(SyntaxKind kind, SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, HandlesClauseSyntax handlesClause, ImplementsClauseSyntax implementsClause);
    internal static SubNewStatementSyntax SubNewStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax subKeyword, KeywordSyntax newKeyword, ParameterListSyntax parameterList);
    internal static DeclareStatementSyntax DeclareSubStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax declareKeyword, KeywordSyntax charsetKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, KeywordSyntax libKeyword, LiteralExpressionSyntax libraryName, KeywordSyntax aliasKeyword, LiteralExpressionSyntax aliasName, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal static DeclareStatementSyntax DeclareFunctionStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax declareKeyword, KeywordSyntax charsetKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, KeywordSyntax libKeyword, LiteralExpressionSyntax libraryName, KeywordSyntax aliasKeyword, LiteralExpressionSyntax aliasName, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal static DeclareStatementSyntax DeclareStatement(SyntaxKind kind, SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax declareKeyword, KeywordSyntax charsetKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, KeywordSyntax libKeyword, LiteralExpressionSyntax libraryName, KeywordSyntax aliasKeyword, LiteralExpressionSyntax aliasName, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal static DelegateStatementSyntax DelegateSubStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax delegateKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal static DelegateStatementSyntax DelegateFunctionStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax delegateKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal static DelegateStatementSyntax DelegateStatement(SyntaxKind kind, SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax delegateKeyword, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal static EventStatementSyntax EventStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax customKeyword, KeywordSyntax eventKeyword, IdentifierTokenSyntax identifier, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, ImplementsClauseSyntax implementsClause);
    internal static OperatorStatementSyntax OperatorStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal static PropertyStatementSyntax PropertyStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax propertyKeyword, IdentifierTokenSyntax identifier, ParameterListSyntax parameterList, AsClauseSyntax asClause, EqualsValueSyntax initializer, ImplementsClauseSyntax implementsClause);
    internal static AccessorStatementSyntax GetAccessorStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax accessorKeyword, ParameterListSyntax parameterList);
    internal static AccessorStatementSyntax SetAccessorStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax accessorKeyword, ParameterListSyntax parameterList);
    internal static AccessorStatementSyntax AddHandlerAccessorStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax accessorKeyword, ParameterListSyntax parameterList);
    internal static AccessorStatementSyntax RemoveHandlerAccessorStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax accessorKeyword, ParameterListSyntax parameterList);
    internal static AccessorStatementSyntax RaiseEventAccessorStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax accessorKeyword, ParameterListSyntax parameterList);
    internal static AccessorStatementSyntax AccessorStatement(SyntaxKind kind, SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax accessorKeyword, ParameterListSyntax parameterList);
    internal static ImplementsClauseSyntax ImplementsClause(KeywordSyntax implementsKeyword, SeparatedSyntaxList`1<QualifiedNameSyntax> interfaceMembers);
    internal static HandlesClauseSyntax HandlesClause(KeywordSyntax handlesKeyword, SeparatedSyntaxList`1<HandlesClauseItemSyntax> events);
    internal static KeywordEventContainerSyntax KeywordEventContainer(KeywordSyntax keyword);
    internal static WithEventsEventContainerSyntax WithEventsEventContainer(IdentifierTokenSyntax identifier);
    internal static WithEventsPropertyEventContainerSyntax WithEventsPropertyEventContainer(WithEventsEventContainerSyntax withEventsContainer, PunctuationSyntax dotToken, IdentifierNameSyntax property);
    internal static HandlesClauseItemSyntax HandlesClauseItem(EventContainerSyntax eventContainer, PunctuationSyntax dotToken, IdentifierNameSyntax eventMember);
    internal static IncompleteMemberSyntax IncompleteMember(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, IdentifierTokenSyntax missingIdentifier);
    internal static FieldDeclarationSyntax FieldDeclaration(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, SeparatedSyntaxList`1<VariableDeclaratorSyntax> declarators);
    internal static VariableDeclaratorSyntax VariableDeclarator(SeparatedSyntaxList`1<ModifiedIdentifierSyntax> names, AsClauseSyntax asClause, EqualsValueSyntax initializer);
    internal static SimpleAsClauseSyntax SimpleAsClause(KeywordSyntax asKeyword, SyntaxList`1<VisualBasicSyntaxNode> attributeLists, TypeSyntax type);
    internal static AsNewClauseSyntax AsNewClause(KeywordSyntax asKeyword, NewExpressionSyntax newExpression);
    internal static ObjectMemberInitializerSyntax ObjectMemberInitializer(KeywordSyntax withKeyword, PunctuationSyntax openBraceToken, SeparatedSyntaxList`1<FieldInitializerSyntax> initializers, PunctuationSyntax closeBraceToken);
    internal static ObjectCollectionInitializerSyntax ObjectCollectionInitializer(KeywordSyntax fromKeyword, CollectionInitializerSyntax initializer);
    internal static InferredFieldInitializerSyntax InferredFieldInitializer(KeywordSyntax keyKeyword, ExpressionSyntax expression);
    internal static NamedFieldInitializerSyntax NamedFieldInitializer(KeywordSyntax keyKeyword, PunctuationSyntax dotToken, IdentifierNameSyntax name, PunctuationSyntax equalsToken, ExpressionSyntax expression);
    internal static EqualsValueSyntax EqualsValue(PunctuationSyntax equalsToken, ExpressionSyntax value);
    internal static ParameterSyntax Parameter(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, EqualsValueSyntax default);
    internal static ModifiedIdentifierSyntax ModifiedIdentifier(IdentifierTokenSyntax identifier, PunctuationSyntax nullable, ArgumentListSyntax arrayBounds, SyntaxList`1<VisualBasicSyntaxNode> arrayRankSpecifiers);
    internal static ArrayRankSpecifierSyntax ArrayRankSpecifier(PunctuationSyntax openParenToken, SyntaxList`1<VisualBasicSyntaxNode> commaTokens, PunctuationSyntax closeParenToken);
    internal static AttributeListSyntax AttributeList(PunctuationSyntax lessThanToken, SeparatedSyntaxList`1<AttributeSyntax> attributes, PunctuationSyntax greaterThanToken);
    internal static AttributeSyntax Attribute(AttributeTargetSyntax target, TypeSyntax name, ArgumentListSyntax argumentList);
    internal static AttributeTargetSyntax AttributeTarget(KeywordSyntax attributeModifier, PunctuationSyntax colonToken);
    internal static AttributesStatementSyntax AttributesStatement(SyntaxList`1<VisualBasicSyntaxNode> attributeLists);
    internal static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression);
    internal static PrintStatementSyntax PrintStatement(PunctuationSyntax questionToken, ExpressionSyntax expression);
    internal static WhileBlockSyntax WhileBlock(WhileStatementSyntax whileStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endWhileStatement);
    internal static UsingBlockSyntax UsingBlock(UsingStatementSyntax usingStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endUsingStatement);
    internal static SyncLockBlockSyntax SyncLockBlock(SyncLockStatementSyntax syncLockStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endSyncLockStatement);
    internal static WithBlockSyntax WithBlock(WithStatementSyntax withStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endWithStatement);
    internal static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxList`1<VisualBasicSyntaxNode> modifiers, SeparatedSyntaxList`1<VariableDeclaratorSyntax> declarators);
    internal static LabelStatementSyntax LabelStatement(SyntaxToken labelToken, PunctuationSyntax colonToken);
    internal static GoToStatementSyntax GoToStatement(KeywordSyntax goToKeyword, LabelSyntax label);
    internal static LabelSyntax IdentifierLabel(SyntaxToken labelToken);
    internal static LabelSyntax NumericLabel(SyntaxToken labelToken);
    internal static LabelSyntax NextLabel(SyntaxToken labelToken);
    internal static LabelSyntax Label(SyntaxKind kind, SyntaxToken labelToken);
    internal static StopOrEndStatementSyntax StopStatement(KeywordSyntax stopOrEndKeyword);
    internal static StopOrEndStatementSyntax EndStatement(KeywordSyntax stopOrEndKeyword);
    internal static StopOrEndStatementSyntax StopOrEndStatement(SyntaxKind kind, KeywordSyntax stopOrEndKeyword);
    internal static ExitStatementSyntax ExitDoStatement(KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal static ExitStatementSyntax ExitForStatement(KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal static ExitStatementSyntax ExitSubStatement(KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal static ExitStatementSyntax ExitFunctionStatement(KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal static ExitStatementSyntax ExitOperatorStatement(KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal static ExitStatementSyntax ExitPropertyStatement(KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal static ExitStatementSyntax ExitTryStatement(KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal static ExitStatementSyntax ExitSelectStatement(KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal static ExitStatementSyntax ExitWhileStatement(KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal static ExitStatementSyntax ExitStatement(SyntaxKind kind, KeywordSyntax exitKeyword, KeywordSyntax blockKeyword);
    internal static ContinueStatementSyntax ContinueWhileStatement(KeywordSyntax continueKeyword, KeywordSyntax blockKeyword);
    internal static ContinueStatementSyntax ContinueDoStatement(KeywordSyntax continueKeyword, KeywordSyntax blockKeyword);
    internal static ContinueStatementSyntax ContinueForStatement(KeywordSyntax continueKeyword, KeywordSyntax blockKeyword);
    internal static ContinueStatementSyntax ContinueStatement(SyntaxKind kind, KeywordSyntax continueKeyword, KeywordSyntax blockKeyword);
    internal static ReturnStatementSyntax ReturnStatement(KeywordSyntax returnKeyword, ExpressionSyntax expression);
    internal static SingleLineIfStatementSyntax SingleLineIfStatement(KeywordSyntax ifKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword, SyntaxList`1<VisualBasicSyntaxNode> statements, SingleLineElseClauseSyntax elseClause);
    internal static SingleLineElseClauseSyntax SingleLineElseClause(KeywordSyntax elseKeyword, SyntaxList`1<VisualBasicSyntaxNode> statements);
    internal static MultiLineIfBlockSyntax MultiLineIfBlock(IfStatementSyntax ifStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, SyntaxList`1<VisualBasicSyntaxNode> elseIfBlocks, ElseBlockSyntax elseBlock, EndBlockStatementSyntax endIfStatement);
    internal static IfStatementSyntax IfStatement(KeywordSyntax ifKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    internal static ElseIfBlockSyntax ElseIfBlock(ElseIfStatementSyntax elseIfStatement, SyntaxList`1<VisualBasicSyntaxNode> statements);
    internal static ElseIfStatementSyntax ElseIfStatement(KeywordSyntax elseIfKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    internal static ElseBlockSyntax ElseBlock(ElseStatementSyntax elseStatement, SyntaxList`1<VisualBasicSyntaxNode> statements);
    internal static ElseStatementSyntax ElseStatement(KeywordSyntax elseKeyword);
    internal static TryBlockSyntax TryBlock(TryStatementSyntax tryStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, SyntaxList`1<VisualBasicSyntaxNode> catchBlocks, FinallyBlockSyntax finallyBlock, EndBlockStatementSyntax endTryStatement);
    internal static TryStatementSyntax TryStatement(KeywordSyntax tryKeyword);
    internal static CatchBlockSyntax CatchBlock(CatchStatementSyntax catchStatement, SyntaxList`1<VisualBasicSyntaxNode> statements);
    internal static CatchStatementSyntax CatchStatement(KeywordSyntax catchKeyword, IdentifierNameSyntax identifierName, SimpleAsClauseSyntax asClause, CatchFilterClauseSyntax whenClause);
    internal static CatchFilterClauseSyntax CatchFilterClause(KeywordSyntax whenKeyword, ExpressionSyntax filter);
    internal static FinallyBlockSyntax FinallyBlock(FinallyStatementSyntax finallyStatement, SyntaxList`1<VisualBasicSyntaxNode> statements);
    internal static FinallyStatementSyntax FinallyStatement(KeywordSyntax finallyKeyword);
    internal static ErrorStatementSyntax ErrorStatement(KeywordSyntax errorKeyword, ExpressionSyntax errorNumber);
    internal static OnErrorGoToStatementSyntax OnErrorGoToZeroStatement(KeywordSyntax onKeyword, KeywordSyntax errorKeyword, KeywordSyntax goToKeyword, PunctuationSyntax minus, LabelSyntax label);
    internal static OnErrorGoToStatementSyntax OnErrorGoToMinusOneStatement(KeywordSyntax onKeyword, KeywordSyntax errorKeyword, KeywordSyntax goToKeyword, PunctuationSyntax minus, LabelSyntax label);
    internal static OnErrorGoToStatementSyntax OnErrorGoToLabelStatement(KeywordSyntax onKeyword, KeywordSyntax errorKeyword, KeywordSyntax goToKeyword, PunctuationSyntax minus, LabelSyntax label);
    internal static OnErrorGoToStatementSyntax OnErrorGoToStatement(SyntaxKind kind, KeywordSyntax onKeyword, KeywordSyntax errorKeyword, KeywordSyntax goToKeyword, PunctuationSyntax minus, LabelSyntax label);
    internal static OnErrorResumeNextStatementSyntax OnErrorResumeNextStatement(KeywordSyntax onKeyword, KeywordSyntax errorKeyword, KeywordSyntax resumeKeyword, KeywordSyntax nextKeyword);
    internal static ResumeStatementSyntax ResumeStatement(KeywordSyntax resumeKeyword, LabelSyntax label);
    internal static ResumeStatementSyntax ResumeLabelStatement(KeywordSyntax resumeKeyword, LabelSyntax label);
    internal static ResumeStatementSyntax ResumeNextStatement(KeywordSyntax resumeKeyword, LabelSyntax label);
    internal static SelectBlockSyntax SelectBlock(SelectStatementSyntax selectStatement, SyntaxList`1<VisualBasicSyntaxNode> caseBlocks, EndBlockStatementSyntax endSelectStatement);
    internal static SelectStatementSyntax SelectStatement(KeywordSyntax selectKeyword, KeywordSyntax caseKeyword, ExpressionSyntax expression);
    internal static CaseBlockSyntax CaseBlock(CaseStatementSyntax caseStatement, SyntaxList`1<VisualBasicSyntaxNode> statements);
    internal static CaseBlockSyntax CaseElseBlock(CaseStatementSyntax caseStatement, SyntaxList`1<VisualBasicSyntaxNode> statements);
    internal static CaseStatementSyntax CaseStatement(KeywordSyntax caseKeyword, SeparatedSyntaxList`1<CaseClauseSyntax> cases);
    internal static CaseStatementSyntax CaseElseStatement(KeywordSyntax caseKeyword, SeparatedSyntaxList`1<CaseClauseSyntax> cases);
    internal static ElseCaseClauseSyntax ElseCaseClause(KeywordSyntax elseKeyword);
    internal static SimpleCaseClauseSyntax SimpleCaseClause(ExpressionSyntax value);
    internal static RangeCaseClauseSyntax RangeCaseClause(ExpressionSyntax lowerBound, KeywordSyntax toKeyword, ExpressionSyntax upperBound);
    internal static RelationalCaseClauseSyntax CaseEqualsClause(KeywordSyntax isKeyword, PunctuationSyntax operatorToken, ExpressionSyntax value);
    internal static RelationalCaseClauseSyntax CaseNotEqualsClause(KeywordSyntax isKeyword, PunctuationSyntax operatorToken, ExpressionSyntax value);
    internal static RelationalCaseClauseSyntax CaseLessThanClause(KeywordSyntax isKeyword, PunctuationSyntax operatorToken, ExpressionSyntax value);
    internal static RelationalCaseClauseSyntax CaseLessThanOrEqualClause(KeywordSyntax isKeyword, PunctuationSyntax operatorToken, ExpressionSyntax value);
    internal static RelationalCaseClauseSyntax CaseGreaterThanOrEqualClause(KeywordSyntax isKeyword, PunctuationSyntax operatorToken, ExpressionSyntax value);
    internal static RelationalCaseClauseSyntax CaseGreaterThanClause(KeywordSyntax isKeyword, PunctuationSyntax operatorToken, ExpressionSyntax value);
    internal static RelationalCaseClauseSyntax RelationalCaseClause(SyntaxKind kind, KeywordSyntax isKeyword, PunctuationSyntax operatorToken, ExpressionSyntax value);
    internal static SyncLockStatementSyntax SyncLockStatement(KeywordSyntax syncLockKeyword, ExpressionSyntax expression);
    internal static DoLoopBlockSyntax SimpleDoLoopBlock(DoStatementSyntax doStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, LoopStatementSyntax loopStatement);
    internal static DoLoopBlockSyntax DoWhileLoopBlock(DoStatementSyntax doStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, LoopStatementSyntax loopStatement);
    internal static DoLoopBlockSyntax DoUntilLoopBlock(DoStatementSyntax doStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, LoopStatementSyntax loopStatement);
    internal static DoLoopBlockSyntax DoLoopWhileBlock(DoStatementSyntax doStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, LoopStatementSyntax loopStatement);
    internal static DoLoopBlockSyntax DoLoopUntilBlock(DoStatementSyntax doStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, LoopStatementSyntax loopStatement);
    internal static DoLoopBlockSyntax DoLoopBlock(SyntaxKind kind, DoStatementSyntax doStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, LoopStatementSyntax loopStatement);
    internal static DoStatementSyntax SimpleDoStatement(KeywordSyntax doKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal static DoStatementSyntax DoWhileStatement(KeywordSyntax doKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal static DoStatementSyntax DoUntilStatement(KeywordSyntax doKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal static DoStatementSyntax DoStatement(SyntaxKind kind, KeywordSyntax doKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal static LoopStatementSyntax SimpleLoopStatement(KeywordSyntax loopKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal static LoopStatementSyntax LoopWhileStatement(KeywordSyntax loopKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal static LoopStatementSyntax LoopUntilStatement(KeywordSyntax loopKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal static LoopStatementSyntax LoopStatement(SyntaxKind kind, KeywordSyntax loopKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    internal static WhileOrUntilClauseSyntax WhileClause(KeywordSyntax whileOrUntilKeyword, ExpressionSyntax condition);
    internal static WhileOrUntilClauseSyntax UntilClause(KeywordSyntax whileOrUntilKeyword, ExpressionSyntax condition);
    internal static WhileOrUntilClauseSyntax WhileOrUntilClause(SyntaxKind kind, KeywordSyntax whileOrUntilKeyword, ExpressionSyntax condition);
    internal static WhileStatementSyntax WhileStatement(KeywordSyntax whileKeyword, ExpressionSyntax condition);
    internal static ForBlockSyntax ForBlock(ForStatementSyntax forStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, NextStatementSyntax nextStatement);
    internal static ForEachBlockSyntax ForEachBlock(ForEachStatementSyntax forEachStatement, SyntaxList`1<VisualBasicSyntaxNode> statements, NextStatementSyntax nextStatement);
    internal static ForStatementSyntax ForStatement(KeywordSyntax forKeyword, VisualBasicSyntaxNode controlVariable, PunctuationSyntax equalsToken, ExpressionSyntax fromValue, KeywordSyntax toKeyword, ExpressionSyntax toValue, ForStepClauseSyntax stepClause);
    internal static ForStepClauseSyntax ForStepClause(KeywordSyntax stepKeyword, ExpressionSyntax stepValue);
    internal static ForEachStatementSyntax ForEachStatement(KeywordSyntax forKeyword, KeywordSyntax eachKeyword, VisualBasicSyntaxNode controlVariable, KeywordSyntax inKeyword, ExpressionSyntax expression);
    internal static NextStatementSyntax NextStatement(KeywordSyntax nextKeyword, SeparatedSyntaxList`1<ExpressionSyntax> controlVariables);
    internal static UsingStatementSyntax UsingStatement(KeywordSyntax usingKeyword, ExpressionSyntax expression, SeparatedSyntaxList`1<VariableDeclaratorSyntax> variables);
    internal static ThrowStatementSyntax ThrowStatement(KeywordSyntax throwKeyword, ExpressionSyntax expression);
    internal static AssignmentStatementSyntax SimpleAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal static AssignmentStatementSyntax MidAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal static AssignmentStatementSyntax AddAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal static AssignmentStatementSyntax SubtractAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal static AssignmentStatementSyntax MultiplyAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal static AssignmentStatementSyntax DivideAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal static AssignmentStatementSyntax IntegerDivideAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal static AssignmentStatementSyntax ExponentiateAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal static AssignmentStatementSyntax LeftShiftAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal static AssignmentStatementSyntax RightShiftAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal static AssignmentStatementSyntax ConcatenateAssignmentStatement(ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal static AssignmentStatementSyntax AssignmentStatement(SyntaxKind kind, ExpressionSyntax left, PunctuationSyntax operatorToken, ExpressionSyntax right);
    internal static MidExpressionSyntax MidExpression(IdentifierTokenSyntax mid, ArgumentListSyntax argumentList);
    internal static CallStatementSyntax CallStatement(KeywordSyntax callKeyword, ExpressionSyntax invocation);
    internal static AddRemoveHandlerStatementSyntax AddHandlerStatement(KeywordSyntax addHandlerOrRemoveHandlerKeyword, ExpressionSyntax eventExpression, PunctuationSyntax commaToken, ExpressionSyntax delegateExpression);
    internal static AddRemoveHandlerStatementSyntax RemoveHandlerStatement(KeywordSyntax addHandlerOrRemoveHandlerKeyword, ExpressionSyntax eventExpression, PunctuationSyntax commaToken, ExpressionSyntax delegateExpression);
    internal static AddRemoveHandlerStatementSyntax AddRemoveHandlerStatement(SyntaxKind kind, KeywordSyntax addHandlerOrRemoveHandlerKeyword, ExpressionSyntax eventExpression, PunctuationSyntax commaToken, ExpressionSyntax delegateExpression);
    internal static RaiseEventStatementSyntax RaiseEventStatement(KeywordSyntax raiseEventKeyword, IdentifierNameSyntax name, ArgumentListSyntax argumentList);
    internal static WithStatementSyntax WithStatement(KeywordSyntax withKeyword, ExpressionSyntax expression);
    internal static ReDimStatementSyntax ReDimStatement(KeywordSyntax reDimKeyword, KeywordSyntax preserveKeyword, SeparatedSyntaxList`1<RedimClauseSyntax> clauses);
    internal static ReDimStatementSyntax ReDimPreserveStatement(KeywordSyntax reDimKeyword, KeywordSyntax preserveKeyword, SeparatedSyntaxList`1<RedimClauseSyntax> clauses);
    internal static RedimClauseSyntax RedimClause(ExpressionSyntax expression, ArgumentListSyntax arrayBounds);
    internal static EraseStatementSyntax EraseStatement(KeywordSyntax eraseKeyword, SeparatedSyntaxList`1<ExpressionSyntax> expressions);
    internal static LiteralExpressionSyntax CharacterLiteralExpression(SyntaxToken token);
    internal static LiteralExpressionSyntax TrueLiteralExpression(SyntaxToken token);
    internal static LiteralExpressionSyntax FalseLiteralExpression(SyntaxToken token);
    internal static LiteralExpressionSyntax NumericLiteralExpression(SyntaxToken token);
    internal static LiteralExpressionSyntax DateLiteralExpression(SyntaxToken token);
    internal static LiteralExpressionSyntax StringLiteralExpression(SyntaxToken token);
    internal static LiteralExpressionSyntax NothingLiteralExpression(SyntaxToken token);
    internal static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token);
    internal static ParenthesizedExpressionSyntax ParenthesizedExpression(PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax closeParenToken);
    internal static MeExpressionSyntax MeExpression(KeywordSyntax keyword);
    internal static MyBaseExpressionSyntax MyBaseExpression(KeywordSyntax keyword);
    internal static MyClassExpressionSyntax MyClassExpression(KeywordSyntax keyword);
    internal static GetTypeExpressionSyntax GetTypeExpression(KeywordSyntax getTypeKeyword, PunctuationSyntax openParenToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal static TypeOfExpressionSyntax TypeOfIsExpression(KeywordSyntax typeOfKeyword, ExpressionSyntax expression, KeywordSyntax operatorToken, TypeSyntax type);
    internal static TypeOfExpressionSyntax TypeOfIsNotExpression(KeywordSyntax typeOfKeyword, ExpressionSyntax expression, KeywordSyntax operatorToken, TypeSyntax type);
    internal static TypeOfExpressionSyntax TypeOfExpression(SyntaxKind kind, KeywordSyntax typeOfKeyword, ExpressionSyntax expression, KeywordSyntax operatorToken, TypeSyntax type);
    internal static GetXmlNamespaceExpressionSyntax GetXmlNamespaceExpression(KeywordSyntax getXmlNamespaceKeyword, PunctuationSyntax openParenToken, XmlPrefixNameSyntax name, PunctuationSyntax closeParenToken);
    internal static MemberAccessExpressionSyntax SimpleMemberAccessExpression(ExpressionSyntax expression, PunctuationSyntax operatorToken, SimpleNameSyntax name);
    internal static MemberAccessExpressionSyntax DictionaryAccessExpression(ExpressionSyntax expression, PunctuationSyntax operatorToken, SimpleNameSyntax name);
    internal static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, PunctuationSyntax operatorToken, SimpleNameSyntax name);
    internal static XmlMemberAccessExpressionSyntax XmlElementAccessExpression(ExpressionSyntax base, PunctuationSyntax token1, PunctuationSyntax token2, PunctuationSyntax token3, XmlNodeSyntax name);
    internal static XmlMemberAccessExpressionSyntax XmlDescendantAccessExpression(ExpressionSyntax base, PunctuationSyntax token1, PunctuationSyntax token2, PunctuationSyntax token3, XmlNodeSyntax name);
    internal static XmlMemberAccessExpressionSyntax XmlAttributeAccessExpression(ExpressionSyntax base, PunctuationSyntax token1, PunctuationSyntax token2, PunctuationSyntax token3, XmlNodeSyntax name);
    internal static XmlMemberAccessExpressionSyntax XmlMemberAccessExpression(SyntaxKind kind, ExpressionSyntax base, PunctuationSyntax token1, PunctuationSyntax token2, PunctuationSyntax token3, XmlNodeSyntax name);
    internal static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList);
    internal static ObjectCreationExpressionSyntax ObjectCreationExpression(KeywordSyntax newKeyword, SyntaxList`1<VisualBasicSyntaxNode> attributeLists, TypeSyntax type, ArgumentListSyntax argumentList, ObjectCreationInitializerSyntax initializer);
    internal static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(KeywordSyntax newKeyword, SyntaxList`1<VisualBasicSyntaxNode> attributeLists, ObjectMemberInitializerSyntax initializer);
    internal static ArrayCreationExpressionSyntax ArrayCreationExpression(KeywordSyntax newKeyword, SyntaxList`1<VisualBasicSyntaxNode> attributeLists, TypeSyntax type, ArgumentListSyntax arrayBounds, SyntaxList`1<VisualBasicSyntaxNode> rankSpecifiers, CollectionInitializerSyntax initializer);
    internal static CollectionInitializerSyntax CollectionInitializer(PunctuationSyntax openBraceToken, SeparatedSyntaxList`1<ExpressionSyntax> initializers, PunctuationSyntax closeBraceToken);
    internal static CTypeExpressionSyntax CTypeExpression(KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal static DirectCastExpressionSyntax DirectCastExpression(KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal static TryCastExpressionSyntax TryCastExpression(KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal static PredefinedCastExpressionSyntax PredefinedCastExpression(KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax closeParenToken);
    internal static BinaryExpressionSyntax AddExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax SubtractExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax MultiplyExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax DivideExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax IntegerDivideExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax ExponentiateExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax LeftShiftExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax RightShiftExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax ConcatenateExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax ModuloExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax EqualsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax NotEqualsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax LessThanExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax LessThanOrEqualExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax GreaterThanOrEqualExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax GreaterThanExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax IsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax IsNotExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax LikeExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax OrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax ExclusiveOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax AndExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax OrElseExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax AndAlsoExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    internal static UnaryExpressionSyntax UnaryPlusExpression(SyntaxToken operatorToken, ExpressionSyntax operand);
    internal static UnaryExpressionSyntax UnaryMinusExpression(SyntaxToken operatorToken, ExpressionSyntax operand);
    internal static UnaryExpressionSyntax NotExpression(SyntaxToken operatorToken, ExpressionSyntax operand);
    internal static UnaryExpressionSyntax AddressOfExpression(SyntaxToken operatorToken, ExpressionSyntax operand);
    internal static UnaryExpressionSyntax UnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand);
    internal static BinaryConditionalExpressionSyntax BinaryConditionalExpression(KeywordSyntax ifKeyword, PunctuationSyntax openParenToken, ExpressionSyntax firstExpression, PunctuationSyntax commaToken, ExpressionSyntax secondExpression, PunctuationSyntax closeParenToken);
    internal static TernaryConditionalExpressionSyntax TernaryConditionalExpression(KeywordSyntax ifKeyword, PunctuationSyntax openParenToken, ExpressionSyntax condition, PunctuationSyntax firstCommaToken, ExpressionSyntax whenTrue, PunctuationSyntax secondCommaToken, ExpressionSyntax whenFalse, PunctuationSyntax closeParenToken);
    internal static SingleLineLambdaExpressionSyntax SingleLineFunctionLambdaExpression(LambdaHeaderSyntax subOrFunctionHeader, VisualBasicSyntaxNode body);
    internal static SingleLineLambdaExpressionSyntax SingleLineSubLambdaExpression(LambdaHeaderSyntax subOrFunctionHeader, VisualBasicSyntaxNode body);
    internal static SingleLineLambdaExpressionSyntax SingleLineLambdaExpression(SyntaxKind kind, LambdaHeaderSyntax subOrFunctionHeader, VisualBasicSyntaxNode body);
    internal static MultiLineLambdaExpressionSyntax MultiLineFunctionLambdaExpression(LambdaHeaderSyntax subOrFunctionHeader, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    internal static MultiLineLambdaExpressionSyntax MultiLineSubLambdaExpression(LambdaHeaderSyntax subOrFunctionHeader, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    internal static MultiLineLambdaExpressionSyntax MultiLineLambdaExpression(SyntaxKind kind, LambdaHeaderSyntax subOrFunctionHeader, SyntaxList`1<VisualBasicSyntaxNode> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    internal static LambdaHeaderSyntax SubLambdaHeader(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax subOrFunctionKeyword, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal static LambdaHeaderSyntax FunctionLambdaHeader(SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax subOrFunctionKeyword, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal static LambdaHeaderSyntax LambdaHeader(SyntaxKind kind, SyntaxList`1<VisualBasicSyntaxNode> attributeLists, SyntaxList`1<VisualBasicSyntaxNode> modifiers, KeywordSyntax subOrFunctionKeyword, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    internal static ArgumentListSyntax ArgumentList(PunctuationSyntax openParenToken, SeparatedSyntaxList`1<ArgumentSyntax> arguments, PunctuationSyntax closeParenToken);
    internal static OmittedArgumentSyntax OmittedArgument(PunctuationSyntax empty);
    internal static SimpleArgumentSyntax SimpleArgument(NameColonEqualsSyntax nameColonEquals, ExpressionSyntax expression);
    internal static NameColonEqualsSyntax NameColonEquals(IdentifierNameSyntax name, PunctuationSyntax colonEqualsToken);
    internal static RangeArgumentSyntax RangeArgument(ExpressionSyntax lowerBound, KeywordSyntax toKeyword, ExpressionSyntax upperBound);
    internal static QueryExpressionSyntax QueryExpression(SyntaxList`1<VisualBasicSyntaxNode> clauses);
    internal static CollectionRangeVariableSyntax CollectionRangeVariable(ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, KeywordSyntax inKeyword, ExpressionSyntax expression);
    internal static ExpressionRangeVariableSyntax ExpressionRangeVariable(VariableNameEqualsSyntax nameEquals, ExpressionSyntax expression);
    internal static AggregationRangeVariableSyntax AggregationRangeVariable(VariableNameEqualsSyntax nameEquals, AggregationSyntax aggregation);
    internal static VariableNameEqualsSyntax VariableNameEquals(ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, PunctuationSyntax equalsToken);
    internal static FunctionAggregationSyntax FunctionAggregation(IdentifierTokenSyntax functionName, PunctuationSyntax openParenToken, ExpressionSyntax argument, PunctuationSyntax closeParenToken);
    internal static GroupAggregationSyntax GroupAggregation(KeywordSyntax groupKeyword);
    internal static FromClauseSyntax FromClause(KeywordSyntax fromKeyword, SeparatedSyntaxList`1<CollectionRangeVariableSyntax> variables);
    internal static LetClauseSyntax LetClause(KeywordSyntax letKeyword, SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> variables);
    internal static AggregateClauseSyntax AggregateClause(KeywordSyntax aggregateKeyword, SeparatedSyntaxList`1<CollectionRangeVariableSyntax> variables, SyntaxList`1<VisualBasicSyntaxNode> additionalQueryOperators, KeywordSyntax intoKeyword, SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
    internal static DistinctClauseSyntax DistinctClause(KeywordSyntax distinctKeyword);
    internal static WhereClauseSyntax WhereClause(KeywordSyntax whereKeyword, ExpressionSyntax condition);
    internal static PartitionWhileClauseSyntax SkipWhileClause(KeywordSyntax skipOrTakeKeyword, KeywordSyntax whileKeyword, ExpressionSyntax condition);
    internal static PartitionWhileClauseSyntax TakeWhileClause(KeywordSyntax skipOrTakeKeyword, KeywordSyntax whileKeyword, ExpressionSyntax condition);
    internal static PartitionWhileClauseSyntax PartitionWhileClause(SyntaxKind kind, KeywordSyntax skipOrTakeKeyword, KeywordSyntax whileKeyword, ExpressionSyntax condition);
    internal static PartitionClauseSyntax SkipClause(KeywordSyntax skipOrTakeKeyword, ExpressionSyntax count);
    internal static PartitionClauseSyntax TakeClause(KeywordSyntax skipOrTakeKeyword, ExpressionSyntax count);
    internal static PartitionClauseSyntax PartitionClause(SyntaxKind kind, KeywordSyntax skipOrTakeKeyword, ExpressionSyntax count);
    internal static GroupByClauseSyntax GroupByClause(KeywordSyntax groupKeyword, SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> items, KeywordSyntax byKeyword, SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> keys, KeywordSyntax intoKeyword, SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
    internal static JoinConditionSyntax JoinCondition(ExpressionSyntax left, KeywordSyntax equalsKeyword, ExpressionSyntax right);
    internal static SimpleJoinClauseSyntax SimpleJoinClause(KeywordSyntax joinKeyword, SeparatedSyntaxList`1<CollectionRangeVariableSyntax> joinedVariables, SyntaxList`1<VisualBasicSyntaxNode> additionalJoins, KeywordSyntax onKeyword, SeparatedSyntaxList`1<JoinConditionSyntax> joinConditions);
    internal static GroupJoinClauseSyntax GroupJoinClause(KeywordSyntax groupKeyword, KeywordSyntax joinKeyword, SeparatedSyntaxList`1<CollectionRangeVariableSyntax> joinedVariables, SyntaxList`1<VisualBasicSyntaxNode> additionalJoins, KeywordSyntax onKeyword, SeparatedSyntaxList`1<JoinConditionSyntax> joinConditions, KeywordSyntax intoKeyword, SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
    internal static OrderByClauseSyntax OrderByClause(KeywordSyntax orderKeyword, KeywordSyntax byKeyword, SeparatedSyntaxList`1<OrderingSyntax> orderings);
    internal static OrderingSyntax AscendingOrdering(ExpressionSyntax expression, KeywordSyntax ascendingOrDescendingKeyword);
    internal static OrderingSyntax DescendingOrdering(ExpressionSyntax expression, KeywordSyntax ascendingOrDescendingKeyword);
    internal static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, KeywordSyntax ascendingOrDescendingKeyword);
    internal static SelectClauseSyntax SelectClause(KeywordSyntax selectKeyword, SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> variables);
    internal static XmlDocumentSyntax XmlDocument(XmlDeclarationSyntax declaration, SyntaxList`1<VisualBasicSyntaxNode> precedingMisc, XmlNodeSyntax root, SyntaxList`1<VisualBasicSyntaxNode> followingMisc);
    internal static XmlDeclarationSyntax XmlDeclaration(PunctuationSyntax lessThanQuestionToken, KeywordSyntax xmlKeyword, XmlDeclarationOptionSyntax version, XmlDeclarationOptionSyntax encoding, XmlDeclarationOptionSyntax standalone, PunctuationSyntax questionGreaterThanToken);
    internal static XmlDeclarationOptionSyntax XmlDeclarationOption(XmlNameTokenSyntax name, PunctuationSyntax equals, XmlStringSyntax value);
    internal static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, SyntaxList`1<VisualBasicSyntaxNode> content, XmlElementEndTagSyntax endTag);
    internal static XmlTextSyntax XmlText(SyntaxList`1<VisualBasicSyntaxNode> textTokens);
    internal static XmlElementStartTagSyntax XmlElementStartTag(PunctuationSyntax lessThanToken, XmlNodeSyntax name, SyntaxList`1<VisualBasicSyntaxNode> attributes, PunctuationSyntax greaterThanToken);
    internal static XmlElementEndTagSyntax XmlElementEndTag(PunctuationSyntax lessThanSlashToken, XmlNameSyntax name, PunctuationSyntax greaterThanToken);
    internal static XmlEmptyElementSyntax XmlEmptyElement(PunctuationSyntax lessThanToken, XmlNodeSyntax name, SyntaxList`1<VisualBasicSyntaxNode> attributes, PunctuationSyntax slashGreaterThanToken);
    internal static XmlAttributeSyntax XmlAttribute(XmlNodeSyntax name, PunctuationSyntax equalsToken, XmlNodeSyntax value);
    internal static XmlStringSyntax XmlString(PunctuationSyntax startQuoteToken, SyntaxList`1<VisualBasicSyntaxNode> textTokens, PunctuationSyntax endQuoteToken);
    internal static XmlPrefixNameSyntax XmlPrefixName(XmlNameTokenSyntax name);
    internal static XmlNameSyntax XmlName(XmlPrefixSyntax prefix, XmlNameTokenSyntax localName);
    internal static XmlBracketedNameSyntax XmlBracketedName(PunctuationSyntax lessThanToken, XmlNameSyntax name, PunctuationSyntax greaterThanToken);
    internal static XmlPrefixSyntax XmlPrefix(XmlNameTokenSyntax name, PunctuationSyntax colonToken);
    internal static XmlCommentSyntax XmlComment(PunctuationSyntax lessThanExclamationMinusMinusToken, SyntaxList`1<VisualBasicSyntaxNode> textTokens, PunctuationSyntax minusMinusGreaterThanToken);
    internal static XmlProcessingInstructionSyntax XmlProcessingInstruction(PunctuationSyntax lessThanQuestionToken, XmlNameTokenSyntax name, SyntaxList`1<VisualBasicSyntaxNode> textTokens, PunctuationSyntax questionGreaterThanToken);
    internal static XmlCDataSectionSyntax XmlCDataSection(PunctuationSyntax beginCDataToken, SyntaxList`1<VisualBasicSyntaxNode> textTokens, PunctuationSyntax endCDataToken);
    internal static XmlEmbeddedExpressionSyntax XmlEmbeddedExpression(PunctuationSyntax lessThanPercentEqualsToken, ExpressionSyntax expression, PunctuationSyntax percentGreaterThanToken);
    internal static ArrayTypeSyntax ArrayType(TypeSyntax elementType, SyntaxList`1<VisualBasicSyntaxNode> rankSpecifiers);
    internal static NullableTypeSyntax NullableType(TypeSyntax elementType, PunctuationSyntax questionMarkToken);
    internal static PredefinedTypeSyntax PredefinedType(KeywordSyntax keyword);
    internal static IdentifierNameSyntax IdentifierName(IdentifierTokenSyntax identifier);
    internal static GenericNameSyntax GenericName(IdentifierTokenSyntax identifier, TypeArgumentListSyntax typeArgumentList);
    internal static QualifiedNameSyntax QualifiedName(NameSyntax left, PunctuationSyntax dotToken, SimpleNameSyntax right);
    internal static GlobalNameSyntax GlobalName(KeywordSyntax globalKeyword);
    internal static TypeArgumentListSyntax TypeArgumentList(PunctuationSyntax openParenToken, KeywordSyntax ofKeyword, SeparatedSyntaxList`1<TypeSyntax> arguments, PunctuationSyntax closeParenToken);
    internal static CrefReferenceSyntax CrefReference(TypeSyntax name, CrefSignatureSyntax signature, SimpleAsClauseSyntax asClause);
    internal static CrefSignatureSyntax CrefSignature(PunctuationSyntax openParenToken, SeparatedSyntaxList`1<CrefSignaturePartSyntax> argumentTypes, PunctuationSyntax closeParenToken);
    internal static CrefSignaturePartSyntax CrefSignaturePart(KeywordSyntax modifier, TypeSyntax type);
    internal static CrefOperatorReferenceSyntax CrefOperatorReference(KeywordSyntax operatorKeyword, SyntaxToken operatorToken);
    internal static QualifiedCrefOperatorReferenceSyntax QualifiedCrefOperatorReference(NameSyntax left, PunctuationSyntax dotToken, CrefOperatorReferenceSyntax right);
    internal static YieldStatementSyntax YieldStatement(KeywordSyntax yieldKeyword, ExpressionSyntax expression);
    internal static AwaitExpressionSyntax AwaitExpression(KeywordSyntax awaitKeyword, ExpressionSyntax expression);
    internal static XmlNameTokenSyntax XmlNameToken(string text, SyntaxKind possibleKeywordKind, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal static XmlTextTokenSyntax XmlTextLiteralToken(string text, string value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal static XmlTextTokenSyntax XmlEntityLiteralToken(string text, string value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal static XmlTextTokenSyntax DocumentationCommentLineBreakToken(string text, string value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal static XmlTextTokenSyntax XmlTextToken(SyntaxKind kind, string text, string value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal static InterpolatedStringTextTokenSyntax InterpolatedStringTextToken(string text, string value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal static DecimalLiteralTokenSyntax DecimalLiteralToken(string text, TypeCharacter typeSuffix, decimal value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal static DateLiteralTokenSyntax DateLiteralToken(string text, DateTime value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal static StringLiteralTokenSyntax StringLiteralToken(string text, string value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal static CharacterLiteralTokenSyntax CharacterLiteralToken(string text, char value, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia);
    internal static SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxList`1<VisualBasicSyntaxNode> tokens);
    internal static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxList`1<VisualBasicSyntaxNode> content);
    internal static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, PunctuationSyntax equalsToken, PunctuationSyntax startQuoteToken, CrefReferenceSyntax reference, PunctuationSyntax endQuoteToken);
    internal static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, PunctuationSyntax equalsToken, PunctuationSyntax startQuoteToken, IdentifierNameSyntax reference, PunctuationSyntax endQuoteToken);
    internal static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, PunctuationSyntax questionMarkToken, ExpressionSyntax whenNotNull);
    internal static NameOfExpressionSyntax NameOfExpression(KeywordSyntax nameOfKeyword, PunctuationSyntax openParenToken, ExpressionSyntax argument, PunctuationSyntax closeParenToken);
    internal static InterpolatedStringExpressionSyntax InterpolatedStringExpression(PunctuationSyntax dollarSignDoubleQuoteToken, SyntaxList`1<VisualBasicSyntaxNode> contents, PunctuationSyntax doubleQuoteToken);
    internal static InterpolatedStringTextSyntax InterpolatedStringText(InterpolatedStringTextTokenSyntax textToken);
    internal static InterpolationSyntax Interpolation(PunctuationSyntax openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, PunctuationSyntax closeBraceToken);
    internal static InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(PunctuationSyntax commaToken, ExpressionSyntax value);
    internal static InterpolationFormatClauseSyntax InterpolationFormatClause(PunctuationSyntax colonToken, InterpolatedStringTextTokenSyntax formatStringToken);
    internal static SyntaxTrivia WhitespaceTrivia(string text);
    internal static SyntaxTrivia EndOfLineTrivia(string text);
    internal static SyntaxTrivia ColonTrivia(string text);
    internal static SyntaxTrivia CommentTrivia(string text);
    internal static SyntaxTrivia LineContinuationTrivia(string text);
    internal static SyntaxTrivia DocumentationCommentExteriorTrivia(string text);
    internal static SyntaxTrivia DisabledTextTrivia(string text);
    internal static SyntaxTrivia SyntaxTrivia(SyntaxKind kind, string text);
    internal static ConstDirectiveTriviaSyntax ConstDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax constKeyword, IdentifierTokenSyntax name, PunctuationSyntax equalsToken, ExpressionSyntax value);
    internal static IfDirectiveTriviaSyntax IfDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax elseKeyword, KeywordSyntax ifOrElseIfKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    internal static IfDirectiveTriviaSyntax ElseIfDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax elseKeyword, KeywordSyntax ifOrElseIfKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword);
    internal static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax elseKeyword);
    internal static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax endKeyword, KeywordSyntax ifKeyword);
    internal static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax regionKeyword, StringLiteralTokenSyntax name);
    internal static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax endKeyword, KeywordSyntax regionKeyword);
    internal static ExternalSourceDirectiveTriviaSyntax ExternalSourceDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax externalSourceKeyword, PunctuationSyntax openParenToken, StringLiteralTokenSyntax externalSource, PunctuationSyntax commaToken, IntegerLiteralTokenSyntax lineStart, PunctuationSyntax closeParenToken);
    internal static EndExternalSourceDirectiveTriviaSyntax EndExternalSourceDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax endKeyword, KeywordSyntax externalSourceKeyword);
    internal static ExternalChecksumDirectiveTriviaSyntax ExternalChecksumDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax externalChecksumKeyword, PunctuationSyntax openParenToken, StringLiteralTokenSyntax externalSource, PunctuationSyntax firstCommaToken, StringLiteralTokenSyntax guid, PunctuationSyntax secondCommaToken, StringLiteralTokenSyntax checksum, PunctuationSyntax closeParenToken);
    internal static EnableWarningDirectiveTriviaSyntax EnableWarningDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax enableKeyword, KeywordSyntax warningKeyword, SeparatedSyntaxList`1<IdentifierNameSyntax> errorCodes);
    internal static DisableWarningDirectiveTriviaSyntax DisableWarningDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax disableKeyword, KeywordSyntax warningKeyword, SeparatedSyntaxList`1<IdentifierNameSyntax> errorCodes);
    internal static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(PunctuationSyntax hashToken, KeywordSyntax referenceKeyword, StringLiteralTokenSyntax file);
    internal static BadDirectiveTriviaSyntax BadDirectiveTrivia(PunctuationSyntax hashToken);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList : VisualBasicSyntaxNode {
    protected SyntaxList(DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal SyntaxList(ObjectReader reader);
    internal static VisualBasicSyntaxNode List(VisualBasicSyntaxNode child);
    internal static WithTwoChildren List(VisualBasicSyntaxNode child0, VisualBasicSyntaxNode child1);
    internal static WithThreeChildren List(VisualBasicSyntaxNode child0, VisualBasicSyntaxNode child1, VisualBasicSyntaxNode child2);
    internal static SyntaxList List(ArrayElement`1[] nodes);
    internal static SyntaxList List(VisualBasicSyntaxNode[] nodes);
    internal static SyntaxList List(VisualBasicSyntaxNode[] nodes, int count);
    internal abstract virtual void CopyTo(ArrayElement`1[] array, int offset);
    internal static VisualBasicSyntaxNode Concat(VisualBasicSyntaxNode left, VisualBasicSyntaxNode right);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxList`1 : ValueType {
    private GreenNode _node;
    internal VisualBasicSyntaxNode Node { get; }
    public int Count { get; }
    public TNode Last { get; }
    public TNode Item { get; }
    internal GreenNode ItemUntyped { get; }
    internal TNode[] Nodes { get; }
    internal SyntaxList`1(GreenNode node);
    internal VisualBasicSyntaxNode get_Node();
    public int get_Count();
    public TNode get_Last();
    public TNode get_Item(int index);
    internal GreenNode get_ItemUntyped(int index);
    public bool Any();
    public bool Any(SyntaxKind kind);
    internal TNode[] get_Nodes();
    public static bool op_Equality(SyntaxList`1<TNode> left, SyntaxList`1<TNode> right);
    public static bool op_Inequality(SyntaxList`1<TNode> left, SyntaxList`1<TNode> right);
    public virtual bool Equals(object obj);
    public sealed virtual override bool Equals(SyntaxList`1<TNode> other);
    public virtual int GetHashCode();
    internal SeparatedSyntaxList`1<TOther> AsSeparatedList();
    public static SyntaxList`1<TNode> op_Implicit(TNode node);
    public static SyntaxList`1<VisualBasicSyntaxNode> op_Implicit(SyntaxList`1<TNode> nodes);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxListBuilder : object {
    private int _count;
    private ArrayElement`1[] _nodes;
    public int Count { get; }
    public VisualBasicSyntaxNode Item { get; public set; }
    public SyntaxListBuilder(int size);
    public static SyntaxListBuilder Create();
    public SyntaxListBuilder Add(VisualBasicSyntaxNode item);
    private SyntaxListBuilder AddUnsafe(GreenNode item);
    public SyntaxListBuilder AddRange(SyntaxList`1<TNode> list);
    public SyntaxListBuilder AddRange(SyntaxList`1<TNode> list, int offset, int length);
    public bool Any(SyntaxKind kind);
    internal void RemoveLast();
    public void Clear();
    private void EnsureAdditionalCapacity(int additionalCount);
    internal ArrayElement`1[] ToArray();
    internal VisualBasicSyntaxNode ToListNode();
    [ConditionalAttribute("DEBUG")]
private void Validate(int start, int end);
    public int get_Count();
    public VisualBasicSyntaxNode get_Item(int index);
    public void set_Item(int index, VisualBasicSyntaxNode value);
    public SyntaxList`1<VisualBasicSyntaxNode> ToList();
    public SyntaxList`1<TDerived> ToList();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxListBuilder`1 : ValueType {
    private SyntaxListBuilder _builder;
    public bool IsNull { get; }
    public int Count { get; }
    public TNode Item { get; public set; }
    public SyntaxListBuilder`1(int size);
    internal SyntaxListBuilder`1(SyntaxListBuilder builder);
    public static SyntaxListBuilder`1<TNode> Create();
    public bool get_IsNull();
    public int get_Count();
    public TNode get_Item(int index);
    public void set_Item(int index, TNode value);
    internal void RemoveLast();
    public void Clear();
    public void Add(TNode node);
    public void AddRange(SyntaxList`1<TNode> nodes);
    public void AddRange(SyntaxList`1<TNode> nodes, int offset, int length);
    public bool Any(SyntaxKind kind);
    public SyntaxList`1<TNode> ToList();
    public SyntaxList`1<TDerivedNode> ToList();
    public static SyntaxListBuilder op_Implicit(SyntaxListBuilder`1<TNode> builder);
    public static SyntaxList`1<TNode> op_Implicit(SyntaxListBuilder`1<TNode> builder);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxListPool : object {
    private Stack`1<SyntaxListBuilder> _freeList;
    internal SyntaxListBuilder Allocate();
    internal SyntaxListBuilder`1<TNode> Allocate();
    internal SeparatedSyntaxListBuilder`1<TNode> AllocateSeparated();
    internal void Free(SyntaxListBuilder item);
    internal SyntaxList`1<TNode> ToListAndFree(SyntaxListBuilder`1<TNode> item);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxNodeCache : object {
    private static int s_cacheSizeBits;
    private static int s_cacheSize;
    private static int s_cacheMask;
    private static Entry[] s_cache;
    private static SyntaxNodeCache();
    internal static void AddNode(GreenNode node, int hash);
    private static bool CanBeCached(GreenNode child1);
    private static bool CanBeCached(GreenNode child1, GreenNode child2);
    private static bool CanBeCached(GreenNode child1, GreenNode child2, GreenNode child3);
    private static bool ChildInCache(GreenNode child);
    private static bool AllChildrenInCache(GreenNode node);
    internal static GreenNode TryGetNode(int kind, GreenNode child1, Int32& hash);
    internal static GreenNode TryGetNode(int kind, ISyntaxFactoryContext context, GreenNode child1, Int32& hash);
    private static GreenNode TryGetNode(int kind, GreenNode child1, NodeFlags flags, Int32& hash);
    internal static GreenNode TryGetNode(int kind, GreenNode child1, GreenNode child2, Int32& hash);
    internal static GreenNode TryGetNode(int kind, ISyntaxFactoryContext context, GreenNode child1, GreenNode child2, Int32& hash);
    private static GreenNode TryGetNode(int kind, GreenNode child1, GreenNode child2, NodeFlags flags, Int32& hash);
    internal static GreenNode TryGetNode(int kind, GreenNode child1, GreenNode child2, GreenNode child3, Int32& hash);
    internal static GreenNode TryGetNode(int kind, ISyntaxFactoryContext context, GreenNode child1, GreenNode child2, GreenNode child3, Int32& hash);
    private static GreenNode TryGetNode(int kind, GreenNode child1, GreenNode child2, GreenNode child3, NodeFlags flags, Int32& hash);
    private static NodeFlags GetFlags();
    private static NodeFlags GetFlags(ISyntaxFactoryContext context);
    private static int GetCacheHash(int kind, NodeFlags flags, GreenNode child1);
    private static int GetCacheHash(int kind, NodeFlags flags, GreenNode child1, GreenNode child2);
    private static int GetCacheHash(int kind, NodeFlags flags, GreenNode child1, GreenNode child2, GreenNode child3);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxNodeExtensions : object {
    private static bool IsMissingToken(SyntaxToken token);
    [ExtensionAttribute]
private static TSyntax AddLeadingTrivia(TSyntax node, SyntaxList`1<VisualBasicSyntaxNode> trivia);
    [ExtensionAttribute]
internal static TSyntax AddLeadingSyntax(TSyntax node, SyntaxList`1<SyntaxToken> unexpected, ERRID errorId);
    [ExtensionAttribute]
internal static TSyntax AddLeadingSyntax(TSyntax node, SyntaxToken unexpected, ERRID errorId);
    [ExtensionAttribute]
internal static TSyntax AddLeadingSyntax(TSyntax node, SyntaxList`1<SyntaxToken> unexpected);
    [ExtensionAttribute]
internal static TSyntax AddLeadingSyntax(TSyntax node, VisualBasicSyntaxNode unexpected, ERRID errorId);
    [ExtensionAttribute]
internal static TSyntax AddLeadingSyntax(TSyntax node, VisualBasicSyntaxNode unexpected);
    [ExtensionAttribute]
internal static TSyntax AddTrailingTrivia(TSyntax node, SyntaxList`1<VisualBasicSyntaxNode> trivia);
    [ExtensionAttribute]
internal static TSyntax AddTrailingSyntax(TSyntax node, SyntaxList`1<SyntaxToken> unexpected, ERRID errorId);
    [ExtensionAttribute]
internal static TSyntax AddTrailingSyntax(TSyntax node, SyntaxToken unexpected, ERRID errorId);
    [ExtensionAttribute]
internal static TSyntax AddTrailingSyntax(TSyntax node, SyntaxList`1<SyntaxToken> unexpected);
    [ExtensionAttribute]
internal static TSyntax AddTrailingSyntax(TSyntax node, SyntaxToken unexpected);
    [ExtensionAttribute]
internal static TSyntax AddTrailingSyntax(TSyntax node, VisualBasicSyntaxNode unexpected, ERRID errorId);
    [ExtensionAttribute]
internal static TSyntax AddTrailingSyntax(TSyntax node, VisualBasicSyntaxNode unexpected);
    [ExtensionAttribute]
internal static TSyntax AddError(TSyntax node, ERRID errorId);
    [ExtensionAttribute]
internal static SyntaxList`1<VisualBasicSyntaxNode> GetStartOfTrivia(SyntaxList`1<VisualBasicSyntaxNode> trivia);
    [ExtensionAttribute]
internal static SyntaxList`1<VisualBasicSyntaxNode> GetStartOfTrivia(SyntaxList`1<VisualBasicSyntaxNode> trivia, int indexOfEnd);
    [ExtensionAttribute]
internal static SyntaxList`1<VisualBasicSyntaxNode> GetEndOfTrivia(SyntaxList`1<VisualBasicSyntaxNode> trivia);
    [ExtensionAttribute]
internal static SyntaxList`1<VisualBasicSyntaxNode> GetEndOfTrivia(SyntaxList`1<VisualBasicSyntaxNode> trivia, int indexOfEnd);
    internal static int GetLengthOfCommonEnd(SyntaxList`1<VisualBasicSyntaxNode> trivia1, SyntaxList`1<VisualBasicSyntaxNode> trivia2);
    [ExtensionAttribute]
private static int GetIndexAfterLastSkippedToken(SyntaxList`1<VisualBasicSyntaxNode> trivia);
    [ExtensionAttribute]
private static int GetIndexOfEndOfTrivia(SyntaxList`1<VisualBasicSyntaxNode> trivia);
    private static bool TriviaListContainsStructuredTrivia(VisualBasicSyntaxNode triviaList);
    private static SyntaxList`1<VisualBasicSyntaxNode> CreateSkippedTrivia(VisualBasicSyntaxNode node, bool preserveDiagnostics, bool addDiagnosticToFirstTokenOnly, DiagnosticInfo addDiagnostic);
    [ExtensionAttribute]
internal static bool ContainsWhitespaceTrivia(VisualBasicSyntaxNode this);
    [ExtensionAttribute]
internal static bool ContainsCommentTrivia(VisualBasicSyntaxNode this);
    [ExtensionAttribute]
internal static SyntaxToken ExtractAnonymousTypeMemberName(ExpressionSyntax input, Boolean& isNameDictionaryAccess, Boolean& isRejectedXmlName);
    [ExtensionAttribute]
private static SyntaxToken ExtractAnonymousTypeMemberName(ArrayBuilder`1& conditionalAccessStack, ExpressionSyntax input, Boolean& isNameDictionaryAccess, Boolean& isRejectedXmlName);
    private static void ClearConditionalAccessStack(ArrayBuilder`1<ConditionalAccessExpressionSyntax> conditionalAccessStack);
    private static ExpressionSyntax PopAndGetConditionalAccessReceiver(ArrayBuilder`1<ConditionalAccessExpressionSyntax> conditionalAccessStack);
    internal static bool IsExecutableStatementOrItsPart(VisualBasicSyntaxNode node);
}
internal enum Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxSubKind : Enum {
    public int value__;
    public static SyntaxSubKind None;
    public static SyntaxSubKind BeginDocTypeToken;
    public static SyntaxSubKind LessThanExclamationToken;
    public static SyntaxSubKind OpenBracketToken;
    public static SyntaxSubKind CloseBracketToken;
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxToken : VisualBasicSyntaxNode {
    private string _text;
    private object _trailingTriviaOrTriviaInfo;
    internal string Text { get; }
    private int _leadingTriviaWidth { get; }
    public bool IsToken { get; }
    internal bool IsKeyword { get; }
    internal object ObjectValue { get; }
    internal string ValueText { get; }
    internal bool IsEndOfLine { get; }
    internal bool IsEndOfParse { get; }
    protected SyntaxToken(SyntaxKind kind, string text, VisualBasicSyntaxNode precedingTrivia, VisualBasicSyntaxNode followingTrivia);
    protected SyntaxToken(SyntaxKind kind, DiagnosticInfo[] errors, string text, VisualBasicSyntaxNode precedingTrivia, VisualBasicSyntaxNode followingTrivia);
    protected SyntaxToken(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, string text, VisualBasicSyntaxNode precedingTrivia, VisualBasicSyntaxNode followingTrivia);
    internal SyntaxToken(ObjectReader reader);
    private void ClearFlagIfMissing();
    internal virtual void WriteTo(ObjectWriter writer);
    internal string get_Text();
    internal sealed virtual GreenNode GetSlot(int index);
    internal sealed virtual VisualBasicSyntaxNode GetLeadingTrivia();
    private int get__leadingTriviaWidth();
    public sealed virtual int GetLeadingTriviaWidth();
    internal sealed virtual VisualBasicSyntaxNode GetTrailingTrivia();
    public sealed virtual int GetTrailingTriviaWidth();
    internal sealed virtual void AddSyntaxErrors(List`1<DiagnosticInfo> accumulatedErrors);
    internal virtual void WriteToOrFlatten(TextWriter writer, ArrayBuilder`1<GreenNode> stack);
    internal sealed virtual void CollectConstituentTokensAndDiagnostics(SyntaxListBuilder`1<SyntaxToken> tokenListBuilder, IList`1<DiagnosticInfo> nonTokenDiagnostics);
    public sealed virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
    public virtual string ToString();
    public sealed virtual bool get_IsToken();
    internal virtual bool get_IsKeyword();
    internal virtual object get_ObjectValue();
    public virtual object GetValue();
    internal virtual string get_ValueText();
    public virtual string GetValueText();
    public bool IsBinaryOperator();
    internal bool get_IsEndOfLine();
    internal bool get_IsEndOfParse();
    public static T AddLeadingTrivia(T token, SyntaxList`1<VisualBasicSyntaxNode> newTrivia);
    public static T AddTrailingTrivia(T token, SyntaxList`1<VisualBasicSyntaxNode> newTrivia);
    internal static SyntaxToken Create(SyntaxKind kind, VisualBasicSyntaxNode leading, VisualBasicSyntaxNode trailing, string text);
    public static SyntaxToken op_Explicit(SyntaxToken token);
    public virtual bool IsEquivalentTo(GreenNode other);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.SyntaxTrivia : VisualBasicSyntaxNode {
    private string _text;
    internal string Text { get; }
    internal SyntaxTrivia(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, string text);
    internal SyntaxTrivia(SyntaxKind kind, string text, ISyntaxFactoryContext context);
    internal SyntaxTrivia(SyntaxKind kind, string text);
    internal SyntaxTrivia(ObjectReader reader);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual void WriteTo(ObjectWriter writer);
    internal string get_Text();
    internal sealed virtual GreenNode GetSlot(int index);
    internal sealed virtual VisualBasicSyntaxNode GetTrailingTrivia();
    public sealed virtual int GetTrailingTriviaWidth();
    internal sealed virtual VisualBasicSyntaxNode GetLeadingTrivia();
    public sealed virtual int GetLeadingTriviaWidth();
    internal virtual void WriteToOrFlatten(TextWriter writer, ArrayBuilder`1<GreenNode> stack);
    public sealed virtual string ToFullString();
    public virtual string ToString();
    internal sealed virtual void AddSyntaxErrors(List`1<DiagnosticInfo> accumulatedErrors);
    public sealed virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
    public static SyntaxTrivia op_Explicit(SyntaxTrivia trivia);
    public virtual bool IsEquivalentTo(GreenNode other);
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TernaryConditionalExpressionSyntax : ExpressionSyntax {
    internal KeywordSyntax _ifKeyword;
    internal PunctuationSyntax _openParenToken;
    internal ExpressionSyntax _condition;
    internal PunctuationSyntax _firstCommaToken;
    internal ExpressionSyntax _whenTrue;
    internal PunctuationSyntax _secondCommaToken;
    internal ExpressionSyntax _whenFalse;
    internal PunctuationSyntax _closeParenToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax IfKeyword { get; }
    internal PunctuationSyntax OpenParenToken { get; }
    internal ExpressionSyntax Condition { get; }
    internal PunctuationSyntax FirstCommaToken { get; }
    internal ExpressionSyntax WhenTrue { get; }
    internal PunctuationSyntax SecondCommaToken { get; }
    internal ExpressionSyntax WhenFalse { get; }
    internal PunctuationSyntax CloseParenToken { get; }
    private static TernaryConditionalExpressionSyntax();
    internal TernaryConditionalExpressionSyntax(SyntaxKind kind, KeywordSyntax ifKeyword, PunctuationSyntax openParenToken, ExpressionSyntax condition, PunctuationSyntax firstCommaToken, ExpressionSyntax whenTrue, PunctuationSyntax secondCommaToken, ExpressionSyntax whenFalse, PunctuationSyntax closeParenToken);
    internal TernaryConditionalExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax ifKeyword, PunctuationSyntax openParenToken, ExpressionSyntax condition, PunctuationSyntax firstCommaToken, ExpressionSyntax whenTrue, PunctuationSyntax secondCommaToken, ExpressionSyntax whenFalse, PunctuationSyntax closeParenToken);
    internal TernaryConditionalExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax ifKeyword, PunctuationSyntax openParenToken, ExpressionSyntax condition, PunctuationSyntax firstCommaToken, ExpressionSyntax whenTrue, PunctuationSyntax secondCommaToken, ExpressionSyntax whenFalse, PunctuationSyntax closeParenToken);
    internal TernaryConditionalExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_IfKeyword();
    internal PunctuationSyntax get_OpenParenToken();
    internal ExpressionSyntax get_Condition();
    internal PunctuationSyntax get_FirstCommaToken();
    internal ExpressionSyntax get_WhenTrue();
    internal PunctuationSyntax get_SecondCommaToken();
    internal ExpressionSyntax get_WhenFalse();
    internal PunctuationSyntax get_CloseParenToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.ThrowStatementSyntax : ExecutableStatementSyntax {
    internal KeywordSyntax _throwKeyword;
    internal ExpressionSyntax _expression;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax ThrowKeyword { get; }
    internal ExpressionSyntax Expression { get; }
    private static ThrowStatementSyntax();
    internal ThrowStatementSyntax(SyntaxKind kind, KeywordSyntax throwKeyword, ExpressionSyntax expression);
    internal ThrowStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax throwKeyword, ExpressionSyntax expression);
    internal ThrowStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax throwKeyword, ExpressionSyntax expression);
    internal ThrowStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_ThrowKeyword();
    internal ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TryBlockContext : ExecutableStatementContext {
    private SyntaxListBuilder`1<CatchBlockSyntax> _catchParts;
    private FinallyBlockSyntax _optionalFinallyPart;
    internal TryBlockContext(StatementSyntax statement, BlockContext prevContext);
    internal virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode node);
    internal virtual LinkResult TryLinkSyntax(VisualBasicSyntaxNode node, BlockContext& newContext);
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax endStmt);
    internal virtual BlockContext EndBlock(StatementSyntax statement);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TryBlockSyntax : ExecutableStatementSyntax {
    internal TryStatementSyntax _tryStatement;
    internal GreenNode _statements;
    internal GreenNode _catchBlocks;
    internal FinallyBlockSyntax _finallyBlock;
    internal EndBlockStatementSyntax _endTryStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal TryStatementSyntax TryStatement { get; }
    internal SyntaxList`1<StatementSyntax> Statements { get; }
    internal SyntaxList`1<CatchBlockSyntax> CatchBlocks { get; }
    internal FinallyBlockSyntax FinallyBlock { get; }
    internal EndBlockStatementSyntax EndTryStatement { get; }
    private static TryBlockSyntax();
    internal TryBlockSyntax(SyntaxKind kind, TryStatementSyntax tryStatement, GreenNode statements, GreenNode catchBlocks, FinallyBlockSyntax finallyBlock, EndBlockStatementSyntax endTryStatement);
    internal TryBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, TryStatementSyntax tryStatement, GreenNode statements, GreenNode catchBlocks, FinallyBlockSyntax finallyBlock, EndBlockStatementSyntax endTryStatement);
    internal TryBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, TryStatementSyntax tryStatement, GreenNode statements, GreenNode catchBlocks, FinallyBlockSyntax finallyBlock, EndBlockStatementSyntax endTryStatement);
    internal TryBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal TryStatementSyntax get_TryStatement();
    internal SyntaxList`1<StatementSyntax> get_Statements();
    internal SyntaxList`1<CatchBlockSyntax> get_CatchBlocks();
    internal FinallyBlockSyntax get_FinallyBlock();
    internal EndBlockStatementSyntax get_EndTryStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TryCastExpressionSyntax : CastExpressionSyntax {
    internal static Func`2<ObjectReader, object> CreateInstance;
    private static TryCastExpressionSyntax();
    internal TryCastExpressionSyntax(SyntaxKind kind, KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal TryCastExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal TryCastExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    internal TryCastExpressionSyntax(ObjectReader reader);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TryStatementSyntax : StatementSyntax {
    internal KeywordSyntax _tryKeyword;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax TryKeyword { get; }
    private static TryStatementSyntax();
    internal TryStatementSyntax(SyntaxKind kind, KeywordSyntax tryKeyword);
    internal TryStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax tryKeyword);
    internal TryStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax tryKeyword);
    internal TryStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_TryKeyword();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeArgumentListSyntax : VisualBasicSyntaxNode {
    internal PunctuationSyntax _openParenToken;
    internal KeywordSyntax _ofKeyword;
    internal GreenNode _arguments;
    internal PunctuationSyntax _closeParenToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax OpenParenToken { get; }
    internal KeywordSyntax OfKeyword { get; }
    internal SeparatedSyntaxList`1<TypeSyntax> Arguments { get; }
    internal PunctuationSyntax CloseParenToken { get; }
    private static TypeArgumentListSyntax();
    internal TypeArgumentListSyntax(SyntaxKind kind, PunctuationSyntax openParenToken, KeywordSyntax ofKeyword, GreenNode arguments, PunctuationSyntax closeParenToken);
    internal TypeArgumentListSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax openParenToken, KeywordSyntax ofKeyword, GreenNode arguments, PunctuationSyntax closeParenToken);
    internal TypeArgumentListSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax openParenToken, KeywordSyntax ofKeyword, GreenNode arguments, PunctuationSyntax closeParenToken);
    internal TypeArgumentListSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_OpenParenToken();
    internal KeywordSyntax get_OfKeyword();
    internal SeparatedSyntaxList`1<TypeSyntax> get_Arguments();
    internal PunctuationSyntax get_CloseParenToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeBlockContext : DeclarationContext {
    protected SyntaxList`1<InheritsStatementSyntax> _inheritsDecls;
    private SyntaxList`1<ImplementsStatementSyntax> _implementsDecls;
    protected SyntaxKind _state;
    internal TypeBlockContext(SyntaxKind contextKind, StatementSyntax statement, BlockContext prevContext);
    internal virtual BlockContext ProcessSyntax(VisualBasicSyntaxNode node);
    internal virtual VisualBasicSyntaxNode CreateBlockSyntax(StatementSyntax endStmt);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeBlockSyntax : DeclarationStatementSyntax {
    internal GreenNode _inherits;
    internal GreenNode _implements;
    internal GreenNode _members;
    public TypeStatementSyntax BlockStatement { get; }
    public EndBlockStatementSyntax EndBlockStatement { get; }
    internal SyntaxList`1<InheritsStatementSyntax> Inherits { get; }
    internal SyntaxList`1<ImplementsStatementSyntax> Implements { get; }
    internal SyntaxList`1<StatementSyntax> Members { get; }
    internal TypeBlockSyntax(SyntaxKind kind, GreenNode inherits, GreenNode implements, GreenNode members);
    internal TypeBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode inherits, GreenNode implements, GreenNode members);
    internal TypeBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode inherits, GreenNode implements, GreenNode members);
    internal TypeBlockSyntax(ObjectReader reader);
    public abstract virtual TypeStatementSyntax get_BlockStatement();
    public abstract virtual EndBlockStatementSyntax get_EndBlockStatement();
    internal virtual void WriteTo(ObjectWriter writer);
    internal SyntaxList`1<InheritsStatementSyntax> get_Inherits();
    internal SyntaxList`1<ImplementsStatementSyntax> get_Implements();
    internal SyntaxList`1<StatementSyntax> get_Members();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeConstraintSyntax : ConstraintSyntax {
    internal TypeSyntax _type;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal TypeSyntax Type { get; }
    private static TypeConstraintSyntax();
    internal TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type);
    internal TypeConstraintSyntax(SyntaxKind kind, ISyntaxFactoryContext context, TypeSyntax type);
    internal TypeConstraintSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, TypeSyntax type);
    internal TypeConstraintSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal TypeSyntax get_Type();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeHelpers : object {
    internal static long UncheckedCLng(CConst v);
    internal static bool VarDecAdd(decimal pdecLeft, decimal pdecRight, Decimal& pdecResult);
    internal static bool VarDecSub(decimal pdecLeft, decimal pdecRight, Decimal& pdecResult);
    internal static bool VarDecMul(decimal pdecLeft, decimal pdecRight, Decimal& pdecResult);
    internal static bool VarDecDiv(decimal pdecLeft, decimal pdecRight, Decimal& pdecResult);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeOfExpressionSyntax : ExpressionSyntax {
    internal KeywordSyntax _typeOfKeyword;
    internal ExpressionSyntax _expression;
    internal KeywordSyntax _operatorToken;
    internal TypeSyntax _type;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax TypeOfKeyword { get; }
    internal ExpressionSyntax Expression { get; }
    internal KeywordSyntax OperatorToken { get; }
    internal TypeSyntax Type { get; }
    private static TypeOfExpressionSyntax();
    internal TypeOfExpressionSyntax(SyntaxKind kind, KeywordSyntax typeOfKeyword, ExpressionSyntax expression, KeywordSyntax operatorToken, TypeSyntax type);
    internal TypeOfExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax typeOfKeyword, ExpressionSyntax expression, KeywordSyntax operatorToken, TypeSyntax type);
    internal TypeOfExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax typeOfKeyword, ExpressionSyntax expression, KeywordSyntax operatorToken, TypeSyntax type);
    internal TypeOfExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_TypeOfKeyword();
    internal ExpressionSyntax get_Expression();
    internal KeywordSyntax get_OperatorToken();
    internal TypeSyntax get_Type();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax : VisualBasicSyntaxNode {
    internal TypeParameterConstraintClauseSyntax(SyntaxKind kind);
    internal TypeParameterConstraintClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal TypeParameterConstraintClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal TypeParameterConstraintClauseSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterListSyntax : VisualBasicSyntaxNode {
    internal PunctuationSyntax _openParenToken;
    internal KeywordSyntax _ofKeyword;
    internal GreenNode _parameters;
    internal PunctuationSyntax _closeParenToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax OpenParenToken { get; }
    internal KeywordSyntax OfKeyword { get; }
    internal SeparatedSyntaxList`1<TypeParameterSyntax> Parameters { get; }
    internal PunctuationSyntax CloseParenToken { get; }
    private static TypeParameterListSyntax();
    internal TypeParameterListSyntax(SyntaxKind kind, PunctuationSyntax openParenToken, KeywordSyntax ofKeyword, GreenNode parameters, PunctuationSyntax closeParenToken);
    internal TypeParameterListSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax openParenToken, KeywordSyntax ofKeyword, GreenNode parameters, PunctuationSyntax closeParenToken);
    internal TypeParameterListSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax openParenToken, KeywordSyntax ofKeyword, GreenNode parameters, PunctuationSyntax closeParenToken);
    internal TypeParameterListSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_OpenParenToken();
    internal KeywordSyntax get_OfKeyword();
    internal SeparatedSyntaxList`1<TypeParameterSyntax> get_Parameters();
    internal PunctuationSyntax get_CloseParenToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterMultipleConstraintClauseSyntax : TypeParameterConstraintClauseSyntax {
    internal KeywordSyntax _asKeyword;
    internal PunctuationSyntax _openBraceToken;
    internal GreenNode _constraints;
    internal PunctuationSyntax _closeBraceToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax AsKeyword { get; }
    internal PunctuationSyntax OpenBraceToken { get; }
    internal SeparatedSyntaxList`1<ConstraintSyntax> Constraints { get; }
    internal PunctuationSyntax CloseBraceToken { get; }
    private static TypeParameterMultipleConstraintClauseSyntax();
    internal TypeParameterMultipleConstraintClauseSyntax(SyntaxKind kind, KeywordSyntax asKeyword, PunctuationSyntax openBraceToken, GreenNode constraints, PunctuationSyntax closeBraceToken);
    internal TypeParameterMultipleConstraintClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax asKeyword, PunctuationSyntax openBraceToken, GreenNode constraints, PunctuationSyntax closeBraceToken);
    internal TypeParameterMultipleConstraintClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax asKeyword, PunctuationSyntax openBraceToken, GreenNode constraints, PunctuationSyntax closeBraceToken);
    internal TypeParameterMultipleConstraintClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_AsKeyword();
    internal PunctuationSyntax get_OpenBraceToken();
    internal SeparatedSyntaxList`1<ConstraintSyntax> get_Constraints();
    internal PunctuationSyntax get_CloseBraceToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterSingleConstraintClauseSyntax : TypeParameterConstraintClauseSyntax {
    internal KeywordSyntax _asKeyword;
    internal ConstraintSyntax _constraint;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax AsKeyword { get; }
    internal ConstraintSyntax Constraint { get; }
    private static TypeParameterSingleConstraintClauseSyntax();
    internal TypeParameterSingleConstraintClauseSyntax(SyntaxKind kind, KeywordSyntax asKeyword, ConstraintSyntax constraint);
    internal TypeParameterSingleConstraintClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax asKeyword, ConstraintSyntax constraint);
    internal TypeParameterSingleConstraintClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax asKeyword, ConstraintSyntax constraint);
    internal TypeParameterSingleConstraintClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_AsKeyword();
    internal ConstraintSyntax get_Constraint();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeParameterSyntax : VisualBasicSyntaxNode {
    internal KeywordSyntax _varianceKeyword;
    internal IdentifierTokenSyntax _identifier;
    internal TypeParameterConstraintClauseSyntax _typeParameterConstraintClause;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax VarianceKeyword { get; }
    internal IdentifierTokenSyntax Identifier { get; }
    internal TypeParameterConstraintClauseSyntax TypeParameterConstraintClause { get; }
    private static TypeParameterSyntax();
    internal TypeParameterSyntax(SyntaxKind kind, KeywordSyntax varianceKeyword, IdentifierTokenSyntax identifier, TypeParameterConstraintClauseSyntax typeParameterConstraintClause);
    internal TypeParameterSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax varianceKeyword, IdentifierTokenSyntax identifier, TypeParameterConstraintClauseSyntax typeParameterConstraintClause);
    internal TypeParameterSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax varianceKeyword, IdentifierTokenSyntax identifier, TypeParameterConstraintClauseSyntax typeParameterConstraintClause);
    internal TypeParameterSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_VarianceKeyword();
    internal IdentifierTokenSyntax get_Identifier();
    internal TypeParameterConstraintClauseSyntax get_TypeParameterConstraintClause();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeStatementSyntax : DeclarationStatementSyntax {
    internal GreenNode _attributeLists;
    internal GreenNode _modifiers;
    internal IdentifierTokenSyntax _identifier;
    internal TypeParameterListSyntax _typeParameterList;
    internal SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    internal SyntaxList`1<KeywordSyntax> Modifiers { get; }
    internal IdentifierTokenSyntax Identifier { get; }
    internal TypeParameterListSyntax TypeParameterList { get; }
    internal TypeStatementSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal TypeStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode attributeLists, GreenNode modifiers, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal TypeStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode attributeLists, GreenNode modifiers, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    internal TypeStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal SyntaxList`1<KeywordSyntax> get_Modifiers();
    internal IdentifierTokenSyntax get_Identifier();
    internal TypeParameterListSyntax get_TypeParameterList();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.TypeSyntax : ExpressionSyntax {
    internal TypeSyntax(SyntaxKind kind);
    internal TypeSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal TypeSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal TypeSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.UnaryExpressionSyntax : ExpressionSyntax {
    internal SyntaxToken _operatorToken;
    internal ExpressionSyntax _operand;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxToken OperatorToken { get; }
    internal ExpressionSyntax Operand { get; }
    private static UnaryExpressionSyntax();
    internal UnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand);
    internal UnaryExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, SyntaxToken operatorToken, ExpressionSyntax operand);
    internal UnaryExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxToken operatorToken, ExpressionSyntax operand);
    internal UnaryExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SyntaxToken get_OperatorToken();
    internal ExpressionSyntax get_Operand();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.UsingBlockSyntax : ExecutableStatementSyntax {
    internal UsingStatementSyntax _usingStatement;
    internal GreenNode _statements;
    internal EndBlockStatementSyntax _endUsingStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal UsingStatementSyntax UsingStatement { get; }
    internal SyntaxList`1<StatementSyntax> Statements { get; }
    internal EndBlockStatementSyntax EndUsingStatement { get; }
    private static UsingBlockSyntax();
    internal UsingBlockSyntax(SyntaxKind kind, UsingStatementSyntax usingStatement, GreenNode statements, EndBlockStatementSyntax endUsingStatement);
    internal UsingBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, UsingStatementSyntax usingStatement, GreenNode statements, EndBlockStatementSyntax endUsingStatement);
    internal UsingBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, UsingStatementSyntax usingStatement, GreenNode statements, EndBlockStatementSyntax endUsingStatement);
    internal UsingBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal UsingStatementSyntax get_UsingStatement();
    internal SyntaxList`1<StatementSyntax> get_Statements();
    internal EndBlockStatementSyntax get_EndUsingStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.UsingStatementSyntax : StatementSyntax {
    internal KeywordSyntax _usingKeyword;
    internal ExpressionSyntax _expression;
    internal GreenNode _variables;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax UsingKeyword { get; }
    internal ExpressionSyntax Expression { get; }
    internal SeparatedSyntaxList`1<VariableDeclaratorSyntax> Variables { get; }
    private static UsingStatementSyntax();
    internal UsingStatementSyntax(SyntaxKind kind, KeywordSyntax usingKeyword, ExpressionSyntax expression, GreenNode variables);
    internal UsingStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax usingKeyword, ExpressionSyntax expression, GreenNode variables);
    internal UsingStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax usingKeyword, ExpressionSyntax expression, GreenNode variables);
    internal UsingStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_UsingKeyword();
    internal ExpressionSyntax get_Expression();
    internal SeparatedSyntaxList`1<VariableDeclaratorSyntax> get_Variables();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableDeclaratorSyntax : VisualBasicSyntaxNode {
    internal GreenNode _names;
    internal AsClauseSyntax _asClause;
    internal EqualsValueSyntax _initializer;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SeparatedSyntaxList`1<ModifiedIdentifierSyntax> Names { get; }
    internal AsClauseSyntax AsClause { get; }
    internal EqualsValueSyntax Initializer { get; }
    private static VariableDeclaratorSyntax();
    internal VariableDeclaratorSyntax(SyntaxKind kind, GreenNode names, AsClauseSyntax asClause, EqualsValueSyntax initializer);
    internal VariableDeclaratorSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode names, AsClauseSyntax asClause, EqualsValueSyntax initializer);
    internal VariableDeclaratorSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode names, AsClauseSyntax asClause, EqualsValueSyntax initializer);
    internal VariableDeclaratorSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SeparatedSyntaxList`1<ModifiedIdentifierSyntax> get_Names();
    internal AsClauseSyntax get_AsClause();
    internal EqualsValueSyntax get_Initializer();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VariableNameEqualsSyntax : VisualBasicSyntaxNode {
    internal ModifiedIdentifierSyntax _identifier;
    internal SimpleAsClauseSyntax _asClause;
    internal PunctuationSyntax _equalsToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ModifiedIdentifierSyntax Identifier { get; }
    internal SimpleAsClauseSyntax AsClause { get; }
    internal PunctuationSyntax EqualsToken { get; }
    private static VariableNameEqualsSyntax();
    internal VariableNameEqualsSyntax(SyntaxKind kind, ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, PunctuationSyntax equalsToken);
    internal VariableNameEqualsSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, PunctuationSyntax equalsToken);
    internal VariableNameEqualsSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, PunctuationSyntax equalsToken);
    internal VariableNameEqualsSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ModifiedIdentifierSyntax get_Identifier();
    internal SimpleAsClauseSyntax get_AsClause();
    internal PunctuationSyntax get_EqualsToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxNode : GreenNode {
    private static ConditionalWeakTable`2<SyntaxNode, Dictionary`2<SyntaxTrivia, SyntaxNode>> s_structuresTable;
    internal SyntaxKind Kind { get; }
    internal SyntaxKind ContextualKind { get; }
    public string KindText { get; }
    public string Language { get; }
    public bool IsStructuredTrivia { get; }
    public bool IsDirective { get; }
    protected int _slotCount { get; protected set; }
    public AbstractSyntaxNavigator Navigator { get; }
    private static VisualBasicSyntaxNode();
    internal VisualBasicSyntaxNode(ObjectReader reader);
    protected VisualBasicSyntaxNode(SyntaxKind kind);
    protected VisualBasicSyntaxNode(SyntaxKind kind, int width);
    protected VisualBasicSyntaxNode(SyntaxKind kind, DiagnosticInfo[] errors);
    protected VisualBasicSyntaxNode(SyntaxKind kind, DiagnosticInfo[] errors, int width);
    internal VisualBasicSyntaxNode(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal VisualBasicSyntaxNode(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations, int fullWidth);
    internal SyntaxKind get_Kind();
    internal SyntaxKind get_ContextualKind();
    public virtual string get_KindText();
    public virtual string get_Language();
    protected void SetFactoryContext(ISyntaxFactoryContext context);
    internal static NodeFlags SetFactoryContext(NodeFlags flags, ISyntaxFactoryContext context);
    internal bool MatchesFactoryContext(ISyntaxFactoryContext context);
    public virtual void WriteTo(TextWriter writer);
    protected virtual void WriteTo(TextWriter writer, bool leading, bool trailing);
    internal virtual void WriteToOrFlatten(TextWriter writer, ArrayBuilder`1<GreenNode> stack);
    internal virtual void CollectConstituentTokensAndDiagnostics(SyntaxListBuilder`1<SyntaxToken> tokenListBuilder, IList`1<DiagnosticInfo> nonTokenDiagnostics);
    public virtual string ToString();
    public virtual string ToFullString();
    public virtual bool get_IsStructuredTrivia();
    public virtual bool get_IsDirective();
    protected virtual int GetSlotCount();
    protected int get__slotCount();
    protected void set__slotCount(int value);
    internal SyntaxToken GetFirstToken();
    internal SyntaxToken GetLastToken();
    internal virtual VisualBasicSyntaxNode GetLeadingTrivia();
    public virtual GreenNode GetLeadingTriviaCore();
    internal virtual VisualBasicSyntaxNode GetTrailingTrivia();
    public virtual GreenNode GetTrailingTriviaCore();
    internal VisualBasicSyntaxNode AddError(DiagnosticInfo err);
    internal virtual IList`1<DiagnosticInfo> GetSyntaxErrors();
    internal virtual void AddSyntaxErrors(List`1<DiagnosticInfo> accumulatedErrors);
    private string GetDebuggerDisplay();
    internal static bool IsEquivalentTo(VisualBasicSyntaxNode left, VisualBasicSyntaxNode right);
    public virtual bool IsEquivalentTo(GreenNode other);
    private static bool EquivalentToInternal(GreenNode node1, GreenNode node2);
    public virtual int GetSlotOffset(int index);
    internal ChildSyntaxList ChildNodesAndTokens();
    public virtual SyntaxNode GetStructure(SyntaxTrivia trivia);
    public virtual AbstractSyntaxNavigator get_Navigator();
    public virtual GreenNode CreateList(IEnumerable`1<GreenNode> nodes, bool alwaysCreateListNode);
    public virtual SyntaxToken CreateSeparator(SyntaxNode element);
    public virtual bool IsTriviaWithEndOfLine();
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxRewriter : VisualBasicSyntaxVisitor {
    public SyntaxList`1<TNode> VisitList(SyntaxList`1<TNode> list);
    public SeparatedSyntaxList`1<TNode> VisitList(SeparatedSyntaxList`1<TNode> list);
    public virtual VisualBasicSyntaxNode VisitEmptyStatement(EmptyStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitEndBlockStatement(EndBlockStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitCompilationUnit(CompilationUnitSyntax node);
    public virtual VisualBasicSyntaxNode VisitOptionStatement(OptionStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitImportsStatement(ImportsStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitSimpleImportsClause(SimpleImportsClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitImportAliasClause(ImportAliasClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlNamespaceImportsClause(XmlNamespaceImportsClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitNamespaceBlock(NamespaceBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitNamespaceStatement(NamespaceStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitModuleBlock(ModuleBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitStructureBlock(StructureBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitInterfaceBlock(InterfaceBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitClassBlock(ClassBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitEnumBlock(EnumBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitInheritsStatement(InheritsStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitImplementsStatement(ImplementsStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitModuleStatement(ModuleStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitStructureStatement(StructureStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitInterfaceStatement(InterfaceStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitClassStatement(ClassStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitEnumStatement(EnumStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitTypeParameterList(TypeParameterListSyntax node);
    public virtual VisualBasicSyntaxNode VisitTypeParameter(TypeParameterSyntax node);
    public virtual VisualBasicSyntaxNode VisitTypeParameterSingleConstraintClause(TypeParameterSingleConstraintClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitTypeParameterMultipleConstraintClause(TypeParameterMultipleConstraintClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitSpecialConstraint(SpecialConstraintSyntax node);
    public virtual VisualBasicSyntaxNode VisitTypeConstraint(TypeConstraintSyntax node);
    public virtual VisualBasicSyntaxNode VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node);
    public virtual VisualBasicSyntaxNode VisitMethodBlock(MethodBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitConstructorBlock(ConstructorBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitOperatorBlock(OperatorBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitAccessorBlock(AccessorBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitPropertyBlock(PropertyBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitEventBlock(EventBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitParameterList(ParameterListSyntax node);
    public virtual VisualBasicSyntaxNode VisitMethodStatement(MethodStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitSubNewStatement(SubNewStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitDeclareStatement(DeclareStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitDelegateStatement(DelegateStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitEventStatement(EventStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitOperatorStatement(OperatorStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitPropertyStatement(PropertyStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitAccessorStatement(AccessorStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitImplementsClause(ImplementsClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitHandlesClause(HandlesClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitKeywordEventContainer(KeywordEventContainerSyntax node);
    public virtual VisualBasicSyntaxNode VisitWithEventsEventContainer(WithEventsEventContainerSyntax node);
    public virtual VisualBasicSyntaxNode VisitWithEventsPropertyEventContainer(WithEventsPropertyEventContainerSyntax node);
    public virtual VisualBasicSyntaxNode VisitHandlesClauseItem(HandlesClauseItemSyntax node);
    public virtual VisualBasicSyntaxNode VisitIncompleteMember(IncompleteMemberSyntax node);
    public virtual VisualBasicSyntaxNode VisitFieldDeclaration(FieldDeclarationSyntax node);
    public virtual VisualBasicSyntaxNode VisitVariableDeclarator(VariableDeclaratorSyntax node);
    public virtual VisualBasicSyntaxNode VisitSimpleAsClause(SimpleAsClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitAsNewClause(AsNewClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitObjectMemberInitializer(ObjectMemberInitializerSyntax node);
    public virtual VisualBasicSyntaxNode VisitObjectCollectionInitializer(ObjectCollectionInitializerSyntax node);
    public virtual VisualBasicSyntaxNode VisitInferredFieldInitializer(InferredFieldInitializerSyntax node);
    public virtual VisualBasicSyntaxNode VisitNamedFieldInitializer(NamedFieldInitializerSyntax node);
    public virtual VisualBasicSyntaxNode VisitEqualsValue(EqualsValueSyntax node);
    public virtual VisualBasicSyntaxNode VisitParameter(ParameterSyntax node);
    public virtual VisualBasicSyntaxNode VisitModifiedIdentifier(ModifiedIdentifierSyntax node);
    public virtual VisualBasicSyntaxNode VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node);
    public virtual VisualBasicSyntaxNode VisitAttributeList(AttributeListSyntax node);
    public virtual VisualBasicSyntaxNode VisitAttribute(AttributeSyntax node);
    public virtual VisualBasicSyntaxNode VisitAttributeTarget(AttributeTargetSyntax node);
    public virtual VisualBasicSyntaxNode VisitAttributesStatement(AttributesStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitPrintStatement(PrintStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitWhileBlock(WhileBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitUsingBlock(UsingBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitSyncLockBlock(SyncLockBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitWithBlock(WithBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitLabelStatement(LabelStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitGoToStatement(GoToStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitLabel(LabelSyntax node);
    public virtual VisualBasicSyntaxNode VisitStopOrEndStatement(StopOrEndStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitExitStatement(ExitStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitContinueStatement(ContinueStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitReturnStatement(ReturnStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitSingleLineIfStatement(SingleLineIfStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitSingleLineElseClause(SingleLineElseClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitMultiLineIfBlock(MultiLineIfBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitIfStatement(IfStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitElseIfBlock(ElseIfBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitElseIfStatement(ElseIfStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitElseBlock(ElseBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitElseStatement(ElseStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitTryBlock(TryBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitTryStatement(TryStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitCatchBlock(CatchBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitCatchStatement(CatchStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitCatchFilterClause(CatchFilterClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitFinallyBlock(FinallyBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitFinallyStatement(FinallyStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitErrorStatement(ErrorStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitOnErrorGoToStatement(OnErrorGoToStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitOnErrorResumeNextStatement(OnErrorResumeNextStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitResumeStatement(ResumeStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitSelectBlock(SelectBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitSelectStatement(SelectStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitCaseBlock(CaseBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitCaseStatement(CaseStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitElseCaseClause(ElseCaseClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitSimpleCaseClause(SimpleCaseClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitRangeCaseClause(RangeCaseClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitRelationalCaseClause(RelationalCaseClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitSyncLockStatement(SyncLockStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitDoLoopBlock(DoLoopBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitDoStatement(DoStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitLoopStatement(LoopStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitWhileOrUntilClause(WhileOrUntilClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitWhileStatement(WhileStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitForBlock(ForBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitForEachBlock(ForEachBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitForStatement(ForStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitForStepClause(ForStepClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitForEachStatement(ForEachStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitNextStatement(NextStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitUsingStatement(UsingStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitThrowStatement(ThrowStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitAssignmentStatement(AssignmentStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitMidExpression(MidExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitCallStatement(CallStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitAddRemoveHandlerStatement(AddRemoveHandlerStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitRaiseEventStatement(RaiseEventStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitWithStatement(WithStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitReDimStatement(ReDimStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitRedimClause(RedimClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitEraseStatement(EraseStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitMeExpression(MeExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitMyBaseExpression(MyBaseExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitMyClassExpression(MyClassExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitGetTypeExpression(GetTypeExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitTypeOfExpression(TypeOfExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitGetXmlNamespaceExpression(GetXmlNamespaceExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlMemberAccessExpression(XmlMemberAccessExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitArrayCreationExpression(ArrayCreationExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitCollectionInitializer(CollectionInitializerSyntax node);
    public virtual VisualBasicSyntaxNode VisitCTypeExpression(CTypeExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitDirectCastExpression(DirectCastExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitTryCastExpression(TryCastExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitPredefinedCastExpression(PredefinedCastExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitUnaryExpression(UnaryExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitBinaryConditionalExpression(BinaryConditionalExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitTernaryConditionalExpression(TernaryConditionalExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitSingleLineLambdaExpression(SingleLineLambdaExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitMultiLineLambdaExpression(MultiLineLambdaExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitLambdaHeader(LambdaHeaderSyntax node);
    public virtual VisualBasicSyntaxNode VisitArgumentList(ArgumentListSyntax node);
    public virtual VisualBasicSyntaxNode VisitOmittedArgument(OmittedArgumentSyntax node);
    public virtual VisualBasicSyntaxNode VisitSimpleArgument(SimpleArgumentSyntax node);
    public virtual VisualBasicSyntaxNode VisitNameColonEquals(NameColonEqualsSyntax node);
    public virtual VisualBasicSyntaxNode VisitRangeArgument(RangeArgumentSyntax node);
    public virtual VisualBasicSyntaxNode VisitQueryExpression(QueryExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitCollectionRangeVariable(CollectionRangeVariableSyntax node);
    public virtual VisualBasicSyntaxNode VisitExpressionRangeVariable(ExpressionRangeVariableSyntax node);
    public virtual VisualBasicSyntaxNode VisitAggregationRangeVariable(AggregationRangeVariableSyntax node);
    public virtual VisualBasicSyntaxNode VisitVariableNameEquals(VariableNameEqualsSyntax node);
    public virtual VisualBasicSyntaxNode VisitFunctionAggregation(FunctionAggregationSyntax node);
    public virtual VisualBasicSyntaxNode VisitGroupAggregation(GroupAggregationSyntax node);
    public virtual VisualBasicSyntaxNode VisitFromClause(FromClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitLetClause(LetClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitAggregateClause(AggregateClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitDistinctClause(DistinctClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitWhereClause(WhereClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitPartitionWhileClause(PartitionWhileClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitPartitionClause(PartitionClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitGroupByClause(GroupByClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitJoinCondition(JoinConditionSyntax node);
    public virtual VisualBasicSyntaxNode VisitSimpleJoinClause(SimpleJoinClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitGroupJoinClause(GroupJoinClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitOrderByClause(OrderByClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitOrdering(OrderingSyntax node);
    public virtual VisualBasicSyntaxNode VisitSelectClause(SelectClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlDocument(XmlDocumentSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlDeclaration(XmlDeclarationSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlDeclarationOption(XmlDeclarationOptionSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlElement(XmlElementSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlText(XmlTextSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlElementStartTag(XmlElementStartTagSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlElementEndTag(XmlElementEndTagSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlEmptyElement(XmlEmptyElementSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlAttribute(XmlAttributeSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlString(XmlStringSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlPrefixName(XmlPrefixNameSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlName(XmlNameSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlBracketedName(XmlBracketedNameSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlPrefix(XmlPrefixSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlComment(XmlCommentSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlCDataSection(XmlCDataSectionSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlEmbeddedExpression(XmlEmbeddedExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitArrayType(ArrayTypeSyntax node);
    public virtual VisualBasicSyntaxNode VisitNullableType(NullableTypeSyntax node);
    public virtual VisualBasicSyntaxNode VisitPredefinedType(PredefinedTypeSyntax node);
    public virtual VisualBasicSyntaxNode VisitIdentifierName(IdentifierNameSyntax node);
    public virtual VisualBasicSyntaxNode VisitGenericName(GenericNameSyntax node);
    public virtual VisualBasicSyntaxNode VisitQualifiedName(QualifiedNameSyntax node);
    public virtual VisualBasicSyntaxNode VisitGlobalName(GlobalNameSyntax node);
    public virtual VisualBasicSyntaxNode VisitTypeArgumentList(TypeArgumentListSyntax node);
    public virtual VisualBasicSyntaxNode VisitCrefReference(CrefReferenceSyntax node);
    public virtual VisualBasicSyntaxNode VisitCrefSignature(CrefSignatureSyntax node);
    public virtual VisualBasicSyntaxNode VisitCrefSignaturePart(CrefSignaturePartSyntax node);
    public virtual VisualBasicSyntaxNode VisitCrefOperatorReference(CrefOperatorReferenceSyntax node);
    public virtual VisualBasicSyntaxNode VisitQualifiedCrefOperatorReference(QualifiedCrefOperatorReferenceSyntax node);
    public virtual VisualBasicSyntaxNode VisitYieldStatement(YieldStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitAwaitExpression(AwaitExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlCrefAttribute(XmlCrefAttributeSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlNameAttribute(XmlNameAttributeSyntax node);
    public virtual VisualBasicSyntaxNode VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitNameOfExpression(NameOfExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitInterpolatedStringText(InterpolatedStringTextSyntax node);
    public virtual VisualBasicSyntaxNode VisitInterpolation(InterpolationSyntax node);
    public virtual VisualBasicSyntaxNode VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitConstDirectiveTrivia(ConstDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitExternalSourceDirectiveTrivia(ExternalSourceDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitEndExternalSourceDirectiveTrivia(EndExternalSourceDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitExternalChecksumDirectiveTrivia(ExternalChecksumDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitEnableWarningDirectiveTrivia(EnableWarningDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitDisableWarningDirectiveTrivia(DisableWarningDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.VisualBasicSyntaxVisitor : object {
    public virtual SyntaxToken VisitSyntaxToken(SyntaxToken token);
    public virtual SyntaxTrivia VisitSyntaxTrivia(SyntaxTrivia trivia);
    public virtual VisualBasicSyntaxNode Visit(VisualBasicSyntaxNode node);
    public virtual VisualBasicSyntaxNode VisitVisualBasicSyntaxNode(VisualBasicSyntaxNode node);
    public virtual VisualBasicSyntaxNode VisitStatement(StatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitExecutableStatement(ExecutableStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitDeclarationStatement(DeclarationStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitEmptyStatement(EmptyStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitEndBlockStatement(EndBlockStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitCompilationUnit(CompilationUnitSyntax node);
    public virtual VisualBasicSyntaxNode VisitOptionStatement(OptionStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitImportsStatement(ImportsStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitImportsClause(ImportsClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitSimpleImportsClause(SimpleImportsClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitImportAliasClause(ImportAliasClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlNamespaceImportsClause(XmlNamespaceImportsClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitNamespaceBlock(NamespaceBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitNamespaceStatement(NamespaceStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitTypeBlock(TypeBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitModuleBlock(ModuleBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitStructureBlock(StructureBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitInterfaceBlock(InterfaceBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitClassBlock(ClassBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitEnumBlock(EnumBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitInheritsOrImplementsStatement(InheritsOrImplementsStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitInheritsStatement(InheritsStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitImplementsStatement(ImplementsStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitTypeStatement(TypeStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitModuleStatement(ModuleStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitStructureStatement(StructureStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitInterfaceStatement(InterfaceStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitClassStatement(ClassStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitEnumStatement(EnumStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitTypeParameterList(TypeParameterListSyntax node);
    public virtual VisualBasicSyntaxNode VisitTypeParameter(TypeParameterSyntax node);
    public virtual VisualBasicSyntaxNode VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitTypeParameterSingleConstraintClause(TypeParameterSingleConstraintClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitTypeParameterMultipleConstraintClause(TypeParameterMultipleConstraintClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitConstraint(ConstraintSyntax node);
    public virtual VisualBasicSyntaxNode VisitSpecialConstraint(SpecialConstraintSyntax node);
    public virtual VisualBasicSyntaxNode VisitTypeConstraint(TypeConstraintSyntax node);
    public virtual VisualBasicSyntaxNode VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node);
    public virtual VisualBasicSyntaxNode VisitMethodBlockBase(MethodBlockBaseSyntax node);
    public virtual VisualBasicSyntaxNode VisitMethodBlock(MethodBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitConstructorBlock(ConstructorBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitOperatorBlock(OperatorBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitAccessorBlock(AccessorBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitPropertyBlock(PropertyBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitEventBlock(EventBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitMethodBase(MethodBaseSyntax node);
    public virtual VisualBasicSyntaxNode VisitParameterList(ParameterListSyntax node);
    public virtual VisualBasicSyntaxNode VisitMethodStatement(MethodStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitSubNewStatement(SubNewStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitDeclareStatement(DeclareStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitDelegateStatement(DelegateStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitEventStatement(EventStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitOperatorStatement(OperatorStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitPropertyStatement(PropertyStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitAccessorStatement(AccessorStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitImplementsClause(ImplementsClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitHandlesClause(HandlesClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitEventContainer(EventContainerSyntax node);
    public virtual VisualBasicSyntaxNode VisitKeywordEventContainer(KeywordEventContainerSyntax node);
    public virtual VisualBasicSyntaxNode VisitWithEventsEventContainer(WithEventsEventContainerSyntax node);
    public virtual VisualBasicSyntaxNode VisitWithEventsPropertyEventContainer(WithEventsPropertyEventContainerSyntax node);
    public virtual VisualBasicSyntaxNode VisitHandlesClauseItem(HandlesClauseItemSyntax node);
    public virtual VisualBasicSyntaxNode VisitIncompleteMember(IncompleteMemberSyntax node);
    public virtual VisualBasicSyntaxNode VisitFieldDeclaration(FieldDeclarationSyntax node);
    public virtual VisualBasicSyntaxNode VisitVariableDeclarator(VariableDeclaratorSyntax node);
    public virtual VisualBasicSyntaxNode VisitAsClause(AsClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitSimpleAsClause(SimpleAsClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitAsNewClause(AsNewClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitObjectCreationInitializer(ObjectCreationInitializerSyntax node);
    public virtual VisualBasicSyntaxNode VisitObjectMemberInitializer(ObjectMemberInitializerSyntax node);
    public virtual VisualBasicSyntaxNode VisitObjectCollectionInitializer(ObjectCollectionInitializerSyntax node);
    public virtual VisualBasicSyntaxNode VisitFieldInitializer(FieldInitializerSyntax node);
    public virtual VisualBasicSyntaxNode VisitInferredFieldInitializer(InferredFieldInitializerSyntax node);
    public virtual VisualBasicSyntaxNode VisitNamedFieldInitializer(NamedFieldInitializerSyntax node);
    public virtual VisualBasicSyntaxNode VisitEqualsValue(EqualsValueSyntax node);
    public virtual VisualBasicSyntaxNode VisitParameter(ParameterSyntax node);
    public virtual VisualBasicSyntaxNode VisitModifiedIdentifier(ModifiedIdentifierSyntax node);
    public virtual VisualBasicSyntaxNode VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node);
    public virtual VisualBasicSyntaxNode VisitAttributeList(AttributeListSyntax node);
    public virtual VisualBasicSyntaxNode VisitAttribute(AttributeSyntax node);
    public virtual VisualBasicSyntaxNode VisitAttributeTarget(AttributeTargetSyntax node);
    public virtual VisualBasicSyntaxNode VisitAttributesStatement(AttributesStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitPrintStatement(PrintStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitWhileBlock(WhileBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitUsingBlock(UsingBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitSyncLockBlock(SyncLockBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitWithBlock(WithBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitLabelStatement(LabelStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitGoToStatement(GoToStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitLabel(LabelSyntax node);
    public virtual VisualBasicSyntaxNode VisitStopOrEndStatement(StopOrEndStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitExitStatement(ExitStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitContinueStatement(ContinueStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitReturnStatement(ReturnStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitSingleLineIfStatement(SingleLineIfStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitSingleLineElseClause(SingleLineElseClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitMultiLineIfBlock(MultiLineIfBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitIfStatement(IfStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitElseIfBlock(ElseIfBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitElseIfStatement(ElseIfStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitElseBlock(ElseBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitElseStatement(ElseStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitTryBlock(TryBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitTryStatement(TryStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitCatchBlock(CatchBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitCatchStatement(CatchStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitCatchFilterClause(CatchFilterClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitFinallyBlock(FinallyBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitFinallyStatement(FinallyStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitErrorStatement(ErrorStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitOnErrorGoToStatement(OnErrorGoToStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitOnErrorResumeNextStatement(OnErrorResumeNextStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitResumeStatement(ResumeStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitSelectBlock(SelectBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitSelectStatement(SelectStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitCaseBlock(CaseBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitCaseStatement(CaseStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitCaseClause(CaseClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitElseCaseClause(ElseCaseClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitSimpleCaseClause(SimpleCaseClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitRangeCaseClause(RangeCaseClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitRelationalCaseClause(RelationalCaseClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitSyncLockStatement(SyncLockStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitDoLoopBlock(DoLoopBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitDoStatement(DoStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitLoopStatement(LoopStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitWhileOrUntilClause(WhileOrUntilClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitWhileStatement(WhileStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitForOrForEachBlock(ForOrForEachBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitForBlock(ForBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitForEachBlock(ForEachBlockSyntax node);
    public virtual VisualBasicSyntaxNode VisitForOrForEachStatement(ForOrForEachStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitForStatement(ForStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitForStepClause(ForStepClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitForEachStatement(ForEachStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitNextStatement(NextStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitUsingStatement(UsingStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitThrowStatement(ThrowStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitAssignmentStatement(AssignmentStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitMidExpression(MidExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitCallStatement(CallStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitAddRemoveHandlerStatement(AddRemoveHandlerStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitRaiseEventStatement(RaiseEventStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitWithStatement(WithStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitReDimStatement(ReDimStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitRedimClause(RedimClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitEraseStatement(EraseStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitExpression(ExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitInstanceExpression(InstanceExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitMeExpression(MeExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitMyBaseExpression(MyBaseExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitMyClassExpression(MyClassExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitGetTypeExpression(GetTypeExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitTypeOfExpression(TypeOfExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitGetXmlNamespaceExpression(GetXmlNamespaceExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlMemberAccessExpression(XmlMemberAccessExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitNewExpression(NewExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitArrayCreationExpression(ArrayCreationExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitCollectionInitializer(CollectionInitializerSyntax node);
    public virtual VisualBasicSyntaxNode VisitCastExpression(CastExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitCTypeExpression(CTypeExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitDirectCastExpression(DirectCastExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitTryCastExpression(TryCastExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitPredefinedCastExpression(PredefinedCastExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitUnaryExpression(UnaryExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitBinaryConditionalExpression(BinaryConditionalExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitTernaryConditionalExpression(TernaryConditionalExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitLambdaExpression(LambdaExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitSingleLineLambdaExpression(SingleLineLambdaExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitMultiLineLambdaExpression(MultiLineLambdaExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitLambdaHeader(LambdaHeaderSyntax node);
    public virtual VisualBasicSyntaxNode VisitArgumentList(ArgumentListSyntax node);
    public virtual VisualBasicSyntaxNode VisitArgument(ArgumentSyntax node);
    public virtual VisualBasicSyntaxNode VisitOmittedArgument(OmittedArgumentSyntax node);
    public virtual VisualBasicSyntaxNode VisitSimpleArgument(SimpleArgumentSyntax node);
    public virtual VisualBasicSyntaxNode VisitNameColonEquals(NameColonEqualsSyntax node);
    public virtual VisualBasicSyntaxNode VisitRangeArgument(RangeArgumentSyntax node);
    public virtual VisualBasicSyntaxNode VisitQueryExpression(QueryExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitQueryClause(QueryClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitCollectionRangeVariable(CollectionRangeVariableSyntax node);
    public virtual VisualBasicSyntaxNode VisitExpressionRangeVariable(ExpressionRangeVariableSyntax node);
    public virtual VisualBasicSyntaxNode VisitAggregationRangeVariable(AggregationRangeVariableSyntax node);
    public virtual VisualBasicSyntaxNode VisitVariableNameEquals(VariableNameEqualsSyntax node);
    public virtual VisualBasicSyntaxNode VisitAggregation(AggregationSyntax node);
    public virtual VisualBasicSyntaxNode VisitFunctionAggregation(FunctionAggregationSyntax node);
    public virtual VisualBasicSyntaxNode VisitGroupAggregation(GroupAggregationSyntax node);
    public virtual VisualBasicSyntaxNode VisitFromClause(FromClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitLetClause(LetClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitAggregateClause(AggregateClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitDistinctClause(DistinctClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitWhereClause(WhereClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitPartitionWhileClause(PartitionWhileClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitPartitionClause(PartitionClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitGroupByClause(GroupByClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitJoinClause(JoinClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitJoinCondition(JoinConditionSyntax node);
    public virtual VisualBasicSyntaxNode VisitSimpleJoinClause(SimpleJoinClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitGroupJoinClause(GroupJoinClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitOrderByClause(OrderByClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitOrdering(OrderingSyntax node);
    public virtual VisualBasicSyntaxNode VisitSelectClause(SelectClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlNode(XmlNodeSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlDocument(XmlDocumentSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlDeclaration(XmlDeclarationSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlDeclarationOption(XmlDeclarationOptionSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlElement(XmlElementSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlText(XmlTextSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlElementStartTag(XmlElementStartTagSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlElementEndTag(XmlElementEndTagSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlEmptyElement(XmlEmptyElementSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlAttribute(XmlAttributeSyntax node);
    public virtual VisualBasicSyntaxNode VisitBaseXmlAttribute(BaseXmlAttributeSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlString(XmlStringSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlPrefixName(XmlPrefixNameSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlName(XmlNameSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlBracketedName(XmlBracketedNameSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlPrefix(XmlPrefixSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlComment(XmlCommentSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlCDataSection(XmlCDataSectionSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlEmbeddedExpression(XmlEmbeddedExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitType(TypeSyntax node);
    public virtual VisualBasicSyntaxNode VisitArrayType(ArrayTypeSyntax node);
    public virtual VisualBasicSyntaxNode VisitNullableType(NullableTypeSyntax node);
    public virtual VisualBasicSyntaxNode VisitPredefinedType(PredefinedTypeSyntax node);
    public virtual VisualBasicSyntaxNode VisitName(NameSyntax node);
    public virtual VisualBasicSyntaxNode VisitSimpleName(SimpleNameSyntax node);
    public virtual VisualBasicSyntaxNode VisitIdentifierName(IdentifierNameSyntax node);
    public virtual VisualBasicSyntaxNode VisitGenericName(GenericNameSyntax node);
    public virtual VisualBasicSyntaxNode VisitQualifiedName(QualifiedNameSyntax node);
    public virtual VisualBasicSyntaxNode VisitGlobalName(GlobalNameSyntax node);
    public virtual VisualBasicSyntaxNode VisitTypeArgumentList(TypeArgumentListSyntax node);
    public virtual VisualBasicSyntaxNode VisitCrefReference(CrefReferenceSyntax node);
    public virtual VisualBasicSyntaxNode VisitCrefSignature(CrefSignatureSyntax node);
    public virtual VisualBasicSyntaxNode VisitCrefSignaturePart(CrefSignaturePartSyntax node);
    public virtual VisualBasicSyntaxNode VisitCrefOperatorReference(CrefOperatorReferenceSyntax node);
    public virtual VisualBasicSyntaxNode VisitQualifiedCrefOperatorReference(QualifiedCrefOperatorReferenceSyntax node);
    public virtual VisualBasicSyntaxNode VisitYieldStatement(YieldStatementSyntax node);
    public virtual VisualBasicSyntaxNode VisitAwaitExpression(AwaitExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitStructuredTrivia(StructuredTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlCrefAttribute(XmlCrefAttributeSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlNameAttribute(XmlNameAttributeSyntax node);
    public virtual VisualBasicSyntaxNode VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitNameOfExpression(NameOfExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node);
    public virtual VisualBasicSyntaxNode VisitInterpolatedStringContent(InterpolatedStringContentSyntax node);
    public virtual VisualBasicSyntaxNode VisitInterpolatedStringText(InterpolatedStringTextSyntax node);
    public virtual VisualBasicSyntaxNode VisitInterpolation(InterpolationSyntax node);
    public virtual VisualBasicSyntaxNode VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node);
    public virtual VisualBasicSyntaxNode VisitDirectiveTrivia(DirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitConstDirectiveTrivia(ConstDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitExternalSourceDirectiveTrivia(ExternalSourceDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitEndExternalSourceDirectiveTrivia(EndExternalSourceDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitExternalChecksumDirectiveTrivia(ExternalChecksumDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitEnableWarningDirectiveTrivia(EnableWarningDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitDisableWarningDirectiveTrivia(DisableWarningDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node);
    public virtual VisualBasicSyntaxNode VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhereClauseSyntax : QueryClauseSyntax {
    internal KeywordSyntax _whereKeyword;
    internal ExpressionSyntax _condition;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax WhereKeyword { get; }
    internal ExpressionSyntax Condition { get; }
    private static WhereClauseSyntax();
    internal WhereClauseSyntax(SyntaxKind kind, KeywordSyntax whereKeyword, ExpressionSyntax condition);
    internal WhereClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax whereKeyword, ExpressionSyntax condition);
    internal WhereClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax whereKeyword, ExpressionSyntax condition);
    internal WhereClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_WhereKeyword();
    internal ExpressionSyntax get_Condition();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileBlockSyntax : ExecutableStatementSyntax {
    internal WhileStatementSyntax _whileStatement;
    internal GreenNode _statements;
    internal EndBlockStatementSyntax _endWhileStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal WhileStatementSyntax WhileStatement { get; }
    internal SyntaxList`1<StatementSyntax> Statements { get; }
    internal EndBlockStatementSyntax EndWhileStatement { get; }
    private static WhileBlockSyntax();
    internal WhileBlockSyntax(SyntaxKind kind, WhileStatementSyntax whileStatement, GreenNode statements, EndBlockStatementSyntax endWhileStatement);
    internal WhileBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, WhileStatementSyntax whileStatement, GreenNode statements, EndBlockStatementSyntax endWhileStatement);
    internal WhileBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, WhileStatementSyntax whileStatement, GreenNode statements, EndBlockStatementSyntax endWhileStatement);
    internal WhileBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal WhileStatementSyntax get_WhileStatement();
    internal SyntaxList`1<StatementSyntax> get_Statements();
    internal EndBlockStatementSyntax get_EndWhileStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileOrUntilClauseSyntax : VisualBasicSyntaxNode {
    internal KeywordSyntax _whileOrUntilKeyword;
    internal ExpressionSyntax _condition;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax WhileOrUntilKeyword { get; }
    internal ExpressionSyntax Condition { get; }
    private static WhileOrUntilClauseSyntax();
    internal WhileOrUntilClauseSyntax(SyntaxKind kind, KeywordSyntax whileOrUntilKeyword, ExpressionSyntax condition);
    internal WhileOrUntilClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax whileOrUntilKeyword, ExpressionSyntax condition);
    internal WhileOrUntilClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax whileOrUntilKeyword, ExpressionSyntax condition);
    internal WhileOrUntilClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_WhileOrUntilKeyword();
    internal ExpressionSyntax get_Condition();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WhileStatementSyntax : StatementSyntax {
    internal KeywordSyntax _whileKeyword;
    internal ExpressionSyntax _condition;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax WhileKeyword { get; }
    internal ExpressionSyntax Condition { get; }
    private static WhileStatementSyntax();
    internal WhileStatementSyntax(SyntaxKind kind, KeywordSyntax whileKeyword, ExpressionSyntax condition);
    internal WhileStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax whileKeyword, ExpressionSyntax condition);
    internal WhileStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax whileKeyword, ExpressionSyntax condition);
    internal WhileStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_WhileKeyword();
    internal ExpressionSyntax get_Condition();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithBlockSyntax : ExecutableStatementSyntax {
    internal WithStatementSyntax _withStatement;
    internal GreenNode _statements;
    internal EndBlockStatementSyntax _endWithStatement;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal WithStatementSyntax WithStatement { get; }
    internal SyntaxList`1<StatementSyntax> Statements { get; }
    internal EndBlockStatementSyntax EndWithStatement { get; }
    private static WithBlockSyntax();
    internal WithBlockSyntax(SyntaxKind kind, WithStatementSyntax withStatement, GreenNode statements, EndBlockStatementSyntax endWithStatement);
    internal WithBlockSyntax(SyntaxKind kind, ISyntaxFactoryContext context, WithStatementSyntax withStatement, GreenNode statements, EndBlockStatementSyntax endWithStatement);
    internal WithBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, WithStatementSyntax withStatement, GreenNode statements, EndBlockStatementSyntax endWithStatement);
    internal WithBlockSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal WithStatementSyntax get_WithStatement();
    internal SyntaxList`1<StatementSyntax> get_Statements();
    internal EndBlockStatementSyntax get_EndWithStatement();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithEventsEventContainerSyntax : EventContainerSyntax {
    internal IdentifierTokenSyntax _identifier;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal IdentifierTokenSyntax Identifier { get; }
    private static WithEventsEventContainerSyntax();
    internal WithEventsEventContainerSyntax(SyntaxKind kind, IdentifierTokenSyntax identifier);
    internal WithEventsEventContainerSyntax(SyntaxKind kind, ISyntaxFactoryContext context, IdentifierTokenSyntax identifier);
    internal WithEventsEventContainerSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, IdentifierTokenSyntax identifier);
    internal WithEventsEventContainerSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal IdentifierTokenSyntax get_Identifier();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithEventsPropertyEventContainerSyntax : EventContainerSyntax {
    internal WithEventsEventContainerSyntax _withEventsContainer;
    internal PunctuationSyntax _dotToken;
    internal IdentifierNameSyntax _property;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal WithEventsEventContainerSyntax WithEventsContainer { get; }
    internal PunctuationSyntax DotToken { get; }
    internal IdentifierNameSyntax Property { get; }
    private static WithEventsPropertyEventContainerSyntax();
    internal WithEventsPropertyEventContainerSyntax(SyntaxKind kind, WithEventsEventContainerSyntax withEventsContainer, PunctuationSyntax dotToken, IdentifierNameSyntax property);
    internal WithEventsPropertyEventContainerSyntax(SyntaxKind kind, ISyntaxFactoryContext context, WithEventsEventContainerSyntax withEventsContainer, PunctuationSyntax dotToken, IdentifierNameSyntax property);
    internal WithEventsPropertyEventContainerSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, WithEventsEventContainerSyntax withEventsContainer, PunctuationSyntax dotToken, IdentifierNameSyntax property);
    internal WithEventsPropertyEventContainerSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal WithEventsEventContainerSyntax get_WithEventsContainer();
    internal PunctuationSyntax get_DotToken();
    internal IdentifierNameSyntax get_Property();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.WithStatementSyntax : StatementSyntax {
    internal KeywordSyntax _withKeyword;
    internal ExpressionSyntax _expression;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax WithKeyword { get; }
    internal ExpressionSyntax Expression { get; }
    private static WithStatementSyntax();
    internal WithStatementSyntax(SyntaxKind kind, KeywordSyntax withKeyword, ExpressionSyntax expression);
    internal WithStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax withKeyword, ExpressionSyntax expression);
    internal WithStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax withKeyword, ExpressionSyntax expression);
    internal WithStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_WithKeyword();
    internal ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlAttributeSyntax : BaseXmlAttributeSyntax {
    internal XmlNodeSyntax _name;
    internal PunctuationSyntax _equalsToken;
    internal XmlNodeSyntax _value;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal XmlNodeSyntax Name { get; }
    internal PunctuationSyntax EqualsToken { get; }
    internal XmlNodeSyntax Value { get; }
    private static XmlAttributeSyntax();
    internal XmlAttributeSyntax(SyntaxKind kind, XmlNodeSyntax name, PunctuationSyntax equalsToken, XmlNodeSyntax value);
    internal XmlAttributeSyntax(SyntaxKind kind, ISyntaxFactoryContext context, XmlNodeSyntax name, PunctuationSyntax equalsToken, XmlNodeSyntax value);
    internal XmlAttributeSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, XmlNodeSyntax name, PunctuationSyntax equalsToken, XmlNodeSyntax value);
    internal XmlAttributeSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal XmlNodeSyntax get_Name();
    internal PunctuationSyntax get_EqualsToken();
    internal XmlNodeSyntax get_Value();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlBracketedNameSyntax : XmlNodeSyntax {
    internal PunctuationSyntax _lessThanToken;
    internal XmlNameSyntax _name;
    internal PunctuationSyntax _greaterThanToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax LessThanToken { get; }
    internal XmlNameSyntax Name { get; }
    internal PunctuationSyntax GreaterThanToken { get; }
    private static XmlBracketedNameSyntax();
    internal XmlBracketedNameSyntax(SyntaxKind kind, PunctuationSyntax lessThanToken, XmlNameSyntax name, PunctuationSyntax greaterThanToken);
    internal XmlBracketedNameSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax lessThanToken, XmlNameSyntax name, PunctuationSyntax greaterThanToken);
    internal XmlBracketedNameSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanToken, XmlNameSyntax name, PunctuationSyntax greaterThanToken);
    internal XmlBracketedNameSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_LessThanToken();
    internal XmlNameSyntax get_Name();
    internal PunctuationSyntax get_GreaterThanToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlCDataSectionSyntax : XmlNodeSyntax {
    internal PunctuationSyntax _beginCDataToken;
    internal GreenNode _textTokens;
    internal PunctuationSyntax _endCDataToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax BeginCDataToken { get; }
    internal SyntaxList`1<XmlTextTokenSyntax> TextTokens { get; }
    internal PunctuationSyntax EndCDataToken { get; }
    private static XmlCDataSectionSyntax();
    internal XmlCDataSectionSyntax(SyntaxKind kind, PunctuationSyntax beginCDataToken, GreenNode textTokens, PunctuationSyntax endCDataToken);
    internal XmlCDataSectionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax beginCDataToken, GreenNode textTokens, PunctuationSyntax endCDataToken);
    internal XmlCDataSectionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax beginCDataToken, GreenNode textTokens, PunctuationSyntax endCDataToken);
    internal XmlCDataSectionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_BeginCDataToken();
    internal SyntaxList`1<XmlTextTokenSyntax> get_TextTokens();
    internal PunctuationSyntax get_EndCDataToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlCharacterGlobalHelpers : object {
    internal static bool isNameChar(char ch);
    internal static bool isStartNameChar(char ch);
    internal static bool isValidUtf16(char wh);
    internal static XmlCharResult HexToUTF16(StringBuilder pwcText);
    internal static bool TryHexToUnicode(StringBuilder pwcText, UInt32& pulCode);
    internal static XmlCharResult DecToUTF16(StringBuilder pwcText);
    internal static bool TryDecToUnicode(StringBuilder pwcText, UInt16& pulCode);
    private static bool ValidateXmlChar(UInt32 ulCode);
    private static XmlCharResult UnicodeToUTF16(UInt32 ulCode);
    internal static int UTF16ToUnicode(XmlCharResult ch);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlCommentSyntax : XmlNodeSyntax {
    internal PunctuationSyntax _lessThanExclamationMinusMinusToken;
    internal GreenNode _textTokens;
    internal PunctuationSyntax _minusMinusGreaterThanToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax LessThanExclamationMinusMinusToken { get; }
    internal SyntaxList`1<XmlTextTokenSyntax> TextTokens { get; }
    internal PunctuationSyntax MinusMinusGreaterThanToken { get; }
    private static XmlCommentSyntax();
    internal XmlCommentSyntax(SyntaxKind kind, PunctuationSyntax lessThanExclamationMinusMinusToken, GreenNode textTokens, PunctuationSyntax minusMinusGreaterThanToken);
    internal XmlCommentSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax lessThanExclamationMinusMinusToken, GreenNode textTokens, PunctuationSyntax minusMinusGreaterThanToken);
    internal XmlCommentSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanExclamationMinusMinusToken, GreenNode textTokens, PunctuationSyntax minusMinusGreaterThanToken);
    internal XmlCommentSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_LessThanExclamationMinusMinusToken();
    internal SyntaxList`1<XmlTextTokenSyntax> get_TextTokens();
    internal PunctuationSyntax get_MinusMinusGreaterThanToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlContext : ValueType {
    private XmlElementStartTagSyntax _start;
    private SyntaxListBuilder`1<XmlNodeSyntax> _content;
    private SyntaxListPool _pool;
    public XmlElementStartTagSyntax StartElement { get; }
    public XmlContext(SyntaxListPool pool, XmlElementStartTagSyntax start);
    public void Add(XmlNodeSyntax xml);
    public XmlElementStartTagSyntax get_StartElement();
    public XmlNodeSyntax CreateElement(XmlElementEndTagSyntax endElement);
    public XmlNodeSyntax CreateElement(XmlElementEndTagSyntax endElement, DiagnosticInfo diagnostic);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlContextExtensions : object {
    [ExtensionAttribute]
internal static void Push(List`1<XmlContext> this, XmlContext context);
    [ExtensionAttribute]
internal static XmlContext Pop(List`1<XmlContext> this);
    [ExtensionAttribute]
internal static XmlContext Peek(List`1<XmlContext> this, int i);
    [ExtensionAttribute]
internal static int MatchEndElement(List`1<XmlContext> this, XmlNameSyntax name);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlCrefAttributeSyntax : BaseXmlAttributeSyntax {
    internal XmlNameSyntax _name;
    internal PunctuationSyntax _equalsToken;
    internal PunctuationSyntax _startQuoteToken;
    internal CrefReferenceSyntax _reference;
    internal PunctuationSyntax _endQuoteToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal XmlNameSyntax Name { get; }
    internal PunctuationSyntax EqualsToken { get; }
    internal PunctuationSyntax StartQuoteToken { get; }
    internal CrefReferenceSyntax Reference { get; }
    internal PunctuationSyntax EndQuoteToken { get; }
    private static XmlCrefAttributeSyntax();
    internal XmlCrefAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, PunctuationSyntax equalsToken, PunctuationSyntax startQuoteToken, CrefReferenceSyntax reference, PunctuationSyntax endQuoteToken);
    internal XmlCrefAttributeSyntax(SyntaxKind kind, ISyntaxFactoryContext context, XmlNameSyntax name, PunctuationSyntax equalsToken, PunctuationSyntax startQuoteToken, CrefReferenceSyntax reference, PunctuationSyntax endQuoteToken);
    internal XmlCrefAttributeSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, XmlNameSyntax name, PunctuationSyntax equalsToken, PunctuationSyntax startQuoteToken, CrefReferenceSyntax reference, PunctuationSyntax endQuoteToken);
    internal XmlCrefAttributeSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal XmlNameSyntax get_Name();
    internal PunctuationSyntax get_EqualsToken();
    internal PunctuationSyntax get_StartQuoteToken();
    internal CrefReferenceSyntax get_Reference();
    internal PunctuationSyntax get_EndQuoteToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlDeclarationOptionSyntax : VisualBasicSyntaxNode {
    internal XmlNameTokenSyntax _name;
    internal PunctuationSyntax _equals;
    internal XmlStringSyntax _value;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal XmlNameTokenSyntax Name { get; }
    internal PunctuationSyntax Equals { get; }
    internal XmlStringSyntax Value { get; }
    private static XmlDeclarationOptionSyntax();
    internal XmlDeclarationOptionSyntax(SyntaxKind kind, XmlNameTokenSyntax name, PunctuationSyntax equals, XmlStringSyntax value);
    internal XmlDeclarationOptionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, XmlNameTokenSyntax name, PunctuationSyntax equals, XmlStringSyntax value);
    internal XmlDeclarationOptionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, XmlNameTokenSyntax name, PunctuationSyntax equals, XmlStringSyntax value);
    internal XmlDeclarationOptionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal XmlNameTokenSyntax get_Name();
    internal PunctuationSyntax get_Equals();
    internal XmlStringSyntax get_Value();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlDeclarationSyntax : VisualBasicSyntaxNode {
    internal PunctuationSyntax _lessThanQuestionToken;
    internal KeywordSyntax _xmlKeyword;
    internal XmlDeclarationOptionSyntax _version;
    internal XmlDeclarationOptionSyntax _encoding;
    internal XmlDeclarationOptionSyntax _standalone;
    internal PunctuationSyntax _questionGreaterThanToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax LessThanQuestionToken { get; }
    internal KeywordSyntax XmlKeyword { get; }
    internal XmlDeclarationOptionSyntax Version { get; }
    internal XmlDeclarationOptionSyntax Encoding { get; }
    internal XmlDeclarationOptionSyntax Standalone { get; }
    internal PunctuationSyntax QuestionGreaterThanToken { get; }
    private static XmlDeclarationSyntax();
    internal XmlDeclarationSyntax(SyntaxKind kind, PunctuationSyntax lessThanQuestionToken, KeywordSyntax xmlKeyword, XmlDeclarationOptionSyntax version, XmlDeclarationOptionSyntax encoding, XmlDeclarationOptionSyntax standalone, PunctuationSyntax questionGreaterThanToken);
    internal XmlDeclarationSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax lessThanQuestionToken, KeywordSyntax xmlKeyword, XmlDeclarationOptionSyntax version, XmlDeclarationOptionSyntax encoding, XmlDeclarationOptionSyntax standalone, PunctuationSyntax questionGreaterThanToken);
    internal XmlDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanQuestionToken, KeywordSyntax xmlKeyword, XmlDeclarationOptionSyntax version, XmlDeclarationOptionSyntax encoding, XmlDeclarationOptionSyntax standalone, PunctuationSyntax questionGreaterThanToken);
    internal XmlDeclarationSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_LessThanQuestionToken();
    internal KeywordSyntax get_XmlKeyword();
    internal XmlDeclarationOptionSyntax get_Version();
    internal XmlDeclarationOptionSyntax get_Encoding();
    internal XmlDeclarationOptionSyntax get_Standalone();
    internal PunctuationSyntax get_QuestionGreaterThanToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlDocumentSyntax : XmlNodeSyntax {
    internal XmlDeclarationSyntax _declaration;
    internal GreenNode _precedingMisc;
    internal XmlNodeSyntax _root;
    internal GreenNode _followingMisc;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal XmlDeclarationSyntax Declaration { get; }
    internal SyntaxList`1<XmlNodeSyntax> PrecedingMisc { get; }
    internal XmlNodeSyntax Root { get; }
    internal SyntaxList`1<XmlNodeSyntax> FollowingMisc { get; }
    private static XmlDocumentSyntax();
    internal XmlDocumentSyntax(SyntaxKind kind, XmlDeclarationSyntax declaration, GreenNode precedingMisc, XmlNodeSyntax root, GreenNode followingMisc);
    internal XmlDocumentSyntax(SyntaxKind kind, ISyntaxFactoryContext context, XmlDeclarationSyntax declaration, GreenNode precedingMisc, XmlNodeSyntax root, GreenNode followingMisc);
    internal XmlDocumentSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, XmlDeclarationSyntax declaration, GreenNode precedingMisc, XmlNodeSyntax root, GreenNode followingMisc);
    internal XmlDocumentSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal XmlDeclarationSyntax get_Declaration();
    internal SyntaxList`1<XmlNodeSyntax> get_PrecedingMisc();
    internal XmlNodeSyntax get_Root();
    internal SyntaxList`1<XmlNodeSyntax> get_FollowingMisc();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlElementEndTagSyntax : XmlNodeSyntax {
    internal PunctuationSyntax _lessThanSlashToken;
    internal XmlNameSyntax _name;
    internal PunctuationSyntax _greaterThanToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax LessThanSlashToken { get; }
    internal XmlNameSyntax Name { get; }
    internal PunctuationSyntax GreaterThanToken { get; }
    private static XmlElementEndTagSyntax();
    internal XmlElementEndTagSyntax(SyntaxKind kind, PunctuationSyntax lessThanSlashToken, XmlNameSyntax name, PunctuationSyntax greaterThanToken);
    internal XmlElementEndTagSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax lessThanSlashToken, XmlNameSyntax name, PunctuationSyntax greaterThanToken);
    internal XmlElementEndTagSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanSlashToken, XmlNameSyntax name, PunctuationSyntax greaterThanToken);
    internal XmlElementEndTagSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_LessThanSlashToken();
    internal XmlNameSyntax get_Name();
    internal PunctuationSyntax get_GreaterThanToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlElementStartTagSyntax : XmlNodeSyntax {
    internal PunctuationSyntax _lessThanToken;
    internal XmlNodeSyntax _name;
    internal GreenNode _attributes;
    internal PunctuationSyntax _greaterThanToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax LessThanToken { get; }
    internal XmlNodeSyntax Name { get; }
    internal SyntaxList`1<XmlNodeSyntax> Attributes { get; }
    internal PunctuationSyntax GreaterThanToken { get; }
    private static XmlElementStartTagSyntax();
    internal XmlElementStartTagSyntax(SyntaxKind kind, PunctuationSyntax lessThanToken, XmlNodeSyntax name, GreenNode attributes, PunctuationSyntax greaterThanToken);
    internal XmlElementStartTagSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax lessThanToken, XmlNodeSyntax name, GreenNode attributes, PunctuationSyntax greaterThanToken);
    internal XmlElementStartTagSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanToken, XmlNodeSyntax name, GreenNode attributes, PunctuationSyntax greaterThanToken);
    internal XmlElementStartTagSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_LessThanToken();
    internal XmlNodeSyntax get_Name();
    internal SyntaxList`1<XmlNodeSyntax> get_Attributes();
    internal PunctuationSyntax get_GreaterThanToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlElementSyntax : XmlNodeSyntax {
    internal XmlElementStartTagSyntax _startTag;
    internal GreenNode _content;
    internal XmlElementEndTagSyntax _endTag;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal XmlElementStartTagSyntax StartTag { get; }
    internal SyntaxList`1<XmlNodeSyntax> Content { get; }
    internal XmlElementEndTagSyntax EndTag { get; }
    private static XmlElementSyntax();
    internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, GreenNode content, XmlElementEndTagSyntax endTag);
    internal XmlElementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, XmlElementStartTagSyntax startTag, GreenNode content, XmlElementEndTagSyntax endTag);
    internal XmlElementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, XmlElementStartTagSyntax startTag, GreenNode content, XmlElementEndTagSyntax endTag);
    internal XmlElementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal XmlElementStartTagSyntax get_StartTag();
    internal SyntaxList`1<XmlNodeSyntax> get_Content();
    internal XmlElementEndTagSyntax get_EndTag();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlEmbeddedExpressionSyntax : XmlNodeSyntax {
    internal PunctuationSyntax _lessThanPercentEqualsToken;
    internal ExpressionSyntax _expression;
    internal PunctuationSyntax _percentGreaterThanToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax LessThanPercentEqualsToken { get; }
    internal ExpressionSyntax Expression { get; }
    internal PunctuationSyntax PercentGreaterThanToken { get; }
    private static XmlEmbeddedExpressionSyntax();
    internal XmlEmbeddedExpressionSyntax(SyntaxKind kind, PunctuationSyntax lessThanPercentEqualsToken, ExpressionSyntax expression, PunctuationSyntax percentGreaterThanToken);
    internal XmlEmbeddedExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax lessThanPercentEqualsToken, ExpressionSyntax expression, PunctuationSyntax percentGreaterThanToken);
    internal XmlEmbeddedExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanPercentEqualsToken, ExpressionSyntax expression, PunctuationSyntax percentGreaterThanToken);
    internal XmlEmbeddedExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_LessThanPercentEqualsToken();
    internal ExpressionSyntax get_Expression();
    internal PunctuationSyntax get_PercentGreaterThanToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlEmptyElementSyntax : XmlNodeSyntax {
    internal PunctuationSyntax _lessThanToken;
    internal XmlNodeSyntax _name;
    internal GreenNode _attributes;
    internal PunctuationSyntax _slashGreaterThanToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax LessThanToken { get; }
    internal XmlNodeSyntax Name { get; }
    internal SyntaxList`1<XmlNodeSyntax> Attributes { get; }
    internal PunctuationSyntax SlashGreaterThanToken { get; }
    private static XmlEmptyElementSyntax();
    internal XmlEmptyElementSyntax(SyntaxKind kind, PunctuationSyntax lessThanToken, XmlNodeSyntax name, GreenNode attributes, PunctuationSyntax slashGreaterThanToken);
    internal XmlEmptyElementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax lessThanToken, XmlNodeSyntax name, GreenNode attributes, PunctuationSyntax slashGreaterThanToken);
    internal XmlEmptyElementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanToken, XmlNodeSyntax name, GreenNode attributes, PunctuationSyntax slashGreaterThanToken);
    internal XmlEmptyElementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_LessThanToken();
    internal XmlNodeSyntax get_Name();
    internal SyntaxList`1<XmlNodeSyntax> get_Attributes();
    internal PunctuationSyntax get_SlashGreaterThanToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlMemberAccessExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax _base;
    internal PunctuationSyntax _token1;
    internal PunctuationSyntax _token2;
    internal PunctuationSyntax _token3;
    internal XmlNodeSyntax _name;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal ExpressionSyntax Base { get; }
    internal PunctuationSyntax Token1 { get; }
    internal PunctuationSyntax Token2 { get; }
    internal PunctuationSyntax Token3 { get; }
    internal XmlNodeSyntax Name { get; }
    private static XmlMemberAccessExpressionSyntax();
    internal XmlMemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax base, PunctuationSyntax token1, PunctuationSyntax token2, PunctuationSyntax token3, XmlNodeSyntax name);
    internal XmlMemberAccessExpressionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, ExpressionSyntax base, PunctuationSyntax token1, PunctuationSyntax token2, PunctuationSyntax token3, XmlNodeSyntax name);
    internal XmlMemberAccessExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax base, PunctuationSyntax token1, PunctuationSyntax token2, PunctuationSyntax token3, XmlNodeSyntax name);
    internal XmlMemberAccessExpressionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal ExpressionSyntax get_Base();
    internal PunctuationSyntax get_Token1();
    internal PunctuationSyntax get_Token2();
    internal PunctuationSyntax get_Token3();
    internal XmlNodeSyntax get_Name();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameAttributeSyntax : BaseXmlAttributeSyntax {
    internal XmlNameSyntax _name;
    internal PunctuationSyntax _equalsToken;
    internal PunctuationSyntax _startQuoteToken;
    internal IdentifierNameSyntax _reference;
    internal PunctuationSyntax _endQuoteToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal XmlNameSyntax Name { get; }
    internal PunctuationSyntax EqualsToken { get; }
    internal PunctuationSyntax StartQuoteToken { get; }
    internal IdentifierNameSyntax Reference { get; }
    internal PunctuationSyntax EndQuoteToken { get; }
    private static XmlNameAttributeSyntax();
    internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, PunctuationSyntax equalsToken, PunctuationSyntax startQuoteToken, IdentifierNameSyntax reference, PunctuationSyntax endQuoteToken);
    internal XmlNameAttributeSyntax(SyntaxKind kind, ISyntaxFactoryContext context, XmlNameSyntax name, PunctuationSyntax equalsToken, PunctuationSyntax startQuoteToken, IdentifierNameSyntax reference, PunctuationSyntax endQuoteToken);
    internal XmlNameAttributeSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, XmlNameSyntax name, PunctuationSyntax equalsToken, PunctuationSyntax startQuoteToken, IdentifierNameSyntax reference, PunctuationSyntax endQuoteToken);
    internal XmlNameAttributeSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal XmlNameSyntax get_Name();
    internal PunctuationSyntax get_EqualsToken();
    internal PunctuationSyntax get_StartQuoteToken();
    internal IdentifierNameSyntax get_Reference();
    internal PunctuationSyntax get_EndQuoteToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNamespaceImportsClauseSyntax : ImportsClauseSyntax {
    internal PunctuationSyntax _lessThanToken;
    internal XmlAttributeSyntax _xmlNamespace;
    internal PunctuationSyntax _greaterThanToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax LessThanToken { get; }
    internal XmlAttributeSyntax XmlNamespace { get; }
    internal PunctuationSyntax GreaterThanToken { get; }
    private static XmlNamespaceImportsClauseSyntax();
    internal XmlNamespaceImportsClauseSyntax(SyntaxKind kind, PunctuationSyntax lessThanToken, XmlAttributeSyntax xmlNamespace, PunctuationSyntax greaterThanToken);
    internal XmlNamespaceImportsClauseSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax lessThanToken, XmlAttributeSyntax xmlNamespace, PunctuationSyntax greaterThanToken);
    internal XmlNamespaceImportsClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanToken, XmlAttributeSyntax xmlNamespace, PunctuationSyntax greaterThanToken);
    internal XmlNamespaceImportsClauseSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_LessThanToken();
    internal XmlAttributeSyntax get_XmlNamespace();
    internal PunctuationSyntax get_GreaterThanToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameSyntax : XmlNodeSyntax {
    internal XmlPrefixSyntax _prefix;
    internal XmlNameTokenSyntax _localName;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal XmlPrefixSyntax Prefix { get; }
    internal XmlNameTokenSyntax LocalName { get; }
    private static XmlNameSyntax();
    internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax prefix, XmlNameTokenSyntax localName);
    internal XmlNameSyntax(SyntaxKind kind, ISyntaxFactoryContext context, XmlPrefixSyntax prefix, XmlNameTokenSyntax localName);
    internal XmlNameSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, XmlPrefixSyntax prefix, XmlNameTokenSyntax localName);
    internal XmlNameSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal XmlPrefixSyntax get_Prefix();
    internal XmlNameTokenSyntax get_LocalName();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNameTokenSyntax : SyntaxToken {
    internal SyntaxKind _possibleKeywordKind;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxKind PossibleKeywordKind { get; }
    private static XmlNameTokenSyntax();
    internal XmlNameTokenSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, SyntaxKind possibleKeywordKind);
    internal XmlNameTokenSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, ISyntaxFactoryContext context, SyntaxKind possibleKeywordKind);
    internal XmlNameTokenSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, SyntaxKind possibleKeywordKind);
    internal XmlNameTokenSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal SyntaxKind get_PossibleKeywordKind();
    public virtual GreenNode WithLeadingTrivia(GreenNode trivia);
    public virtual GreenNode WithTrailingTrivia(GreenNode trivia);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlNodeSyntax : ExpressionSyntax {
    internal XmlNodeSyntax(SyntaxKind kind);
    internal XmlNodeSyntax(SyntaxKind kind, ISyntaxFactoryContext context);
    internal XmlNodeSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations);
    internal XmlNodeSyntax(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlPrefixNameSyntax : XmlNodeSyntax {
    internal XmlNameTokenSyntax _name;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal XmlNameTokenSyntax Name { get; }
    private static XmlPrefixNameSyntax();
    internal XmlPrefixNameSyntax(SyntaxKind kind, XmlNameTokenSyntax name);
    internal XmlPrefixNameSyntax(SyntaxKind kind, ISyntaxFactoryContext context, XmlNameTokenSyntax name);
    internal XmlPrefixNameSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, XmlNameTokenSyntax name);
    internal XmlPrefixNameSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal XmlNameTokenSyntax get_Name();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlPrefixSyntax : VisualBasicSyntaxNode {
    internal XmlNameTokenSyntax _name;
    internal PunctuationSyntax _colonToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal XmlNameTokenSyntax Name { get; }
    internal PunctuationSyntax ColonToken { get; }
    private static XmlPrefixSyntax();
    internal XmlPrefixSyntax(SyntaxKind kind, XmlNameTokenSyntax name, PunctuationSyntax colonToken);
    internal XmlPrefixSyntax(SyntaxKind kind, ISyntaxFactoryContext context, XmlNameTokenSyntax name, PunctuationSyntax colonToken);
    internal XmlPrefixSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, XmlNameTokenSyntax name, PunctuationSyntax colonToken);
    internal XmlPrefixSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal XmlNameTokenSyntax get_Name();
    internal PunctuationSyntax get_ColonToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlProcessingInstructionSyntax : XmlNodeSyntax {
    internal PunctuationSyntax _lessThanQuestionToken;
    internal XmlNameTokenSyntax _name;
    internal GreenNode _textTokens;
    internal PunctuationSyntax _questionGreaterThanToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax LessThanQuestionToken { get; }
    internal XmlNameTokenSyntax Name { get; }
    internal SyntaxList`1<XmlTextTokenSyntax> TextTokens { get; }
    internal PunctuationSyntax QuestionGreaterThanToken { get; }
    private static XmlProcessingInstructionSyntax();
    internal XmlProcessingInstructionSyntax(SyntaxKind kind, PunctuationSyntax lessThanQuestionToken, XmlNameTokenSyntax name, GreenNode textTokens, PunctuationSyntax questionGreaterThanToken);
    internal XmlProcessingInstructionSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax lessThanQuestionToken, XmlNameTokenSyntax name, GreenNode textTokens, PunctuationSyntax questionGreaterThanToken);
    internal XmlProcessingInstructionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanQuestionToken, XmlNameTokenSyntax name, GreenNode textTokens, PunctuationSyntax questionGreaterThanToken);
    internal XmlProcessingInstructionSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_LessThanQuestionToken();
    internal XmlNameTokenSyntax get_Name();
    internal SyntaxList`1<XmlTextTokenSyntax> get_TextTokens();
    internal PunctuationSyntax get_QuestionGreaterThanToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlStringSyntax : XmlNodeSyntax {
    internal PunctuationSyntax _startQuoteToken;
    internal GreenNode _textTokens;
    internal PunctuationSyntax _endQuoteToken;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal PunctuationSyntax StartQuoteToken { get; }
    internal SyntaxList`1<XmlTextTokenSyntax> TextTokens { get; }
    internal PunctuationSyntax EndQuoteToken { get; }
    private static XmlStringSyntax();
    internal XmlStringSyntax(SyntaxKind kind, PunctuationSyntax startQuoteToken, GreenNode textTokens, PunctuationSyntax endQuoteToken);
    internal XmlStringSyntax(SyntaxKind kind, ISyntaxFactoryContext context, PunctuationSyntax startQuoteToken, GreenNode textTokens, PunctuationSyntax endQuoteToken);
    internal XmlStringSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax startQuoteToken, GreenNode textTokens, PunctuationSyntax endQuoteToken);
    internal XmlStringSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal PunctuationSyntax get_StartQuoteToken();
    internal SyntaxList`1<XmlTextTokenSyntax> get_TextTokens();
    internal PunctuationSyntax get_EndQuoteToken();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlTextSyntax : XmlNodeSyntax {
    internal GreenNode _textTokens;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal SyntaxList`1<XmlTextTokenSyntax> TextTokens { get; }
    private static XmlTextSyntax();
    internal XmlTextSyntax(SyntaxKind kind, GreenNode textTokens);
    internal XmlTextSyntax(SyntaxKind kind, ISyntaxFactoryContext context, GreenNode textTokens);
    internal XmlTextSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode textTokens);
    internal XmlTextSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal SyntaxList`1<XmlTextTokenSyntax> get_TextTokens();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlTextTokenSyntax : SyntaxToken {
    internal string _value;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal string ValueText { get; }
    internal string Value { get; }
    private static XmlTextTokenSyntax();
    internal XmlTextTokenSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, string value);
    internal XmlTextTokenSyntax(SyntaxKind kind, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, ISyntaxFactoryContext context, string value);
    internal XmlTextTokenSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, string text, VisualBasicSyntaxNode leadingTrivia, VisualBasicSyntaxNode trailingTrivia, string value);
    internal XmlTextTokenSyntax(ObjectReader reader);
    internal sealed virtual string get_ValueText();
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal string get_Value();
    public virtual GreenNode WithLeadingTrivia(GreenNode trivia);
    public virtual GreenNode WithTrailingTrivia(GreenNode trivia);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.XmlWhitespaceChecker : VisualBasicSyntaxRewriter {
    private WhiteSpaceOptions _options;
    public virtual VisualBasicSyntaxNode VisitXmlDeclaration(XmlDeclarationSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlElementStartTag(XmlElementStartTagSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlEmptyElement(XmlEmptyElementSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlElementEndTag(XmlElementEndTagSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlNameAttribute(XmlNameAttributeSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlCrefAttribute(XmlCrefAttributeSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlAttribute(XmlAttributeSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlBracketedName(XmlBracketedNameSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlName(XmlNameSyntax node);
    public virtual VisualBasicSyntaxNode VisitXmlPrefix(XmlPrefixSyntax node);
    public virtual SyntaxToken VisitSyntaxToken(SyntaxToken token);
    public virtual SyntaxTrivia VisitSyntaxTrivia(SyntaxTrivia trivia);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.InternalSyntax.YieldStatementSyntax : ExecutableStatementSyntax {
    internal KeywordSyntax _yieldKeyword;
    internal ExpressionSyntax _expression;
    internal static Func`2<ObjectReader, object> CreateInstance;
    internal KeywordSyntax YieldKeyword { get; }
    internal ExpressionSyntax Expression { get; }
    private static YieldStatementSyntax();
    internal YieldStatementSyntax(SyntaxKind kind, KeywordSyntax yieldKeyword, ExpressionSyntax expression);
    internal YieldStatementSyntax(SyntaxKind kind, ISyntaxFactoryContext context, KeywordSyntax yieldKeyword, ExpressionSyntax expression);
    internal YieldStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax yieldKeyword, ExpressionSyntax expression);
    internal YieldStatementSyntax(ObjectReader reader);
    internal virtual void WriteTo(ObjectWriter writer);
    internal virtual Func`2<ObjectReader, object> GetReader();
    internal virtual SyntaxNode CreateRed(SyntaxNode parent, int startLocation);
    internal KeywordSyntax get_YieldKeyword();
    internal ExpressionSyntax get_Expression();
    internal virtual GreenNode GetSlot(int i);
    internal virtual GreenNode SetDiagnostics(DiagnosticInfo[] newErrors);
    internal virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    public virtual VisualBasicSyntaxNode Accept(VisualBasicSyntaxVisitor visitor);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringContentSyntax : VisualBasicSyntaxNode {
    internal InterpolatedStringContentSyntax(GreenNode green, SyntaxNode parent, int startLocation);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringExpressionSyntax : ExpressionSyntax {
    internal SyntaxNode _contents;
    public SyntaxToken DollarSignDoubleQuoteToken { get; }
    public SyntaxList`1<InterpolatedStringContentSyntax> Contents { get; }
    public SyntaxToken DoubleQuoteToken { get; }
    internal InterpolatedStringExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal InterpolatedStringExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax dollarSignDoubleQuoteToken, SyntaxNode contents, PunctuationSyntax doubleQuoteToken);
    public SyntaxToken get_DollarSignDoubleQuoteToken();
    public InterpolatedStringExpressionSyntax WithDollarSignDoubleQuoteToken(SyntaxToken dollarSignDoubleQuoteToken);
    public SyntaxList`1<InterpolatedStringContentSyntax> get_Contents();
    public InterpolatedStringExpressionSyntax WithContents(SyntaxList`1<InterpolatedStringContentSyntax> contents);
    public InterpolatedStringExpressionSyntax AddContents(InterpolatedStringContentSyntax[] items);
    public SyntaxToken get_DoubleQuoteToken();
    public InterpolatedStringExpressionSyntax WithDoubleQuoteToken(SyntaxToken doubleQuoteToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public InterpolatedStringExpressionSyntax Update(SyntaxToken dollarSignDoubleQuoteToken, SyntaxList`1<InterpolatedStringContentSyntax> contents, SyntaxToken doubleQuoteToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolatedStringTextSyntax : InterpolatedStringContentSyntax {
    public SyntaxToken TextToken { get; }
    internal InterpolatedStringTextSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal InterpolatedStringTextSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, InterpolatedStringTextTokenSyntax textToken);
    public SyntaxToken get_TextToken();
    public InterpolatedStringTextSyntax WithTextToken(SyntaxToken textToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public InterpolatedStringTextSyntax Update(SyntaxToken textToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationAlignmentClauseSyntax : VisualBasicSyntaxNode {
    internal ExpressionSyntax _value;
    public SyntaxToken CommaToken { get; }
    public ExpressionSyntax Value { get; }
    internal InterpolationAlignmentClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax commaToken, ExpressionSyntax value);
    public SyntaxToken get_CommaToken();
    public InterpolationAlignmentClauseSyntax WithCommaToken(SyntaxToken commaToken);
    public ExpressionSyntax get_Value();
    public InterpolationAlignmentClauseSyntax WithValue(ExpressionSyntax value);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public InterpolationAlignmentClauseSyntax Update(SyntaxToken commaToken, ExpressionSyntax value);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationFormatClauseSyntax : VisualBasicSyntaxNode {
    public SyntaxToken ColonToken { get; }
    public SyntaxToken FormatStringToken { get; }
    internal InterpolationFormatClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal InterpolationFormatClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax colonToken, InterpolatedStringTextTokenSyntax formatStringToken);
    public SyntaxToken get_ColonToken();
    public InterpolationFormatClauseSyntax WithColonToken(SyntaxToken colonToken);
    public SyntaxToken get_FormatStringToken();
    public InterpolationFormatClauseSyntax WithFormatStringToken(SyntaxToken formatStringToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public InterpolationFormatClauseSyntax Update(SyntaxToken colonToken, SyntaxToken formatStringToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.InterpolationSyntax : InterpolatedStringContentSyntax {
    internal ExpressionSyntax _expression;
    internal InterpolationAlignmentClauseSyntax _alignmentClause;
    internal InterpolationFormatClauseSyntax _formatClause;
    public SyntaxToken OpenBraceToken { get; }
    public ExpressionSyntax Expression { get; }
    public InterpolationAlignmentClauseSyntax AlignmentClause { get; }
    public InterpolationFormatClauseSyntax FormatClause { get; }
    public SyntaxToken CloseBraceToken { get; }
    internal InterpolationSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal InterpolationSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, PunctuationSyntax closeBraceToken);
    public SyntaxToken get_OpenBraceToken();
    public InterpolationSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
    public ExpressionSyntax get_Expression();
    public InterpolationSyntax WithExpression(ExpressionSyntax expression);
    public InterpolationAlignmentClauseSyntax get_AlignmentClause();
    public InterpolationSyntax WithAlignmentClause(InterpolationAlignmentClauseSyntax alignmentClause);
    public InterpolationFormatClauseSyntax get_FormatClause();
    public InterpolationSyntax WithFormatClause(InterpolationFormatClauseSyntax formatClause);
    public SyntaxToken get_CloseBraceToken();
    public InterpolationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public InterpolationSyntax Update(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.InvocationExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax _expression;
    internal ArgumentListSyntax _argumentList;
    public ExpressionSyntax Expression { get; }
    public ArgumentListSyntax ArgumentList { get; }
    internal InvocationExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal InvocationExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax expression, ArgumentListSyntax argumentList);
    public ExpressionSyntax get_Expression();
    public InvocationExpressionSyntax WithExpression(ExpressionSyntax expression);
    public ArgumentListSyntax get_ArgumentList();
    public InvocationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList);
    public InvocationExpressionSyntax AddArgumentListArguments(ArgumentSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public InvocationExpressionSyntax Update(ExpressionSyntax expression, ArgumentListSyntax argumentList);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinClauseSyntax : QueryClauseSyntax {
    internal SyntaxNode _joinedVariables;
    internal SyntaxNode _additionalJoins;
    internal SyntaxNode _joinConditions;
    public SyntaxToken JoinKeyword { get; }
    public SeparatedSyntaxList`1<CollectionRangeVariableSyntax> JoinedVariables { get; }
    public SyntaxList`1<JoinClauseSyntax> AdditionalJoins { get; }
    public SyntaxToken OnKeyword { get; }
    public SeparatedSyntaxList`1<JoinConditionSyntax> JoinConditions { get; }
    internal JoinClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    public SyntaxToken get_JoinKeyword();
    internal virtual SyntaxToken GetJoinKeywordCore();
    public virtual SeparatedSyntaxList`1<CollectionRangeVariableSyntax> get_JoinedVariables();
    public SyntaxList`1<JoinClauseSyntax> get_AdditionalJoins();
    internal virtual SyntaxList`1<JoinClauseSyntax> GetAdditionalJoinsCore();
    public SyntaxToken get_OnKeyword();
    internal virtual SyntaxToken GetOnKeywordCore();
    public virtual SeparatedSyntaxList`1<JoinConditionSyntax> get_JoinConditions();
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.JoinConditionSyntax : VisualBasicSyntaxNode {
    internal ExpressionSyntax _left;
    internal ExpressionSyntax _right;
    public ExpressionSyntax Left { get; }
    public SyntaxToken EqualsKeyword { get; }
    public ExpressionSyntax Right { get; }
    internal JoinConditionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal JoinConditionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax left, KeywordSyntax equalsKeyword, ExpressionSyntax right);
    public ExpressionSyntax get_Left();
    public JoinConditionSyntax WithLeft(ExpressionSyntax left);
    public SyntaxToken get_EqualsKeyword();
    public JoinConditionSyntax WithEqualsKeyword(SyntaxToken equalsKeyword);
    public ExpressionSyntax get_Right();
    public JoinConditionSyntax WithRight(ExpressionSyntax right);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public JoinConditionSyntax Update(ExpressionSyntax left, SyntaxToken equalsKeyword, ExpressionSyntax right);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.KeywordEventContainerSyntax : EventContainerSyntax {
    public SyntaxToken Keyword { get; }
    internal KeywordEventContainerSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal KeywordEventContainerSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword);
    public SyntaxToken get_Keyword();
    public KeywordEventContainerSyntax WithKeyword(SyntaxToken keyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public KeywordEventContainerSyntax Update(SyntaxToken keyword);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.KeywordTable : object {
    private static Dictionary`2<string, SyntaxKind> s_keywords;
    private static Dictionary`2<ushort, KeywordDescription> s_keywordProperties;
    private static KeywordTable();
    internal static SyntaxKind TokenOfString(string tokenName);
    private static string EnsureHalfWidth(string s);
    internal static bool CanFollowExpression(SyntaxKind kind);
    internal static bool IsQueryClause(SyntaxKind kind);
    internal static OperatorPrecedence TokenOpPrec(SyntaxKind kind);
    private static void AddKeyword(SyntaxKind Token, bool New7To8, OperatorPrecedence Precedence, bool isQueryClause, bool canFollowExpr);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelStatementSyntax : ExecutableStatementSyntax {
    public SyntaxToken LabelToken { get; }
    public SyntaxToken ColonToken { get; }
    internal LabelStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal LabelStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxToken labelToken, PunctuationSyntax colonToken);
    public SyntaxToken get_LabelToken();
    public LabelStatementSyntax WithLabelToken(SyntaxToken labelToken);
    public SyntaxToken get_ColonToken();
    public LabelStatementSyntax WithColonToken(SyntaxToken colonToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public LabelStatementSyntax Update(SyntaxToken labelToken, SyntaxToken colonToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.LabelSyntax : ExpressionSyntax {
    public SyntaxToken LabelToken { get; }
    internal LabelSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal LabelSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxToken labelToken);
    public SyntaxToken get_LabelToken();
    public LabelSyntax WithLabelToken(SyntaxToken labelToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public LabelSyntax Update(SyntaxKind kind, SyntaxToken labelToken);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaExpressionSyntax : ExpressionSyntax {
    internal LambdaHeaderSyntax _subOrFunctionHeader;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use SubOrFunctionHeader instead.", "True")]
public LambdaHeaderSyntax Begin { get; }
    public LambdaHeaderSyntax SubOrFunctionHeader { get; }
    internal LambdaExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    public LambdaHeaderSyntax get_Begin();
    public LambdaHeaderSyntax get_SubOrFunctionHeader();
    internal virtual LambdaHeaderSyntax GetSubOrFunctionHeaderCore();
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.LambdaHeaderSyntax : MethodBaseSyntax {
    internal SimpleAsClauseSyntax _asClause;
    public SyntaxToken DeclarationKeyword { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public SyntaxToken Keyword { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken SubOrFunctionKeyword { get; }
    public ParameterListSyntax ParameterList { get; }
    public SimpleAsClauseSyntax AsClause { get; }
    internal LambdaHeaderSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal LambdaHeaderSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode attributeLists, GreenNode modifiers, KeywordSyntax subOrFunctionKeyword, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public virtual SyntaxToken get_DeclarationKeyword();
    public virtual MethodBaseSyntax WithDeclarationKeyword(SyntaxToken keyword);
    public SyntaxToken get_Keyword();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public LambdaHeaderSyntax WithKeyword(SyntaxToken keyword);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual SyntaxList`1<AttributeListSyntax> GetAttributeListsCore();
    public LambdaHeaderSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public LambdaHeaderSyntax AddAttributeLists(AttributeListSyntax[] items);
    public SyntaxTokenList get_Modifiers();
    internal virtual SyntaxTokenList GetModifiersCore();
    public LambdaHeaderSyntax WithModifiers(SyntaxTokenList modifiers);
    public LambdaHeaderSyntax AddModifiers(SyntaxToken[] items);
    public SyntaxToken get_SubOrFunctionKeyword();
    public LambdaHeaderSyntax WithSubOrFunctionKeyword(SyntaxToken subOrFunctionKeyword);
    public ParameterListSyntax get_ParameterList();
    internal virtual ParameterListSyntax GetParameterListCore();
    public LambdaHeaderSyntax WithParameterList(ParameterListSyntax parameterList);
    public LambdaHeaderSyntax AddParameterListParameters(ParameterSyntax[] items);
    public SimpleAsClauseSyntax get_AsClause();
    public LambdaHeaderSyntax WithAsClause(SimpleAsClauseSyntax asClause);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public LambdaHeaderSyntax Update(SyntaxKind kind, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken subOrFunctionKeyword, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.LetClauseSyntax : QueryClauseSyntax {
    internal SyntaxNode _variables;
    public SyntaxToken LetKeyword { get; }
    public SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> Variables { get; }
    internal LetClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal LetClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax letKeyword, SyntaxNode variables);
    public SyntaxToken get_LetKeyword();
    public LetClauseSyntax WithLetKeyword(SyntaxToken letKeyword);
    public SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> get_Variables();
    public LetClauseSyntax WithVariables(SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> variables);
    public LetClauseSyntax AddVariables(ExpressionRangeVariableSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public LetClauseSyntax Update(SyntaxToken letKeyword, SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> variables);
}
public enum Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralBase : Enum {
    public int value__;
    public static LiteralBase Decimal;
    public static LiteralBase Hexadecimal;
    public static LiteralBase Octal;
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.LiteralExpressionSyntax : ExpressionSyntax {
    public SyntaxToken Token { get; }
    internal LiteralExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal LiteralExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxToken token);
    public SyntaxToken get_Token();
    public LiteralExpressionSyntax WithToken(SyntaxToken token);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public LiteralExpressionSyntax Update(SyntaxKind kind, SyntaxToken token);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.LocalDeclarationStatementSyntax : ExecutableStatementSyntax {
    internal SyntaxNode _declarators;
    public SyntaxTokenList Modifiers { get; }
    public SeparatedSyntaxList`1<VariableDeclaratorSyntax> Declarators { get; }
    internal LocalDeclarationStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal LocalDeclarationStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode modifiers, SyntaxNode declarators);
    public SyntaxTokenList get_Modifiers();
    public LocalDeclarationStatementSyntax WithModifiers(SyntaxTokenList modifiers);
    public LocalDeclarationStatementSyntax AddModifiers(SyntaxToken[] items);
    public SeparatedSyntaxList`1<VariableDeclaratorSyntax> get_Declarators();
    public LocalDeclarationStatementSyntax WithDeclarators(SeparatedSyntaxList`1<VariableDeclaratorSyntax> declarators);
    public LocalDeclarationStatementSyntax AddDeclarators(VariableDeclaratorSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public LocalDeclarationStatementSyntax Update(SyntaxTokenList modifiers, SeparatedSyntaxList`1<VariableDeclaratorSyntax> declarators);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.LoopStatementSyntax : StatementSyntax {
    internal WhileOrUntilClauseSyntax _whileOrUntilClause;
    public SyntaxToken LoopKeyword { get; }
    public WhileOrUntilClauseSyntax WhileOrUntilClause { get; }
    internal LoopStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal LoopStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax loopKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    public SyntaxToken get_LoopKeyword();
    public LoopStatementSyntax WithLoopKeyword(SyntaxToken loopKeyword);
    public WhileOrUntilClauseSyntax get_WhileOrUntilClause();
    public LoopStatementSyntax WithWhileOrUntilClause(WhileOrUntilClauseSyntax whileOrUntilClause);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public LoopStatementSyntax Update(SyntaxKind kind, SyntaxToken loopKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.MeExpressionSyntax : InstanceExpressionSyntax {
    public SyntaxToken Keyword { get; }
    internal MeExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal MeExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword);
    public SyntaxToken get_Keyword();
    internal virtual SyntaxToken GetKeywordCore();
    public MeExpressionSyntax WithKeyword(SyntaxToken keyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public MeExpressionSyntax Update(SyntaxToken keyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.MemberAccessExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax _expression;
    internal SimpleNameSyntax _name;
    public ExpressionSyntax Expression { get; }
    public SyntaxToken OperatorToken { get; }
    public SimpleNameSyntax Name { get; }
    internal MemberAccessExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal MemberAccessExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax expression, PunctuationSyntax operatorToken, SimpleNameSyntax name);
    public ExpressionSyntax get_Expression();
    public MemberAccessExpressionSyntax WithExpression(ExpressionSyntax expression);
    public SyntaxToken get_OperatorToken();
    public MemberAccessExpressionSyntax WithOperatorToken(SyntaxToken operatorToken);
    public SimpleNameSyntax get_Name();
    public MemberAccessExpressionSyntax WithName(SimpleNameSyntax name);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public MemberAccessExpressionSyntax Update(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBaseSyntax : DeclarationStatementSyntax {
    internal SyntaxNode _attributeLists;
    internal ParameterListSyntax _parameterList;
    public SyntaxToken DeclarationKeyword { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use DeclarationKeyword or a more specific property (e.g. SubOrFunctionKeyword) instead.", "True")]
public SyntaxToken Keyword { get; }
    internal AsClauseSyntax AsClauseInternal { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public ParameterListSyntax ParameterList { get; }
    internal MethodBaseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    public abstract virtual SyntaxToken get_DeclarationKeyword();
    public abstract virtual MethodBaseSyntax WithDeclarationKeyword(SyntaxToken keyword);
    public SyntaxToken get_Keyword();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use DeclarationKeyword or a more specific property (e.g. WithSubOrFunctionKeyword) instead.", "True")]
public MethodBaseSyntax WithKeyword(SyntaxToken keyword);
    internal AsClauseSyntax get_AsClauseInternal();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual SyntaxList`1<AttributeListSyntax> GetAttributeListsCore();
    public SyntaxTokenList get_Modifiers();
    internal virtual SyntaxTokenList GetModifiersCore();
    public ParameterListSyntax get_ParameterList();
    internal virtual ParameterListSyntax GetParameterListCore();
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockBaseSyntax : DeclarationStatementSyntax {
    internal SyntaxNode _statements;
    public MethodBaseSyntax BlockStatement { get; }
    public EndBlockStatementSyntax EndBlockStatement { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use BlockStatement or a more specific property (e.g. SubOrFunctionStatement) instead.", "True")]
public MethodBaseSyntax Begin { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use EndBlockStatement or a more specific property (e.g. EndSubOrFunctionStatement) instead.", "True")]
public EndBlockStatementSyntax End { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    internal MethodBlockBaseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    public abstract virtual MethodBaseSyntax get_BlockStatement();
    public abstract virtual EndBlockStatementSyntax get_EndBlockStatement();
    public abstract virtual MethodBlockBaseSyntax WithBlockStatement(MethodBaseSyntax blockStatement);
    public abstract virtual MethodBlockBaseSyntax WithEndBlockStatement(EndBlockStatementSyntax endBlockStatement);
    public MethodBaseSyntax get_Begin();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use WithBlockStatement or a more specific property (e.g. WithSubOrFunctionStatement) instead.", "True")]
public MethodBlockBaseSyntax WithBegin(MethodBaseSyntax begin);
    public EndBlockStatementSyntax get_End();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use WithEndBlockStatement or a more specific property (e.g. WithEndSubOrFunctionStatement) instead.", "True")]
public MethodBlockBaseSyntax WithEnd(EndBlockStatementSyntax end);
    public SyntaxList`1<StatementSyntax> get_Statements();
    internal virtual SyntaxList`1<StatementSyntax> GetStatementsCore();
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodBlockSyntax : MethodBlockBaseSyntax {
    internal MethodStatementSyntax _subOrFunctionStatement;
    internal EndBlockStatementSyntax _endSubOrFunctionStatement;
    public MethodBaseSyntax BlockStatement { get; }
    public EndBlockStatementSyntax EndBlockStatement { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public MethodStatementSyntax Begin { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public EndBlockStatementSyntax End { get; }
    public MethodStatementSyntax SubOrFunctionStatement { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    public EndBlockStatementSyntax EndSubOrFunctionStatement { get; }
    internal MethodBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal MethodBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, MethodStatementSyntax subOrFunctionStatement, SyntaxNode statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    public virtual MethodBaseSyntax get_BlockStatement();
    public virtual EndBlockStatementSyntax get_EndBlockStatement();
    public virtual MethodBlockBaseSyntax WithBlockStatement(MethodBaseSyntax blockStatement);
    public virtual MethodBlockBaseSyntax WithEndBlockStatement(EndBlockStatementSyntax endBlockStatement);
    public MethodStatementSyntax get_Begin();
    public EndBlockStatementSyntax get_End();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public MethodBlockSyntax WithBegin(MethodStatementSyntax begin);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public MethodBlockSyntax WithEnd(EndBlockStatementSyntax end);
    public MethodStatementSyntax get_SubOrFunctionStatement();
    public MethodBlockSyntax WithSubOrFunctionStatement(MethodStatementSyntax subOrFunctionStatement);
    public SyntaxList`1<StatementSyntax> get_Statements();
    internal virtual SyntaxList`1<StatementSyntax> GetStatementsCore();
    public MethodBlockSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public MethodBlockSyntax AddStatements(StatementSyntax[] items);
    public EndBlockStatementSyntax get_EndSubOrFunctionStatement();
    public MethodBlockSyntax WithEndSubOrFunctionStatement(EndBlockStatementSyntax endSubOrFunctionStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public MethodBlockSyntax Update(SyntaxKind kind, MethodStatementSyntax subOrFunctionStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.MethodStatementSyntax : MethodBaseSyntax {
    internal TypeParameterListSyntax _typeParameterList;
    internal SimpleAsClauseSyntax _asClause;
    internal HandlesClauseSyntax _handlesClause;
    internal ImplementsClauseSyntax _implementsClause;
    public SyntaxToken DeclarationKeyword { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public SyntaxToken Keyword { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken SubOrFunctionKeyword { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    public ParameterListSyntax ParameterList { get; }
    public SimpleAsClauseSyntax AsClause { get; }
    public HandlesClauseSyntax HandlesClause { get; }
    public ImplementsClauseSyntax ImplementsClause { get; }
    internal MethodStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal MethodStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode attributeLists, GreenNode modifiers, KeywordSyntax subOrFunctionKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, HandlesClauseSyntax handlesClause, ImplementsClauseSyntax implementsClause);
    public virtual SyntaxToken get_DeclarationKeyword();
    public virtual MethodBaseSyntax WithDeclarationKeyword(SyntaxToken keyword);
    public SyntaxToken get_Keyword();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public MethodStatementSyntax WithKeyword(SyntaxToken keyword);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual SyntaxList`1<AttributeListSyntax> GetAttributeListsCore();
    public MethodStatementSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public MethodStatementSyntax AddAttributeLists(AttributeListSyntax[] items);
    public SyntaxTokenList get_Modifiers();
    internal virtual SyntaxTokenList GetModifiersCore();
    public MethodStatementSyntax WithModifiers(SyntaxTokenList modifiers);
    public MethodStatementSyntax AddModifiers(SyntaxToken[] items);
    public SyntaxToken get_SubOrFunctionKeyword();
    public MethodStatementSyntax WithSubOrFunctionKeyword(SyntaxToken subOrFunctionKeyword);
    public SyntaxToken get_Identifier();
    public MethodStatementSyntax WithIdentifier(SyntaxToken identifier);
    public TypeParameterListSyntax get_TypeParameterList();
    public MethodStatementSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList);
    public MethodStatementSyntax AddTypeParameterListParameters(TypeParameterSyntax[] items);
    public ParameterListSyntax get_ParameterList();
    internal virtual ParameterListSyntax GetParameterListCore();
    public MethodStatementSyntax WithParameterList(ParameterListSyntax parameterList);
    public MethodStatementSyntax AddParameterListParameters(ParameterSyntax[] items);
    public SimpleAsClauseSyntax get_AsClause();
    public MethodStatementSyntax WithAsClause(SimpleAsClauseSyntax asClause);
    public HandlesClauseSyntax get_HandlesClause();
    public MethodStatementSyntax WithHandlesClause(HandlesClauseSyntax handlesClause);
    public MethodStatementSyntax AddHandlesClauseEvents(HandlesClauseItemSyntax[] items);
    public ImplementsClauseSyntax get_ImplementsClause();
    public MethodStatementSyntax WithImplementsClause(ImplementsClauseSyntax implementsClause);
    public MethodStatementSyntax AddImplementsClauseInterfaceMembers(QualifiedNameSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public MethodStatementSyntax Update(SyntaxKind kind, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, HandlesClauseSyntax handlesClause, ImplementsClauseSyntax implementsClause);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.MidExpressionSyntax : ExpressionSyntax {
    internal ArgumentListSyntax _argumentList;
    public SyntaxToken Mid { get; }
    public ArgumentListSyntax ArgumentList { get; }
    internal MidExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal MidExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, IdentifierTokenSyntax mid, ArgumentListSyntax argumentList);
    public SyntaxToken get_Mid();
    public MidExpressionSyntax WithMid(SyntaxToken mid);
    public ArgumentListSyntax get_ArgumentList();
    public MidExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList);
    public MidExpressionSyntax AddArgumentListArguments(ArgumentSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public MidExpressionSyntax Update(SyntaxToken mid, ArgumentListSyntax argumentList);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ModifiedIdentifierSyntax : VisualBasicSyntaxNode {
    internal ArgumentListSyntax _arrayBounds;
    internal SyntaxNode _arrayRankSpecifiers;
    public SyntaxToken Identifier { get; }
    public SyntaxToken Nullable { get; }
    public ArgumentListSyntax ArrayBounds { get; }
    public SyntaxList`1<ArrayRankSpecifierSyntax> ArrayRankSpecifiers { get; }
    internal ModifiedIdentifierSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ModifiedIdentifierSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, IdentifierTokenSyntax identifier, PunctuationSyntax nullable, ArgumentListSyntax arrayBounds, SyntaxNode arrayRankSpecifiers);
    public SyntaxToken get_Identifier();
    public ModifiedIdentifierSyntax WithIdentifier(SyntaxToken identifier);
    public SyntaxToken get_Nullable();
    public ModifiedIdentifierSyntax WithNullable(SyntaxToken nullable);
    public ArgumentListSyntax get_ArrayBounds();
    public ModifiedIdentifierSyntax WithArrayBounds(ArgumentListSyntax arrayBounds);
    public ModifiedIdentifierSyntax AddArrayBoundsArguments(ArgumentSyntax[] items);
    public SyntaxList`1<ArrayRankSpecifierSyntax> get_ArrayRankSpecifiers();
    public ModifiedIdentifierSyntax WithArrayRankSpecifiers(SyntaxList`1<ArrayRankSpecifierSyntax> arrayRankSpecifiers);
    public ModifiedIdentifierSyntax AddArrayRankSpecifiers(ArrayRankSpecifierSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ModifiedIdentifierSyntax Update(SyntaxToken identifier, SyntaxToken nullable, ArgumentListSyntax arrayBounds, SyntaxList`1<ArrayRankSpecifierSyntax> arrayRankSpecifiers);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleBlockSyntax : TypeBlockSyntax {
    internal ModuleStatementSyntax _moduleStatement;
    internal EndBlockStatementSyntax _endModuleStatement;
    public TypeStatementSyntax BlockStatement { get; }
    public EndBlockStatementSyntax EndBlockStatement { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public ModuleStatementSyntax Begin { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public EndBlockStatementSyntax End { get; }
    public ModuleStatementSyntax ModuleStatement { get; }
    public SyntaxList`1<InheritsStatementSyntax> Inherits { get; }
    public SyntaxList`1<ImplementsStatementSyntax> Implements { get; }
    public SyntaxList`1<StatementSyntax> Members { get; }
    public EndBlockStatementSyntax EndModuleStatement { get; }
    internal ModuleBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ModuleBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ModuleStatementSyntax moduleStatement, SyntaxNode inherits, SyntaxNode implements, SyntaxNode members, EndBlockStatementSyntax endModuleStatement);
    public virtual TypeStatementSyntax get_BlockStatement();
    public virtual EndBlockStatementSyntax get_EndBlockStatement();
    public virtual TypeBlockSyntax WithBlockStatement(TypeStatementSyntax blockStatement);
    public virtual TypeBlockSyntax WithEndBlockStatement(EndBlockStatementSyntax endBlockStatement);
    public ModuleStatementSyntax get_Begin();
    public EndBlockStatementSyntax get_End();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public ModuleBlockSyntax WithBegin(ModuleStatementSyntax begin);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public ModuleBlockSyntax WithEnd(EndBlockStatementSyntax end);
    public ModuleStatementSyntax get_ModuleStatement();
    public ModuleBlockSyntax WithModuleStatement(ModuleStatementSyntax moduleStatement);
    public SyntaxList`1<InheritsStatementSyntax> get_Inherits();
    internal virtual SyntaxList`1<InheritsStatementSyntax> GetInheritsCore();
    public ModuleBlockSyntax WithInherits(SyntaxList`1<InheritsStatementSyntax> inherits);
    public ModuleBlockSyntax AddInherits(InheritsStatementSyntax[] items);
    public SyntaxList`1<ImplementsStatementSyntax> get_Implements();
    internal virtual SyntaxList`1<ImplementsStatementSyntax> GetImplementsCore();
    public ModuleBlockSyntax WithImplements(SyntaxList`1<ImplementsStatementSyntax> implements);
    public ModuleBlockSyntax AddImplements(ImplementsStatementSyntax[] items);
    public SyntaxList`1<StatementSyntax> get_Members();
    internal virtual SyntaxList`1<StatementSyntax> GetMembersCore();
    public ModuleBlockSyntax WithMembers(SyntaxList`1<StatementSyntax> members);
    public ModuleBlockSyntax AddMembers(StatementSyntax[] items);
    public EndBlockStatementSyntax get_EndModuleStatement();
    public ModuleBlockSyntax WithEndModuleStatement(EndBlockStatementSyntax endModuleStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ModuleBlockSyntax Update(ModuleStatementSyntax moduleStatement, SyntaxList`1<InheritsStatementSyntax> inherits, SyntaxList`1<ImplementsStatementSyntax> implements, SyntaxList`1<StatementSyntax> members, EndBlockStatementSyntax endModuleStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ModuleStatementSyntax : TypeStatementSyntax {
    public SyntaxToken DeclarationKeyword { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public SyntaxToken Keyword { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken ModuleKeyword { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    internal ModuleStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ModuleStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode attributeLists, GreenNode modifiers, KeywordSyntax moduleKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    public virtual SyntaxToken get_DeclarationKeyword();
    public virtual TypeStatementSyntax WithDeclarationKeyword(SyntaxToken keyword);
    public SyntaxToken get_Keyword();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public ModuleStatementSyntax WithKeyword(SyntaxToken keyword);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual SyntaxList`1<AttributeListSyntax> GetAttributeListsCore();
    public ModuleStatementSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public ModuleStatementSyntax AddAttributeLists(AttributeListSyntax[] items);
    public SyntaxTokenList get_Modifiers();
    internal virtual SyntaxTokenList GetModifiersCore();
    public ModuleStatementSyntax WithModifiers(SyntaxTokenList modifiers);
    public ModuleStatementSyntax AddModifiers(SyntaxToken[] items);
    public SyntaxToken get_ModuleKeyword();
    public ModuleStatementSyntax WithModuleKeyword(SyntaxToken moduleKeyword);
    public SyntaxToken get_Identifier();
    internal virtual SyntaxToken GetIdentifierCore();
    public ModuleStatementSyntax WithIdentifier(SyntaxToken identifier);
    public TypeParameterListSyntax get_TypeParameterList();
    internal virtual TypeParameterListSyntax GetTypeParameterListCore();
    public ModuleStatementSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList);
    public ModuleStatementSyntax AddTypeParameterListParameters(TypeParameterSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ModuleStatementSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken moduleKeyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineIfBlockSyntax : ExecutableStatementSyntax {
    internal IfStatementSyntax _ifStatement;
    internal SyntaxNode _statements;
    internal SyntaxNode _elseIfBlocks;
    internal ElseBlockSyntax _elseBlock;
    internal EndBlockStatementSyntax _endIfStatement;
    public IfStatementSyntax IfStatement { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    public SyntaxList`1<ElseIfBlockSyntax> ElseIfBlocks { get; }
    public ElseBlockSyntax ElseBlock { get; }
    public EndBlockStatementSyntax EndIfStatement { get; }
    internal MultiLineIfBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal MultiLineIfBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, IfStatementSyntax ifStatement, SyntaxNode statements, SyntaxNode elseIfBlocks, ElseBlockSyntax elseBlock, EndBlockStatementSyntax endIfStatement);
    public IfStatementSyntax get_IfStatement();
    public MultiLineIfBlockSyntax WithIfStatement(IfStatementSyntax ifStatement);
    public SyntaxList`1<StatementSyntax> get_Statements();
    public MultiLineIfBlockSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public MultiLineIfBlockSyntax AddStatements(StatementSyntax[] items);
    public SyntaxList`1<ElseIfBlockSyntax> get_ElseIfBlocks();
    public MultiLineIfBlockSyntax WithElseIfBlocks(SyntaxList`1<ElseIfBlockSyntax> elseIfBlocks);
    public MultiLineIfBlockSyntax AddElseIfBlocks(ElseIfBlockSyntax[] items);
    public ElseBlockSyntax get_ElseBlock();
    public MultiLineIfBlockSyntax WithElseBlock(ElseBlockSyntax elseBlock);
    public MultiLineIfBlockSyntax AddElseBlockStatements(StatementSyntax[] items);
    public EndBlockStatementSyntax get_EndIfStatement();
    public MultiLineIfBlockSyntax WithEndIfStatement(EndBlockStatementSyntax endIfStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public MultiLineIfBlockSyntax Update(IfStatementSyntax ifStatement, SyntaxList`1<StatementSyntax> statements, SyntaxList`1<ElseIfBlockSyntax> elseIfBlocks, ElseBlockSyntax elseBlock, EndBlockStatementSyntax endIfStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.MultiLineLambdaExpressionSyntax : LambdaExpressionSyntax {
    internal SyntaxNode _statements;
    internal EndBlockStatementSyntax _endSubOrFunctionStatement;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use SubOrFunctionHeader instead.", "True")]
public LambdaHeaderSyntax Begin { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use EndBlockStatement or a more specific property (e.g. EndClassStatement) instead.", "True")]
public EndBlockStatementSyntax End { get; }
    public LambdaHeaderSyntax SubOrFunctionHeader { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    public EndBlockStatementSyntax EndSubOrFunctionStatement { get; }
    internal MultiLineLambdaExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal MultiLineLambdaExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, LambdaHeaderSyntax subOrFunctionHeader, SyntaxNode statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    public LambdaHeaderSyntax get_Begin();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use WithBlockStatement or a more specific property (e.g. WithClassStatement) instead.", "True")]
public MultiLineLambdaExpressionSyntax WithBegin(LambdaHeaderSyntax begin);
    public EndBlockStatementSyntax get_End();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use WithEndBlockStatement or a more specific property (e.g. WithEndClassStatement) instead.", "True")]
public MultiLineLambdaExpressionSyntax WithEnd(EndBlockStatementSyntax end);
    public LambdaHeaderSyntax get_SubOrFunctionHeader();
    internal virtual LambdaHeaderSyntax GetSubOrFunctionHeaderCore();
    public MultiLineLambdaExpressionSyntax WithSubOrFunctionHeader(LambdaHeaderSyntax subOrFunctionHeader);
    public SyntaxList`1<StatementSyntax> get_Statements();
    public MultiLineLambdaExpressionSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public MultiLineLambdaExpressionSyntax AddStatements(StatementSyntax[] items);
    public EndBlockStatementSyntax get_EndSubOrFunctionStatement();
    public MultiLineLambdaExpressionSyntax WithEndSubOrFunctionStatement(EndBlockStatementSyntax endSubOrFunctionStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public MultiLineLambdaExpressionSyntax Update(SyntaxKind kind, LambdaHeaderSyntax subOrFunctionHeader, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.MyBaseExpressionSyntax : InstanceExpressionSyntax {
    public SyntaxToken Keyword { get; }
    internal MyBaseExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal MyBaseExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword);
    public SyntaxToken get_Keyword();
    internal virtual SyntaxToken GetKeywordCore();
    public MyBaseExpressionSyntax WithKeyword(SyntaxToken keyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public MyBaseExpressionSyntax Update(SyntaxToken keyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.MyClassExpressionSyntax : InstanceExpressionSyntax {
    public SyntaxToken Keyword { get; }
    internal MyClassExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal MyClassExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword);
    public SyntaxToken get_Keyword();
    internal virtual SyntaxToken GetKeywordCore();
    public MyClassExpressionSyntax WithKeyword(SyntaxToken keyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public MyClassExpressionSyntax Update(SyntaxToken keyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.NameColonEqualsSyntax : VisualBasicSyntaxNode {
    internal IdentifierNameSyntax _name;
    public IdentifierNameSyntax Name { get; }
    public SyntaxToken ColonEqualsToken { get; }
    internal NameColonEqualsSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal NameColonEqualsSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, IdentifierNameSyntax name, PunctuationSyntax colonEqualsToken);
    public IdentifierNameSyntax get_Name();
    public NameColonEqualsSyntax WithName(IdentifierNameSyntax name);
    public SyntaxToken get_ColonEqualsToken();
    public NameColonEqualsSyntax WithColonEqualsToken(SyntaxToken colonEqualsToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public NameColonEqualsSyntax Update(IdentifierNameSyntax name, SyntaxToken colonEqualsToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.NamedFieldInitializerSyntax : FieldInitializerSyntax {
    internal IdentifierNameSyntax _name;
    internal ExpressionSyntax _expression;
    public SyntaxToken KeyKeyword { get; }
    public SyntaxToken DotToken { get; }
    public IdentifierNameSyntax Name { get; }
    public SyntaxToken EqualsToken { get; }
    public ExpressionSyntax Expression { get; }
    internal NamedFieldInitializerSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal NamedFieldInitializerSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyKeyword, PunctuationSyntax dotToken, IdentifierNameSyntax name, PunctuationSyntax equalsToken, ExpressionSyntax expression);
    public SyntaxToken get_KeyKeyword();
    internal virtual SyntaxToken GetKeyKeywordCore();
    public NamedFieldInitializerSyntax WithKeyKeyword(SyntaxToken keyKeyword);
    public SyntaxToken get_DotToken();
    public NamedFieldInitializerSyntax WithDotToken(SyntaxToken dotToken);
    public IdentifierNameSyntax get_Name();
    public NamedFieldInitializerSyntax WithName(IdentifierNameSyntax name);
    public SyntaxToken get_EqualsToken();
    public NamedFieldInitializerSyntax WithEqualsToken(SyntaxToken equalsToken);
    public ExpressionSyntax get_Expression();
    public NamedFieldInitializerSyntax WithExpression(ExpressionSyntax expression);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public NamedFieldInitializerSyntax Update(SyntaxToken keyKeyword, SyntaxToken dotToken, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax expression);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.NameOfExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax _argument;
    public SyntaxToken NameOfKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Argument { get; }
    public SyntaxToken CloseParenToken { get; }
    internal NameOfExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal NameOfExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax nameOfKeyword, PunctuationSyntax openParenToken, ExpressionSyntax argument, PunctuationSyntax closeParenToken);
    public SyntaxToken get_NameOfKeyword();
    public NameOfExpressionSyntax WithNameOfKeyword(SyntaxToken nameOfKeyword);
    public SyntaxToken get_OpenParenToken();
    public NameOfExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public ExpressionSyntax get_Argument();
    public NameOfExpressionSyntax WithArgument(ExpressionSyntax argument);
    public SyntaxToken get_CloseParenToken();
    public NameOfExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public NameOfExpressionSyntax Update(SyntaxToken nameOfKeyword, SyntaxToken openParenToken, ExpressionSyntax argument, SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceBlockSyntax : DeclarationStatementSyntax {
    internal NamespaceStatementSyntax _namespaceStatement;
    internal SyntaxNode _members;
    internal EndBlockStatementSyntax _endNamespaceStatement;
    public NamespaceStatementSyntax NamespaceStatement { get; }
    public SyntaxList`1<StatementSyntax> Members { get; }
    public EndBlockStatementSyntax EndNamespaceStatement { get; }
    internal NamespaceBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal NamespaceBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, NamespaceStatementSyntax namespaceStatement, SyntaxNode members, EndBlockStatementSyntax endNamespaceStatement);
    public NamespaceStatementSyntax get_NamespaceStatement();
    public NamespaceBlockSyntax WithNamespaceStatement(NamespaceStatementSyntax namespaceStatement);
    public SyntaxList`1<StatementSyntax> get_Members();
    public NamespaceBlockSyntax WithMembers(SyntaxList`1<StatementSyntax> members);
    public NamespaceBlockSyntax AddMembers(StatementSyntax[] items);
    public EndBlockStatementSyntax get_EndNamespaceStatement();
    public NamespaceBlockSyntax WithEndNamespaceStatement(EndBlockStatementSyntax endNamespaceStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public NamespaceBlockSyntax Update(NamespaceStatementSyntax namespaceStatement, SyntaxList`1<StatementSyntax> members, EndBlockStatementSyntax endNamespaceStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.NamespaceStatementSyntax : DeclarationStatementSyntax {
    internal NameSyntax _name;
    public SyntaxToken NamespaceKeyword { get; }
    public NameSyntax Name { get; }
    internal NamespaceStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal NamespaceStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax namespaceKeyword, NameSyntax name);
    public SyntaxToken get_NamespaceKeyword();
    public NamespaceStatementSyntax WithNamespaceKeyword(SyntaxToken namespaceKeyword);
    public NameSyntax get_Name();
    public NamespaceStatementSyntax WithName(NameSyntax name);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public NamespaceStatementSyntax Update(SyntaxToken namespaceKeyword, NameSyntax name);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.NameSyntax : TypeSyntax {
    public int Arity { get; }
    internal NameSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    public int get_Arity();
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.NewExpressionSyntax : ExpressionSyntax {
    internal SyntaxNode _attributeLists;
    public SyntaxToken NewKeyword { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    internal NewExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    public SyntaxToken get_NewKeyword();
    internal virtual SyntaxToken GetNewKeywordCore();
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual SyntaxList`1<AttributeListSyntax> GetAttributeListsCore();
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.NextStatementSyntax : StatementSyntax {
    internal SyntaxNode _controlVariables;
    public SyntaxToken NextKeyword { get; }
    public SeparatedSyntaxList`1<ExpressionSyntax> ControlVariables { get; }
    internal NextStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal NextStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax nextKeyword, SyntaxNode controlVariables);
    public SyntaxToken get_NextKeyword();
    public NextStatementSyntax WithNextKeyword(SyntaxToken nextKeyword);
    public SeparatedSyntaxList`1<ExpressionSyntax> get_ControlVariables();
    public NextStatementSyntax WithControlVariables(SeparatedSyntaxList`1<ExpressionSyntax> controlVariables);
    public NextStatementSyntax AddControlVariables(ExpressionSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public NextStatementSyntax Update(SyntaxToken nextKeyword, SeparatedSyntaxList`1<ExpressionSyntax> controlVariables);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.NullableTypeSyntax : TypeSyntax {
    internal TypeSyntax _elementType;
    public TypeSyntax ElementType { get; }
    public SyntaxToken QuestionMarkToken { get; }
    internal NullableTypeSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal NullableTypeSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, TypeSyntax elementType, PunctuationSyntax questionMarkToken);
    public TypeSyntax get_ElementType();
    public NullableTypeSyntax WithElementType(TypeSyntax elementType);
    public SyntaxToken get_QuestionMarkToken();
    public NullableTypeSyntax WithQuestionMarkToken(SyntaxToken questionMarkToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public NullableTypeSyntax Update(TypeSyntax elementType, SyntaxToken questionMarkToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCollectionInitializerSyntax : ObjectCreationInitializerSyntax {
    internal CollectionInitializerSyntax _initializer;
    public SyntaxToken FromKeyword { get; }
    public CollectionInitializerSyntax Initializer { get; }
    internal ObjectCollectionInitializerSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ObjectCollectionInitializerSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax fromKeyword, CollectionInitializerSyntax initializer);
    public SyntaxToken get_FromKeyword();
    public ObjectCollectionInitializerSyntax WithFromKeyword(SyntaxToken fromKeyword);
    public CollectionInitializerSyntax get_Initializer();
    public ObjectCollectionInitializerSyntax WithInitializer(CollectionInitializerSyntax initializer);
    public ObjectCollectionInitializerSyntax AddInitializerInitializers(ExpressionSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ObjectCollectionInitializerSyntax Update(SyntaxToken fromKeyword, CollectionInitializerSyntax initializer);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationExpressionSyntax : NewExpressionSyntax {
    internal TypeSyntax _type;
    internal ArgumentListSyntax _argumentList;
    internal ObjectCreationInitializerSyntax _initializer;
    public SyntaxToken NewKeyword { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public TypeSyntax Type { get; }
    public ArgumentListSyntax ArgumentList { get; }
    public ObjectCreationInitializerSyntax Initializer { get; }
    internal ObjectCreationExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ObjectCreationExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax newKeyword, SyntaxNode attributeLists, TypeSyntax type, ArgumentListSyntax argumentList, ObjectCreationInitializerSyntax initializer);
    public SyntaxToken get_NewKeyword();
    internal virtual SyntaxToken GetNewKeywordCore();
    public ObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual SyntaxList`1<AttributeListSyntax> GetAttributeListsCore();
    public ObjectCreationExpressionSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public ObjectCreationExpressionSyntax AddAttributeLists(AttributeListSyntax[] items);
    public TypeSyntax get_Type();
    public ObjectCreationExpressionSyntax WithType(TypeSyntax type);
    public ArgumentListSyntax get_ArgumentList();
    public ObjectCreationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList);
    public ObjectCreationExpressionSyntax AddArgumentListArguments(ArgumentSyntax[] items);
    public ObjectCreationInitializerSyntax get_Initializer();
    public ObjectCreationExpressionSyntax WithInitializer(ObjectCreationInitializerSyntax initializer);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxList`1<AttributeListSyntax> attributeLists, TypeSyntax type, ArgumentListSyntax argumentList, ObjectCreationInitializerSyntax initializer);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectCreationInitializerSyntax : VisualBasicSyntaxNode {
    internal ObjectCreationInitializerSyntax(GreenNode green, SyntaxNode parent, int startLocation);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ObjectMemberInitializerSyntax : ObjectCreationInitializerSyntax {
    internal SyntaxNode _initializers;
    public SyntaxToken WithKeyword { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SeparatedSyntaxList`1<FieldInitializerSyntax> Initializers { get; }
    public SyntaxToken CloseBraceToken { get; }
    internal ObjectMemberInitializerSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ObjectMemberInitializerSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax withKeyword, PunctuationSyntax openBraceToken, SyntaxNode initializers, PunctuationSyntax closeBraceToken);
    public SyntaxToken get_WithKeyword();
    public ObjectMemberInitializerSyntax WithWithKeyword(SyntaxToken withKeyword);
    public SyntaxToken get_OpenBraceToken();
    public ObjectMemberInitializerSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
    public SeparatedSyntaxList`1<FieldInitializerSyntax> get_Initializers();
    public ObjectMemberInitializerSyntax WithInitializers(SeparatedSyntaxList`1<FieldInitializerSyntax> initializers);
    public ObjectMemberInitializerSyntax AddInitializers(FieldInitializerSyntax[] items);
    public SyntaxToken get_CloseBraceToken();
    public ObjectMemberInitializerSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ObjectMemberInitializerSyntax Update(SyntaxToken withKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList`1<FieldInitializerSyntax> initializers, SyntaxToken closeBraceToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.OmittedArgumentSyntax : ArgumentSyntax {
    public bool IsNamed { get; }
    public SyntaxToken Empty { get; }
    internal OmittedArgumentSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal OmittedArgumentSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax empty);
    public sealed virtual bool get_IsNamed();
    [EditorBrowsableAttribute("1")]
public sealed virtual ExpressionSyntax GetExpression();
    public SyntaxToken get_Empty();
    public OmittedArgumentSyntax WithEmpty(SyntaxToken empty);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public OmittedArgumentSyntax Update(SyntaxToken empty);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorGoToStatementSyntax : ExecutableStatementSyntax {
    internal LabelSyntax _label;
    public SyntaxToken OnKeyword { get; }
    public SyntaxToken ErrorKeyword { get; }
    public SyntaxToken GoToKeyword { get; }
    public SyntaxToken Minus { get; }
    public LabelSyntax Label { get; }
    internal OnErrorGoToStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal OnErrorGoToStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax onKeyword, KeywordSyntax errorKeyword, KeywordSyntax goToKeyword, PunctuationSyntax minus, LabelSyntax label);
    public SyntaxToken get_OnKeyword();
    public OnErrorGoToStatementSyntax WithOnKeyword(SyntaxToken onKeyword);
    public SyntaxToken get_ErrorKeyword();
    public OnErrorGoToStatementSyntax WithErrorKeyword(SyntaxToken errorKeyword);
    public SyntaxToken get_GoToKeyword();
    public OnErrorGoToStatementSyntax WithGoToKeyword(SyntaxToken goToKeyword);
    public SyntaxToken get_Minus();
    public OnErrorGoToStatementSyntax WithMinus(SyntaxToken minus);
    public LabelSyntax get_Label();
    public OnErrorGoToStatementSyntax WithLabel(LabelSyntax label);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public OnErrorGoToStatementSyntax Update(SyntaxKind kind, SyntaxToken onKeyword, SyntaxToken errorKeyword, SyntaxToken goToKeyword, SyntaxToken minus, LabelSyntax label);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.OnErrorResumeNextStatementSyntax : ExecutableStatementSyntax {
    public SyntaxToken OnKeyword { get; }
    public SyntaxToken ErrorKeyword { get; }
    public SyntaxToken ResumeKeyword { get; }
    public SyntaxToken NextKeyword { get; }
    internal OnErrorResumeNextStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal OnErrorResumeNextStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax onKeyword, KeywordSyntax errorKeyword, KeywordSyntax resumeKeyword, KeywordSyntax nextKeyword);
    public SyntaxToken get_OnKeyword();
    public OnErrorResumeNextStatementSyntax WithOnKeyword(SyntaxToken onKeyword);
    public SyntaxToken get_ErrorKeyword();
    public OnErrorResumeNextStatementSyntax WithErrorKeyword(SyntaxToken errorKeyword);
    public SyntaxToken get_ResumeKeyword();
    public OnErrorResumeNextStatementSyntax WithResumeKeyword(SyntaxToken resumeKeyword);
    public SyntaxToken get_NextKeyword();
    public OnErrorResumeNextStatementSyntax WithNextKeyword(SyntaxToken nextKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public OnErrorResumeNextStatementSyntax Update(SyntaxToken onKeyword, SyntaxToken errorKeyword, SyntaxToken resumeKeyword, SyntaxToken nextKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorBlockSyntax : MethodBlockBaseSyntax {
    internal OperatorStatementSyntax _operatorStatement;
    internal EndBlockStatementSyntax _endOperatorStatement;
    public MethodBaseSyntax BlockStatement { get; }
    public EndBlockStatementSyntax EndBlockStatement { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public OperatorStatementSyntax Begin { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public EndBlockStatementSyntax End { get; }
    public OperatorStatementSyntax OperatorStatement { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    public EndBlockStatementSyntax EndOperatorStatement { get; }
    internal OperatorBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal OperatorBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, OperatorStatementSyntax operatorStatement, SyntaxNode statements, EndBlockStatementSyntax endOperatorStatement);
    public virtual MethodBaseSyntax get_BlockStatement();
    public virtual EndBlockStatementSyntax get_EndBlockStatement();
    public virtual MethodBlockBaseSyntax WithBlockStatement(MethodBaseSyntax blockStatement);
    public virtual MethodBlockBaseSyntax WithEndBlockStatement(EndBlockStatementSyntax endBlockStatement);
    public OperatorStatementSyntax get_Begin();
    public EndBlockStatementSyntax get_End();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public OperatorBlockSyntax WithBegin(OperatorStatementSyntax begin);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public OperatorBlockSyntax WithEnd(EndBlockStatementSyntax end);
    public OperatorStatementSyntax get_OperatorStatement();
    public OperatorBlockSyntax WithOperatorStatement(OperatorStatementSyntax operatorStatement);
    public SyntaxList`1<StatementSyntax> get_Statements();
    internal virtual SyntaxList`1<StatementSyntax> GetStatementsCore();
    public OperatorBlockSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public OperatorBlockSyntax AddStatements(StatementSyntax[] items);
    public EndBlockStatementSyntax get_EndOperatorStatement();
    public OperatorBlockSyntax WithEndOperatorStatement(EndBlockStatementSyntax endOperatorStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public OperatorBlockSyntax Update(OperatorStatementSyntax operatorStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endOperatorStatement);
}
internal enum Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorPrecedence : Enum {
    public byte value__;
    public static OperatorPrecedence PrecedenceNone;
    public static OperatorPrecedence PrecedenceXor;
    public static OperatorPrecedence PrecedenceOr;
    public static OperatorPrecedence PrecedenceAnd;
    public static OperatorPrecedence PrecedenceNot;
    public static OperatorPrecedence PrecedenceRelational;
    public static OperatorPrecedence PrecedenceShift;
    public static OperatorPrecedence PrecedenceConcatenate;
    public static OperatorPrecedence PrecedenceAdd;
    public static OperatorPrecedence PrecedenceModulus;
    public static OperatorPrecedence PrecedenceIntegerDivide;
    public static OperatorPrecedence PrecedenceMultiply;
    public static OperatorPrecedence PrecedenceNegate;
    public static OperatorPrecedence PrecedenceExponentiate;
    public static OperatorPrecedence PrecedenceAwait;
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.OperatorStatementSyntax : MethodBaseSyntax {
    internal SimpleAsClauseSyntax _asClause;
    public SyntaxToken DeclarationKeyword { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public SyntaxToken Keyword { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken OperatorKeyword { get; }
    public SyntaxToken OperatorToken { get; }
    public ParameterListSyntax ParameterList { get; }
    public SimpleAsClauseSyntax AsClause { get; }
    internal OperatorStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal OperatorStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode attributeLists, GreenNode modifiers, KeywordSyntax operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public virtual SyntaxToken get_DeclarationKeyword();
    public virtual MethodBaseSyntax WithDeclarationKeyword(SyntaxToken keyword);
    public SyntaxToken get_Keyword();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public OperatorStatementSyntax WithKeyword(SyntaxToken keyword);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual SyntaxList`1<AttributeListSyntax> GetAttributeListsCore();
    public OperatorStatementSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public OperatorStatementSyntax AddAttributeLists(AttributeListSyntax[] items);
    public SyntaxTokenList get_Modifiers();
    internal virtual SyntaxTokenList GetModifiersCore();
    public OperatorStatementSyntax WithModifiers(SyntaxTokenList modifiers);
    public OperatorStatementSyntax AddModifiers(SyntaxToken[] items);
    public SyntaxToken get_OperatorKeyword();
    public OperatorStatementSyntax WithOperatorKeyword(SyntaxToken operatorKeyword);
    public SyntaxToken get_OperatorToken();
    public OperatorStatementSyntax WithOperatorToken(SyntaxToken operatorToken);
    public ParameterListSyntax get_ParameterList();
    internal virtual ParameterListSyntax GetParameterListCore();
    public OperatorStatementSyntax WithParameterList(ParameterListSyntax parameterList);
    public OperatorStatementSyntax AddParameterListParameters(ParameterSyntax[] items);
    public SimpleAsClauseSyntax get_AsClause();
    public OperatorStatementSyntax WithAsClause(SimpleAsClauseSyntax asClause);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public OperatorStatementSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.OptionStatementSyntax : DeclarationStatementSyntax {
    public SyntaxToken OptionKeyword { get; }
    public SyntaxToken NameKeyword { get; }
    public SyntaxToken ValueKeyword { get; }
    internal OptionStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal OptionStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax optionKeyword, KeywordSyntax nameKeyword, KeywordSyntax valueKeyword);
    public SyntaxToken get_OptionKeyword();
    public OptionStatementSyntax WithOptionKeyword(SyntaxToken optionKeyword);
    public SyntaxToken get_NameKeyword();
    public OptionStatementSyntax WithNameKeyword(SyntaxToken nameKeyword);
    public SyntaxToken get_ValueKeyword();
    public OptionStatementSyntax WithValueKeyword(SyntaxToken valueKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public OptionStatementSyntax Update(SyntaxToken optionKeyword, SyntaxToken nameKeyword, SyntaxToken valueKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderByClauseSyntax : QueryClauseSyntax {
    internal SyntaxNode _orderings;
    public SyntaxToken OrderKeyword { get; }
    public SyntaxToken ByKeyword { get; }
    public SeparatedSyntaxList`1<OrderingSyntax> Orderings { get; }
    internal OrderByClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal OrderByClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax orderKeyword, KeywordSyntax byKeyword, SyntaxNode orderings);
    public SyntaxToken get_OrderKeyword();
    public OrderByClauseSyntax WithOrderKeyword(SyntaxToken orderKeyword);
    public SyntaxToken get_ByKeyword();
    public OrderByClauseSyntax WithByKeyword(SyntaxToken byKeyword);
    public SeparatedSyntaxList`1<OrderingSyntax> get_Orderings();
    public OrderByClauseSyntax WithOrderings(SeparatedSyntaxList`1<OrderingSyntax> orderings);
    public OrderByClauseSyntax AddOrderings(OrderingSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public OrderByClauseSyntax Update(SyntaxToken orderKeyword, SyntaxToken byKeyword, SeparatedSyntaxList`1<OrderingSyntax> orderings);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.OrderingSyntax : VisualBasicSyntaxNode {
    internal ExpressionSyntax _expression;
    public ExpressionSyntax Expression { get; }
    public SyntaxToken AscendingOrDescendingKeyword { get; }
    internal OrderingSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal OrderingSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax expression, KeywordSyntax ascendingOrDescendingKeyword);
    public ExpressionSyntax get_Expression();
    public OrderingSyntax WithExpression(ExpressionSyntax expression);
    public SyntaxToken get_AscendingOrDescendingKeyword();
    public OrderingSyntax WithAscendingOrDescendingKeyword(SyntaxToken ascendingOrDescendingKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public OrderingSyntax Update(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterListSyntax : VisualBasicSyntaxNode {
    internal SyntaxNode _parameters;
    public SyntaxToken OpenParenToken { get; }
    public SeparatedSyntaxList`1<ParameterSyntax> Parameters { get; }
    public SyntaxToken CloseParenToken { get; }
    internal ParameterListSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ParameterListSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax openParenToken, SyntaxNode parameters, PunctuationSyntax closeParenToken);
    public SyntaxToken get_OpenParenToken();
    public ParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public SeparatedSyntaxList`1<ParameterSyntax> get_Parameters();
    public ParameterListSyntax WithParameters(SeparatedSyntaxList`1<ParameterSyntax> parameters);
    public ParameterListSyntax AddParameters(ParameterSyntax[] items);
    public SyntaxToken get_CloseParenToken();
    public ParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList`1<ParameterSyntax> parameters, SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ParameterSyntax : VisualBasicSyntaxNode {
    internal SyntaxNode _attributeLists;
    internal ModifiedIdentifierSyntax _identifier;
    internal SimpleAsClauseSyntax _asClause;
    internal EqualsValueSyntax _default;
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public ModifiedIdentifierSyntax Identifier { get; }
    public SimpleAsClauseSyntax AsClause { get; }
    public EqualsValueSyntax Default { get; }
    internal ParameterSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ParameterSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode attributeLists, GreenNode modifiers, ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, EqualsValueSyntax default);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public ParameterSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public ParameterSyntax AddAttributeLists(AttributeListSyntax[] items);
    public SyntaxTokenList get_Modifiers();
    public ParameterSyntax WithModifiers(SyntaxTokenList modifiers);
    public ParameterSyntax AddModifiers(SyntaxToken[] items);
    public ModifiedIdentifierSyntax get_Identifier();
    public ParameterSyntax WithIdentifier(ModifiedIdentifierSyntax identifier);
    public SimpleAsClauseSyntax get_AsClause();
    public ParameterSyntax WithAsClause(SimpleAsClauseSyntax asClause);
    public EqualsValueSyntax get_Default();
    public ParameterSyntax WithDefault(EqualsValueSyntax default);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ParameterSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, EqualsValueSyntax default);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ParenthesizedExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax _expression;
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    internal ParenthesizedExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ParenthesizedExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax closeParenToken);
    public SyntaxToken get_OpenParenToken();
    public ParenthesizedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public ExpressionSyntax get_Expression();
    public ParenthesizedExpressionSyntax WithExpression(ExpressionSyntax expression);
    public SyntaxToken get_CloseParenToken();
    public ParenthesizedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionClauseSyntax : QueryClauseSyntax {
    internal ExpressionSyntax _count;
    public SyntaxToken SkipOrTakeKeyword { get; }
    public ExpressionSyntax Count { get; }
    internal PartitionClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal PartitionClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax skipOrTakeKeyword, ExpressionSyntax count);
    public SyntaxToken get_SkipOrTakeKeyword();
    public PartitionClauseSyntax WithSkipOrTakeKeyword(SyntaxToken skipOrTakeKeyword);
    public ExpressionSyntax get_Count();
    public PartitionClauseSyntax WithCount(ExpressionSyntax count);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public PartitionClauseSyntax Update(SyntaxKind kind, SyntaxToken skipOrTakeKeyword, ExpressionSyntax count);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.PartitionWhileClauseSyntax : QueryClauseSyntax {
    internal ExpressionSyntax _condition;
    public SyntaxToken SkipOrTakeKeyword { get; }
    public SyntaxToken WhileKeyword { get; }
    public ExpressionSyntax Condition { get; }
    internal PartitionWhileClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal PartitionWhileClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax skipOrTakeKeyword, KeywordSyntax whileKeyword, ExpressionSyntax condition);
    public SyntaxToken get_SkipOrTakeKeyword();
    public PartitionWhileClauseSyntax WithSkipOrTakeKeyword(SyntaxToken skipOrTakeKeyword);
    public SyntaxToken get_WhileKeyword();
    public PartitionWhileClauseSyntax WithWhileKeyword(SyntaxToken whileKeyword);
    public ExpressionSyntax get_Condition();
    public PartitionWhileClauseSyntax WithCondition(ExpressionSyntax condition);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public PartitionWhileClauseSyntax Update(SyntaxKind kind, SyntaxToken skipOrTakeKeyword, SyntaxToken whileKeyword, ExpressionSyntax condition);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedCastExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax _expression;
    public SyntaxToken Keyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CloseParenToken { get; }
    internal PredefinedCastExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal PredefinedCastExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax closeParenToken);
    public SyntaxToken get_Keyword();
    public PredefinedCastExpressionSyntax WithKeyword(SyntaxToken keyword);
    public SyntaxToken get_OpenParenToken();
    public PredefinedCastExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public ExpressionSyntax get_Expression();
    public PredefinedCastExpressionSyntax WithExpression(ExpressionSyntax expression);
    public SyntaxToken get_CloseParenToken();
    public PredefinedCastExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public PredefinedCastExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.PredefinedTypeSyntax : TypeSyntax {
    public SyntaxToken Keyword { get; }
    internal PredefinedTypeSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal PredefinedTypeSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword);
    public SyntaxToken get_Keyword();
    public PredefinedTypeSyntax WithKeyword(SyntaxToken keyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public PredefinedTypeSyntax Update(SyntaxToken keyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.PrintStatementSyntax : ExecutableStatementSyntax {
    internal ExpressionSyntax _expression;
    public SyntaxToken QuestionToken { get; }
    public ExpressionSyntax Expression { get; }
    internal PrintStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal PrintStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax questionToken, ExpressionSyntax expression);
    public SyntaxToken get_QuestionToken();
    public PrintStatementSyntax WithQuestionToken(SyntaxToken questionToken);
    public ExpressionSyntax get_Expression();
    public PrintStatementSyntax WithExpression(ExpressionSyntax expression);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public PrintStatementSyntax Update(SyntaxToken questionToken, ExpressionSyntax expression);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyBlockSyntax : DeclarationStatementSyntax {
    internal PropertyStatementSyntax _propertyStatement;
    internal SyntaxNode _accessors;
    internal EndBlockStatementSyntax _endPropertyStatement;
    public PropertyStatementSyntax PropertyStatement { get; }
    public SyntaxList`1<AccessorBlockSyntax> Accessors { get; }
    public EndBlockStatementSyntax EndPropertyStatement { get; }
    internal PropertyBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal PropertyBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PropertyStatementSyntax propertyStatement, SyntaxNode accessors, EndBlockStatementSyntax endPropertyStatement);
    public PropertyStatementSyntax get_PropertyStatement();
    public PropertyBlockSyntax WithPropertyStatement(PropertyStatementSyntax propertyStatement);
    public SyntaxList`1<AccessorBlockSyntax> get_Accessors();
    public PropertyBlockSyntax WithAccessors(SyntaxList`1<AccessorBlockSyntax> accessors);
    public PropertyBlockSyntax AddAccessors(AccessorBlockSyntax[] items);
    public EndBlockStatementSyntax get_EndPropertyStatement();
    public PropertyBlockSyntax WithEndPropertyStatement(EndBlockStatementSyntax endPropertyStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public PropertyBlockSyntax Update(PropertyStatementSyntax propertyStatement, SyntaxList`1<AccessorBlockSyntax> accessors, EndBlockStatementSyntax endPropertyStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.PropertyStatementSyntax : MethodBaseSyntax {
    internal AsClauseSyntax _asClause;
    internal EqualsValueSyntax _initializer;
    internal ImplementsClauseSyntax _implementsClause;
    public SyntaxToken DeclarationKeyword { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public SyntaxToken Keyword { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken PropertyKeyword { get; }
    public SyntaxToken Identifier { get; }
    public ParameterListSyntax ParameterList { get; }
    public AsClauseSyntax AsClause { get; }
    public EqualsValueSyntax Initializer { get; }
    public ImplementsClauseSyntax ImplementsClause { get; }
    internal PropertyStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal PropertyStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode attributeLists, GreenNode modifiers, KeywordSyntax propertyKeyword, IdentifierTokenSyntax identifier, ParameterListSyntax parameterList, AsClauseSyntax asClause, EqualsValueSyntax initializer, ImplementsClauseSyntax implementsClause);
    public virtual SyntaxToken get_DeclarationKeyword();
    public virtual MethodBaseSyntax WithDeclarationKeyword(SyntaxToken keyword);
    public SyntaxToken get_Keyword();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public PropertyStatementSyntax WithKeyword(SyntaxToken keyword);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual SyntaxList`1<AttributeListSyntax> GetAttributeListsCore();
    public PropertyStatementSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public PropertyStatementSyntax AddAttributeLists(AttributeListSyntax[] items);
    public SyntaxTokenList get_Modifiers();
    internal virtual SyntaxTokenList GetModifiersCore();
    public PropertyStatementSyntax WithModifiers(SyntaxTokenList modifiers);
    public PropertyStatementSyntax AddModifiers(SyntaxToken[] items);
    public SyntaxToken get_PropertyKeyword();
    public PropertyStatementSyntax WithPropertyKeyword(SyntaxToken propertyKeyword);
    public SyntaxToken get_Identifier();
    public PropertyStatementSyntax WithIdentifier(SyntaxToken identifier);
    public ParameterListSyntax get_ParameterList();
    internal virtual ParameterListSyntax GetParameterListCore();
    public PropertyStatementSyntax WithParameterList(ParameterListSyntax parameterList);
    public PropertyStatementSyntax AddParameterListParameters(ParameterSyntax[] items);
    public AsClauseSyntax get_AsClause();
    public PropertyStatementSyntax WithAsClause(AsClauseSyntax asClause);
    public EqualsValueSyntax get_Initializer();
    public PropertyStatementSyntax WithInitializer(EqualsValueSyntax initializer);
    public ImplementsClauseSyntax get_ImplementsClause();
    public PropertyStatementSyntax WithImplementsClause(ImplementsClauseSyntax implementsClause);
    public PropertyStatementSyntax AddImplementsClauseInterfaceMembers(QualifiedNameSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public PropertyStatementSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken propertyKeyword, SyntaxToken identifier, ParameterListSyntax parameterList, AsClauseSyntax asClause, EqualsValueSyntax initializer, ImplementsClauseSyntax implementsClause);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedCrefOperatorReferenceSyntax : NameSyntax {
    internal NameSyntax _left;
    internal CrefOperatorReferenceSyntax _right;
    public NameSyntax Left { get; }
    public SyntaxToken DotToken { get; }
    public CrefOperatorReferenceSyntax Right { get; }
    internal QualifiedCrefOperatorReferenceSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal QualifiedCrefOperatorReferenceSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, NameSyntax left, PunctuationSyntax dotToken, CrefOperatorReferenceSyntax right);
    public NameSyntax get_Left();
    public QualifiedCrefOperatorReferenceSyntax WithLeft(NameSyntax left);
    public SyntaxToken get_DotToken();
    public QualifiedCrefOperatorReferenceSyntax WithDotToken(SyntaxToken dotToken);
    public CrefOperatorReferenceSyntax get_Right();
    public QualifiedCrefOperatorReferenceSyntax WithRight(CrefOperatorReferenceSyntax right);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public QualifiedCrefOperatorReferenceSyntax Update(NameSyntax left, SyntaxToken dotToken, CrefOperatorReferenceSyntax right);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.QualifiedNameSyntax : NameSyntax {
    internal NameSyntax _left;
    internal SimpleNameSyntax _right;
    public NameSyntax Left { get; }
    public SyntaxToken DotToken { get; }
    public SimpleNameSyntax Right { get; }
    internal QualifiedNameSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal QualifiedNameSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, NameSyntax left, PunctuationSyntax dotToken, SimpleNameSyntax right);
    public NameSyntax get_Left();
    public QualifiedNameSyntax WithLeft(NameSyntax left);
    public SyntaxToken get_DotToken();
    public QualifiedNameSyntax WithDotToken(SyntaxToken dotToken);
    public SimpleNameSyntax get_Right();
    public QualifiedNameSyntax WithRight(SimpleNameSyntax right);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public QualifiedNameSyntax Update(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryClauseSyntax : VisualBasicSyntaxNode {
    internal QueryClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.QueryExpressionSyntax : ExpressionSyntax {
    internal SyntaxNode _clauses;
    public SyntaxList`1<QueryClauseSyntax> Clauses { get; }
    internal QueryExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal QueryExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode clauses);
    public SyntaxList`1<QueryClauseSyntax> get_Clauses();
    public QueryExpressionSyntax WithClauses(SyntaxList`1<QueryClauseSyntax> clauses);
    public QueryExpressionSyntax AddClauses(QueryClauseSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public QueryExpressionSyntax Update(SyntaxList`1<QueryClauseSyntax> clauses);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.RaiseEventStatementSyntax : ExecutableStatementSyntax {
    internal IdentifierNameSyntax _name;
    internal ArgumentListSyntax _argumentList;
    public SyntaxToken RaiseEventKeyword { get; }
    public IdentifierNameSyntax Name { get; }
    public ArgumentListSyntax ArgumentList { get; }
    internal RaiseEventStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal RaiseEventStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax raiseEventKeyword, IdentifierNameSyntax name, ArgumentListSyntax argumentList);
    public SyntaxToken get_RaiseEventKeyword();
    public RaiseEventStatementSyntax WithRaiseEventKeyword(SyntaxToken raiseEventKeyword);
    public IdentifierNameSyntax get_Name();
    public RaiseEventStatementSyntax WithName(IdentifierNameSyntax name);
    public ArgumentListSyntax get_ArgumentList();
    public RaiseEventStatementSyntax WithArgumentList(ArgumentListSyntax argumentList);
    public RaiseEventStatementSyntax AddArgumentListArguments(ArgumentSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public RaiseEventStatementSyntax Update(SyntaxToken raiseEventKeyword, IdentifierNameSyntax name, ArgumentListSyntax argumentList);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeArgumentSyntax : ArgumentSyntax {
    internal ExpressionSyntax _lowerBound;
    internal ExpressionSyntax _upperBound;
    public bool IsNamed { get; }
    public ExpressionSyntax LowerBound { get; }
    public SyntaxToken ToKeyword { get; }
    public ExpressionSyntax UpperBound { get; }
    internal RangeArgumentSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal RangeArgumentSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax lowerBound, KeywordSyntax toKeyword, ExpressionSyntax upperBound);
    public sealed virtual bool get_IsNamed();
    [EditorBrowsableAttribute("1")]
public sealed virtual ExpressionSyntax GetExpression();
    public ExpressionSyntax get_LowerBound();
    public RangeArgumentSyntax WithLowerBound(ExpressionSyntax lowerBound);
    public SyntaxToken get_ToKeyword();
    public RangeArgumentSyntax WithToKeyword(SyntaxToken toKeyword);
    public ExpressionSyntax get_UpperBound();
    public RangeArgumentSyntax WithUpperBound(ExpressionSyntax upperBound);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public RangeArgumentSyntax Update(ExpressionSyntax lowerBound, SyntaxToken toKeyword, ExpressionSyntax upperBound);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.RangeCaseClauseSyntax : CaseClauseSyntax {
    internal ExpressionSyntax _lowerBound;
    internal ExpressionSyntax _upperBound;
    public ExpressionSyntax LowerBound { get; }
    public SyntaxToken ToKeyword { get; }
    public ExpressionSyntax UpperBound { get; }
    internal RangeCaseClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal RangeCaseClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax lowerBound, KeywordSyntax toKeyword, ExpressionSyntax upperBound);
    public ExpressionSyntax get_LowerBound();
    public RangeCaseClauseSyntax WithLowerBound(ExpressionSyntax lowerBound);
    public SyntaxToken get_ToKeyword();
    public RangeCaseClauseSyntax WithToKeyword(SyntaxToken toKeyword);
    public ExpressionSyntax get_UpperBound();
    public RangeCaseClauseSyntax WithUpperBound(ExpressionSyntax upperBound);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public RangeCaseClauseSyntax Update(ExpressionSyntax lowerBound, SyntaxToken toKeyword, ExpressionSyntax upperBound);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.RedimClauseSyntax : VisualBasicSyntaxNode {
    internal ExpressionSyntax _expression;
    internal ArgumentListSyntax _arrayBounds;
    public ExpressionSyntax Expression { get; }
    public ArgumentListSyntax ArrayBounds { get; }
    internal RedimClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal RedimClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax expression, ArgumentListSyntax arrayBounds);
    public ExpressionSyntax get_Expression();
    public RedimClauseSyntax WithExpression(ExpressionSyntax expression);
    public ArgumentListSyntax get_ArrayBounds();
    public RedimClauseSyntax WithArrayBounds(ArgumentListSyntax arrayBounds);
    public RedimClauseSyntax AddArrayBoundsArguments(ArgumentSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public RedimClauseSyntax Update(ExpressionSyntax expression, ArgumentListSyntax arrayBounds);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ReDimStatementSyntax : ExecutableStatementSyntax {
    internal SyntaxNode _clauses;
    public SyntaxToken ReDimKeyword { get; }
    public SyntaxToken PreserveKeyword { get; }
    public SeparatedSyntaxList`1<RedimClauseSyntax> Clauses { get; }
    internal ReDimStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ReDimStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax reDimKeyword, KeywordSyntax preserveKeyword, SyntaxNode clauses);
    public SyntaxToken get_ReDimKeyword();
    public ReDimStatementSyntax WithReDimKeyword(SyntaxToken reDimKeyword);
    public SyntaxToken get_PreserveKeyword();
    public ReDimStatementSyntax WithPreserveKeyword(SyntaxToken preserveKeyword);
    public SeparatedSyntaxList`1<RedimClauseSyntax> get_Clauses();
    public ReDimStatementSyntax WithClauses(SeparatedSyntaxList`1<RedimClauseSyntax> clauses);
    public ReDimStatementSyntax AddClauses(RedimClauseSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ReDimStatementSyntax Update(SyntaxKind kind, SyntaxToken reDimKeyword, SyntaxToken preserveKeyword, SeparatedSyntaxList`1<RedimClauseSyntax> clauses);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ReferenceDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken ReferenceKeyword { get; }
    public SyntaxToken File { get; }
    internal ReferenceDirectiveTriviaSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ReferenceDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax referenceKeyword, StringLiteralTokenSyntax file);
    public SyntaxToken get_HashToken();
    internal virtual SyntaxToken GetHashTokenCore();
    public ReferenceDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public SyntaxToken get_ReferenceKeyword();
    public ReferenceDirectiveTriviaSyntax WithReferenceKeyword(SyntaxToken referenceKeyword);
    public SyntaxToken get_File();
    public ReferenceDirectiveTriviaSyntax WithFile(SyntaxToken file);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ReferenceDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.RegionDirectiveTriviaSyntax : DirectiveTriviaSyntax {
    public SyntaxToken HashToken { get; }
    public SyntaxToken RegionKeyword { get; }
    public SyntaxToken Name { get; }
    internal RegionDirectiveTriviaSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal RegionDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax hashToken, KeywordSyntax regionKeyword, StringLiteralTokenSyntax name);
    public SyntaxToken get_HashToken();
    internal virtual SyntaxToken GetHashTokenCore();
    public RegionDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken);
    public SyntaxToken get_RegionKeyword();
    public RegionDirectiveTriviaSyntax WithRegionKeyword(SyntaxToken regionKeyword);
    public SyntaxToken get_Name();
    public RegionDirectiveTriviaSyntax WithName(SyntaxToken name);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public RegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken name);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.RelationalCaseClauseSyntax : CaseClauseSyntax {
    internal ExpressionSyntax _value;
    public SyntaxToken IsKeyword { get; }
    public SyntaxToken OperatorToken { get; }
    public ExpressionSyntax Value { get; }
    internal RelationalCaseClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal RelationalCaseClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax isKeyword, PunctuationSyntax operatorToken, ExpressionSyntax value);
    public SyntaxToken get_IsKeyword();
    public RelationalCaseClauseSyntax WithIsKeyword(SyntaxToken isKeyword);
    public SyntaxToken get_OperatorToken();
    public RelationalCaseClauseSyntax WithOperatorToken(SyntaxToken operatorToken);
    public ExpressionSyntax get_Value();
    public RelationalCaseClauseSyntax WithValue(ExpressionSyntax value);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public RelationalCaseClauseSyntax Update(SyntaxKind kind, SyntaxToken isKeyword, SyntaxToken operatorToken, ExpressionSyntax value);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ResumeStatementSyntax : ExecutableStatementSyntax {
    internal LabelSyntax _label;
    public SyntaxToken ResumeKeyword { get; }
    public LabelSyntax Label { get; }
    internal ResumeStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ResumeStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax resumeKeyword, LabelSyntax label);
    public SyntaxToken get_ResumeKeyword();
    public ResumeStatementSyntax WithResumeKeyword(SyntaxToken resumeKeyword);
    public LabelSyntax get_Label();
    public ResumeStatementSyntax WithLabel(LabelSyntax label);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ResumeStatementSyntax Update(SyntaxKind kind, SyntaxToken resumeKeyword, LabelSyntax label);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ReturnStatementSyntax : ExecutableStatementSyntax {
    internal ExpressionSyntax _expression;
    public SyntaxToken ReturnKeyword { get; }
    public ExpressionSyntax Expression { get; }
    internal ReturnStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ReturnStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax returnKeyword, ExpressionSyntax expression);
    public SyntaxToken get_ReturnKeyword();
    public ReturnStatementSyntax WithReturnKeyword(SyntaxToken returnKeyword);
    public ExpressionSyntax get_Expression();
    public ReturnStatementSyntax WithExpression(ExpressionSyntax expression);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ReturnStatementSyntax Update(SyntaxToken returnKeyword, ExpressionSyntax expression);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectBlockSyntax : ExecutableStatementSyntax {
    internal SelectStatementSyntax _selectStatement;
    internal SyntaxNode _caseBlocks;
    internal EndBlockStatementSyntax _endSelectStatement;
    public SelectStatementSyntax SelectStatement { get; }
    public SyntaxList`1<CaseBlockSyntax> CaseBlocks { get; }
    public EndBlockStatementSyntax EndSelectStatement { get; }
    internal SelectBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal SelectBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SelectStatementSyntax selectStatement, SyntaxNode caseBlocks, EndBlockStatementSyntax endSelectStatement);
    public SelectStatementSyntax get_SelectStatement();
    public SelectBlockSyntax WithSelectStatement(SelectStatementSyntax selectStatement);
    public SyntaxList`1<CaseBlockSyntax> get_CaseBlocks();
    public SelectBlockSyntax WithCaseBlocks(SyntaxList`1<CaseBlockSyntax> caseBlocks);
    public SelectBlockSyntax AddCaseBlocks(CaseBlockSyntax[] items);
    public EndBlockStatementSyntax get_EndSelectStatement();
    public SelectBlockSyntax WithEndSelectStatement(EndBlockStatementSyntax endSelectStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public SelectBlockSyntax Update(SelectStatementSyntax selectStatement, SyntaxList`1<CaseBlockSyntax> caseBlocks, EndBlockStatementSyntax endSelectStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectClauseSyntax : QueryClauseSyntax {
    internal SyntaxNode _variables;
    public SyntaxToken SelectKeyword { get; }
    public SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> Variables { get; }
    internal SelectClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal SelectClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax selectKeyword, SyntaxNode variables);
    public SyntaxToken get_SelectKeyword();
    public SelectClauseSyntax WithSelectKeyword(SyntaxToken selectKeyword);
    public SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> get_Variables();
    public SelectClauseSyntax WithVariables(SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> variables);
    public SelectClauseSyntax AddVariables(ExpressionRangeVariableSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public SelectClauseSyntax Update(SyntaxToken selectKeyword, SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> variables);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.SelectStatementSyntax : StatementSyntax {
    internal ExpressionSyntax _expression;
    public SyntaxToken SelectKeyword { get; }
    public SyntaxToken CaseKeyword { get; }
    public ExpressionSyntax Expression { get; }
    internal SelectStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal SelectStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax selectKeyword, KeywordSyntax caseKeyword, ExpressionSyntax expression);
    public SyntaxToken get_SelectKeyword();
    public SelectStatementSyntax WithSelectKeyword(SyntaxToken selectKeyword);
    public SyntaxToken get_CaseKeyword();
    public SelectStatementSyntax WithCaseKeyword(SyntaxToken caseKeyword);
    public ExpressionSyntax get_Expression();
    public SelectStatementSyntax WithExpression(ExpressionSyntax expression);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public SelectStatementSyntax Update(SyntaxToken selectKeyword, SyntaxToken caseKeyword, ExpressionSyntax expression);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.SeparatedSyntaxListBuilder`1 : ValueType {
    private SyntaxListBuilder _builder;
    private bool _expectSeparator;
    public bool IsNull { get; }
    public int Count { get; }
    public SeparatedSyntaxListBuilder`1(int size);
    internal SeparatedSyntaxListBuilder`1(SyntaxListBuilder builder);
    public static SeparatedSyntaxListBuilder`1<TNode> Create();
    public bool get_IsNull();
    public int get_Count();
    public void Clear();
    public void Add(TNode node);
    internal void AddSeparator(SyntaxToken separatorToken);
    public void AddSeparator(SyntaxToken separatorToken);
    public void AddRange(SeparatedSyntaxList`1<TNode> nodes);
    internal void AddRange(SeparatedSyntaxList`1<TNode> nodes, int count);
    internal void RemoveLast();
    public bool Any(SyntaxKind kind);
    public SeparatedSyntaxList`1<TNode> ToList();
    public SeparatedSyntaxList`1<TDerived> ToList();
    public static SeparatedSyntaxList`1<TNode> op_Implicit(SeparatedSyntaxListBuilder`1<TNode> builder);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleArgumentSyntax : ArgumentSyntax {
    internal NameColonEqualsSyntax _nameColonEquals;
    internal ExpressionSyntax _expression;
    public bool IsNamed { get; }
    public NameColonEqualsSyntax NameColonEquals { get; }
    public ExpressionSyntax Expression { get; }
    internal SimpleArgumentSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal SimpleArgumentSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, NameColonEqualsSyntax nameColonEquals, ExpressionSyntax expression);
    public sealed virtual bool get_IsNamed();
    [EditorBrowsableAttribute("1")]
public sealed virtual ExpressionSyntax GetExpression();
    public NameColonEqualsSyntax get_NameColonEquals();
    public SimpleArgumentSyntax WithNameColonEquals(NameColonEqualsSyntax nameColonEquals);
    public ExpressionSyntax get_Expression();
    public SimpleArgumentSyntax WithExpression(ExpressionSyntax expression);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public SimpleArgumentSyntax Update(NameColonEqualsSyntax nameColonEquals, ExpressionSyntax expression);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleAsClauseSyntax : AsClauseSyntax {
    internal SyntaxNode _attributeLists;
    internal TypeSyntax _type;
    public SyntaxToken AsKeyword { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public TypeSyntax Type { get; }
    internal SimpleAsClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal SimpleAsClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax asKeyword, SyntaxNode attributeLists, TypeSyntax type);
    public SyntaxToken get_AsKeyword();
    internal virtual SyntaxToken GetAsKeywordCore();
    public SimpleAsClauseSyntax WithAsKeyword(SyntaxToken asKeyword);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    public SimpleAsClauseSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public SimpleAsClauseSyntax AddAttributeLists(AttributeListSyntax[] items);
    public TypeSyntax get_Type();
    public SimpleAsClauseSyntax WithType(TypeSyntax type);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public SimpleAsClauseSyntax Update(SyntaxToken asKeyword, SyntaxList`1<AttributeListSyntax> attributeLists, TypeSyntax type);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleCaseClauseSyntax : CaseClauseSyntax {
    internal ExpressionSyntax _value;
    public ExpressionSyntax Value { get; }
    internal SimpleCaseClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal SimpleCaseClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax value);
    public ExpressionSyntax get_Value();
    public SimpleCaseClauseSyntax WithValue(ExpressionSyntax value);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public SimpleCaseClauseSyntax Update(ExpressionSyntax value);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleImportsClauseSyntax : ImportsClauseSyntax {
    internal ImportAliasClauseSyntax _alias;
    internal NameSyntax _name;
    public ImportAliasClauseSyntax Alias { get; }
    public NameSyntax Name { get; }
    internal SimpleImportsClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal SimpleImportsClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ImportAliasClauseSyntax alias, NameSyntax name);
    public ImportAliasClauseSyntax get_Alias();
    public SimpleImportsClauseSyntax WithAlias(ImportAliasClauseSyntax alias);
    public NameSyntax get_Name();
    public SimpleImportsClauseSyntax WithName(NameSyntax name);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public SimpleImportsClauseSyntax Update(ImportAliasClauseSyntax alias, NameSyntax name);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleJoinClauseSyntax : JoinClauseSyntax {
    public SyntaxToken JoinKeyword { get; }
    public SeparatedSyntaxList`1<CollectionRangeVariableSyntax> JoinedVariables { get; }
    public SyntaxList`1<JoinClauseSyntax> AdditionalJoins { get; }
    public SyntaxToken OnKeyword { get; }
    public SeparatedSyntaxList`1<JoinConditionSyntax> JoinConditions { get; }
    internal SimpleJoinClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal SimpleJoinClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax joinKeyword, SyntaxNode joinedVariables, SyntaxNode additionalJoins, KeywordSyntax onKeyword, SyntaxNode joinConditions);
    public SyntaxToken get_JoinKeyword();
    internal virtual SyntaxToken GetJoinKeywordCore();
    public SimpleJoinClauseSyntax WithJoinKeyword(SyntaxToken joinKeyword);
    public virtual SeparatedSyntaxList`1<CollectionRangeVariableSyntax> get_JoinedVariables();
    public SimpleJoinClauseSyntax WithJoinedVariables(SeparatedSyntaxList`1<CollectionRangeVariableSyntax> joinedVariables);
    public SimpleJoinClauseSyntax AddJoinedVariables(CollectionRangeVariableSyntax[] items);
    public SyntaxList`1<JoinClauseSyntax> get_AdditionalJoins();
    internal virtual SyntaxList`1<JoinClauseSyntax> GetAdditionalJoinsCore();
    public SimpleJoinClauseSyntax WithAdditionalJoins(SyntaxList`1<JoinClauseSyntax> additionalJoins);
    public SimpleJoinClauseSyntax AddAdditionalJoins(JoinClauseSyntax[] items);
    public SyntaxToken get_OnKeyword();
    internal virtual SyntaxToken GetOnKeywordCore();
    public SimpleJoinClauseSyntax WithOnKeyword(SyntaxToken onKeyword);
    public virtual SeparatedSyntaxList`1<JoinConditionSyntax> get_JoinConditions();
    public SimpleJoinClauseSyntax WithJoinConditions(SeparatedSyntaxList`1<JoinConditionSyntax> joinConditions);
    public SimpleJoinClauseSyntax AddJoinConditions(JoinConditionSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public SimpleJoinClauseSyntax Update(SyntaxToken joinKeyword, SeparatedSyntaxList`1<CollectionRangeVariableSyntax> joinedVariables, SyntaxList`1<JoinClauseSyntax> additionalJoins, SyntaxToken onKeyword, SeparatedSyntaxList`1<JoinConditionSyntax> joinConditions);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.SimpleNameSyntax : NameSyntax {
    public SyntaxToken Identifier { get; }
    internal SimpleNameSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    public SyntaxToken get_Identifier();
    internal virtual SyntaxToken GetIdentifierCore();
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineElseClauseSyntax : VisualBasicSyntaxNode {
    internal SyntaxNode _statements;
    public SyntaxToken ElseKeyword { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    internal SingleLineElseClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal SingleLineElseClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax elseKeyword, SyntaxNode statements);
    public SyntaxToken get_ElseKeyword();
    public SingleLineElseClauseSyntax WithElseKeyword(SyntaxToken elseKeyword);
    public SyntaxList`1<StatementSyntax> get_Statements();
    public SingleLineElseClauseSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public SingleLineElseClauseSyntax AddStatements(StatementSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public SingleLineElseClauseSyntax Update(SyntaxToken elseKeyword, SyntaxList`1<StatementSyntax> statements);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineIfStatementSyntax : ExecutableStatementSyntax {
    internal ExpressionSyntax _condition;
    internal SyntaxNode _statements;
    internal SingleLineElseClauseSyntax _elseClause;
    public SyntaxToken IfKeyword { get; }
    public ExpressionSyntax Condition { get; }
    public SyntaxToken ThenKeyword { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    public SingleLineElseClauseSyntax ElseClause { get; }
    internal SingleLineIfStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal SingleLineIfStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax ifKeyword, ExpressionSyntax condition, KeywordSyntax thenKeyword, SyntaxNode statements, SingleLineElseClauseSyntax elseClause);
    public SyntaxToken get_IfKeyword();
    public SingleLineIfStatementSyntax WithIfKeyword(SyntaxToken ifKeyword);
    public ExpressionSyntax get_Condition();
    public SingleLineIfStatementSyntax WithCondition(ExpressionSyntax condition);
    public SyntaxToken get_ThenKeyword();
    public SingleLineIfStatementSyntax WithThenKeyword(SyntaxToken thenKeyword);
    public SyntaxList`1<StatementSyntax> get_Statements();
    public SingleLineIfStatementSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public SingleLineIfStatementSyntax AddStatements(StatementSyntax[] items);
    public SingleLineElseClauseSyntax get_ElseClause();
    public SingleLineIfStatementSyntax WithElseClause(SingleLineElseClauseSyntax elseClause);
    public SingleLineIfStatementSyntax AddElseClauseStatements(StatementSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public SingleLineIfStatementSyntax Update(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, SyntaxList`1<StatementSyntax> statements, SingleLineElseClauseSyntax elseClause);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.SingleLineLambdaExpressionSyntax : LambdaExpressionSyntax {
    internal VisualBasicSyntaxNode _body;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use SubOrFunctionHeader instead.", "True")]
public LambdaHeaderSyntax Begin { get; }
    internal SyntaxList`1<StatementSyntax> Statements { get; }
    public LambdaHeaderSyntax SubOrFunctionHeader { get; }
    public VisualBasicSyntaxNode Body { get; }
    internal SingleLineLambdaExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal SingleLineLambdaExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, LambdaHeaderSyntax subOrFunctionHeader, VisualBasicSyntaxNode body);
    public LambdaHeaderSyntax get_Begin();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use WithSubOrFunctionHeader instead.", "True")]
public SingleLineLambdaExpressionSyntax WithBegin(LambdaHeaderSyntax begin);
    internal SyntaxList`1<StatementSyntax> get_Statements();
    public LambdaHeaderSyntax get_SubOrFunctionHeader();
    internal virtual LambdaHeaderSyntax GetSubOrFunctionHeaderCore();
    public SingleLineLambdaExpressionSyntax WithSubOrFunctionHeader(LambdaHeaderSyntax subOrFunctionHeader);
    public VisualBasicSyntaxNode get_Body();
    public SingleLineLambdaExpressionSyntax WithBody(VisualBasicSyntaxNode body);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public SingleLineLambdaExpressionSyntax Update(SyntaxKind kind, LambdaHeaderSyntax subOrFunctionHeader, VisualBasicSyntaxNode body);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.SkippedTokensTriviaSyntax : StructuredTriviaSyntax {
    private SyntaxTokenList ISkippedTokensTriviaSyntax_Tokens { get; }
    public SyntaxTokenList Tokens { get; }
    internal SkippedTokensTriviaSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal SkippedTokensTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode tokens);
    private sealed virtual override SyntaxTokenList get_ISkippedTokensTriviaSyntax_Tokens();
    public SyntaxTokenList get_Tokens();
    public SkippedTokensTriviaSyntax WithTokens(SyntaxTokenList tokens);
    public SkippedTokensTriviaSyntax AddTokens(SyntaxToken[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public SkippedTokensTriviaSyntax Update(SyntaxTokenList tokens);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.SpecialConstraintSyntax : ConstraintSyntax {
    public SyntaxToken ConstraintKeyword { get; }
    internal SpecialConstraintSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal SpecialConstraintSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax constraintKeyword);
    public SyntaxToken get_ConstraintKeyword();
    public SpecialConstraintSyntax WithConstraintKeyword(SyntaxToken constraintKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public SpecialConstraintSyntax Update(SyntaxKind kind, SyntaxToken constraintKeyword);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.StatementSyntax : VisualBasicSyntaxNode {
    internal StatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.StopOrEndStatementSyntax : ExecutableStatementSyntax {
    public SyntaxToken StopOrEndKeyword { get; }
    internal StopOrEndStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal StopOrEndStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax stopOrEndKeyword);
    public SyntaxToken get_StopOrEndKeyword();
    public StopOrEndStatementSyntax WithStopOrEndKeyword(SyntaxToken stopOrEndKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public StopOrEndStatementSyntax Update(SyntaxKind kind, SyntaxToken stopOrEndKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureBlockSyntax : TypeBlockSyntax {
    internal StructureStatementSyntax _structureStatement;
    internal EndBlockStatementSyntax _endStructureStatement;
    public TypeStatementSyntax BlockStatement { get; }
    public EndBlockStatementSyntax EndBlockStatement { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public StructureStatementSyntax Begin { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public EndBlockStatementSyntax End { get; }
    public StructureStatementSyntax StructureStatement { get; }
    public SyntaxList`1<InheritsStatementSyntax> Inherits { get; }
    public SyntaxList`1<ImplementsStatementSyntax> Implements { get; }
    public SyntaxList`1<StatementSyntax> Members { get; }
    public EndBlockStatementSyntax EndStructureStatement { get; }
    internal StructureBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal StructureBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, StructureStatementSyntax structureStatement, SyntaxNode inherits, SyntaxNode implements, SyntaxNode members, EndBlockStatementSyntax endStructureStatement);
    public virtual TypeStatementSyntax get_BlockStatement();
    public virtual EndBlockStatementSyntax get_EndBlockStatement();
    public virtual TypeBlockSyntax WithBlockStatement(TypeStatementSyntax blockStatement);
    public virtual TypeBlockSyntax WithEndBlockStatement(EndBlockStatementSyntax endBlockStatement);
    public StructureStatementSyntax get_Begin();
    public EndBlockStatementSyntax get_End();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public StructureBlockSyntax WithBegin(StructureStatementSyntax begin);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public StructureBlockSyntax WithEnd(EndBlockStatementSyntax end);
    public StructureStatementSyntax get_StructureStatement();
    public StructureBlockSyntax WithStructureStatement(StructureStatementSyntax structureStatement);
    public SyntaxList`1<InheritsStatementSyntax> get_Inherits();
    internal virtual SyntaxList`1<InheritsStatementSyntax> GetInheritsCore();
    public StructureBlockSyntax WithInherits(SyntaxList`1<InheritsStatementSyntax> inherits);
    public StructureBlockSyntax AddInherits(InheritsStatementSyntax[] items);
    public SyntaxList`1<ImplementsStatementSyntax> get_Implements();
    internal virtual SyntaxList`1<ImplementsStatementSyntax> GetImplementsCore();
    public StructureBlockSyntax WithImplements(SyntaxList`1<ImplementsStatementSyntax> implements);
    public StructureBlockSyntax AddImplements(ImplementsStatementSyntax[] items);
    public SyntaxList`1<StatementSyntax> get_Members();
    internal virtual SyntaxList`1<StatementSyntax> GetMembersCore();
    public StructureBlockSyntax WithMembers(SyntaxList`1<StatementSyntax> members);
    public StructureBlockSyntax AddMembers(StatementSyntax[] items);
    public EndBlockStatementSyntax get_EndStructureStatement();
    public StructureBlockSyntax WithEndStructureStatement(EndBlockStatementSyntax endStructureStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public StructureBlockSyntax Update(StructureStatementSyntax structureStatement, SyntaxList`1<InheritsStatementSyntax> inherits, SyntaxList`1<ImplementsStatementSyntax> implements, SyntaxList`1<StatementSyntax> members, EndBlockStatementSyntax endStructureStatement);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.StructuredTriviaSyntax : VisualBasicSyntaxNode {
    private SyntaxTrivia _parentTrivia;
    public SyntaxTrivia ParentTrivia { get; }
    internal StructuredTriviaSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal static StructuredTriviaSyntax Create(SyntaxTrivia trivia);
    public virtual override SyntaxTrivia get_ParentTrivia();
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.StructureStatementSyntax : TypeStatementSyntax {
    public SyntaxToken DeclarationKeyword { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public SyntaxToken Keyword { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken StructureKeyword { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    internal StructureStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal StructureStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode attributeLists, GreenNode modifiers, KeywordSyntax structureKeyword, IdentifierTokenSyntax identifier, TypeParameterListSyntax typeParameterList);
    public virtual SyntaxToken get_DeclarationKeyword();
    public virtual TypeStatementSyntax WithDeclarationKeyword(SyntaxToken keyword);
    public SyntaxToken get_Keyword();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public StructureStatementSyntax WithKeyword(SyntaxToken keyword);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual SyntaxList`1<AttributeListSyntax> GetAttributeListsCore();
    public StructureStatementSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public StructureStatementSyntax AddAttributeLists(AttributeListSyntax[] items);
    public SyntaxTokenList get_Modifiers();
    internal virtual SyntaxTokenList GetModifiersCore();
    public StructureStatementSyntax WithModifiers(SyntaxTokenList modifiers);
    public StructureStatementSyntax AddModifiers(SyntaxToken[] items);
    public SyntaxToken get_StructureKeyword();
    public StructureStatementSyntax WithStructureKeyword(SyntaxToken structureKeyword);
    public SyntaxToken get_Identifier();
    internal virtual SyntaxToken GetIdentifierCore();
    public StructureStatementSyntax WithIdentifier(SyntaxToken identifier);
    public TypeParameterListSyntax get_TypeParameterList();
    internal virtual TypeParameterListSyntax GetTypeParameterListCore();
    public StructureStatementSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList);
    public StructureStatementSyntax AddTypeParameterListParameters(TypeParameterSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public StructureStatementSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken structureKeyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.SubNewStatementSyntax : MethodBaseSyntax {
    public SyntaxToken DeclarationKeyword { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public SyntaxToken Keyword { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken SubKeyword { get; }
    public SyntaxToken NewKeyword { get; }
    public ParameterListSyntax ParameterList { get; }
    internal SubNewStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal SubNewStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode attributeLists, GreenNode modifiers, KeywordSyntax subKeyword, KeywordSyntax newKeyword, ParameterListSyntax parameterList);
    public virtual SyntaxToken get_DeclarationKeyword();
    public virtual MethodBaseSyntax WithDeclarationKeyword(SyntaxToken keyword);
    public SyntaxToken get_Keyword();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete.", "True")]
public SubNewStatementSyntax WithKeyword(SyntaxToken keyword);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual SyntaxList`1<AttributeListSyntax> GetAttributeListsCore();
    public SubNewStatementSyntax WithAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists);
    public SubNewStatementSyntax AddAttributeLists(AttributeListSyntax[] items);
    public SyntaxTokenList get_Modifiers();
    internal virtual SyntaxTokenList GetModifiersCore();
    public SubNewStatementSyntax WithModifiers(SyntaxTokenList modifiers);
    public SubNewStatementSyntax AddModifiers(SyntaxToken[] items);
    public SyntaxToken get_SubKeyword();
    public SubNewStatementSyntax WithSubKeyword(SyntaxToken subKeyword);
    public SyntaxToken get_NewKeyword();
    public SubNewStatementSyntax WithNewKeyword(SyntaxToken newKeyword);
    public ParameterListSyntax get_ParameterList();
    internal virtual ParameterListSyntax GetParameterListCore();
    public SubNewStatementSyntax WithParameterList(ParameterListSyntax parameterList);
    public SubNewStatementSyntax AddParameterListParameters(ParameterSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public SubNewStatementSyntax Update(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken subKeyword, SyntaxToken newKeyword, ParameterListSyntax parameterList);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockBlockSyntax : ExecutableStatementSyntax {
    internal SyncLockStatementSyntax _syncLockStatement;
    internal SyntaxNode _statements;
    internal EndBlockStatementSyntax _endSyncLockStatement;
    public SyncLockStatementSyntax SyncLockStatement { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    public EndBlockStatementSyntax EndSyncLockStatement { get; }
    internal SyncLockBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal SyncLockBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyncLockStatementSyntax syncLockStatement, SyntaxNode statements, EndBlockStatementSyntax endSyncLockStatement);
    public SyncLockStatementSyntax get_SyncLockStatement();
    public SyncLockBlockSyntax WithSyncLockStatement(SyncLockStatementSyntax syncLockStatement);
    public SyntaxList`1<StatementSyntax> get_Statements();
    public SyncLockBlockSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public SyncLockBlockSyntax AddStatements(StatementSyntax[] items);
    public EndBlockStatementSyntax get_EndSyncLockStatement();
    public SyncLockBlockSyntax WithEndSyncLockStatement(EndBlockStatementSyntax endSyncLockStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public SyncLockBlockSyntax Update(SyncLockStatementSyntax syncLockStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endSyncLockStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.SyncLockStatementSyntax : StatementSyntax {
    internal ExpressionSyntax _expression;
    public SyntaxToken SyncLockKeyword { get; }
    public ExpressionSyntax Expression { get; }
    internal SyncLockStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal SyncLockStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax syncLockKeyword, ExpressionSyntax expression);
    public SyntaxToken get_SyncLockKeyword();
    public SyncLockStatementSyntax WithSyncLockKeyword(SyntaxToken syncLockKeyword);
    public ExpressionSyntax get_Expression();
    public SyncLockStatementSyntax WithExpression(ExpressionSyntax expression);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public SyncLockStatementSyntax Update(SyntaxToken syncLockKeyword, ExpressionSyntax expression);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.SyntaxEquivalence : object {
    internal static bool AreEquivalent(SyntaxTree before, SyntaxTree after, Func`2<SyntaxKind, bool> ignoreChildNode, bool topLevel);
    public static bool AreEquivalent(SyntaxNode before, SyntaxNode after, Func`2<SyntaxKind, bool> ignoreChildNode, bool topLevel);
    public static bool AreEquivalent(SyntaxTokenList before, SyntaxTokenList after);
    public static bool AreEquivalent(SyntaxToken before, SyntaxToken after);
    private static bool AreTokensEquivalent(GreenNode before, GreenNode after);
    private static bool AreEquivalentRecursive(GreenNode before, GreenNode after, SyntaxKind parentKind, Func`2<SyntaxKind, bool> ignoreChildNode, bool topLevel);
    private static bool AreModifiersEquivalent(GreenNode before, GreenNode after, SyntaxKind kind);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.SyntaxList : VisualBasicSyntaxNode {
    internal SyntaxList(VisualBasicSyntaxNode green, SyntaxNode parent, int position);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.SyntaxListBuilder : object {
    private int _count;
    private ArrayElement`1[] _nodes;
    internal int Count { get; }
    internal SyntaxListBuilder(int size);
    internal SyntaxListBuilder Add(SyntaxNode item);
    internal SyntaxListBuilder AddInternal(GreenNode item);
    internal SyntaxListBuilder AddRange(SyntaxList`1<TNode> list);
    internal SyntaxListBuilder AddRange(SyntaxNode[] items);
    internal SyntaxListBuilder AddRange(SyntaxList`1<SyntaxNode> list);
    internal SyntaxListBuilder AddRange(SyntaxNodeOrTokenList list);
    internal SyntaxListBuilder AddRange(SyntaxList`1<SyntaxNode> list, int offset, int length);
    internal SyntaxListBuilder AddRange(SyntaxNode[] items, int offset, int length);
    internal SyntaxListBuilder AddRange(SyntaxList`1<TNode> list, int offset, int length);
    internal SyntaxListBuilder AddRange(SyntaxNodeOrTokenList list, int offset, int length);
    internal SyntaxListBuilder AddRange(SyntaxTokenList list, int offset, int length);
    internal bool Any(SyntaxKind kind);
    internal void RemoveLast();
    internal void Clear();
    private void Grow(int size);
    internal ArrayElement`1[] ToGreenArray();
    internal GreenNode ToListNode();
    [ConditionalAttribute("DEBUG")]
private void Validate(int start, int end);
    internal int get_Count();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.SyntaxListBuilder`1 : ValueType {
    private SyntaxListBuilder _builder;
    public bool IsNull { get; }
    public int Count { get; }
    public SyntaxListBuilder`1(int size);
    internal SyntaxListBuilder`1(SyntaxListBuilder builder);
    public static SyntaxListBuilder`1<TNode> Create();
    public bool get_IsNull();
    public int get_Count();
    public void Clear();
    public SyntaxListBuilder`1<TNode> Add(TNode node);
    public SyntaxListBuilder`1<TNode> AddRange(TNode[] items, int offset, int length);
    public SyntaxListBuilder`1<TNode> AddRange(SyntaxList`1<TNode> nodes);
    public SyntaxListBuilder`1<TNode> AddRange(SyntaxList`1<TNode> nodes, int offset, int length);
    public bool Any(SyntaxKind kind);
    public SyntaxList`1<TNode> ToList();
    public static SyntaxList`1<TNode> op_Implicit(SyntaxListBuilder`1<TNode> builder);
}
[StandardModuleAttribute]
[ExtensionAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.SyntaxListBuilderExtensions : object {
    [ExtensionAttribute]
internal static SyntaxList`1<SyntaxNode> ToList(SyntaxListBuilder builder);
    [ExtensionAttribute]
internal static SeparatedSyntaxList`1<TNode> ToSeparatedList(SyntaxListBuilder builder);
    [ExtensionAttribute]
internal static SyntaxList`1<TNode> ToList(SyntaxListBuilder builder);
    [ExtensionAttribute]
internal static SyntaxTokenList ToTokenList(SyntaxListBuilder builder);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.SyntaxNavigator : AbstractSyntaxNavigator {
    public static AbstractSyntaxNavigator Instance;
    private Func`2[] _stepIntoFunctions;
    private static SyntaxNavigator();
    protected virtual Func`2<SyntaxTrivia, bool> GetStepIntoFunction(bool skipped, bool directives, bool docComments);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.SyntaxNodeOrTokenListBuilder : object {
    private int _count;
    private VisualBasicSyntaxNode[] _nodes;
    public int Count { get; }
    public SyntaxNodeOrToken Item { get; public set; }
    internal SyntaxNodeOrTokenListBuilder(int size);
    public static SyntaxNodeOrTokenListBuilder Create();
    internal void Add(VisualBasicSyntaxNode item);
    public void Add(SyntaxNodeOrToken item);
    public void AddRange(SyntaxNodeOrTokenList list);
    public void AddRange(SyntaxNodeOrTokenList list, int offset, int length);
    public void AddRange(IEnumerable`1<SyntaxNodeOrToken> list);
    internal void RemoveLast();
    public void Clear();
    private void Grow(int size);
    public SyntaxNodeOrTokenList ToList();
    public int get_Count();
    public SyntaxNodeOrToken get_Item(int index);
    public void set_Item(int index, SyntaxNodeOrToken value);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.SyntaxNodeRemover : object {
    internal static TRoot RemoveNodes(TRoot root, IEnumerable`1<SyntaxNode> nodes, SyntaxRemoveOptions options);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.SyntaxNormalizer : VisualBasicSyntaxRewriter {
    private TextSpan _consideredSpan;
    private string _indentWhitespace;
    private SyntaxTrivia _eolTrivia;
    private bool _useElasticTrivia;
    private bool _useDefaultCasing;
    private bool _isInStructuredTrivia;
    private SyntaxToken _previousToken;
    private bool _afterLineBreak;
    private bool _afterIndentation;
    private Dictionary`2<SyntaxToken, int> _lineBreaksAfterToken;
    private HashSet`1<SyntaxNode> _lastStatementsInBlocks;
    private int _indentationDepth;
    private ArrayBuilder`1<SyntaxTrivia> _indentations;
    private SyntaxNormalizer(TextSpan consideredSpan, string indentWhitespace, string eolWhitespace, bool useElasticTrivia, bool useDefaultCasing);
    internal static SyntaxNode Normalize(TNode node, string indentWhitespace, string eolWhitespace, bool useElasticTrivia, bool useDefaultCasing);
    internal static SyntaxToken Normalize(SyntaxToken token, string indentWhitespace, string eolWhitespace, bool useElasticTrivia, bool useDefaultCasing);
    internal static SyntaxTriviaList Normalize(SyntaxTriviaList trivia, string indentWhitespace, string eolWhitespace, bool useElasticTrivia, bool useDefaultCasing);
    private void Free();
    private SyntaxTrivia GetIdentation(int count);
    public virtual SyntaxToken VisitToken(SyntaxToken token);
    private SyntaxTriviaList RewriteTrivia(SyntaxTriviaList triviaList, int depth, bool isTrailing, bool mustBeIndented, bool mustHaveSeparator, int lineBreaksAfter, int lineBreaksBefore);
    private bool IsLastTokenOnLine(SyntaxToken token);
    private int LineBreaksBetween(SyntaxToken currentToken, SyntaxToken nextToken);
    private int GetIndentationDepth();
    private int GetIndentationDepth(SyntaxTrivia trivia);
    private SyntaxTrivia GetSpace();
    private SyntaxTrivia GetEndOfLine();
    private bool NeedsSeparatorBetween(SyntaxTrivia trivia);
    private bool NeedsLineBreakBetween(SyntaxTrivia trivia, SyntaxTrivia nextTrivia, bool isTrailingTrivia);
    private bool NeedsLineBreakAfter(SyntaxTrivia trivia);
    private bool NeedsLineBreakBefore(SyntaxTrivia trivia);
    private bool NeedsIndentAfterLineBreak(SyntaxTrivia trivia);
    private bool NeedsSeparator(SyntaxToken token, SyntaxToken nextToken);
    private bool EndsInLineBreak(SyntaxTrivia trivia);
    private static bool IsNewLineChar(char ch);
    private SyntaxTrivia VisitStructuredTrivia(SyntaxTrivia trivia);
    private SyntaxToken GetNextRelevantToken(SyntaxToken token);
    private void AddLinebreaksAfterElementsIfNeeded(SyntaxList`1<TNode> list, int linebreaksBetweenElements, int linebreaksAfterLastElement);
    private void AddLinebreaksAfterTokenIfNeeded(SyntaxToken node, int linebreaksAfterToken);
    private bool EndsWithColonSeparator(SyntaxToken node);
    private void MarkLastStatementIfNeeded(SyntaxList`1<TNode> list);
    public virtual SyntaxNode VisitCompilationUnit(CompilationUnitSyntax node);
    public virtual SyntaxNode VisitNamespaceBlock(NamespaceBlockSyntax node);
    public virtual SyntaxNode VisitModuleBlock(ModuleBlockSyntax node);
    public virtual SyntaxNode VisitClassBlock(ClassBlockSyntax node);
    public virtual SyntaxNode VisitStructureBlock(StructureBlockSyntax node);
    public virtual SyntaxNode VisitInterfaceBlock(InterfaceBlockSyntax node);
    private void VisitTypeBlockSyntax(TypeBlockSyntax node);
    public virtual SyntaxNode VisitMultiLineIfBlock(MultiLineIfBlockSyntax node);
    public virtual SyntaxNode VisitEventBlock(EventBlockSyntax node);
    public virtual SyntaxNode VisitDoLoopBlock(DoLoopBlockSyntax node);
    public virtual SyntaxNode VisitSyncLockBlock(SyncLockBlockSyntax node);
    public virtual SyntaxNode VisitMethodBlock(MethodBlockSyntax node);
    public virtual SyntaxNode VisitConstructorBlock(ConstructorBlockSyntax node);
    public virtual SyntaxNode VisitOperatorBlock(OperatorBlockSyntax node);
    public virtual SyntaxNode VisitAccessorBlock(AccessorBlockSyntax node);
    public virtual SyntaxNode VisitEnumBlock(EnumBlockSyntax node);
    public virtual SyntaxNode VisitWhileBlock(WhileBlockSyntax node);
    public virtual SyntaxNode VisitForBlock(ForBlockSyntax node);
    public virtual SyntaxNode VisitForEachBlock(ForEachBlockSyntax node);
    private void VisitForOrForEachBlock(ForOrForEachBlockSyntax node);
    public virtual SyntaxNode VisitUsingBlock(UsingBlockSyntax node);
    public virtual SyntaxNode VisitWithBlock(WithBlockSyntax node);
    public virtual SyntaxNode VisitSelectBlock(SelectBlockSyntax node);
    public virtual SyntaxNode VisitCaseBlock(CaseBlockSyntax node);
    public virtual SyntaxNode VisitTryBlock(TryBlockSyntax node);
    public virtual SyntaxNode VisitCatchBlock(CatchBlockSyntax node);
    public virtual SyntaxNode VisitFinallyBlock(FinallyBlockSyntax node);
    public virtual SyntaxNode VisitPropertyBlock(PropertyBlockSyntax node);
    public virtual SyntaxNode VisitElseBlock(ElseBlockSyntax node);
    public virtual SyntaxNode VisitElseIfBlock(ElseIfBlockSyntax node);
    public virtual SyntaxNode VisitMultiLineLambdaExpression(MultiLineLambdaExpressionSyntax node);
    public virtual SyntaxNode VisitConstDirectiveTrivia(ConstDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitExternalSourceDirectiveTrivia(ExternalSourceDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitEndExternalSourceDirectiveTrivia(EndExternalSourceDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitExternalChecksumDirectiveTrivia(ExternalChecksumDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitEnableWarningDirectiveTrivia(EnableWarningDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitDisableWarningDirectiveTrivia(DisableWarningDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitAttributeList(AttributeListSyntax node);
    public virtual SyntaxNode VisitEndBlockStatement(EndBlockStatementSyntax node);
    public virtual SyntaxNode VisitElseStatement(ElseStatementSyntax node);
    public virtual SyntaxNode VisitElseIfStatement(ElseIfStatementSyntax node);
    public virtual SyntaxNode VisitIfStatement(IfStatementSyntax node);
    public virtual SyntaxNode VisitWithStatement(WithStatementSyntax node);
    public virtual SyntaxNode VisitSyncLockStatement(SyncLockStatementSyntax node);
    public virtual SyntaxNode VisitModuleStatement(ModuleStatementSyntax node);
    public virtual SyntaxNode VisitNamespaceStatement(NamespaceStatementSyntax node);
    public virtual SyntaxNode VisitInterfaceStatement(InterfaceStatementSyntax node);
    public virtual SyntaxNode VisitStructureStatement(StructureStatementSyntax node);
    public virtual SyntaxNode VisitEnumStatement(EnumStatementSyntax node);
    public virtual SyntaxNode VisitClassStatement(ClassStatementSyntax node);
    public virtual SyntaxNode VisitWhileStatement(WhileStatementSyntax node);
    public virtual SyntaxNode VisitDoStatement(DoStatementSyntax node);
    public virtual SyntaxNode VisitSelectStatement(SelectStatementSyntax node);
    public virtual SyntaxNode VisitCaseStatement(CaseStatementSyntax node);
    public virtual SyntaxNode VisitLoopStatement(LoopStatementSyntax node);
    public virtual SyntaxNode VisitForStatement(ForStatementSyntax node);
    public virtual SyntaxNode VisitForEachStatement(ForEachStatementSyntax node);
    public virtual SyntaxNode VisitTryStatement(TryStatementSyntax node);
    public virtual SyntaxNode VisitCatchStatement(CatchStatementSyntax node);
    public virtual SyntaxNode VisitFinallyStatement(FinallyStatementSyntax node);
    public virtual SyntaxNode VisitUsingStatement(UsingStatementSyntax node);
    public virtual SyntaxNode VisitMethodStatement(MethodStatementSyntax node);
    public virtual SyntaxNode VisitSubNewStatement(SubNewStatementSyntax node);
    public virtual SyntaxNode VisitAccessorStatement(AccessorStatementSyntax node);
    public virtual SyntaxNode VisitOperatorStatement(OperatorStatementSyntax node);
    public virtual SyntaxNode VisitEventStatement(EventStatementSyntax node);
    public virtual SyntaxNode VisitPropertyStatement(PropertyStatementSyntax node);
    public virtual SyntaxNode VisitLabelStatement(LabelStatementSyntax node);
    public virtual SyntaxNode VisitNextStatement(NextStatementSyntax node);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.SyntaxReplacer : object {
    internal static SyntaxNode Replace(SyntaxNode root, IEnumerable`1<TNode> nodes, Func`3<TNode, TNode, SyntaxNode> computeReplacementNode, IEnumerable`1<SyntaxToken> tokens, Func`3<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken, IEnumerable`1<SyntaxTrivia> trivia, Func`3<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia);
    internal static SyntaxToken Replace(SyntaxToken root, IEnumerable`1<SyntaxNode> nodes, Func`3<SyntaxNode, SyntaxNode, SyntaxNode> computeReplacementNode, IEnumerable`1<SyntaxToken> tokens, Func`3<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken, IEnumerable`1<SyntaxTrivia> trivia, Func`3<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia);
    public static SyntaxNode ReplaceNodeInList(SyntaxNode root, SyntaxNode originalNode, IEnumerable`1<SyntaxNode> newNodes);
    public static SyntaxNode InsertNodeInList(SyntaxNode root, SyntaxNode nodeInList, IEnumerable`1<SyntaxNode> nodesToInsert, bool insertBefore);
    public static SyntaxNode ReplaceTokenInList(SyntaxNode root, SyntaxToken tokenInList, IEnumerable`1<SyntaxToken> newTokens);
    public static SyntaxNode InsertTokenInList(SyntaxNode root, SyntaxToken tokenInList, IEnumerable`1<SyntaxToken> newTokens, bool insertBefore);
    public static SyntaxNode ReplaceTriviaInList(SyntaxNode root, SyntaxTrivia triviaInList, IEnumerable`1<SyntaxTrivia> newTrivia);
    public static SyntaxNode InsertTriviaInList(SyntaxNode root, SyntaxTrivia triviaInList, IEnumerable`1<SyntaxTrivia> newTrivia, bool insertBefore);
    public static SyntaxToken ReplaceTriviaInList(SyntaxToken root, SyntaxTrivia triviaInList, IEnumerable`1<SyntaxTrivia> newTrivia);
    public static SyntaxToken InsertTriviaInList(SyntaxToken root, SyntaxTrivia triviaInList, IEnumerable`1<SyntaxTrivia> newTrivia, bool insertBefore);
    private static InvalidOperationException GetItemNotListElementException();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.SyntaxTokenListBuilder : object {
    private int _count;
    private VisualBasicSyntaxNode[] _nodes;
    public int Count { get; }
    public SyntaxTokenListBuilder(int size);
    public static SyntaxTokenListBuilder Create();
    public int get_Count();
    internal SyntaxTokenListBuilder Add(SyntaxToken item);
    public SyntaxTokenListBuilder Add(SyntaxToken item);
    public SyntaxTokenListBuilder Add(SyntaxTokenList list);
    public SyntaxTokenListBuilder Add(SyntaxTokenList list, int offset, int length);
    public void Add(SyntaxToken[] list);
    public void Add(SyntaxToken[] list, int offset, int length);
    private void Grow(int size);
    public static SyntaxTokenList op_Implicit(SyntaxTokenListBuilder builder);
    public SyntaxTokenList ToList();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.SyntaxTriviaListBuilder : object {
    private int _count;
    private SyntaxTrivia[] _nodes;
    public int Count { get; }
    public SyntaxTrivia Item { get; }
    public SyntaxTriviaListBuilder(int size);
    public int get_Count();
    public SyntaxTrivia get_Item(int index);
    public void Add(SyntaxTriviaList list);
    public void Add(SyntaxTrivia[] items);
    public SyntaxTriviaListBuilder Add(SyntaxTrivia item);
    public void Add(SyntaxTrivia[] items, int sourceOffset, int length);
    public void Add(SyntaxTriviaList list, int sourceOffset, int length);
    public void Clear();
    public static SyntaxTriviaListBuilder Create();
    private void Grow(int size);
    public static SyntaxTriviaList op_Implicit(SyntaxTriviaListBuilder builder);
    public SyntaxTriviaList ToList();
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.TernaryConditionalExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax _condition;
    internal ExpressionSyntax _whenTrue;
    internal ExpressionSyntax _whenFalse;
    public SyntaxToken IfKeyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Condition { get; }
    public SyntaxToken FirstCommaToken { get; }
    public ExpressionSyntax WhenTrue { get; }
    public SyntaxToken SecondCommaToken { get; }
    public ExpressionSyntax WhenFalse { get; }
    public SyntaxToken CloseParenToken { get; }
    internal TernaryConditionalExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal TernaryConditionalExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax ifKeyword, PunctuationSyntax openParenToken, ExpressionSyntax condition, PunctuationSyntax firstCommaToken, ExpressionSyntax whenTrue, PunctuationSyntax secondCommaToken, ExpressionSyntax whenFalse, PunctuationSyntax closeParenToken);
    public SyntaxToken get_IfKeyword();
    public TernaryConditionalExpressionSyntax WithIfKeyword(SyntaxToken ifKeyword);
    public SyntaxToken get_OpenParenToken();
    public TernaryConditionalExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public ExpressionSyntax get_Condition();
    public TernaryConditionalExpressionSyntax WithCondition(ExpressionSyntax condition);
    public SyntaxToken get_FirstCommaToken();
    public TernaryConditionalExpressionSyntax WithFirstCommaToken(SyntaxToken firstCommaToken);
    public ExpressionSyntax get_WhenTrue();
    public TernaryConditionalExpressionSyntax WithWhenTrue(ExpressionSyntax whenTrue);
    public SyntaxToken get_SecondCommaToken();
    public TernaryConditionalExpressionSyntax WithSecondCommaToken(SyntaxToken secondCommaToken);
    public ExpressionSyntax get_WhenFalse();
    public TernaryConditionalExpressionSyntax WithWhenFalse(ExpressionSyntax whenFalse);
    public SyntaxToken get_CloseParenToken();
    public TernaryConditionalExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public TernaryConditionalExpressionSyntax Update(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken firstCommaToken, ExpressionSyntax whenTrue, SyntaxToken secondCommaToken, ExpressionSyntax whenFalse, SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.ThrowStatementSyntax : ExecutableStatementSyntax {
    internal ExpressionSyntax _expression;
    public SyntaxToken ThrowKeyword { get; }
    public ExpressionSyntax Expression { get; }
    internal ThrowStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal ThrowStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax throwKeyword, ExpressionSyntax expression);
    public SyntaxToken get_ThrowKeyword();
    public ThrowStatementSyntax WithThrowKeyword(SyntaxToken throwKeyword);
    public ExpressionSyntax get_Expression();
    public ThrowStatementSyntax WithExpression(ExpressionSyntax expression);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public ThrowStatementSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.TryBlockSyntax : ExecutableStatementSyntax {
    internal TryStatementSyntax _tryStatement;
    internal SyntaxNode _statements;
    internal SyntaxNode _catchBlocks;
    internal FinallyBlockSyntax _finallyBlock;
    internal EndBlockStatementSyntax _endTryStatement;
    public TryStatementSyntax TryStatement { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    public SyntaxList`1<CatchBlockSyntax> CatchBlocks { get; }
    public FinallyBlockSyntax FinallyBlock { get; }
    public EndBlockStatementSyntax EndTryStatement { get; }
    internal TryBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal TryBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, TryStatementSyntax tryStatement, SyntaxNode statements, SyntaxNode catchBlocks, FinallyBlockSyntax finallyBlock, EndBlockStatementSyntax endTryStatement);
    public TryStatementSyntax get_TryStatement();
    public TryBlockSyntax WithTryStatement(TryStatementSyntax tryStatement);
    public SyntaxList`1<StatementSyntax> get_Statements();
    public TryBlockSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public TryBlockSyntax AddStatements(StatementSyntax[] items);
    public SyntaxList`1<CatchBlockSyntax> get_CatchBlocks();
    public TryBlockSyntax WithCatchBlocks(SyntaxList`1<CatchBlockSyntax> catchBlocks);
    public TryBlockSyntax AddCatchBlocks(CatchBlockSyntax[] items);
    public FinallyBlockSyntax get_FinallyBlock();
    public TryBlockSyntax WithFinallyBlock(FinallyBlockSyntax finallyBlock);
    public TryBlockSyntax AddFinallyBlockStatements(StatementSyntax[] items);
    public EndBlockStatementSyntax get_EndTryStatement();
    public TryBlockSyntax WithEndTryStatement(EndBlockStatementSyntax endTryStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public TryBlockSyntax Update(TryStatementSyntax tryStatement, SyntaxList`1<StatementSyntax> statements, SyntaxList`1<CatchBlockSyntax> catchBlocks, FinallyBlockSyntax finallyBlock, EndBlockStatementSyntax endTryStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.TryCastExpressionSyntax : CastExpressionSyntax {
    public SyntaxToken Keyword { get; }
    public SyntaxToken OpenParenToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken CommaToken { get; }
    public TypeSyntax Type { get; }
    public SyntaxToken CloseParenToken { get; }
    internal TryCastExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal TryCastExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax keyword, PunctuationSyntax openParenToken, ExpressionSyntax expression, PunctuationSyntax commaToken, TypeSyntax type, PunctuationSyntax closeParenToken);
    public SyntaxToken get_Keyword();
    internal virtual SyntaxToken GetKeywordCore();
    public TryCastExpressionSyntax WithKeyword(SyntaxToken keyword);
    public SyntaxToken get_OpenParenToken();
    internal virtual SyntaxToken GetOpenParenTokenCore();
    public TryCastExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public ExpressionSyntax get_Expression();
    internal virtual ExpressionSyntax GetExpressionCore();
    public TryCastExpressionSyntax WithExpression(ExpressionSyntax expression);
    public SyntaxToken get_CommaToken();
    internal virtual SyntaxToken GetCommaTokenCore();
    public TryCastExpressionSyntax WithCommaToken(SyntaxToken commaToken);
    public TypeSyntax get_Type();
    internal virtual TypeSyntax GetTypeCore();
    public TryCastExpressionSyntax WithType(TypeSyntax type);
    public SyntaxToken get_CloseParenToken();
    internal virtual SyntaxToken GetCloseParenTokenCore();
    public TryCastExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public TryCastExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken commaToken, TypeSyntax type, SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.TryStatementSyntax : StatementSyntax {
    public SyntaxToken TryKeyword { get; }
    internal TryStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal TryStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax tryKeyword);
    public SyntaxToken get_TryKeyword();
    public TryStatementSyntax WithTryKeyword(SyntaxToken tryKeyword);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public TryStatementSyntax Update(SyntaxToken tryKeyword);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeArgumentListSyntax : VisualBasicSyntaxNode {
    internal SyntaxNode _arguments;
    public SyntaxToken OpenParenToken { get; }
    public SyntaxToken OfKeyword { get; }
    public SeparatedSyntaxList`1<TypeSyntax> Arguments { get; }
    public SyntaxToken CloseParenToken { get; }
    internal TypeArgumentListSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal TypeArgumentListSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax openParenToken, KeywordSyntax ofKeyword, SyntaxNode arguments, PunctuationSyntax closeParenToken);
    public SyntaxToken get_OpenParenToken();
    public TypeArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public SyntaxToken get_OfKeyword();
    public TypeArgumentListSyntax WithOfKeyword(SyntaxToken ofKeyword);
    public SeparatedSyntaxList`1<TypeSyntax> get_Arguments();
    public TypeArgumentListSyntax WithArguments(SeparatedSyntaxList`1<TypeSyntax> arguments);
    public TypeArgumentListSyntax AddArguments(TypeSyntax[] items);
    public SyntaxToken get_CloseParenToken();
    public TypeArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public TypeArgumentListSyntax Update(SyntaxToken openParenToken, SyntaxToken ofKeyword, SeparatedSyntaxList`1<TypeSyntax> arguments, SyntaxToken closeParenToken);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeBlockSyntax : DeclarationStatementSyntax {
    internal SyntaxNode _inherits;
    internal SyntaxNode _implements;
    internal SyntaxNode _members;
    public TypeStatementSyntax BlockStatement { get; }
    public EndBlockStatementSyntax EndBlockStatement { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use BlockStatement or a more specific property (e.g. ClassStatement) instead.", "True")]
public TypeStatementSyntax Begin { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use EndBlockStatement or a more specific property (e.g. EndClassStatement) instead.", "True")]
public EndBlockStatementSyntax End { get; }
    public SyntaxList`1<InheritsStatementSyntax> Inherits { get; }
    public SyntaxList`1<ImplementsStatementSyntax> Implements { get; }
    public SyntaxList`1<StatementSyntax> Members { get; }
    internal TypeBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    public abstract virtual TypeStatementSyntax get_BlockStatement();
    public abstract virtual EndBlockStatementSyntax get_EndBlockStatement();
    public abstract virtual TypeBlockSyntax WithBlockStatement(TypeStatementSyntax blockStatement);
    public abstract virtual TypeBlockSyntax WithEndBlockStatement(EndBlockStatementSyntax endBlockStatement);
    public TypeStatementSyntax get_Begin();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use WithBlockStatement or a more specific property (e.g. WithClassStatement) instead.", "True")]
public TypeBlockSyntax WithBegin(TypeStatementSyntax begin);
    public EndBlockStatementSyntax get_End();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use WithEndBlockStatement or a more specific property (e.g. WithEndClassStatement) instead.", "True")]
public TypeBlockSyntax WithEnd(EndBlockStatementSyntax end);
    public SyntaxList`1<InheritsStatementSyntax> get_Inherits();
    internal virtual SyntaxList`1<InheritsStatementSyntax> GetInheritsCore();
    public SyntaxList`1<ImplementsStatementSyntax> get_Implements();
    internal virtual SyntaxList`1<ImplementsStatementSyntax> GetImplementsCore();
    public SyntaxList`1<StatementSyntax> get_Members();
    internal virtual SyntaxList`1<StatementSyntax> GetMembersCore();
}
public enum Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeCharacter : Enum {
    public int value__;
    public static TypeCharacter None;
    public static TypeCharacter Integer;
    public static TypeCharacter Long;
    public static TypeCharacter Decimal;
    public static TypeCharacter Single;
    public static TypeCharacter Double;
    public static TypeCharacter String;
    public static TypeCharacter ShortLiteral;
    public static TypeCharacter UShortLiteral;
    public static TypeCharacter IntegerLiteral;
    public static TypeCharacter UIntegerLiteral;
    public static TypeCharacter LongLiteral;
    public static TypeCharacter ULongLiteral;
    public static TypeCharacter SingleLiteral;
    public static TypeCharacter DoubleLiteral;
    public static TypeCharacter DecimalLiteral;
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeConstraintSyntax : ConstraintSyntax {
    internal TypeSyntax _type;
    public TypeSyntax Type { get; }
    internal TypeConstraintSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal TypeConstraintSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, TypeSyntax type);
    public TypeSyntax get_Type();
    public TypeConstraintSyntax WithType(TypeSyntax type);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public TypeConstraintSyntax Update(TypeSyntax type);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeOfExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax _expression;
    internal TypeSyntax _type;
    public SyntaxToken TypeOfKeyword { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken OperatorToken { get; }
    public TypeSyntax Type { get; }
    internal TypeOfExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal TypeOfExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax typeOfKeyword, ExpressionSyntax expression, KeywordSyntax operatorToken, TypeSyntax type);
    public SyntaxToken get_TypeOfKeyword();
    public TypeOfExpressionSyntax WithTypeOfKeyword(SyntaxToken typeOfKeyword);
    public ExpressionSyntax get_Expression();
    public TypeOfExpressionSyntax WithExpression(ExpressionSyntax expression);
    public SyntaxToken get_OperatorToken();
    public TypeOfExpressionSyntax WithOperatorToken(SyntaxToken operatorToken);
    public TypeSyntax get_Type();
    public TypeOfExpressionSyntax WithType(TypeSyntax type);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public TypeOfExpressionSyntax Update(SyntaxKind kind, SyntaxToken typeOfKeyword, ExpressionSyntax expression, SyntaxToken operatorToken, TypeSyntax type);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterConstraintClauseSyntax : VisualBasicSyntaxNode {
    internal TypeParameterConstraintClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterListSyntax : VisualBasicSyntaxNode {
    internal SyntaxNode _parameters;
    public SyntaxToken OpenParenToken { get; }
    public SyntaxToken OfKeyword { get; }
    public SeparatedSyntaxList`1<TypeParameterSyntax> Parameters { get; }
    public SyntaxToken CloseParenToken { get; }
    internal TypeParameterListSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal TypeParameterListSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax openParenToken, KeywordSyntax ofKeyword, SyntaxNode parameters, PunctuationSyntax closeParenToken);
    public SyntaxToken get_OpenParenToken();
    public TypeParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken);
    public SyntaxToken get_OfKeyword();
    public TypeParameterListSyntax WithOfKeyword(SyntaxToken ofKeyword);
    public SeparatedSyntaxList`1<TypeParameterSyntax> get_Parameters();
    public TypeParameterListSyntax WithParameters(SeparatedSyntaxList`1<TypeParameterSyntax> parameters);
    public TypeParameterListSyntax AddParameters(TypeParameterSyntax[] items);
    public SyntaxToken get_CloseParenToken();
    public TypeParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public TypeParameterListSyntax Update(SyntaxToken openParenToken, SyntaxToken ofKeyword, SeparatedSyntaxList`1<TypeParameterSyntax> parameters, SyntaxToken closeParenToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterMultipleConstraintClauseSyntax : TypeParameterConstraintClauseSyntax {
    internal SyntaxNode _constraints;
    public SyntaxToken AsKeyword { get; }
    public SyntaxToken OpenBraceToken { get; }
    public SeparatedSyntaxList`1<ConstraintSyntax> Constraints { get; }
    public SyntaxToken CloseBraceToken { get; }
    internal TypeParameterMultipleConstraintClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal TypeParameterMultipleConstraintClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax asKeyword, PunctuationSyntax openBraceToken, SyntaxNode constraints, PunctuationSyntax closeBraceToken);
    public SyntaxToken get_AsKeyword();
    public TypeParameterMultipleConstraintClauseSyntax WithAsKeyword(SyntaxToken asKeyword);
    public SyntaxToken get_OpenBraceToken();
    public TypeParameterMultipleConstraintClauseSyntax WithOpenBraceToken(SyntaxToken openBraceToken);
    public SeparatedSyntaxList`1<ConstraintSyntax> get_Constraints();
    public TypeParameterMultipleConstraintClauseSyntax WithConstraints(SeparatedSyntaxList`1<ConstraintSyntax> constraints);
    public TypeParameterMultipleConstraintClauseSyntax AddConstraints(ConstraintSyntax[] items);
    public SyntaxToken get_CloseBraceToken();
    public TypeParameterMultipleConstraintClauseSyntax WithCloseBraceToken(SyntaxToken closeBraceToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public TypeParameterMultipleConstraintClauseSyntax Update(SyntaxToken asKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList`1<ConstraintSyntax> constraints, SyntaxToken closeBraceToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSingleConstraintClauseSyntax : TypeParameterConstraintClauseSyntax {
    internal ConstraintSyntax _constraint;
    public SyntaxToken AsKeyword { get; }
    public ConstraintSyntax Constraint { get; }
    internal TypeParameterSingleConstraintClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal TypeParameterSingleConstraintClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax asKeyword, ConstraintSyntax constraint);
    public SyntaxToken get_AsKeyword();
    public TypeParameterSingleConstraintClauseSyntax WithAsKeyword(SyntaxToken asKeyword);
    public ConstraintSyntax get_Constraint();
    public TypeParameterSingleConstraintClauseSyntax WithConstraint(ConstraintSyntax constraint);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public TypeParameterSingleConstraintClauseSyntax Update(SyntaxToken asKeyword, ConstraintSyntax constraint);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeParameterSyntax : VisualBasicSyntaxNode {
    internal TypeParameterConstraintClauseSyntax _typeParameterConstraintClause;
    public SyntaxToken VarianceKeyword { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterConstraintClauseSyntax TypeParameterConstraintClause { get; }
    internal TypeParameterSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal TypeParameterSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax varianceKeyword, IdentifierTokenSyntax identifier, TypeParameterConstraintClauseSyntax typeParameterConstraintClause);
    public SyntaxToken get_VarianceKeyword();
    public TypeParameterSyntax WithVarianceKeyword(SyntaxToken varianceKeyword);
    public SyntaxToken get_Identifier();
    public TypeParameterSyntax WithIdentifier(SyntaxToken identifier);
    public TypeParameterConstraintClauseSyntax get_TypeParameterConstraintClause();
    public TypeParameterSyntax WithTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax typeParameterConstraintClause);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public TypeParameterSyntax Update(SyntaxToken varianceKeyword, SyntaxToken identifier, TypeParameterConstraintClauseSyntax typeParameterConstraintClause);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeStatementSyntax : DeclarationStatementSyntax {
    internal SyntaxNode _attributeLists;
    internal TypeParameterListSyntax _typeParameterList;
    public int Arity { get; }
    public SyntaxToken DeclarationKeyword { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use DeclarationKeyword or a more specific property (e.g. ClassKeyword) instead.", "True")]
public SyntaxToken Keyword { get; }
    public SyntaxList`1<AttributeListSyntax> AttributeLists { get; }
    public SyntaxTokenList Modifiers { get; }
    public SyntaxToken Identifier { get; }
    public TypeParameterListSyntax TypeParameterList { get; }
    internal TypeStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    public int get_Arity();
    public abstract virtual SyntaxToken get_DeclarationKeyword();
    public abstract virtual TypeStatementSyntax WithDeclarationKeyword(SyntaxToken keyword);
    public SyntaxToken get_Keyword();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use DeclarationKeyword or a more specific property (e.g. WithClassKeyword) instead.", "True")]
public TypeStatementSyntax WithKeyword(SyntaxToken keyword);
    public SyntaxList`1<AttributeListSyntax> get_AttributeLists();
    internal virtual SyntaxList`1<AttributeListSyntax> GetAttributeListsCore();
    public SyntaxTokenList get_Modifiers();
    internal virtual SyntaxTokenList GetModifiersCore();
    public SyntaxToken get_Identifier();
    internal virtual SyntaxToken GetIdentifierCore();
    public TypeParameterListSyntax get_TypeParameterList();
    internal virtual TypeParameterListSyntax GetTypeParameterListCore();
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.TypeSyntax : ExpressionSyntax {
    internal TypeSyntax(GreenNode green, SyntaxNode parent, int startLocation);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.UnaryExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax _operand;
    public SyntaxToken OperatorToken { get; }
    public ExpressionSyntax Operand { get; }
    internal UnaryExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal UnaryExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxToken operatorToken, ExpressionSyntax operand);
    public SyntaxToken get_OperatorToken();
    public UnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken);
    public ExpressionSyntax get_Operand();
    public UnaryExpressionSyntax WithOperand(ExpressionSyntax operand);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public UnaryExpressionSyntax Update(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingBlockSyntax : ExecutableStatementSyntax {
    internal UsingStatementSyntax _usingStatement;
    internal SyntaxNode _statements;
    internal EndBlockStatementSyntax _endUsingStatement;
    public UsingStatementSyntax UsingStatement { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    public EndBlockStatementSyntax EndUsingStatement { get; }
    internal UsingBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal UsingBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, UsingStatementSyntax usingStatement, SyntaxNode statements, EndBlockStatementSyntax endUsingStatement);
    public UsingStatementSyntax get_UsingStatement();
    public UsingBlockSyntax WithUsingStatement(UsingStatementSyntax usingStatement);
    public SyntaxList`1<StatementSyntax> get_Statements();
    public UsingBlockSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public UsingBlockSyntax AddStatements(StatementSyntax[] items);
    public EndBlockStatementSyntax get_EndUsingStatement();
    public UsingBlockSyntax WithEndUsingStatement(EndBlockStatementSyntax endUsingStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public UsingBlockSyntax Update(UsingStatementSyntax usingStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endUsingStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.UsingStatementSyntax : StatementSyntax {
    internal ExpressionSyntax _expression;
    internal SyntaxNode _variables;
    public SyntaxToken UsingKeyword { get; }
    public ExpressionSyntax Expression { get; }
    public SeparatedSyntaxList`1<VariableDeclaratorSyntax> Variables { get; }
    internal UsingStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal UsingStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax usingKeyword, ExpressionSyntax expression, SyntaxNode variables);
    public SyntaxToken get_UsingKeyword();
    public UsingStatementSyntax WithUsingKeyword(SyntaxToken usingKeyword);
    public ExpressionSyntax get_Expression();
    public UsingStatementSyntax WithExpression(ExpressionSyntax expression);
    public SeparatedSyntaxList`1<VariableDeclaratorSyntax> get_Variables();
    public UsingStatementSyntax WithVariables(SeparatedSyntaxList`1<VariableDeclaratorSyntax> variables);
    public UsingStatementSyntax AddVariables(VariableDeclaratorSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public UsingStatementSyntax Update(SyntaxToken usingKeyword, ExpressionSyntax expression, SeparatedSyntaxList`1<VariableDeclaratorSyntax> variables);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableDeclaratorSyntax : VisualBasicSyntaxNode {
    internal SyntaxNode _names;
    internal AsClauseSyntax _asClause;
    internal EqualsValueSyntax _initializer;
    public SeparatedSyntaxList`1<ModifiedIdentifierSyntax> Names { get; }
    public AsClauseSyntax AsClause { get; }
    public EqualsValueSyntax Initializer { get; }
    internal VariableDeclaratorSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal VariableDeclaratorSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, SyntaxNode names, AsClauseSyntax asClause, EqualsValueSyntax initializer);
    public SeparatedSyntaxList`1<ModifiedIdentifierSyntax> get_Names();
    public VariableDeclaratorSyntax WithNames(SeparatedSyntaxList`1<ModifiedIdentifierSyntax> names);
    public VariableDeclaratorSyntax AddNames(ModifiedIdentifierSyntax[] items);
    public AsClauseSyntax get_AsClause();
    public VariableDeclaratorSyntax WithAsClause(AsClauseSyntax asClause);
    public EqualsValueSyntax get_Initializer();
    public VariableDeclaratorSyntax WithInitializer(EqualsValueSyntax initializer);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public VariableDeclaratorSyntax Update(SeparatedSyntaxList`1<ModifiedIdentifierSyntax> names, AsClauseSyntax asClause, EqualsValueSyntax initializer);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.VariableNameEqualsSyntax : VisualBasicSyntaxNode {
    internal ModifiedIdentifierSyntax _identifier;
    internal SimpleAsClauseSyntax _asClause;
    public ModifiedIdentifierSyntax Identifier { get; }
    public SimpleAsClauseSyntax AsClause { get; }
    public SyntaxToken EqualsToken { get; }
    internal VariableNameEqualsSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal VariableNameEqualsSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, PunctuationSyntax equalsToken);
    public ModifiedIdentifierSyntax get_Identifier();
    public VariableNameEqualsSyntax WithIdentifier(ModifiedIdentifierSyntax identifier);
    public SimpleAsClauseSyntax get_AsClause();
    public VariableNameEqualsSyntax WithAsClause(SimpleAsClauseSyntax asClause);
    public SyntaxToken get_EqualsToken();
    public VariableNameEqualsSyntax WithEqualsToken(SyntaxToken equalsToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public VariableNameEqualsSyntax Update(ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, SyntaxToken equalsToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.VisualBasicLineDirectiveMap : LineDirectiveMap`1<DirectiveTriviaSyntax> {
    public VisualBasicLineDirectiveMap(SyntaxTree tree);
    protected virtual bool ShouldAddDirective(DirectiveTriviaSyntax directive);
    protected virtual LineMappingEntry<DirectiveTriviaSyntax> GetEntry(DirectiveTriviaSyntax directive, SourceText sourceText, LineMappingEntry<DirectiveTriviaSyntax> previous);
    protected virtual LineMappingEntry<DirectiveTriviaSyntax> InitializeFirstEntry();
    public virtual LineVisibility GetLineVisibility(SourceText sourceText, int position);
    private LineVisibility GetLineVisibility(int index);
    internal virtual FileLinePositionSpan TranslateSpanAndVisibility(SourceText sourceText, string treeFilePath, TextSpan span, Boolean& isHiddenPosition);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Syntax.VisualBasicWarningStateMap : AbstractWarningStateMap {
    public VisualBasicWarningStateMap(SyntaxTree tree);
    protected virtual WarningStateMapEntry[] CreateWarningStateMapEntries(SyntaxTree syntaxTree);
    private static void GetAllWarningDirectives(SyntaxTree syntaxTree, ArrayBuilder`1<DirectiveTriviaSyntax> directiveList);
    private static WarningStateMapEntry[] CreateWarningStateEntries(ImmutableArray`1<DirectiveTriviaSyntax> directiveList);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.WhereClauseSyntax : QueryClauseSyntax {
    internal ExpressionSyntax _condition;
    public SyntaxToken WhereKeyword { get; }
    public ExpressionSyntax Condition { get; }
    internal WhereClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal WhereClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax whereKeyword, ExpressionSyntax condition);
    public SyntaxToken get_WhereKeyword();
    public WhereClauseSyntax WithWhereKeyword(SyntaxToken whereKeyword);
    public ExpressionSyntax get_Condition();
    public WhereClauseSyntax WithCondition(ExpressionSyntax condition);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public WhereClauseSyntax Update(SyntaxToken whereKeyword, ExpressionSyntax condition);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileBlockSyntax : ExecutableStatementSyntax {
    internal WhileStatementSyntax _whileStatement;
    internal SyntaxNode _statements;
    internal EndBlockStatementSyntax _endWhileStatement;
    public WhileStatementSyntax WhileStatement { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    public EndBlockStatementSyntax EndWhileStatement { get; }
    internal WhileBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal WhileBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, WhileStatementSyntax whileStatement, SyntaxNode statements, EndBlockStatementSyntax endWhileStatement);
    public WhileStatementSyntax get_WhileStatement();
    public WhileBlockSyntax WithWhileStatement(WhileStatementSyntax whileStatement);
    public SyntaxList`1<StatementSyntax> get_Statements();
    public WhileBlockSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public WhileBlockSyntax AddStatements(StatementSyntax[] items);
    public EndBlockStatementSyntax get_EndWhileStatement();
    public WhileBlockSyntax WithEndWhileStatement(EndBlockStatementSyntax endWhileStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public WhileBlockSyntax Update(WhileStatementSyntax whileStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endWhileStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileOrUntilClauseSyntax : VisualBasicSyntaxNode {
    internal ExpressionSyntax _condition;
    public SyntaxToken WhileOrUntilKeyword { get; }
    public ExpressionSyntax Condition { get; }
    internal WhileOrUntilClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal WhileOrUntilClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax whileOrUntilKeyword, ExpressionSyntax condition);
    public SyntaxToken get_WhileOrUntilKeyword();
    public WhileOrUntilClauseSyntax WithWhileOrUntilKeyword(SyntaxToken whileOrUntilKeyword);
    public ExpressionSyntax get_Condition();
    public WhileOrUntilClauseSyntax WithCondition(ExpressionSyntax condition);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public WhileOrUntilClauseSyntax Update(SyntaxKind kind, SyntaxToken whileOrUntilKeyword, ExpressionSyntax condition);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.WhileStatementSyntax : StatementSyntax {
    internal ExpressionSyntax _condition;
    public SyntaxToken WhileKeyword { get; }
    public ExpressionSyntax Condition { get; }
    internal WhileStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal WhileStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax whileKeyword, ExpressionSyntax condition);
    public SyntaxToken get_WhileKeyword();
    public WhileStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword);
    public ExpressionSyntax get_Condition();
    public WhileStatementSyntax WithCondition(ExpressionSyntax condition);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public WhileStatementSyntax Update(SyntaxToken whileKeyword, ExpressionSyntax condition);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.WithBlockSyntax : ExecutableStatementSyntax {
    internal WithStatementSyntax _withStatement;
    internal SyntaxNode _statements;
    internal EndBlockStatementSyntax _endWithStatement;
    public WithStatementSyntax WithStatement { get; }
    public SyntaxList`1<StatementSyntax> Statements { get; }
    public EndBlockStatementSyntax EndWithStatement { get; }
    internal WithBlockSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal WithBlockSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, WithStatementSyntax withStatement, SyntaxNode statements, EndBlockStatementSyntax endWithStatement);
    public WithStatementSyntax get_WithStatement();
    public WithBlockSyntax WithWithStatement(WithStatementSyntax withStatement);
    public SyntaxList`1<StatementSyntax> get_Statements();
    public WithBlockSyntax WithStatements(SyntaxList`1<StatementSyntax> statements);
    public WithBlockSyntax AddStatements(StatementSyntax[] items);
    public EndBlockStatementSyntax get_EndWithStatement();
    public WithBlockSyntax WithEndWithStatement(EndBlockStatementSyntax endWithStatement);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public WithBlockSyntax Update(WithStatementSyntax withStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endWithStatement);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsEventContainerSyntax : EventContainerSyntax {
    public SyntaxToken Identifier { get; }
    internal WithEventsEventContainerSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal WithEventsEventContainerSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, IdentifierTokenSyntax identifier);
    public SyntaxToken get_Identifier();
    public WithEventsEventContainerSyntax WithIdentifier(SyntaxToken identifier);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public WithEventsEventContainerSyntax Update(SyntaxToken identifier);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.WithEventsPropertyEventContainerSyntax : EventContainerSyntax {
    internal WithEventsEventContainerSyntax _withEventsContainer;
    internal IdentifierNameSyntax _property;
    public WithEventsEventContainerSyntax WithEventsContainer { get; }
    public SyntaxToken DotToken { get; }
    public IdentifierNameSyntax Property { get; }
    internal WithEventsPropertyEventContainerSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal WithEventsPropertyEventContainerSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, WithEventsEventContainerSyntax withEventsContainer, PunctuationSyntax dotToken, IdentifierNameSyntax property);
    public WithEventsEventContainerSyntax get_WithEventsContainer();
    public WithEventsPropertyEventContainerSyntax WithWithEventsContainer(WithEventsEventContainerSyntax withEventsContainer);
    public SyntaxToken get_DotToken();
    public WithEventsPropertyEventContainerSyntax WithDotToken(SyntaxToken dotToken);
    public IdentifierNameSyntax get_Property();
    public WithEventsPropertyEventContainerSyntax WithProperty(IdentifierNameSyntax property);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public WithEventsPropertyEventContainerSyntax Update(WithEventsEventContainerSyntax withEventsContainer, SyntaxToken dotToken, IdentifierNameSyntax property);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.WithStatementSyntax : StatementSyntax {
    internal ExpressionSyntax _expression;
    public SyntaxToken WithKeyword { get; }
    public ExpressionSyntax Expression { get; }
    internal WithStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal WithStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax withKeyword, ExpressionSyntax expression);
    public SyntaxToken get_WithKeyword();
    public WithStatementSyntax WithWithKeyword(SyntaxToken withKeyword);
    public ExpressionSyntax get_Expression();
    public WithStatementSyntax WithExpression(ExpressionSyntax expression);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public WithStatementSyntax Update(SyntaxToken withKeyword, ExpressionSyntax expression);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlAttributeSyntax : BaseXmlAttributeSyntax {
    internal XmlNodeSyntax _name;
    internal XmlNodeSyntax _value;
    public XmlNodeSyntax Name { get; }
    public SyntaxToken EqualsToken { get; }
    public XmlNodeSyntax Value { get; }
    internal XmlAttributeSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlAttributeSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, XmlNodeSyntax name, PunctuationSyntax equalsToken, XmlNodeSyntax value);
    public XmlNodeSyntax get_Name();
    public XmlAttributeSyntax WithName(XmlNodeSyntax name);
    public SyntaxToken get_EqualsToken();
    public XmlAttributeSyntax WithEqualsToken(SyntaxToken equalsToken);
    public XmlNodeSyntax get_Value();
    public XmlAttributeSyntax WithValue(XmlNodeSyntax value);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlAttributeSyntax Update(XmlNodeSyntax name, SyntaxToken equalsToken, XmlNodeSyntax value);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlBracketedNameSyntax : XmlNodeSyntax {
    internal XmlNameSyntax _name;
    public SyntaxToken LessThanToken { get; }
    public XmlNameSyntax Name { get; }
    public SyntaxToken GreaterThanToken { get; }
    internal XmlBracketedNameSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlBracketedNameSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanToken, XmlNameSyntax name, PunctuationSyntax greaterThanToken);
    public SyntaxToken get_LessThanToken();
    public XmlBracketedNameSyntax WithLessThanToken(SyntaxToken lessThanToken);
    public XmlNameSyntax get_Name();
    public XmlBracketedNameSyntax WithName(XmlNameSyntax name);
    public SyntaxToken get_GreaterThanToken();
    public XmlBracketedNameSyntax WithGreaterThanToken(SyntaxToken greaterThanToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlBracketedNameSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxToken greaterThanToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCDataSectionSyntax : XmlNodeSyntax {
    public SyntaxToken BeginCDataToken { get; }
    public SyntaxTokenList TextTokens { get; }
    public SyntaxToken EndCDataToken { get; }
    internal XmlCDataSectionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlCDataSectionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax beginCDataToken, GreenNode textTokens, PunctuationSyntax endCDataToken);
    public SyntaxToken get_BeginCDataToken();
    public XmlCDataSectionSyntax WithBeginCDataToken(SyntaxToken beginCDataToken);
    public SyntaxTokenList get_TextTokens();
    public XmlCDataSectionSyntax WithTextTokens(SyntaxTokenList textTokens);
    public XmlCDataSectionSyntax AddTextTokens(SyntaxToken[] items);
    public SyntaxToken get_EndCDataToken();
    public XmlCDataSectionSyntax WithEndCDataToken(SyntaxToken endCDataToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlCDataSectionSyntax Update(SyntaxToken beginCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCommentSyntax : XmlNodeSyntax {
    public SyntaxToken LessThanExclamationMinusMinusToken { get; }
    public SyntaxTokenList TextTokens { get; }
    public SyntaxToken MinusMinusGreaterThanToken { get; }
    internal XmlCommentSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlCommentSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanExclamationMinusMinusToken, GreenNode textTokens, PunctuationSyntax minusMinusGreaterThanToken);
    public SyntaxToken get_LessThanExclamationMinusMinusToken();
    public XmlCommentSyntax WithLessThanExclamationMinusMinusToken(SyntaxToken lessThanExclamationMinusMinusToken);
    public SyntaxTokenList get_TextTokens();
    public XmlCommentSyntax WithTextTokens(SyntaxTokenList textTokens);
    public XmlCommentSyntax AddTextTokens(SyntaxToken[] items);
    public SyntaxToken get_MinusMinusGreaterThanToken();
    public XmlCommentSyntax WithMinusMinusGreaterThanToken(SyntaxToken minusMinusGreaterThanToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlCommentSyntax Update(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlCrefAttributeSyntax : BaseXmlAttributeSyntax {
    internal XmlNameSyntax _name;
    internal CrefReferenceSyntax _reference;
    public XmlNameSyntax Name { get; }
    public SyntaxToken EqualsToken { get; }
    public SyntaxToken StartQuoteToken { get; }
    public CrefReferenceSyntax Reference { get; }
    public SyntaxToken EndQuoteToken { get; }
    internal XmlCrefAttributeSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlCrefAttributeSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, XmlNameSyntax name, PunctuationSyntax equalsToken, PunctuationSyntax startQuoteToken, CrefReferenceSyntax reference, PunctuationSyntax endQuoteToken);
    public XmlNameSyntax get_Name();
    public XmlCrefAttributeSyntax WithName(XmlNameSyntax name);
    public SyntaxToken get_EqualsToken();
    public XmlCrefAttributeSyntax WithEqualsToken(SyntaxToken equalsToken);
    public SyntaxToken get_StartQuoteToken();
    public XmlCrefAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken);
    public CrefReferenceSyntax get_Reference();
    public XmlCrefAttributeSyntax WithReference(CrefReferenceSyntax reference);
    public SyntaxToken get_EndQuoteToken();
    public XmlCrefAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlCrefAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefReferenceSyntax reference, SyntaxToken endQuoteToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationOptionSyntax : VisualBasicSyntaxNode {
    internal XmlStringSyntax _value;
    public SyntaxToken Name { get; }
    public SyntaxToken Equals { get; }
    public XmlStringSyntax Value { get; }
    internal XmlDeclarationOptionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlDeclarationOptionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, XmlNameTokenSyntax name, PunctuationSyntax equals, XmlStringSyntax value);
    public SyntaxToken get_Name();
    public XmlDeclarationOptionSyntax WithName(SyntaxToken name);
    public SyntaxToken get_Equals();
    public XmlDeclarationOptionSyntax WithEquals(SyntaxToken equals);
    public XmlStringSyntax get_Value();
    public XmlDeclarationOptionSyntax WithValue(XmlStringSyntax value);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlDeclarationOptionSyntax Update(SyntaxToken name, SyntaxToken equals, XmlStringSyntax value);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDeclarationSyntax : VisualBasicSyntaxNode {
    internal XmlDeclarationOptionSyntax _version;
    internal XmlDeclarationOptionSyntax _encoding;
    internal XmlDeclarationOptionSyntax _standalone;
    public SyntaxToken LessThanQuestionToken { get; }
    public SyntaxToken XmlKeyword { get; }
    public XmlDeclarationOptionSyntax Version { get; }
    public XmlDeclarationOptionSyntax Encoding { get; }
    public XmlDeclarationOptionSyntax Standalone { get; }
    public SyntaxToken QuestionGreaterThanToken { get; }
    internal XmlDeclarationSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanQuestionToken, KeywordSyntax xmlKeyword, XmlDeclarationOptionSyntax version, XmlDeclarationOptionSyntax encoding, XmlDeclarationOptionSyntax standalone, PunctuationSyntax questionGreaterThanToken);
    public SyntaxToken get_LessThanQuestionToken();
    public XmlDeclarationSyntax WithLessThanQuestionToken(SyntaxToken lessThanQuestionToken);
    public SyntaxToken get_XmlKeyword();
    public XmlDeclarationSyntax WithXmlKeyword(SyntaxToken xmlKeyword);
    public XmlDeclarationOptionSyntax get_Version();
    public XmlDeclarationSyntax WithVersion(XmlDeclarationOptionSyntax version);
    public XmlDeclarationOptionSyntax get_Encoding();
    public XmlDeclarationSyntax WithEncoding(XmlDeclarationOptionSyntax encoding);
    public XmlDeclarationOptionSyntax get_Standalone();
    public XmlDeclarationSyntax WithStandalone(XmlDeclarationOptionSyntax standalone);
    public SyntaxToken get_QuestionGreaterThanToken();
    public XmlDeclarationSyntax WithQuestionGreaterThanToken(SyntaxToken questionGreaterThanToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlDeclarationSyntax Update(SyntaxToken lessThanQuestionToken, SyntaxToken xmlKeyword, XmlDeclarationOptionSyntax version, XmlDeclarationOptionSyntax encoding, XmlDeclarationOptionSyntax standalone, SyntaxToken questionGreaterThanToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlDocumentSyntax : XmlNodeSyntax {
    internal XmlDeclarationSyntax _declaration;
    internal SyntaxNode _precedingMisc;
    internal XmlNodeSyntax _root;
    internal SyntaxNode _followingMisc;
    public XmlDeclarationSyntax Declaration { get; }
    public SyntaxList`1<XmlNodeSyntax> PrecedingMisc { get; }
    public XmlNodeSyntax Root { get; }
    public SyntaxList`1<XmlNodeSyntax> FollowingMisc { get; }
    internal XmlDocumentSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlDocumentSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, XmlDeclarationSyntax declaration, SyntaxNode precedingMisc, XmlNodeSyntax root, SyntaxNode followingMisc);
    public XmlDeclarationSyntax get_Declaration();
    public XmlDocumentSyntax WithDeclaration(XmlDeclarationSyntax declaration);
    public SyntaxList`1<XmlNodeSyntax> get_PrecedingMisc();
    public XmlDocumentSyntax WithPrecedingMisc(SyntaxList`1<XmlNodeSyntax> precedingMisc);
    public XmlDocumentSyntax AddPrecedingMisc(XmlNodeSyntax[] items);
    public XmlNodeSyntax get_Root();
    public XmlDocumentSyntax WithRoot(XmlNodeSyntax root);
    public SyntaxList`1<XmlNodeSyntax> get_FollowingMisc();
    public XmlDocumentSyntax WithFollowingMisc(SyntaxList`1<XmlNodeSyntax> followingMisc);
    public XmlDocumentSyntax AddFollowingMisc(XmlNodeSyntax[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlDocumentSyntax Update(XmlDeclarationSyntax declaration, SyntaxList`1<XmlNodeSyntax> precedingMisc, XmlNodeSyntax root, SyntaxList`1<XmlNodeSyntax> followingMisc);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementEndTagSyntax : XmlNodeSyntax {
    internal XmlNameSyntax _name;
    public SyntaxToken LessThanSlashToken { get; }
    public XmlNameSyntax Name { get; }
    public SyntaxToken GreaterThanToken { get; }
    internal XmlElementEndTagSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlElementEndTagSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanSlashToken, XmlNameSyntax name, PunctuationSyntax greaterThanToken);
    public SyntaxToken get_LessThanSlashToken();
    public XmlElementEndTagSyntax WithLessThanSlashToken(SyntaxToken lessThanSlashToken);
    public XmlNameSyntax get_Name();
    public XmlElementEndTagSyntax WithName(XmlNameSyntax name);
    public SyntaxToken get_GreaterThanToken();
    public XmlElementEndTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlElementEndTagSyntax Update(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementStartTagSyntax : XmlNodeSyntax {
    internal XmlNodeSyntax _name;
    internal SyntaxNode _attributes;
    public SyntaxToken LessThanToken { get; }
    public XmlNodeSyntax Name { get; }
    public SyntaxList`1<XmlNodeSyntax> Attributes { get; }
    public SyntaxToken GreaterThanToken { get; }
    internal XmlElementStartTagSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlElementStartTagSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanToken, XmlNodeSyntax name, SyntaxNode attributes, PunctuationSyntax greaterThanToken);
    public SyntaxToken get_LessThanToken();
    public XmlElementStartTagSyntax WithLessThanToken(SyntaxToken lessThanToken);
    public XmlNodeSyntax get_Name();
    public XmlElementStartTagSyntax WithName(XmlNodeSyntax name);
    public SyntaxList`1<XmlNodeSyntax> get_Attributes();
    public XmlElementStartTagSyntax WithAttributes(SyntaxList`1<XmlNodeSyntax> attributes);
    public XmlElementStartTagSyntax AddAttributes(XmlNodeSyntax[] items);
    public SyntaxToken get_GreaterThanToken();
    public XmlElementStartTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlElementStartTagSyntax Update(SyntaxToken lessThanToken, XmlNodeSyntax name, SyntaxList`1<XmlNodeSyntax> attributes, SyntaxToken greaterThanToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlElementSyntax : XmlNodeSyntax {
    internal XmlElementStartTagSyntax _startTag;
    internal SyntaxNode _content;
    internal XmlElementEndTagSyntax _endTag;
    public XmlElementStartTagSyntax StartTag { get; }
    public SyntaxList`1<XmlNodeSyntax> Content { get; }
    public XmlElementEndTagSyntax EndTag { get; }
    internal XmlElementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlElementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, XmlElementStartTagSyntax startTag, SyntaxNode content, XmlElementEndTagSyntax endTag);
    public XmlElementStartTagSyntax get_StartTag();
    public XmlElementSyntax WithStartTag(XmlElementStartTagSyntax startTag);
    public SyntaxList`1<XmlNodeSyntax> get_Content();
    public XmlElementSyntax WithContent(SyntaxList`1<XmlNodeSyntax> content);
    public XmlElementSyntax AddContent(XmlNodeSyntax[] items);
    public XmlElementEndTagSyntax get_EndTag();
    public XmlElementSyntax WithEndTag(XmlElementEndTagSyntax endTag);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlElementSyntax Update(XmlElementStartTagSyntax startTag, SyntaxList`1<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmbeddedExpressionSyntax : XmlNodeSyntax {
    internal ExpressionSyntax _expression;
    public SyntaxToken LessThanPercentEqualsToken { get; }
    public ExpressionSyntax Expression { get; }
    public SyntaxToken PercentGreaterThanToken { get; }
    internal XmlEmbeddedExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlEmbeddedExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanPercentEqualsToken, ExpressionSyntax expression, PunctuationSyntax percentGreaterThanToken);
    public SyntaxToken get_LessThanPercentEqualsToken();
    public XmlEmbeddedExpressionSyntax WithLessThanPercentEqualsToken(SyntaxToken lessThanPercentEqualsToken);
    public ExpressionSyntax get_Expression();
    public XmlEmbeddedExpressionSyntax WithExpression(ExpressionSyntax expression);
    public SyntaxToken get_PercentGreaterThanToken();
    public XmlEmbeddedExpressionSyntax WithPercentGreaterThanToken(SyntaxToken percentGreaterThanToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlEmbeddedExpressionSyntax Update(SyntaxToken lessThanPercentEqualsToken, ExpressionSyntax expression, SyntaxToken percentGreaterThanToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlEmptyElementSyntax : XmlNodeSyntax {
    internal XmlNodeSyntax _name;
    internal SyntaxNode _attributes;
    public SyntaxToken LessThanToken { get; }
    public XmlNodeSyntax Name { get; }
    public SyntaxList`1<XmlNodeSyntax> Attributes { get; }
    public SyntaxToken SlashGreaterThanToken { get; }
    internal XmlEmptyElementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlEmptyElementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanToken, XmlNodeSyntax name, SyntaxNode attributes, PunctuationSyntax slashGreaterThanToken);
    public SyntaxToken get_LessThanToken();
    public XmlEmptyElementSyntax WithLessThanToken(SyntaxToken lessThanToken);
    public XmlNodeSyntax get_Name();
    public XmlEmptyElementSyntax WithName(XmlNodeSyntax name);
    public SyntaxList`1<XmlNodeSyntax> get_Attributes();
    public XmlEmptyElementSyntax WithAttributes(SyntaxList`1<XmlNodeSyntax> attributes);
    public XmlEmptyElementSyntax AddAttributes(XmlNodeSyntax[] items);
    public SyntaxToken get_SlashGreaterThanToken();
    public XmlEmptyElementSyntax WithSlashGreaterThanToken(SyntaxToken slashGreaterThanToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlEmptyElementSyntax Update(SyntaxToken lessThanToken, XmlNodeSyntax name, SyntaxList`1<XmlNodeSyntax> attributes, SyntaxToken slashGreaterThanToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlMemberAccessExpressionSyntax : ExpressionSyntax {
    internal ExpressionSyntax _base;
    internal XmlNodeSyntax _name;
    public ExpressionSyntax Base { get; }
    public SyntaxToken Token1 { get; }
    public SyntaxToken Token2 { get; }
    public SyntaxToken Token3 { get; }
    public XmlNodeSyntax Name { get; }
    internal XmlMemberAccessExpressionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlMemberAccessExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, ExpressionSyntax base, PunctuationSyntax token1, PunctuationSyntax token2, PunctuationSyntax token3, XmlNodeSyntax name);
    public ExpressionSyntax get_Base();
    public XmlMemberAccessExpressionSyntax WithBase(ExpressionSyntax base);
    public SyntaxToken get_Token1();
    public XmlMemberAccessExpressionSyntax WithToken1(SyntaxToken token1);
    public SyntaxToken get_Token2();
    public XmlMemberAccessExpressionSyntax WithToken2(SyntaxToken token2);
    public SyntaxToken get_Token3();
    public XmlMemberAccessExpressionSyntax WithToken3(SyntaxToken token3);
    public XmlNodeSyntax get_Name();
    public XmlMemberAccessExpressionSyntax WithName(XmlNodeSyntax name);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlMemberAccessExpressionSyntax Update(SyntaxKind kind, ExpressionSyntax base, SyntaxToken token1, SyntaxToken token2, SyntaxToken token3, XmlNodeSyntax name);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameAttributeSyntax : BaseXmlAttributeSyntax {
    internal XmlNameSyntax _name;
    internal IdentifierNameSyntax _reference;
    public XmlNameSyntax Name { get; }
    public SyntaxToken EqualsToken { get; }
    public SyntaxToken StartQuoteToken { get; }
    public IdentifierNameSyntax Reference { get; }
    public SyntaxToken EndQuoteToken { get; }
    internal XmlNameAttributeSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlNameAttributeSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, XmlNameSyntax name, PunctuationSyntax equalsToken, PunctuationSyntax startQuoteToken, IdentifierNameSyntax reference, PunctuationSyntax endQuoteToken);
    public XmlNameSyntax get_Name();
    public XmlNameAttributeSyntax WithName(XmlNameSyntax name);
    public SyntaxToken get_EqualsToken();
    public XmlNameAttributeSyntax WithEqualsToken(SyntaxToken equalsToken);
    public SyntaxToken get_StartQuoteToken();
    public XmlNameAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken);
    public IdentifierNameSyntax get_Reference();
    public XmlNameAttributeSyntax WithReference(IdentifierNameSyntax reference);
    public SyntaxToken get_EndQuoteToken();
    public XmlNameAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlNameAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax reference, SyntaxToken endQuoteToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNamespaceImportsClauseSyntax : ImportsClauseSyntax {
    internal XmlAttributeSyntax _xmlNamespace;
    public SyntaxToken LessThanToken { get; }
    public XmlAttributeSyntax XmlNamespace { get; }
    public SyntaxToken GreaterThanToken { get; }
    internal XmlNamespaceImportsClauseSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlNamespaceImportsClauseSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanToken, XmlAttributeSyntax xmlNamespace, PunctuationSyntax greaterThanToken);
    public SyntaxToken get_LessThanToken();
    public XmlNamespaceImportsClauseSyntax WithLessThanToken(SyntaxToken lessThanToken);
    public XmlAttributeSyntax get_XmlNamespace();
    public XmlNamespaceImportsClauseSyntax WithXmlNamespace(XmlAttributeSyntax xmlNamespace);
    public SyntaxToken get_GreaterThanToken();
    public XmlNamespaceImportsClauseSyntax WithGreaterThanToken(SyntaxToken greaterThanToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlNamespaceImportsClauseSyntax Update(SyntaxToken lessThanToken, XmlAttributeSyntax xmlNamespace, SyntaxToken greaterThanToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNameSyntax : XmlNodeSyntax {
    internal XmlPrefixSyntax _prefix;
    public XmlPrefixSyntax Prefix { get; }
    public SyntaxToken LocalName { get; }
    internal XmlNameSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlNameSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, XmlPrefixSyntax prefix, XmlNameTokenSyntax localName);
    public XmlPrefixSyntax get_Prefix();
    public XmlNameSyntax WithPrefix(XmlPrefixSyntax prefix);
    public SyntaxToken get_LocalName();
    public XmlNameSyntax WithLocalName(SyntaxToken localName);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlNameSyntax Update(XmlPrefixSyntax prefix, SyntaxToken localName);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlNodeSyntax : ExpressionSyntax {
    internal XmlNodeSyntax(GreenNode green, SyntaxNode parent, int startLocation);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixNameSyntax : XmlNodeSyntax {
    public SyntaxToken Name { get; }
    internal XmlPrefixNameSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlPrefixNameSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, XmlNameTokenSyntax name);
    public SyntaxToken get_Name();
    public XmlPrefixNameSyntax WithName(SyntaxToken name);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlPrefixNameSyntax Update(SyntaxToken name);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlPrefixSyntax : VisualBasicSyntaxNode {
    public SyntaxToken Name { get; }
    public SyntaxToken ColonToken { get; }
    internal XmlPrefixSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlPrefixSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, XmlNameTokenSyntax name, PunctuationSyntax colonToken);
    public SyntaxToken get_Name();
    public XmlPrefixSyntax WithName(SyntaxToken name);
    public SyntaxToken get_ColonToken();
    public XmlPrefixSyntax WithColonToken(SyntaxToken colonToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlPrefixSyntax Update(SyntaxToken name, SyntaxToken colonToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlProcessingInstructionSyntax : XmlNodeSyntax {
    public SyntaxToken LessThanQuestionToken { get; }
    public SyntaxToken Name { get; }
    public SyntaxTokenList TextTokens { get; }
    public SyntaxToken QuestionGreaterThanToken { get; }
    internal XmlProcessingInstructionSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlProcessingInstructionSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax lessThanQuestionToken, XmlNameTokenSyntax name, GreenNode textTokens, PunctuationSyntax questionGreaterThanToken);
    public SyntaxToken get_LessThanQuestionToken();
    public XmlProcessingInstructionSyntax WithLessThanQuestionToken(SyntaxToken lessThanQuestionToken);
    public SyntaxToken get_Name();
    public XmlProcessingInstructionSyntax WithName(SyntaxToken name);
    public SyntaxTokenList get_TextTokens();
    public XmlProcessingInstructionSyntax WithTextTokens(SyntaxTokenList textTokens);
    public XmlProcessingInstructionSyntax AddTextTokens(SyntaxToken[] items);
    public SyntaxToken get_QuestionGreaterThanToken();
    public XmlProcessingInstructionSyntax WithQuestionGreaterThanToken(SyntaxToken questionGreaterThanToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlProcessingInstructionSyntax Update(SyntaxToken lessThanQuestionToken, SyntaxToken name, SyntaxTokenList textTokens, SyntaxToken questionGreaterThanToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlStringSyntax : XmlNodeSyntax {
    public SyntaxToken StartQuoteToken { get; }
    public SyntaxTokenList TextTokens { get; }
    public SyntaxToken EndQuoteToken { get; }
    internal XmlStringSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlStringSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, PunctuationSyntax startQuoteToken, GreenNode textTokens, PunctuationSyntax endQuoteToken);
    public SyntaxToken get_StartQuoteToken();
    public XmlStringSyntax WithStartQuoteToken(SyntaxToken startQuoteToken);
    public SyntaxTokenList get_TextTokens();
    public XmlStringSyntax WithTextTokens(SyntaxTokenList textTokens);
    public XmlStringSyntax AddTextTokens(SyntaxToken[] items);
    public SyntaxToken get_EndQuoteToken();
    public XmlStringSyntax WithEndQuoteToken(SyntaxToken endQuoteToken);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlStringSyntax Update(SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.XmlTextSyntax : XmlNodeSyntax {
    public SyntaxTokenList TextTokens { get; }
    internal XmlTextSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal XmlTextSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, GreenNode textTokens);
    public SyntaxTokenList get_TextTokens();
    public XmlTextSyntax WithTextTokens(SyntaxTokenList textTokens);
    public XmlTextSyntax AddTextTokens(SyntaxToken[] items);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public XmlTextSyntax Update(SyntaxTokenList textTokens);
}
public class Microsoft.CodeAnalysis.VisualBasic.Syntax.YieldStatementSyntax : ExecutableStatementSyntax {
    internal ExpressionSyntax _expression;
    public SyntaxToken YieldKeyword { get; }
    public ExpressionSyntax Expression { get; }
    internal YieldStatementSyntax(GreenNode green, SyntaxNode parent, int startLocation);
    internal YieldStatementSyntax(SyntaxKind kind, DiagnosticInfo[] errors, SyntaxAnnotation[] annotations, KeywordSyntax yieldKeyword, ExpressionSyntax expression);
    public SyntaxToken get_YieldKeyword();
    public YieldStatementSyntax WithYieldKeyword(SyntaxToken yieldKeyword);
    public ExpressionSyntax get_Expression();
    public YieldStatementSyntax WithExpression(ExpressionSyntax expression);
    internal virtual SyntaxNode GetCachedSlot(int i);
    internal virtual SyntaxNode GetNodeSlot(int i);
    public virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public YieldStatementSyntax Update(SyntaxToken yieldKeyword, ExpressionSyntax expression);
}
[ExtensionAttribute]
[StandardModuleAttribute]
public class Microsoft.CodeAnalysis.VisualBasic.SyntaxExtensions : object {
    [ExtensionAttribute]
internal static bool ReportDocumentationCommentDiagnostics(SyntaxTree tree);
    [ExtensionAttribute]
public static SyntaxTriviaList ToSyntaxTriviaList(IEnumerable`1<SyntaxTrivia> sequence);
    [ExtensionAttribute]
public static TNode NormalizeWhitespace(TNode node, bool useDefaultCasing, string indentation, bool elasticTrivia);
    [ExtensionAttribute]
public static TNode NormalizeWhitespace(TNode node, bool useDefaultCasing, string indentation, string eol, bool elasticTrivia);
    [ExtensionAttribute]
public static SyntaxToken NormalizeWhitespace(SyntaxToken token, string indentation, bool elasticTrivia);
    [ExtensionAttribute]
public static SyntaxToken NormalizeWhitespace(SyntaxToken token, string indentation, string eol, bool elasticTrivia, bool useDefaultCasing);
    [ExtensionAttribute]
public static SyntaxTriviaList NormalizeWhitespace(SyntaxTriviaList trivia, string indentation, string eol, bool elasticTrivia, bool useDefaultCasing);
    [ExtensionAttribute]
public static TypeSyntax Type(NewExpressionSyntax newExpressionSyntax);
    [ExtensionAttribute]
public static TypeSyntax Type(AsClauseSyntax asClauseSyntax);
    [ExtensionAttribute]
public static SyntaxList`1<AttributeListSyntax> Attributes(AsClauseSyntax asClauseSyntax);
    [ExtensionAttribute]
public static SimpleNameSyntax WithIdentifier(SimpleNameSyntax simpleName, SyntaxToken identifier);
}
public class Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory : object {
    [CompilerGeneratedAttribute]
private static SyntaxTrivia _CarriageReturnLineFeed;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia _LineFeed;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia _CarriageReturn;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia _Space;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia _Tab;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia _ElasticCarriageReturnLineFeed;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia _ElasticLineFeed;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia _ElasticCarriageReturn;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia _ElasticSpace;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia _ElasticTab;
    [CompilerGeneratedAttribute]
private static SyntaxTrivia _ElasticMarker;
    private static SyntaxTriviaList s_elasticMarkerList;
    public static SyntaxTrivia CarriageReturnLineFeed { get; }
    public static SyntaxTrivia LineFeed { get; }
    public static SyntaxTrivia CarriageReturn { get; }
    public static SyntaxTrivia Space { get; }
    public static SyntaxTrivia Tab { get; }
    public static SyntaxTrivia ElasticCarriageReturnLineFeed { get; }
    public static SyntaxTrivia ElasticLineFeed { get; }
    public static SyntaxTrivia ElasticCarriageReturn { get; }
    public static SyntaxTrivia ElasticSpace { get; }
    public static SyntaxTrivia ElasticTab { get; }
    public static SyntaxTrivia ElasticMarker { get; }
    private static SyntaxFactory();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_CarriageReturnLineFeed();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_LineFeed();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_CarriageReturn();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_Space();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_Tab();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_ElasticCarriageReturnLineFeed();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_ElasticLineFeed();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_ElasticCarriageReturn();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_ElasticSpace();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_ElasticTab();
    [CompilerGeneratedAttribute]
public static SyntaxTrivia get_ElasticMarker();
    public static SyntaxTrivia EndOfLine(string text);
    public static SyntaxTrivia ElasticEndOfLine(string text);
    [ObsoleteAttribute("Use SyntaxFactory.EndOfLine or SyntaxFactory.ElasticEndOfLine")]
[EditorBrowsableAttribute("1")]
public static SyntaxTrivia EndOfLine(string text, bool elastic);
    public static SyntaxTrivia Whitespace(string text);
    public static SyntaxTrivia ElasticWhitespace(string text);
    [ObsoleteAttribute("Use SyntaxFactory.Whitespace or SyntaxFactory.ElasticWhitespace")]
[EditorBrowsableAttribute("1")]
public static SyntaxTrivia Whitespace(string text, bool elastic);
    public static ExpressionSyntax GetStandaloneExpression(ExpressionSyntax node);
    internal static void VerifySyntaxKindOfToken(SyntaxKind kind);
    public static SyntaxToken Token(SyntaxKind kind, string text);
    internal static SyntaxToken Token(SyntaxKind kind, SyntaxTrivia trailing, string text);
    public static SyntaxToken Token(SyntaxKind kind, SyntaxTriviaList trailing, string text);
    public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, string text);
    internal static SyntaxToken Token(SyntaxTrivia leading, SyntaxKind kind, SyntaxTrivia trailing, string text);
    public static SyntaxToken Token(SyntaxTriviaList leading, SyntaxKind kind, SyntaxTriviaList trailing, string text);
    public static SyntaxToken Literal(int value);
    public static SyntaxToken Literal(string text, int value);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, int value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(UInt32 value);
    public static SyntaxToken Literal(string text, UInt32 value);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, UInt32 value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(long value);
    public static SyntaxToken Literal(string text, long value);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, long value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(ulong value);
    public static SyntaxToken Literal(string text, ulong value);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, ulong value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(float value);
    public static SyntaxToken Literal(string text, float value);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, float value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(double value);
    public static SyntaxToken Literal(string text, double value);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, double value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(decimal value);
    public static SyntaxToken Literal(string text, decimal value);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, decimal value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(string value);
    public static SyntaxToken Literal(string text, string value);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, string value, SyntaxTriviaList trailing);
    public static SyntaxToken Literal(char value);
    public static SyntaxToken Literal(string text, char value);
    public static SyntaxToken Literal(SyntaxTriviaList leading, string text, char value, SyntaxTriviaList trailing);
    public static TypeBlockSyntax TypeBlock(SyntaxKind blockKind, TypeStatementSyntax begin, SyntaxList`1<InheritsStatementSyntax> inherits, SyntaxList`1<ImplementsStatementSyntax> implements, SyntaxList`1<StatementSyntax> members, EndBlockStatementSyntax end);
    public static TypeStatementSyntax TypeStatement(SyntaxKind statementKind, SyntaxList`1<AttributeListSyntax> attributes, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList);
    public static DocumentationCommentTriviaSyntax DocumentationComment(XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlSummaryElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlSummaryElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlEmptyElementSyntax XmlSeeElement(CrefReferenceSyntax cref);
    public static XmlEmptyElementSyntax XmlSeeAlsoElement(CrefReferenceSyntax cref);
    public static XmlElementSyntax XmlSeeAlsoElement(Uri linkAddress, SyntaxList`1<XmlNodeSyntax> linkText);
    public static XmlEmptyElementSyntax XmlThreadSafetyElement();
    public static XmlEmptyElementSyntax XmlThreadSafetyElement(bool isStatic, bool isInstance);
    public static XmlNameAttributeSyntax XmlNameAttribute(string parameterName);
    public static XmlEmptyElementSyntax XmlPreliminaryElement();
    public static XmlCrefAttributeSyntax XmlCrefAttribute(CrefReferenceSyntax cref);
    public static XmlCrefAttributeSyntax XmlCrefAttribute(CrefReferenceSyntax cref, SyntaxKind quoteKind);
    public static XmlElementSyntax XmlRemarksElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlRemarksElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlReturnsElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlReturnsElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlValueElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlValueElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlExceptionElement(CrefReferenceSyntax cref, XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlExceptionElement(CrefReferenceSyntax cref, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlPermissionElement(CrefReferenceSyntax cref, XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlPermissionElement(CrefReferenceSyntax cref, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlExampleElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlExampleElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlParaElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlParaElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlParamElement(string parameterName, XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlParamElement(string parameterName, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlEmptyElementSyntax XmlParamRefElement(string parameterName);
    public static XmlEmptyElementSyntax XmlNullKeywordElement();
    private static XmlEmptyElementSyntax XmlKeywordElement(string keyword);
    public static XmlElementSyntax XmlPlaceholderElement(XmlNodeSyntax[] content);
    public static XmlElementSyntax XmlPlaceholderElement(SyntaxList`1<XmlNodeSyntax> content);
    public static XmlEmptyElementSyntax XmlEmptyElement(string localName);
    public static XmlElementSyntax XmlElement(string localName, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlElement(XmlNameSyntax name, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlMultiLineElement(string localName, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlElementSyntax XmlMultiLineElement(XmlNameSyntax name, SyntaxList`1<XmlNodeSyntax> content);
    public static XmlTextSyntax XmlNewLine(string text);
    public static SyntaxToken XmlTextNewLine(string text);
    public static SyntaxToken XmlTextNewLine(string text, string value, SyntaxTriviaList leading, SyntaxTriviaList trailing);
    public static SyntaxToken XmlTextNewLine(string text, bool continueXmlDocumentationComment);
    public static XmlTextSyntax XmlText(string value);
    public static XmlTextSyntax XmlText(SyntaxToken[] textTokens);
    public static SyntaxToken XmlTextLiteral(string value);
    public static SyntaxToken XmlTextLiteral(string text, string value);
    private static SyntaxToken XmlReplaceBracketTokens(SyntaxToken originalToken, SyntaxToken rewrittenToken);
    public static bool AreEquivalent(SyntaxTree oldTree, SyntaxTree newTree, bool topLevel);
    public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, bool topLevel);
    public static bool AreEquivalent(SyntaxNode oldNode, SyntaxNode newNode, Func`2<SyntaxKind, bool> ignoreChildNode);
    public static bool AreEquivalent(SyntaxToken oldToken, SyntaxToken newToken);
    public static bool AreEquivalent(SyntaxTokenList oldList, SyntaxTokenList newList);
    public static bool AreEquivalent(SyntaxList`1<TNode> oldList, SyntaxList`1<TNode> newList, Func`2<SyntaxKind, bool> ignoreChildNode);
    public static bool AreEquivalent(SeparatedSyntaxList`1<TNode> oldList, SeparatedSyntaxList`1<TNode> newList, Func`2<SyntaxKind, bool> ignoreChildNode);
    private static bool IsPartOfLinqQueryNotFollowedByNewLine(SyntaxToken token, SyntaxNode statementNode, SyntaxToken endOfFileToken);
    internal static bool IsCompleteSubmission(SyntaxTree tree);
    public static SyntaxTree SyntaxTree(SyntaxNode root, ParseOptions options, string path, Encoding encoding);
    public static SyntaxTree ParseSyntaxTree(string text, ParseOptions options, string path, Encoding encoding, CancellationToken cancellationToken);
    public static SyntaxTree ParseSyntaxTree(SourceText text, ParseOptions options, string path, CancellationToken cancellationToken);
    public static SyntaxTriviaList ParseLeadingTrivia(string text, int offset);
    public static SyntaxTriviaList ParseTrailingTrivia(string text, int offset);
    public static SyntaxToken ParseToken(string text, int offset, bool startStatement);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.SyntaxFactory/VB$StateMachine_141_ParseTokens")]
public static IEnumerable`1<SyntaxToken> ParseTokens(string text, int offset, int initialTokenPosition, VisualBasicParseOptions options);
    public static NameSyntax ParseName(string text, int offset, bool consumeFullText);
    public static TypeSyntax ParseTypeName(string text, int offset, bool consumeFullText);
    public static ExpressionSyntax ParseExpression(string text, int offset, bool consumeFullText);
    public static StatementSyntax ParseExecutableStatement(string text, int offset, bool consumeFullText);
    public static CompilationUnitSyntax ParseCompilationUnit(string text, int offset, VisualBasicParseOptions options);
    public static ParameterListSyntax ParseParameterList(string text, int offset, bool consumeFullText);
    public static ArgumentListSyntax ParseArgumentList(string text, int offset, bool consumeFullText);
    internal static SourceText MakeSourceText(string text, int offset);
    internal static BaseXmlAttributeSyntax ParseDocCommentAttributeAsStandAloneEntity(string text, string parentElementName);
    public static SyntaxToken IntegerLiteralToken(string text, LiteralBase base, TypeCharacter typeSuffix, ulong value);
    public static SyntaxToken IntegerLiteralToken(SyntaxTriviaList leadingTrivia, string text, LiteralBase base, TypeCharacter typeSuffix, ulong value, SyntaxTriviaList trailingTrivia);
    public static SyntaxToken FloatingLiteralToken(string text, TypeCharacter typeSuffix, double value);
    public static SyntaxToken FloatingLiteralToken(SyntaxTriviaList leadingTrivia, string text, TypeCharacter typeSuffix, double value, SyntaxTriviaList trailingTrivia);
    public static SyntaxToken Identifier(string text, bool isBracketed, string identifierText, TypeCharacter typeCharacter);
    internal static SyntaxToken Identifier(SyntaxTrivia leadingTrivia, string text, bool isBracketed, string identifierText, TypeCharacter typeCharacter, SyntaxTrivia trailingTrivia);
    public static SyntaxToken Identifier(SyntaxTriviaList leadingTrivia, string text, bool isBracketed, string identifierText, TypeCharacter typeCharacter, SyntaxTriviaList trailingTrivia);
    public static SyntaxToken Identifier(string text);
    internal static SyntaxToken Identifier(SyntaxTrivia leadingTrivia, string text, SyntaxTrivia trailingTrivia);
    public static SyntaxToken Identifier(SyntaxTriviaList leadingTrivia, string text, SyntaxTriviaList trailingTrivia);
    public static SyntaxToken BracketedIdentifier(string text);
    public static SyntaxToken BracketedIdentifier(SyntaxTriviaList leadingTrivia, string text, SyntaxTriviaList trailingTrivia);
    internal static SyntaxToken MissingIdentifier();
    internal static SyntaxToken MissingIdentifier(SyntaxKind kind);
    internal static SyntaxToken MissingKeyword(SyntaxKind kind);
    internal static SyntaxToken MissingPunctuation(SyntaxKind kind);
    internal static SyntaxToken MissingStringLiteral();
    internal static SyntaxToken MissingCharacterLiteralToken();
    internal static SyntaxToken MissingIntegerLiteralToken();
    internal static SyntaxToken MissingToken(SyntaxKind kind);
    public static SyntaxToken BadToken(string text);
    public static SyntaxToken BadToken(SyntaxTriviaList leadingTrivia, string text, SyntaxTriviaList trailingTrivia);
    public static SyntaxTrivia Trivia(StructuredTriviaSyntax node);
    public static SyntaxList`1<TNode> List();
    public static SyntaxList`1<TNode> SingletonList(TNode node);
    public static SyntaxList`1<TNode> List(IEnumerable`1<TNode> nodes);
    public static SyntaxTokenList TokenList();
    public static SyntaxTokenList TokenList(SyntaxToken token);
    public static SyntaxTokenList TokenList(SyntaxToken[] tokens);
    public static SyntaxTokenList TokenList(IEnumerable`1<SyntaxToken> tokens);
    public static SyntaxTriviaList TriviaList();
    public static SyntaxTriviaList TriviaList(SyntaxTrivia trivia);
    public static SyntaxTriviaList TriviaList(SyntaxTrivia[] trivias);
    public static SyntaxTriviaList TriviaList(IEnumerable`1<SyntaxTrivia> trivias);
    public static SeparatedSyntaxList`1<TNode> SeparatedList();
    public static SeparatedSyntaxList`1<TNode> SingletonSeparatedList(TNode node);
    public static SeparatedSyntaxList`1<TNode> SeparatedList(IEnumerable`1<TNode> nodes);
    public static SeparatedSyntaxList`1<TNode> SeparatedList(IEnumerable`1<TNode> nodes, IEnumerable`1<SyntaxToken> separators);
    public static SeparatedSyntaxList`1<TNode> SeparatedList(IEnumerable`1<SyntaxNodeOrToken> nodesAndTokens);
    public static SeparatedSyntaxList`1<TNode> SeparatedList(SyntaxNodeOrTokenList nodesAndTokens);
    private static bool NodesAreCorrectType(SyntaxNodeOrTokenList list);
    private static bool HasSeparatedNodeTokenPattern(SyntaxNodeOrTokenList list);
    public static SyntaxNodeOrTokenList NodeOrTokenList();
    public static SyntaxNodeOrTokenList NodeOrTokenList(IEnumerable`1<SyntaxNodeOrToken> nodesAndTokens);
    public static SyntaxNodeOrTokenList NodeOrTokenList(SyntaxNodeOrToken[] nodesAndTokens);
    public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression);
    public static EmptyStatementSyntax EmptyStatement(SyntaxToken empty);
    public static EmptyStatementSyntax EmptyStatement();
    public static EndBlockStatementSyntax EndIfStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndIfStatement();
    public static EndBlockStatementSyntax EndUsingStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndUsingStatement();
    public static EndBlockStatementSyntax EndWithStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndWithStatement();
    public static EndBlockStatementSyntax EndSelectStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndSelectStatement();
    public static EndBlockStatementSyntax EndStructureStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndStructureStatement();
    public static EndBlockStatementSyntax EndEnumStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndEnumStatement();
    public static EndBlockStatementSyntax EndInterfaceStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndInterfaceStatement();
    public static EndBlockStatementSyntax EndClassStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndClassStatement();
    public static EndBlockStatementSyntax EndModuleStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndModuleStatement();
    public static EndBlockStatementSyntax EndNamespaceStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndNamespaceStatement();
    public static EndBlockStatementSyntax EndSubStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndSubStatement();
    public static EndBlockStatementSyntax EndFunctionStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndFunctionStatement();
    public static EndBlockStatementSyntax EndGetStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndGetStatement();
    public static EndBlockStatementSyntax EndSetStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndSetStatement();
    public static EndBlockStatementSyntax EndPropertyStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndPropertyStatement();
    public static EndBlockStatementSyntax EndOperatorStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndOperatorStatement();
    public static EndBlockStatementSyntax EndEventStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndEventStatement();
    public static EndBlockStatementSyntax EndAddHandlerStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndAddHandlerStatement();
    public static EndBlockStatementSyntax EndRemoveHandlerStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndRemoveHandlerStatement();
    public static EndBlockStatementSyntax EndRaiseEventStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndRaiseEventStatement();
    public static EndBlockStatementSyntax EndWhileStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndWhileStatement();
    public static EndBlockStatementSyntax EndTryStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndTryStatement();
    public static EndBlockStatementSyntax EndSyncLockStatement(SyntaxToken endKeyword, SyntaxToken blockKeyword);
    public static EndBlockStatementSyntax EndSyncLockStatement();
    public static EndBlockStatementSyntax EndBlockStatement(SyntaxKind kind, SyntaxToken endKeyword, SyntaxToken blockKeyword);
    private static SyntaxKind GetEndBlockStatementBlockKeywordKind(SyntaxKind kind);
    public static EndBlockStatementSyntax EndBlockStatement(SyntaxKind kind, SyntaxToken blockKeyword);
    public static CompilationUnitSyntax CompilationUnit(SyntaxList`1<OptionStatementSyntax> options, SyntaxList`1<ImportsStatementSyntax> imports, SyntaxList`1<AttributesStatementSyntax> attributes, SyntaxList`1<StatementSyntax> members, SyntaxToken endOfFileToken);
    public static CompilationUnitSyntax CompilationUnit(SyntaxList`1<OptionStatementSyntax> options, SyntaxList`1<ImportsStatementSyntax> imports, SyntaxList`1<AttributesStatementSyntax> attributes, SyntaxList`1<StatementSyntax> members);
    public static CompilationUnitSyntax CompilationUnit();
    public static OptionStatementSyntax OptionStatement(SyntaxToken optionKeyword, SyntaxToken nameKeyword, SyntaxToken valueKeyword);
    public static OptionStatementSyntax OptionStatement(SyntaxToken nameKeyword, SyntaxToken valueKeyword);
    public static OptionStatementSyntax OptionStatement(SyntaxToken nameKeyword);
    public static ImportsStatementSyntax ImportsStatement(SyntaxToken importsKeyword, SeparatedSyntaxList`1<ImportsClauseSyntax> importsClauses);
    public static ImportsStatementSyntax ImportsStatement(SeparatedSyntaxList`1<ImportsClauseSyntax> importsClauses);
    public static ImportsStatementSyntax ImportsStatement();
    public static SimpleImportsClauseSyntax SimpleImportsClause(ImportAliasClauseSyntax alias, NameSyntax name);
    public static SimpleImportsClauseSyntax SimpleImportsClause(NameSyntax name);
    public static ImportAliasClauseSyntax ImportAliasClause(SyntaxToken identifier, SyntaxToken equalsToken);
    public static ImportAliasClauseSyntax ImportAliasClause(SyntaxToken identifier);
    public static ImportAliasClauseSyntax ImportAliasClause(string identifier);
    public static XmlNamespaceImportsClauseSyntax XmlNamespaceImportsClause(SyntaxToken lessThanToken, XmlAttributeSyntax xmlNamespace, SyntaxToken greaterThanToken);
    public static XmlNamespaceImportsClauseSyntax XmlNamespaceImportsClause(XmlAttributeSyntax xmlNamespace);
    public static NamespaceBlockSyntax NamespaceBlock(NamespaceStatementSyntax namespaceStatement, SyntaxList`1<StatementSyntax> members, EndBlockStatementSyntax endNamespaceStatement);
    public static NamespaceBlockSyntax NamespaceBlock(NamespaceStatementSyntax namespaceStatement, SyntaxList`1<StatementSyntax> members);
    public static NamespaceBlockSyntax NamespaceBlock(NamespaceStatementSyntax namespaceStatement);
    public static NamespaceStatementSyntax NamespaceStatement(SyntaxToken namespaceKeyword, NameSyntax name);
    public static NamespaceStatementSyntax NamespaceStatement(NameSyntax name);
    public static ModuleBlockSyntax ModuleBlock(ModuleStatementSyntax moduleStatement, SyntaxList`1<InheritsStatementSyntax> inherits, SyntaxList`1<ImplementsStatementSyntax> implements, SyntaxList`1<StatementSyntax> members, EndBlockStatementSyntax endModuleStatement);
    public static ModuleBlockSyntax ModuleBlock(ModuleStatementSyntax moduleStatement, SyntaxList`1<InheritsStatementSyntax> inherits, SyntaxList`1<ImplementsStatementSyntax> implements, SyntaxList`1<StatementSyntax> members);
    public static ModuleBlockSyntax ModuleBlock(ModuleStatementSyntax moduleStatement);
    public static StructureBlockSyntax StructureBlock(StructureStatementSyntax structureStatement, SyntaxList`1<InheritsStatementSyntax> inherits, SyntaxList`1<ImplementsStatementSyntax> implements, SyntaxList`1<StatementSyntax> members, EndBlockStatementSyntax endStructureStatement);
    public static StructureBlockSyntax StructureBlock(StructureStatementSyntax structureStatement, SyntaxList`1<InheritsStatementSyntax> inherits, SyntaxList`1<ImplementsStatementSyntax> implements, SyntaxList`1<StatementSyntax> members);
    public static StructureBlockSyntax StructureBlock(StructureStatementSyntax structureStatement);
    public static InterfaceBlockSyntax InterfaceBlock(InterfaceStatementSyntax interfaceStatement, SyntaxList`1<InheritsStatementSyntax> inherits, SyntaxList`1<ImplementsStatementSyntax> implements, SyntaxList`1<StatementSyntax> members, EndBlockStatementSyntax endInterfaceStatement);
    public static InterfaceBlockSyntax InterfaceBlock(InterfaceStatementSyntax interfaceStatement, SyntaxList`1<InheritsStatementSyntax> inherits, SyntaxList`1<ImplementsStatementSyntax> implements, SyntaxList`1<StatementSyntax> members);
    public static InterfaceBlockSyntax InterfaceBlock(InterfaceStatementSyntax interfaceStatement);
    public static ClassBlockSyntax ClassBlock(ClassStatementSyntax classStatement, SyntaxList`1<InheritsStatementSyntax> inherits, SyntaxList`1<ImplementsStatementSyntax> implements, SyntaxList`1<StatementSyntax> members, EndBlockStatementSyntax endClassStatement);
    public static ClassBlockSyntax ClassBlock(ClassStatementSyntax classStatement, SyntaxList`1<InheritsStatementSyntax> inherits, SyntaxList`1<ImplementsStatementSyntax> implements, SyntaxList`1<StatementSyntax> members);
    public static ClassBlockSyntax ClassBlock(ClassStatementSyntax classStatement);
    public static EnumBlockSyntax EnumBlock(EnumStatementSyntax enumStatement, SyntaxList`1<StatementSyntax> members, EndBlockStatementSyntax endEnumStatement);
    public static EnumBlockSyntax EnumBlock(EnumStatementSyntax enumStatement, SyntaxList`1<StatementSyntax> members);
    public static EnumBlockSyntax EnumBlock(EnumStatementSyntax enumStatement);
    public static InheritsStatementSyntax InheritsStatement(SyntaxToken inheritsKeyword, SeparatedSyntaxList`1<TypeSyntax> types);
    public static InheritsStatementSyntax InheritsStatement(SeparatedSyntaxList`1<TypeSyntax> types);
    public static InheritsStatementSyntax InheritsStatement(TypeSyntax[] types);
    public static ImplementsStatementSyntax ImplementsStatement(SyntaxToken implementsKeyword, SeparatedSyntaxList`1<TypeSyntax> types);
    public static ImplementsStatementSyntax ImplementsStatement(SeparatedSyntaxList`1<TypeSyntax> types);
    public static ImplementsStatementSyntax ImplementsStatement(TypeSyntax[] types);
    public static ModuleStatementSyntax ModuleStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken moduleKeyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList);
    public static ModuleStatementSyntax ModuleStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList);
    public static ModuleStatementSyntax ModuleStatement(SyntaxToken identifier);
    public static ModuleStatementSyntax ModuleStatement(string identifier);
    public static StructureStatementSyntax StructureStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken structureKeyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList);
    public static StructureStatementSyntax StructureStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList);
    public static StructureStatementSyntax StructureStatement(SyntaxToken identifier);
    public static StructureStatementSyntax StructureStatement(string identifier);
    public static InterfaceStatementSyntax InterfaceStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken interfaceKeyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList);
    public static InterfaceStatementSyntax InterfaceStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList);
    public static InterfaceStatementSyntax InterfaceStatement(SyntaxToken identifier);
    public static InterfaceStatementSyntax InterfaceStatement(string identifier);
    public static ClassStatementSyntax ClassStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken classKeyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList);
    public static ClassStatementSyntax ClassStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList);
    public static ClassStatementSyntax ClassStatement(SyntaxToken identifier);
    public static ClassStatementSyntax ClassStatement(string identifier);
    public static EnumStatementSyntax EnumStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, AsClauseSyntax underlyingType);
    public static EnumStatementSyntax EnumStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, AsClauseSyntax underlyingType);
    public static EnumStatementSyntax EnumStatement(SyntaxToken identifier);
    public static EnumStatementSyntax EnumStatement(string identifier);
    public static TypeParameterListSyntax TypeParameterList(SyntaxToken openParenToken, SyntaxToken ofKeyword, SeparatedSyntaxList`1<TypeParameterSyntax> parameters, SyntaxToken closeParenToken);
    public static TypeParameterListSyntax TypeParameterList(SeparatedSyntaxList`1<TypeParameterSyntax> parameters);
    public static TypeParameterListSyntax TypeParameterList(TypeParameterSyntax[] parameters);
    public static TypeParameterSyntax TypeParameter(SyntaxToken varianceKeyword, SyntaxToken identifier, TypeParameterConstraintClauseSyntax typeParameterConstraintClause);
    public static TypeParameterSyntax TypeParameter(SyntaxToken identifier);
    public static TypeParameterSyntax TypeParameter(string identifier);
    public static TypeParameterSingleConstraintClauseSyntax TypeParameterSingleConstraintClause(SyntaxToken asKeyword, ConstraintSyntax constraint);
    public static TypeParameterSingleConstraintClauseSyntax TypeParameterSingleConstraintClause(ConstraintSyntax constraint);
    public static TypeParameterMultipleConstraintClauseSyntax TypeParameterMultipleConstraintClause(SyntaxToken asKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList`1<ConstraintSyntax> constraints, SyntaxToken closeBraceToken);
    public static TypeParameterMultipleConstraintClauseSyntax TypeParameterMultipleConstraintClause(SeparatedSyntaxList`1<ConstraintSyntax> constraints);
    public static TypeParameterMultipleConstraintClauseSyntax TypeParameterMultipleConstraintClause(ConstraintSyntax[] constraints);
    public static SpecialConstraintSyntax NewConstraint(SyntaxToken constraintKeyword);
    public static SpecialConstraintSyntax ClassConstraint(SyntaxToken constraintKeyword);
    public static SpecialConstraintSyntax StructureConstraint(SyntaxToken constraintKeyword);
    public static SpecialConstraintSyntax SpecialConstraint(SyntaxKind kind, SyntaxToken constraintKeyword);
    public static TypeConstraintSyntax TypeConstraint(TypeSyntax type);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueSyntax initializer);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier);
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string identifier);
    public static MethodBlockSyntax SubBlock(MethodStatementSyntax subOrFunctionStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    public static MethodBlockSyntax SubBlock(MethodStatementSyntax subOrFunctionStatement, SyntaxList`1<StatementSyntax> statements);
    public static MethodBlockSyntax SubBlock(MethodStatementSyntax subOrFunctionStatement);
    public static MethodBlockSyntax FunctionBlock(MethodStatementSyntax subOrFunctionStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    public static MethodBlockSyntax FunctionBlock(MethodStatementSyntax subOrFunctionStatement, SyntaxList`1<StatementSyntax> statements);
    public static MethodBlockSyntax FunctionBlock(MethodStatementSyntax subOrFunctionStatement);
    public static MethodBlockSyntax MethodBlock(SyntaxKind kind, MethodStatementSyntax subOrFunctionStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    private static SyntaxKind GetMethodBlockSubOrFunctionStatementKind(SyntaxKind kind);
    private static SyntaxKind GetMethodBlockEndSubOrFunctionStatementKind(SyntaxKind kind);
    public static MethodBlockSyntax MethodBlock(SyntaxKind kind, MethodStatementSyntax subOrFunctionStatement, EndBlockStatementSyntax endSubOrFunctionStatement);
    public static ConstructorBlockSyntax ConstructorBlock(SubNewStatementSyntax subNewStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endSubStatement);
    public static ConstructorBlockSyntax ConstructorBlock(SubNewStatementSyntax subNewStatement, SyntaxList`1<StatementSyntax> statements);
    public static ConstructorBlockSyntax ConstructorBlock(SubNewStatementSyntax subNewStatement);
    public static OperatorBlockSyntax OperatorBlock(OperatorStatementSyntax operatorStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endOperatorStatement);
    public static OperatorBlockSyntax OperatorBlock(OperatorStatementSyntax operatorStatement, SyntaxList`1<StatementSyntax> statements);
    public static OperatorBlockSyntax OperatorBlock(OperatorStatementSyntax operatorStatement);
    public static AccessorBlockSyntax GetAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endAccessorStatement);
    public static AccessorBlockSyntax GetAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<StatementSyntax> statements);
    public static AccessorBlockSyntax GetAccessorBlock(AccessorStatementSyntax accessorStatement);
    public static AccessorBlockSyntax SetAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endAccessorStatement);
    public static AccessorBlockSyntax SetAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<StatementSyntax> statements);
    public static AccessorBlockSyntax SetAccessorBlock(AccessorStatementSyntax accessorStatement);
    public static AccessorBlockSyntax AddHandlerAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endAccessorStatement);
    public static AccessorBlockSyntax AddHandlerAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<StatementSyntax> statements);
    public static AccessorBlockSyntax AddHandlerAccessorBlock(AccessorStatementSyntax accessorStatement);
    public static AccessorBlockSyntax RemoveHandlerAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endAccessorStatement);
    public static AccessorBlockSyntax RemoveHandlerAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<StatementSyntax> statements);
    public static AccessorBlockSyntax RemoveHandlerAccessorBlock(AccessorStatementSyntax accessorStatement);
    public static AccessorBlockSyntax RaiseEventAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endAccessorStatement);
    public static AccessorBlockSyntax RaiseEventAccessorBlock(AccessorStatementSyntax accessorStatement, SyntaxList`1<StatementSyntax> statements);
    public static AccessorBlockSyntax RaiseEventAccessorBlock(AccessorStatementSyntax accessorStatement);
    public static AccessorBlockSyntax AccessorBlock(SyntaxKind kind, AccessorStatementSyntax accessorStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endAccessorStatement);
    private static SyntaxKind GetAccessorBlockAccessorStatementKind(SyntaxKind kind);
    private static SyntaxKind GetAccessorBlockEndAccessorStatementKind(SyntaxKind kind);
    public static AccessorBlockSyntax AccessorBlock(SyntaxKind kind, AccessorStatementSyntax accessorStatement, EndBlockStatementSyntax endAccessorStatement);
    public static PropertyBlockSyntax PropertyBlock(PropertyStatementSyntax propertyStatement, SyntaxList`1<AccessorBlockSyntax> accessors, EndBlockStatementSyntax endPropertyStatement);
    public static PropertyBlockSyntax PropertyBlock(PropertyStatementSyntax propertyStatement, SyntaxList`1<AccessorBlockSyntax> accessors);
    public static EventBlockSyntax EventBlock(EventStatementSyntax eventStatement, SyntaxList`1<AccessorBlockSyntax> accessors, EndBlockStatementSyntax endEventStatement);
    public static EventBlockSyntax EventBlock(EventStatementSyntax eventStatement, SyntaxList`1<AccessorBlockSyntax> accessors);
    public static ParameterListSyntax ParameterList(SyntaxToken openParenToken, SeparatedSyntaxList`1<ParameterSyntax> parameters, SyntaxToken closeParenToken);
    public static ParameterListSyntax ParameterList(SeparatedSyntaxList`1<ParameterSyntax> parameters);
    public static ParameterListSyntax ParameterList();
    public static MethodStatementSyntax SubStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, HandlesClauseSyntax handlesClause, ImplementsClauseSyntax implementsClause);
    public static MethodStatementSyntax SubStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, HandlesClauseSyntax handlesClause, ImplementsClauseSyntax implementsClause);
    public static MethodStatementSyntax SubStatement(SyntaxToken identifier);
    public static MethodStatementSyntax SubStatement(string identifier);
    public static MethodStatementSyntax FunctionStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, HandlesClauseSyntax handlesClause, ImplementsClauseSyntax implementsClause);
    public static MethodStatementSyntax FunctionStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, HandlesClauseSyntax handlesClause, ImplementsClauseSyntax implementsClause);
    public static MethodStatementSyntax FunctionStatement(SyntaxToken identifier);
    public static MethodStatementSyntax FunctionStatement(string identifier);
    public static MethodStatementSyntax MethodStatement(SyntaxKind kind, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, HandlesClauseSyntax handlesClause, ImplementsClauseSyntax implementsClause);
    private static SyntaxKind GetMethodStatementSubOrFunctionKeywordKind(SyntaxKind kind);
    public static MethodStatementSyntax MethodStatement(SyntaxKind kind, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier);
    public static MethodStatementSyntax MethodStatement(SyntaxKind kind, SyntaxToken subOrFunctionKeyword, string identifier);
    public static SubNewStatementSyntax SubNewStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken subKeyword, SyntaxToken newKeyword, ParameterListSyntax parameterList);
    public static SubNewStatementSyntax SubNewStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, ParameterListSyntax parameterList);
    public static SubNewStatementSyntax SubNewStatement();
    public static DeclareStatementSyntax DeclareSubStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken declareKeyword, SyntaxToken charsetKeyword, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, SyntaxToken libKeyword, LiteralExpressionSyntax libraryName, SyntaxToken aliasKeyword, LiteralExpressionSyntax aliasName, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public static DeclareStatementSyntax DeclareSubStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken charsetKeyword, SyntaxToken identifier, LiteralExpressionSyntax libraryName, LiteralExpressionSyntax aliasName, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public static DeclareStatementSyntax DeclareSubStatement(SyntaxToken identifier, LiteralExpressionSyntax libraryName);
    public static DeclareStatementSyntax DeclareSubStatement(string identifier, LiteralExpressionSyntax libraryName);
    public static DeclareStatementSyntax DeclareFunctionStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken declareKeyword, SyntaxToken charsetKeyword, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, SyntaxToken libKeyword, LiteralExpressionSyntax libraryName, SyntaxToken aliasKeyword, LiteralExpressionSyntax aliasName, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public static DeclareStatementSyntax DeclareFunctionStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken charsetKeyword, SyntaxToken identifier, LiteralExpressionSyntax libraryName, LiteralExpressionSyntax aliasName, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public static DeclareStatementSyntax DeclareFunctionStatement(SyntaxToken identifier, LiteralExpressionSyntax libraryName);
    public static DeclareStatementSyntax DeclareFunctionStatement(string identifier, LiteralExpressionSyntax libraryName);
    public static DeclareStatementSyntax DeclareStatement(SyntaxKind kind, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken declareKeyword, SyntaxToken charsetKeyword, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, SyntaxToken libKeyword, LiteralExpressionSyntax libraryName, SyntaxToken aliasKeyword, LiteralExpressionSyntax aliasName, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    private static SyntaxKind GetDeclareStatementSubOrFunctionKeywordKind(SyntaxKind kind);
    public static DeclareStatementSyntax DeclareStatement(SyntaxKind kind, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken charsetKeyword, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, LiteralExpressionSyntax libraryName, LiteralExpressionSyntax aliasName, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public static DeclareStatementSyntax DeclareStatement(SyntaxKind kind, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, LiteralExpressionSyntax libraryName);
    public static DeclareStatementSyntax DeclareStatement(SyntaxKind kind, SyntaxToken subOrFunctionKeyword, string identifier, LiteralExpressionSyntax libraryName);
    public static DelegateStatementSyntax DelegateSubStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public static DelegateStatementSyntax DelegateSubStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public static DelegateStatementSyntax DelegateSubStatement(SyntaxToken identifier);
    public static DelegateStatementSyntax DelegateSubStatement(string identifier);
    public static DelegateStatementSyntax DelegateFunctionStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public static DelegateStatementSyntax DelegateFunctionStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public static DelegateStatementSyntax DelegateFunctionStatement(SyntaxToken identifier);
    public static DelegateStatementSyntax DelegateFunctionStatement(string identifier);
    public static DelegateStatementSyntax DelegateStatement(SyntaxKind kind, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    private static SyntaxKind GetDelegateStatementSubOrFunctionKeywordKind(SyntaxKind kind);
    public static DelegateStatementSyntax DelegateStatement(SyntaxKind kind, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public static DelegateStatementSyntax DelegateStatement(SyntaxKind kind, SyntaxToken subOrFunctionKeyword, SyntaxToken identifier);
    public static DelegateStatementSyntax DelegateStatement(SyntaxKind kind, SyntaxToken subOrFunctionKeyword, string identifier);
    public static EventStatementSyntax EventStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken customKeyword, SyntaxToken eventKeyword, SyntaxToken identifier, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, ImplementsClauseSyntax implementsClause);
    public static EventStatementSyntax EventStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause, ImplementsClauseSyntax implementsClause);
    public static EventStatementSyntax EventStatement(SyntaxToken identifier);
    public static EventStatementSyntax EventStatement(string identifier);
    public static OperatorStatementSyntax OperatorStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public static OperatorStatementSyntax OperatorStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken operatorToken, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public static OperatorStatementSyntax OperatorStatement(SyntaxToken operatorToken);
    public static PropertyStatementSyntax PropertyStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken propertyKeyword, SyntaxToken identifier, ParameterListSyntax parameterList, AsClauseSyntax asClause, EqualsValueSyntax initializer, ImplementsClauseSyntax implementsClause);
    public static PropertyStatementSyntax PropertyStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, AsClauseSyntax asClause, EqualsValueSyntax initializer, ImplementsClauseSyntax implementsClause);
    public static PropertyStatementSyntax PropertyStatement(SyntaxToken identifier);
    public static PropertyStatementSyntax PropertyStatement(string identifier);
    public static AccessorStatementSyntax GetAccessorStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken accessorKeyword, ParameterListSyntax parameterList);
    public static AccessorStatementSyntax GetAccessorStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, ParameterListSyntax parameterList);
    public static AccessorStatementSyntax GetAccessorStatement();
    public static AccessorStatementSyntax SetAccessorStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken accessorKeyword, ParameterListSyntax parameterList);
    public static AccessorStatementSyntax SetAccessorStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, ParameterListSyntax parameterList);
    public static AccessorStatementSyntax SetAccessorStatement();
    public static AccessorStatementSyntax AddHandlerAccessorStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken accessorKeyword, ParameterListSyntax parameterList);
    public static AccessorStatementSyntax AddHandlerAccessorStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, ParameterListSyntax parameterList);
    public static AccessorStatementSyntax AddHandlerAccessorStatement();
    public static AccessorStatementSyntax RemoveHandlerAccessorStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken accessorKeyword, ParameterListSyntax parameterList);
    public static AccessorStatementSyntax RemoveHandlerAccessorStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, ParameterListSyntax parameterList);
    public static AccessorStatementSyntax RemoveHandlerAccessorStatement();
    public static AccessorStatementSyntax RaiseEventAccessorStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken accessorKeyword, ParameterListSyntax parameterList);
    public static AccessorStatementSyntax RaiseEventAccessorStatement(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, ParameterListSyntax parameterList);
    public static AccessorStatementSyntax RaiseEventAccessorStatement();
    public static AccessorStatementSyntax AccessorStatement(SyntaxKind kind, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken accessorKeyword, ParameterListSyntax parameterList);
    private static SyntaxKind GetAccessorStatementAccessorKeywordKind(SyntaxKind kind);
    public static AccessorStatementSyntax AccessorStatement(SyntaxKind kind, SyntaxToken accessorKeyword);
    public static ImplementsClauseSyntax ImplementsClause(SyntaxToken implementsKeyword, SeparatedSyntaxList`1<QualifiedNameSyntax> interfaceMembers);
    public static ImplementsClauseSyntax ImplementsClause(SeparatedSyntaxList`1<QualifiedNameSyntax> interfaceMembers);
    public static ImplementsClauseSyntax ImplementsClause(QualifiedNameSyntax[] interfaceMembers);
    public static HandlesClauseSyntax HandlesClause(SyntaxToken handlesKeyword, SeparatedSyntaxList`1<HandlesClauseItemSyntax> events);
    public static HandlesClauseSyntax HandlesClause(SeparatedSyntaxList`1<HandlesClauseItemSyntax> events);
    public static HandlesClauseSyntax HandlesClause(HandlesClauseItemSyntax[] events);
    public static KeywordEventContainerSyntax KeywordEventContainer(SyntaxToken keyword);
    public static WithEventsEventContainerSyntax WithEventsEventContainer(SyntaxToken identifier);
    public static WithEventsEventContainerSyntax WithEventsEventContainer(string identifier);
    public static WithEventsPropertyEventContainerSyntax WithEventsPropertyEventContainer(WithEventsEventContainerSyntax withEventsContainer, SyntaxToken dotToken, IdentifierNameSyntax property);
    public static WithEventsPropertyEventContainerSyntax WithEventsPropertyEventContainer(WithEventsEventContainerSyntax withEventsContainer, IdentifierNameSyntax property);
    public static HandlesClauseItemSyntax HandlesClauseItem(EventContainerSyntax eventContainer, SyntaxToken dotToken, IdentifierNameSyntax eventMember);
    public static HandlesClauseItemSyntax HandlesClauseItem(EventContainerSyntax eventContainer, IdentifierNameSyntax eventMember);
    public static IncompleteMemberSyntax IncompleteMember(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken missingIdentifier);
    public static IncompleteMemberSyntax IncompleteMember();
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SeparatedSyntaxList`1<VariableDeclaratorSyntax> declarators);
    public static FieldDeclarationSyntax FieldDeclaration(SeparatedSyntaxList`1<VariableDeclaratorSyntax> declarators);
    public static FieldDeclarationSyntax FieldDeclaration(VariableDeclaratorSyntax[] declarators);
    public static VariableDeclaratorSyntax VariableDeclarator(SeparatedSyntaxList`1<ModifiedIdentifierSyntax> names, AsClauseSyntax asClause, EqualsValueSyntax initializer);
    public static VariableDeclaratorSyntax VariableDeclarator(SeparatedSyntaxList`1<ModifiedIdentifierSyntax> names);
    public static VariableDeclaratorSyntax VariableDeclarator(ModifiedIdentifierSyntax[] names);
    public static SimpleAsClauseSyntax SimpleAsClause(SyntaxToken asKeyword, SyntaxList`1<AttributeListSyntax> attributeLists, TypeSyntax type);
    public static SimpleAsClauseSyntax SimpleAsClause(SyntaxList`1<AttributeListSyntax> attributeLists, TypeSyntax type);
    public static SimpleAsClauseSyntax SimpleAsClause(TypeSyntax type);
    public static AsNewClauseSyntax AsNewClause(SyntaxToken asKeyword, NewExpressionSyntax newExpression);
    public static AsNewClauseSyntax AsNewClause(NewExpressionSyntax newExpression);
    public static ObjectMemberInitializerSyntax ObjectMemberInitializer(SyntaxToken withKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList`1<FieldInitializerSyntax> initializers, SyntaxToken closeBraceToken);
    public static ObjectMemberInitializerSyntax ObjectMemberInitializer(SeparatedSyntaxList`1<FieldInitializerSyntax> initializers);
    public static ObjectMemberInitializerSyntax ObjectMemberInitializer(FieldInitializerSyntax[] initializers);
    public static ObjectCollectionInitializerSyntax ObjectCollectionInitializer(SyntaxToken fromKeyword, CollectionInitializerSyntax initializer);
    public static ObjectCollectionInitializerSyntax ObjectCollectionInitializer(CollectionInitializerSyntax initializer);
    public static InferredFieldInitializerSyntax InferredFieldInitializer(SyntaxToken keyKeyword, ExpressionSyntax expression);
    public static InferredFieldInitializerSyntax InferredFieldInitializer(ExpressionSyntax expression);
    public static NamedFieldInitializerSyntax NamedFieldInitializer(SyntaxToken keyKeyword, SyntaxToken dotToken, IdentifierNameSyntax name, SyntaxToken equalsToken, ExpressionSyntax expression);
    public static NamedFieldInitializerSyntax NamedFieldInitializer(IdentifierNameSyntax name, ExpressionSyntax expression);
    public static EqualsValueSyntax EqualsValue(SyntaxToken equalsToken, ExpressionSyntax value);
    public static EqualsValueSyntax EqualsValue(ExpressionSyntax value);
    public static ParameterSyntax Parameter(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, EqualsValueSyntax default);
    public static ParameterSyntax Parameter(ModifiedIdentifierSyntax identifier);
    public static ModifiedIdentifierSyntax ModifiedIdentifier(SyntaxToken identifier, SyntaxToken nullable, ArgumentListSyntax arrayBounds, SyntaxList`1<ArrayRankSpecifierSyntax> arrayRankSpecifiers);
    public static ModifiedIdentifierSyntax ModifiedIdentifier(SyntaxToken identifier, ArgumentListSyntax arrayBounds);
    public static ModifiedIdentifierSyntax ModifiedIdentifier(SyntaxToken identifier);
    public static ModifiedIdentifierSyntax ModifiedIdentifier(string identifier);
    public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openParenToken, SyntaxTokenList commaTokens, SyntaxToken closeParenToken);
    public static ArrayRankSpecifierSyntax ArrayRankSpecifier();
    public static AttributeListSyntax AttributeList(SyntaxToken lessThanToken, SeparatedSyntaxList`1<AttributeSyntax> attributes, SyntaxToken greaterThanToken);
    public static AttributeListSyntax AttributeList(SeparatedSyntaxList`1<AttributeSyntax> attributes);
    public static AttributeListSyntax AttributeList();
    public static AttributeSyntax Attribute(AttributeTargetSyntax target, TypeSyntax name, ArgumentListSyntax argumentList);
    public static AttributeSyntax Attribute(TypeSyntax name);
    public static AttributeTargetSyntax AttributeTarget(SyntaxToken attributeModifier, SyntaxToken colonToken);
    public static AttributeTargetSyntax AttributeTarget(SyntaxToken attributeModifier);
    public static AttributesStatementSyntax AttributesStatement(SyntaxList`1<AttributeListSyntax> attributeLists);
    public static AttributesStatementSyntax AttributesStatement();
    public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression);
    public static PrintStatementSyntax PrintStatement(SyntaxToken questionToken, ExpressionSyntax expression);
    public static PrintStatementSyntax PrintStatement(ExpressionSyntax expression);
    public static WhileBlockSyntax WhileBlock(WhileStatementSyntax whileStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endWhileStatement);
    public static WhileBlockSyntax WhileBlock(WhileStatementSyntax whileStatement, SyntaxList`1<StatementSyntax> statements);
    public static WhileBlockSyntax WhileBlock(WhileStatementSyntax whileStatement);
    public static UsingBlockSyntax UsingBlock(UsingStatementSyntax usingStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endUsingStatement);
    public static UsingBlockSyntax UsingBlock(UsingStatementSyntax usingStatement, SyntaxList`1<StatementSyntax> statements);
    public static UsingBlockSyntax UsingBlock(UsingStatementSyntax usingStatement);
    public static SyncLockBlockSyntax SyncLockBlock(SyncLockStatementSyntax syncLockStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endSyncLockStatement);
    public static SyncLockBlockSyntax SyncLockBlock(SyncLockStatementSyntax syncLockStatement, SyntaxList`1<StatementSyntax> statements);
    public static SyncLockBlockSyntax SyncLockBlock(SyncLockStatementSyntax syncLockStatement);
    public static WithBlockSyntax WithBlock(WithStatementSyntax withStatement, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endWithStatement);
    public static WithBlockSyntax WithBlock(WithStatementSyntax withStatement, SyntaxList`1<StatementSyntax> statements);
    public static WithBlockSyntax WithBlock(WithStatementSyntax withStatement);
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxTokenList modifiers, SeparatedSyntaxList`1<VariableDeclaratorSyntax> declarators);
    public static LabelStatementSyntax LabelStatement(SyntaxToken labelToken, SyntaxToken colonToken);
    public static LabelStatementSyntax LabelStatement(SyntaxToken labelToken);
    public static LabelStatementSyntax LabelStatement(string labelToken);
    public static GoToStatementSyntax GoToStatement(SyntaxToken goToKeyword, LabelSyntax label);
    public static GoToStatementSyntax GoToStatement(LabelSyntax label);
    public static LabelSyntax IdentifierLabel(SyntaxToken labelToken);
    public static LabelSyntax IdentifierLabel(string labelToken);
    public static LabelSyntax NumericLabel(SyntaxToken labelToken);
    public static LabelSyntax NumericLabel();
    public static LabelSyntax NextLabel(SyntaxToken labelToken);
    public static LabelSyntax NextLabel();
    public static LabelSyntax Label(SyntaxKind kind, SyntaxToken labelToken);
    private static SyntaxKind GetLabelLabelTokenKind(SyntaxKind kind);
    public static LabelSyntax Label(SyntaxKind kind, string labelToken);
    public static StopOrEndStatementSyntax StopStatement(SyntaxToken stopOrEndKeyword);
    public static StopOrEndStatementSyntax EndStatement(SyntaxToken stopOrEndKeyword);
    public static StopOrEndStatementSyntax StopOrEndStatement(SyntaxKind kind, SyntaxToken stopOrEndKeyword);
    public static ExitStatementSyntax ExitDoStatement(SyntaxToken exitKeyword, SyntaxToken blockKeyword);
    public static ExitStatementSyntax ExitDoStatement();
    public static ExitStatementSyntax ExitForStatement(SyntaxToken exitKeyword, SyntaxToken blockKeyword);
    public static ExitStatementSyntax ExitForStatement();
    public static ExitStatementSyntax ExitSubStatement(SyntaxToken exitKeyword, SyntaxToken blockKeyword);
    public static ExitStatementSyntax ExitSubStatement();
    public static ExitStatementSyntax ExitFunctionStatement(SyntaxToken exitKeyword, SyntaxToken blockKeyword);
    public static ExitStatementSyntax ExitFunctionStatement();
    public static ExitStatementSyntax ExitOperatorStatement(SyntaxToken exitKeyword, SyntaxToken blockKeyword);
    public static ExitStatementSyntax ExitOperatorStatement();
    public static ExitStatementSyntax ExitPropertyStatement(SyntaxToken exitKeyword, SyntaxToken blockKeyword);
    public static ExitStatementSyntax ExitPropertyStatement();
    public static ExitStatementSyntax ExitTryStatement(SyntaxToken exitKeyword, SyntaxToken blockKeyword);
    public static ExitStatementSyntax ExitTryStatement();
    public static ExitStatementSyntax ExitSelectStatement(SyntaxToken exitKeyword, SyntaxToken blockKeyword);
    public static ExitStatementSyntax ExitSelectStatement();
    public static ExitStatementSyntax ExitWhileStatement(SyntaxToken exitKeyword, SyntaxToken blockKeyword);
    public static ExitStatementSyntax ExitWhileStatement();
    public static ExitStatementSyntax ExitStatement(SyntaxKind kind, SyntaxToken exitKeyword, SyntaxToken blockKeyword);
    private static SyntaxKind GetExitStatementBlockKeywordKind(SyntaxKind kind);
    public static ExitStatementSyntax ExitStatement(SyntaxKind kind, SyntaxToken blockKeyword);
    public static ContinueStatementSyntax ContinueWhileStatement(SyntaxToken continueKeyword, SyntaxToken blockKeyword);
    public static ContinueStatementSyntax ContinueWhileStatement();
    public static ContinueStatementSyntax ContinueDoStatement(SyntaxToken continueKeyword, SyntaxToken blockKeyword);
    public static ContinueStatementSyntax ContinueDoStatement();
    public static ContinueStatementSyntax ContinueForStatement(SyntaxToken continueKeyword, SyntaxToken blockKeyword);
    public static ContinueStatementSyntax ContinueForStatement();
    public static ContinueStatementSyntax ContinueStatement(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken blockKeyword);
    private static SyntaxKind GetContinueStatementBlockKeywordKind(SyntaxKind kind);
    public static ContinueStatementSyntax ContinueStatement(SyntaxKind kind, SyntaxToken blockKeyword);
    public static ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, ExpressionSyntax expression);
    public static ReturnStatementSyntax ReturnStatement(ExpressionSyntax expression);
    public static ReturnStatementSyntax ReturnStatement();
    public static SingleLineIfStatementSyntax SingleLineIfStatement(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, SyntaxList`1<StatementSyntax> statements, SingleLineElseClauseSyntax elseClause);
    public static SingleLineIfStatementSyntax SingleLineIfStatement(ExpressionSyntax condition, SyntaxList`1<StatementSyntax> statements, SingleLineElseClauseSyntax elseClause);
    public static SingleLineIfStatementSyntax SingleLineIfStatement(ExpressionSyntax condition);
    public static SingleLineElseClauseSyntax SingleLineElseClause(SyntaxToken elseKeyword, SyntaxList`1<StatementSyntax> statements);
    public static SingleLineElseClauseSyntax SingleLineElseClause(SyntaxList`1<StatementSyntax> statements);
    public static SingleLineElseClauseSyntax SingleLineElseClause();
    public static MultiLineIfBlockSyntax MultiLineIfBlock(IfStatementSyntax ifStatement, SyntaxList`1<StatementSyntax> statements, SyntaxList`1<ElseIfBlockSyntax> elseIfBlocks, ElseBlockSyntax elseBlock, EndBlockStatementSyntax endIfStatement);
    public static MultiLineIfBlockSyntax MultiLineIfBlock(IfStatementSyntax ifStatement, SyntaxList`1<StatementSyntax> statements, SyntaxList`1<ElseIfBlockSyntax> elseIfBlocks, ElseBlockSyntax elseBlock);
    public static MultiLineIfBlockSyntax MultiLineIfBlock(IfStatementSyntax ifStatement);
    public static IfStatementSyntax IfStatement(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword);
    public static IfStatementSyntax IfStatement(ExpressionSyntax condition);
    public static ElseIfBlockSyntax ElseIfBlock(ElseIfStatementSyntax elseIfStatement, SyntaxList`1<StatementSyntax> statements);
    public static ElseIfBlockSyntax ElseIfBlock(ElseIfStatementSyntax elseIfStatement);
    public static ElseIfStatementSyntax ElseIfStatement(SyntaxToken elseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword);
    public static ElseIfStatementSyntax ElseIfStatement(ExpressionSyntax condition);
    public static ElseBlockSyntax ElseBlock(ElseStatementSyntax elseStatement, SyntaxList`1<StatementSyntax> statements);
    public static ElseBlockSyntax ElseBlock(SyntaxList`1<StatementSyntax> statements);
    public static ElseBlockSyntax ElseBlock();
    public static ElseStatementSyntax ElseStatement(SyntaxToken elseKeyword);
    public static ElseStatementSyntax ElseStatement();
    public static TryBlockSyntax TryBlock(TryStatementSyntax tryStatement, SyntaxList`1<StatementSyntax> statements, SyntaxList`1<CatchBlockSyntax> catchBlocks, FinallyBlockSyntax finallyBlock, EndBlockStatementSyntax endTryStatement);
    public static TryBlockSyntax TryBlock(SyntaxList`1<StatementSyntax> statements, SyntaxList`1<CatchBlockSyntax> catchBlocks, FinallyBlockSyntax finallyBlock);
    public static TryBlockSyntax TryBlock();
    public static TryStatementSyntax TryStatement(SyntaxToken tryKeyword);
    public static TryStatementSyntax TryStatement();
    public static CatchBlockSyntax CatchBlock(CatchStatementSyntax catchStatement, SyntaxList`1<StatementSyntax> statements);
    public static CatchBlockSyntax CatchBlock(CatchStatementSyntax catchStatement);
    public static CatchStatementSyntax CatchStatement(SyntaxToken catchKeyword, IdentifierNameSyntax identifierName, SimpleAsClauseSyntax asClause, CatchFilterClauseSyntax whenClause);
    public static CatchStatementSyntax CatchStatement(IdentifierNameSyntax identifierName, SimpleAsClauseSyntax asClause, CatchFilterClauseSyntax whenClause);
    public static CatchStatementSyntax CatchStatement();
    public static CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, ExpressionSyntax filter);
    public static CatchFilterClauseSyntax CatchFilterClause(ExpressionSyntax filter);
    public static FinallyBlockSyntax FinallyBlock(FinallyStatementSyntax finallyStatement, SyntaxList`1<StatementSyntax> statements);
    public static FinallyBlockSyntax FinallyBlock(SyntaxList`1<StatementSyntax> statements);
    public static FinallyBlockSyntax FinallyBlock();
    public static FinallyStatementSyntax FinallyStatement(SyntaxToken finallyKeyword);
    public static FinallyStatementSyntax FinallyStatement();
    public static ErrorStatementSyntax ErrorStatement(SyntaxToken errorKeyword, ExpressionSyntax errorNumber);
    public static ErrorStatementSyntax ErrorStatement(ExpressionSyntax errorNumber);
    public static OnErrorGoToStatementSyntax OnErrorGoToZeroStatement(SyntaxToken onKeyword, SyntaxToken errorKeyword, SyntaxToken goToKeyword, SyntaxToken minus, LabelSyntax label);
    public static OnErrorGoToStatementSyntax OnErrorGoToZeroStatement(LabelSyntax label);
    public static OnErrorGoToStatementSyntax OnErrorGoToMinusOneStatement(SyntaxToken onKeyword, SyntaxToken errorKeyword, SyntaxToken goToKeyword, SyntaxToken minus, LabelSyntax label);
    public static OnErrorGoToStatementSyntax OnErrorGoToMinusOneStatement(LabelSyntax label);
    public static OnErrorGoToStatementSyntax OnErrorGoToLabelStatement(SyntaxToken onKeyword, SyntaxToken errorKeyword, SyntaxToken goToKeyword, SyntaxToken minus, LabelSyntax label);
    public static OnErrorGoToStatementSyntax OnErrorGoToLabelStatement(LabelSyntax label);
    public static OnErrorGoToStatementSyntax OnErrorGoToStatement(SyntaxKind kind, SyntaxToken onKeyword, SyntaxToken errorKeyword, SyntaxToken goToKeyword, SyntaxToken minus, LabelSyntax label);
    public static OnErrorGoToStatementSyntax OnErrorGoToStatement(SyntaxKind kind, LabelSyntax label);
    public static OnErrorResumeNextStatementSyntax OnErrorResumeNextStatement(SyntaxToken onKeyword, SyntaxToken errorKeyword, SyntaxToken resumeKeyword, SyntaxToken nextKeyword);
    public static OnErrorResumeNextStatementSyntax OnErrorResumeNextStatement();
    public static ResumeStatementSyntax ResumeStatement(SyntaxToken resumeKeyword, LabelSyntax label);
    public static ResumeStatementSyntax ResumeStatement(LabelSyntax label);
    public static ResumeStatementSyntax ResumeStatement();
    public static ResumeStatementSyntax ResumeLabelStatement(SyntaxToken resumeKeyword, LabelSyntax label);
    public static ResumeStatementSyntax ResumeLabelStatement(LabelSyntax label);
    public static ResumeStatementSyntax ResumeLabelStatement();
    public static ResumeStatementSyntax ResumeNextStatement(SyntaxToken resumeKeyword, LabelSyntax label);
    public static ResumeStatementSyntax ResumeNextStatement(LabelSyntax label);
    public static ResumeStatementSyntax ResumeNextStatement();
    public static ResumeStatementSyntax ResumeStatement(SyntaxKind kind, SyntaxToken resumeKeyword, LabelSyntax label);
    public static ResumeStatementSyntax ResumeStatement(SyntaxKind kind, LabelSyntax label);
    public static ResumeStatementSyntax ResumeStatement(SyntaxKind kind);
    public static SelectBlockSyntax SelectBlock(SelectStatementSyntax selectStatement, SyntaxList`1<CaseBlockSyntax> caseBlocks, EndBlockStatementSyntax endSelectStatement);
    public static SelectBlockSyntax SelectBlock(SelectStatementSyntax selectStatement, SyntaxList`1<CaseBlockSyntax> caseBlocks);
    public static SelectBlockSyntax SelectBlock(SelectStatementSyntax selectStatement);
    public static SelectStatementSyntax SelectStatement(SyntaxToken selectKeyword, SyntaxToken caseKeyword, ExpressionSyntax expression);
    public static SelectStatementSyntax SelectStatement(ExpressionSyntax expression);
    public static CaseBlockSyntax CaseBlock(CaseStatementSyntax caseStatement, SyntaxList`1<StatementSyntax> statements);
    public static CaseBlockSyntax CaseBlock(CaseStatementSyntax caseStatement);
    public static CaseBlockSyntax CaseElseBlock(CaseStatementSyntax caseStatement, SyntaxList`1<StatementSyntax> statements);
    public static CaseBlockSyntax CaseElseBlock(CaseStatementSyntax caseStatement);
    public static CaseBlockSyntax CaseBlock(SyntaxKind kind, CaseStatementSyntax caseStatement, SyntaxList`1<StatementSyntax> statements);
    public static CaseBlockSyntax CaseBlock(SyntaxKind kind, CaseStatementSyntax caseStatement);
    public static CaseStatementSyntax CaseStatement(SyntaxToken caseKeyword, SeparatedSyntaxList`1<CaseClauseSyntax> cases);
    public static CaseStatementSyntax CaseStatement(SeparatedSyntaxList`1<CaseClauseSyntax> cases);
    public static CaseStatementSyntax CaseStatement(CaseClauseSyntax[] cases);
    public static CaseStatementSyntax CaseElseStatement(SyntaxToken caseKeyword, SeparatedSyntaxList`1<CaseClauseSyntax> cases);
    public static CaseStatementSyntax CaseElseStatement(SeparatedSyntaxList`1<CaseClauseSyntax> cases);
    public static CaseStatementSyntax CaseElseStatement(CaseClauseSyntax[] cases);
    public static CaseStatementSyntax CaseStatement(SyntaxKind kind, SyntaxToken caseKeyword, SeparatedSyntaxList`1<CaseClauseSyntax> cases);
    public static CaseStatementSyntax CaseStatement(SyntaxKind kind, SeparatedSyntaxList`1<CaseClauseSyntax> cases);
    public static CaseStatementSyntax CaseStatement(SyntaxKind kind, CaseClauseSyntax[] cases);
    public static ElseCaseClauseSyntax ElseCaseClause(SyntaxToken elseKeyword);
    public static ElseCaseClauseSyntax ElseCaseClause();
    public static SimpleCaseClauseSyntax SimpleCaseClause(ExpressionSyntax value);
    public static RangeCaseClauseSyntax RangeCaseClause(ExpressionSyntax lowerBound, SyntaxToken toKeyword, ExpressionSyntax upperBound);
    public static RangeCaseClauseSyntax RangeCaseClause(ExpressionSyntax lowerBound, ExpressionSyntax upperBound);
    public static RelationalCaseClauseSyntax CaseEqualsClause(SyntaxToken isKeyword, SyntaxToken operatorToken, ExpressionSyntax value);
    public static RelationalCaseClauseSyntax CaseEqualsClause(ExpressionSyntax value);
    public static RelationalCaseClauseSyntax CaseNotEqualsClause(SyntaxToken isKeyword, SyntaxToken operatorToken, ExpressionSyntax value);
    public static RelationalCaseClauseSyntax CaseNotEqualsClause(ExpressionSyntax value);
    public static RelationalCaseClauseSyntax CaseLessThanClause(SyntaxToken isKeyword, SyntaxToken operatorToken, ExpressionSyntax value);
    public static RelationalCaseClauseSyntax CaseLessThanClause(ExpressionSyntax value);
    public static RelationalCaseClauseSyntax CaseLessThanOrEqualClause(SyntaxToken isKeyword, SyntaxToken operatorToken, ExpressionSyntax value);
    public static RelationalCaseClauseSyntax CaseLessThanOrEqualClause(ExpressionSyntax value);
    public static RelationalCaseClauseSyntax CaseGreaterThanOrEqualClause(SyntaxToken isKeyword, SyntaxToken operatorToken, ExpressionSyntax value);
    public static RelationalCaseClauseSyntax CaseGreaterThanOrEqualClause(ExpressionSyntax value);
    public static RelationalCaseClauseSyntax CaseGreaterThanClause(SyntaxToken isKeyword, SyntaxToken operatorToken, ExpressionSyntax value);
    public static RelationalCaseClauseSyntax CaseGreaterThanClause(ExpressionSyntax value);
    public static RelationalCaseClauseSyntax RelationalCaseClause(SyntaxKind kind, SyntaxToken isKeyword, SyntaxToken operatorToken, ExpressionSyntax value);
    private static SyntaxKind GetRelationalCaseClauseOperatorTokenKind(SyntaxKind kind);
    public static RelationalCaseClauseSyntax RelationalCaseClause(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax value);
    public static SyncLockStatementSyntax SyncLockStatement(SyntaxToken syncLockKeyword, ExpressionSyntax expression);
    public static SyncLockStatementSyntax SyncLockStatement(ExpressionSyntax expression);
    public static DoLoopBlockSyntax SimpleDoLoopBlock(DoStatementSyntax doStatement, SyntaxList`1<StatementSyntax> statements, LoopStatementSyntax loopStatement);
    public static DoLoopBlockSyntax SimpleDoLoopBlock(DoStatementSyntax doStatement, LoopStatementSyntax loopStatement);
    public static DoLoopBlockSyntax DoWhileLoopBlock(DoStatementSyntax doStatement, SyntaxList`1<StatementSyntax> statements, LoopStatementSyntax loopStatement);
    public static DoLoopBlockSyntax DoWhileLoopBlock(DoStatementSyntax doStatement, LoopStatementSyntax loopStatement);
    public static DoLoopBlockSyntax DoUntilLoopBlock(DoStatementSyntax doStatement, SyntaxList`1<StatementSyntax> statements, LoopStatementSyntax loopStatement);
    public static DoLoopBlockSyntax DoUntilLoopBlock(DoStatementSyntax doStatement, LoopStatementSyntax loopStatement);
    public static DoLoopBlockSyntax DoLoopWhileBlock(DoStatementSyntax doStatement, SyntaxList`1<StatementSyntax> statements, LoopStatementSyntax loopStatement);
    public static DoLoopBlockSyntax DoLoopWhileBlock(DoStatementSyntax doStatement, LoopStatementSyntax loopStatement);
    public static DoLoopBlockSyntax DoLoopUntilBlock(DoStatementSyntax doStatement, SyntaxList`1<StatementSyntax> statements, LoopStatementSyntax loopStatement);
    public static DoLoopBlockSyntax DoLoopUntilBlock(DoStatementSyntax doStatement, LoopStatementSyntax loopStatement);
    public static DoLoopBlockSyntax DoLoopBlock(SyntaxKind kind, DoStatementSyntax doStatement, SyntaxList`1<StatementSyntax> statements, LoopStatementSyntax loopStatement);
    private static SyntaxKind GetDoLoopBlockDoStatementKind(SyntaxKind kind);
    private static SyntaxKind GetDoLoopBlockLoopStatementKind(SyntaxKind kind);
    public static DoLoopBlockSyntax DoLoopBlock(SyntaxKind kind, DoStatementSyntax doStatement, LoopStatementSyntax loopStatement);
    public static DoStatementSyntax SimpleDoStatement(SyntaxToken doKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    public static DoStatementSyntax SimpleDoStatement(WhileOrUntilClauseSyntax whileOrUntilClause);
    public static DoStatementSyntax SimpleDoStatement();
    public static DoStatementSyntax DoWhileStatement(SyntaxToken doKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    public static DoStatementSyntax DoWhileStatement(WhileOrUntilClauseSyntax whileOrUntilClause);
    public static DoStatementSyntax DoWhileStatement();
    public static DoStatementSyntax DoUntilStatement(SyntaxToken doKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    public static DoStatementSyntax DoUntilStatement(WhileOrUntilClauseSyntax whileOrUntilClause);
    public static DoStatementSyntax DoUntilStatement();
    public static DoStatementSyntax DoStatement(SyntaxKind kind, SyntaxToken doKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    private static SyntaxKind GetDoStatementWhileOrUntilClauseKind(SyntaxKind kind);
    public static DoStatementSyntax DoStatement(SyntaxKind kind, WhileOrUntilClauseSyntax whileOrUntilClause);
    public static DoStatementSyntax DoStatement(SyntaxKind kind);
    public static LoopStatementSyntax SimpleLoopStatement(SyntaxToken loopKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    public static LoopStatementSyntax SimpleLoopStatement(WhileOrUntilClauseSyntax whileOrUntilClause);
    public static LoopStatementSyntax SimpleLoopStatement();
    public static LoopStatementSyntax LoopWhileStatement(SyntaxToken loopKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    public static LoopStatementSyntax LoopWhileStatement(WhileOrUntilClauseSyntax whileOrUntilClause);
    public static LoopStatementSyntax LoopWhileStatement();
    public static LoopStatementSyntax LoopUntilStatement(SyntaxToken loopKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    public static LoopStatementSyntax LoopUntilStatement(WhileOrUntilClauseSyntax whileOrUntilClause);
    public static LoopStatementSyntax LoopUntilStatement();
    public static LoopStatementSyntax LoopStatement(SyntaxKind kind, SyntaxToken loopKeyword, WhileOrUntilClauseSyntax whileOrUntilClause);
    private static SyntaxKind GetLoopStatementWhileOrUntilClauseKind(SyntaxKind kind);
    public static LoopStatementSyntax LoopStatement(SyntaxKind kind, WhileOrUntilClauseSyntax whileOrUntilClause);
    public static LoopStatementSyntax LoopStatement(SyntaxKind kind);
    public static WhileOrUntilClauseSyntax WhileClause(SyntaxToken whileOrUntilKeyword, ExpressionSyntax condition);
    public static WhileOrUntilClauseSyntax WhileClause(ExpressionSyntax condition);
    public static WhileOrUntilClauseSyntax UntilClause(SyntaxToken whileOrUntilKeyword, ExpressionSyntax condition);
    public static WhileOrUntilClauseSyntax UntilClause(ExpressionSyntax condition);
    public static WhileOrUntilClauseSyntax WhileOrUntilClause(SyntaxKind kind, SyntaxToken whileOrUntilKeyword, ExpressionSyntax condition);
    private static SyntaxKind GetWhileOrUntilClauseWhileOrUntilKeywordKind(SyntaxKind kind);
    public static WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, ExpressionSyntax condition);
    public static WhileStatementSyntax WhileStatement(ExpressionSyntax condition);
    public static ForBlockSyntax ForBlock(ForStatementSyntax forStatement, SyntaxList`1<StatementSyntax> statements, NextStatementSyntax nextStatement);
    public static ForBlockSyntax ForBlock(ForStatementSyntax forStatement);
    public static ForEachBlockSyntax ForEachBlock(ForEachStatementSyntax forEachStatement, SyntaxList`1<StatementSyntax> statements, NextStatementSyntax nextStatement);
    public static ForEachBlockSyntax ForEachBlock(ForEachStatementSyntax forEachStatement);
    public static ForStatementSyntax ForStatement(SyntaxToken forKeyword, VisualBasicSyntaxNode controlVariable, SyntaxToken equalsToken, ExpressionSyntax fromValue, SyntaxToken toKeyword, ExpressionSyntax toValue, ForStepClauseSyntax stepClause);
    public static ForStatementSyntax ForStatement(VisualBasicSyntaxNode controlVariable, ExpressionSyntax fromValue, ExpressionSyntax toValue, ForStepClauseSyntax stepClause);
    public static ForStatementSyntax ForStatement(VisualBasicSyntaxNode controlVariable, ExpressionSyntax fromValue, ExpressionSyntax toValue);
    public static ForStepClauseSyntax ForStepClause(SyntaxToken stepKeyword, ExpressionSyntax stepValue);
    public static ForStepClauseSyntax ForStepClause(ExpressionSyntax stepValue);
    public static ForEachStatementSyntax ForEachStatement(SyntaxToken forKeyword, SyntaxToken eachKeyword, VisualBasicSyntaxNode controlVariable, SyntaxToken inKeyword, ExpressionSyntax expression);
    public static ForEachStatementSyntax ForEachStatement(VisualBasicSyntaxNode controlVariable, ExpressionSyntax expression);
    public static NextStatementSyntax NextStatement(SyntaxToken nextKeyword, SeparatedSyntaxList`1<ExpressionSyntax> controlVariables);
    public static NextStatementSyntax NextStatement(SeparatedSyntaxList`1<ExpressionSyntax> controlVariables);
    public static NextStatementSyntax NextStatement();
    public static UsingStatementSyntax UsingStatement(SyntaxToken usingKeyword, ExpressionSyntax expression, SeparatedSyntaxList`1<VariableDeclaratorSyntax> variables);
    public static UsingStatementSyntax UsingStatement(ExpressionSyntax expression, SeparatedSyntaxList`1<VariableDeclaratorSyntax> variables);
    public static UsingStatementSyntax UsingStatement();
    public static ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, ExpressionSyntax expression);
    public static ThrowStatementSyntax ThrowStatement(ExpressionSyntax expression);
    public static ThrowStatementSyntax ThrowStatement();
    public static AssignmentStatementSyntax SimpleAssignmentStatement(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentStatementSyntax SimpleAssignmentStatement(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentStatementSyntax MidAssignmentStatement(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentStatementSyntax MidAssignmentStatement(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentStatementSyntax AddAssignmentStatement(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentStatementSyntax AddAssignmentStatement(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentStatementSyntax SubtractAssignmentStatement(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentStatementSyntax SubtractAssignmentStatement(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentStatementSyntax MultiplyAssignmentStatement(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentStatementSyntax MultiplyAssignmentStatement(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentStatementSyntax DivideAssignmentStatement(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentStatementSyntax DivideAssignmentStatement(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentStatementSyntax IntegerDivideAssignmentStatement(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentStatementSyntax IntegerDivideAssignmentStatement(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentStatementSyntax ExponentiateAssignmentStatement(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentStatementSyntax ExponentiateAssignmentStatement(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentStatementSyntax LeftShiftAssignmentStatement(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentStatementSyntax LeftShiftAssignmentStatement(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentStatementSyntax RightShiftAssignmentStatement(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentStatementSyntax RightShiftAssignmentStatement(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentStatementSyntax ConcatenateAssignmentStatement(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static AssignmentStatementSyntax ConcatenateAssignmentStatement(ExpressionSyntax left, ExpressionSyntax right);
    public static AssignmentStatementSyntax AssignmentStatement(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    private static SyntaxKind GetAssignmentStatementOperatorTokenKind(SyntaxKind kind);
    public static MidExpressionSyntax MidExpression(SyntaxToken mid, ArgumentListSyntax argumentList);
    public static MidExpressionSyntax MidExpression(string mid, ArgumentListSyntax argumentList);
    public static CallStatementSyntax CallStatement(SyntaxToken callKeyword, ExpressionSyntax invocation);
    public static CallStatementSyntax CallStatement(ExpressionSyntax invocation);
    public static AddRemoveHandlerStatementSyntax AddHandlerStatement(SyntaxToken addHandlerOrRemoveHandlerKeyword, ExpressionSyntax eventExpression, SyntaxToken commaToken, ExpressionSyntax delegateExpression);
    public static AddRemoveHandlerStatementSyntax AddHandlerStatement(ExpressionSyntax eventExpression, ExpressionSyntax delegateExpression);
    public static AddRemoveHandlerStatementSyntax RemoveHandlerStatement(SyntaxToken addHandlerOrRemoveHandlerKeyword, ExpressionSyntax eventExpression, SyntaxToken commaToken, ExpressionSyntax delegateExpression);
    public static AddRemoveHandlerStatementSyntax RemoveHandlerStatement(ExpressionSyntax eventExpression, ExpressionSyntax delegateExpression);
    public static AddRemoveHandlerStatementSyntax AddRemoveHandlerStatement(SyntaxKind kind, SyntaxToken addHandlerOrRemoveHandlerKeyword, ExpressionSyntax eventExpression, SyntaxToken commaToken, ExpressionSyntax delegateExpression);
    private static SyntaxKind GetAddRemoveHandlerStatementAddHandlerOrRemoveHandlerKeywordKind(SyntaxKind kind);
    public static AddRemoveHandlerStatementSyntax AddRemoveHandlerStatement(SyntaxKind kind, SyntaxToken addHandlerOrRemoveHandlerKeyword, ExpressionSyntax eventExpression, ExpressionSyntax delegateExpression);
    public static RaiseEventStatementSyntax RaiseEventStatement(SyntaxToken raiseEventKeyword, IdentifierNameSyntax name, ArgumentListSyntax argumentList);
    public static RaiseEventStatementSyntax RaiseEventStatement(IdentifierNameSyntax name, ArgumentListSyntax argumentList);
    public static RaiseEventStatementSyntax RaiseEventStatement(IdentifierNameSyntax name);
    public static WithStatementSyntax WithStatement(SyntaxToken withKeyword, ExpressionSyntax expression);
    public static WithStatementSyntax WithStatement(ExpressionSyntax expression);
    public static ReDimStatementSyntax ReDimStatement(SyntaxToken reDimKeyword, SyntaxToken preserveKeyword, SeparatedSyntaxList`1<RedimClauseSyntax> clauses);
    public static ReDimStatementSyntax ReDimStatement(SeparatedSyntaxList`1<RedimClauseSyntax> clauses);
    public static ReDimStatementSyntax ReDimStatement(RedimClauseSyntax[] clauses);
    public static ReDimStatementSyntax ReDimPreserveStatement(SyntaxToken reDimKeyword, SyntaxToken preserveKeyword, SeparatedSyntaxList`1<RedimClauseSyntax> clauses);
    public static ReDimStatementSyntax ReDimPreserveStatement(SeparatedSyntaxList`1<RedimClauseSyntax> clauses);
    public static ReDimStatementSyntax ReDimPreserveStatement(RedimClauseSyntax[] clauses);
    public static ReDimStatementSyntax ReDimStatement(SyntaxKind kind, SyntaxToken reDimKeyword, SyntaxToken preserveKeyword, SeparatedSyntaxList`1<RedimClauseSyntax> clauses);
    public static ReDimStatementSyntax ReDimStatement(SyntaxKind kind, SeparatedSyntaxList`1<RedimClauseSyntax> clauses);
    public static ReDimStatementSyntax ReDimStatement(SyntaxKind kind, RedimClauseSyntax[] clauses);
    public static RedimClauseSyntax RedimClause(ExpressionSyntax expression, ArgumentListSyntax arrayBounds);
    public static EraseStatementSyntax EraseStatement(SyntaxToken eraseKeyword, SeparatedSyntaxList`1<ExpressionSyntax> expressions);
    public static EraseStatementSyntax EraseStatement(SeparatedSyntaxList`1<ExpressionSyntax> expressions);
    public static EraseStatementSyntax EraseStatement(ExpressionSyntax[] expressions);
    public static LiteralExpressionSyntax CharacterLiteralExpression(SyntaxToken token);
    public static LiteralExpressionSyntax TrueLiteralExpression(SyntaxToken token);
    public static LiteralExpressionSyntax FalseLiteralExpression(SyntaxToken token);
    public static LiteralExpressionSyntax NumericLiteralExpression(SyntaxToken token);
    public static LiteralExpressionSyntax DateLiteralExpression(SyntaxToken token);
    public static LiteralExpressionSyntax StringLiteralExpression(SyntaxToken token);
    public static LiteralExpressionSyntax NothingLiteralExpression(SyntaxToken token);
    public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token);
    public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public static ParenthesizedExpressionSyntax ParenthesizedExpression(ExpressionSyntax expression);
    public static MeExpressionSyntax MeExpression(SyntaxToken keyword);
    public static MeExpressionSyntax MeExpression();
    public static MyBaseExpressionSyntax MyBaseExpression(SyntaxToken keyword);
    public static MyBaseExpressionSyntax MyBaseExpression();
    public static MyClassExpressionSyntax MyClassExpression(SyntaxToken keyword);
    public static MyClassExpressionSyntax MyClassExpression();
    public static GetTypeExpressionSyntax GetTypeExpression(SyntaxToken getTypeKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken);
    public static GetTypeExpressionSyntax GetTypeExpression(TypeSyntax type);
    public static TypeOfExpressionSyntax TypeOfIsExpression(SyntaxToken typeOfKeyword, ExpressionSyntax expression, SyntaxToken operatorToken, TypeSyntax type);
    public static TypeOfExpressionSyntax TypeOfIsExpression(ExpressionSyntax expression, TypeSyntax type);
    public static TypeOfExpressionSyntax TypeOfIsNotExpression(SyntaxToken typeOfKeyword, ExpressionSyntax expression, SyntaxToken operatorToken, TypeSyntax type);
    public static TypeOfExpressionSyntax TypeOfIsNotExpression(ExpressionSyntax expression, TypeSyntax type);
    public static TypeOfExpressionSyntax TypeOfExpression(SyntaxKind kind, SyntaxToken typeOfKeyword, ExpressionSyntax expression, SyntaxToken operatorToken, TypeSyntax type);
    private static SyntaxKind GetTypeOfExpressionOperatorTokenKind(SyntaxKind kind);
    public static TypeOfExpressionSyntax TypeOfExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, TypeSyntax type);
    public static GetXmlNamespaceExpressionSyntax GetXmlNamespaceExpression(SyntaxToken getXmlNamespaceKeyword, SyntaxToken openParenToken, XmlPrefixNameSyntax name, SyntaxToken closeParenToken);
    public static GetXmlNamespaceExpressionSyntax GetXmlNamespaceExpression();
    public static MemberAccessExpressionSyntax SimpleMemberAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name);
    public static MemberAccessExpressionSyntax SimpleMemberAccessExpression(ExpressionSyntax expression, SimpleNameSyntax name);
    public static MemberAccessExpressionSyntax SimpleMemberAccessExpression(SimpleNameSyntax name);
    public static MemberAccessExpressionSyntax DictionaryAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name);
    public static MemberAccessExpressionSyntax DictionaryAccessExpression(ExpressionSyntax expression, SimpleNameSyntax name);
    public static MemberAccessExpressionSyntax DictionaryAccessExpression(SimpleNameSyntax name);
    public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name);
    private static SyntaxKind GetMemberAccessExpressionOperatorTokenKind(SyntaxKind kind);
    public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, SyntaxToken operatorToken, SimpleNameSyntax name);
    public static XmlMemberAccessExpressionSyntax XmlElementAccessExpression(ExpressionSyntax base, SyntaxToken token1, SyntaxToken token2, SyntaxToken token3, XmlNodeSyntax name);
    public static XmlMemberAccessExpressionSyntax XmlElementAccessExpression(ExpressionSyntax base, SyntaxToken token2, XmlNodeSyntax name);
    public static XmlMemberAccessExpressionSyntax XmlElementAccessExpression(XmlNodeSyntax name);
    public static XmlMemberAccessExpressionSyntax XmlDescendantAccessExpression(ExpressionSyntax base, SyntaxToken token1, SyntaxToken token2, SyntaxToken token3, XmlNodeSyntax name);
    public static XmlMemberAccessExpressionSyntax XmlDescendantAccessExpression(ExpressionSyntax base, SyntaxToken token2, XmlNodeSyntax name);
    public static XmlMemberAccessExpressionSyntax XmlDescendantAccessExpression(XmlNodeSyntax name);
    public static XmlMemberAccessExpressionSyntax XmlAttributeAccessExpression(ExpressionSyntax base, SyntaxToken token1, SyntaxToken token2, SyntaxToken token3, XmlNodeSyntax name);
    public static XmlMemberAccessExpressionSyntax XmlAttributeAccessExpression(ExpressionSyntax base, SyntaxToken token2, XmlNodeSyntax name);
    public static XmlMemberAccessExpressionSyntax XmlAttributeAccessExpression(XmlNodeSyntax name);
    public static XmlMemberAccessExpressionSyntax XmlMemberAccessExpression(SyntaxKind kind, ExpressionSyntax base, SyntaxToken token1, SyntaxToken token2, SyntaxToken token3, XmlNodeSyntax name);
    public static XmlMemberAccessExpressionSyntax XmlMemberAccessExpression(SyntaxKind kind, ExpressionSyntax base, SyntaxToken token2, XmlNodeSyntax name);
    public static XmlMemberAccessExpressionSyntax XmlMemberAccessExpression(SyntaxKind kind, XmlNodeSyntax name);
    public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList);
    public static InvocationExpressionSyntax InvocationExpression();
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, SyntaxList`1<AttributeListSyntax> attributeLists, TypeSyntax type, ArgumentListSyntax argumentList, ObjectCreationInitializerSyntax initializer);
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxList`1<AttributeListSyntax> attributeLists, TypeSyntax type, ArgumentListSyntax argumentList, ObjectCreationInitializerSyntax initializer);
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type);
    public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxList`1<AttributeListSyntax> attributeLists, ObjectMemberInitializerSyntax initializer);
    public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxList`1<AttributeListSyntax> attributeLists, ObjectMemberInitializerSyntax initializer);
    public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(ObjectMemberInitializerSyntax initializer);
    public static ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, SyntaxList`1<AttributeListSyntax> attributeLists, TypeSyntax type, ArgumentListSyntax arrayBounds, SyntaxList`1<ArrayRankSpecifierSyntax> rankSpecifiers, CollectionInitializerSyntax initializer);
    public static ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxList`1<AttributeListSyntax> attributeLists, TypeSyntax type, ArgumentListSyntax arrayBounds, CollectionInitializerSyntax initializer);
    public static ArrayCreationExpressionSyntax ArrayCreationExpression(TypeSyntax type, CollectionInitializerSyntax initializer);
    public static CollectionInitializerSyntax CollectionInitializer(SyntaxToken openBraceToken, SeparatedSyntaxList`1<ExpressionSyntax> initializers, SyntaxToken closeBraceToken);
    public static CollectionInitializerSyntax CollectionInitializer(SeparatedSyntaxList`1<ExpressionSyntax> initializers);
    public static CollectionInitializerSyntax CollectionInitializer();
    public static CTypeExpressionSyntax CTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken commaToken, TypeSyntax type, SyntaxToken closeParenToken);
    public static CTypeExpressionSyntax CTypeExpression(ExpressionSyntax expression, TypeSyntax type);
    public static DirectCastExpressionSyntax DirectCastExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken commaToken, TypeSyntax type, SyntaxToken closeParenToken);
    public static DirectCastExpressionSyntax DirectCastExpression(ExpressionSyntax expression, TypeSyntax type);
    public static TryCastExpressionSyntax TryCastExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken commaToken, TypeSyntax type, SyntaxToken closeParenToken);
    public static TryCastExpressionSyntax TryCastExpression(ExpressionSyntax expression, TypeSyntax type);
    public static PredefinedCastExpressionSyntax PredefinedCastExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken);
    public static PredefinedCastExpressionSyntax PredefinedCastExpression(SyntaxToken keyword, ExpressionSyntax expression);
    public static BinaryExpressionSyntax AddExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax AddExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax SubtractExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax SubtractExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax MultiplyExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax MultiplyExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax DivideExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax DivideExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax IntegerDivideExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax IntegerDivideExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax ExponentiateExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax ExponentiateExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax LeftShiftExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax LeftShiftExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax RightShiftExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax RightShiftExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax ConcatenateExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax ConcatenateExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax ModuloExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax ModuloExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax EqualsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax EqualsExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax NotEqualsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax NotEqualsExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax LessThanExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax LessThanExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax LessThanOrEqualExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax LessThanOrEqualExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax GreaterThanOrEqualExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax GreaterThanOrEqualExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax GreaterThanExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax GreaterThanExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax IsExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax IsExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax IsNotExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax IsNotExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax LikeExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax LikeExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax OrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax OrExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax ExclusiveOrExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax ExclusiveOrExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax AndExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax AndExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax OrElseExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax OrElseExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax AndAlsoExpression(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    public static BinaryExpressionSyntax AndAlsoExpression(ExpressionSyntax left, ExpressionSyntax right);
    public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right);
    private static SyntaxKind GetBinaryExpressionOperatorTokenKind(SyntaxKind kind);
    public static UnaryExpressionSyntax UnaryPlusExpression(SyntaxToken operatorToken, ExpressionSyntax operand);
    public static UnaryExpressionSyntax UnaryPlusExpression(ExpressionSyntax operand);
    public static UnaryExpressionSyntax UnaryMinusExpression(SyntaxToken operatorToken, ExpressionSyntax operand);
    public static UnaryExpressionSyntax UnaryMinusExpression(ExpressionSyntax operand);
    public static UnaryExpressionSyntax NotExpression(SyntaxToken operatorToken, ExpressionSyntax operand);
    public static UnaryExpressionSyntax NotExpression(ExpressionSyntax operand);
    public static UnaryExpressionSyntax AddressOfExpression(SyntaxToken operatorToken, ExpressionSyntax operand);
    public static UnaryExpressionSyntax AddressOfExpression(ExpressionSyntax operand);
    public static UnaryExpressionSyntax UnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand);
    private static SyntaxKind GetUnaryExpressionOperatorTokenKind(SyntaxKind kind);
    public static BinaryConditionalExpressionSyntax BinaryConditionalExpression(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax firstExpression, SyntaxToken commaToken, ExpressionSyntax secondExpression, SyntaxToken closeParenToken);
    public static BinaryConditionalExpressionSyntax BinaryConditionalExpression(ExpressionSyntax firstExpression, ExpressionSyntax secondExpression);
    public static TernaryConditionalExpressionSyntax TernaryConditionalExpression(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken firstCommaToken, ExpressionSyntax whenTrue, SyntaxToken secondCommaToken, ExpressionSyntax whenFalse, SyntaxToken closeParenToken);
    public static TernaryConditionalExpressionSyntax TernaryConditionalExpression(ExpressionSyntax condition, ExpressionSyntax whenTrue, ExpressionSyntax whenFalse);
    public static SingleLineLambdaExpressionSyntax SingleLineFunctionLambdaExpression(LambdaHeaderSyntax subOrFunctionHeader, VisualBasicSyntaxNode body);
    public static SingleLineLambdaExpressionSyntax SingleLineSubLambdaExpression(LambdaHeaderSyntax subOrFunctionHeader, VisualBasicSyntaxNode body);
    public static SingleLineLambdaExpressionSyntax SingleLineLambdaExpression(SyntaxKind kind, LambdaHeaderSyntax subOrFunctionHeader, VisualBasicSyntaxNode body);
    public static MultiLineLambdaExpressionSyntax MultiLineFunctionLambdaExpression(LambdaHeaderSyntax subOrFunctionHeader, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    public static MultiLineLambdaExpressionSyntax MultiLineFunctionLambdaExpression(LambdaHeaderSyntax subOrFunctionHeader, EndBlockStatementSyntax endSubOrFunctionStatement);
    public static MultiLineLambdaExpressionSyntax MultiLineSubLambdaExpression(LambdaHeaderSyntax subOrFunctionHeader, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    public static MultiLineLambdaExpressionSyntax MultiLineSubLambdaExpression(LambdaHeaderSyntax subOrFunctionHeader, EndBlockStatementSyntax endSubOrFunctionStatement);
    public static MultiLineLambdaExpressionSyntax MultiLineLambdaExpression(SyntaxKind kind, LambdaHeaderSyntax subOrFunctionHeader, SyntaxList`1<StatementSyntax> statements, EndBlockStatementSyntax endSubOrFunctionStatement);
    public static MultiLineLambdaExpressionSyntax MultiLineLambdaExpression(SyntaxKind kind, LambdaHeaderSyntax subOrFunctionHeader, EndBlockStatementSyntax endSubOrFunctionStatement);
    public static LambdaHeaderSyntax SubLambdaHeader(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken subOrFunctionKeyword, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public static LambdaHeaderSyntax SubLambdaHeader(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public static LambdaHeaderSyntax SubLambdaHeader();
    public static LambdaHeaderSyntax FunctionLambdaHeader(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken subOrFunctionKeyword, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public static LambdaHeaderSyntax FunctionLambdaHeader(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    public static LambdaHeaderSyntax FunctionLambdaHeader();
    public static LambdaHeaderSyntax LambdaHeader(SyntaxKind kind, SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken subOrFunctionKeyword, ParameterListSyntax parameterList, SimpleAsClauseSyntax asClause);
    private static SyntaxKind GetLambdaHeaderSubOrFunctionKeywordKind(SyntaxKind kind);
    public static LambdaHeaderSyntax LambdaHeader(SyntaxKind kind, SyntaxToken subOrFunctionKeyword);
    public static ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList`1<ArgumentSyntax> arguments, SyntaxToken closeParenToken);
    public static ArgumentListSyntax ArgumentList(SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    public static ArgumentListSyntax ArgumentList();
    public static OmittedArgumentSyntax OmittedArgument(SyntaxToken empty);
    public static OmittedArgumentSyntax OmittedArgument();
    public static SimpleArgumentSyntax SimpleArgument(NameColonEqualsSyntax nameColonEquals, ExpressionSyntax expression);
    public static SimpleArgumentSyntax SimpleArgument(ExpressionSyntax expression);
    public static NameColonEqualsSyntax NameColonEquals(IdentifierNameSyntax name, SyntaxToken colonEqualsToken);
    public static NameColonEqualsSyntax NameColonEquals(IdentifierNameSyntax name);
    public static RangeArgumentSyntax RangeArgument(ExpressionSyntax lowerBound, SyntaxToken toKeyword, ExpressionSyntax upperBound);
    public static RangeArgumentSyntax RangeArgument(ExpressionSyntax lowerBound, ExpressionSyntax upperBound);
    public static QueryExpressionSyntax QueryExpression(SyntaxList`1<QueryClauseSyntax> clauses);
    public static QueryExpressionSyntax QueryExpression(QueryClauseSyntax[] clauses);
    public static CollectionRangeVariableSyntax CollectionRangeVariable(ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, SyntaxToken inKeyword, ExpressionSyntax expression);
    public static CollectionRangeVariableSyntax CollectionRangeVariable(ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, ExpressionSyntax expression);
    public static CollectionRangeVariableSyntax CollectionRangeVariable(ModifiedIdentifierSyntax identifier, ExpressionSyntax expression);
    public static ExpressionRangeVariableSyntax ExpressionRangeVariable(VariableNameEqualsSyntax nameEquals, ExpressionSyntax expression);
    public static ExpressionRangeVariableSyntax ExpressionRangeVariable(ExpressionSyntax expression);
    public static AggregationRangeVariableSyntax AggregationRangeVariable(VariableNameEqualsSyntax nameEquals, AggregationSyntax aggregation);
    public static AggregationRangeVariableSyntax AggregationRangeVariable(AggregationSyntax aggregation);
    public static VariableNameEqualsSyntax VariableNameEquals(ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause, SyntaxToken equalsToken);
    public static VariableNameEqualsSyntax VariableNameEquals(ModifiedIdentifierSyntax identifier, SimpleAsClauseSyntax asClause);
    public static VariableNameEqualsSyntax VariableNameEquals(ModifiedIdentifierSyntax identifier);
    public static FunctionAggregationSyntax FunctionAggregation(SyntaxToken functionName, SyntaxToken openParenToken, ExpressionSyntax argument, SyntaxToken closeParenToken);
    public static FunctionAggregationSyntax FunctionAggregation(SyntaxToken functionName, ExpressionSyntax argument);
    public static FunctionAggregationSyntax FunctionAggregation(SyntaxToken functionName);
    public static FunctionAggregationSyntax FunctionAggregation(string functionName);
    public static GroupAggregationSyntax GroupAggregation(SyntaxToken groupKeyword);
    public static GroupAggregationSyntax GroupAggregation();
    public static FromClauseSyntax FromClause(SyntaxToken fromKeyword, SeparatedSyntaxList`1<CollectionRangeVariableSyntax> variables);
    public static FromClauseSyntax FromClause(SeparatedSyntaxList`1<CollectionRangeVariableSyntax> variables);
    public static FromClauseSyntax FromClause(CollectionRangeVariableSyntax[] variables);
    public static LetClauseSyntax LetClause(SyntaxToken letKeyword, SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> variables);
    public static LetClauseSyntax LetClause(SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> variables);
    public static LetClauseSyntax LetClause(ExpressionRangeVariableSyntax[] variables);
    public static AggregateClauseSyntax AggregateClause(SyntaxToken aggregateKeyword, SeparatedSyntaxList`1<CollectionRangeVariableSyntax> variables, SyntaxList`1<QueryClauseSyntax> additionalQueryOperators, SyntaxToken intoKeyword, SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
    public static AggregateClauseSyntax AggregateClause(SeparatedSyntaxList`1<CollectionRangeVariableSyntax> variables, SyntaxList`1<QueryClauseSyntax> additionalQueryOperators, SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
    public static AggregateClauseSyntax AggregateClause(SeparatedSyntaxList`1<CollectionRangeVariableSyntax> variables, SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
    public static DistinctClauseSyntax DistinctClause(SyntaxToken distinctKeyword);
    public static DistinctClauseSyntax DistinctClause();
    public static WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition);
    public static WhereClauseSyntax WhereClause(ExpressionSyntax condition);
    public static PartitionWhileClauseSyntax SkipWhileClause(SyntaxToken skipOrTakeKeyword, SyntaxToken whileKeyword, ExpressionSyntax condition);
    public static PartitionWhileClauseSyntax SkipWhileClause(ExpressionSyntax condition);
    public static PartitionWhileClauseSyntax TakeWhileClause(SyntaxToken skipOrTakeKeyword, SyntaxToken whileKeyword, ExpressionSyntax condition);
    public static PartitionWhileClauseSyntax TakeWhileClause(ExpressionSyntax condition);
    public static PartitionWhileClauseSyntax PartitionWhileClause(SyntaxKind kind, SyntaxToken skipOrTakeKeyword, SyntaxToken whileKeyword, ExpressionSyntax condition);
    private static SyntaxKind GetPartitionWhileClauseSkipOrTakeKeywordKind(SyntaxKind kind);
    public static PartitionWhileClauseSyntax PartitionWhileClause(SyntaxKind kind, SyntaxToken skipOrTakeKeyword, ExpressionSyntax condition);
    public static PartitionClauseSyntax SkipClause(SyntaxToken skipOrTakeKeyword, ExpressionSyntax count);
    public static PartitionClauseSyntax SkipClause(ExpressionSyntax count);
    public static PartitionClauseSyntax TakeClause(SyntaxToken skipOrTakeKeyword, ExpressionSyntax count);
    public static PartitionClauseSyntax TakeClause(ExpressionSyntax count);
    public static PartitionClauseSyntax PartitionClause(SyntaxKind kind, SyntaxToken skipOrTakeKeyword, ExpressionSyntax count);
    private static SyntaxKind GetPartitionClauseSkipOrTakeKeywordKind(SyntaxKind kind);
    public static GroupByClauseSyntax GroupByClause(SyntaxToken groupKeyword, SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> items, SyntaxToken byKeyword, SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> keys, SyntaxToken intoKeyword, SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
    public static GroupByClauseSyntax GroupByClause(SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> items, SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> keys, SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
    public static GroupByClauseSyntax GroupByClause(SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> keys, SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
    public static JoinConditionSyntax JoinCondition(ExpressionSyntax left, SyntaxToken equalsKeyword, ExpressionSyntax right);
    public static JoinConditionSyntax JoinCondition(ExpressionSyntax left, ExpressionSyntax right);
    public static SimpleJoinClauseSyntax SimpleJoinClause(SyntaxToken joinKeyword, SeparatedSyntaxList`1<CollectionRangeVariableSyntax> joinedVariables, SyntaxList`1<JoinClauseSyntax> additionalJoins, SyntaxToken onKeyword, SeparatedSyntaxList`1<JoinConditionSyntax> joinConditions);
    public static SimpleJoinClauseSyntax SimpleJoinClause(SeparatedSyntaxList`1<CollectionRangeVariableSyntax> joinedVariables, SyntaxList`1<JoinClauseSyntax> additionalJoins, SeparatedSyntaxList`1<JoinConditionSyntax> joinConditions);
    public static SimpleJoinClauseSyntax SimpleJoinClause(SeparatedSyntaxList`1<CollectionRangeVariableSyntax> joinedVariables, SeparatedSyntaxList`1<JoinConditionSyntax> joinConditions);
    public static GroupJoinClauseSyntax GroupJoinClause(SyntaxToken groupKeyword, SyntaxToken joinKeyword, SeparatedSyntaxList`1<CollectionRangeVariableSyntax> joinedVariables, SyntaxList`1<JoinClauseSyntax> additionalJoins, SyntaxToken onKeyword, SeparatedSyntaxList`1<JoinConditionSyntax> joinConditions, SyntaxToken intoKeyword, SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
    public static GroupJoinClauseSyntax GroupJoinClause(SeparatedSyntaxList`1<CollectionRangeVariableSyntax> joinedVariables, SyntaxList`1<JoinClauseSyntax> additionalJoins, SeparatedSyntaxList`1<JoinConditionSyntax> joinConditions, SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
    public static GroupJoinClauseSyntax GroupJoinClause(SeparatedSyntaxList`1<CollectionRangeVariableSyntax> joinedVariables, SeparatedSyntaxList`1<JoinConditionSyntax> joinConditions, SeparatedSyntaxList`1<AggregationRangeVariableSyntax> aggregationVariables);
    public static OrderByClauseSyntax OrderByClause(SyntaxToken orderKeyword, SyntaxToken byKeyword, SeparatedSyntaxList`1<OrderingSyntax> orderings);
    public static OrderByClauseSyntax OrderByClause(SeparatedSyntaxList`1<OrderingSyntax> orderings);
    public static OrderByClauseSyntax OrderByClause(OrderingSyntax[] orderings);
    public static OrderingSyntax AscendingOrdering(ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword);
    public static OrderingSyntax AscendingOrdering(ExpressionSyntax expression);
    public static OrderingSyntax DescendingOrdering(ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword);
    public static OrderingSyntax DescendingOrdering(ExpressionSyntax expression);
    public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword);
    private static SyntaxKind GetOrderingAscendingOrDescendingKeywordKind(SyntaxKind kind);
    public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression);
    public static SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> variables);
    public static SelectClauseSyntax SelectClause(SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> variables);
    public static SelectClauseSyntax SelectClause(ExpressionRangeVariableSyntax[] variables);
    public static XmlDocumentSyntax XmlDocument(XmlDeclarationSyntax declaration, SyntaxList`1<XmlNodeSyntax> precedingMisc, XmlNodeSyntax root, SyntaxList`1<XmlNodeSyntax> followingMisc);
    public static XmlDocumentSyntax XmlDocument(XmlDeclarationSyntax declaration, XmlNodeSyntax root);
    public static XmlDeclarationSyntax XmlDeclaration(SyntaxToken lessThanQuestionToken, SyntaxToken xmlKeyword, XmlDeclarationOptionSyntax version, XmlDeclarationOptionSyntax encoding, XmlDeclarationOptionSyntax standalone, SyntaxToken questionGreaterThanToken);
    public static XmlDeclarationSyntax XmlDeclaration(XmlDeclarationOptionSyntax version, XmlDeclarationOptionSyntax encoding, XmlDeclarationOptionSyntax standalone);
    public static XmlDeclarationSyntax XmlDeclaration(XmlDeclarationOptionSyntax version);
    public static XmlDeclarationOptionSyntax XmlDeclarationOption(SyntaxToken name, SyntaxToken equals, XmlStringSyntax value);
    public static XmlDeclarationOptionSyntax XmlDeclarationOption(XmlStringSyntax value);
    public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, SyntaxList`1<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag);
    public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, XmlElementEndTagSyntax endTag);
    public static XmlTextSyntax XmlText(SyntaxTokenList textTokens);
    public static XmlTextSyntax XmlText();
    public static XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNodeSyntax name, SyntaxList`1<XmlNodeSyntax> attributes, SyntaxToken greaterThanToken);
    public static XmlElementStartTagSyntax XmlElementStartTag(XmlNodeSyntax name, SyntaxList`1<XmlNodeSyntax> attributes);
    public static XmlElementStartTagSyntax XmlElementStartTag(XmlNodeSyntax name);
    public static XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken);
    public static XmlElementEndTagSyntax XmlElementEndTag(XmlNameSyntax name);
    public static XmlElementEndTagSyntax XmlElementEndTag();
    public static XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNodeSyntax name, SyntaxList`1<XmlNodeSyntax> attributes, SyntaxToken slashGreaterThanToken);
    public static XmlEmptyElementSyntax XmlEmptyElement(XmlNodeSyntax name, SyntaxList`1<XmlNodeSyntax> attributes);
    public static XmlEmptyElementSyntax XmlEmptyElement(XmlNodeSyntax name);
    public static XmlAttributeSyntax XmlAttribute(XmlNodeSyntax name, SyntaxToken equalsToken, XmlNodeSyntax value);
    public static XmlAttributeSyntax XmlAttribute(XmlNodeSyntax name, XmlNodeSyntax value);
    public static XmlStringSyntax XmlString(SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken);
    public static XmlStringSyntax XmlString(SyntaxToken startQuoteToken, SyntaxToken endQuoteToken);
    public static XmlPrefixNameSyntax XmlPrefixName(SyntaxToken name);
    public static XmlPrefixNameSyntax XmlPrefixName();
    public static XmlNameSyntax XmlName(XmlPrefixSyntax prefix, SyntaxToken localName);
    public static XmlNameSyntax XmlName();
    public static XmlBracketedNameSyntax XmlBracketedName(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxToken greaterThanToken);
    public static XmlBracketedNameSyntax XmlBracketedName(XmlNameSyntax name);
    public static XmlPrefixSyntax XmlPrefix(SyntaxToken name, SyntaxToken colonToken);
    public static XmlPrefixSyntax XmlPrefix();
    public static XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken);
    public static XmlCommentSyntax XmlComment();
    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken lessThanQuestionToken, SyntaxToken name, SyntaxTokenList textTokens, SyntaxToken questionGreaterThanToken);
    public static XmlProcessingInstructionSyntax XmlProcessingInstruction();
    public static XmlCDataSectionSyntax XmlCDataSection(SyntaxToken beginCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken);
    public static XmlCDataSectionSyntax XmlCDataSection();
    public static XmlEmbeddedExpressionSyntax XmlEmbeddedExpression(SyntaxToken lessThanPercentEqualsToken, ExpressionSyntax expression, SyntaxToken percentGreaterThanToken);
    public static XmlEmbeddedExpressionSyntax XmlEmbeddedExpression(ExpressionSyntax expression);
    public static ArrayTypeSyntax ArrayType(TypeSyntax elementType, SyntaxList`1<ArrayRankSpecifierSyntax> rankSpecifiers);
    public static ArrayTypeSyntax ArrayType(TypeSyntax elementType);
    public static NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionMarkToken);
    public static NullableTypeSyntax NullableType(TypeSyntax elementType);
    public static PredefinedTypeSyntax PredefinedType(SyntaxToken keyword);
    public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier);
    public static IdentifierNameSyntax IdentifierName(string identifier);
    public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList);
    public static GenericNameSyntax GenericName(string identifier, TypeArgumentListSyntax typeArgumentList);
    public static QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right);
    public static QualifiedNameSyntax QualifiedName(NameSyntax left, SimpleNameSyntax right);
    public static GlobalNameSyntax GlobalName(SyntaxToken globalKeyword);
    public static GlobalNameSyntax GlobalName();
    public static TypeArgumentListSyntax TypeArgumentList(SyntaxToken openParenToken, SyntaxToken ofKeyword, SeparatedSyntaxList`1<TypeSyntax> arguments, SyntaxToken closeParenToken);
    public static TypeArgumentListSyntax TypeArgumentList(SeparatedSyntaxList`1<TypeSyntax> arguments);
    public static TypeArgumentListSyntax TypeArgumentList(TypeSyntax[] arguments);
    public static CrefReferenceSyntax CrefReference(TypeSyntax name, CrefSignatureSyntax signature, SimpleAsClauseSyntax asClause);
    public static CrefReferenceSyntax CrefReference(TypeSyntax name);
    public static CrefSignatureSyntax CrefSignature(SyntaxToken openParenToken, SeparatedSyntaxList`1<CrefSignaturePartSyntax> argumentTypes, SyntaxToken closeParenToken);
    public static CrefSignatureSyntax CrefSignature(SeparatedSyntaxList`1<CrefSignaturePartSyntax> argumentTypes);
    public static CrefSignatureSyntax CrefSignature(CrefSignaturePartSyntax[] argumentTypes);
    public static CrefSignaturePartSyntax CrefSignaturePart(SyntaxToken modifier, TypeSyntax type);
    public static CrefSignaturePartSyntax CrefSignaturePart();
    public static CrefOperatorReferenceSyntax CrefOperatorReference(SyntaxToken operatorKeyword, SyntaxToken operatorToken);
    public static CrefOperatorReferenceSyntax CrefOperatorReference(SyntaxToken operatorToken);
    public static QualifiedCrefOperatorReferenceSyntax QualifiedCrefOperatorReference(NameSyntax left, SyntaxToken dotToken, CrefOperatorReferenceSyntax right);
    public static QualifiedCrefOperatorReferenceSyntax QualifiedCrefOperatorReference(NameSyntax left, CrefOperatorReferenceSyntax right);
    public static YieldStatementSyntax YieldStatement(SyntaxToken yieldKeyword, ExpressionSyntax expression);
    public static YieldStatementSyntax YieldStatement(ExpressionSyntax expression);
    public static AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, ExpressionSyntax expression);
    public static AwaitExpressionSyntax AwaitExpression(ExpressionSyntax expression);
    public static SyntaxToken XmlNameToken(SyntaxTriviaList leadingTrivia, string text, SyntaxKind possibleKeywordKind, SyntaxTriviaList trailingTrivia);
    public static SyntaxToken XmlNameToken(string text, SyntaxKind possibleKeywordKind);
    public static SyntaxToken XmlTextLiteralToken(SyntaxTriviaList leadingTrivia, string text, string value, SyntaxTriviaList trailingTrivia);
    public static SyntaxToken XmlTextLiteralToken(string text, string value);
    public static SyntaxToken XmlEntityLiteralToken(SyntaxTriviaList leadingTrivia, string text, string value, SyntaxTriviaList trailingTrivia);
    public static SyntaxToken XmlEntityLiteralToken(string text, string value);
    public static SyntaxToken DocumentationCommentLineBreakToken(SyntaxTriviaList leadingTrivia, string text, string value, SyntaxTriviaList trailingTrivia);
    public static SyntaxToken DocumentationCommentLineBreakToken(string text, string value);
    public static SyntaxToken XmlTextToken(SyntaxTriviaList leadingTrivia, SyntaxKind kind, string text, string value, SyntaxTriviaList trailingTrivia);
    public static SyntaxToken XmlTextToken(SyntaxKind kind, string text, string value);
    public static SyntaxToken InterpolatedStringTextToken(SyntaxTriviaList leadingTrivia, string text, string value, SyntaxTriviaList trailingTrivia);
    public static SyntaxToken InterpolatedStringTextToken(string text, string value);
    public static SyntaxToken DecimalLiteralToken(SyntaxTriviaList leadingTrivia, string text, TypeCharacter typeSuffix, decimal value, SyntaxTriviaList trailingTrivia);
    public static SyntaxToken DecimalLiteralToken(string text, TypeCharacter typeSuffix, decimal value);
    public static SyntaxToken DateLiteralToken(SyntaxTriviaList leadingTrivia, string text, DateTime value, SyntaxTriviaList trailingTrivia);
    public static SyntaxToken DateLiteralToken(string text, DateTime value);
    public static SyntaxToken StringLiteralToken(SyntaxTriviaList leadingTrivia, string text, string value, SyntaxTriviaList trailingTrivia);
    public static SyntaxToken StringLiteralToken(string text, string value);
    public static SyntaxToken CharacterLiteralToken(SyntaxTriviaList leadingTrivia, string text, char value, SyntaxTriviaList trailingTrivia);
    public static SyntaxToken CharacterLiteralToken(string text, char value);
    public static SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxTokenList tokens);
    public static SkippedTokensTriviaSyntax SkippedTokensTrivia();
    public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxList`1<XmlNodeSyntax> content);
    public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia();
    public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefReferenceSyntax reference, SyntaxToken endQuoteToken);
    public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, CrefReferenceSyntax reference, SyntaxToken endQuoteToken);
    public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax reference, SyntaxToken endQuoteToken);
    public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, IdentifierNameSyntax reference, SyntaxToken endQuoteToken);
    public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, SyntaxToken questionMarkToken, ExpressionSyntax whenNotNull);
    public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, ExpressionSyntax whenNotNull);
    public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax whenNotNull);
    public static NameOfExpressionSyntax NameOfExpression(SyntaxToken nameOfKeyword, SyntaxToken openParenToken, ExpressionSyntax argument, SyntaxToken closeParenToken);
    public static NameOfExpressionSyntax NameOfExpression(ExpressionSyntax argument);
    public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken dollarSignDoubleQuoteToken, SyntaxList`1<InterpolatedStringContentSyntax> contents, SyntaxToken doubleQuoteToken);
    public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxList`1<InterpolatedStringContentSyntax> contents);
    public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(InterpolatedStringContentSyntax[] contents);
    public static InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken);
    public static InterpolatedStringTextSyntax InterpolatedStringText();
    public static InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken);
    public static InterpolationSyntax Interpolation(ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause);
    public static InterpolationSyntax Interpolation(ExpressionSyntax expression);
    public static InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExpressionSyntax value);
    public static InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(ExpressionSyntax value);
    public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken);
    public static InterpolationFormatClauseSyntax InterpolationFormatClause();
    public static SyntaxTrivia WhitespaceTrivia(string text);
    public static SyntaxTrivia EndOfLineTrivia(string text);
    public static SyntaxTrivia ColonTrivia(string text);
    public static SyntaxTrivia CommentTrivia(string text);
    public static SyntaxTrivia LineContinuationTrivia(string text);
    public static SyntaxTrivia DocumentationCommentExteriorTrivia(string text);
    public static SyntaxTrivia DisabledTextTrivia(string text);
    public static SyntaxTrivia SyntaxTrivia(SyntaxKind kind, string text);
    public static ConstDirectiveTriviaSyntax ConstDirectiveTrivia(SyntaxToken hashToken, SyntaxToken constKeyword, SyntaxToken name, SyntaxToken equalsToken, ExpressionSyntax value);
    public static ConstDirectiveTriviaSyntax ConstDirectiveTrivia(SyntaxToken name, ExpressionSyntax value);
    public static ConstDirectiveTriviaSyntax ConstDirectiveTrivia(string name, ExpressionSyntax value);
    public static IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken ifOrElseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword);
    public static IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken ifOrElseIfKeyword, ExpressionSyntax condition);
    public static IfDirectiveTriviaSyntax ElseIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken ifOrElseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword);
    public static IfDirectiveTriviaSyntax ElseIfDirectiveTrivia(SyntaxToken ifOrElseIfKeyword, ExpressionSyntax condition);
    public static IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken ifOrElseIfKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword);
    public static IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxKind kind, SyntaxToken ifOrElseIfKeyword, ExpressionSyntax condition);
    public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword);
    public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia();
    public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endKeyword, SyntaxToken ifKeyword);
    public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia();
    public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken name);
    public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia();
    public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endKeyword, SyntaxToken regionKeyword);
    public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia();
    public static ExternalSourceDirectiveTriviaSyntax ExternalSourceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken externalSourceKeyword, SyntaxToken openParenToken, SyntaxToken externalSource, SyntaxToken commaToken, SyntaxToken lineStart, SyntaxToken closeParenToken);
    public static ExternalSourceDirectiveTriviaSyntax ExternalSourceDirectiveTrivia();
    public static EndExternalSourceDirectiveTriviaSyntax EndExternalSourceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endKeyword, SyntaxToken externalSourceKeyword);
    public static EndExternalSourceDirectiveTriviaSyntax EndExternalSourceDirectiveTrivia();
    public static ExternalChecksumDirectiveTriviaSyntax ExternalChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken externalChecksumKeyword, SyntaxToken openParenToken, SyntaxToken externalSource, SyntaxToken firstCommaToken, SyntaxToken guid, SyntaxToken secondCommaToken, SyntaxToken checksum, SyntaxToken closeParenToken);
    public static ExternalChecksumDirectiveTriviaSyntax ExternalChecksumDirectiveTrivia();
    public static EnableWarningDirectiveTriviaSyntax EnableWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken enableKeyword, SyntaxToken warningKeyword, SeparatedSyntaxList`1<IdentifierNameSyntax> errorCodes);
    public static EnableWarningDirectiveTriviaSyntax EnableWarningDirectiveTrivia(SeparatedSyntaxList`1<IdentifierNameSyntax> errorCodes);
    public static EnableWarningDirectiveTriviaSyntax EnableWarningDirectiveTrivia(IdentifierNameSyntax[] errorCodes);
    public static DisableWarningDirectiveTriviaSyntax DisableWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken disableKeyword, SyntaxToken warningKeyword, SeparatedSyntaxList`1<IdentifierNameSyntax> errorCodes);
    public static DisableWarningDirectiveTriviaSyntax DisableWarningDirectiveTrivia(SeparatedSyntaxList`1<IdentifierNameSyntax> errorCodes);
    public static DisableWarningDirectiveTriviaSyntax DisableWarningDirectiveTrivia(IdentifierNameSyntax[] errorCodes);
    public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file);
    public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia();
    public static BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken);
    public static BadDirectiveTriviaSyntax BadDirectiveTrivia();
}
public class Microsoft.CodeAnalysis.VisualBasic.SyntaxFacts : object {
    private static int s_fullwidth;
    internal static char CHARACTER_TABULATION;
    internal static char LINE_FEED;
    internal static char CARRIAGE_RETURN;
    internal static char SPACE;
    internal static char NO_BREAK_SPACE;
    internal static char IDEOGRAPHIC_SPACE;
    internal static char LINE_SEPARATOR;
    internal static char PARAGRAPH_SEPARATOR;
    internal static char NEXT_LINE;
    internal static char LEFT_SINGLE_QUOTATION_MARK;
    internal static char RIGHT_SINGLE_QUOTATION_MARK;
    internal static char LEFT_DOUBLE_QUOTATION_MARK;
    internal static char RIGHT_DOUBLE_QUOTATION_MARK;
    internal static char FULLWIDTH_APOSTROPHE;
    internal static char FULLWIDTH_QUOTATION_MARK;
    internal static char FULLWIDTH_DIGIT_ZERO;
    internal static char FULLWIDTH_DIGIT_SEVEN;
    internal static char FULLWIDTH_DIGIT_NINE;
    internal static char FULLWIDTH_LOW_LINE;
    internal static char FULLWIDTH_COLON;
    internal static char FULLWIDTH_SOLIDUS;
    internal static char FULLWIDTH_HYPHEN_MINUS;
    internal static char FULLWIDTH_PLUS_SIGN;
    internal static char FULLWIDTH_NUMBER_SIGN;
    internal static char FULLWIDTH_EQUALS_SIGN;
    internal static char FULLWIDTH_LESS_THAN_SIGN;
    internal static char FULLWIDTH_GREATER_THAN_SIGN;
    internal static char FULLWIDTH_LEFT_PARENTHESIS;
    internal static char FULLWIDTH_LEFT_SQUARE_BRACKET;
    internal static char FULLWIDTH_RIGHT_SQUARE_BRACKET;
    internal static char FULLWIDTH_LEFT_CURLY_BRACKET;
    internal static char FULLWIDTH_RIGHT_CURLY_BRACKET;
    internal static char FULLWIDTH_AMPERSAND;
    internal static char FULLWIDTH_DOLLAR_SIGN;
    internal static char FULLWIDTH_QUESTION_MARK;
    internal static char FULLWIDTH_FULL_STOP;
    internal static char FULLWIDTH_COMMA;
    internal static char FULLWIDTH_PERCENT_SIGN;
    internal static char FULLWIDTH_LATIN_CAPITAL_LETTER_H;
    internal static char FULLWIDTH_LATIN_CAPITAL_LETTER_O;
    internal static char FULLWIDTH_LATIN_CAPITAL_LETTER_E;
    internal static char FULLWIDTH_LATIN_CAPITAL_LETTER_A;
    internal static char FULLWIDTH_LATIN_CAPITAL_LETTER_F;
    internal static char FULLWIDTH_LATIN_CAPITAL_LETTER_C;
    internal static char FULLWIDTH_LATIN_CAPITAL_LETTER_P;
    internal static char FULLWIDTH_LATIN_CAPITAL_LETTER_M;
    internal static char FULLWIDTH_LATIN_SMALL_LETTER_H;
    internal static char FULLWIDTH_LATIN_SMALL_LETTER_O;
    internal static char FULLWIDTH_LATIN_SMALL_LETTER_E;
    internal static char FULLWIDTH_LATIN_SMALL_LETTER_A;
    internal static char FULLWIDTH_LATIN_SMALL_LETTER_F;
    internal static char FULLWIDTH_LATIN_SMALL_LETTER_C;
    internal static char FULLWIDTH_LATIN_SMALL_LETTER_P;
    internal static char FULLWIDTH_LATIN_SMALL_LETTER_M;
    internal static string FULLWIDTH_LEFT_PARENTHESIS_STRING;
    internal static string FULLWIDTH_RIGHT_PARENTHESIS_STRING;
    internal static string FULLWIDTH_LEFT_CURLY_BRACKET_STRING;
    internal static string FULLWIDTH_RIGHT_CURLY_BRACKET_STRING;
    internal static string FULLWIDTH_FULL_STOP_STRING;
    internal static string FULLWIDTH_COMMA_STRING;
    internal static string FULLWIDTH_EQUALS_SIGN_STRING;
    internal static string FULLWIDTH_PLUS_SIGN_STRING;
    internal static string FULLWIDTH_HYPHEN_MINUS_STRING;
    internal static string FULLWIDTH_ASTERISK_STRING;
    internal static string FULLWIDTH_SOLIDUS_STRING;
    internal static string FULLWIDTH_REVERSE_SOLIDUS_STRING;
    internal static string FULLWIDTH_COLON_STRING;
    internal static string FULLWIDTH_CIRCUMFLEX_ACCENT_STRING;
    internal static string FULLWIDTH_AMPERSAND_STRING;
    internal static string FULLWIDTH_NUMBER_SIGN_STRING;
    internal static string FULLWIDTH_EXCLAMATION_MARK_STRING;
    internal static string FULLWIDTH_QUESTION_MARK_STRING;
    internal static string FULLWIDTH_COMMERCIAL_AT_STRING;
    internal static string FULLWIDTH_LESS_THAN_SIGN_STRING;
    internal static string FULLWIDTH_GREATER_THAN_SIGN_STRING;
    private static Boolean[] s_isIDChar;
    internal static Int32[] DaysToMonth365;
    internal static Int32[] DaysToMonth366;
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<SyntaxKind> _EqualityComparer;
    private static SyntaxKind[] s_reservedKeywords;
    private static SyntaxKind[] s_contextualKeywords;
    private static SyntaxKind[] s_punctuationKinds;
    private static SyntaxKind[] s_preprocessorKeywords;
    private static Dictionary`2<string, SyntaxKind> s_contextualKeywordToSyntaxKindMap;
    private static Dictionary`2<string, SyntaxKind> s_preprocessorKeywordToSyntaxKindMap;
    public static IEqualityComparer`1<SyntaxKind> EqualityComparer { get; }
    private static SyntaxFacts();
    internal static char MakeFullWidth(char c);
    internal static bool IsHalfWidth(char c);
    internal static char MakeHalfWidth(char c);
    internal static bool IsFullWidth(char c);
    public static bool IsWhitespace(char c);
    public static bool IsXmlWhitespace(char c);
    internal static bool IsWhitespaceNotAscii(char ch);
    public static bool IsNewLine(char c);
    internal static bool IsSingleQuote(char c);
    internal static bool IsDoubleQuote(char c);
    internal static bool IsLeftCurlyBracket(char c);
    internal static bool IsRightCurlyBracket(char c);
    public static bool IsColon(char c);
    public static bool IsUnderscore(char c);
    public static bool IsHash(char c);
    public static bool IsIdentifierStartCharacter(char c);
    internal static byte IntegralLiteralCharacterValue(char Digit);
    internal static bool BeginsBaseLiteral(char c);
    internal static bool IsNarrowIdentifierCharacter(ushort c);
    public static bool IsIdentifierPartCharacter(char c);
    public static bool IsValidIdentifier(string name);
    public static string MakeHalfWidthIdentifier(string text);
    internal static bool IsWideIdentifierCharacter(char c);
    internal static bool BeginsExponent(char c);
    internal static bool IsOctalDigit(char c);
    internal static bool IsDecimalDigit(char c);
    internal static bool IsHexDigit(char c);
    internal static bool IsDateSeparatorCharacter(char c);
    internal static bool IsLetterC(char ch);
    internal static bool MatchOneOrAnother(char ch, char one, char another);
    internal static bool MatchOneOrAnotherOrFullwidth(char ch, char one, char another);
    internal static bool IsPropAlpha(UnicodeCategory CharacterProperties);
    internal static bool IsPropAlphaNumeric(UnicodeCategory CharacterProperties);
    internal static bool IsPropLetterDigit(UnicodeCategory CharacterProperties);
    internal static bool IsPropConnectorPunctuation(UnicodeCategory CharacterProperties);
    internal static bool IsPropCombining(UnicodeCategory CharacterProperties);
    internal static bool IsConnectorPunctuation(char c);
    internal static bool IsSpaceSeparator(char c);
    internal static bool IsPropOtherFormat(UnicodeCategory CharacterProperties);
    internal static bool IsSurrogate(char c);
    internal static bool IsHighSurrogate(char c);
    internal static bool IsLowSurrogate(char c);
    internal static char ReturnFullWidthOrSelf(char c);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use IsAccessorStatementAccessorKeyword instead.", "True")]
public static bool IsAccessorStatementKeyword(SyntaxKind kind);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use IsDeclareStatementSubOrFunctionKeyword instead.", "True")]
public static bool IsDeclareStatementKeyword(SyntaxKind kind);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use IsDelegateStatementSubOrFunctionKeyword instead.", "True")]
public static bool IsDelegateStatementKeyword(SyntaxKind kind);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use IsLambdaHeaderSubOrFunctionKeyword instead.", "True")]
public static bool IsLambdaHeaderKeyword(SyntaxKind kind);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This member is obsolete. Use IsMethodStatementSubOrFunctionKeyword instead.", "True")]
public static bool IsMethodStatementKeyword(SyntaxKind kind);
    public static bool IsTrivia(SyntaxKind this);
    public static IEnumerable`1<SyntaxKind> GetKeywordKinds();
    public static bool IsPredefinedType(SyntaxKind kind);
    internal static bool IsPredefinedTypeOrVariant(SyntaxKind kind);
    public static bool IsInvoked(ExpressionSyntax node);
    public static bool IsAddressOfOperand(ExpressionSyntax node);
    public static bool IsInvocationOrAddressOfOperand(ExpressionSyntax node);
    public static bool IsInTypeOnlyContext(ExpressionSyntax node);
    internal static bool IsImplementedMember(SyntaxNode node);
    internal static bool IsHandlesEvent(SyntaxNode node);
    internal static bool IsHandlesContainer(SyntaxNode node);
    internal static bool IsHandlesProperty(SyntaxNode node);
    public static bool IsInNamespaceOrTypeContext(SyntaxNode node);
    private static bool InOrBeforeSpanOrEffectiveTrailingOfNode(SyntaxNode node, int position);
    internal static bool InSpanOrEffectiveTrailingOfNode(SyntaxNode node, int position);
    internal static bool InBlockInterior(SyntaxNode possibleBlock, int position);
    internal static bool InLambdaInterior(SyntaxNode possibleLambda, int position);
    internal static bool InBlockInterior(SyntaxNode possibleBlock, int position, SyntaxList`1& body);
    internal static bool IsBlockStatement(SyntaxNode possibleBlock, StatementSyntax& beginStatement, SyntaxToken& beginTerminator, SyntaxList`1& body, StatementSyntax& endStatement);
    internal static SyntaxNode BeginOfBlockStatementIfAny(SyntaxNode node);
    public static string GetText(Accessibility accessibility);
    public static bool IsAnyToken(SyntaxKind kind);
    public static SyntaxKind GetUnaryExpression(SyntaxKind token);
    public static bool IsPreprocessorPunctuation(SyntaxKind kind);
    public static bool IsLanguagePunctuation(SyntaxKind kind);
    public static bool IsName(SyntaxKind kind);
    public static bool IsNamespaceMemberDeclaration(SyntaxKind kind);
    public static bool IsPunctuationOrKeyword(SyntaxKind kind);
    public static VarianceKind VarianceKindFromToken(SyntaxToken token);
    public static bool IsAttributeName(SyntaxNode node);
    public static bool IsNamedArgumentName(SyntaxNode node);
    public static string GetBlockName(SyntaxKind kind);
    public static bool AllowsTrailingImplicitLineContinuation(SyntaxToken token);
    public static bool AllowsLeadingImplicitLineContinuation(SyntaxToken token);
    public static SyntaxKind GetOperatorKind(string operatorMetadataName);
    public static bool IsAccessibilityModifier(SyntaxKind kind);
    internal static bool IsTerminator(SyntaxKind kind);
    internal static bool IsWithinPreprocessorConditionalExpression(SyntaxNode node);
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<SyntaxKind> get_EqualityComparer();
    public static bool IsReservedKeyword(SyntaxKind kind);
    public static bool IsContextualKeyword(SyntaxKind kind);
    public static bool IsInstanceExpression(SyntaxKind kind);
    public static SyntaxKind GetInstanceExpression(SyntaxKind kind);
    public static bool IsPreprocessorKeyword(SyntaxKind kind);
    public static IEnumerable`1<SyntaxKind> GetReservedKeywordKinds();
    public static IEnumerable`1<SyntaxKind> GetContextualKeywordKinds();
    public static IEnumerable`1<SyntaxKind> GetPunctuationKinds();
    public static IEnumerable`1<SyntaxKind> GetPreprocessorKeywordKinds();
    internal static bool IsSpecifier(SyntaxKind kind);
    internal static bool CanStartSpecifierDeclaration(SyntaxKind kind);
    public static bool IsRelationalOperator(SyntaxKind kind);
    public static bool IsOperator(SyntaxKind kind);
    public static bool IsPreprocessorDirective(SyntaxKind kind);
    internal static bool SupportsContinueStatement(SyntaxKind kind);
    internal static bool SupportsExitStatement(SyntaxKind kind);
    internal static bool IsEndBlockLoopOrNextStatement(SyntaxKind kind);
    internal static bool IsXmlSyntax(SyntaxKind kind);
    public static SyntaxKind GetKeywordKind(string text);
    public static SyntaxKind GetAccessorStatementKind(SyntaxKind keyword);
    public static SyntaxKind GetBaseTypeStatementKind(SyntaxKind keyword);
    public static SyntaxKind GetTypeStatementKind(SyntaxKind keyword);
    public static SyntaxKind GetBinaryExpression(SyntaxKind keyword);
    public static SyntaxKind GetContextualKeywordKind(string text);
    public static SyntaxKind GetPreprocessorKeywordKind(string text);
    public static SyntaxKind GetLiteralExpression(SyntaxKind token);
    public static bool IsEndBlockStatement(SyntaxKind kind);
    public static bool IsEndBlockStatementBlockKeyword(SyntaxKind kind);
    public static bool IsOptionStatementNameKeyword(SyntaxKind kind);
    public static bool IsOptionStatementValueKeyword(SyntaxKind kind);
    public static bool IsTypeParameterVarianceKeyword(SyntaxKind kind);
    public static bool IsSpecialConstraint(SyntaxKind kind);
    public static bool IsSpecialConstraintConstraintKeyword(SyntaxKind kind);
    public static bool IsMethodBlock(SyntaxKind kind);
    public static bool IsAccessorBlock(SyntaxKind kind);
    public static bool IsMethodStatement(SyntaxKind kind);
    public static bool IsMethodStatementSubOrFunctionKeyword(SyntaxKind kind);
    public static bool IsDeclareStatement(SyntaxKind kind);
    public static bool IsDeclareStatementCharsetKeyword(SyntaxKind kind);
    public static bool IsDeclareStatementSubOrFunctionKeyword(SyntaxKind kind);
    public static bool IsDelegateStatement(SyntaxKind kind);
    public static bool IsDelegateStatementSubOrFunctionKeyword(SyntaxKind kind);
    public static bool IsOperatorStatementOperatorToken(SyntaxKind kind);
    public static bool IsAccessorStatement(SyntaxKind kind);
    public static bool IsAccessorStatementAccessorKeyword(SyntaxKind kind);
    public static bool IsKeywordEventContainerKeyword(SyntaxKind kind);
    public static bool IsAttributeTargetAttributeModifier(SyntaxKind kind);
    public static bool IsLabelStatementLabelToken(SyntaxKind kind);
    public static bool IsLabel(SyntaxKind kind);
    public static bool IsLabelLabelToken(SyntaxKind kind);
    public static bool IsStopOrEndStatement(SyntaxKind kind);
    public static bool IsStopOrEndStatementStopOrEndKeyword(SyntaxKind kind);
    public static bool IsExitStatement(SyntaxKind kind);
    public static bool IsExitStatementBlockKeyword(SyntaxKind kind);
    public static bool IsContinueStatement(SyntaxKind kind);
    public static bool IsContinueStatementBlockKeyword(SyntaxKind kind);
    public static bool IsOnErrorGoToStatement(SyntaxKind kind);
    public static bool IsResumeStatement(SyntaxKind kind);
    public static bool IsCaseBlock(SyntaxKind kind);
    public static bool IsCaseStatement(SyntaxKind kind);
    public static bool IsRelationalCaseClause(SyntaxKind kind);
    public static bool IsRelationalCaseClauseOperatorToken(SyntaxKind kind);
    public static bool IsDoLoopBlock(SyntaxKind kind);
    public static bool IsDoStatement(SyntaxKind kind);
    public static bool IsLoopStatement(SyntaxKind kind);
    public static bool IsWhileOrUntilClause(SyntaxKind kind);
    public static bool IsWhileOrUntilClauseWhileOrUntilKeyword(SyntaxKind kind);
    public static bool IsAssignmentStatement(SyntaxKind kind);
    public static bool IsAssignmentStatementOperatorToken(SyntaxKind kind);
    public static bool IsAddRemoveHandlerStatement(SyntaxKind kind);
    public static bool IsAddRemoveHandlerStatementAddHandlerOrRemoveHandlerKeyword(SyntaxKind kind);
    public static bool IsReDimStatement(SyntaxKind kind);
    public static bool IsLiteralExpression(SyntaxKind kind);
    public static bool IsLiteralExpressionToken(SyntaxKind kind);
    public static bool IsTypeOfExpression(SyntaxKind kind);
    public static bool IsTypeOfExpressionOperatorToken(SyntaxKind kind);
    public static bool IsMemberAccessExpression(SyntaxKind kind);
    public static bool IsMemberAccessExpressionOperatorToken(SyntaxKind kind);
    public static bool IsXmlMemberAccessExpression(SyntaxKind kind);
    public static bool IsXmlMemberAccessExpressionToken2(SyntaxKind kind);
    public static bool IsPredefinedCastExpressionKeyword(SyntaxKind kind);
    public static bool IsBinaryExpression(SyntaxKind kind);
    public static bool IsBinaryExpressionOperatorToken(SyntaxKind kind);
    public static bool IsUnaryExpression(SyntaxKind kind);
    public static bool IsUnaryExpressionOperatorToken(SyntaxKind kind);
    public static bool IsSingleLineLambdaExpression(SyntaxKind kind);
    public static bool IsMultiLineLambdaExpression(SyntaxKind kind);
    public static bool IsLambdaHeader(SyntaxKind kind);
    public static bool IsLambdaHeaderSubOrFunctionKeyword(SyntaxKind kind);
    public static bool IsPartitionWhileClause(SyntaxKind kind);
    public static bool IsPartitionWhileClauseSkipOrTakeKeyword(SyntaxKind kind);
    public static bool IsPartitionClause(SyntaxKind kind);
    public static bool IsPartitionClauseSkipOrTakeKeyword(SyntaxKind kind);
    public static bool IsOrdering(SyntaxKind kind);
    public static bool IsOrderingAscendingOrDescendingKeyword(SyntaxKind kind);
    public static bool IsXmlStringStartQuoteToken(SyntaxKind kind);
    public static bool IsXmlStringEndQuoteToken(SyntaxKind kind);
    internal static bool IsPredefinedTypeKeyword(SyntaxKind kind);
    public static bool IsCrefSignaturePartModifier(SyntaxKind kind);
    public static bool IsCrefOperatorReferenceOperatorToken(SyntaxKind kind);
    public static bool IsKeywordKind(SyntaxKind kind);
    public static bool IsPunctuation(SyntaxKind kind);
    public static bool IsXmlTextToken(SyntaxKind kind);
    public static bool IsXmlCrefAttributeStartQuoteToken(SyntaxKind kind);
    public static bool IsXmlCrefAttributeEndQuoteToken(SyntaxKind kind);
    public static bool IsXmlNameAttributeStartQuoteToken(SyntaxKind kind);
    public static bool IsXmlNameAttributeEndQuoteToken(SyntaxKind kind);
    internal static bool IsSyntaxTrivia(SyntaxKind kind);
    public static bool IsIfDirectiveTrivia(SyntaxKind kind);
    public static bool IsIfDirectiveTriviaIfOrElseIfKeyword(SyntaxKind kind);
    public static string GetText(SyntaxKind kind);
}
public enum Microsoft.CodeAnalysis.VisualBasic.SyntaxKind : Enum {
    public ushort value__;
    public static SyntaxKind None;
    public static SyntaxKind List;
    public static SyntaxKind EmptyStatement;
    public static SyntaxKind EndIfStatement;
    public static SyntaxKind EndUsingStatement;
    public static SyntaxKind EndWithStatement;
    public static SyntaxKind EndSelectStatement;
    public static SyntaxKind EndStructureStatement;
    public static SyntaxKind EndEnumStatement;
    public static SyntaxKind EndInterfaceStatement;
    public static SyntaxKind EndClassStatement;
    public static SyntaxKind EndModuleStatement;
    public static SyntaxKind EndNamespaceStatement;
    public static SyntaxKind EndSubStatement;
    public static SyntaxKind EndFunctionStatement;
    public static SyntaxKind EndGetStatement;
    public static SyntaxKind EndSetStatement;
    public static SyntaxKind EndPropertyStatement;
    public static SyntaxKind EndOperatorStatement;
    public static SyntaxKind EndEventStatement;
    public static SyntaxKind EndAddHandlerStatement;
    public static SyntaxKind EndRemoveHandlerStatement;
    public static SyntaxKind EndRaiseEventStatement;
    public static SyntaxKind EndWhileStatement;
    public static SyntaxKind EndTryStatement;
    public static SyntaxKind EndSyncLockStatement;
    public static SyntaxKind CompilationUnit;
    public static SyntaxKind OptionStatement;
    public static SyntaxKind ImportsStatement;
    public static SyntaxKind SimpleImportsClause;
    public static SyntaxKind XmlNamespaceImportsClause;
    public static SyntaxKind NamespaceBlock;
    public static SyntaxKind NamespaceStatement;
    public static SyntaxKind ModuleBlock;
    public static SyntaxKind StructureBlock;
    public static SyntaxKind InterfaceBlock;
    public static SyntaxKind ClassBlock;
    public static SyntaxKind EnumBlock;
    public static SyntaxKind InheritsStatement;
    public static SyntaxKind ImplementsStatement;
    public static SyntaxKind ModuleStatement;
    public static SyntaxKind StructureStatement;
    public static SyntaxKind InterfaceStatement;
    public static SyntaxKind ClassStatement;
    public static SyntaxKind EnumStatement;
    public static SyntaxKind TypeParameterList;
    public static SyntaxKind TypeParameter;
    public static SyntaxKind TypeParameterSingleConstraintClause;
    public static SyntaxKind TypeParameterMultipleConstraintClause;
    public static SyntaxKind NewConstraint;
    public static SyntaxKind ClassConstraint;
    public static SyntaxKind StructureConstraint;
    public static SyntaxKind TypeConstraint;
    public static SyntaxKind EnumMemberDeclaration;
    public static SyntaxKind SubBlock;
    public static SyntaxKind FunctionBlock;
    public static SyntaxKind ConstructorBlock;
    public static SyntaxKind OperatorBlock;
    public static SyntaxKind GetAccessorBlock;
    public static SyntaxKind SetAccessorBlock;
    public static SyntaxKind AddHandlerAccessorBlock;
    public static SyntaxKind RemoveHandlerAccessorBlock;
    public static SyntaxKind RaiseEventAccessorBlock;
    public static SyntaxKind PropertyBlock;
    public static SyntaxKind EventBlock;
    public static SyntaxKind ParameterList;
    public static SyntaxKind SubStatement;
    public static SyntaxKind FunctionStatement;
    public static SyntaxKind SubNewStatement;
    public static SyntaxKind DeclareSubStatement;
    public static SyntaxKind DeclareFunctionStatement;
    public static SyntaxKind DelegateSubStatement;
    public static SyntaxKind DelegateFunctionStatement;
    public static SyntaxKind EventStatement;
    public static SyntaxKind OperatorStatement;
    public static SyntaxKind PropertyStatement;
    public static SyntaxKind GetAccessorStatement;
    public static SyntaxKind SetAccessorStatement;
    public static SyntaxKind AddHandlerAccessorStatement;
    public static SyntaxKind RemoveHandlerAccessorStatement;
    public static SyntaxKind RaiseEventAccessorStatement;
    public static SyntaxKind ImplementsClause;
    public static SyntaxKind HandlesClause;
    public static SyntaxKind KeywordEventContainer;
    public static SyntaxKind WithEventsEventContainer;
    public static SyntaxKind WithEventsPropertyEventContainer;
    public static SyntaxKind HandlesClauseItem;
    public static SyntaxKind IncompleteMember;
    public static SyntaxKind FieldDeclaration;
    public static SyntaxKind VariableDeclarator;
    public static SyntaxKind SimpleAsClause;
    public static SyntaxKind AsNewClause;
    public static SyntaxKind ObjectMemberInitializer;
    public static SyntaxKind ObjectCollectionInitializer;
    public static SyntaxKind InferredFieldInitializer;
    public static SyntaxKind NamedFieldInitializer;
    public static SyntaxKind EqualsValue;
    public static SyntaxKind Parameter;
    public static SyntaxKind ModifiedIdentifier;
    public static SyntaxKind ArrayRankSpecifier;
    public static SyntaxKind AttributeList;
    public static SyntaxKind Attribute;
    public static SyntaxKind AttributeTarget;
    public static SyntaxKind AttributesStatement;
    public static SyntaxKind ExpressionStatement;
    public static SyntaxKind PrintStatement;
    public static SyntaxKind WhileBlock;
    public static SyntaxKind UsingBlock;
    public static SyntaxKind SyncLockBlock;
    public static SyntaxKind WithBlock;
    public static SyntaxKind LocalDeclarationStatement;
    public static SyntaxKind LabelStatement;
    public static SyntaxKind GoToStatement;
    public static SyntaxKind IdentifierLabel;
    public static SyntaxKind NumericLabel;
    public static SyntaxKind NextLabel;
    public static SyntaxKind StopStatement;
    public static SyntaxKind EndStatement;
    public static SyntaxKind ExitDoStatement;
    public static SyntaxKind ExitForStatement;
    public static SyntaxKind ExitSubStatement;
    public static SyntaxKind ExitFunctionStatement;
    public static SyntaxKind ExitOperatorStatement;
    public static SyntaxKind ExitPropertyStatement;
    public static SyntaxKind ExitTryStatement;
    public static SyntaxKind ExitSelectStatement;
    public static SyntaxKind ExitWhileStatement;
    public static SyntaxKind ContinueWhileStatement;
    public static SyntaxKind ContinueDoStatement;
    public static SyntaxKind ContinueForStatement;
    public static SyntaxKind ReturnStatement;
    public static SyntaxKind SingleLineIfStatement;
    public static SyntaxKind SingleLineIfPart;
    public static SyntaxKind SingleLineElseClause;
    public static SyntaxKind MultiLineIfBlock;
    public static SyntaxKind ElseIfBlock;
    public static SyntaxKind ElseBlock;
    public static SyntaxKind IfStatement;
    public static SyntaxKind ElseIfStatement;
    public static SyntaxKind ElseStatement;
    public static SyntaxKind TryBlock;
    public static SyntaxKind CatchBlock;
    public static SyntaxKind FinallyBlock;
    public static SyntaxKind TryStatement;
    public static SyntaxKind CatchStatement;
    public static SyntaxKind CatchFilterClause;
    public static SyntaxKind FinallyStatement;
    public static SyntaxKind ErrorStatement;
    public static SyntaxKind OnErrorGoToZeroStatement;
    public static SyntaxKind OnErrorGoToMinusOneStatement;
    public static SyntaxKind OnErrorGoToLabelStatement;
    public static SyntaxKind OnErrorResumeNextStatement;
    public static SyntaxKind ResumeStatement;
    public static SyntaxKind ResumeLabelStatement;
    public static SyntaxKind ResumeNextStatement;
    public static SyntaxKind SelectBlock;
    public static SyntaxKind SelectStatement;
    public static SyntaxKind CaseBlock;
    public static SyntaxKind CaseElseBlock;
    public static SyntaxKind CaseStatement;
    public static SyntaxKind CaseElseStatement;
    public static SyntaxKind ElseCaseClause;
    public static SyntaxKind SimpleCaseClause;
    public static SyntaxKind RangeCaseClause;
    public static SyntaxKind CaseEqualsClause;
    public static SyntaxKind CaseNotEqualsClause;
    public static SyntaxKind CaseLessThanClause;
    public static SyntaxKind CaseLessThanOrEqualClause;
    public static SyntaxKind CaseGreaterThanOrEqualClause;
    public static SyntaxKind CaseGreaterThanClause;
    public static SyntaxKind SyncLockStatement;
    public static SyntaxKind WhileStatement;
    public static SyntaxKind ForBlock;
    public static SyntaxKind ForEachBlock;
    public static SyntaxKind ForStatement;
    public static SyntaxKind ForStepClause;
    public static SyntaxKind ForEachStatement;
    public static SyntaxKind NextStatement;
    public static SyntaxKind UsingStatement;
    public static SyntaxKind ThrowStatement;
    public static SyntaxKind SimpleAssignmentStatement;
    public static SyntaxKind MidAssignmentStatement;
    public static SyntaxKind AddAssignmentStatement;
    public static SyntaxKind SubtractAssignmentStatement;
    public static SyntaxKind MultiplyAssignmentStatement;
    public static SyntaxKind DivideAssignmentStatement;
    public static SyntaxKind IntegerDivideAssignmentStatement;
    public static SyntaxKind ExponentiateAssignmentStatement;
    public static SyntaxKind LeftShiftAssignmentStatement;
    public static SyntaxKind RightShiftAssignmentStatement;
    public static SyntaxKind ConcatenateAssignmentStatement;
    public static SyntaxKind MidExpression;
    public static SyntaxKind CallStatement;
    public static SyntaxKind AddHandlerStatement;
    public static SyntaxKind RemoveHandlerStatement;
    public static SyntaxKind RaiseEventStatement;
    public static SyntaxKind WithStatement;
    public static SyntaxKind ReDimStatement;
    public static SyntaxKind ReDimPreserveStatement;
    public static SyntaxKind RedimClause;
    public static SyntaxKind EraseStatement;
    public static SyntaxKind CharacterLiteralExpression;
    public static SyntaxKind TrueLiteralExpression;
    public static SyntaxKind FalseLiteralExpression;
    public static SyntaxKind NumericLiteralExpression;
    public static SyntaxKind DateLiteralExpression;
    public static SyntaxKind StringLiteralExpression;
    public static SyntaxKind NothingLiteralExpression;
    public static SyntaxKind ParenthesizedExpression;
    public static SyntaxKind MeExpression;
    public static SyntaxKind MyBaseExpression;
    public static SyntaxKind MyClassExpression;
    public static SyntaxKind GetTypeExpression;
    public static SyntaxKind TypeOfIsExpression;
    public static SyntaxKind TypeOfIsNotExpression;
    public static SyntaxKind GetXmlNamespaceExpression;
    public static SyntaxKind SimpleMemberAccessExpression;
    public static SyntaxKind DictionaryAccessExpression;
    public static SyntaxKind XmlElementAccessExpression;
    public static SyntaxKind XmlDescendantAccessExpression;
    public static SyntaxKind XmlAttributeAccessExpression;
    public static SyntaxKind InvocationExpression;
    public static SyntaxKind ObjectCreationExpression;
    public static SyntaxKind AnonymousObjectCreationExpression;
    public static SyntaxKind ArrayCreationExpression;
    public static SyntaxKind CollectionInitializer;
    public static SyntaxKind CTypeExpression;
    public static SyntaxKind DirectCastExpression;
    public static SyntaxKind TryCastExpression;
    public static SyntaxKind PredefinedCastExpression;
    public static SyntaxKind AddExpression;
    public static SyntaxKind SubtractExpression;
    public static SyntaxKind MultiplyExpression;
    public static SyntaxKind DivideExpression;
    public static SyntaxKind IntegerDivideExpression;
    public static SyntaxKind ExponentiateExpression;
    public static SyntaxKind LeftShiftExpression;
    public static SyntaxKind RightShiftExpression;
    public static SyntaxKind ConcatenateExpression;
    public static SyntaxKind ModuloExpression;
    public static SyntaxKind EqualsExpression;
    public static SyntaxKind NotEqualsExpression;
    public static SyntaxKind LessThanExpression;
    public static SyntaxKind LessThanOrEqualExpression;
    public static SyntaxKind GreaterThanOrEqualExpression;
    public static SyntaxKind GreaterThanExpression;
    public static SyntaxKind IsExpression;
    public static SyntaxKind IsNotExpression;
    public static SyntaxKind LikeExpression;
    public static SyntaxKind OrExpression;
    public static SyntaxKind ExclusiveOrExpression;
    public static SyntaxKind AndExpression;
    public static SyntaxKind OrElseExpression;
    public static SyntaxKind AndAlsoExpression;
    public static SyntaxKind UnaryPlusExpression;
    public static SyntaxKind UnaryMinusExpression;
    public static SyntaxKind NotExpression;
    public static SyntaxKind AddressOfExpression;
    public static SyntaxKind BinaryConditionalExpression;
    public static SyntaxKind TernaryConditionalExpression;
    public static SyntaxKind SingleLineFunctionLambdaExpression;
    public static SyntaxKind SingleLineSubLambdaExpression;
    public static SyntaxKind MultiLineFunctionLambdaExpression;
    public static SyntaxKind MultiLineSubLambdaExpression;
    public static SyntaxKind SubLambdaHeader;
    public static SyntaxKind FunctionLambdaHeader;
    public static SyntaxKind ArgumentList;
    public static SyntaxKind OmittedArgument;
    public static SyntaxKind SimpleArgument;
    public static SyntaxKind RangeArgument;
    public static SyntaxKind QueryExpression;
    public static SyntaxKind CollectionRangeVariable;
    public static SyntaxKind ExpressionRangeVariable;
    public static SyntaxKind AggregationRangeVariable;
    public static SyntaxKind VariableNameEquals;
    public static SyntaxKind FunctionAggregation;
    public static SyntaxKind GroupAggregation;
    public static SyntaxKind FromClause;
    public static SyntaxKind LetClause;
    public static SyntaxKind AggregateClause;
    public static SyntaxKind DistinctClause;
    public static SyntaxKind WhereClause;
    public static SyntaxKind SkipWhileClause;
    public static SyntaxKind TakeWhileClause;
    public static SyntaxKind SkipClause;
    public static SyntaxKind TakeClause;
    public static SyntaxKind GroupByClause;
    public static SyntaxKind JoinCondition;
    public static SyntaxKind SimpleJoinClause;
    public static SyntaxKind GroupJoinClause;
    public static SyntaxKind OrderByClause;
    public static SyntaxKind AscendingOrdering;
    public static SyntaxKind DescendingOrdering;
    public static SyntaxKind SelectClause;
    public static SyntaxKind XmlDocument;
    public static SyntaxKind XmlDeclaration;
    public static SyntaxKind XmlDeclarationOption;
    public static SyntaxKind XmlElement;
    public static SyntaxKind XmlText;
    public static SyntaxKind XmlElementStartTag;
    public static SyntaxKind XmlElementEndTag;
    public static SyntaxKind XmlEmptyElement;
    public static SyntaxKind XmlAttribute;
    public static SyntaxKind XmlString;
    public static SyntaxKind XmlPrefixName;
    public static SyntaxKind XmlName;
    public static SyntaxKind XmlBracketedName;
    public static SyntaxKind XmlPrefix;
    public static SyntaxKind XmlComment;
    public static SyntaxKind XmlProcessingInstruction;
    public static SyntaxKind XmlCDataSection;
    public static SyntaxKind XmlEmbeddedExpression;
    public static SyntaxKind ArrayType;
    public static SyntaxKind NullableType;
    public static SyntaxKind PredefinedType;
    public static SyntaxKind IdentifierName;
    public static SyntaxKind GenericName;
    public static SyntaxKind QualifiedName;
    public static SyntaxKind GlobalName;
    public static SyntaxKind TypeArgumentList;
    public static SyntaxKind CrefReference;
    public static SyntaxKind CrefSignature;
    public static SyntaxKind CrefSignaturePart;
    public static SyntaxKind CrefOperatorReference;
    public static SyntaxKind QualifiedCrefOperatorReference;
    public static SyntaxKind YieldStatement;
    public static SyntaxKind AwaitExpression;
    public static SyntaxKind AddHandlerKeyword;
    public static SyntaxKind AddressOfKeyword;
    public static SyntaxKind AliasKeyword;
    public static SyntaxKind AndKeyword;
    public static SyntaxKind AndAlsoKeyword;
    public static SyntaxKind AsKeyword;
    public static SyntaxKind BooleanKeyword;
    public static SyntaxKind ByRefKeyword;
    public static SyntaxKind ByteKeyword;
    public static SyntaxKind ByValKeyword;
    public static SyntaxKind CallKeyword;
    public static SyntaxKind CaseKeyword;
    public static SyntaxKind CatchKeyword;
    public static SyntaxKind CBoolKeyword;
    public static SyntaxKind CByteKeyword;
    public static SyntaxKind CCharKeyword;
    public static SyntaxKind CDateKeyword;
    public static SyntaxKind CDecKeyword;
    public static SyntaxKind CDblKeyword;
    public static SyntaxKind CharKeyword;
    public static SyntaxKind CIntKeyword;
    public static SyntaxKind ClassKeyword;
    public static SyntaxKind CLngKeyword;
    public static SyntaxKind CObjKeyword;
    public static SyntaxKind ConstKeyword;
    public static SyntaxKind ReferenceKeyword;
    public static SyntaxKind ContinueKeyword;
    public static SyntaxKind CSByteKeyword;
    public static SyntaxKind CShortKeyword;
    public static SyntaxKind CSngKeyword;
    public static SyntaxKind CStrKeyword;
    public static SyntaxKind CTypeKeyword;
    public static SyntaxKind CUIntKeyword;
    public static SyntaxKind CULngKeyword;
    public static SyntaxKind CUShortKeyword;
    public static SyntaxKind DateKeyword;
    public static SyntaxKind DecimalKeyword;
    public static SyntaxKind DeclareKeyword;
    public static SyntaxKind DefaultKeyword;
    public static SyntaxKind DelegateKeyword;
    public static SyntaxKind DimKeyword;
    public static SyntaxKind DirectCastKeyword;
    public static SyntaxKind DoKeyword;
    public static SyntaxKind DoubleKeyword;
    public static SyntaxKind EachKeyword;
    public static SyntaxKind ElseKeyword;
    public static SyntaxKind ElseIfKeyword;
    public static SyntaxKind EndKeyword;
    public static SyntaxKind EnumKeyword;
    public static SyntaxKind EraseKeyword;
    public static SyntaxKind ErrorKeyword;
    public static SyntaxKind EventKeyword;
    public static SyntaxKind ExitKeyword;
    public static SyntaxKind FalseKeyword;
    public static SyntaxKind FinallyKeyword;
    public static SyntaxKind ForKeyword;
    public static SyntaxKind FriendKeyword;
    public static SyntaxKind FunctionKeyword;
    public static SyntaxKind GetKeyword;
    public static SyntaxKind GetTypeKeyword;
    public static SyntaxKind GetXmlNamespaceKeyword;
    public static SyntaxKind GlobalKeyword;
    public static SyntaxKind GoToKeyword;
    public static SyntaxKind HandlesKeyword;
    public static SyntaxKind IfKeyword;
    public static SyntaxKind ImplementsKeyword;
    public static SyntaxKind ImportsKeyword;
    public static SyntaxKind InKeyword;
    public static SyntaxKind InheritsKeyword;
    public static SyntaxKind IntegerKeyword;
    public static SyntaxKind InterfaceKeyword;
    public static SyntaxKind IsKeyword;
    public static SyntaxKind IsNotKeyword;
    public static SyntaxKind LetKeyword;
    public static SyntaxKind LibKeyword;
    public static SyntaxKind LikeKeyword;
    public static SyntaxKind LongKeyword;
    public static SyntaxKind LoopKeyword;
    public static SyntaxKind MeKeyword;
    public static SyntaxKind ModKeyword;
    public static SyntaxKind ModuleKeyword;
    public static SyntaxKind MustInheritKeyword;
    public static SyntaxKind MustOverrideKeyword;
    public static SyntaxKind MyBaseKeyword;
    public static SyntaxKind MyClassKeyword;
    public static SyntaxKind NamespaceKeyword;
    public static SyntaxKind NarrowingKeyword;
    public static SyntaxKind NextKeyword;
    public static SyntaxKind NewKeyword;
    public static SyntaxKind NotKeyword;
    public static SyntaxKind NothingKeyword;
    public static SyntaxKind NotInheritableKeyword;
    public static SyntaxKind NotOverridableKeyword;
    public static SyntaxKind ObjectKeyword;
    public static SyntaxKind OfKeyword;
    public static SyntaxKind OnKeyword;
    public static SyntaxKind OperatorKeyword;
    public static SyntaxKind OptionKeyword;
    public static SyntaxKind OptionalKeyword;
    public static SyntaxKind OrKeyword;
    public static SyntaxKind OrElseKeyword;
    public static SyntaxKind OverloadsKeyword;
    public static SyntaxKind OverridableKeyword;
    public static SyntaxKind OverridesKeyword;
    public static SyntaxKind ParamArrayKeyword;
    public static SyntaxKind PartialKeyword;
    public static SyntaxKind PrivateKeyword;
    public static SyntaxKind PropertyKeyword;
    public static SyntaxKind ProtectedKeyword;
    public static SyntaxKind PublicKeyword;
    public static SyntaxKind RaiseEventKeyword;
    public static SyntaxKind ReadOnlyKeyword;
    public static SyntaxKind ReDimKeyword;
    public static SyntaxKind REMKeyword;
    public static SyntaxKind RemoveHandlerKeyword;
    public static SyntaxKind ResumeKeyword;
    public static SyntaxKind ReturnKeyword;
    public static SyntaxKind SByteKeyword;
    public static SyntaxKind SelectKeyword;
    public static SyntaxKind SetKeyword;
    public static SyntaxKind ShadowsKeyword;
    public static SyntaxKind SharedKeyword;
    public static SyntaxKind ShortKeyword;
    public static SyntaxKind SingleKeyword;
    public static SyntaxKind StaticKeyword;
    public static SyntaxKind StepKeyword;
    public static SyntaxKind StopKeyword;
    public static SyntaxKind StringKeyword;
    public static SyntaxKind StructureKeyword;
    public static SyntaxKind SubKeyword;
    public static SyntaxKind SyncLockKeyword;
    public static SyntaxKind ThenKeyword;
    public static SyntaxKind ThrowKeyword;
    public static SyntaxKind ToKeyword;
    public static SyntaxKind TrueKeyword;
    public static SyntaxKind TryKeyword;
    public static SyntaxKind TryCastKeyword;
    public static SyntaxKind TypeOfKeyword;
    public static SyntaxKind UIntegerKeyword;
    public static SyntaxKind ULongKeyword;
    public static SyntaxKind UShortKeyword;
    public static SyntaxKind UsingKeyword;
    public static SyntaxKind WhenKeyword;
    public static SyntaxKind WhileKeyword;
    public static SyntaxKind WideningKeyword;
    public static SyntaxKind WithKeyword;
    public static SyntaxKind WithEventsKeyword;
    public static SyntaxKind WriteOnlyKeyword;
    public static SyntaxKind XorKeyword;
    public static SyntaxKind EndIfKeyword;
    public static SyntaxKind GosubKeyword;
    public static SyntaxKind VariantKeyword;
    public static SyntaxKind WendKeyword;
    public static SyntaxKind AggregateKeyword;
    public static SyntaxKind AllKeyword;
    public static SyntaxKind AnsiKeyword;
    public static SyntaxKind AscendingKeyword;
    public static SyntaxKind AssemblyKeyword;
    public static SyntaxKind AutoKeyword;
    public static SyntaxKind BinaryKeyword;
    public static SyntaxKind ByKeyword;
    public static SyntaxKind CompareKeyword;
    public static SyntaxKind CustomKeyword;
    public static SyntaxKind DescendingKeyword;
    public static SyntaxKind DisableKeyword;
    public static SyntaxKind DistinctKeyword;
    public static SyntaxKind EnableKeyword;
    public static SyntaxKind EqualsKeyword;
    public static SyntaxKind ExplicitKeyword;
    public static SyntaxKind ExternalSourceKeyword;
    public static SyntaxKind ExternalChecksumKeyword;
    public static SyntaxKind FromKeyword;
    public static SyntaxKind GroupKeyword;
    public static SyntaxKind InferKeyword;
    public static SyntaxKind IntoKeyword;
    public static SyntaxKind IsFalseKeyword;
    public static SyntaxKind IsTrueKeyword;
    public static SyntaxKind JoinKeyword;
    public static SyntaxKind KeyKeyword;
    public static SyntaxKind MidKeyword;
    public static SyntaxKind OffKeyword;
    public static SyntaxKind OrderKeyword;
    public static SyntaxKind OutKeyword;
    public static SyntaxKind PreserveKeyword;
    public static SyntaxKind RegionKeyword;
    public static SyntaxKind SkipKeyword;
    public static SyntaxKind StrictKeyword;
    public static SyntaxKind TakeKeyword;
    public static SyntaxKind TextKeyword;
    public static SyntaxKind UnicodeKeyword;
    public static SyntaxKind UntilKeyword;
    public static SyntaxKind WarningKeyword;
    public static SyntaxKind WhereKeyword;
    public static SyntaxKind TypeKeyword;
    public static SyntaxKind XmlKeyword;
    public static SyntaxKind AsyncKeyword;
    public static SyntaxKind AwaitKeyword;
    public static SyntaxKind IteratorKeyword;
    public static SyntaxKind YieldKeyword;
    public static SyntaxKind ExclamationToken;
    public static SyntaxKind AtToken;
    public static SyntaxKind CommaToken;
    public static SyntaxKind HashToken;
    public static SyntaxKind AmpersandToken;
    public static SyntaxKind SingleQuoteToken;
    public static SyntaxKind OpenParenToken;
    public static SyntaxKind CloseParenToken;
    public static SyntaxKind OpenBraceToken;
    public static SyntaxKind CloseBraceToken;
    public static SyntaxKind SemicolonToken;
    public static SyntaxKind AsteriskToken;
    public static SyntaxKind PlusToken;
    public static SyntaxKind MinusToken;
    public static SyntaxKind DotToken;
    public static SyntaxKind SlashToken;
    public static SyntaxKind ColonToken;
    public static SyntaxKind LessThanToken;
    public static SyntaxKind LessThanEqualsToken;
    public static SyntaxKind LessThanGreaterThanToken;
    public static SyntaxKind EqualsToken;
    public static SyntaxKind GreaterThanToken;
    public static SyntaxKind GreaterThanEqualsToken;
    public static SyntaxKind BackslashToken;
    public static SyntaxKind CaretToken;
    public static SyntaxKind ColonEqualsToken;
    public static SyntaxKind AmpersandEqualsToken;
    public static SyntaxKind AsteriskEqualsToken;
    public static SyntaxKind PlusEqualsToken;
    public static SyntaxKind MinusEqualsToken;
    public static SyntaxKind SlashEqualsToken;
    public static SyntaxKind BackslashEqualsToken;
    public static SyntaxKind CaretEqualsToken;
    public static SyntaxKind LessThanLessThanToken;
    public static SyntaxKind GreaterThanGreaterThanToken;
    public static SyntaxKind LessThanLessThanEqualsToken;
    public static SyntaxKind GreaterThanGreaterThanEqualsToken;
    public static SyntaxKind QuestionToken;
    public static SyntaxKind DoubleQuoteToken;
    public static SyntaxKind StatementTerminatorToken;
    public static SyntaxKind EndOfFileToken;
    public static SyntaxKind EmptyToken;
    public static SyntaxKind SlashGreaterThanToken;
    public static SyntaxKind LessThanSlashToken;
    public static SyntaxKind LessThanExclamationMinusMinusToken;
    public static SyntaxKind MinusMinusGreaterThanToken;
    public static SyntaxKind LessThanQuestionToken;
    public static SyntaxKind QuestionGreaterThanToken;
    public static SyntaxKind LessThanPercentEqualsToken;
    public static SyntaxKind PercentGreaterThanToken;
    public static SyntaxKind BeginCDataToken;
    public static SyntaxKind EndCDataToken;
    public static SyntaxKind EndOfXmlToken;
    public static SyntaxKind BadToken;
    public static SyntaxKind XmlNameToken;
    public static SyntaxKind XmlTextLiteralToken;
    public static SyntaxKind XmlEntityLiteralToken;
    public static SyntaxKind DocumentationCommentLineBreakToken;
    public static SyntaxKind IdentifierToken;
    public static SyntaxKind IntegerLiteralToken;
    public static SyntaxKind FloatingLiteralToken;
    public static SyntaxKind DecimalLiteralToken;
    public static SyntaxKind DateLiteralToken;
    public static SyntaxKind StringLiteralToken;
    public static SyntaxKind CharacterLiteralToken;
    public static SyntaxKind SkippedTokensTrivia;
    public static SyntaxKind DocumentationCommentTrivia;
    public static SyntaxKind XmlCrefAttribute;
    public static SyntaxKind XmlNameAttribute;
    public static SyntaxKind ConditionalAccessExpression;
    public static SyntaxKind WhitespaceTrivia;
    public static SyntaxKind EndOfLineTrivia;
    public static SyntaxKind ColonTrivia;
    public static SyntaxKind CommentTrivia;
    public static SyntaxKind LineContinuationTrivia;
    public static SyntaxKind DocumentationCommentExteriorTrivia;
    public static SyntaxKind DisabledTextTrivia;
    public static SyntaxKind ConstDirectiveTrivia;
    public static SyntaxKind IfDirectiveTrivia;
    public static SyntaxKind ElseIfDirectiveTrivia;
    public static SyntaxKind ElseDirectiveTrivia;
    public static SyntaxKind EndIfDirectiveTrivia;
    public static SyntaxKind RegionDirectiveTrivia;
    public static SyntaxKind EndRegionDirectiveTrivia;
    public static SyntaxKind ExternalSourceDirectiveTrivia;
    public static SyntaxKind EndExternalSourceDirectiveTrivia;
    public static SyntaxKind ExternalChecksumDirectiveTrivia;
    public static SyntaxKind EnableWarningDirectiveTrivia;
    public static SyntaxKind DisableWarningDirectiveTrivia;
    public static SyntaxKind ReferenceDirectiveTrivia;
    public static SyntaxKind BadDirectiveTrivia;
    public static SyntaxKind ImportAliasClause;
    public static SyntaxKind NameColonEquals;
    public static SyntaxKind SimpleDoLoopBlock;
    public static SyntaxKind DoWhileLoopBlock;
    public static SyntaxKind DoUntilLoopBlock;
    public static SyntaxKind DoLoopWhileBlock;
    public static SyntaxKind DoLoopUntilBlock;
    public static SyntaxKind SimpleDoStatement;
    public static SyntaxKind DoWhileStatement;
    public static SyntaxKind DoUntilStatement;
    public static SyntaxKind SimpleLoopStatement;
    public static SyntaxKind LoopWhileStatement;
    public static SyntaxKind LoopUntilStatement;
    public static SyntaxKind WhileClause;
    public static SyntaxKind UntilClause;
    public static SyntaxKind NameOfKeyword;
    public static SyntaxKind NameOfExpression;
    public static SyntaxKind InterpolatedStringExpression;
    public static SyntaxKind InterpolatedStringText;
    public static SyntaxKind Interpolation;
    public static SyntaxKind InterpolationAlignmentClause;
    public static SyntaxKind InterpolationFormatClause;
    public static SyntaxKind DollarSignDoubleQuoteToken;
    public static SyntaxKind InterpolatedStringTextToken;
    public static SyntaxKind EndOfInterpolatedStringToken;
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SyntaxKindExtensions : object {
    [ExtensionAttribute]
public static bool Contains(SyntaxKind[] kinds, SyntaxKind kind);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SyntaxNodeExtensions : object {
    [ExtensionAttribute]
public static TNode WithAnnotations(TNode node, SyntaxAnnotation[] annotations);
    [ExtensionAttribute]
public static WithStatementSyntax ContainingWithStatement(VisualBasicSyntaxNode node);
    [ExtensionAttribute]
public static void GetAncestors(VisualBasicSyntaxNode node, ArrayBuilder`1<T> result);
    [ExtensionAttribute]
public static T GetAncestorOrSelf(VisualBasicSyntaxNode node);
    [ExtensionAttribute]
public static bool IsLambdaExpressionSyntax(VisualBasicSyntaxNode this);
    [ExtensionAttribute]
internal static SyntaxToken ExtractAnonymousTypeMemberName(ExpressionSyntax input, XmlNameSyntax& failedToInferFromXmlName);
    private static ExpressionSyntax GetCorrespondingConditionalAccessReceiver(ExpressionSyntax node);
    [ExtensionAttribute]
internal static ConditionalAccessExpressionSyntax GetCorrespondingConditionalAccessExpression(ExpressionSyntax node);
    [ExtensionAttribute]
internal static ExpressionSyntax GetLeafAccess(ConditionalAccessExpressionSyntax conditionalAccess);
    [ExtensionAttribute]
public static bool AllAreMissing(IEnumerable`1<VisualBasicSyntaxNode> arguments, SyntaxKind kind);
    [ExtensionAttribute]
public static bool AllAreMissingIdentifierName(IEnumerable`1<VisualBasicSyntaxNode> arguments);
    [ExtensionAttribute]
public static SyntaxToken QueryClauseKeywordOrRangeVariableIdentifier(VisualBasicSyntaxNode syntax);
    [ExtensionAttribute]
internal static StructuredTriviaSyntax EnclosingStructuredTrivia(VisualBasicSyntaxNode node);
}
internal class Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeDiagnosticEnumerator : ValueType {
    private SyntaxTree _tree;
    private NodeIteration[] _stack;
    private int _count;
    private Diagnostic _current;
    private int _position;
    public Diagnostic Current { get; }
    internal SyntaxTreeDiagnosticEnumerator(SyntaxTree tree, VisualBasicSyntaxNode node, int position, bool inDocumentationComment);
    public bool MoveNext();
    private void Push(GreenNode node, bool inDocumentationComment);
    private void PushToken(SyntaxToken token, bool inDocumentationComment);
    private void PushNode(GreenNode node, bool inDocumentationComment);
    private void Pop();
    public Diagnostic get_Current();
}
internal class Microsoft.CodeAnalysis.VisualBasic.SyntaxTreeSemanticModel : VBSemanticModel {
    private VisualBasicCompilation _compilation;
    private SourceModuleSymbol _sourceModule;
    private SyntaxTree _syntaxTree;
    private BinderFactory _binderFactory;
    private bool _ignoresAccessibility;
    private ConcurrentDictionary`2<Tuple`2<Binder, bool>, MemberSemanticModel> _semanticModelCache;
    private static Func`2<Tuple`2<Binder, bool>, MemberSemanticModel> s_methodBodySemanticModelCreator;
    private static Func`2<Tuple`2<Binder, bool>, MemberSemanticModel> s_initializerSemanticModelCreator;
    private static Func`2<Tuple`2<Binder, bool>, MemberSemanticModel> s_attributeSemanticModelCreator;
    public VisualBasicCompilation Compilation { get; }
    internal VisualBasicSyntaxNode Root { get; }
    public SyntaxTree SyntaxTree { get; }
    public bool IgnoresAccessibility { get; }
    public bool IsSpeculativeSemanticModel { get; }
    public int OriginalPositionForSpeculation { get; }
    public SemanticModel ParentModel { get; }
    private static SyntaxTreeSemanticModel();
    internal SyntaxTreeSemanticModel(VisualBasicCompilation compilation, SourceModuleSymbol sourceModule, SyntaxTree syntaxTree, bool ignoreAccessibility);
    public virtual VisualBasicCompilation get_Compilation();
    internal virtual VisualBasicSyntaxNode get_Root();
    public virtual SyntaxTree get_SyntaxTree();
    public sealed virtual bool get_IgnoresAccessibility();
    public virtual ImmutableArray`1<Diagnostic> GetDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetSyntaxDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetDeclarationDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetMethodBodyDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public MemberSemanticModel GetMemberSemanticModel(Binder binder);
    internal MemberSemanticModel GetMemberSemanticModel(int position);
    internal MemberSemanticModel GetMemberSemanticModel(VisualBasicSyntaxNode node);
    internal virtual Binder GetEnclosingBinder(int position);
    internal virtual BoundNodeSummary GetInvokeSummaryForRaiseEvent(RaiseEventStatementSyntax node);
    internal virtual SymbolInfo GetCrefReferenceSymbolInfo(CrefReferenceSyntax crefReference, SymbolInfoOptions options, CancellationToken cancellationToken);
    internal virtual SymbolInfo GetExpressionSymbolInfo(ExpressionSyntax node, SymbolInfoOptions options, CancellationToken cancellationToken);
    internal virtual SymbolInfo GetCollectionInitializerAddSymbolInfo(ObjectCreationExpressionSyntax collectionInitializer, ExpressionSyntax node, CancellationToken cancellationToken);
    private SymbolInfo TryBindNamespaceOrTypeAsExpression(ExpressionSyntax node, SymbolInfoOptions options);
    internal virtual VisualBasicTypeInfo GetExpressionTypeInfo(ExpressionSyntax node, CancellationToken cancellationToken);
    internal virtual ImmutableArray`1<Symbol> GetExpressionMemberGroup(ExpressionSyntax node, CancellationToken cancellationToken);
    internal virtual ConstantValue GetExpressionConstantValue(ExpressionSyntax node, CancellationToken cancellationToken);
    internal virtual IOperation GetOperationWorker(VisualBasicSyntaxNode node, GetOperationOptions options, CancellationToken cancellationToken);
    internal virtual SymbolInfo GetAttributeSymbolInfo(AttributeSyntax attribute, CancellationToken cancellationToken);
    internal virtual SymbolInfo GetQueryClauseSymbolInfo(QueryClauseSyntax node, CancellationToken cancellationToken);
    internal virtual SymbolInfo GetLetClauseSymbolInfo(ExpressionRangeVariableSyntax node, CancellationToken cancellationToken);
    internal virtual SymbolInfo GetOrderingSymbolInfo(OrderingSyntax node, CancellationToken cancellationToken);
    internal virtual AggregateClauseSymbolInfo GetAggregateClauseSymbolInfoWorker(AggregateClauseSyntax node, CancellationToken cancellationToken);
    internal virtual CollectionRangeVariableSymbolInfo GetCollectionRangeVariableSymbolInfoWorker(CollectionRangeVariableSyntax node, CancellationToken cancellationToken);
    internal virtual VisualBasicTypeInfo GetAttributeTypeInfo(AttributeSyntax attribute, CancellationToken cancellationToken);
    internal virtual ImmutableArray`1<Symbol> GetAttributeMemberGroup(AttributeSyntax attribute, CancellationToken cancellationToken);
    private Symbol GetTypeOrNamespaceSymbolNotInMember(TypeSyntax expression);
    private SymbolInfo GetSymbolInfoForCrefOrNameAttributeReference(VisualBasicSyntaxNode node, SymbolInfoOptions options);
    private VisualBasicTypeInfo GetTypeInfoForCrefOrNameAttributeReference(TypeSyntax name);
    private ImmutableArray`1<Symbol> GetCrefOrNameAttributeReferenceSymbols(VisualBasicSyntaxNode node, bool preserveAlias, ImmutableArray`1& typeParameters);
    private SymbolInfo GetTypeOrNamespaceSymbolInfoNotInMember(TypeSyntax expression, SymbolInfoOptions options);
    private VisualBasicTypeInfo GetTypeOrNamespaceTypeInfoNotInMember(TypeSyntax expression);
    private LookupResultKind GetImplementedMemberAndResultKind(ArrayBuilder`1<Symbol> symbolBuilder, QualifiedNameSyntax memberName);
    private LookupResultKind GetHandledEventOrContainerSymbolsAndResultKind(ArrayBuilder`1<Symbol> eventSymbolBuilder, ArrayBuilder`1<Symbol> containerSymbolBuilder, ArrayBuilder`1<Symbol> propertySymbolBuilder, HandlesClauseItemSyntax handlesClause);
    private SymbolInfo GetImplementedMemberSymbolInfo(QualifiedNameSyntax memberName, SymbolInfoOptions options);
    private SymbolInfo GetHandlesEventSymbolInfo(HandlesClauseItemSyntax handlesClause, SymbolInfoOptions options);
    private SymbolInfo GetHandlesContainerSymbolInfo(HandlesClauseItemSyntax handlesClause, SymbolInfoOptions options);
    private SymbolInfo GetHandlesPropertySymbolInfo(HandlesClauseItemSyntax handlesClause, SymbolInfoOptions options);
    private VisualBasicTypeInfo GetImplementedMemberTypeInfo(QualifiedNameSyntax memberName);
    private VisualBasicTypeInfo GetHandlesEventTypeInfo(IdentifierNameSyntax memberName);
    private VisualBasicTypeInfo GetHandlesContainerTypeInfo(HandlesClauseItemSyntax memberName);
    private VisualBasicTypeInfo GetHandlesPropertyTypeInfo(HandlesClauseItemSyntax memberName);
    private NamedTypeSymbol CheckSymbolLocationsAgainstSyntax(NamedTypeSymbol symbol, VisualBasicSyntaxNode nodeToCheck);
    public NamedTypeSymbol GetDeclaredSymbol(DelegateStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual INamedTypeSymbol GetDeclaredSymbol(TypeStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual INamedTypeSymbol GetDeclaredSymbol(EnumStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual INamespaceSymbol GetDeclaredSymbol(NamespaceStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    internal virtual ISymbol GetDeclaredSymbol(MethodBaseSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IParameterSymbol GetDeclaredSymbol(ParameterSyntax parameter, CancellationToken cancellationToken);
    public virtual ITypeParameterSymbol GetDeclaredSymbol(TypeParameterSyntax typeParameter, CancellationToken cancellationToken);
    private TypeParameterSymbol GetTypeParameterSymbol(ImmutableArray`1<TypeParameterSymbol> parameters, TypeParameterSyntax parameter);
    public virtual IFieldSymbol GetDeclaredSymbol(EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual ISymbol GetDeclaredSymbol(ModifiedIdentifierSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual IPropertySymbol GetDeclaredSymbol(FieldInitializerSyntax fieldInitializerSyntax, CancellationToken cancellationToken);
    public virtual INamedTypeSymbol GetDeclaredSymbol(AnonymousObjectCreationExpressionSyntax anonymousObjectCreationExpressionSyntax, CancellationToken cancellationToken);
    public virtual IRangeVariableSymbol GetDeclaredSymbol(ExpressionRangeVariableSyntax rangeVariableSyntax, CancellationToken cancellationToken);
    public virtual IRangeVariableSymbol GetDeclaredSymbol(CollectionRangeVariableSyntax rangeVariableSyntax, CancellationToken cancellationToken);
    public virtual IRangeVariableSymbol GetDeclaredSymbol(AggregationRangeVariableSyntax rangeVariableSyntax, CancellationToken cancellationToken);
    public virtual IAliasSymbol GetDeclaredSymbol(SimpleImportsClauseSyntax declarationSyntax, CancellationToken cancellationToken);
    internal virtual ImmutableArray`1<ISymbol> GetDeclaredSymbols(FieldDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public virtual Conversion ClassifyConversion(ExpressionSyntax expression, ITypeSymbol destination);
    public virtual bool get_IsSpeculativeSemanticModel();
    public virtual int get_OriginalPositionForSpeculation();
    public virtual SemanticModel get_ParentModel();
    internal virtual bool TryGetSpeculativeSemanticModelForMethodBodyCore(SyntaxTreeSemanticModel parentModel, int position, MethodBlockBaseSyntax method, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, TypeSyntax type, SpeculativeBindingOption bindingOption, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, RangeArgumentSyntax rangeArgument, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, ExecutableStatementSyntax statement, SemanticModel& speculativeModel);
    internal virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, EqualsValueSyntax initializer, SemanticModel& speculativeModel);
    public virtual ControlFlowAnalysis AnalyzeControlFlow(StatementSyntax firstStatement, StatementSyntax lastStatement);
    public virtual DataFlowAnalysis AnalyzeDataFlow(StatementSyntax firstStatement, StatementSyntax lastStatement);
    public virtual DataFlowAnalysis AnalyzeDataFlow(ExpressionSyntax expression);
    [ConditionalAttribute("DEBUG")]
private void CheckSucceededFlagInAnalyzeDataFlow(ExpressionSyntax expression, VisualBasicDataFlowAnalysis result, RegionAnalysisContext context);
    private static bool IsNodeInsideAttributeArguments(VisualBasicSyntaxNode node);
    private static bool IsExpressionInValidContext(ExpressionSyntax expression);
    private void AssertNodeInTree(VisualBasicSyntaxNode node, string argName);
    private bool ValidateRegionDefiningExpression(ExpressionSyntax expression);
    private bool ValidateRegionDefiningStatementsRange(StatementSyntax firstStatement, StatementSyntax lastStatement);
    private bool IsNotUppermostForBlock(VisualBasicSyntaxNode forBlockOrStatement);
    internal virtual ForEachStatementInfo GetForEachStatementInfoWorker(ForEachBlockSyntax node);
    internal virtual AwaitExpressionInfo GetAwaitExpressionInfoWorker(AwaitExpressionSyntax awaitExpression, CancellationToken cancellationToken);
    private RegionAnalysisContext CreateFailedRegionAnalysisContext();
    private RegionAnalysisContext CreateRegionAnalysisContext(ExpressionSyntax expression);
    private RegionAnalysisContext CreateRegionAnalysisContext(StatementSyntax firstStatement, StatementSyntax lastStatement);
}
internal class Microsoft.CodeAnalysis.VisualBasic.SyntaxTriviaFunctions : object {
    internal static Func`2<SyntaxTrivia, bool> Skipped;
    private static SyntaxTriviaFunctions();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.SynthesizedContainer : InstanceTypeSymbol {
    private NamedTypeSymbol _containingType;
    private NamedTypeSymbol _baseType;
    private string _name;
    private ImmutableArray`1<TypeParameterSymbol> _typeParameters;
    private ImmutableArray`1<NamedTypeSymbol> _interfaces;
    private TypeSubstitution _typeMap;
    private static Func`2<Symbol, TypeSubstitution> s_typeSubstitutionFactory;
    private static Func`3<TypeParameterSymbol, Symbol, TypeParameterSymbol> s_createTypeParameter;
    protected internal MethodSymbol Constructor { get; }
    public string Name { get; }
    internal bool MangleName { get; }
    internal bool HasSpecialName { get; }
    internal bool IsSerializable { get; }
    internal TypeLayout Layout { get; }
    internal CharSet MarshallingCharSet { get; }
    public TypeKind TypeKind { get; }
    public int Arity { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public bool IsMustInherit { get; }
    public bool MightContainExtensionMethods { get; }
    internal bool HasEmbeddedAttribute { get; }
    internal bool IsExtensibleInterfaceNoUseSiteDiagnostics { get; }
    internal bool IsWindowsRuntimeImport { get; }
    internal bool ShouldAddWinRTMembers { get; }
    internal bool IsComImport { get; }
    internal TypeSymbol CoClassType { get; }
    internal bool HasDeclarativeSecurity { get; }
    internal string DefaultPropertyName { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public Symbol ContainingSymbol { get; }
    public NamedTypeSymbol ContainingType { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public bool IsImplicitlyDeclared { get; }
    internal ObsoleteAttributeData ObsoleteAttributeData { get; }
    public bool IsNotInheritable { get; }
    internal TypeSubstitution TypeSubstitution { get; }
    private static SynthesizedContainer();
    protected internal SynthesizedContainer(MethodSymbol topLevelMethod, string typeName, NamedTypeSymbol baseType, ImmutableArray`1<NamedTypeSymbol> originalInterfaces);
    protected internal abstract virtual MethodSymbol get_Constructor();
    public sealed virtual string get_Name();
    internal sealed virtual bool get_MangleName();
    internal sealed virtual bool get_HasSpecialName();
    internal virtual bool get_IsSerializable();
    internal sealed virtual TypeLayout get_Layout();
    internal sealed virtual CharSet get_MarshallingCharSet();
    public abstract virtual TypeKind get_TypeKind();
    public virtual int get_Arity();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public sealed virtual bool get_IsMustInherit();
    public sealed virtual bool get_MightContainExtensionMethods();
    internal sealed virtual bool get_HasEmbeddedAttribute();
    internal sealed virtual bool get_IsExtensibleInterfaceNoUseSiteDiagnostics();
    internal sealed virtual bool get_IsWindowsRuntimeImport();
    internal virtual bool get_ShouldAddWinRTMembers();
    internal sealed virtual bool get_IsComImport();
    internal sealed virtual TypeSymbol get_CoClassType();
    internal sealed virtual ImmutableArray`1<string> GetAppliedConditionalSymbols();
    internal sealed virtual AttributeUsageInfo GetAttributeUsageInfo();
    internal sealed virtual bool get_HasDeclarativeSecurity();
    internal sealed virtual IEnumerable`1<SecurityAttribute> GetSecurityInformation();
    internal sealed virtual string get_DefaultPropertyName();
    internal virtual NamedTypeSymbol MakeAcyclicBaseType(DiagnosticBag diagnostics);
    internal virtual NamedTypeSymbol MakeDeclaredBase(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<NamedTypeSymbol> MakeAcyclicInterfaces(DiagnosticBag diagnostics);
    internal virtual ImmutableArray`1<NamedTypeSymbol> MakeDeclaredInterfaces(ConsList`1<Symbol> basesBeingResolved, DiagnosticBag diagnostics);
    public virtual ImmutableArray`1<Symbol> GetMembers();
    public virtual ImmutableArray`1<Symbol> GetMembers(string name);
    public virtual IEnumerable`1<string> get_MemberNames();
    internal virtual IEnumerable`1<FieldSymbol> GetFieldsToEmit();
    public sealed virtual Symbol get_ContainingSymbol();
    public sealed virtual NamedTypeSymbol get_ContainingType();
    public sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers();
    public sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name);
    public sealed virtual ImmutableArray`1<NamedTypeSymbol> GetTypeMembers(string name, int arity);
    public virtual Accessibility get_DeclaredAccessibility();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public sealed virtual bool get_IsImplicitlyDeclared();
    internal sealed virtual ObsoleteAttributeData get_ObsoleteAttributeData();
    internal sealed virtual void GenerateDeclarationErrors(CancellationToken cancellationToken);
    public sealed virtual bool get_IsNotInheritable();
    internal virtual TypeSubstitution get_TypeSubstitution();
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    [CompilerGeneratedAttribute]
private NamedTypeSymbol _Lambda$__9-0(NamedTypeSymbol i);
}
internal class Microsoft.CodeAnalysis.VisualBasic.SynthesizedLambdaCacheFieldSymbol : SynthesizedFieldSymbol {
    private MethodSymbol _topLevelMethod;
    public bool HasMethodBodyDependency { get; }
    public IMethodSymbol Method { get; }
    public SynthesizedLambdaCacheFieldSymbol(NamedTypeSymbol containingType, Symbol implicitlyDefinedBy, TypeSymbol type, string name, MethodSymbol topLevelMethod, Accessibility accessibility, bool isReadOnly, bool isShared, bool isSpecialNameAndRuntimeSpecial);
    public sealed virtual override bool get_HasMethodBodyDependency();
    public sealed virtual override IMethodSymbol get_Method();
}
internal class Microsoft.CodeAnalysis.VisualBasic.SynthesizedLambdaConstructor : SynthesizedMethod {
    public MethodKind MethodKind { get; }
    internal bool HasSpecialName { get; }
    internal bool GenerateDebugInfoImpl { get; }
    public bool HasMethodBodyDependency { get; }
    public IMethodSymbol Method { get; }
    internal SynthesizedLambdaConstructor(VisualBasicSyntaxNode syntaxNode, LambdaFrame containingType);
    public virtual MethodKind get_MethodKind();
    internal MethodSymbol AsMember(NamedTypeSymbol frameType);
    internal sealed virtual bool get_HasSpecialName();
    internal virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal virtual bool get_GenerateDebugInfoImpl();
    internal sealed virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    public sealed virtual override bool get_HasMethodBodyDependency();
    public sealed virtual override IMethodSymbol get_Method();
}
internal class Microsoft.CodeAnalysis.VisualBasic.SynthesizedLambdaCopyConstructor : SynthesizedLambdaConstructor {
    private ImmutableArray`1<ParameterSymbol> _parameters;
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    internal bool GenerateDebugInfoImpl { get; }
    internal SynthesizedLambdaCopyConstructor(VisualBasicSyntaxNode syntaxNode, LambdaFrame containingType);
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    internal virtual bool get_GenerateDebugInfoImpl();
}
internal class Microsoft.CodeAnalysis.VisualBasic.SynthesizedLambdaMethod : SynthesizedMethod {
    private LambdaSymbol _lambda;
    private ImmutableArray`1<ParameterSymbol> _parameters;
    private ImmutableArray`1<Location> _locations;
    private ImmutableArray`1<TypeParameterSymbol> _typeParameters;
    private TypeSubstitution _typeMap;
    private MethodSymbol _topLevelMethod;
    public Accessibility DeclaredAccessibility { get; }
    internal TypeSubstitution TypeMap { get; }
    public MethodSymbol TopLevelMethod { get; }
    public ImmutableArray`1<TypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public TypeSymbol ReturnType { get; }
    public bool IsShared { get; }
    public bool IsVararg { get; }
    public int Arity { get; }
    internal bool HasSpecialName { get; }
    public bool IsAsync { get; }
    public bool IsIterator { get; }
    internal bool GenerateDebugInfoImpl { get; }
    public bool HasMethodBodyDependency { get; }
    public IMethodSymbol Method { get; }
    internal SynthesizedLambdaMethod(InstanceTypeSymbol containingType, ClosureKind closureKind, MethodSymbol topLevelMethod, DebugId topLevelMethodId, BoundLambda lambdaNode, DebugId lambdaId, DiagnosticBag diagnostics);
    public virtual Accessibility get_DeclaredAccessibility();
    internal virtual TypeSubstitution get_TypeMap();
    private static string MakeName(DebugId topLevelMethodId, ClosureKind closureKind, SynthesizedLambdaKind lambdaKind, DebugId lambdaId);
    public MethodSymbol get_TopLevelMethod();
    public virtual ImmutableArray`1<TypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual TypeSymbol get_ReturnType();
    public virtual bool get_IsShared();
    public virtual bool get_IsVararg();
    public virtual int get_Arity();
    internal virtual bool get_HasSpecialName();
    public virtual bool get_IsAsync();
    public virtual bool get_IsIterator();
    internal virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal MethodSymbol AsMember(NamedTypeSymbol constructedFrame);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    internal virtual bool get_GenerateDebugInfoImpl();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    public sealed virtual override bool get_HasMethodBodyDependency();
    public sealed virtual override IMethodSymbol get_Method();
}
internal class Microsoft.CodeAnalysis.VisualBasic.SynthesizedMetadataCompiler : VisualBasicSymbolVisitor {
    private PEModuleBuilder _moduleBeingBuilt;
    private CancellationToken _cancellationToken;
    private SynthesizedMetadataCompiler(PEModuleBuilder moduleBeingBuilt, CancellationToken cancellationToken);
    internal static void ProcessSynthesizedMembers(VisualBasicCompilation compilation, PEModuleBuilder moduleBeingBuilt, CancellationToken cancellationToken);
    public virtual void VisitNamespace(NamespaceSymbol symbol);
    public virtual void VisitNamedType(NamedTypeSymbol symbol);
}
internal class Microsoft.CodeAnalysis.VisualBasic.SynthesizedStateMachineDebuggerNonUserCodeMethod : SynthesizedStateMachineMethod {
    internal SynthesizedStateMachineDebuggerNonUserCodeMethod(StateMachineTypeSymbol stateMachineType, string name, MethodSymbol interfaceMethod, VisualBasicSyntaxNode syntax, Accessibility declaredAccessibility, bool hasMethodBodyDependency, PropertySymbol associatedProperty);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.SynthesizedStateMachineMethod : SynthesizedMethod {
    private MethodSymbol _interfaceMethod;
    private ImmutableArray`1<ParameterSymbol> _parameters;
    private ImmutableArray`1<Location> _locations;
    private Accessibility _accessibility;
    private bool _generateDebugInfo;
    private bool _hasMethodBodyDependency;
    private PropertySymbol _associatedProperty;
    public StateMachineTypeSymbol StateMachineType { get; }
    internal TypeSubstitution TypeMap { get; }
    public ImmutableArray`1<TypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public TypeSymbol ReturnType { get; }
    public bool IsShared { get; }
    public bool IsSub { get; }
    public bool IsVararg { get; }
    public int Arity { get; }
    public Accessibility DeclaredAccessibility { get; }
    internal int ParameterCount { get; }
    internal bool HasSpecialName { get; }
    public ImmutableArray`1<MethodSymbol> ExplicitInterfaceImplementations { get; }
    public Symbol AssociatedSymbol { get; }
    internal bool GenerateDebugInfoImpl { get; }
    public bool HasMethodBodyDependency { get; }
    public IMethodSymbol Method { get; }
    protected SynthesizedStateMachineMethod(StateMachineTypeSymbol stateMachineType, string name, MethodSymbol interfaceMethod, VisualBasicSyntaxNode syntax, Accessibility declaredAccessibility, bool generateDebugInfo, bool hasMethodBodyDependency, PropertySymbol associatedProperty);
    public StateMachineTypeSymbol get_StateMachineType();
    internal virtual TypeSubstitution get_TypeMap();
    public virtual ImmutableArray`1<TypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual TypeSymbol get_ReturnType();
    public virtual bool get_IsShared();
    public virtual bool get_IsSub();
    public virtual bool get_IsVararg();
    public virtual int get_Arity();
    public virtual Accessibility get_DeclaredAccessibility();
    internal virtual int get_ParameterCount();
    internal virtual bool get_HasSpecialName();
    public virtual ImmutableArray`1<MethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual Symbol get_AssociatedSymbol();
    internal virtual bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges);
    internal virtual bool get_GenerateDebugInfoImpl();
    internal virtual int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree);
    public sealed virtual override bool get_HasMethodBodyDependency();
    public sealed virtual override IMethodSymbol get_Method();
}
internal class Microsoft.CodeAnalysis.VisualBasic.SynthesizedStateMachineMoveNextMethod : SynthesizedStateMachineMethod {
    private ImmutableArray`1<VisualBasicAttributeData> _attributes;
    internal SynthesizedStateMachineMoveNextMethod(StateMachineTypeSymbol stateMachineType, MethodSymbol interfaceMethod, VisualBasicSyntaxNode syntax, Accessibility declaredAccessibility);
    internal virtual void AddSynthesizedAttributes(ModuleCompilationState compilationState, ArrayBuilder`1& attributes);
    public virtual ImmutableArray`1<VisualBasicAttributeData> GetAttributes();
}
internal class Microsoft.CodeAnalysis.VisualBasic.SynthesizedStateMachineProperty : SynthesizedPropertyBase {
    private SynthesizedStateMachineMethod _getter;
    private string _name;
    private PropertySymbol ImplementedProperty { get; }
    public ImmutableArray`1<PropertySymbol> ExplicitInterfaceImplementations { get; }
    public string Name { get; }
    public Symbol ContainingSymbol { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public MethodSymbol GetMethod { get; }
    public bool IsImplicitlyDeclared { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public MethodSymbol SetMethod { get; }
    public TypeSymbol Type { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public int ParameterCount { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public Accessibility DeclaredAccessibility { get; }
    internal CallingConvention CallingConvention { get; }
    public bool IsShared { get; }
    public bool HasMethodBodyDependency { get; }
    public IMethodSymbol Method { get; }
    internal SynthesizedStateMachineProperty(StateMachineTypeSymbol stateMachineType, string name, MethodSymbol interfacePropertyGetter, VisualBasicSyntaxNode syntax, Accessibility declaredAccessibility);
    private PropertySymbol get_ImplementedProperty();
    public virtual ImmutableArray`1<PropertySymbol> get_ExplicitInterfaceImplementations();
    public virtual string get_Name();
    public virtual Symbol get_ContainingSymbol();
    public virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public virtual MethodSymbol get_GetMethod();
    public virtual bool get_IsImplicitlyDeclared();
    public virtual ImmutableArray`1<Location> get_Locations();
    public virtual MethodSymbol get_SetMethod();
    public virtual TypeSymbol get_Type();
    public virtual ImmutableArray`1<ParameterSymbol> get_Parameters();
    public virtual int get_ParameterCount();
    public virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
    public virtual Accessibility get_DeclaredAccessibility();
    internal virtual CallingConvention get_CallingConvention();
    public virtual bool get_IsShared();
    public sealed virtual override bool get_HasMethodBodyDependency();
    public sealed virtual override IMethodSymbol get_Method();
}
internal class Microsoft.CodeAnalysis.VisualBasic.SynthesizedSubmissionFields : object {
    private NamedTypeSymbol _declaringSubmissionClass;
    private VisualBasicCompilation _compilation;
    private FieldSymbol _hostObjectField;
    private Dictionary`2<ImplicitNamedTypeSymbol, FieldSymbol> _previousSubmissionFieldMap;
    internal int Count { get; }
    internal IEnumerable`1<FieldSymbol> FieldSymbols { get; }
    public SynthesizedSubmissionFields(VisualBasicCompilation compilation, NamedTypeSymbol submissionClass);
    internal int get_Count();
    internal IEnumerable`1<FieldSymbol> get_FieldSymbols();
    internal FieldSymbol GetHostObjectField();
    internal FieldSymbol GetOrMakeField(ImplicitNamedTypeSymbol previousSubmissionType);
    internal void AddToType(NamedTypeSymbol containingType, PEModuleBuilder moduleBeingBuilt);
}
internal class Microsoft.CodeAnalysis.VisualBasic.SyntheticBoundNodeFactory : object {
    private NamedTypeSymbol _currentClass;
    private VisualBasicSyntaxNode _syntax;
    public DiagnosticBag Diagnostics;
    public MethodSymbol TopLevelMethod;
    public TypeCompilationState CompilationState;
    [CompilerGeneratedAttribute]
private MethodSymbol _CurrentMethod;
    public MethodSymbol CurrentMethod { get; public set; }
    public NamedTypeSymbol CurrentType { get; }
    public VisualBasicCompilation Compilation { get; }
    public VisualBasicSyntaxNode Syntax { get; public set; }
    private PEModuleBuilder EmitModule { get; }
    public SyntheticBoundNodeFactory(MethodSymbol topLevelMethod, MethodSymbol currentMethod, VisualBasicSyntaxNode node, TypeCompilationState compilationState, DiagnosticBag diagnostics);
    public SyntheticBoundNodeFactory(MethodSymbol topLevelMethod, MethodSymbol currentMethod, NamedTypeSymbol currentClass, VisualBasicSyntaxNode node, TypeCompilationState compilationState, DiagnosticBag diagnostics);
    [CompilerGeneratedAttribute]
public MethodSymbol get_CurrentMethod();
    [CompilerGeneratedAttribute]
public void set_CurrentMethod(MethodSymbol AutoPropertyValue);
    public NamedTypeSymbol get_CurrentType();
    public VisualBasicCompilation get_Compilation();
    public VisualBasicSyntaxNode get_Syntax();
    public void set_Syntax(VisualBasicSyntaxNode value);
    private PEModuleBuilder get_EmitModule();
    public void AddNestedType(NamedTypeSymbol nestedType);
    public void OpenNestedType(NamedTypeSymbol nestedType);
    public void AddField(NamedTypeSymbol containingType, FieldSymbol field);
    public void AddMethod(NamedTypeSymbol containingType, MethodSymbol method);
    public void AddProperty(NamedTypeSymbol containingType, PropertySymbol prop);
    public SynthesizedFieldSymbol StateMachineField(TypeSymbol type, Symbol implicitlyDefinedBy, string name, Accessibility accessibility);
    public SynthesizedFieldSymbol StateMachineField(TypeSymbol type, Symbol implicitlyDefinedBy, string name, SynthesizedLocalKind synthesizedKind, int slotIndex, Accessibility accessibility);
    public SynthesizedFieldSymbol StateMachineField(TypeSymbol type, Symbol implicitlyDefinedBy, string name, LocalSlotDebugInfo slotDebugInfo, int slotIndex, Accessibility accessibility);
    public GeneratedLabelSymbol GenerateLabel(string prefix);
    public BoundMeReference Me();
    public BoundExpression ReferenceOrByrefMe();
    public BoundMyBaseReference Base();
    public BoundParameter Parameter(ParameterSymbol p);
    public BoundFieldAccess Field(BoundExpression receiver, FieldSymbol f, bool isLValue);
    public BoundExpression Property(WellKnownMember member);
    public BoundExpression Property(BoundExpression receiver, WellKnownMember member);
    public BoundExpression Property(BoundExpression receiver, string name);
    public BoundExpression Property(NamedTypeSymbol receiver, string name);
    public NamedTypeSymbol SpecialType(SpecialType st);
    public NamedTypeSymbol NullableOf(TypeSymbol type);
    public NamedTypeSymbol WellKnownType(WellKnownType wt);
    public void ReportDiagnostic(DiagnosticInfo diagInfo);
    public T WellKnownMember(WellKnownMember wm, bool isOptional);
    public Symbol SpecialMember(SpecialMember sm);
    public BoundExpressionStatement Assignment(BoundExpression left, BoundExpression right);
    public BoundExpressionStatement ExpressionStatement(BoundExpression expr);
    public BoundAssignmentOperator AssignmentExpression(BoundExpression left, BoundExpression right);
    public BoundReferenceAssignment ReferenceAssignment(LocalSymbol byRefLocal, BoundExpression lValue);
    public BoundBlock Block(ImmutableArray`1<BoundStatement> statements);
    public BoundBlock Block(ImmutableArray`1<LocalSymbol> locals, ImmutableArray`1<BoundStatement> statements);
    public BoundBlock Block();
    public BoundBlock Block(BoundStatement[] statements);
    public BoundBlock Block(ImmutableArray`1<LocalSymbol> locals, BoundStatement[] statements);
    public BoundReturnStatement Return(BoundExpression expression);
    public LocalSymbol SynthesizedLocal(TypeSymbol type, SynthesizedLocalKind kind, SyntaxNode syntax);
    public ParameterSymbol SynthesizedParameter(TypeSymbol type, string name, MethodSymbol container, int ordinal);
    public BoundBinaryOperator LogicalAndAlso(BoundExpression left, BoundExpression right);
    public BoundBinaryOperator LogicalOrElse(BoundExpression left, BoundExpression right);
    public BoundBinaryOperator IntEqual(BoundExpression left, BoundExpression right);
    public BoundBinaryOperator IntLessThan(BoundExpression left, BoundExpression right);
    public BoundLiteral Literal(bool value);
    public BoundLiteral Literal(int value);
    public BoundExpression BadExpression(BoundNode[] subExpressions);
    public BoundObjectCreationExpression New(NamedTypeSymbol type, BoundExpression[] args);
    public BoundObjectCreationExpression New(MethodSymbol ctor, BoundExpression[] args);
    public BoundCall Call(BoundExpression receiver, MethodSymbol method);
    public BoundCall Call(BoundExpression receiver, MethodSymbol method, BoundExpression[] args);
    public BoundCall Call(BoundExpression receiver, MethodSymbol method, ImmutableArray`1<BoundExpression> args);
    public BoundStatement If(BoundExpression condition, BoundStatement thenClause, BoundStatement elseClause);
    public BoundTernaryConditionalExpression TernaryConditionalExpression(BoundExpression condition, BoundExpression ifTrue, BoundExpression ifFalse);
    public BoundTryCast TryCast(BoundExpression expression, TypeSymbol type);
    public BoundDirectCast DirectCast(BoundExpression expression, TypeSymbol type);
    public BoundStatement If(BoundExpression condition, BoundStatement thenClause);
    public BoundThrowStatement Throw(BoundExpression e);
    public BoundLocal Local(LocalSymbol localSym, bool isLValue);
    public BoundExpression Sequence(ImmutableArray`1<LocalSymbol> temps, BoundExpression[] parts);
    public BoundExpression Sequence(LocalSymbol temp, BoundExpression[] parts);
    public BoundExpression Sequence(BoundExpression[] parts);
    public BoundExpression Sequence(ImmutableArray`1<LocalSymbol> locals, ImmutableArray`1<BoundExpression> sideEffects, BoundExpression result);
    public BoundStatement Select(BoundExpression ex, IEnumerable`1<BoundCaseBlock> sections);
    [ConditionalAttribute("DEBUG")]
private void CheckSwitchSections(ImmutableArray`1<BoundCaseBlock> sections);
    public BoundCaseBlock SwitchSection(List`1<int> values, BoundStatement[] statements);
    public BoundGotoStatement Goto(LabelSymbol label, bool setWasCompilerGenerated);
    public BoundLabelStatement Label(LabelSymbol labelSym);
    public BoundLiteral Literal(string value);
    public BoundLiteral StringLiteral(ConstantValue value);
    public BoundArrayAccess ArrayAccess(BoundExpression array, bool isLValue, BoundExpression[] indices);
    public BoundArrayAccess ArrayAccess(BoundExpression array, bool isLValue, ImmutableArray`1<BoundExpression> indices);
    public BoundStatement BaseInitialization(BoundExpression[] args);
    public BoundStatement HiddenSequencePoint();
    public BoundExpression Null();
    public BoundExpression Null(TypeSymbol type);
    public BoundTypeExpression Type(TypeSymbol typeSym);
    public BoundExpression Typeof(WellKnownType type);
    public BoundExpression Typeof(TypeSymbol typeSym);
    public BoundTypeArguments TypeArguments(ImmutableArray`1<TypeSymbol> typeArgs);
    public BoundExpression MethodInfo(WellKnownMember meth);
    public BoundExpression MethodInfo(SpecialMember meth);
    public BoundExpression MethodInfo(MethodSymbol method);
    public BoundExpression ConstructorInfo(WellKnownMember meth);
    public BoundExpression ConstructorInfo(SpecialMember meth);
    public BoundExpression ConstructorInfo(MethodSymbol meth);
    public BoundExpression FieldInfo(FieldSymbol field);
    public BoundConversion Convert(TypeSymbol type, BoundExpression arg, bool isChecked);
    public BoundConversion Convert(TypeSymbol type, BoundExpression arg, ConversionKind convKind, bool isChecked);
    public BoundExpression Array(TypeSymbol elementType, BoundExpression[] elements);
    public BoundExpression Array(TypeSymbol elementType, ImmutableArray`1<BoundExpression> elements);
    public BoundTernaryConditionalExpression Conditional(BoundExpression condition, BoundExpression consequence, BoundExpression alternative, TypeSymbol type);
    public BoundBinaryConditionalExpression BinaryConditional(BoundExpression left, BoundExpression right);
    public BoundBinaryOperator Binary(BinaryOperatorKind kind, TypeSymbol type, BoundExpression left, BoundExpression right);
    public BoundBinaryOperator ObjectReferenceEqual(BoundExpression left, BoundExpression right);
    public BoundBinaryOperator ReferenceIsNothing(BoundExpression operand);
    public BoundBinaryOperator ReferenceIsNotNothing(BoundExpression operand);
    public BoundExpression Not(BoundExpression expression);
    public BoundStatement Try(BoundBlock tryBlock, ImmutableArray`1<BoundCatchBlock> catchBlocks, BoundBlock finallyBlock, LabelSymbol exitLabel);
    public ImmutableArray`1<BoundCatchBlock> CatchBlocks(BoundCatchBlock[] blocks);
    public BoundCatchBlock Catch(LocalSymbol local, BoundBlock block, bool isSynthesizedAsyncCatchAll);
    public BoundStatement SequencePoint(VisualBasicSyntaxNode syntax, BoundStatement statement);
    public BoundStatement SequencePoint(VisualBasicSyntaxNode syntax);
    public BoundStatement SequencePointWithSpan(VisualBasicSyntaxNode syntax, TextSpan textSpan, BoundStatement boundStatement);
    public BoundStatement NoOp(NoOpStatementFlavor flavor);
    public void CloseMethod(BoundStatement body);
    public BoundSpillSequence SpillSequence(ImmutableArray`1<LocalSymbol> locals, ImmutableArray`1<FieldSymbol> fields, ImmutableArray`1<BoundStatement> statements, BoundExpression valueOpt);
}
internal class Microsoft.CodeAnalysis.VisualBasic.TopLevelCodeBinder : SubOrFunctionBodyBinder {
    public bool IsInQuery { get; }
    public TopLevelCodeBinder(MethodSymbol scriptInitializer, Binder containingBinder);
    public virtual LocalSymbol GetLocalForFunctionValue();
    public virtual bool get_IsInQuery();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.TypeArgumentInference : object {
    public static bool Infer(MethodSymbol candidate, ImmutableArray`1<BoundExpression> arguments, ArrayBuilder`1<int> parameterToArgumentMap, ArrayBuilder`1<int> paramArrayItems, TypeSymbol delegateReturnType, BoundNode delegateReturnTypeReferenceBoundNode, ImmutableArray`1& typeArguments, InferenceLevel& inferenceLevel, Boolean& allFailedInferenceIsDueToObject, Boolean& someInferenceFailed, InferenceErrorReasons& inferenceErrorReasons, BitVector& inferredTypeByAssumption, ImmutableArray`1& typeArgumentsLocation, HashSet`1& asyncLambdaSubToFunctionMismatch, HashSet`1& useSiteDiagnostics, DiagnosticBag& diagnostic, BitVector inferTheseTypeParameters);
}
internal class Microsoft.CodeAnalysis.VisualBasic.TypeCompilationState : object {
    public VisualBasicCompilation Compilation;
    public LambdaFrame staticLambdaFrame;
    public PEModuleBuilder ModuleBuilderOpt;
    private ArrayBuilder`1<MethodWithBody> _synthesizedMethods;
    public MethodSymbol InitializeComponentOpt;
    public Dictionary`2<MethodSymbol, NamedTypeSymbol> StateMachineImplementationClass;
    private Dictionary`2<MethodSymbol, MethodSymbol> _methodWrappers;
    private Dictionary`2<MethodSymbol, ImmutableArray`1<MethodSymbol>> _initializeComponentCallTree;
    public bool HasSynthesizedMethods { get; }
    public ArrayBuilder`1<MethodWithBody> SynthesizedMethods { get; }
    public TypeCompilationState(VisualBasicCompilation compilation, PEModuleBuilder moduleBuilderOpt, MethodSymbol initializeComponentOpt);
    public bool get_HasSynthesizedMethods();
    public ArrayBuilder`1<MethodWithBody> get_SynthesizedMethods();
    public void AddSynthesizedMethod(MethodSymbol method, BoundStatement body);
    public bool HasMethodWrapper(MethodSymbol method);
    public void AddMethodWrapper(MethodSymbol method, MethodSymbol wrapper, BoundStatement body);
    public MethodSymbol GetMethodWrapper(MethodSymbol method);
    public void Free();
    public void AddToInitializeComponentCallTree(MethodSymbol method, ImmutableArray`1<MethodSymbol> callees);
    public bool CallsInitializeComponent(MethodSymbol method);
    private bool CallsInitializeComponent(MethodSymbol method, HashSet`1<MethodSymbol> visited);
}
[ExtensionAttribute]
[StandardModuleAttribute]
public class Microsoft.CodeAnalysis.VisualBasic.TypedConstantExtensions : object {
    [ExtensionAttribute]
public static string ToVisualBasicString(TypedConstant constant);
    private static string DisplayEnumConstant(TypedConstant constant);
    private static string DisplayUnsignedEnumConstant(TypedConstant constant, SpecialType splType, ulong constantToDecode, string typeName);
    private static string DisplaySignedEnumConstant(TypedConstant constant, SpecialType splType, long constantToDecode, string typeName);
}
internal class Microsoft.CodeAnalysis.VisualBasic.TypeInferenceCollection : TypeInferenceCollection`1<DominantTypeData> {
    public void AddType(TypeSymbol type, RequiredConversion conversion, BoundExpression sourceExpression);
}
internal class Microsoft.CodeAnalysis.VisualBasic.TypeInferenceCollection`1 : object {
    private ArrayBuilder`1<TDominantTypeData> _dominantTypeDataList;
    public ArrayBuilder`1<TDominantTypeData> GetTypeDataList();
    internal void FindDominantType(ArrayBuilder`1<TDominantTypeData> resultList, InferenceErrorReasons& inferenceErrorReasons, HashSet`1& useSiteDiagnostics);
    private static void AppendArrayElements(BoundArrayInitialization source, ArrayBuilder`1<BoundExpression> elements);
    private HintSatisfaction<TDominantTypeData> CheckHintSatisfaction(DominantTypeData candidateData, DominantTypeData hintData, RequiredConversion hintRestrictions, HashSet`1& useSiteDiagnostics);
}
internal class Microsoft.CodeAnalysis.VisualBasic.TypesOfImportedNamespacesMembersBinder : Binder {
    private ImmutableArray`1<NamespaceOrTypeAndImportsClausePosition> _importedSymbols;
    public TypesOfImportedNamespacesMembersBinder(Binder containingBinder, ImmutableArray`1<NamespaceOrTypeAndImportsClausePosition> importedSymbols);
    internal virtual void LookupInSingleBinder(LookupResult lookupResult, string name, int arity, LookupOptions options, Binder originalBinder, HashSet`1& useSiteDiagnostics);
    protected virtual void CollectProbableExtensionMethodsInSingleBinder(string name, ArrayBuilder`1<MethodSymbol> methods, Binder originalBinder);
    protected virtual void AddExtensionMethodLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
    internal virtual void AddLookupSymbolsInfoInSingleBinder(LookupSymbolsInfo nameSet, LookupOptions options, Binder originalBinder);
}
internal class Microsoft.CodeAnalysis.VisualBasic.TypeUnification : object {
    public static bool CanUnify(NamedTypeSymbol containingGenericType, TypeSymbol t1, TypeSymbol t2);
    private static bool CanUnifyHelper(NamedTypeSymbol containingGenericType, TypeWithModifiers t1, TypeWithModifiers t2, TypeSubstitution& substitution);
    private static void AddSubstitution(TypeSubstitution& substitution, NamedTypeSymbol targetGenericType, TypeParameterSymbol tp, TypeWithModifiers typeArgument);
    private static bool Contains(TypeSymbol type, TypeParameterSymbol typeParam);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.VisualBasic.UnaryOperatorKind : Enum {
    public int value__;
    public static UnaryOperatorKind Plus;
    public static UnaryOperatorKind Minus;
    public static UnaryOperatorKind Not;
    public static UnaryOperatorKind IntrinsicOpMask;
    public static UnaryOperatorKind Lifted;
    public static UnaryOperatorKind UserDefined;
    public static UnaryOperatorKind Implicit;
    public static UnaryOperatorKind Explicit;
    public static UnaryOperatorKind IsTrue;
    public static UnaryOperatorKind IsFalse;
    public static UnaryOperatorKind OpMask;
    public static UnaryOperatorKind Error;
}
internal class Microsoft.CodeAnalysis.VisualBasic.UnassignedVariablesWalker : DataFlowPass {
    private HashSet`1<Symbol> _result;
    protected bool SuppressRedimOperandRvalueOnPreserve { get; }
    protected bool IgnoreOutSemantics { get; }
    protected bool EnableBreakingFlowAnalysisFeatures { get; }
    private UnassignedVariablesWalker(FlowAnalysisInfo info);
    internal static HashSet`1<Symbol> Analyze(FlowAnalysisInfo info);
    protected virtual void ReportUnassigned(Symbol local, VisualBasicSyntaxNode node, ReadWriteContext<LocalState> rwContext, int slot, BoundFieldAccess boundFieldAccess);
    protected virtual bool get_SuppressRedimOperandRvalueOnPreserve();
    internal virtual void AssignLocalOnDeclaration(LocalSymbol local, BoundLocalDeclaration node);
    protected virtual bool get_IgnoreOutSemantics();
    protected virtual bool get_EnableBreakingFlowAnalysisFeatures();
}
internal class Microsoft.CodeAnalysis.VisualBasic.UnboundLambda : BoundExpression {
    private Binder _Binder;
    private SourceMemberFlags _Flags;
    private ImmutableArray`1<ParameterSymbol> _Parameters;
    private TypeSymbol _ReturnType;
    private UnboundLambdaBindingCache _BindingCache;
    public Binder Binder { get; }
    public SourceMemberFlags Flags { get; }
    public ImmutableArray`1<ParameterSymbol> Parameters { get; }
    public TypeSymbol ReturnType { get; }
    public UnboundLambdaBindingCache BindingCache { get; }
    public bool IsSingleLine { get; }
    public bool IsFunctionLambda { get; }
    public KeyValuePair`2<NamedTypeSymbol, ImmutableArray`1<Diagnostic>> InferredAnonymousDelegate { get; }
    public UnboundLambda(VisualBasicSyntaxNode syntax, Binder binder, SourceMemberFlags flags, ImmutableArray`1<ParameterSymbol> parameters, TypeSymbol returnType, UnboundLambdaBindingCache bindingCache, bool hasErrors);
    public UnboundLambda(VisualBasicSyntaxNode syntax, Binder binder, SourceMemberFlags flags, ImmutableArray`1<ParameterSymbol> parameters, TypeSymbol returnType, UnboundLambdaBindingCache bindingCache);
    public Binder get_Binder();
    public SourceMemberFlags get_Flags();
    public ImmutableArray`1<ParameterSymbol> get_Parameters();
    public TypeSymbol get_ReturnType();
    public UnboundLambdaBindingCache get_BindingCache();
    public virtual BoundNode Accept(BoundTreeVisitor visitor);
    public UnboundLambda Update(Binder binder, SourceMemberFlags flags, ImmutableArray`1<ParameterSymbol> parameters, TypeSymbol returnType, UnboundLambdaBindingCache bindingCache);
    protected virtual OperationKind ExpressionKind();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public bool get_IsSingleLine();
    public bool get_IsFunctionLambda();
    public BoundLambda Bind(TargetSignature target);
    public KeyValuePair`2<TypeSymbol, ImmutableArray`1<Diagnostic>> InferReturnType(TargetSignature target);
    public BoundLambda BindForErrorRecovery();
    public BoundLambda GetBoundLambda(TargetSignature target);
    private BoundLambda GetSingletonBoundLambda();
    private BoundLambda DoBind(TargetSignature target);
    private KeyValuePair`2<TypeSymbol, ImmutableArray`1<Diagnostic>> DoInferFunctionLambdaReturnType(TargetSignature target);
    public KeyValuePair`2<NamedTypeSymbol, ImmutableArray`1<Diagnostic>> get_InferredAnonymousDelegate();
    public bool IsInferredDelegateForThisLambda(NamedTypeSymbol delegateType);
}
internal class Microsoft.CodeAnalysis.VisualBasic.UseTwiceRewriter : object {
    public static Result UseTwice(Symbol containingMember, BoundExpression value, ArrayBuilder`1<SynthesizedLocal> temporaries);
    private static Result UseTwiceLateBoundReceiver(Symbol containingMember, BoundExpression receiverOpt, ArrayBuilder`1<SynthesizedLocal> temporaries);
    private static Result UseTwiceExpression(Symbol containingMember, BoundExpression value, ArrayBuilder`1<SynthesizedLocal> temporaries);
    private static BoundAssignmentOperator CaptureInATemp(Symbol containingMember, BoundExpression value, TypeSymbol type, ArrayBuilder`1<SynthesizedLocal> temporaries, BoundLocal& referToTemp);
    private static BoundAssignmentOperator CaptureInATemp(Symbol containingMember, BoundExpression value, ArrayBuilder`1<SynthesizedLocal> temporaries, BoundLocal& referToTemp);
    private static Result UseTwiceRValue(Symbol containingMember, BoundExpression value, ArrayBuilder`1<SynthesizedLocal> arg);
    private static Result UseTwiceArrayAccess(Symbol containingMember, BoundArrayAccess node, ArrayBuilder`1<SynthesizedLocal> arg);
    private static Result UseTwiceLValue(Symbol containingMember, BoundExpression lvalue, ArrayBuilder`1<SynthesizedLocal> temporaries);
    private static Result UseTwiceFieldAccess(Symbol containingMember, BoundFieldAccess node, ArrayBuilder`1<SynthesizedLocal> arg);
    private static Result UseTwicePropertyAccess(Symbol containingMember, BoundPropertyAccess node, ArrayBuilder`1<SynthesizedLocal> arg);
    private static Result UseTwiceLateInvocation(Symbol containingMember, BoundLateInvocation node, ArrayBuilder`1<SynthesizedLocal> arg);
    private static Result UseTwiceLateMember(Symbol containingMember, BoundLateMemberAccess node, ArrayBuilder`1<SynthesizedLocal> arg);
    private static void UseTwiceRegularArgument(Symbol containingMember, BoundExpression boundArgument, ArrayBuilder`1<SynthesizedLocal> arg, BoundExpression& first, BoundExpression& second);
    private static void UseTwiceParamArrayArgument(Symbol containingMember, BoundArrayCreation boundArray, ArrayBuilder`1<SynthesizedLocal> arg, BoundExpression& first, BoundExpression& second);
}
internal class Microsoft.CodeAnalysis.VisualBasic.UsingBlockBinder : BlockBaseBinder {
    private UsingBlockSyntax _syntax;
    private ImmutableArray`1<LocalSymbol> _locals;
    internal ImmutableArray`1<LocalSymbol> Locals { get; }
    public UsingBlockBinder(Binder enclosing, UsingBlockSyntax syntax);
    internal virtual ImmutableArray`1<LocalSymbol> get_Locals();
    private ImmutableArray`1<LocalSymbol> BuildLocals();
}
internal class Microsoft.CodeAnalysis.VisualBasic.UsingInfo : object {
    public Dictionary`2<TypeSymbol, ValueTuple`3<BoundRValuePlaceholder, BoundExpression, BoundExpression>> PlaceholderInfo;
    public UsingBlockSyntax UsingStatementSyntax;
    public UsingInfo(UsingBlockSyntax usingStatementSyntax, Dictionary`2<TypeSymbol, ValueTuple`3<BoundRValuePlaceholder, BoundExpression, BoundExpression>> placeholderInfo);
}
internal class Microsoft.CodeAnalysis.VisualBasic.VariablesDeclaredWalker : AbstractRegionControlFlowPass {
    private HashSet`1<Symbol> _variablesDeclared;
    private VariablesDeclaredWalker(FlowAnalysisInfo info, FlowAnalysisRegionInfo region);
    internal static IEnumerable`1<Symbol> Analyze(FlowAnalysisInfo info, FlowAnalysisRegionInfo region);
    private bool Analyze();
    public virtual BoundNode VisitLocalDeclaration(BoundLocalDeclaration node);
    protected virtual void VisitForStatementVariableDeclaration(BoundForStatement node);
    public virtual BoundNode VisitLambda(BoundLambda node);
    public virtual BoundNode VisitQueryableSource(BoundQueryableSource node);
    public virtual BoundNode VisitRangeVariableAssignment(BoundRangeVariableAssignment node);
    protected virtual void VisitCatchBlock(BoundCatchBlock catchBlock, LocalState& finallyState);
}
internal class Microsoft.CodeAnalysis.VisualBasic.VarianceAmbiguity : object {
    public static bool HasVarianceAmbiguity(NamedTypeSymbol containingType, NamedTypeSymbol i1, NamedTypeSymbol i2, HashSet`1& useSiteDiagnostics);
    private static void CheckCorrespondingTypeArguments(NamedTypeSymbol containingType, VarianceKind variance, TypeSymbol typeArgument1, TypeSymbol typeArgument2, Boolean& causesAmbiguity, Boolean& preventsAmbiguity, HashSet`1& useSiteDiagnostics);
}
internal class Microsoft.CodeAnalysis.VisualBasic.VBDiagnostic : DiagnosticWithInfo {
    internal VBDiagnostic(DiagnosticInfo info, Location location, bool isSuppressed);
    public virtual string ToString();
    internal virtual Diagnostic WithLocation(Location location);
    internal virtual Diagnostic WithSeverity(DiagnosticSeverity severity);
    internal virtual Diagnostic WithIsSuppressed(bool isSuppressed);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.VBLocation : Location {
    internal EmbeddedSymbolKind EmbeddedKind { get; }
    internal TextSpan PossiblyEmbeddedOrMySourceSpan { get; }
    internal SyntaxTree PossiblyEmbeddedOrMySourceTree { get; }
    internal virtual EmbeddedSymbolKind get_EmbeddedKind();
    internal virtual TextSpan get_PossiblyEmbeddedOrMySourceSpan();
    internal virtual SyntaxTree get_PossiblyEmbeddedOrMySourceTree();
}
[StandardModuleAttribute]
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[HideModuleNameAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.VBResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AggregateSyntaxNotWithinSyntaxTree { get; }
    internal static string AnonymousObjectCreationExpressionSyntaxNotWithinTree { get; }
    internal static string AssociatedTypeDoesNotHaveTypeParameters { get; }
    internal static string CannotAddCompilerSpecialTree { get; }
    internal static string CannotRemoveCompilerSpecialTree { get; }
    internal static string CantReferenceCompilationFromTypes { get; }
    internal static string ChainingSpeculativeModelIsNotSupported { get; }
    internal static string CompilationVisualBasic { get; }
    internal static string DeclarationSyntaxNotWithinSyntaxTree { get; }
    internal static string DeclarationSyntaxNotWithinTree { get; }
    internal static string ElementsCannotBeNull { get; }
    internal static string ERR_AbsentReferenceToPIA1 { get; }
    internal static string ERR_AccessMismatch6 { get; }
    internal static string ERR_AccessMismatchImplementedEvent4 { get; }
    internal static string ERR_AccessMismatchImplementedEvent6 { get; }
    internal static string ERR_AccessMismatchOutsideAssembly4 { get; }
    internal static string ERR_AddOrRemoveHandlerEvent { get; }
    internal static string ERR_AddParamWrongForWinRT { get; }
    internal static string ERR_AddRemoveParamNotEventType { get; }
    internal static string ERR_AddressOfInSelectCaseExpr { get; }
    internal static string ERR_AddressOfNotCreatableDelegate1 { get; }
    internal static string ERR_AddressOfNotDelegate1 { get; }
    internal static string ERR_AddressOfNullableMethod { get; }
    internal static string ERR_AddressOfOperandNotMethod { get; }
    internal static string ERR_AggrInitInvalidForObject { get; }
    internal static string ERR_AgnosticToMachineModule { get; }
    internal static string ERR_AmbiguousAcrossInterfaces3 { get; }
    internal static string ERR_AmbiguousCastConversion2 { get; }
    internal static string ERR_AmbiguousDelegateBinding2 { get; }
    internal static string ERR_AmbiguousImplements3 { get; }
    internal static string ERR_AmbiguousImplementsMember3 { get; }
    internal static string ERR_AmbiguousInImports2 { get; }
    internal static string ERR_AmbiguousInModules2 { get; }
    internal static string ERR_AmbiguousInNamespace2 { get; }
    internal static string ERR_AmbiguousInNamespaces2 { get; }
    internal static string ERR_AmbiguousInUnnamedNamespace1 { get; }
    internal static string ERR_AmbiguousOverrides3 { get; }
    internal static string ERR_AmbiguousWidestType3 { get; }
    internal static string ERR_AnonTypeFieldXMLNameInference { get; }
    internal static string ERR_AnonymousTypeDisallowsTypeChar { get; }
    internal static string ERR_AnonymousTypeExpectedIdentifier { get; }
    internal static string ERR_AnonymousTypeFieldNameInference { get; }
    internal static string ERR_AnonymousTypeNameWithoutPeriod { get; }
    internal static string ERR_AnonymousTypeNeedField { get; }
    internal static string ERR_AnonymousTypePropertyOutOfOrder1 { get; }
    internal static string ERR_ArgumentCopyBackNarrowing3 { get; }
    internal static string ERR_ArgumentNarrowing2 { get; }
    internal static string ERR_ArgumentNarrowing3 { get; }
    internal static string ERR_ArgumentRequired { get; }
    internal static string ERR_ArgumentSyntax { get; }
    internal static string ERR_ArrayInitForNonArray2 { get; }
    internal static string ERR_ArrayInitializerForNonConstDim { get; }
    internal static string ERR_ArrayInitializerTooFewDimensions { get; }
    internal static string ERR_ArrayInitializerTooManyDimensions { get; }
    internal static string ERR_ArrayInitInStruct { get; }
    internal static string ERR_ArrayInitNoType { get; }
    internal static string ERR_ArrayInitNoTypeObjectDisallowed { get; }
    internal static string ERR_ArrayInitTooManyTypesObjectDisallowed { get; }
    internal static string ERR_ArrayOfRawGenericInvalid { get; }
    internal static string ERR_ArrayRankLimit { get; }
    internal static string ERR_AsNewArray { get; }
    internal static string ERR_AsyncSubMain { get; }
    internal static string ERR_AttrAssignmentNotFieldOrProp1 { get; }
    internal static string ERR_AttrCannotBeGenerics { get; }
    internal static string ERR_AttributeCannotBeAbstract { get; }
    internal static string ERR_AttributeMustBeClassNotStruct1 { get; }
    internal static string ERR_AttributeMustInheritSysAttr { get; }
    internal static string ERR_AttributeOnLambdaReturnType { get; }
    internal static string ERR_AttributeOrder { get; }
    internal static string ERR_AttributeParameterRequired1 { get; }
    internal static string ERR_AttributeParameterRequired2 { get; }
    internal static string ERR_AttributeStmtWrongOrder { get; }
    internal static string ERR_AutoPropertyCantBeWriteOnly { get; }
    internal static string ERR_AutoPropertyCantHaveParams { get; }
    internal static string ERR_AutoPropertyInitializedInStructure { get; }
    internal static string ERR_BadAnonymousTypeForExprTree { get; }
    internal static string ERR_BadAsyncByRefParam { get; }
    internal static string ERR_BadAsyncInQuery { get; }
    internal static string ERR_BadAsyncReturn { get; }
    internal static string ERR_BadAsyncReturnOperand1 { get; }
    internal static string ERR_BadAttribute1 { get; }
    internal static string ERR_BadAttributeConstructor1 { get; }
    internal static string ERR_BadAttributeConstructor2 { get; }
    internal static string ERR_BadAttributeNonPublicConstructor { get; }
    internal static string ERR_BadAttributeNonPublicContType2 { get; }
    internal static string ERR_BadAttributeNonPublicProperty1 { get; }
    internal static string ERR_BadAttributeNonPublicType1 { get; }
    internal static string ERR_BadAttributePropertyType1 { get; }
    internal static string ERR_BadAttributeReadOnlyProperty1 { get; }
    internal static string ERR_BadAttributeSharedProperty1 { get; }
    internal static string ERR_BadAttributeUuid2 { get; }
    internal static string ERR_BadAwaitInNonAsyncLambda { get; }
    internal static string ERR_BadAwaitInNonAsyncMethod { get; }
    internal static string ERR_BadAwaitInNonAsyncVoidMethod { get; }
    internal static string ERR_BadAwaitInTryHandler { get; }
    internal static string ERR_BadAwaitNothing { get; }
    internal static string ERR_BadAwaitNotInAsyncMethodOrLambda { get; }
    internal static string ERR_BadCCExpression { get; }
    internal static string ERR_BadClassFlags1 { get; }
    internal static string ERR_BadCodepage { get; }
    internal static string ERR_BadCompilationOption { get; }
    internal static string ERR_BadConditionalWithRef { get; }
    internal static string ERR_BadConstFlags1 { get; }
    internal static string ERR_BadConstraintSyntax { get; }
    internal static string ERR_BadDeclareFlags1 { get; }
    internal static string ERR_BadDelegateFlags1 { get; }
    internal static string ERR_BadDimFlags1 { get; }
    internal static string ERR_BadEmptyEnum1 { get; }
    internal static string ERR_BadEnumFlags1 { get; }
    internal static string ERR_BadEventFlags1 { get; }
    internal static string ERR_BadFlagsInNotInheritableClass1 { get; }
    internal static string ERR_BadFlagsOnNew1 { get; }
    internal static string ERR_BadFlagsOnNewOverloads { get; }
    internal static string ERR_BadFlagsOnSharedMeth1 { get; }
    internal static string ERR_BadFlagsOnSharedProperty1 { get; }
    internal static string ERR_BadFlagsOnStdModuleProperty1 { get; }
    internal static string ERR_BadFlagsWithDefault1 { get; }
    internal static string ERR_BadGenericParamForNewConstraint2 { get; }
    internal static string ERR_BadGetAwaiterMethod1 { get; }
    internal static string ERR_BadImplementsType { get; }
    internal static string ERR_BadInstanceMemberAccess { get; }
    internal static string ERR_BadInterfaceClassSpecifier1 { get; }
    internal static string ERR_BadInterfaceDelegateSpecifier1 { get; }
    internal static string ERR_BadInterfaceEnumSpecifier1 { get; }
    internal static string ERR_BadInterfaceFlags1 { get; }
    internal static string ERR_BadInterfaceInterfaceSpecifier1 { get; }
    internal static string ERR_BadInterfaceMethodFlags1 { get; }
    internal static string ERR_BadInterfaceOrderOnInherits { get; }
    internal static string ERR_BadInterfacePropertyFlags1 { get; }
    internal static string ERR_BadInterfaceStructSpecifier1 { get; }
    internal static string ERR_BadIsCompletedOnCompletedGetResult2 { get; }
    internal static string ERR_BadIteratorByRefParam { get; }
    internal static string ERR_BadIteratorExpressionLambda { get; }
    internal static string ERR_BadIteratorReturn { get; }
    internal static string ERR_BadLocalConstFlags1 { get; }
    internal static string ERR_BadLocalDimFlags1 { get; }
    internal static string ERR_BadMetaDataReference1 { get; }
    internal static string ERR_BadMethodFlags1 { get; }
    internal static string ERR_BadModuleFile1 { get; }
    internal static string ERR_BadModuleFlags1 { get; }
    internal static string ERR_BadNamespaceName1 { get; }
    internal static string ERR_BadNullTypeInCCExpression { get; }
    internal static string ERR_BadOperatorFlags1 { get; }
    internal static string ERR_BadOverloadCandidates2 { get; }
    internal static string ERR_BadOverrideAccess2 { get; }
    internal static string ERR_BadPdbData { get; }
    internal static string ERR_BadPropertyAccessorFlags { get; }
    internal static string ERR_BadPropertyAccessorFlags1 { get; }
    internal static string ERR_BadPropertyAccessorFlags2 { get; }
    internal static string ERR_BadPropertyAccessorFlags3 { get; }
    internal static string ERR_BadPropertyAccessorFlagsRestrict { get; }
    internal static string ERR_BadPropertyFlags1 { get; }
    internal static string ERR_BadRecordFlags1 { get; }
    internal static string ERR_BadRefLib1 { get; }
    internal static string ERR_BadResumableAccessReturnVariable { get; }
    internal static string ERR_BadReturnValueInIterator { get; }
    internal static string ERR_BadSpecifierCombo2 { get; }
    internal static string ERR_BadStaticInitializerInResumable { get; }
    internal static string ERR_BadStaticLocalInGenericMethod { get; }
    internal static string ERR_BadStaticLocalInStruct { get; }
    internal static string ERR_BadTypeArgForRefConstraint2 { get; }
    internal static string ERR_BadTypeArgForStructConstraint2 { get; }
    internal static string ERR_BadTypeArgForStructConstraintNull { get; }
    internal static string ERR_BadTypeInCCExpression { get; }
    internal static string ERR_BadUseOfVoid { get; }
    internal static string ERR_BadWithEventsFlags1 { get; }
    internal static string ERR_BadWithRef { get; }
    internal static string ERR_BadYieldInNonIteratorMethod { get; }
    internal static string ERR_BadYieldInTryHandler { get; }
    internal static string ERR_BaseMismatchForPartialClass3 { get; }
    internal static string ERR_BaseOnlyClassesMustBeExplicit2 { get; }
    internal static string ERR_BaseTypeReferences2 { get; }
    internal static string ERR_BaseUnifiesWithInterfaces3 { get; }
    internal static string ERR_BinaryFile { get; }
    internal static string ERR_BinaryOperands3 { get; }
    internal static string ERR_BinaryOperandsForXml4 { get; }
    internal static string ERR_BinaryParamMustBeContainingType1 { get; }
    internal static string ERR_BlockLocalShadowing1 { get; }
    internal static string ERR_BogusWithinLineIf { get; }
    internal static string ERR_BranchOutOfFinally { get; }
    internal static string ERR_ByRefIllegal1 { get; }
    internal static string ERR_ByRefParamInExpressionTree { get; }
    internal static string ERR_CannotBeMadeNullable1 { get; }
    internal static string ERR_CannotCallEvent1 { get; }
    internal static string ERR_CannotConvertValue2 { get; }
    internal static string ERR_CannotEmbedInterfaceWithGeneric { get; }
    internal static string ERR_CannotGotoNonScopeBlocksWithClosure { get; }
    internal static string ERR_CannotInferNullableForVariable1 { get; }
    internal static string ERR_CannotLiftAnonymousType1 { get; }
    internal static string ERR_CannotLiftByRefParamLambda1 { get; }
    internal static string ERR_CannotLiftByRefParamQuery1 { get; }
    internal static string ERR_CannotLiftRestrictedTypeLambda { get; }
    internal static string ERR_CannotLiftRestrictedTypeQuery { get; }
    internal static string ERR_CannotLiftRestrictedTypeResumable1 { get; }
    internal static string ERR_CannotLiftStructureMeLambda { get; }
    internal static string ERR_CannotLiftStructureMeQuery { get; }
    internal static string ERR_CannotLinkClassWithNoPIA1 { get; }
    internal static string ERR_CannotOverrideInAccessibleMember { get; }
    internal static string ERR_CannotUseGenericTypeAcrossAssemblyBoundaries { get; }
    internal static string ERR_CannotUseOnErrorGotoWithClosure { get; }
    internal static string ERR_CantAssignToConst { get; }
    internal static string ERR_CantAwaitAsyncSub1 { get; }
    internal static string ERR_CantCallIIF { get; }
    internal static string ERR_CantCombineInitializers { get; }
    internal static string ERR_CantHaveWin32ResAndManifest { get; }
    internal static string ERR_CantOpenFileWrite { get; }
    internal static string ERR_CantOverride4 { get; }
    internal static string ERR_CantOverrideConstructor { get; }
    internal static string ERR_CantOverrideNotOverridable2 { get; }
    internal static string ERR_CantRaiseBaseEvent { get; }
    internal static string ERR_CantReadRulesetFile { get; }
    internal static string ERR_CantReferToMyGroupInsideGroupType1 { get; }
    internal static string ERR_CantShadowAMustOverride1 { get; }
    internal static string ERR_CantSpecifyArrayAndNullableOnBoth { get; }
    internal static string ERR_CantSpecifyArraysOnBoth { get; }
    internal static string ERR_CantSpecifyAsNewAndNullable { get; }
    internal static string ERR_CantSpecifyNullableOnBoth { get; }
    internal static string ERR_CantSpecifyParamsOnLambdaParamNoType { get; }
    internal static string ERR_CantSpecifyTypeCharacterOnIIF { get; }
    internal static string ERR_CantThrowNonException { get; }
    internal static string ERR_CantUseRequiredAttribute { get; }
    internal static string ERR_CaseAfterCaseElse { get; }
    internal static string ERR_CaseElseNoSelect { get; }
    internal static string ERR_CaseNoSelect { get; }
    internal static string ERR_CatchAfterFinally { get; }
    internal static string ERR_CatchNoMatchingTry { get; }
    internal static string ERR_CatchNotException1 { get; }
    internal static string ERR_CatchVariableNotLocal1 { get; }
    internal static string ERR_CharToIntegralTypeMismatch1 { get; }
    internal static string ERR_CircularBaseDependencies4 { get; }
    internal static string ERR_CircularEvaluation1 { get; }
    internal static string ERR_CircularInference1 { get; }
    internal static string ERR_ClashWithReservedEnumMember1 { get; }
    internal static string ERR_ClassConstraintNotInheritable1 { get; }
    internal static string ERR_ClassInheritsBaseUnifiesWithInterfaces3 { get; }
    internal static string ERR_ClassInheritsInterfaceBaseUnifiesWithBase4 { get; }
    internal static string ERR_ClassInheritsInterfaceUnifiesWithBase3 { get; }
    internal static string ERR_ClassNotExpression1 { get; }
    internal static string ERR_CmdOptionConflictsSource { get; }
    internal static string ERR_CoClassMissing2 { get; }
    internal static string ERR_CollisionWithPublicTypeInModule { get; }
    internal static string ERR_ComClassAndReservedAttribute1 { get; }
    internal static string ERR_ComClassCantBeAbstract0 { get; }
    internal static string ERR_ComClassDuplicateGuids1 { get; }
    internal static string ERR_ComClassGenericMethod { get; }
    internal static string ERR_ComClassOnGeneric { get; }
    internal static string ERR_ComClassRequiresPublicClass1 { get; }
    internal static string ERR_ComClassRequiresPublicClass2 { get; }
    internal static string ERR_ComClassReservedDispId1 { get; }
    internal static string ERR_ComClassReservedDispIdZero1 { get; }
    internal static string ERR_ConditionOperatorRequired3 { get; }
    internal static string ERR_ConflictDefaultPropertyAttribute { get; }
    internal static string ERR_ConflictingDirectConstraints3 { get; }
    internal static string ERR_ConflictingMachineModule { get; }
    internal static string ERR_ConflictingManifestSwitches { get; }
    internal static string ERR_ConstantStringTooLong { get; }
    internal static string ERR_ConstantWithNoValue { get; }
    internal static string ERR_ConstAsNonConstant { get; }
    internal static string ERR_ConstNotClassInterfaceOrTypeParam1 { get; }
    internal static string ERR_ConstraintAlreadyExists1 { get; }
    internal static string ERR_ConstraintClashDirectIndirect3 { get; }
    internal static string ERR_ConstraintClashIndirectDirect3 { get; }
    internal static string ERR_ConstraintClashIndirectIndirect4 { get; }
    internal static string ERR_ConstraintCycle2 { get; }
    internal static string ERR_ConstraintCycleLink2 { get; }
    internal static string ERR_ConstraintIsRestrictedType1 { get; }
    internal static string ERR_ConstructorAsync { get; }
    internal static string ERR_ConstructorCannotBeDeclaredPartial { get; }
    internal static string ERR_ConstructorFunction { get; }
    internal static string ERR_ConstructorNotFound1 { get; }
    internal static string ERR_ContinueDoNotWithinDo { get; }
    internal static string ERR_ContinueForNotWithinFor { get; }
    internal static string ERR_ContinueWhileNotWithinWhile { get; }
    internal static string ERR_ConversionFromBaseType { get; }
    internal static string ERR_ConversionFromDerivedType { get; }
    internal static string ERR_ConversionFromInterfaceType { get; }
    internal static string ERR_ConversionFromObject { get; }
    internal static string ERR_ConversionToBaseType { get; }
    internal static string ERR_ConversionToDerivedType { get; }
    internal static string ERR_ConversionToInterfaceType { get; }
    internal static string ERR_ConversionToObject { get; }
    internal static string ERR_ConversionToSameType { get; }
    internal static string ERR_ConvertArrayMismatch4 { get; }
    internal static string ERR_ConvertArrayRankMismatch2 { get; }
    internal static string ERR_ConvertObjectArrayMismatch3 { get; }
    internal static string ERR_ConvMustBeWideningOrNarrowing { get; }
    internal static string ERR_ConvParamMustBeContainingType1 { get; }
    internal static string ERR_CopyBackTypeMismatch3 { get; }
    internal static string ERR_CryptoHashFailed { get; }
    internal static string ERR_CustomEventInvInInterface { get; }
    internal static string ERR_CustomEventRequiresAs { get; }
    internal static string ERR_DateToDoubleConversion { get; }
    internal static string ERR_DebugEntryPointNotSourceMethodDefinition { get; }
    internal static string ERR_DeclaresCantBeInGeneric { get; }
    internal static string ERR_DefaultEventNotFound1 { get; }
    internal static string ERR_DefaultMemberNotProperty1 { get; }
    internal static string ERR_DefaultMissingFromProperty2 { get; }
    internal static string ERR_DefaultPropertyAmbiguousAcrossInterfaces4 { get; }
    internal static string ERR_DefaultPropertyWithNoParams { get; }
    internal static string ERR_DefaultValueForNonOptionalParam { get; }
    internal static string ERR_DelegateBindingFailure3 { get; }
    internal static string ERR_DelegateBindingIncompatible2 { get; }
    internal static string ERR_DelegateBindingIncompatible3 { get; }
    internal static string ERR_DelegateBindingMismatch { get; }
    internal static string ERR_DelegateBindingMismatchStrictOff2 { get; }
    internal static string ERR_DelegateBindingMismatchStrictOff3 { get; }
    internal static string ERR_DelegateBindingTypeInferenceFails { get; }
    internal static string ERR_DelegateCantHandleEvents { get; }
    internal static string ERR_DelegateCantImplement { get; }
    internal static string ERR_DelegateNoInvoke1 { get; }
    internal static string ERR_DllImportNotLegalOnDeclare { get; }
    internal static string ERR_DllImportNotLegalOnEventMethod { get; }
    internal static string ERR_DllImportNotLegalOnGetOrSet { get; }
    internal static string ERR_DllImportOnGenericSubOrFunction { get; }
    internal static string ERR_DllImportOnInstanceMethod { get; }
    internal static string ERR_DllImportOnInterfaceMethod { get; }
    internal static string ERR_DllImportOnNonEmptySubOrFunction { get; }
    internal static string ERR_DllImportOnResumableMethod { get; }
    internal static string ERR_DoesntImplementAwaitInterface2 { get; }
    internal static string ERR_DoubleToDateConversion { get; }
    internal static string ERR_DTDNotSupported { get; }
    internal static string ERR_DuplicateAccessCategoryUsed { get; }
    internal static string ERR_DuplicateAddHandlerDef { get; }
    internal static string ERR_DuplicateAggrMemberInit1 { get; }
    internal static string ERR_DuplicateAnonTypeMemberName1 { get; }
    internal static string ERR_DuplicateConversionCategoryUsed { get; }
    internal static string ERR_DuplicateDefaultProps1 { get; }
    internal static string ERR_DuplicateImport1 { get; }
    internal static string ERR_DuplicateInInherits1 { get; }
    internal static string ERR_DuplicateLocals1 { get; }
    internal static string ERR_DuplicateLocalStatic1 { get; }
    internal static string ERR_DuplicateLocalTypes3 { get; }
    internal static string ERR_DuplicateModifierCategoryUsed { get; }
    internal static string ERR_DuplicateNamedImportAlias1 { get; }
    internal static string ERR_DuplicateOption1 { get; }
    internal static string ERR_DuplicateParameterSpecifier { get; }
    internal static string ERR_DuplicateParamName1 { get; }
    internal static string ERR_DuplicatePrefix { get; }
    internal static string ERR_DuplicateProcDef1 { get; }
    internal static string ERR_DuplicatePropertyGet { get; }
    internal static string ERR_DuplicatePropertySet { get; }
    internal static string ERR_DuplicateRaiseEventDef { get; }
    internal static string ERR_DuplicateRawGenericTypeImport1 { get; }
    internal static string ERR_DuplicateReference2 { get; }
    internal static string ERR_DuplicateReferenceStrong { get; }
    internal static string ERR_DuplicateRemoveHandlerDef { get; }
    internal static string ERR_DuplicateResourceFileName1 { get; }
    internal static string ERR_DuplicateResourceName1 { get; }
    internal static string ERR_DuplicateSpecifier { get; }
    internal static string ERR_DuplicateTypeParamName1 { get; }
    internal static string ERR_DuplicateWriteabilityCategoryUsed { get; }
    internal static string ERR_DuplicateXmlAttribute { get; }
    internal static string ERR_ElseIfNoMatchingIf { get; }
    internal static string ERR_ElseNoMatchingIf { get; }
    internal static string ERR_EmbeddedExpression { get; }
    internal static string ERR_EmptyAggregateInitializer { get; }
    internal static string ERR_EncNoPIAReference { get; }
    internal static string ERR_EncodinglessSyntaxTree { get; }
    internal static string ERR_EncReferenceToAddedMember { get; }
    internal static string ERR_EncUpdateFailedMissingAttribute { get; }
    internal static string ERR_EndClassNoClass { get; }
    internal static string ERR_EndDisallowedInDllProjects { get; }
    internal static string ERR_EndExternalSource { get; }
    internal static string ERR_EndFunctionExpected { get; }
    internal static string ERR_EndIfNoMatchingIf { get; }
    internal static string ERR_EndModuleNoModule { get; }
    internal static string ERR_EndNamespaceNoNamespace { get; }
    internal static string ERR_EndOperatorExpected { get; }
    internal static string ERR_EndOperatorNotAtLineStart { get; }
    internal static string ERR_EndProp { get; }
    internal static string ERR_EndRegionNoRegion { get; }
    internal static string ERR_EndSelectNoSelect { get; }
    internal static string ERR_EndStructureNoStructure { get; }
    internal static string ERR_EndSubExpected { get; }
    internal static string ERR_EndSyncLockNoSyncLock { get; }
    internal static string ERR_EndTryNoTry { get; }
    internal static string ERR_EndUsingWithoutUsing { get; }
    internal static string ERR_EndWhileNoWhile { get; }
    internal static string ERR_EndWithWithoutWith { get; }
    internal static string ERR_EnumNotExpression1 { get; }
    internal static string ERR_EqualsOperandIsBad { get; }
    internal static string ERR_EqualsTypeMismatch { get; }
    internal static string ERR_ErrorCreatingWin32ResourceFile { get; }
    internal static string ERR_EventAddRemoveByrefParamIllegal { get; }
    internal static string ERR_EventAddRemoveHasOnlyOneParam { get; }
    internal static string ERR_EventDelegatesCantBeFunctions { get; }
    internal static string ERR_EventHandlerSignatureIncompatible2 { get; }
    internal static string ERR_EventImplMismatch5 { get; }
    internal static string ERR_EventImplRemoveHandlerParamWrong { get; }
    internal static string ERR_EventMethodOptionalParamIllegal1 { get; }
    internal static string ERR_EventNoPIANoBackingMember { get; }
    internal static string ERR_EventNotFound1 { get; }
    internal static string ERR_EventsCantBeFunctions { get; }
    internal static string ERR_EventSourceIsArray { get; }
    internal static string ERR_EventTypeNotDelegate { get; }
    internal static string ERR_ExecutableAsDeclaration { get; }
    internal static string ERR_ExitDoNotWithinDo { get; }
    internal static string ERR_ExitEventMemberNotInvalid { get; }
    internal static string ERR_ExitForNotWithinFor { get; }
    internal static string ERR_ExitFuncOfSub { get; }
    internal static string ERR_ExitOperatorNotValid { get; }
    internal static string ERR_ExitPropNot { get; }
    internal static string ERR_ExitSelectNotWithinSelect { get; }
    internal static string ERR_ExitSubOfFunc { get; }
    internal static string ERR_ExitTryNotWithinTry { get; }
    internal static string ERR_ExitWhileNotWithinWhile { get; }
    internal static string ERR_ExpectedAnd { get; }
    internal static string ERR_ExpectedArray1 { get; }
    internal static string ERR_ExpectedAs { get; }
    internal static string ERR_ExpectedAssignmentOperator { get; }
    internal static string ERR_ExpectedAssignmentOperatorInInit { get; }
    internal static string ERR_ExpectedBy { get; }
    internal static string ERR_ExpectedCase { get; }
    internal static string ERR_ExpectedComma { get; }
    internal static string ERR_ExpectedConditionalDirective { get; }
    internal static string ERR_ExpectedContinueKind { get; }
    internal static string ERR_ExpectedDeclaration { get; }
    internal static string ERR_ExpectedDiv { get; }
    internal static string ERR_ExpectedDot { get; }
    internal static string ERR_ExpectedDotAfterGlobalNameSpace { get; }
    internal static string ERR_ExpectedDotAfterMyBase { get; }
    internal static string ERR_ExpectedDotAfterMyClass { get; }
    internal static string ERR_ExpectedEndClass { get; }
    internal static string ERR_ExpectedEndExternalSource { get; }
    internal static string ERR_ExpectedEndIf { get; }
    internal static string ERR_ExpectedEndModule { get; }
    internal static string ERR_ExpectedEndNamespace { get; }
    internal static string ERR_ExpectedEndOfExpression { get; }
    internal static string ERR_ExpectedEndRegion { get; }
    internal static string ERR_ExpectedEndSelect { get; }
    internal static string ERR_ExpectedEndStructure { get; }
    internal static string ERR_ExpectedEndSyncLock { get; }
    internal static string ERR_ExpectedEndTry { get; }
    internal static string ERR_ExpectedEndUsing { get; }
    internal static string ERR_ExpectedEndWhile { get; }
    internal static string ERR_ExpectedEndWith { get; }
    internal static string ERR_ExpectedEOS { get; }
    internal static string ERR_ExpectedEQ { get; }
    internal static string ERR_ExpectedEquals { get; }
    internal static string ERR_ExpectedExitKind { get; }
    internal static string ERR_ExpectedExpression { get; }
    internal static string ERR_ExpectedForOptionStmt { get; }
    internal static string ERR_ExpectedFrom { get; }
    internal static string ERR_ExpectedGreater { get; }
    internal static string ERR_ExpectedIdentifier { get; }
    internal static string ERR_ExpectedIdentifierOrGroup { get; }
    internal static string ERR_ExpectedIn { get; }
    internal static string ERR_ExpectedInOrEq { get; }
    internal static string ERR_ExpectedIntLiteral { get; }
    internal static string ERR_ExpectedInto { get; }
    internal static string ERR_ExpectedJoin { get; }
    internal static string ERR_ExpectedLbrace { get; }
    internal static string ERR_ExpectedLoop { get; }
    internal static string ERR_ExpectedLparen { get; }
    internal static string ERR_ExpectedLT { get; }
    internal static string ERR_ExpectedMinus { get; }
    internal static string ERR_ExpectedNamedArgument { get; }
    internal static string ERR_ExpectedNext { get; }
    internal static string ERR_ExpectedOn { get; }
    internal static string ERR_ExpectedOptional { get; }
    internal static string ERR_ExpectedOptionCompare { get; }
    internal static string ERR_ExpectedProcedure { get; }
    internal static string ERR_ExpectedQualifiedNameInInit { get; }
    internal static string ERR_ExpectedQueryableSource { get; }
    internal static string ERR_ExpectedQuote { get; }
    internal static string ERR_ExpectedRbrace { get; }
    internal static string ERR_ExpectedRelational { get; }
    internal static string ERR_ExpectedResumeOrGoto { get; }
    internal static string ERR_ExpectedRparen { get; }
    internal static string ERR_ExpectedSColon { get; }
    internal static string ERR_ExpectedSingleScript { get; }
    internal static string ERR_ExpectedSpecifier { get; }
    internal static string ERR_ExpectedSQuote { get; }
    internal static string ERR_ExpectedStringLiteral { get; }
    internal static string ERR_ExpectedSubFunction { get; }
    internal static string ERR_ExpectedSubOrFunction { get; }
    internal static string ERR_ExpectedWarningKeyword { get; }
    internal static string ERR_ExpectedXmlBeginEmbedded { get; }
    internal static string ERR_ExpectedXmlEndCData { get; }
    internal static string ERR_ExpectedXmlEndComment { get; }
    internal static string ERR_ExpectedXmlEndEmbedded { get; }
    internal static string ERR_ExpectedXmlEndPI { get; }
    internal static string ERR_ExpectedXmlName { get; }
    internal static string ERR_ExpectedXmlns { get; }
    internal static string ERR_ExpectedXmlWhiteSpace { get; }
    internal static string ERR_ExportedTypeConflictsWithDeclaration { get; }
    internal static string ERR_ExportedTypesConflict { get; }
    internal static string ERR_ExpressionDoesntHaveName { get; }
    internal static string ERR_ExpressionOverflow1 { get; }
    internal static string ERR_ExpressionTreeNotSupported { get; }
    internal static string ERR_ExprTreeNoLateBind { get; }
    internal static string ERR_ExprTreeNoMultiDimArrayCreation { get; }
    internal static string ERR_ExtensionAttributeInvalid { get; }
    internal static string ERR_ExtensionMethodCannotBeLateBound { get; }
    internal static string ERR_ExtensionMethodNoParams { get; }
    internal static string ERR_ExtensionMethodNotInModule { get; }
    internal static string ERR_ExtensionMethodOptionalFirstArg { get; }
    internal static string ERR_ExtensionMethodOverloadCandidate2 { get; }
    internal static string ERR_ExtensionMethodOverloadCandidate3 { get; }
    internal static string ERR_ExtensionMethodParamArrayFirstArg { get; }
    internal static string ERR_ExtensionMethodUncallable1 { get; }
    internal static string ERR_ExtensionOnlyAllowedOnModuleSubOrFunction { get; }
    internal static string ERR_ExtraNextVariable { get; }
    internal static string ERR_ExtraSpecifiers { get; }
    internal static string ERR_FailureSigningAssembly { get; }
    internal static string ERR_FieldHasMultipleDistinctConstantValues { get; }
    internal static string ERR_FieldOfValueFieldOfMarshalByRef3 { get; }
    internal static string ERR_FileAttributeNotAssemblyOrModule { get; }
    internal static string ERR_FileNotFound { get; }
    internal static string ERR_FinallyAfterFinally { get; }
    internal static string ERR_FinallyNoMatchingTry { get; }
    internal static string ERR_ForCtlVarArraySizesSpecified { get; }
    internal static string ERR_ForEachAmbiguousIEnumerable1 { get; }
    internal static string ERR_ForEachCollectionDesignPattern1 { get; }
    internal static string ERR_ForIndexInUse1 { get; }
    internal static string ERR_ForLoopOperatorRequired2 { get; }
    internal static string ERR_ForLoopType1 { get; }
    internal static string ERR_ForwardedTypeConflictsWithDeclaration { get; }
    internal static string ERR_ForwardedTypeConflictsWithExportedType { get; }
    internal static string ERR_ForwardedTypesConflict { get; }
    internal static string ERR_ForwardedTypeUnavailable3 { get; }
    internal static string ERR_FriendAssemblyBadAccessOverride2 { get; }
    internal static string ERR_FriendAssemblyBadArguments { get; }
    internal static string ERR_FriendAssemblyNameInvalid { get; }
    internal static string ERR_FriendAssemblyStrongNameRequired { get; }
    internal static string ERR_FriendRefNotEqualToThis { get; }
    internal static string ERR_FriendRefSigningMismatch { get; }
    internal static string ERR_FullWidthAsXmlDelimiter { get; }
    internal static string ERR_FunctionResultCannotBeIndexed1 { get; }
    internal static string ERR_GeneralProjectImportsError3 { get; }
    internal static string ERR_GenericArgsOnAttributeSpecifier { get; }
    internal static string ERR_GenericClassCannotInheritAttr { get; }
    internal static string ERR_GenericConstraintNotSatisfied2 { get; }
    internal static string ERR_GenericParamBase2 { get; }
    internal static string ERR_GenericParamsOnInvalidMember { get; }
    internal static string ERR_GenericSubMainsFound1 { get; }
    internal static string ERR_GotoIntoFor { get; }
    internal static string ERR_GotoIntoSyncLock { get; }
    internal static string ERR_GotoIntoTryHandler { get; }
    internal static string ERR_GotoIntoUsing { get; }
    internal static string ERR_GotoIntoWith { get; }
    internal static string ERR_HandlesInvalidOnGenericMethod { get; }
    internal static string ERR_HandlesSyntaxInClass { get; }
    internal static string ERR_HandlesSyntaxInModule { get; }
    internal static string ERR_IconFileAndWin32ResFile { get; }
    internal static string ERR_IdentityDirectCastForFloat { get; }
    internal static string ERR_IdentNotMemberOfInterface4 { get; }
    internal static string ERR_IfNoType { get; }
    internal static string ERR_IfNoTypeObjectDisallowed { get; }
    internal static string ERR_IfTooManyTypesObjectDisallowed { get; }
    internal static string ERR_IllegalAttributeInXmlDecl { get; }
    internal static string ERR_IllegalBaseTypeReferences3 { get; }
    internal static string ERR_IllegalCallOrIndex { get; }
    internal static string ERR_IllegalChar { get; }
    internal static string ERR_IllegalCharConstant { get; }
    internal static string ERR_IllegalCondTypeInIIF { get; }
    internal static string ERR_IllegalDefaultNamespace { get; }
    internal static string ERR_IllegalOperandInIIFConversion { get; }
    internal static string ERR_IllegalOperandInIIFConversion2 { get; }
    internal static string ERR_IllegalOperandInIIFCount { get; }
    internal static string ERR_IllegalOperandInIIFName { get; }
    internal static string ERR_IllegalProcessingInstructionName { get; }
    internal static string ERR_IllegalXmlCommentChar { get; }
    internal static string ERR_IllegalXmlNameChar { get; }
    internal static string ERR_IllegalXmlnsPrefix { get; }
    internal static string ERR_IllegalXmlStartNameChar { get; }
    internal static string ERR_IllegalXmlWhiteSpace { get; }
    internal static string ERR_ImplementationMustBePrivate2 { get; }
    internal static string ERR_ImplementsGenericParam { get; }
    internal static string ERR_ImplementsOnNew { get; }
    internal static string ERR_ImplementsStmtWrongOrder { get; }
    internal static string ERR_ImplementsWithConstraintMismatch3 { get; }
    internal static string ERR_ImportAliasConflictsWithType2 { get; }
    internal static string ERR_ImportsMustBeFirst { get; }
    internal static string ERR_InAccessibleCoClass3 { get; }
    internal static string ERR_InaccessibleMember3 { get; }
    internal static string ERR_InAccessibleOverridingMethod5 { get; }
    internal static string ERR_InaccessibleReturnTypeOfMember2 { get; }
    internal static string ERR_InaccessibleSymbol2 { get; }
    internal static string ERR_IndexedNotArrayOrProc { get; }
    internal static string ERR_IndirectUnreferencedAssembly4 { get; }
    internal static string ERR_InferringNonArrayType1 { get; }
    internal static string ERR_InheritanceAccessMismatch5 { get; }
    internal static string ERR_InheritanceAccessMismatchOutside3 { get; }
    internal static string ERR_InheritanceCycle1 { get; }
    internal static string ERR_InheritanceCycleInImportedType1 { get; }
    internal static string ERR_InheritsFrom2 { get; }
    internal static string ERR_InheritsFromCantInherit3 { get; }
    internal static string ERR_InheritsFromNonClass { get; }
    internal static string ERR_InheritsFromNonInterface { get; }
    internal static string ERR_InheritsFromRestrictedType1 { get; }
    internal static string ERR_InheritsStmtWrongOrder { get; }
    internal static string ERR_InheritsTypeArgAccessMismatch7 { get; }
    internal static string ERR_InheritsTypeArgAccessMismatchOutside5 { get; }
    internal static string ERR_InitializedExpandedProperty { get; }
    internal static string ERR_InitializerExpected { get; }
    internal static string ERR_InitializerInStruct { get; }
    internal static string ERR_InitializerTooFewElements1 { get; }
    internal static string ERR_InitializerTooManyElements1 { get; }
    internal static string ERR_InitWithExplicitArraySizes { get; }
    internal static string ERR_InitWithMultipleDeclarators { get; }
    internal static string ERR_InReferencedAssembly { get; }
    internal static string ERR_IntegralToCharTypeMismatch1 { get; }
    internal static string ERR_InterfaceBaseUnifiesWithBase4 { get; }
    internal static string ERR_InterfaceCantUseEventSpecifier1 { get; }
    internal static string ERR_InterfaceCycle1 { get; }
    internal static string ERR_InterfaceEventCantUse1 { get; }
    internal static string ERR_InterfaceImplementedTwice1 { get; }
    internal static string ERR_InterfaceMemberSyntax { get; }
    internal static string ERR_InterfaceNoDefault1 { get; }
    internal static string ERR_InterfaceNotExpression1 { get; }
    internal static string ERR_InterfaceNotImplemented1 { get; }
    internal static string ERR_InterfacePossiblyImplTwice2 { get; }
    internal static string ERR_InterfaceUnifiesWithBase3 { get; }
    internal static string ERR_InterfaceUnifiesWithInterface2 { get; }
    internal static string ERR_InteropMethodWithBody1 { get; }
    internal static string ERR_InterpolatedStringFactoryError { get; }
    internal static string ERR_InterpolationAlignmentOutOfRange { get; }
    internal static string ERR_InterpolationFormatWhitespace { get; }
    internal static string ERR_InvalidAssemblyAttribute1 { get; }
    internal static string ERR_InvalidAssemblyCulture { get; }
    internal static string ERR_InvalidAssemblyCultureForExe { get; }
    internal static string ERR_InvalidAssemblyName { get; }
    internal static string ERR_InvalidAsyncIteratorModifiers { get; }
    internal static string ERR_InvalidAttributeUsage2 { get; }
    internal static string ERR_InvalidAttributeUsageOnAccessor { get; }
    internal static string ERR_InvalidAttributeValue1 { get; }
    internal static string ERR_InvalidAttributeValue2 { get; }
    internal static string ERR_InvalidCoClass1 { get; }
    internal static string ERR_InvalidConstructorCall { get; }
    internal static string ERR_InvalidDate { get; }
    internal static string ERR_InvalidDebugInformationFormat { get; }
    internal static string ERR_InvalidEndAddHandler { get; }
    internal static string ERR_InvalidEndEnum { get; }
    internal static string ERR_InvalidEndEvent { get; }
    internal static string ERR_InvalidEndFunction { get; }
    internal static string ERR_InvalidEndGet { get; }
    internal static string ERR_InvalidEndInterface { get; }
    internal static string ERR_InvalidEndOperator { get; }
    internal static string ERR_InvalidEndProperty { get; }
    internal static string ERR_InvalidEndRaiseEvent { get; }
    internal static string ERR_InvalidEndRemoveHandler { get; }
    internal static string ERR_InvalidEndSet { get; }
    internal static string ERR_InvalidEndSub { get; }
    internal static string ERR_InvalidEnumBase { get; }
    internal static string ERR_InvalidFileAlignment { get; }
    internal static string ERR_InvalidFormatForGuidForOption { get; }
    internal static string ERR_InvalidFormatSpecifier { get; }
    internal static string ERR_InvalidHandles { get; }
    internal static string ERR_InvalidImplements { get; }
    internal static string ERR_InvalidImplicitMeReference { get; }
    internal static string ERR_InvalidImplicitVar { get; }
    internal static string ERR_InvalidInNamespace { get; }
    internal static string ERR_InvalidLambdaModifier { get; }
    internal static string ERR_InvalidLiteralExponent { get; }
    internal static string ERR_InvalidMe { get; }
    internal static string ERR_InvalidMeReference { get; }
    internal static string ERR_InvalidModuleAttribute1 { get; }
    internal static string ERR_InvalidMultipleAttributeUsage1 { get; }
    internal static string ERR_InvalidMultipleAttributeUsageInNetModule2 { get; }
    internal static string ERR_InvalidNameOfSubExpression { get; }
    internal static string ERR_InvalidNewInType { get; }
    internal static string ERR_InvalidNonSerializedUsage { get; }
    internal static string ERR_InvalidOptionalParameterUsage1 { get; }
    internal static string ERR_InvalidOptionCompare { get; }
    internal static string ERR_InvalidOptionExplicit { get; }
    internal static string ERR_InvalidOptionInfer { get; }
    internal static string ERR_InvalidOptionStrict { get; }
    internal static string ERR_InvalidOptionStrictCustom { get; }
    internal static string ERR_InvalidOutputName { get; }
    internal static string ERR_InvalidOverrideDueToReturn2 { get; }
    internal static string ERR_InvalidParameterSyntax { get; }
    internal static string ERR_InvalidPathMap { get; }
    internal static string ERR_InvalidSignaturePublicKey { get; }
    internal static string ERR_InvalidSpecifierOnNonConversion1 { get; }
    internal static string ERR_InvalidStructMemberNoPIA1 { get; }
    internal static string ERR_InValidSubMainsFound1 { get; }
    internal static string ERR_InvalidSubsystemVersion { get; }
    internal static string ERR_InvalidSwitchValue { get; }
    internal static string ERR_InvalidTypeForAliasesImport2 { get; }
    internal static string ERR_InvalidUseOfCustomModifier { get; }
    internal static string ERR_InvalidUseOfKeyword { get; }
    internal static string ERR_InvalidVersionFormat { get; }
    internal static string ERR_InvalidVersionFormat2 { get; }
    internal static string ERR_InvInsideBlock { get; }
    internal static string ERR_InvInsideEndsEnum { get; }
    internal static string ERR_InvInsideEndsEvent { get; }
    internal static string ERR_InvInsideEndsInterface { get; }
    internal static string ERR_InvInsideEndsProc { get; }
    internal static string ERR_InvInsideEndsProperty { get; }
    internal static string ERR_InvInsideEnum { get; }
    internal static string ERR_InvInsideInterface { get; }
    internal static string ERR_InvInsideProc { get; }
    internal static string ERR_InvOutsideProc { get; }
    internal static string ERR_IsNestedIn2 { get; }
    internal static string ERR_IsNotOperatorGenericParam1 { get; }
    internal static string ERR_IsNotOperatorNullable1 { get; }
    internal static string ERR_IsNotOpRequiresReferenceTypes1 { get; }
    internal static string ERR_IsOperatorGenericParam1 { get; }
    internal static string ERR_IsOperatorNullable1 { get; }
    internal static string ERR_IsOperatorRequiresReferenceTypes1 { get; }
    internal static string ERR_IterationVariableShadowLocal1 { get; }
    internal static string ERR_IterationVariableShadowLocal2 { get; }
    internal static string ERR_KeywordNotAllowedInScript { get; }
    internal static string ERR_LabelNotDefined1 { get; }
    internal static string ERR_LambdaBindingMismatch1 { get; }
    internal static string ERR_LambdaBindingMismatch2 { get; }
    internal static string ERR_LambdaInSelectCaseExpr { get; }
    internal static string ERR_LambdaNotCreatableDelegate1 { get; }
    internal static string ERR_LambdaNotDelegate1 { get; }
    internal static string ERR_LambdaNoType { get; }
    internal static string ERR_LambdaNoTypeObjectDisallowed { get; }
    internal static string ERR_LambdaParamShadowLocal1 { get; }
    internal static string ERR_LambdasCannotHaveAttributes { get; }
    internal static string ERR_LambdaTooManyTypesObjectDisallowed { get; }
    internal static string ERR_LanguageVersion { get; }
    internal static string ERR_LateBoundOverloadInterfaceCall1 { get; }
    internal static string ERR_LbBadElseif { get; }
    internal static string ERR_LbElseifAfterElse { get; }
    internal static string ERR_LbElseNoMatchingIf { get; }
    internal static string ERR_LbExpectedEndIf { get; }
    internal static string ERR_LbNoMatchingIf { get; }
    internal static string ERR_LibAnycpu32bitPreferredConflict { get; }
    internal static string ERR_LibNotFound { get; }
    internal static string ERR_LineContWithCommentOrNoPrecSpace { get; }
    internal static string ERR_LinkedNetmoduleMetadataMustProvideFullPEImage { get; }
    internal static string ERR_LiteralExpected { get; }
    internal static string ERR_LocalNamedSameAsParam1 { get; }
    internal static string ERR_LocalNamedSameAsParamInLambda1 { get; }
    internal static string ERR_LocalSameAsFunc { get; }
    internal static string ERR_LocalsCannotHaveAttributes { get; }
    internal static string ERR_LocalTypeNameClash2 { get; }
    internal static string ERR_LoopControlMustNotAwait { get; }
    internal static string ERR_LoopControlMustNotBeProperty { get; }
    internal static string ERR_LoopDoubleCondition { get; }
    internal static string ERR_LoopNoMatchingDo { get; }
    internal static string ERR_LValueRequired { get; }
    internal static string ERR_MarshalUnmanagedTypeNotValidForFields { get; }
    internal static string ERR_MarshalUnmanagedTypeOnlyValidForFields { get; }
    internal static string ERR_MatchingOperatorExpected2 { get; }
    internal static string ERR_MaximumNumberOfErrors { get; }
    internal static string ERR_MemberClashesWithSynth6 { get; }
    internal static string ERR_MemberConflictWithSynth4 { get; }
    internal static string ERR_MetaDataIsNotAssembly { get; }
    internal static string ERR_MetaDataIsNotModule { get; }
    internal static string ERR_MetadataMembersAmbiguous3 { get; }
    internal static string ERR_MetadataReferencesNotSupported { get; }
    internal static string ERR_MethodAlreadyImplemented2 { get; }
    internal static string ERR_MethodBodyNotAtLineStart { get; }
    internal static string ERR_MethodMustBeFirstStatementOnLine { get; }
    internal static string ERR_MethodTypeArgsUnexpected { get; }
    internal static string ERR_MismatchedXmlEndTag { get; }
    internal static string ERR_MissingAddHandlerDef1 { get; }
    internal static string ERR_MissingEndAddHandler { get; }
    internal static string ERR_MissingEndBrack { get; }
    internal static string ERR_MissingEndEnum { get; }
    internal static string ERR_MissingEndEvent { get; }
    internal static string ERR_MissingEndGet { get; }
    internal static string ERR_MissingEndInterface { get; }
    internal static string ERR_MissingEndRaiseEvent { get; }
    internal static string ERR_MissingEndRemoveHandler { get; }
    internal static string ERR_MissingEndSet { get; }
    internal static string ERR_MissingGuidForOption { get; }
    internal static string ERR_MissingIsInTypeOf { get; }
    internal static string ERR_MissingLibInDeclare { get; }
    internal static string ERR_MissingNetModuleReference { get; }
    internal static string ERR_MissingNext { get; }
    internal static string ERR_MissingRaiseEventDef1 { get; }
    internal static string ERR_MissingRemoveHandlerDef1 { get; }
    internal static string ERR_MissingRuntimeHelper { get; }
    internal static string ERR_MissingSubscript { get; }
    internal static string ERR_MissingValuesForArraysInApplAttrs { get; }
    internal static string ERR_MissingVersionInXmlDecl { get; }
    internal static string ERR_MissingXmlEndTag { get; }
    internal static string ERR_MixingWinRTAndNETEvents { get; }
    internal static string ERR_ModuleAsType1 { get; }
    internal static string ERR_ModuleCantImplement { get; }
    internal static string ERR_ModuleCantInherit { get; }
    internal static string ERR_ModuleCantUseDLLDeclareSpecifier1 { get; }
    internal static string ERR_ModuleCantUseEventSpecifier1 { get; }
    internal static string ERR_ModuleCantUseMethodSpecifier1 { get; }
    internal static string ERR_ModuleCantUseTypeSpecifier1 { get; }
    internal static string ERR_ModuleCantUseVariableSpecifier1 { get; }
    internal static string ERR_ModuleEmitFailure { get; }
    internal static string ERR_ModuleMemberCantImplement { get; }
    internal static string ERR_ModuleNotAtNamespace { get; }
    internal static string ERR_ModulesCannotBeGeneric { get; }
    internal static string ERR_MoreThanOneValidMainWasFound2 { get; }
    internal static string ERR_MultilineLambdaMissingFunction { get; }
    internal static string ERR_MultilineLambdaMissingSub { get; }
    internal static string ERR_MultilineLambdasCannotContainOnError { get; }
    internal static string ERR_MultipleClassConstraints1 { get; }
    internal static string ERR_MultipleEventImplMismatch3 { get; }
    internal static string ERR_MultipleExtends { get; }
    internal static string ERR_MultipleNewConstraints { get; }
    internal static string ERR_MultipleOptionalParameterSpecifiers { get; }
    internal static string ERR_MultipleParameterSpecifiers { get; }
    internal static string ERR_MultipleReferenceConstraints { get; }
    internal static string ERR_MultipleValueConstraints { get; }
    internal static string ERR_MultiplyDefined1 { get; }
    internal static string ERR_MultiplyDefinedEnumMember2 { get; }
    internal static string ERR_MultiplyDefinedType3 { get; }
    internal static string ERR_MustBeInCatchToRethrow { get; }
    internal static string ERR_MustBeOverloads2 { get; }
    internal static string ERR_MustInheritEventNotOverridden { get; }
    internal static string ERR_MustInheritForNewConstraint2 { get; }
    internal static string ERR_MustOverOnNotInheritPartClsMem1 { get; }
    internal static string ERR_MustOverridesInClass1 { get; }
    internal static string ERR_MustShadow2 { get; }
    internal static string ERR_MutuallyExclusiveOptions { get; }
    internal static string ERR_MyBaseAbstractCall1 { get; }
    internal static string ERR_MyClassAbstractCall1 { get; }
    internal static string ERR_MyClassNotInClass { get; }
    internal static string ERR_MyGroupCollectionAttributeCycle { get; }
    internal static string ERR_NamedArgAlsoOmitted1 { get; }
    internal static string ERR_NamedArgAlsoOmitted2 { get; }
    internal static string ERR_NamedArgAlsoOmitted3 { get; }
    internal static string ERR_NamedArgUsedTwice1 { get; }
    internal static string ERR_NamedArgUsedTwice2 { get; }
    internal static string ERR_NamedArgUsedTwice3 { get; }
    internal static string ERR_NamedParamArrayArgument { get; }
    internal static string ERR_NamedParamNotFound1 { get; }
    internal static string ERR_NamedParamNotFound2 { get; }
    internal static string ERR_NamedParamNotFound3 { get; }
    internal static string ERR_NamedSubscript { get; }
    internal static string ERR_NameNotDeclared1 { get; }
    internal static string ERR_NameNotEvent2 { get; }
    internal static string ERR_NameNotMember2 { get; }
    internal static string ERR_NameNotMemberOfAnonymousType2 { get; }
    internal static string ERR_NameSameAsMethodTypeParam1 { get; }
    internal static string ERR_NamespaceNotAllowedInScript { get; }
    internal static string ERR_NamespaceNotAtNamespace { get; }
    internal static string ERR_NamespaceNotExpression1 { get; }
    internal static string ERR_NarrowingConversionCollection2 { get; }
    internal static string ERR_NarrowingConversionDisallowed2 { get; }
    internal static string ERR_NeedModule { get; }
    internal static string ERR_NegativeArraySize { get; }
    internal static string ERR_NestedBase2 { get; }
    internal static string ERR_NestedExternalSource { get; }
    internal static string ERR_NestedFunctionArgumentNarrowing3 { get; }
    internal static string ERR_NestedGlobalNamespace { get; }
    internal static string ERR_NestedInteropType { get; }
    internal static string ERR_NestedTypeInInheritsClause2 { get; }
    internal static string ERR_NestingViolatesCLS1 { get; }
    internal static string ERR_NetModuleNameMismatch { get; }
    internal static string ERR_NetModuleNameMustBeUnique { get; }
    internal static string ERR_NewAndValueConstraintsCombined { get; }
    internal static string ERR_NewArgsDisallowedForTypeParam { get; }
    internal static string ERR_NewCannotHandleEvents { get; }
    internal static string ERR_NewIfNullOnGenericParam { get; }
    internal static string ERR_NewIfNullOnNonClass { get; }
    internal static string ERR_NewInInterface { get; }
    internal static string ERR_NewInStruct { get; }
    internal static string ERR_NewOnAbstractClass { get; }
    internal static string ERR_NextForMismatch1 { get; }
    internal static string ERR_NextNoMatchingFor { get; }
    internal static string ERR_NoAccessibleConstructorOnBase { get; }
    internal static string ERR_NoAccessibleGet { get; }
    internal static string ERR_NoAccessibleSet { get; }
    internal static string ERR_NoAddMethod1 { get; }
    internal static string ERR_NoArgumentCountOverloadCandidates1 { get; }
    internal static string ERR_NoCallableOverloadCandidates2 { get; }
    internal static string ERR_NoConstituentArraySizes { get; }
    internal static string ERR_NoConstructorOnBase2 { get; }
    internal static string ERR_NoDefaultNotExtend1 { get; }
    internal static string ERR_NoDirectDelegateConstruction1 { get; }
    internal static string ERR_NoExplicitArraySizes { get; }
    internal static string ERR_NoGetProperty1 { get; }
    internal static string ERR_NoGlobalExpectedIdentifier { get; }
    internal static string ERR_NoGlobalInHandles { get; }
    internal static string ERR_NoMostSpecificOverload2 { get; }
    internal static string ERR_NonFieldPropertyAggrMemberInit1 { get; }
    internal static string ERR_NonNamespaceOrClassOnImport2 { get; }
    internal static string ERR_NoNonIndexProperty1 { get; }
    internal static string ERR_NoNonNarrowingOverloadCandidates2 { get; }
    internal static string ERR_NoNonObsoleteConstructorOnBase3 { get; }
    internal static string ERR_NoNonObsoleteConstructorOnBase4 { get; }
    internal static string ERR_NoPartialMethodInAddressOf1 { get; }
    internal static string ERR_NoPIAAttributeMissing2 { get; }
    internal static string ERR_NoResponseFile { get; }
    internal static string ERR_NoSetProperty1 { get; }
    internal static string ERR_NoSources { get; }
    internal static string ERR_NoSourcesOut { get; }
    internal static string ERR_NoSuitableNewForNewConstraint2 { get; }
    internal static string ERR_NoSuitableWidestType1 { get; }
    internal static string ERR_NotACollection1 { get; }
    internal static string ERR_NotMostSpecificOverload { get; }
    internal static string ERR_NotOverridableRequiresOverrides { get; }
    internal static string ERR_NoTypeArgumentCountOverloadCand1 { get; }
    internal static string ERR_NoTypecharInAlias { get; }
    internal static string ERR_NoTypecharInLabel { get; }
    internal static string ERR_NoUniqueConstructorOnBase2 { get; }
    internal static string ERR_NoViableOverloadCandidates1 { get; }
    internal static string ERR_NoWithEventsVarOnHandlesList { get; }
    internal static string ERR_NoXmlAxesLateBinding { get; }
    internal static string ERR_NoZeroCountArgumentInitCandidates1 { get; }
    internal static string ERR_NullableCharNotSupported { get; }
    internal static string ERR_NullableDisallowedForStructConstr1 { get; }
    internal static string ERR_NullableImplicit { get; }
    internal static string ERR_NullableParameterMustSpecifyType { get; }
    internal static string ERR_NullableTypeInferenceNotSupported { get; }
    internal static string ERR_NullPropagatingOpInExpressionTree { get; }
    internal static string ERR_ObjectInitializerRequiresFieldName { get; }
    internal static string ERR_ObjectReferenceNotSupplied { get; }
    internal static string ERR_ObsoleteArgumentsNeedParens { get; }
    internal static string ERR_ObsoleteAsAny { get; }
    internal static string ERR_ObsoleteEndIf { get; }
    internal static string ERR_ObsoleteExponent { get; }
    internal static string ERR_ObsoleteGetStatement { get; }
    internal static string ERR_ObsoleteGosub { get; }
    internal static string ERR_ObsoleteInvalidOnEventMember { get; }
    internal static string ERR_ObsoleteLetSetNotNeeded { get; }
    internal static string ERR_ObsoleteLineNumbersAreLabels { get; }
    internal static string ERR_ObsoleteObjectNotVariant { get; }
    internal static string ERR_ObsoleteOnGotoGosub { get; }
    internal static string ERR_ObsoleteOptionalWithoutValue { get; }
    internal static string ERR_ObsoletePropertyGetLetSet { get; }
    internal static string ERR_ObsoleteRedimAs { get; }
    internal static string ERR_ObsoleteStructureNotType { get; }
    internal static string ERR_ObsoleteWhileWend { get; }
    internal static string ERR_OfExpected { get; }
    internal static string ERR_OmittedArgument1 { get; }
    internal static string ERR_OmittedArgument2 { get; }
    internal static string ERR_OmittedArgument3 { get; }
    internal static string ERR_OmittedParamArrayArgument { get; }
    internal static string ERR_OneOrTwoParametersRequired1 { get; }
    internal static string ERR_OneParameterRequired1 { get; }
    internal static string ERR_OnErrorInSyncLock { get; }
    internal static string ERR_OnErrorInUsing { get; }
    internal static string ERR_OnlyNullLowerBound { get; }
    internal static string ERR_OnlyOneAccessorForGetSet { get; }
    internal static string ERR_OnlyOneImplementingMethodAllowed3 { get; }
    internal static string ERR_OnlyOnePartialMethodAllowed2 { get; }
    internal static string ERR_OnlyPrivatePartialMethods1 { get; }
    internal static string ERR_OpenTypeDisallowed { get; }
    internal static string ERR_OperatorDeclaredInModule { get; }
    internal static string ERR_OperatorMustBePublic { get; }
    internal static string ERR_OperatorMustBeShared { get; }
    internal static string ERR_OperatorNotOverloadable { get; }
    internal static string ERR_OperatorRequiresBoolReturnType1 { get; }
    internal static string ERR_OperatorRequiresIntegerParameter1 { get; }
    internal static string ERR_OptionalIllegal1 { get; }
    internal static string ERR_OptionalsCantBeStructGenericParams { get; }
    internal static string ERR_OptionMustBeAbsolutePath { get; }
    internal static string ERR_OptionStmtWrongOrder { get; }
    internal static string ERR_Overflow { get; }
    internal static string ERR_OverloadCandidate1 { get; }
    internal static string ERR_OverloadCandidate2 { get; }
    internal static string ERR_OverloadingPropertyKind2 { get; }
    internal static string ERR_OverloadsModifierInModule { get; }
    internal static string ERR_OverloadWithArrayVsParamArray2 { get; }
    internal static string ERR_OverloadWithByref2 { get; }
    internal static string ERR_OverloadWithDefault2 { get; }
    internal static string ERR_OverloadWithOptional2 { get; }
    internal static string ERR_OverloadWithReturnType2 { get; }
    internal static string ERR_OverriddenCandidate1 { get; }
    internal static string ERR_OverrideNotNeeded3 { get; }
    internal static string ERR_OverridesImpliesOverridable { get; }
    internal static string ERR_OverrideWithArrayVsParamArray2 { get; }
    internal static string ERR_OverrideWithByref2 { get; }
    internal static string ERR_OverrideWithConstraintMismatch2 { get; }
    internal static string ERR_OverrideWithDefault2 { get; }
    internal static string ERR_OverrideWithOptional2 { get; }
    internal static string ERR_OverrideWithOptionalTypes2 { get; }
    internal static string ERR_OverridingPropertyKind2 { get; }
    internal static string ERR_ParamArrayArgumentMismatch { get; }
    internal static string ERR_ParamArrayIllegal1 { get; }
    internal static string ERR_ParamArrayMustBeByVal { get; }
    internal static string ERR_ParamArrayMustBeLast { get; }
    internal static string ERR_ParamArrayNotArray { get; }
    internal static string ERR_ParamArrayRank { get; }
    internal static string ERR_ParamArrayWithOptArgs { get; }
    internal static string ERR_ParamArrayWrongType { get; }
    internal static string ERR_ParamDefaultValueDiffersFromAttribute { get; }
    internal static string ERR_ParameterizedPropertyInAggrInit1 { get; }
    internal static string ERR_ParameterNotValidForType { get; }
    internal static string ERR_ParamNameFunctionNameCollision { get; }
    internal static string ERR_ParamTypingInconsistency { get; }
    internal static string ERR_PartialDeclarationImplements1 { get; }
    internal static string ERR_PartialMethodDefaultParameterValueMismatch2 { get; }
    internal static string ERR_PartialMethodGenericConstraints2 { get; }
    internal static string ERR_PartialMethodMustBeEmpty { get; }
    internal static string ERR_PartialMethodParamArrayMismatch2 { get; }
    internal static string ERR_PartialMethodParamNamesMustMatch3 { get; }
    internal static string ERR_PartialMethodsMustBePrivate { get; }
    internal static string ERR_PartialMethodsMustBeSub1 { get; }
    internal static string ERR_PartialMethodsMustNotBeAsync1 { get; }
    internal static string ERR_PartialMethodTypeParamNameMismatch3 { get; }
    internal static string ERR_PartialTypeAccessMismatch3 { get; }
    internal static string ERR_PartialTypeBadMustInherit1 { get; }
    internal static string ERR_PartialTypeConstraintMismatch1 { get; }
    internal static string ERR_PartialTypeTypeParamNameMismatch3 { get; }
    internal static string ERR_PDBWritingFailed { get; }
    internal static string ERR_PermissionSetAttributeFileReadError { get; }
    internal static string ERR_PermissionSetAttributeInvalidFile { get; }
    internal static string ERR_PeWritingFailure { get; }
    internal static string ERR_PIAHasNoAssemblyGuid1 { get; }
    internal static string ERR_PIAHasNoTypeLibAttribute1 { get; }
    internal static string ERR_PlatformDoesntSupport { get; }
    internal static string ERR_PrincipalPermissionInvalidAction { get; }
    internal static string ERR_PrivateTypeOutsideType { get; }
    internal static string ERR_ProjectCCError1 { get; }
    internal static string ERR_PropertyAccessIgnored { get; }
    internal static string ERR_PropertyDoesntImplementAllAccessors { get; }
    internal static string ERR_PropertyNameConflictInMyCollection { get; }
    internal static string ERR_PropertyOrFieldNotDefined1 { get; }
    internal static string ERR_PropertySetParamCollisionWithValue { get; }
    internal static string ERR_PropMustHaveGetSet { get; }
    internal static string ERR_ProtectedTypeOutsideClass { get; }
    internal static string ERR_PublicKeyContainerFailure { get; }
    internal static string ERR_PublicKeyFileFailure { get; }
    internal static string ERR_PublicSignNoKey { get; }
    internal static string ERR_QualifiedNameNotAllowed { get; }
    internal static string ERR_QualNotObjectRecord1 { get; }
    internal static string ERR_QueryAnonTypeFieldXMLNameInference { get; }
    internal static string ERR_QueryAnonymousTypeDisallowsTypeChar { get; }
    internal static string ERR_QueryAnonymousTypeFieldNameInference { get; }
    internal static string ERR_QueryDuplicateAnonTypeMemberName1 { get; }
    internal static string ERR_QueryInvalidControlVariableName1 { get; }
    internal static string ERR_QueryNameNotDeclared { get; }
    internal static string ERR_QueryOperatorNotFound { get; }
    internal static string ERR_QueryStrictDisallowImplicitObject { get; }
    internal static string ERR_QuotedEmbeddedExpression { get; }
    internal static string ERR_RaiseEventShapeMismatch1 { get; }
    internal static string ERR_ReadOnlyAssignment { get; }
    internal static string ERR_ReadOnlyHasNoGet { get; }
    internal static string ERR_ReadOnlyHasSet { get; }
    internal static string ERR_ReadOnlyInClosure { get; }
    internal static string ERR_ReadOnlyNoAccessorFlag { get; }
    internal static string ERR_ReadOnlyProperty1 { get; }
    internal static string ERR_RecordCycle2 { get; }
    internal static string ERR_RecordEmbeds2 { get; }
    internal static string ERR_RedimNoSizes { get; }
    internal static string ERR_RedimRankMismatch { get; }
    internal static string ERR_RefAndClassTypeConstrCombined { get; }
    internal static string ERR_RefAndValueConstraintsCombined { get; }
    internal static string ERR_ReferenceComparison3 { get; }
    internal static string ERR_ReferenceDirectiveOnlyAllowedInScripts { get; }
    internal static string ERR_ReImplementingWinRTInterface4 { get; }
    internal static string ERR_ReImplementingWinRTInterface5 { get; }
    internal static string ERR_RemoveParamWrongForWinRT { get; }
    internal static string ERR_RequiredAttributeConstConversion2 { get; }
    internal static string ERR_RequiredConstConversion2 { get; }
    internal static string ERR_RequiredConstExpr { get; }
    internal static string ERR_RequiredNewCall2 { get; }
    internal static string ERR_RequiredNewCallTooMany2 { get; }
    internal static string ERR_RequiredNonObsoleteNewCall3 { get; }
    internal static string ERR_RequiredNonObsoleteNewCall4 { get; }
    internal static string ERR_ReservedAssemblyName { get; }
    internal static string ERR_ReservedXmlNamespace { get; }
    internal static string ERR_ReservedXmlPrefix { get; }
    internal static string ERR_ResourceInModule { get; }
    internal static string ERR_RestrictedAccess { get; }
    internal static string ERR_RestrictedConversion1 { get; }
    internal static string ERR_RestrictedResumableType1 { get; }
    internal static string ERR_RestrictedType1 { get; }
    internal static string ERR_ResumableLambdaInExpressionTree { get; }
    internal static string ERR_ResumablesCannotContainOnError { get; }
    internal static string ERR_ReturnFromNonFunction { get; }
    internal static string ERR_ReturnFromNonGenericTaskAsync { get; }
    internal static string ERR_ReturnWithoutValue { get; }
    internal static string ERR_RuntimeMemberNotFound2 { get; }
    internal static string ERR_SecurityAttributeInvalidAction { get; }
    internal static string ERR_SecurityAttributeInvalidActionAssembly { get; }
    internal static string ERR_SecurityAttributeInvalidActionTypeOrMethod { get; }
    internal static string ERR_SecurityAttributeInvalidTarget { get; }
    internal static string ERR_SecurityAttributeMissingAction { get; }
    internal static string ERR_SecurityCriticalAsync { get; }
    internal static string ERR_SecurityCriticalAsyncInClassOrStruct { get; }
    internal static string ERR_SetHasOnlyOneParam { get; }
    internal static string ERR_SetHasToBeByVal1 { get; }
    internal static string ERR_SetValueNotPropertyType { get; }
    internal static string ERR_ShadowingGenericParamWithMember1 { get; }
    internal static string ERR_ShadowingTypeOutsideClass1 { get; }
    internal static string ERR_SharedConstructorIllegalSpec1 { get; }
    internal static string ERR_SharedConstructorWithParams { get; }
    internal static string ERR_SharedEventNeedsSharedHandler { get; }
    internal static string ERR_SharedMemberAggrMemberInit1 { get; }
    internal static string ERR_SharedOnProcThatImpl { get; }
    internal static string ERR_SharedStructMemberCannotSpecifyNew { get; }
    internal static string ERR_SignButNoPrivateKey { get; }
    internal static string ERR_SourceInterfaceMustBeInterface { get; }
    internal static string ERR_SpecifiersInvalidOnInheritsImplOpt { get; }
    internal static string ERR_SpecifiersInvOnEventMethod { get; }
    internal static string ERR_StandaloneAttribute { get; }
    internal static string ERR_StartAttributeValue { get; }
    internal static string ERR_StartupCodeNotFound1 { get; }
    internal static string ERR_StatementLambdaInExpressionTree { get; }
    internal static string ERR_STAThreadAndMTAThread0 { get; }
    internal static string ERR_StaticInLambda { get; }
    internal static string ERR_StrictArgumentCopyBackNarrowing3 { get; }
    internal static string ERR_StrictDisallowImplicitObject { get; }
    internal static string ERR_StrictDisallowImplicitObjectLambda { get; }
    internal static string ERR_StrictDisallowsImplicitArgs { get; }
    internal static string ERR_StrictDisallowsImplicitProc { get; }
    internal static string ERR_StrictDisallowsLateBinding { get; }
    internal static string ERR_StrictDisallowsObjectComparison1 { get; }
    internal static string ERR_StrictDisallowsObjectOperand1 { get; }
    internal static string ERR_StructCantInherit { get; }
    internal static string ERR_StructCantUseDLLDeclareSpecifier1 { get; }
    internal static string ERR_StructCantUseVarSpecifier1 { get; }
    internal static string ERR_StructLayoutAttributeNotAllowed { get; }
    internal static string ERR_StructsCannotHandleEvents { get; }
    internal static string ERR_StructureCantUseProtected { get; }
    internal static string ERR_StructureNoDefault1 { get; }
    internal static string ERR_StructureNotExpression1 { get; }
    internal static string ERR_SubDisallowsStatement { get; }
    internal static string ERR_SubNewCycle1 { get; }
    internal static string ERR_SubNewCycle2 { get; }
    internal static string ERR_SubRequiresParenthesesBang { get; }
    internal static string ERR_SubRequiresParenthesesDot { get; }
    internal static string ERR_SubRequiresParenthesesLParen { get; }
    internal static string ERR_SubRequiresSingleStatement { get; }
    internal static string ERR_SwitchNeedsBool { get; }
    internal static string ERR_SxSIndirectRefHigherThanDirectRef3 { get; }
    internal static string ERR_SynchronizedAsyncMethod { get; }
    internal static string ERR_SyncLockRequiresReferenceType1 { get; }
    internal static string ERR_Syntax { get; }
    internal static string ERR_SyntaxInCastOp { get; }
    internal static string ERR_SynthMemberClashesWithMember5 { get; }
    internal static string ERR_SynthMemberClashesWithSynth7 { get; }
    internal static string ERR_SynthMemberShadowsMustOverride5 { get; }
    internal static string ERR_SyntMemberShadowsGenericParam3 { get; }
    internal static string ERR_TooFewGenericArguments1 { get; }
    internal static string ERR_TooFewGenericArguments2 { get; }
    internal static string ERR_TooFewIndices { get; }
    internal static string ERR_TooLongMetadataName { get; }
    internal static string ERR_TooLongOrComplexExpression { get; }
    internal static string ERR_TooManyArgs { get; }
    internal static string ERR_TooManyArgs1 { get; }
    internal static string ERR_TooManyArgs2 { get; }
    internal static string ERR_TooManyGenericArguments1 { get; }
    internal static string ERR_TooManyGenericArguments2 { get; }
    internal static string ERR_TooManyIndices { get; }
    internal static string ERR_TooManyUserStrings { get; }
    internal static string ERR_TryAndOnErrorDoNotMix { get; }
    internal static string ERR_TryCastOfUnconstrainedTypeParam1 { get; }
    internal static string ERR_TryCastOfValueType1 { get; }
    internal static string ERR_TryWithoutCatchOrFinally { get; }
    internal static string ERR_TwoParametersRequired1 { get; }
    internal static string ERR_TypeArgsUnexpected { get; }
    internal static string ERR_TypecharNoMatch2 { get; }
    internal static string ERR_TypecharNotallowed { get; }
    internal static string ERR_TypeCharOnAggregation { get; }
    internal static string ERR_TypeCharOnGenericParam { get; }
    internal static string ERR_TypeCharOnSub { get; }
    internal static string ERR_TypeCharWithType1 { get; }
    internal static string ERR_TypeClashesWithVbCoreType4 { get; }
    internal static string ERR_TypeConflict6 { get; }
    internal static string ERR_TypeDisallowsAttributes { get; }
    internal static string ERR_TypeDisallowsDescendants { get; }
    internal static string ERR_TypeDisallowsElements { get; }
    internal static string ERR_TypeFwdCycle2 { get; }
    internal static string ERR_TypeInferenceArrayRankMismatch1 { get; }
    internal static string ERR_TypeInferenceFailure1 { get; }
    internal static string ERR_TypeInferenceFailure2 { get; }
    internal static string ERR_TypeInferenceFailure3 { get; }
    internal static string ERR_TypeInferenceFailureAmbiguous1 { get; }
    internal static string ERR_TypeInferenceFailureAmbiguous2 { get; }
    internal static string ERR_TypeInferenceFailureAmbiguous3 { get; }
    internal static string ERR_TypeInferenceFailureNoBest1 { get; }
    internal static string ERR_TypeInferenceFailureNoBest2 { get; }
    internal static string ERR_TypeInferenceFailureNoBest3 { get; }
    internal static string ERR_TypeInferenceFailureNoExplicit1 { get; }
    internal static string ERR_TypeInferenceFailureNoExplicit2 { get; }
    internal static string ERR_TypeInferenceFailureNoExplicit3 { get; }
    internal static string ERR_TypeInferenceFailureNoExplicitAmbiguous1 { get; }
    internal static string ERR_TypeInferenceFailureNoExplicitAmbiguous2 { get; }
    internal static string ERR_TypeInferenceFailureNoExplicitAmbiguous3 { get; }
    internal static string ERR_TypeInferenceFailureNoExplicitNoBest1 { get; }
    internal static string ERR_TypeInferenceFailureNoExplicitNoBest2 { get; }
    internal static string ERR_TypeInferenceFailureNoExplicitNoBest3 { get; }
    internal static string ERR_TypeInItsInheritsClause1 { get; }
    internal static string ERR_TypeMismatch2 { get; }
    internal static string ERR_TypeMismatchForXml3 { get; }
    internal static string ERR_TypeNotExpression1 { get; }
    internal static string ERR_TypeOfExprAlwaysFalse2 { get; }
    internal static string ERR_TypeOfRequiresReferenceType1 { get; }
    internal static string ERR_TypeOrMemberNotGeneric1 { get; }
    internal static string ERR_TypeOrMemberNotGeneric2 { get; }
    internal static string ERR_TypeParamMissingAsCommaOrRParen { get; }
    internal static string ERR_TypeParamMissingCommaOrRParen { get; }
    internal static string ERR_TypeParamNameFunctionNameCollision { get; }
    internal static string ERR_TypeParamQualifierDisallowed { get; }
    internal static string ERR_TypeParamWithStructConstAsConst { get; }
    internal static string ERR_TypeRefResolutionError3 { get; }
    internal static string ERR_UnableToCreateTempFile { get; }
    internal static string ERR_UnableToOpenResourceFile1 { get; }
    internal static string ERR_UnableToReadUacManifest2 { get; }
    internal static string ERR_UnacceptableForLoopOperator2 { get; }
    internal static string ERR_UnacceptableForLoopRelOperator2 { get; }
    internal static string ERR_UnacceptableLogicalOperator3 { get; }
    internal static string ERR_UnaryOperand2 { get; }
    internal static string ERR_UnaryParamMustBeContainingType1 { get; }
    internal static string ERR_UnboundTypeParam1 { get; }
    internal static string ERR_UnboundTypeParam2 { get; }
    internal static string ERR_UnboundTypeParam3 { get; }
    internal static string ERR_UndefinedType1 { get; }
    internal static string ERR_UndefinedTypeOrNamespace1 { get; }
    internal static string ERR_UndefinedXmlPrefix { get; }
    internal static string ERR_UnexpectedExpressionStatement { get; }
    internal static string ERR_UnexpectedGroup { get; }
    internal static string ERR_UnimplementedMember3 { get; }
    internal static string ERR_UnimplementedMustOverride { get; }
    internal static string ERR_UnknownOperator { get; }
    internal static string ERR_UnrecognizedEnd { get; }
    internal static string ERR_UnrecognizedType { get; }
    internal static string ERR_UnrecognizedTypeKeyword { get; }
    internal static string ERR_UnrecognizedTypeOrWith { get; }
    internal static string ERR_UnreferencedAssembly3 { get; }
    internal static string ERR_UnreferencedAssemblyBase3 { get; }
    internal static string ERR_UnreferencedAssemblyEvent3 { get; }
    internal static string ERR_UnreferencedAssemblyImplements3 { get; }
    internal static string ERR_UnreferencedModule3 { get; }
    internal static string ERR_UnreferencedModuleBase3 { get; }
    internal static string ERR_UnreferencedModuleEvent3 { get; }
    internal static string ERR_UnreferencedModuleImplements3 { get; }
    internal static string ERR_UnsupportedConstant2 { get; }
    internal static string ERR_UnsupportedEvent1 { get; }
    internal static string ERR_UnsupportedField1 { get; }
    internal static string ERR_UnsupportedMethod1 { get; }
    internal static string ERR_UnsupportedModule1 { get; }
    internal static string ERR_UnsupportedProperty1 { get; }
    internal static string ERR_UnsupportedType1 { get; }
    internal static string ERR_UnterminatedStringLiteral { get; }
    internal static string ERR_UseOfKeywordFromModule1 { get; }
    internal static string ERR_UseOfKeywordFromStructure1 { get; }
    internal static string ERR_UseOfKeywordNotInInstanceMethod1 { get; }
    internal static string ERR_UseOfLocalBeforeDeclaration1 { get; }
    internal static string ERR_UseOfObsoletePropertyAccessor2 { get; }
    internal static string ERR_UseOfObsoletePropertyAccessor3 { get; }
    internal static string ERR_UseOfObsoleteSymbol2 { get; }
    internal static string ERR_UseOfObsoleteSymbolNoMessage1 { get; }
    internal static string ERR_UsingRequiresDisposePattern { get; }
    internal static string ERR_UsingResourceVarCantBeArray { get; }
    internal static string ERR_UsingResourceVarNeedsInitializer { get; }
    internal static string ERR_ValueAndClassTypeConstrCombined { get; }
    internal static string ERR_VarianceConversionFailedIn6 { get; }
    internal static string ERR_VarianceConversionFailedOut6 { get; }
    internal static string ERR_VarianceConversionFailedTryIn4 { get; }
    internal static string ERR_VarianceConversionFailedTryOut4 { get; }
    internal static string ERR_VarianceDisallowedHere { get; }
    internal static string ERR_VarianceIEnumerableSuggestion3 { get; }
    internal static string ERR_VarianceInByRefDisallowed1 { get; }
    internal static string ERR_VarianceInNullableDisallowed2 { get; }
    internal static string ERR_VarianceInParamDisallowed1 { get; }
    internal static string ERR_VarianceInParamDisallowedForGeneric3 { get; }
    internal static string ERR_VarianceInParamDisallowedHere2 { get; }
    internal static string ERR_VarianceInParamDisallowedHereForGeneric4 { get; }
    internal static string ERR_VarianceInPropertyDisallowed1 { get; }
    internal static string ERR_VarianceInReadOnlyPropertyDisallowed1 { get; }
    internal static string ERR_VarianceInReturnDisallowed1 { get; }
    internal static string ERR_VarianceInterfaceNesting { get; }
    internal static string ERR_VarianceOutByRefDisallowed1 { get; }
    internal static string ERR_VarianceOutByValDisallowed1 { get; }
    internal static string ERR_VarianceOutConstraintDisallowed1 { get; }
    internal static string ERR_VarianceOutNullableDisallowed2 { get; }
    internal static string ERR_VarianceOutParamDisallowed1 { get; }
    internal static string ERR_VarianceOutParamDisallowedForGeneric3 { get; }
    internal static string ERR_VarianceOutParamDisallowedHere2 { get; }
    internal static string ERR_VarianceOutParamDisallowedHereForGeneric4 { get; }
    internal static string ERR_VarianceOutPropertyDisallowed1 { get; }
    internal static string ERR_VarianceOutWriteOnlyPropertyDisallowed1 { get; }
    internal static string ERR_VariancePreventsSynthesizedEvents2 { get; }
    internal static string ERR_VarianceTypeDisallowed2 { get; }
    internal static string ERR_VarianceTypeDisallowedForGeneric4 { get; }
    internal static string ERR_VarianceTypeDisallowedHere3 { get; }
    internal static string ERR_VarianceTypeDisallowedHereForGeneric5 { get; }
    internal static string ERR_VBCoreNetModuleConflict { get; }
    internal static string ERR_VersionMustBeFirstInXmlDecl { get; }
    internal static string ERR_VoidArrayDisallowed { get; }
    internal static string ERR_VoidValue { get; }
    internal static string ERR_WinRTEventWithoutDelegate { get; }
    internal static string ERR_WithEventsAsStruct { get; }
    internal static string ERR_WithEventsRequiresClass { get; }
    internal static string ERR_WriteOnlyHasGet { get; }
    internal static string ERR_WriteOnlyHasNoWrite { get; }
    internal static string ERR_WriteOnlyNoAccessorFlag { get; }
    internal static string ERR_XmlEndCDataNotAllowedInContent { get; }
    internal static string ERR_XmlEndElementNoMatchingStart { get; }
    internal static string ERR_XmlEntityReference { get; }
    internal static string ERR_XmlFeaturesNotAvailable { get; }
    internal static string ERR_XmlPrefixNotExpression { get; }
    internal static string ERR_ZeroDivide { get; }
    internal static string FEATURE_ArrayLiterals { get; }
    internal static string FEATURE_AsyncExpressions { get; }
    internal static string FEATURE_AutoProperties { get; }
    internal static string FEATURE_CObjInAttributeArguments { get; }
    internal static string FEATURE_CoContraVariance { get; }
    internal static string FEATURE_CollectionInitializers { get; }
    internal static string FEATURE_GlobalNamespace { get; }
    internal static string FEATURE_ImplementingReadonlyOrWriteonlyPropertyWithReadwrite { get; }
    internal static string FEATURE_Iterators { get; }
    internal static string FEATURE_LineContinuation { get; }
    internal static string FEATURE_LineContinuationComments { get; }
    internal static string FEATURE_MultilineStringLiterals { get; }
    internal static string FEATURE_NameOfExpressions { get; }
    internal static string FEATURE_NullPropagatingOperator { get; }
    internal static string FEATURE_PartialInterfaces { get; }
    internal static string FEATURE_PartialModules { get; }
    internal static string FEATURE_ReadonlyAutoProperties { get; }
    internal static string FEATURE_RegionsEverywhere { get; }
    internal static string FEATURE_StatementLambdas { get; }
    internal static string FEATURE_SubLambdas { get; }
    internal static string FEATURE_TypeOfIsNot { get; }
    internal static string FEATURE_WarningDirectives { get; }
    internal static string FEATURE_YearFirstDateLiterals { get; }
    internal static string FieldInitializerSyntaxNotWithinSyntaxTree { get; }
    internal static string FTL_InputFileNameTooLong { get; }
    internal static string FunctionSyntaxNotWithinSyntaxTree { get; }
    internal static string HDN_UnusedImportClause { get; }
    internal static string HDN_UnusedImportClause_Title { get; }
    internal static string HDN_UnusedImportStatement { get; }
    internal static string HDN_UnusedImportStatement_Title { get; }
    internal static string IdentifierSyntaxNotWithinSyntaxTree { get; }
    internal static string IDS_FunctionReturnType { get; }
    internal static string IDS_InvalidPreprocessorConstantType { get; }
    internal static string IDS_LogoLine1 { get; }
    internal static string IDS_LogoLine2 { get; }
    internal static string IDS_MSG_ADDLINKREFERENCE { get; }
    internal static string IDS_MSG_ADDMODULE { get; }
    internal static string IDS_MSG_ADDREFERENCE { get; }
    internal static string IDS_ProjectSettingsLocationName { get; }
    internal static string IDS_TheSystemCannotFindThePathSpecified { get; }
    internal static string IDS_ToolName { get; }
    internal static string IDS_UnrecognizedFileFormat { get; }
    internal static string IDS_VBCHelp { get; }
    internal static string INF_UnableToLoadSomeTypesInAnalyzer { get; }
    internal static string INF_UnableToLoadSomeTypesInAnalyzer_Title { get; }
    internal static string LocationMustBeProvided { get; }
    internal static string NodeIsNotWithinSyntaxTree { get; }
    internal static string NoNoneSearchCriteria { get; }
    internal static string NotAVbSymbol { get; }
    internal static string NotWithinTree { get; }
    internal static string NumberOfTypeParametersAndArgumentsMustMatch { get; }
    internal static string PositionIsNotWithinSyntax { get; }
    internal static string PositionNotWithinTree { get; }
    internal static string PositionOfTypeParameterTooLarge { get; }
    internal static string PropertiesCanNotHaveTypeArguments { get; }
    internal static string RangeVariableSyntaxNotWithinSyntaxTree { get; }
    internal static string SemanticModelMustBeProvided { get; }
    internal static string SpeculatedSyntaxNodeCannotBelongToCurrentCompilation { get; }
    internal static string StatementOrExpressionIsNotAValidType { get; }
    internal static string SubmissionCanHaveAtMostOneSyntaxTree { get; }
    internal static string SyntaxTreeAlreadyPresent { get; }
    internal static string SyntaxTreeIsNotASubmission { get; }
    internal static string SyntaxTreeNotFoundToRemove { get; }
    internal static string ThereAreNoPointerTypesInVB { get; }
    internal static string ThereIsNoDynamicTypeInVB { get; }
    internal static string TreeMustHaveARootNodeWithCompilationUnit { get; }
    internal static string Trees0 { get; }
    internal static string TreesMustHaveRootNode { get; }
    internal static string TypeArgumentCannotBeNothing { get; }
    internal static string TypeParameterNotWithinTree { get; }
    internal static string VariableSyntaxNotWithinSyntaxTree { get; }
    internal static string WRN_AmbiguousCastConversion2 { get; }
    internal static string WRN_AmbiguousCastConversion2_Title { get; }
    internal static string WRN_AnalyzerCannotBeCreated { get; }
    internal static string WRN_AnalyzerCannotBeCreated_Title { get; }
    internal static string WRN_ArrayInitNoTypeObjectAssumed { get; }
    internal static string WRN_ArrayInitNoTypeObjectAssumed_Title { get; }
    internal static string WRN_ArrayInitTooManyTypesObjectAssumed { get; }
    internal static string WRN_ArrayInitTooManyTypesObjectAssumed_Title { get; }
    internal static string WRN_ArrayOverloadsNonCLS2 { get; }
    internal static string WRN_ArrayOverloadsNonCLS2_Title { get; }
    internal static string WRN_AssemblyAttributeFromModuleIsOverridden { get; }
    internal static string WRN_AssemblyAttributeFromModuleIsOverridden_Title { get; }
    internal static string WRN_AssemblyGeneration0 { get; }
    internal static string WRN_AssemblyGeneration0_Title { get; }
    internal static string WRN_AssemblyGeneration1 { get; }
    internal static string WRN_AssemblyGeneration1_Title { get; }
    internal static string WRN_AsyncLacksAwaits { get; }
    internal static string WRN_AsyncLacksAwaits_Title { get; }
    internal static string WRN_AsyncSubCouldBeFunction { get; }
    internal static string WRN_AsyncSubCouldBeFunction_Title { get; }
    internal static string WRN_BadChecksumValExtChecksum { get; }
    internal static string WRN_BadChecksumValExtChecksum_Title { get; }
    internal static string WRN_BadGUIDFormatExtChecksum { get; }
    internal static string WRN_BadGUIDFormatExtChecksum_Title { get; }
    internal static string WRN_BadSwitch { get; }
    internal static string WRN_BadSwitch_Title { get; }
    internal static string WRN_BadUILang { get; }
    internal static string WRN_BadUILang_Title { get; }
    internal static string WRN_BaseClassNotCLSCompliant2 { get; }
    internal static string WRN_BaseClassNotCLSCompliant2_Title { get; }
    internal static string WRN_CannotFindStandardLibrary1 { get; }
    internal static string WRN_CannotFindStandardLibrary1_Title { get; }
    internal static string WRN_CLSAttrInvalidOnGetSet { get; }
    internal static string WRN_CLSAttrInvalidOnGetSet_Title { get; }
    internal static string WRN_CLSEventMethodInNonCLSType3 { get; }
    internal static string WRN_CLSEventMethodInNonCLSType3_Title { get; }
    internal static string WRN_CLSMemberInNonCLSType3 { get; }
    internal static string WRN_CLSMemberInNonCLSType3_Title { get; }
    internal static string WRN_ComClassInterfaceShadows5 { get; }
    internal static string WRN_ComClassInterfaceShadows5_Title { get; }
    internal static string WRN_ComClassNoMembers1 { get; }
    internal static string WRN_ComClassNoMembers1_Title { get; }
    internal static string WRN_ComClassPropertySetObject1 { get; }
    internal static string WRN_ComClassPropertySetObject1_Title { get; }
    internal static string WRN_ConditionalNotValidOnFunction { get; }
    internal static string WRN_ConditionalNotValidOnFunction_Title { get; }
    internal static string WRN_ConflictingMachineAssembly { get; }
    internal static string WRN_ConflictingMachineAssembly_Title { get; }
    internal static string WRN_ConstraintsFailedForInferredArgs2 { get; }
    internal static string WRN_ConstraintsFailedForInferredArgs2_Title { get; }
    internal static string WRN_DebuggerHiddenIgnoredOnProperties { get; }
    internal static string WRN_DebuggerHiddenIgnoredOnProperties_Title { get; }
    internal static string WRN_DefAsgNoRetValFuncRef1 { get; }
    internal static string WRN_DefAsgNoRetValFuncRef1_Title { get; }
    internal static string WRN_DefAsgNoRetValFuncVal1 { get; }
    internal static string WRN_DefAsgNoRetValFuncVal1_Title { get; }
    internal static string WRN_DefAsgNoRetValOpRef1 { get; }
    internal static string WRN_DefAsgNoRetValOpRef1_Title { get; }
    internal static string WRN_DefAsgNoRetValOpVal1 { get; }
    internal static string WRN_DefAsgNoRetValOpVal1_Title { get; }
    internal static string WRN_DefAsgNoRetValPropRef1 { get; }
    internal static string WRN_DefAsgNoRetValPropRef1_Title { get; }
    internal static string WRN_DefAsgNoRetValPropVal1 { get; }
    internal static string WRN_DefAsgNoRetValPropVal1_Title { get; }
    internal static string WRN_DefAsgNoRetValWinRtEventVal1 { get; }
    internal static string WRN_DefAsgNoRetValWinRtEventVal1_Title { get; }
    internal static string WRN_DefAsgUseNullRef { get; }
    internal static string WRN_DefAsgUseNullRef_Title { get; }
    internal static string WRN_DefAsgUseNullRefByRef { get; }
    internal static string WRN_DefAsgUseNullRefByRef_Title { get; }
    internal static string WRN_DefAsgUseNullRefByRefStr { get; }
    internal static string WRN_DefAsgUseNullRefByRefStr_Title { get; }
    internal static string WRN_DefAsgUseNullRefStr { get; }
    internal static string WRN_DefAsgUseNullRefStr_Title { get; }
    internal static string WRN_DefaultnessShadowed4 { get; }
    internal static string WRN_DefaultnessShadowed4_Title { get; }
    internal static string WRN_DelaySignButNoKey { get; }
    internal static string WRN_DelaySignButNoKey_Title { get; }
    internal static string WRN_DuplicateCatch { get; }
    internal static string WRN_DuplicateCatch_Title { get; }
    internal static string WRN_EmptyPrefixAndXmlnsLocalName { get; }
    internal static string WRN_EmptyPrefixAndXmlnsLocalName_Title { get; }
    internal static string WRN_EnumUnderlyingTypeNotCLS1 { get; }
    internal static string WRN_EnumUnderlyingTypeNotCLS1_Title { get; }
    internal static string WRN_EqualToLiteralNothing { get; }
    internal static string WRN_EqualToLiteralNothing_Title { get; }
    internal static string WRN_EventDelegateTypeNotCLSCompliant2 { get; }
    internal static string WRN_EventDelegateTypeNotCLSCompliant2_Title { get; }
    internal static string WRN_ExpectedInitComponentCall2 { get; }
    internal static string WRN_ExpectedInitComponentCall2_Title { get; }
    internal static string WRN_FieldNotCLSCompliant1 { get; }
    internal static string WRN_FieldNotCLSCompliant1_Title { get; }
    internal static string WRN_FileAlreadyIncluded { get; }
    internal static string WRN_FileAlreadyIncluded_Title { get; }
    internal static string WRN_GenericConstraintNotCLSCompliant1 { get; }
    internal static string WRN_GenericConstraintNotCLSCompliant1_Title { get; }
    internal static string WRN_IfNoTypeObjectAssumed { get; }
    internal static string WRN_IfNoTypeObjectAssumed_Title { get; }
    internal static string WRN_IfTooManyTypesObjectAssumed { get; }
    internal static string WRN_IfTooManyTypesObjectAssumed_Title { get; }
    internal static string WRN_IgnoreModuleManifest { get; }
    internal static string WRN_IgnoreModuleManifest_Title { get; }
    internal static string WRN_ImplicitConversion2 { get; }
    internal static string WRN_ImplicitConversion2_Title { get; }
    internal static string WRN_ImplicitConversionCopyBack { get; }
    internal static string WRN_ImplicitConversionCopyBack_Title { get; }
    internal static string WRN_ImplicitConversionSubst1 { get; }
    internal static string WRN_ImplicitConversionSubst1_Title { get; }
    internal static string WRN_IndirectRefToLinkedAssembly2 { get; }
    internal static string WRN_IndirectRefToLinkedAssembly2_Title { get; }
    internal static string WRN_InheritedInterfaceNotCLSCompliant2 { get; }
    internal static string WRN_InheritedInterfaceNotCLSCompliant2_Title { get; }
    internal static string WRN_InterfaceConversion2 { get; }
    internal static string WRN_InterfaceConversion2_Title { get; }
    internal static string WRN_InvalidAssemblyName { get; }
    internal static string WRN_InvalidAssemblyName_Title { get; }
    internal static string WRN_InvalidVersionFormat { get; }
    internal static string WRN_InvalidVersionFormat_Title { get; }
    internal static string WRN_InvalidWarningId { get; }
    internal static string WRN_InvalidWarningId_Title { get; }
    internal static string WRN_LambdaNoTypeObjectAssumed { get; }
    internal static string WRN_LambdaNoTypeObjectAssumed_Title { get; }
    internal static string WRN_LambdaPassedToRemoveHandler { get; }
    internal static string WRN_LambdaPassedToRemoveHandler_Title { get; }
    internal static string WRN_LambdaTooManyTypesObjectAssumed { get; }
    internal static string WRN_LambdaTooManyTypesObjectAssumed_Title { get; }
    internal static string WRN_LateBindingResolution { get; }
    internal static string WRN_LateBindingResolution_Title { get; }
    internal static string WRN_LiftControlVariableLambda { get; }
    internal static string WRN_LiftControlVariableLambda_Title { get; }
    internal static string WRN_LiftControlVariableQuery { get; }
    internal static string WRN_LiftControlVariableQuery_Title { get; }
    internal static string WRN_MainIgnored { get; }
    internal static string WRN_MainIgnored_Title { get; }
    internal static string WRN_MemberShadowsSynthMember6 { get; }
    internal static string WRN_MemberShadowsSynthMember6_Title { get; }
    internal static string WRN_MissingAsClauseinFunction { get; }
    internal static string WRN_MissingAsClauseinFunction_Title { get; }
    internal static string WRN_MissingAsClauseinOperator { get; }
    internal static string WRN_MissingAsClauseinOperator_Title { get; }
    internal static string WRN_MissingAsClauseinProperty { get; }
    internal static string WRN_MissingAsClauseinProperty_Title { get; }
    internal static string WRN_MissingAsClauseinVarDecl { get; }
    internal static string WRN_MissingAsClauseinVarDecl_Title { get; }
    internal static string WRN_MultipleDeclFileExtChecksum { get; }
    internal static string WRN_MultipleDeclFileExtChecksum_Title { get; }
    internal static string WRN_MustOverloadBase4 { get; }
    internal static string WRN_MustOverloadBase4_Title { get; }
    internal static string WRN_MustOverride2 { get; }
    internal static string WRN_MustOverride2_Title { get; }
    internal static string WRN_MustShadowOnMultipleInheritance2 { get; }
    internal static string WRN_MustShadowOnMultipleInheritance2_Title { get; }
    internal static string WRN_MutableGenericStructureInUsing { get; }
    internal static string WRN_MutableGenericStructureInUsing_Title { get; }
    internal static string WRN_MutableStructureInUsing { get; }
    internal static string WRN_MutableStructureInUsing_Title { get; }
    internal static string WRN_NameNotCLSCompliant1 { get; }
    internal static string WRN_NameNotCLSCompliant1_Title { get; }
    internal static string WRN_NamespaceCaseMismatch3 { get; }
    internal static string WRN_NamespaceCaseMismatch3_Title { get; }
    internal static string WRN_NoAnalyzerInAssembly { get; }
    internal static string WRN_NoAnalyzerInAssembly_Title { get; }
    internal static string WRN_NoConfigInResponseFile { get; }
    internal static string WRN_NoConfigInResponseFile_Title { get; }
    internal static string WRN_NonCLSMemberInCLSInterface1 { get; }
    internal static string WRN_NonCLSMemberInCLSInterface1_Title { get; }
    internal static string WRN_NonCLSMustOverrideInCLSType1 { get; }
    internal static string WRN_NonCLSMustOverrideInCLSType1_Title { get; }
    internal static string WRN_NoNonObsoleteConstructorOnBase3 { get; }
    internal static string WRN_NoNonObsoleteConstructorOnBase3_Title { get; }
    internal static string WRN_NoNonObsoleteConstructorOnBase4 { get; }
    internal static string WRN_NoNonObsoleteConstructorOnBase4_Title { get; }
    internal static string WRN_NotEqualToLiteralNothing { get; }
    internal static string WRN_NotEqualToLiteralNothing_Title { get; }
    internal static string WRN_ObjectAssumed1 { get; }
    internal static string WRN_ObjectAssumed1_Title { get; }
    internal static string WRN_ObjectAssumedProperty1 { get; }
    internal static string WRN_ObjectAssumedProperty1_Title { get; }
    internal static string WRN_ObjectAssumedVar1 { get; }
    internal static string WRN_ObjectAssumedVar1_Title { get; }
    internal static string WRN_ObjectMath1 { get; }
    internal static string WRN_ObjectMath1_Title { get; }
    internal static string WRN_ObjectMath1Not { get; }
    internal static string WRN_ObjectMath1Not_Title { get; }
    internal static string WRN_ObjectMath2 { get; }
    internal static string WRN_ObjectMath2_Title { get; }
    internal static string WRN_ObjectMathSelectCase { get; }
    internal static string WRN_ObjectMathSelectCase_Title { get; }
    internal static string WRN_ObsoleteIdentityDirectCastForValueType { get; }
    internal static string WRN_ObsoleteIdentityDirectCastForValueType_Title { get; }
    internal static string WRN_OptionalValueNotCLSCompliant1 { get; }
    internal static string WRN_OptionalValueNotCLSCompliant1_Title { get; }
    internal static string WRN_OverlappingCatch { get; }
    internal static string WRN_OverlappingCatch_Title { get; }
    internal static string WRN_OverrideType5 { get; }
    internal static string WRN_OverrideType5_Title { get; }
    internal static string WRN_ParamNotCLSCompliant1 { get; }
    internal static string WRN_ParamNotCLSCompliant1_Title { get; }
    internal static string WRN_PdbLocalNameTooLong { get; }
    internal static string WRN_PdbLocalNameTooLong_Title { get; }
    internal static string WRN_PdbUsingNameTooLong { get; }
    internal static string WRN_PdbUsingNameTooLong_Title { get; }
    internal static string WRN_PrefixAndXmlnsLocalName { get; }
    internal static string WRN_PrefixAndXmlnsLocalName_Title { get; }
    internal static string WRN_ProcTypeNotCLSCompliant1 { get; }
    internal static string WRN_ProcTypeNotCLSCompliant1_Title { get; }
    internal static string WRN_QueryMissingAsClauseinVarDecl { get; }
    internal static string WRN_QueryMissingAsClauseinVarDecl_Title { get; }
    internal static string WRN_RecursiveAddHandlerCall { get; }
    internal static string WRN_RecursiveAddHandlerCall_Title { get; }
    internal static string WRN_RecursiveOperatorCall { get; }
    internal static string WRN_RecursiveOperatorCall_Title { get; }
    internal static string WRN_RecursivePropertyCall { get; }
    internal static string WRN_RecursivePropertyCall_Title { get; }
    internal static string WRN_RefCultureMismatch { get; }
    internal static string WRN_RefCultureMismatch_Title { get; }
    internal static string WRN_ReferencedAssemblyDoesNotHaveStrongName { get; }
    internal static string WRN_ReferencedAssemblyDoesNotHaveStrongName_Title { get; }
    internal static string WRN_RelDelegatePassedToRemoveHandler { get; }
    internal static string WRN_RelDelegatePassedToRemoveHandler_Title { get; }
    internal static string WRN_RequiredNonObsoleteNewCall3 { get; }
    internal static string WRN_RequiredNonObsoleteNewCall3_Title { get; }
    internal static string WRN_RequiredNonObsoleteNewCall4 { get; }
    internal static string WRN_RequiredNonObsoleteNewCall4_Title { get; }
    internal static string WRN_ReturnTypeAttributeOnWriteOnlyProperty { get; }
    internal static string WRN_ReturnTypeAttributeOnWriteOnlyProperty_Title { get; }
    internal static string WRN_RootNamespaceNotCLSCompliant1 { get; }
    internal static string WRN_RootNamespaceNotCLSCompliant1_Title { get; }
    internal static string WRN_RootNamespaceNotCLSCompliant2 { get; }
    internal static string WRN_RootNamespaceNotCLSCompliant2_Title { get; }
    internal static string WRN_SelectCaseInvalidRange { get; }
    internal static string WRN_SelectCaseInvalidRange_Title { get; }
    internal static string WRN_ShadowingGenericParamWithParam1 { get; }
    internal static string WRN_ShadowingGenericParamWithParam1_Title { get; }
    internal static string WRN_SharedMemberThroughInstance { get; }
    internal static string WRN_SharedMemberThroughInstance_Title { get; }
    internal static string WRN_StaticLocalNoInference { get; }
    internal static string WRN_StaticLocalNoInference_Title { get; }
    internal static string WRN_SynthMemberShadowsMember5 { get; }
    internal static string WRN_SynthMemberShadowsMember5_Title { get; }
    internal static string WRN_SynthMemberShadowsSynthMember7 { get; }
    internal static string WRN_SynthMemberShadowsSynthMember7_Title { get; }
    internal static string WRN_TypeConflictButMerged6 { get; }
    internal static string WRN_TypeConflictButMerged6_Title { get; }
    internal static string WRN_TypeInferenceAssumed3 { get; }
    internal static string WRN_TypeInferenceAssumed3_Title { get; }
    internal static string WRN_TypeNotCLSCompliant1 { get; }
    internal static string WRN_TypeNotCLSCompliant1_Title { get; }
    internal static string WRN_UnableToLoadAnalyzer { get; }
    internal static string WRN_UnableToLoadAnalyzer_Title { get; }
    internal static string WRN_UndefinedOrEmptyNamespaceOrClass1 { get; }
    internal static string WRN_UndefinedOrEmptyNamespaceOrClass1_Title { get; }
    internal static string WRN_UndefinedOrEmptyProjectNamespaceOrClass1 { get; }
    internal static string WRN_UndefinedOrEmptyProjectNamespaceOrClass1_Title { get; }
    internal static string WRN_UnimplementedCommandLineSwitch { get; }
    internal static string WRN_UnimplementedCommandLineSwitch_Title { get; }
    internal static string WRN_UnobservedAwaitableDelegate { get; }
    internal static string WRN_UnobservedAwaitableDelegate_Title { get; }
    internal static string WRN_UnobservedAwaitableExpression { get; }
    internal static string WRN_UnobservedAwaitableExpression_Title { get; }
    internal static string WRN_UnreachableCode { get; }
    internal static string WRN_UnreachableCode_Title { get; }
    internal static string WRN_UnusedLocal { get; }
    internal static string WRN_UnusedLocal_Title { get; }
    internal static string WRN_UnusedLocalConst { get; }
    internal static string WRN_UnusedLocalConst_Title { get; }
    internal static string WRN_UseOfObsoletePropertyAccessor2 { get; }
    internal static string WRN_UseOfObsoletePropertyAccessor2_Title { get; }
    internal static string WRN_UseOfObsoletePropertyAccessor3 { get; }
    internal static string WRN_UseOfObsoletePropertyAccessor3_Title { get; }
    internal static string WRN_UseOfObsoleteSymbol2 { get; }
    internal static string WRN_UseOfObsoleteSymbol2_Title { get; }
    internal static string WRN_UseOfObsoleteSymbolNoMessage1 { get; }
    internal static string WRN_UseOfObsoleteSymbolNoMessage1_Title { get; }
    internal static string WRN_UseSwitchInsteadOfAttribute { get; }
    internal static string WRN_UseSwitchInsteadOfAttribute_Title { get; }
    internal static string WRN_UseValueForXmlExpression3 { get; }
    internal static string WRN_UseValueForXmlExpression3_Title { get; }
    internal static string WRN_VarianceConversionFailedIn6 { get; }
    internal static string WRN_VarianceConversionFailedIn6_Title { get; }
    internal static string WRN_VarianceConversionFailedOut6 { get; }
    internal static string WRN_VarianceConversionFailedOut6_Title { get; }
    internal static string WRN_VarianceConversionFailedTryIn4 { get; }
    internal static string WRN_VarianceConversionFailedTryIn4_Title { get; }
    internal static string WRN_VarianceConversionFailedTryOut4 { get; }
    internal static string WRN_VarianceConversionFailedTryOut4_Title { get; }
    internal static string WRN_VarianceDeclarationAmbiguous3 { get; }
    internal static string WRN_VarianceDeclarationAmbiguous3_Title { get; }
    internal static string WRN_VarianceIEnumerableSuggestion3 { get; }
    internal static string WRN_VarianceIEnumerableSuggestion3_Title { get; }
    internal static string WRN_XMLCannotWriteToXMLDocFile2 { get; }
    internal static string WRN_XMLCannotWriteToXMLDocFile2_Title { get; }
    internal static string WRN_XMLDocBadFormedXML { get; }
    internal static string WRN_XMLDocBadFormedXML_Title { get; }
    internal static string WRN_XMLDocBadGenericParamTag2 { get; }
    internal static string WRN_XMLDocBadGenericParamTag2_Title { get; }
    internal static string WRN_XMLDocBadParamTag2 { get; }
    internal static string WRN_XMLDocBadParamTag2_Title { get; }
    internal static string WRN_XMLDocBadXMLLine { get; }
    internal static string WRN_XMLDocBadXMLLine_Title { get; }
    internal static string WRN_XMLDocCrefAttributeNotFound1 { get; }
    internal static string WRN_XMLDocCrefAttributeNotFound1_Title { get; }
    internal static string WRN_XMLDocCrefToTypeParameter { get; }
    internal static string WRN_XMLDocCrefToTypeParameter_Title { get; }
    internal static string WRN_XMLDocDuplicateXMLNode1 { get; }
    internal static string WRN_XMLDocDuplicateXMLNode1_Title { get; }
    internal static string WRN_XMLDocExceptionTagWithoutCRef { get; }
    internal static string WRN_XMLDocExceptionTagWithoutCRef_Title { get; }
    internal static string WRN_XMLDocGenericParamTagWithoutName { get; }
    internal static string WRN_XMLDocGenericParamTagWithoutName_Title { get; }
    internal static string WRN_XMLDocIllegalTagOnElement2 { get; }
    internal static string WRN_XMLDocIllegalTagOnElement2_Title { get; }
    internal static string WRN_XMLDocInsideMethod { get; }
    internal static string WRN_XMLDocInsideMethod_Title { get; }
    internal static string WRN_XMLDocInvalidXMLFragment { get; }
    internal static string WRN_XMLDocInvalidXMLFragment_Title { get; }
    internal static string WRN_XMLDocMoreThanOneCommentBlock { get; }
    internal static string WRN_XMLDocMoreThanOneCommentBlock_Title { get; }
    internal static string WRN_XMLDocNotFirstOnLine { get; }
    internal static string WRN_XMLDocNotFirstOnLine_Title { get; }
    internal static string WRN_XMLDocOnAPartialType { get; }
    internal static string WRN_XMLDocOnAPartialType_Title { get; }
    internal static string WRN_XMLDocParamTagWithoutName { get; }
    internal static string WRN_XMLDocParamTagWithoutName_Title { get; }
    internal static string WRN_XMLDocParseError1 { get; }
    internal static string WRN_XMLDocParseError1_Title { get; }
    internal static string WRN_XMLDocReturnsOnADeclareSub { get; }
    internal static string WRN_XMLDocReturnsOnADeclareSub_Title { get; }
    internal static string WRN_XMLDocReturnsOnWriteOnlyProperty { get; }
    internal static string WRN_XMLDocReturnsOnWriteOnlyProperty_Title { get; }
    internal static string WRN_XMLDocStartTagWithNoEndTag { get; }
    internal static string WRN_XMLDocStartTagWithNoEndTag_Title { get; }
    internal static string WRN_XMLDocWithoutLanguageElement { get; }
    internal static string WRN_XMLDocWithoutLanguageElement_Title { get; }
    internal static string WRN_XMLMissingFileOrPathAttribute1 { get; }
    internal static string WRN_XMLMissingFileOrPathAttribute1_Title { get; }
    internal static string WrongNumberOfTypeArguments { get; }
    internal static string WrongSemanticModelType { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo Value);
    internal static string get_AggregateSyntaxNotWithinSyntaxTree();
    internal static string get_AnonymousObjectCreationExpressionSyntaxNotWithinTree();
    internal static string get_AssociatedTypeDoesNotHaveTypeParameters();
    internal static string get_CannotAddCompilerSpecialTree();
    internal static string get_CannotRemoveCompilerSpecialTree();
    internal static string get_CantReferenceCompilationFromTypes();
    internal static string get_ChainingSpeculativeModelIsNotSupported();
    internal static string get_CompilationVisualBasic();
    internal static string get_DeclarationSyntaxNotWithinSyntaxTree();
    internal static string get_DeclarationSyntaxNotWithinTree();
    internal static string get_ElementsCannotBeNull();
    internal static string get_ERR_AbsentReferenceToPIA1();
    internal static string get_ERR_AccessMismatch6();
    internal static string get_ERR_AccessMismatchImplementedEvent4();
    internal static string get_ERR_AccessMismatchImplementedEvent6();
    internal static string get_ERR_AccessMismatchOutsideAssembly4();
    internal static string get_ERR_AddOrRemoveHandlerEvent();
    internal static string get_ERR_AddParamWrongForWinRT();
    internal static string get_ERR_AddRemoveParamNotEventType();
    internal static string get_ERR_AddressOfInSelectCaseExpr();
    internal static string get_ERR_AddressOfNotCreatableDelegate1();
    internal static string get_ERR_AddressOfNotDelegate1();
    internal static string get_ERR_AddressOfNullableMethod();
    internal static string get_ERR_AddressOfOperandNotMethod();
    internal static string get_ERR_AggrInitInvalidForObject();
    internal static string get_ERR_AgnosticToMachineModule();
    internal static string get_ERR_AmbiguousAcrossInterfaces3();
    internal static string get_ERR_AmbiguousCastConversion2();
    internal static string get_ERR_AmbiguousDelegateBinding2();
    internal static string get_ERR_AmbiguousImplements3();
    internal static string get_ERR_AmbiguousImplementsMember3();
    internal static string get_ERR_AmbiguousInImports2();
    internal static string get_ERR_AmbiguousInModules2();
    internal static string get_ERR_AmbiguousInNamespace2();
    internal static string get_ERR_AmbiguousInNamespaces2();
    internal static string get_ERR_AmbiguousInUnnamedNamespace1();
    internal static string get_ERR_AmbiguousOverrides3();
    internal static string get_ERR_AmbiguousWidestType3();
    internal static string get_ERR_AnonTypeFieldXMLNameInference();
    internal static string get_ERR_AnonymousTypeDisallowsTypeChar();
    internal static string get_ERR_AnonymousTypeExpectedIdentifier();
    internal static string get_ERR_AnonymousTypeFieldNameInference();
    internal static string get_ERR_AnonymousTypeNameWithoutPeriod();
    internal static string get_ERR_AnonymousTypeNeedField();
    internal static string get_ERR_AnonymousTypePropertyOutOfOrder1();
    internal static string get_ERR_ArgumentCopyBackNarrowing3();
    internal static string get_ERR_ArgumentNarrowing2();
    internal static string get_ERR_ArgumentNarrowing3();
    internal static string get_ERR_ArgumentRequired();
    internal static string get_ERR_ArgumentSyntax();
    internal static string get_ERR_ArrayInitForNonArray2();
    internal static string get_ERR_ArrayInitializerForNonConstDim();
    internal static string get_ERR_ArrayInitializerTooFewDimensions();
    internal static string get_ERR_ArrayInitializerTooManyDimensions();
    internal static string get_ERR_ArrayInitInStruct();
    internal static string get_ERR_ArrayInitNoType();
    internal static string get_ERR_ArrayInitNoTypeObjectDisallowed();
    internal static string get_ERR_ArrayInitTooManyTypesObjectDisallowed();
    internal static string get_ERR_ArrayOfRawGenericInvalid();
    internal static string get_ERR_ArrayRankLimit();
    internal static string get_ERR_AsNewArray();
    internal static string get_ERR_AsyncSubMain();
    internal static string get_ERR_AttrAssignmentNotFieldOrProp1();
    internal static string get_ERR_AttrCannotBeGenerics();
    internal static string get_ERR_AttributeCannotBeAbstract();
    internal static string get_ERR_AttributeMustBeClassNotStruct1();
    internal static string get_ERR_AttributeMustInheritSysAttr();
    internal static string get_ERR_AttributeOnLambdaReturnType();
    internal static string get_ERR_AttributeOrder();
    internal static string get_ERR_AttributeParameterRequired1();
    internal static string get_ERR_AttributeParameterRequired2();
    internal static string get_ERR_AttributeStmtWrongOrder();
    internal static string get_ERR_AutoPropertyCantBeWriteOnly();
    internal static string get_ERR_AutoPropertyCantHaveParams();
    internal static string get_ERR_AutoPropertyInitializedInStructure();
    internal static string get_ERR_BadAnonymousTypeForExprTree();
    internal static string get_ERR_BadAsyncByRefParam();
    internal static string get_ERR_BadAsyncInQuery();
    internal static string get_ERR_BadAsyncReturn();
    internal static string get_ERR_BadAsyncReturnOperand1();
    internal static string get_ERR_BadAttribute1();
    internal static string get_ERR_BadAttributeConstructor1();
    internal static string get_ERR_BadAttributeConstructor2();
    internal static string get_ERR_BadAttributeNonPublicConstructor();
    internal static string get_ERR_BadAttributeNonPublicContType2();
    internal static string get_ERR_BadAttributeNonPublicProperty1();
    internal static string get_ERR_BadAttributeNonPublicType1();
    internal static string get_ERR_BadAttributePropertyType1();
    internal static string get_ERR_BadAttributeReadOnlyProperty1();
    internal static string get_ERR_BadAttributeSharedProperty1();
    internal static string get_ERR_BadAttributeUuid2();
    internal static string get_ERR_BadAwaitInNonAsyncLambda();
    internal static string get_ERR_BadAwaitInNonAsyncMethod();
    internal static string get_ERR_BadAwaitInNonAsyncVoidMethod();
    internal static string get_ERR_BadAwaitInTryHandler();
    internal static string get_ERR_BadAwaitNothing();
    internal static string get_ERR_BadAwaitNotInAsyncMethodOrLambda();
    internal static string get_ERR_BadCCExpression();
    internal static string get_ERR_BadClassFlags1();
    internal static string get_ERR_BadCodepage();
    internal static string get_ERR_BadCompilationOption();
    internal static string get_ERR_BadConditionalWithRef();
    internal static string get_ERR_BadConstFlags1();
    internal static string get_ERR_BadConstraintSyntax();
    internal static string get_ERR_BadDeclareFlags1();
    internal static string get_ERR_BadDelegateFlags1();
    internal static string get_ERR_BadDimFlags1();
    internal static string get_ERR_BadEmptyEnum1();
    internal static string get_ERR_BadEnumFlags1();
    internal static string get_ERR_BadEventFlags1();
    internal static string get_ERR_BadFlagsInNotInheritableClass1();
    internal static string get_ERR_BadFlagsOnNew1();
    internal static string get_ERR_BadFlagsOnNewOverloads();
    internal static string get_ERR_BadFlagsOnSharedMeth1();
    internal static string get_ERR_BadFlagsOnSharedProperty1();
    internal static string get_ERR_BadFlagsOnStdModuleProperty1();
    internal static string get_ERR_BadFlagsWithDefault1();
    internal static string get_ERR_BadGenericParamForNewConstraint2();
    internal static string get_ERR_BadGetAwaiterMethod1();
    internal static string get_ERR_BadImplementsType();
    internal static string get_ERR_BadInstanceMemberAccess();
    internal static string get_ERR_BadInterfaceClassSpecifier1();
    internal static string get_ERR_BadInterfaceDelegateSpecifier1();
    internal static string get_ERR_BadInterfaceEnumSpecifier1();
    internal static string get_ERR_BadInterfaceFlags1();
    internal static string get_ERR_BadInterfaceInterfaceSpecifier1();
    internal static string get_ERR_BadInterfaceMethodFlags1();
    internal static string get_ERR_BadInterfaceOrderOnInherits();
    internal static string get_ERR_BadInterfacePropertyFlags1();
    internal static string get_ERR_BadInterfaceStructSpecifier1();
    internal static string get_ERR_BadIsCompletedOnCompletedGetResult2();
    internal static string get_ERR_BadIteratorByRefParam();
    internal static string get_ERR_BadIteratorExpressionLambda();
    internal static string get_ERR_BadIteratorReturn();
    internal static string get_ERR_BadLocalConstFlags1();
    internal static string get_ERR_BadLocalDimFlags1();
    internal static string get_ERR_BadMetaDataReference1();
    internal static string get_ERR_BadMethodFlags1();
    internal static string get_ERR_BadModuleFile1();
    internal static string get_ERR_BadModuleFlags1();
    internal static string get_ERR_BadNamespaceName1();
    internal static string get_ERR_BadNullTypeInCCExpression();
    internal static string get_ERR_BadOperatorFlags1();
    internal static string get_ERR_BadOverloadCandidates2();
    internal static string get_ERR_BadOverrideAccess2();
    internal static string get_ERR_BadPdbData();
    internal static string get_ERR_BadPropertyAccessorFlags();
    internal static string get_ERR_BadPropertyAccessorFlags1();
    internal static string get_ERR_BadPropertyAccessorFlags2();
    internal static string get_ERR_BadPropertyAccessorFlags3();
    internal static string get_ERR_BadPropertyAccessorFlagsRestrict();
    internal static string get_ERR_BadPropertyFlags1();
    internal static string get_ERR_BadRecordFlags1();
    internal static string get_ERR_BadRefLib1();
    internal static string get_ERR_BadResumableAccessReturnVariable();
    internal static string get_ERR_BadReturnValueInIterator();
    internal static string get_ERR_BadSpecifierCombo2();
    internal static string get_ERR_BadStaticInitializerInResumable();
    internal static string get_ERR_BadStaticLocalInGenericMethod();
    internal static string get_ERR_BadStaticLocalInStruct();
    internal static string get_ERR_BadTypeArgForRefConstraint2();
    internal static string get_ERR_BadTypeArgForStructConstraint2();
    internal static string get_ERR_BadTypeArgForStructConstraintNull();
    internal static string get_ERR_BadTypeInCCExpression();
    internal static string get_ERR_BadUseOfVoid();
    internal static string get_ERR_BadWithEventsFlags1();
    internal static string get_ERR_BadWithRef();
    internal static string get_ERR_BadYieldInNonIteratorMethod();
    internal static string get_ERR_BadYieldInTryHandler();
    internal static string get_ERR_BaseMismatchForPartialClass3();
    internal static string get_ERR_BaseOnlyClassesMustBeExplicit2();
    internal static string get_ERR_BaseTypeReferences2();
    internal static string get_ERR_BaseUnifiesWithInterfaces3();
    internal static string get_ERR_BinaryFile();
    internal static string get_ERR_BinaryOperands3();
    internal static string get_ERR_BinaryOperandsForXml4();
    internal static string get_ERR_BinaryParamMustBeContainingType1();
    internal static string get_ERR_BlockLocalShadowing1();
    internal static string get_ERR_BogusWithinLineIf();
    internal static string get_ERR_BranchOutOfFinally();
    internal static string get_ERR_ByRefIllegal1();
    internal static string get_ERR_ByRefParamInExpressionTree();
    internal static string get_ERR_CannotBeMadeNullable1();
    internal static string get_ERR_CannotCallEvent1();
    internal static string get_ERR_CannotConvertValue2();
    internal static string get_ERR_CannotEmbedInterfaceWithGeneric();
    internal static string get_ERR_CannotGotoNonScopeBlocksWithClosure();
    internal static string get_ERR_CannotInferNullableForVariable1();
    internal static string get_ERR_CannotLiftAnonymousType1();
    internal static string get_ERR_CannotLiftByRefParamLambda1();
    internal static string get_ERR_CannotLiftByRefParamQuery1();
    internal static string get_ERR_CannotLiftRestrictedTypeLambda();
    internal static string get_ERR_CannotLiftRestrictedTypeQuery();
    internal static string get_ERR_CannotLiftRestrictedTypeResumable1();
    internal static string get_ERR_CannotLiftStructureMeLambda();
    internal static string get_ERR_CannotLiftStructureMeQuery();
    internal static string get_ERR_CannotLinkClassWithNoPIA1();
    internal static string get_ERR_CannotOverrideInAccessibleMember();
    internal static string get_ERR_CannotUseGenericTypeAcrossAssemblyBoundaries();
    internal static string get_ERR_CannotUseOnErrorGotoWithClosure();
    internal static string get_ERR_CantAssignToConst();
    internal static string get_ERR_CantAwaitAsyncSub1();
    internal static string get_ERR_CantCallIIF();
    internal static string get_ERR_CantCombineInitializers();
    internal static string get_ERR_CantHaveWin32ResAndManifest();
    internal static string get_ERR_CantOpenFileWrite();
    internal static string get_ERR_CantOverride4();
    internal static string get_ERR_CantOverrideConstructor();
    internal static string get_ERR_CantOverrideNotOverridable2();
    internal static string get_ERR_CantRaiseBaseEvent();
    internal static string get_ERR_CantReadRulesetFile();
    internal static string get_ERR_CantReferToMyGroupInsideGroupType1();
    internal static string get_ERR_CantShadowAMustOverride1();
    internal static string get_ERR_CantSpecifyArrayAndNullableOnBoth();
    internal static string get_ERR_CantSpecifyArraysOnBoth();
    internal static string get_ERR_CantSpecifyAsNewAndNullable();
    internal static string get_ERR_CantSpecifyNullableOnBoth();
    internal static string get_ERR_CantSpecifyParamsOnLambdaParamNoType();
    internal static string get_ERR_CantSpecifyTypeCharacterOnIIF();
    internal static string get_ERR_CantThrowNonException();
    internal static string get_ERR_CantUseRequiredAttribute();
    internal static string get_ERR_CaseAfterCaseElse();
    internal static string get_ERR_CaseElseNoSelect();
    internal static string get_ERR_CaseNoSelect();
    internal static string get_ERR_CatchAfterFinally();
    internal static string get_ERR_CatchNoMatchingTry();
    internal static string get_ERR_CatchNotException1();
    internal static string get_ERR_CatchVariableNotLocal1();
    internal static string get_ERR_CharToIntegralTypeMismatch1();
    internal static string get_ERR_CircularBaseDependencies4();
    internal static string get_ERR_CircularEvaluation1();
    internal static string get_ERR_CircularInference1();
    internal static string get_ERR_ClashWithReservedEnumMember1();
    internal static string get_ERR_ClassConstraintNotInheritable1();
    internal static string get_ERR_ClassInheritsBaseUnifiesWithInterfaces3();
    internal static string get_ERR_ClassInheritsInterfaceBaseUnifiesWithBase4();
    internal static string get_ERR_ClassInheritsInterfaceUnifiesWithBase3();
    internal static string get_ERR_ClassNotExpression1();
    internal static string get_ERR_CmdOptionConflictsSource();
    internal static string get_ERR_CoClassMissing2();
    internal static string get_ERR_CollisionWithPublicTypeInModule();
    internal static string get_ERR_ComClassAndReservedAttribute1();
    internal static string get_ERR_ComClassCantBeAbstract0();
    internal static string get_ERR_ComClassDuplicateGuids1();
    internal static string get_ERR_ComClassGenericMethod();
    internal static string get_ERR_ComClassOnGeneric();
    internal static string get_ERR_ComClassRequiresPublicClass1();
    internal static string get_ERR_ComClassRequiresPublicClass2();
    internal static string get_ERR_ComClassReservedDispId1();
    internal static string get_ERR_ComClassReservedDispIdZero1();
    internal static string get_ERR_ConditionOperatorRequired3();
    internal static string get_ERR_ConflictDefaultPropertyAttribute();
    internal static string get_ERR_ConflictingDirectConstraints3();
    internal static string get_ERR_ConflictingMachineModule();
    internal static string get_ERR_ConflictingManifestSwitches();
    internal static string get_ERR_ConstantStringTooLong();
    internal static string get_ERR_ConstantWithNoValue();
    internal static string get_ERR_ConstAsNonConstant();
    internal static string get_ERR_ConstNotClassInterfaceOrTypeParam1();
    internal static string get_ERR_ConstraintAlreadyExists1();
    internal static string get_ERR_ConstraintClashDirectIndirect3();
    internal static string get_ERR_ConstraintClashIndirectDirect3();
    internal static string get_ERR_ConstraintClashIndirectIndirect4();
    internal static string get_ERR_ConstraintCycle2();
    internal static string get_ERR_ConstraintCycleLink2();
    internal static string get_ERR_ConstraintIsRestrictedType1();
    internal static string get_ERR_ConstructorAsync();
    internal static string get_ERR_ConstructorCannotBeDeclaredPartial();
    internal static string get_ERR_ConstructorFunction();
    internal static string get_ERR_ConstructorNotFound1();
    internal static string get_ERR_ContinueDoNotWithinDo();
    internal static string get_ERR_ContinueForNotWithinFor();
    internal static string get_ERR_ContinueWhileNotWithinWhile();
    internal static string get_ERR_ConversionFromBaseType();
    internal static string get_ERR_ConversionFromDerivedType();
    internal static string get_ERR_ConversionFromInterfaceType();
    internal static string get_ERR_ConversionFromObject();
    internal static string get_ERR_ConversionToBaseType();
    internal static string get_ERR_ConversionToDerivedType();
    internal static string get_ERR_ConversionToInterfaceType();
    internal static string get_ERR_ConversionToObject();
    internal static string get_ERR_ConversionToSameType();
    internal static string get_ERR_ConvertArrayMismatch4();
    internal static string get_ERR_ConvertArrayRankMismatch2();
    internal static string get_ERR_ConvertObjectArrayMismatch3();
    internal static string get_ERR_ConvMustBeWideningOrNarrowing();
    internal static string get_ERR_ConvParamMustBeContainingType1();
    internal static string get_ERR_CopyBackTypeMismatch3();
    internal static string get_ERR_CryptoHashFailed();
    internal static string get_ERR_CustomEventInvInInterface();
    internal static string get_ERR_CustomEventRequiresAs();
    internal static string get_ERR_DateToDoubleConversion();
    internal static string get_ERR_DebugEntryPointNotSourceMethodDefinition();
    internal static string get_ERR_DeclaresCantBeInGeneric();
    internal static string get_ERR_DefaultEventNotFound1();
    internal static string get_ERR_DefaultMemberNotProperty1();
    internal static string get_ERR_DefaultMissingFromProperty2();
    internal static string get_ERR_DefaultPropertyAmbiguousAcrossInterfaces4();
    internal static string get_ERR_DefaultPropertyWithNoParams();
    internal static string get_ERR_DefaultValueForNonOptionalParam();
    internal static string get_ERR_DelegateBindingFailure3();
    internal static string get_ERR_DelegateBindingIncompatible2();
    internal static string get_ERR_DelegateBindingIncompatible3();
    internal static string get_ERR_DelegateBindingMismatch();
    internal static string get_ERR_DelegateBindingMismatchStrictOff2();
    internal static string get_ERR_DelegateBindingMismatchStrictOff3();
    internal static string get_ERR_DelegateBindingTypeInferenceFails();
    internal static string get_ERR_DelegateCantHandleEvents();
    internal static string get_ERR_DelegateCantImplement();
    internal static string get_ERR_DelegateNoInvoke1();
    internal static string get_ERR_DllImportNotLegalOnDeclare();
    internal static string get_ERR_DllImportNotLegalOnEventMethod();
    internal static string get_ERR_DllImportNotLegalOnGetOrSet();
    internal static string get_ERR_DllImportOnGenericSubOrFunction();
    internal static string get_ERR_DllImportOnInstanceMethod();
    internal static string get_ERR_DllImportOnInterfaceMethod();
    internal static string get_ERR_DllImportOnNonEmptySubOrFunction();
    internal static string get_ERR_DllImportOnResumableMethod();
    internal static string get_ERR_DoesntImplementAwaitInterface2();
    internal static string get_ERR_DoubleToDateConversion();
    internal static string get_ERR_DTDNotSupported();
    internal static string get_ERR_DuplicateAccessCategoryUsed();
    internal static string get_ERR_DuplicateAddHandlerDef();
    internal static string get_ERR_DuplicateAggrMemberInit1();
    internal static string get_ERR_DuplicateAnonTypeMemberName1();
    internal static string get_ERR_DuplicateConversionCategoryUsed();
    internal static string get_ERR_DuplicateDefaultProps1();
    internal static string get_ERR_DuplicateImport1();
    internal static string get_ERR_DuplicateInInherits1();
    internal static string get_ERR_DuplicateLocals1();
    internal static string get_ERR_DuplicateLocalStatic1();
    internal static string get_ERR_DuplicateLocalTypes3();
    internal static string get_ERR_DuplicateModifierCategoryUsed();
    internal static string get_ERR_DuplicateNamedImportAlias1();
    internal static string get_ERR_DuplicateOption1();
    internal static string get_ERR_DuplicateParameterSpecifier();
    internal static string get_ERR_DuplicateParamName1();
    internal static string get_ERR_DuplicatePrefix();
    internal static string get_ERR_DuplicateProcDef1();
    internal static string get_ERR_DuplicatePropertyGet();
    internal static string get_ERR_DuplicatePropertySet();
    internal static string get_ERR_DuplicateRaiseEventDef();
    internal static string get_ERR_DuplicateRawGenericTypeImport1();
    internal static string get_ERR_DuplicateReference2();
    internal static string get_ERR_DuplicateReferenceStrong();
    internal static string get_ERR_DuplicateRemoveHandlerDef();
    internal static string get_ERR_DuplicateResourceFileName1();
    internal static string get_ERR_DuplicateResourceName1();
    internal static string get_ERR_DuplicateSpecifier();
    internal static string get_ERR_DuplicateTypeParamName1();
    internal static string get_ERR_DuplicateWriteabilityCategoryUsed();
    internal static string get_ERR_DuplicateXmlAttribute();
    internal static string get_ERR_ElseIfNoMatchingIf();
    internal static string get_ERR_ElseNoMatchingIf();
    internal static string get_ERR_EmbeddedExpression();
    internal static string get_ERR_EmptyAggregateInitializer();
    internal static string get_ERR_EncNoPIAReference();
    internal static string get_ERR_EncodinglessSyntaxTree();
    internal static string get_ERR_EncReferenceToAddedMember();
    internal static string get_ERR_EncUpdateFailedMissingAttribute();
    internal static string get_ERR_EndClassNoClass();
    internal static string get_ERR_EndDisallowedInDllProjects();
    internal static string get_ERR_EndExternalSource();
    internal static string get_ERR_EndFunctionExpected();
    internal static string get_ERR_EndIfNoMatchingIf();
    internal static string get_ERR_EndModuleNoModule();
    internal static string get_ERR_EndNamespaceNoNamespace();
    internal static string get_ERR_EndOperatorExpected();
    internal static string get_ERR_EndOperatorNotAtLineStart();
    internal static string get_ERR_EndProp();
    internal static string get_ERR_EndRegionNoRegion();
    internal static string get_ERR_EndSelectNoSelect();
    internal static string get_ERR_EndStructureNoStructure();
    internal static string get_ERR_EndSubExpected();
    internal static string get_ERR_EndSyncLockNoSyncLock();
    internal static string get_ERR_EndTryNoTry();
    internal static string get_ERR_EndUsingWithoutUsing();
    internal static string get_ERR_EndWhileNoWhile();
    internal static string get_ERR_EndWithWithoutWith();
    internal static string get_ERR_EnumNotExpression1();
    internal static string get_ERR_EqualsOperandIsBad();
    internal static string get_ERR_EqualsTypeMismatch();
    internal static string get_ERR_ErrorCreatingWin32ResourceFile();
    internal static string get_ERR_EventAddRemoveByrefParamIllegal();
    internal static string get_ERR_EventAddRemoveHasOnlyOneParam();
    internal static string get_ERR_EventDelegatesCantBeFunctions();
    internal static string get_ERR_EventHandlerSignatureIncompatible2();
    internal static string get_ERR_EventImplMismatch5();
    internal static string get_ERR_EventImplRemoveHandlerParamWrong();
    internal static string get_ERR_EventMethodOptionalParamIllegal1();
    internal static string get_ERR_EventNoPIANoBackingMember();
    internal static string get_ERR_EventNotFound1();
    internal static string get_ERR_EventsCantBeFunctions();
    internal static string get_ERR_EventSourceIsArray();
    internal static string get_ERR_EventTypeNotDelegate();
    internal static string get_ERR_ExecutableAsDeclaration();
    internal static string get_ERR_ExitDoNotWithinDo();
    internal static string get_ERR_ExitEventMemberNotInvalid();
    internal static string get_ERR_ExitForNotWithinFor();
    internal static string get_ERR_ExitFuncOfSub();
    internal static string get_ERR_ExitOperatorNotValid();
    internal static string get_ERR_ExitPropNot();
    internal static string get_ERR_ExitSelectNotWithinSelect();
    internal static string get_ERR_ExitSubOfFunc();
    internal static string get_ERR_ExitTryNotWithinTry();
    internal static string get_ERR_ExitWhileNotWithinWhile();
    internal static string get_ERR_ExpectedAnd();
    internal static string get_ERR_ExpectedArray1();
    internal static string get_ERR_ExpectedAs();
    internal static string get_ERR_ExpectedAssignmentOperator();
    internal static string get_ERR_ExpectedAssignmentOperatorInInit();
    internal static string get_ERR_ExpectedBy();
    internal static string get_ERR_ExpectedCase();
    internal static string get_ERR_ExpectedComma();
    internal static string get_ERR_ExpectedConditionalDirective();
    internal static string get_ERR_ExpectedContinueKind();
    internal static string get_ERR_ExpectedDeclaration();
    internal static string get_ERR_ExpectedDiv();
    internal static string get_ERR_ExpectedDot();
    internal static string get_ERR_ExpectedDotAfterGlobalNameSpace();
    internal static string get_ERR_ExpectedDotAfterMyBase();
    internal static string get_ERR_ExpectedDotAfterMyClass();
    internal static string get_ERR_ExpectedEndClass();
    internal static string get_ERR_ExpectedEndExternalSource();
    internal static string get_ERR_ExpectedEndIf();
    internal static string get_ERR_ExpectedEndModule();
    internal static string get_ERR_ExpectedEndNamespace();
    internal static string get_ERR_ExpectedEndOfExpression();
    internal static string get_ERR_ExpectedEndRegion();
    internal static string get_ERR_ExpectedEndSelect();
    internal static string get_ERR_ExpectedEndStructure();
    internal static string get_ERR_ExpectedEndSyncLock();
    internal static string get_ERR_ExpectedEndTry();
    internal static string get_ERR_ExpectedEndUsing();
    internal static string get_ERR_ExpectedEndWhile();
    internal static string get_ERR_ExpectedEndWith();
    internal static string get_ERR_ExpectedEOS();
    internal static string get_ERR_ExpectedEQ();
    internal static string get_ERR_ExpectedEquals();
    internal static string get_ERR_ExpectedExitKind();
    internal static string get_ERR_ExpectedExpression();
    internal static string get_ERR_ExpectedForOptionStmt();
    internal static string get_ERR_ExpectedFrom();
    internal static string get_ERR_ExpectedGreater();
    internal static string get_ERR_ExpectedIdentifier();
    internal static string get_ERR_ExpectedIdentifierOrGroup();
    internal static string get_ERR_ExpectedIn();
    internal static string get_ERR_ExpectedInOrEq();
    internal static string get_ERR_ExpectedIntLiteral();
    internal static string get_ERR_ExpectedInto();
    internal static string get_ERR_ExpectedJoin();
    internal static string get_ERR_ExpectedLbrace();
    internal static string get_ERR_ExpectedLoop();
    internal static string get_ERR_ExpectedLparen();
    internal static string get_ERR_ExpectedLT();
    internal static string get_ERR_ExpectedMinus();
    internal static string get_ERR_ExpectedNamedArgument();
    internal static string get_ERR_ExpectedNext();
    internal static string get_ERR_ExpectedOn();
    internal static string get_ERR_ExpectedOptional();
    internal static string get_ERR_ExpectedOptionCompare();
    internal static string get_ERR_ExpectedProcedure();
    internal static string get_ERR_ExpectedQualifiedNameInInit();
    internal static string get_ERR_ExpectedQueryableSource();
    internal static string get_ERR_ExpectedQuote();
    internal static string get_ERR_ExpectedRbrace();
    internal static string get_ERR_ExpectedRelational();
    internal static string get_ERR_ExpectedResumeOrGoto();
    internal static string get_ERR_ExpectedRparen();
    internal static string get_ERR_ExpectedSColon();
    internal static string get_ERR_ExpectedSingleScript();
    internal static string get_ERR_ExpectedSpecifier();
    internal static string get_ERR_ExpectedSQuote();
    internal static string get_ERR_ExpectedStringLiteral();
    internal static string get_ERR_ExpectedSubFunction();
    internal static string get_ERR_ExpectedSubOrFunction();
    internal static string get_ERR_ExpectedWarningKeyword();
    internal static string get_ERR_ExpectedXmlBeginEmbedded();
    internal static string get_ERR_ExpectedXmlEndCData();
    internal static string get_ERR_ExpectedXmlEndComment();
    internal static string get_ERR_ExpectedXmlEndEmbedded();
    internal static string get_ERR_ExpectedXmlEndPI();
    internal static string get_ERR_ExpectedXmlName();
    internal static string get_ERR_ExpectedXmlns();
    internal static string get_ERR_ExpectedXmlWhiteSpace();
    internal static string get_ERR_ExportedTypeConflictsWithDeclaration();
    internal static string get_ERR_ExportedTypesConflict();
    internal static string get_ERR_ExpressionDoesntHaveName();
    internal static string get_ERR_ExpressionOverflow1();
    internal static string get_ERR_ExpressionTreeNotSupported();
    internal static string get_ERR_ExprTreeNoLateBind();
    internal static string get_ERR_ExprTreeNoMultiDimArrayCreation();
    internal static string get_ERR_ExtensionAttributeInvalid();
    internal static string get_ERR_ExtensionMethodCannotBeLateBound();
    internal static string get_ERR_ExtensionMethodNoParams();
    internal static string get_ERR_ExtensionMethodNotInModule();
    internal static string get_ERR_ExtensionMethodOptionalFirstArg();
    internal static string get_ERR_ExtensionMethodOverloadCandidate2();
    internal static string get_ERR_ExtensionMethodOverloadCandidate3();
    internal static string get_ERR_ExtensionMethodParamArrayFirstArg();
    internal static string get_ERR_ExtensionMethodUncallable1();
    internal static string get_ERR_ExtensionOnlyAllowedOnModuleSubOrFunction();
    internal static string get_ERR_ExtraNextVariable();
    internal static string get_ERR_ExtraSpecifiers();
    internal static string get_ERR_FailureSigningAssembly();
    internal static string get_ERR_FieldHasMultipleDistinctConstantValues();
    internal static string get_ERR_FieldOfValueFieldOfMarshalByRef3();
    internal static string get_ERR_FileAttributeNotAssemblyOrModule();
    internal static string get_ERR_FileNotFound();
    internal static string get_ERR_FinallyAfterFinally();
    internal static string get_ERR_FinallyNoMatchingTry();
    internal static string get_ERR_ForCtlVarArraySizesSpecified();
    internal static string get_ERR_ForEachAmbiguousIEnumerable1();
    internal static string get_ERR_ForEachCollectionDesignPattern1();
    internal static string get_ERR_ForIndexInUse1();
    internal static string get_ERR_ForLoopOperatorRequired2();
    internal static string get_ERR_ForLoopType1();
    internal static string get_ERR_ForwardedTypeConflictsWithDeclaration();
    internal static string get_ERR_ForwardedTypeConflictsWithExportedType();
    internal static string get_ERR_ForwardedTypesConflict();
    internal static string get_ERR_ForwardedTypeUnavailable3();
    internal static string get_ERR_FriendAssemblyBadAccessOverride2();
    internal static string get_ERR_FriendAssemblyBadArguments();
    internal static string get_ERR_FriendAssemblyNameInvalid();
    internal static string get_ERR_FriendAssemblyStrongNameRequired();
    internal static string get_ERR_FriendRefNotEqualToThis();
    internal static string get_ERR_FriendRefSigningMismatch();
    internal static string get_ERR_FullWidthAsXmlDelimiter();
    internal static string get_ERR_FunctionResultCannotBeIndexed1();
    internal static string get_ERR_GeneralProjectImportsError3();
    internal static string get_ERR_GenericArgsOnAttributeSpecifier();
    internal static string get_ERR_GenericClassCannotInheritAttr();
    internal static string get_ERR_GenericConstraintNotSatisfied2();
    internal static string get_ERR_GenericParamBase2();
    internal static string get_ERR_GenericParamsOnInvalidMember();
    internal static string get_ERR_GenericSubMainsFound1();
    internal static string get_ERR_GotoIntoFor();
    internal static string get_ERR_GotoIntoSyncLock();
    internal static string get_ERR_GotoIntoTryHandler();
    internal static string get_ERR_GotoIntoUsing();
    internal static string get_ERR_GotoIntoWith();
    internal static string get_ERR_HandlesInvalidOnGenericMethod();
    internal static string get_ERR_HandlesSyntaxInClass();
    internal static string get_ERR_HandlesSyntaxInModule();
    internal static string get_ERR_IconFileAndWin32ResFile();
    internal static string get_ERR_IdentityDirectCastForFloat();
    internal static string get_ERR_IdentNotMemberOfInterface4();
    internal static string get_ERR_IfNoType();
    internal static string get_ERR_IfNoTypeObjectDisallowed();
    internal static string get_ERR_IfTooManyTypesObjectDisallowed();
    internal static string get_ERR_IllegalAttributeInXmlDecl();
    internal static string get_ERR_IllegalBaseTypeReferences3();
    internal static string get_ERR_IllegalCallOrIndex();
    internal static string get_ERR_IllegalChar();
    internal static string get_ERR_IllegalCharConstant();
    internal static string get_ERR_IllegalCondTypeInIIF();
    internal static string get_ERR_IllegalDefaultNamespace();
    internal static string get_ERR_IllegalOperandInIIFConversion();
    internal static string get_ERR_IllegalOperandInIIFConversion2();
    internal static string get_ERR_IllegalOperandInIIFCount();
    internal static string get_ERR_IllegalOperandInIIFName();
    internal static string get_ERR_IllegalProcessingInstructionName();
    internal static string get_ERR_IllegalXmlCommentChar();
    internal static string get_ERR_IllegalXmlNameChar();
    internal static string get_ERR_IllegalXmlnsPrefix();
    internal static string get_ERR_IllegalXmlStartNameChar();
    internal static string get_ERR_IllegalXmlWhiteSpace();
    internal static string get_ERR_ImplementationMustBePrivate2();
    internal static string get_ERR_ImplementsGenericParam();
    internal static string get_ERR_ImplementsOnNew();
    internal static string get_ERR_ImplementsStmtWrongOrder();
    internal static string get_ERR_ImplementsWithConstraintMismatch3();
    internal static string get_ERR_ImportAliasConflictsWithType2();
    internal static string get_ERR_ImportsMustBeFirst();
    internal static string get_ERR_InAccessibleCoClass3();
    internal static string get_ERR_InaccessibleMember3();
    internal static string get_ERR_InAccessibleOverridingMethod5();
    internal static string get_ERR_InaccessibleReturnTypeOfMember2();
    internal static string get_ERR_InaccessibleSymbol2();
    internal static string get_ERR_IndexedNotArrayOrProc();
    internal static string get_ERR_IndirectUnreferencedAssembly4();
    internal static string get_ERR_InferringNonArrayType1();
    internal static string get_ERR_InheritanceAccessMismatch5();
    internal static string get_ERR_InheritanceAccessMismatchOutside3();
    internal static string get_ERR_InheritanceCycle1();
    internal static string get_ERR_InheritanceCycleInImportedType1();
    internal static string get_ERR_InheritsFrom2();
    internal static string get_ERR_InheritsFromCantInherit3();
    internal static string get_ERR_InheritsFromNonClass();
    internal static string get_ERR_InheritsFromNonInterface();
    internal static string get_ERR_InheritsFromRestrictedType1();
    internal static string get_ERR_InheritsStmtWrongOrder();
    internal static string get_ERR_InheritsTypeArgAccessMismatch7();
    internal static string get_ERR_InheritsTypeArgAccessMismatchOutside5();
    internal static string get_ERR_InitializedExpandedProperty();
    internal static string get_ERR_InitializerExpected();
    internal static string get_ERR_InitializerInStruct();
    internal static string get_ERR_InitializerTooFewElements1();
    internal static string get_ERR_InitializerTooManyElements1();
    internal static string get_ERR_InitWithExplicitArraySizes();
    internal static string get_ERR_InitWithMultipleDeclarators();
    internal static string get_ERR_InReferencedAssembly();
    internal static string get_ERR_IntegralToCharTypeMismatch1();
    internal static string get_ERR_InterfaceBaseUnifiesWithBase4();
    internal static string get_ERR_InterfaceCantUseEventSpecifier1();
    internal static string get_ERR_InterfaceCycle1();
    internal static string get_ERR_InterfaceEventCantUse1();
    internal static string get_ERR_InterfaceImplementedTwice1();
    internal static string get_ERR_InterfaceMemberSyntax();
    internal static string get_ERR_InterfaceNoDefault1();
    internal static string get_ERR_InterfaceNotExpression1();
    internal static string get_ERR_InterfaceNotImplemented1();
    internal static string get_ERR_InterfacePossiblyImplTwice2();
    internal static string get_ERR_InterfaceUnifiesWithBase3();
    internal static string get_ERR_InterfaceUnifiesWithInterface2();
    internal static string get_ERR_InteropMethodWithBody1();
    internal static string get_ERR_InterpolatedStringFactoryError();
    internal static string get_ERR_InterpolationAlignmentOutOfRange();
    internal static string get_ERR_InterpolationFormatWhitespace();
    internal static string get_ERR_InvalidAssemblyAttribute1();
    internal static string get_ERR_InvalidAssemblyCulture();
    internal static string get_ERR_InvalidAssemblyCultureForExe();
    internal static string get_ERR_InvalidAssemblyName();
    internal static string get_ERR_InvalidAsyncIteratorModifiers();
    internal static string get_ERR_InvalidAttributeUsage2();
    internal static string get_ERR_InvalidAttributeUsageOnAccessor();
    internal static string get_ERR_InvalidAttributeValue1();
    internal static string get_ERR_InvalidAttributeValue2();
    internal static string get_ERR_InvalidCoClass1();
    internal static string get_ERR_InvalidConstructorCall();
    internal static string get_ERR_InvalidDate();
    internal static string get_ERR_InvalidDebugInformationFormat();
    internal static string get_ERR_InvalidEndAddHandler();
    internal static string get_ERR_InvalidEndEnum();
    internal static string get_ERR_InvalidEndEvent();
    internal static string get_ERR_InvalidEndFunction();
    internal static string get_ERR_InvalidEndGet();
    internal static string get_ERR_InvalidEndInterface();
    internal static string get_ERR_InvalidEndOperator();
    internal static string get_ERR_InvalidEndProperty();
    internal static string get_ERR_InvalidEndRaiseEvent();
    internal static string get_ERR_InvalidEndRemoveHandler();
    internal static string get_ERR_InvalidEndSet();
    internal static string get_ERR_InvalidEndSub();
    internal static string get_ERR_InvalidEnumBase();
    internal static string get_ERR_InvalidFileAlignment();
    internal static string get_ERR_InvalidFormatForGuidForOption();
    internal static string get_ERR_InvalidFormatSpecifier();
    internal static string get_ERR_InvalidHandles();
    internal static string get_ERR_InvalidImplements();
    internal static string get_ERR_InvalidImplicitMeReference();
    internal static string get_ERR_InvalidImplicitVar();
    internal static string get_ERR_InvalidInNamespace();
    internal static string get_ERR_InvalidLambdaModifier();
    internal static string get_ERR_InvalidLiteralExponent();
    internal static string get_ERR_InvalidMe();
    internal static string get_ERR_InvalidMeReference();
    internal static string get_ERR_InvalidModuleAttribute1();
    internal static string get_ERR_InvalidMultipleAttributeUsage1();
    internal static string get_ERR_InvalidMultipleAttributeUsageInNetModule2();
    internal static string get_ERR_InvalidNameOfSubExpression();
    internal static string get_ERR_InvalidNewInType();
    internal static string get_ERR_InvalidNonSerializedUsage();
    internal static string get_ERR_InvalidOptionalParameterUsage1();
    internal static string get_ERR_InvalidOptionCompare();
    internal static string get_ERR_InvalidOptionExplicit();
    internal static string get_ERR_InvalidOptionInfer();
    internal static string get_ERR_InvalidOptionStrict();
    internal static string get_ERR_InvalidOptionStrictCustom();
    internal static string get_ERR_InvalidOutputName();
    internal static string get_ERR_InvalidOverrideDueToReturn2();
    internal static string get_ERR_InvalidParameterSyntax();
    internal static string get_ERR_InvalidPathMap();
    internal static string get_ERR_InvalidSignaturePublicKey();
    internal static string get_ERR_InvalidSpecifierOnNonConversion1();
    internal static string get_ERR_InvalidStructMemberNoPIA1();
    internal static string get_ERR_InValidSubMainsFound1();
    internal static string get_ERR_InvalidSubsystemVersion();
    internal static string get_ERR_InvalidSwitchValue();
    internal static string get_ERR_InvalidTypeForAliasesImport2();
    internal static string get_ERR_InvalidUseOfCustomModifier();
    internal static string get_ERR_InvalidUseOfKeyword();
    internal static string get_ERR_InvalidVersionFormat();
    internal static string get_ERR_InvalidVersionFormat2();
    internal static string get_ERR_InvInsideBlock();
    internal static string get_ERR_InvInsideEndsEnum();
    internal static string get_ERR_InvInsideEndsEvent();
    internal static string get_ERR_InvInsideEndsInterface();
    internal static string get_ERR_InvInsideEndsProc();
    internal static string get_ERR_InvInsideEndsProperty();
    internal static string get_ERR_InvInsideEnum();
    internal static string get_ERR_InvInsideInterface();
    internal static string get_ERR_InvInsideProc();
    internal static string get_ERR_InvOutsideProc();
    internal static string get_ERR_IsNestedIn2();
    internal static string get_ERR_IsNotOperatorGenericParam1();
    internal static string get_ERR_IsNotOperatorNullable1();
    internal static string get_ERR_IsNotOpRequiresReferenceTypes1();
    internal static string get_ERR_IsOperatorGenericParam1();
    internal static string get_ERR_IsOperatorNullable1();
    internal static string get_ERR_IsOperatorRequiresReferenceTypes1();
    internal static string get_ERR_IterationVariableShadowLocal1();
    internal static string get_ERR_IterationVariableShadowLocal2();
    internal static string get_ERR_KeywordNotAllowedInScript();
    internal static string get_ERR_LabelNotDefined1();
    internal static string get_ERR_LambdaBindingMismatch1();
    internal static string get_ERR_LambdaBindingMismatch2();
    internal static string get_ERR_LambdaInSelectCaseExpr();
    internal static string get_ERR_LambdaNotCreatableDelegate1();
    internal static string get_ERR_LambdaNotDelegate1();
    internal static string get_ERR_LambdaNoType();
    internal static string get_ERR_LambdaNoTypeObjectDisallowed();
    internal static string get_ERR_LambdaParamShadowLocal1();
    internal static string get_ERR_LambdasCannotHaveAttributes();
    internal static string get_ERR_LambdaTooManyTypesObjectDisallowed();
    internal static string get_ERR_LanguageVersion();
    internal static string get_ERR_LateBoundOverloadInterfaceCall1();
    internal static string get_ERR_LbBadElseif();
    internal static string get_ERR_LbElseifAfterElse();
    internal static string get_ERR_LbElseNoMatchingIf();
    internal static string get_ERR_LbExpectedEndIf();
    internal static string get_ERR_LbNoMatchingIf();
    internal static string get_ERR_LibAnycpu32bitPreferredConflict();
    internal static string get_ERR_LibNotFound();
    internal static string get_ERR_LineContWithCommentOrNoPrecSpace();
    internal static string get_ERR_LinkedNetmoduleMetadataMustProvideFullPEImage();
    internal static string get_ERR_LiteralExpected();
    internal static string get_ERR_LocalNamedSameAsParam1();
    internal static string get_ERR_LocalNamedSameAsParamInLambda1();
    internal static string get_ERR_LocalSameAsFunc();
    internal static string get_ERR_LocalsCannotHaveAttributes();
    internal static string get_ERR_LocalTypeNameClash2();
    internal static string get_ERR_LoopControlMustNotAwait();
    internal static string get_ERR_LoopControlMustNotBeProperty();
    internal static string get_ERR_LoopDoubleCondition();
    internal static string get_ERR_LoopNoMatchingDo();
    internal static string get_ERR_LValueRequired();
    internal static string get_ERR_MarshalUnmanagedTypeNotValidForFields();
    internal static string get_ERR_MarshalUnmanagedTypeOnlyValidForFields();
    internal static string get_ERR_MatchingOperatorExpected2();
    internal static string get_ERR_MaximumNumberOfErrors();
    internal static string get_ERR_MemberClashesWithSynth6();
    internal static string get_ERR_MemberConflictWithSynth4();
    internal static string get_ERR_MetaDataIsNotAssembly();
    internal static string get_ERR_MetaDataIsNotModule();
    internal static string get_ERR_MetadataMembersAmbiguous3();
    internal static string get_ERR_MetadataReferencesNotSupported();
    internal static string get_ERR_MethodAlreadyImplemented2();
    internal static string get_ERR_MethodBodyNotAtLineStart();
    internal static string get_ERR_MethodMustBeFirstStatementOnLine();
    internal static string get_ERR_MethodTypeArgsUnexpected();
    internal static string get_ERR_MismatchedXmlEndTag();
    internal static string get_ERR_MissingAddHandlerDef1();
    internal static string get_ERR_MissingEndAddHandler();
    internal static string get_ERR_MissingEndBrack();
    internal static string get_ERR_MissingEndEnum();
    internal static string get_ERR_MissingEndEvent();
    internal static string get_ERR_MissingEndGet();
    internal static string get_ERR_MissingEndInterface();
    internal static string get_ERR_MissingEndRaiseEvent();
    internal static string get_ERR_MissingEndRemoveHandler();
    internal static string get_ERR_MissingEndSet();
    internal static string get_ERR_MissingGuidForOption();
    internal static string get_ERR_MissingIsInTypeOf();
    internal static string get_ERR_MissingLibInDeclare();
    internal static string get_ERR_MissingNetModuleReference();
    internal static string get_ERR_MissingNext();
    internal static string get_ERR_MissingRaiseEventDef1();
    internal static string get_ERR_MissingRemoveHandlerDef1();
    internal static string get_ERR_MissingRuntimeHelper();
    internal static string get_ERR_MissingSubscript();
    internal static string get_ERR_MissingValuesForArraysInApplAttrs();
    internal static string get_ERR_MissingVersionInXmlDecl();
    internal static string get_ERR_MissingXmlEndTag();
    internal static string get_ERR_MixingWinRTAndNETEvents();
    internal static string get_ERR_ModuleAsType1();
    internal static string get_ERR_ModuleCantImplement();
    internal static string get_ERR_ModuleCantInherit();
    internal static string get_ERR_ModuleCantUseDLLDeclareSpecifier1();
    internal static string get_ERR_ModuleCantUseEventSpecifier1();
    internal static string get_ERR_ModuleCantUseMethodSpecifier1();
    internal static string get_ERR_ModuleCantUseTypeSpecifier1();
    internal static string get_ERR_ModuleCantUseVariableSpecifier1();
    internal static string get_ERR_ModuleEmitFailure();
    internal static string get_ERR_ModuleMemberCantImplement();
    internal static string get_ERR_ModuleNotAtNamespace();
    internal static string get_ERR_ModulesCannotBeGeneric();
    internal static string get_ERR_MoreThanOneValidMainWasFound2();
    internal static string get_ERR_MultilineLambdaMissingFunction();
    internal static string get_ERR_MultilineLambdaMissingSub();
    internal static string get_ERR_MultilineLambdasCannotContainOnError();
    internal static string get_ERR_MultipleClassConstraints1();
    internal static string get_ERR_MultipleEventImplMismatch3();
    internal static string get_ERR_MultipleExtends();
    internal static string get_ERR_MultipleNewConstraints();
    internal static string get_ERR_MultipleOptionalParameterSpecifiers();
    internal static string get_ERR_MultipleParameterSpecifiers();
    internal static string get_ERR_MultipleReferenceConstraints();
    internal static string get_ERR_MultipleValueConstraints();
    internal static string get_ERR_MultiplyDefined1();
    internal static string get_ERR_MultiplyDefinedEnumMember2();
    internal static string get_ERR_MultiplyDefinedType3();
    internal static string get_ERR_MustBeInCatchToRethrow();
    internal static string get_ERR_MustBeOverloads2();
    internal static string get_ERR_MustInheritEventNotOverridden();
    internal static string get_ERR_MustInheritForNewConstraint2();
    internal static string get_ERR_MustOverOnNotInheritPartClsMem1();
    internal static string get_ERR_MustOverridesInClass1();
    internal static string get_ERR_MustShadow2();
    internal static string get_ERR_MutuallyExclusiveOptions();
    internal static string get_ERR_MyBaseAbstractCall1();
    internal static string get_ERR_MyClassAbstractCall1();
    internal static string get_ERR_MyClassNotInClass();
    internal static string get_ERR_MyGroupCollectionAttributeCycle();
    internal static string get_ERR_NamedArgAlsoOmitted1();
    internal static string get_ERR_NamedArgAlsoOmitted2();
    internal static string get_ERR_NamedArgAlsoOmitted3();
    internal static string get_ERR_NamedArgUsedTwice1();
    internal static string get_ERR_NamedArgUsedTwice2();
    internal static string get_ERR_NamedArgUsedTwice3();
    internal static string get_ERR_NamedParamArrayArgument();
    internal static string get_ERR_NamedParamNotFound1();
    internal static string get_ERR_NamedParamNotFound2();
    internal static string get_ERR_NamedParamNotFound3();
    internal static string get_ERR_NamedSubscript();
    internal static string get_ERR_NameNotDeclared1();
    internal static string get_ERR_NameNotEvent2();
    internal static string get_ERR_NameNotMember2();
    internal static string get_ERR_NameNotMemberOfAnonymousType2();
    internal static string get_ERR_NameSameAsMethodTypeParam1();
    internal static string get_ERR_NamespaceNotAllowedInScript();
    internal static string get_ERR_NamespaceNotAtNamespace();
    internal static string get_ERR_NamespaceNotExpression1();
    internal static string get_ERR_NarrowingConversionCollection2();
    internal static string get_ERR_NarrowingConversionDisallowed2();
    internal static string get_ERR_NeedModule();
    internal static string get_ERR_NegativeArraySize();
    internal static string get_ERR_NestedBase2();
    internal static string get_ERR_NestedExternalSource();
    internal static string get_ERR_NestedFunctionArgumentNarrowing3();
    internal static string get_ERR_NestedGlobalNamespace();
    internal static string get_ERR_NestedInteropType();
    internal static string get_ERR_NestedTypeInInheritsClause2();
    internal static string get_ERR_NestingViolatesCLS1();
    internal static string get_ERR_NetModuleNameMismatch();
    internal static string get_ERR_NetModuleNameMustBeUnique();
    internal static string get_ERR_NewAndValueConstraintsCombined();
    internal static string get_ERR_NewArgsDisallowedForTypeParam();
    internal static string get_ERR_NewCannotHandleEvents();
    internal static string get_ERR_NewIfNullOnGenericParam();
    internal static string get_ERR_NewIfNullOnNonClass();
    internal static string get_ERR_NewInInterface();
    internal static string get_ERR_NewInStruct();
    internal static string get_ERR_NewOnAbstractClass();
    internal static string get_ERR_NextForMismatch1();
    internal static string get_ERR_NextNoMatchingFor();
    internal static string get_ERR_NoAccessibleConstructorOnBase();
    internal static string get_ERR_NoAccessibleGet();
    internal static string get_ERR_NoAccessibleSet();
    internal static string get_ERR_NoAddMethod1();
    internal static string get_ERR_NoArgumentCountOverloadCandidates1();
    internal static string get_ERR_NoCallableOverloadCandidates2();
    internal static string get_ERR_NoConstituentArraySizes();
    internal static string get_ERR_NoConstructorOnBase2();
    internal static string get_ERR_NoDefaultNotExtend1();
    internal static string get_ERR_NoDirectDelegateConstruction1();
    internal static string get_ERR_NoExplicitArraySizes();
    internal static string get_ERR_NoGetProperty1();
    internal static string get_ERR_NoGlobalExpectedIdentifier();
    internal static string get_ERR_NoGlobalInHandles();
    internal static string get_ERR_NoMostSpecificOverload2();
    internal static string get_ERR_NonFieldPropertyAggrMemberInit1();
    internal static string get_ERR_NonNamespaceOrClassOnImport2();
    internal static string get_ERR_NoNonIndexProperty1();
    internal static string get_ERR_NoNonNarrowingOverloadCandidates2();
    internal static string get_ERR_NoNonObsoleteConstructorOnBase3();
    internal static string get_ERR_NoNonObsoleteConstructorOnBase4();
    internal static string get_ERR_NoPartialMethodInAddressOf1();
    internal static string get_ERR_NoPIAAttributeMissing2();
    internal static string get_ERR_NoResponseFile();
    internal static string get_ERR_NoSetProperty1();
    internal static string get_ERR_NoSources();
    internal static string get_ERR_NoSourcesOut();
    internal static string get_ERR_NoSuitableNewForNewConstraint2();
    internal static string get_ERR_NoSuitableWidestType1();
    internal static string get_ERR_NotACollection1();
    internal static string get_ERR_NotMostSpecificOverload();
    internal static string get_ERR_NotOverridableRequiresOverrides();
    internal static string get_ERR_NoTypeArgumentCountOverloadCand1();
    internal static string get_ERR_NoTypecharInAlias();
    internal static string get_ERR_NoTypecharInLabel();
    internal static string get_ERR_NoUniqueConstructorOnBase2();
    internal static string get_ERR_NoViableOverloadCandidates1();
    internal static string get_ERR_NoWithEventsVarOnHandlesList();
    internal static string get_ERR_NoXmlAxesLateBinding();
    internal static string get_ERR_NoZeroCountArgumentInitCandidates1();
    internal static string get_ERR_NullableCharNotSupported();
    internal static string get_ERR_NullableDisallowedForStructConstr1();
    internal static string get_ERR_NullableImplicit();
    internal static string get_ERR_NullableParameterMustSpecifyType();
    internal static string get_ERR_NullableTypeInferenceNotSupported();
    internal static string get_ERR_NullPropagatingOpInExpressionTree();
    internal static string get_ERR_ObjectInitializerRequiresFieldName();
    internal static string get_ERR_ObjectReferenceNotSupplied();
    internal static string get_ERR_ObsoleteArgumentsNeedParens();
    internal static string get_ERR_ObsoleteAsAny();
    internal static string get_ERR_ObsoleteEndIf();
    internal static string get_ERR_ObsoleteExponent();
    internal static string get_ERR_ObsoleteGetStatement();
    internal static string get_ERR_ObsoleteGosub();
    internal static string get_ERR_ObsoleteInvalidOnEventMember();
    internal static string get_ERR_ObsoleteLetSetNotNeeded();
    internal static string get_ERR_ObsoleteLineNumbersAreLabels();
    internal static string get_ERR_ObsoleteObjectNotVariant();
    internal static string get_ERR_ObsoleteOnGotoGosub();
    internal static string get_ERR_ObsoleteOptionalWithoutValue();
    internal static string get_ERR_ObsoletePropertyGetLetSet();
    internal static string get_ERR_ObsoleteRedimAs();
    internal static string get_ERR_ObsoleteStructureNotType();
    internal static string get_ERR_ObsoleteWhileWend();
    internal static string get_ERR_OfExpected();
    internal static string get_ERR_OmittedArgument1();
    internal static string get_ERR_OmittedArgument2();
    internal static string get_ERR_OmittedArgument3();
    internal static string get_ERR_OmittedParamArrayArgument();
    internal static string get_ERR_OneOrTwoParametersRequired1();
    internal static string get_ERR_OneParameterRequired1();
    internal static string get_ERR_OnErrorInSyncLock();
    internal static string get_ERR_OnErrorInUsing();
    internal static string get_ERR_OnlyNullLowerBound();
    internal static string get_ERR_OnlyOneAccessorForGetSet();
    internal static string get_ERR_OnlyOneImplementingMethodAllowed3();
    internal static string get_ERR_OnlyOnePartialMethodAllowed2();
    internal static string get_ERR_OnlyPrivatePartialMethods1();
    internal static string get_ERR_OpenTypeDisallowed();
    internal static string get_ERR_OperatorDeclaredInModule();
    internal static string get_ERR_OperatorMustBePublic();
    internal static string get_ERR_OperatorMustBeShared();
    internal static string get_ERR_OperatorNotOverloadable();
    internal static string get_ERR_OperatorRequiresBoolReturnType1();
    internal static string get_ERR_OperatorRequiresIntegerParameter1();
    internal static string get_ERR_OptionalIllegal1();
    internal static string get_ERR_OptionalsCantBeStructGenericParams();
    internal static string get_ERR_OptionMustBeAbsolutePath();
    internal static string get_ERR_OptionStmtWrongOrder();
    internal static string get_ERR_Overflow();
    internal static string get_ERR_OverloadCandidate1();
    internal static string get_ERR_OverloadCandidate2();
    internal static string get_ERR_OverloadingPropertyKind2();
    internal static string get_ERR_OverloadsModifierInModule();
    internal static string get_ERR_OverloadWithArrayVsParamArray2();
    internal static string get_ERR_OverloadWithByref2();
    internal static string get_ERR_OverloadWithDefault2();
    internal static string get_ERR_OverloadWithOptional2();
    internal static string get_ERR_OverloadWithReturnType2();
    internal static string get_ERR_OverriddenCandidate1();
    internal static string get_ERR_OverrideNotNeeded3();
    internal static string get_ERR_OverridesImpliesOverridable();
    internal static string get_ERR_OverrideWithArrayVsParamArray2();
    internal static string get_ERR_OverrideWithByref2();
    internal static string get_ERR_OverrideWithConstraintMismatch2();
    internal static string get_ERR_OverrideWithDefault2();
    internal static string get_ERR_OverrideWithOptional2();
    internal static string get_ERR_OverrideWithOptionalTypes2();
    internal static string get_ERR_OverridingPropertyKind2();
    internal static string get_ERR_ParamArrayArgumentMismatch();
    internal static string get_ERR_ParamArrayIllegal1();
    internal static string get_ERR_ParamArrayMustBeByVal();
    internal static string get_ERR_ParamArrayMustBeLast();
    internal static string get_ERR_ParamArrayNotArray();
    internal static string get_ERR_ParamArrayRank();
    internal static string get_ERR_ParamArrayWithOptArgs();
    internal static string get_ERR_ParamArrayWrongType();
    internal static string get_ERR_ParamDefaultValueDiffersFromAttribute();
    internal static string get_ERR_ParameterizedPropertyInAggrInit1();
    internal static string get_ERR_ParameterNotValidForType();
    internal static string get_ERR_ParamNameFunctionNameCollision();
    internal static string get_ERR_ParamTypingInconsistency();
    internal static string get_ERR_PartialDeclarationImplements1();
    internal static string get_ERR_PartialMethodDefaultParameterValueMismatch2();
    internal static string get_ERR_PartialMethodGenericConstraints2();
    internal static string get_ERR_PartialMethodMustBeEmpty();
    internal static string get_ERR_PartialMethodParamArrayMismatch2();
    internal static string get_ERR_PartialMethodParamNamesMustMatch3();
    internal static string get_ERR_PartialMethodsMustBePrivate();
    internal static string get_ERR_PartialMethodsMustBeSub1();
    internal static string get_ERR_PartialMethodsMustNotBeAsync1();
    internal static string get_ERR_PartialMethodTypeParamNameMismatch3();
    internal static string get_ERR_PartialTypeAccessMismatch3();
    internal static string get_ERR_PartialTypeBadMustInherit1();
    internal static string get_ERR_PartialTypeConstraintMismatch1();
    internal static string get_ERR_PartialTypeTypeParamNameMismatch3();
    internal static string get_ERR_PDBWritingFailed();
    internal static string get_ERR_PermissionSetAttributeFileReadError();
    internal static string get_ERR_PermissionSetAttributeInvalidFile();
    internal static string get_ERR_PeWritingFailure();
    internal static string get_ERR_PIAHasNoAssemblyGuid1();
    internal static string get_ERR_PIAHasNoTypeLibAttribute1();
    internal static string get_ERR_PlatformDoesntSupport();
    internal static string get_ERR_PrincipalPermissionInvalidAction();
    internal static string get_ERR_PrivateTypeOutsideType();
    internal static string get_ERR_ProjectCCError1();
    internal static string get_ERR_PropertyAccessIgnored();
    internal static string get_ERR_PropertyDoesntImplementAllAccessors();
    internal static string get_ERR_PropertyNameConflictInMyCollection();
    internal static string get_ERR_PropertyOrFieldNotDefined1();
    internal static string get_ERR_PropertySetParamCollisionWithValue();
    internal static string get_ERR_PropMustHaveGetSet();
    internal static string get_ERR_ProtectedTypeOutsideClass();
    internal static string get_ERR_PublicKeyContainerFailure();
    internal static string get_ERR_PublicKeyFileFailure();
    internal static string get_ERR_PublicSignNoKey();
    internal static string get_ERR_QualifiedNameNotAllowed();
    internal static string get_ERR_QualNotObjectRecord1();
    internal static string get_ERR_QueryAnonTypeFieldXMLNameInference();
    internal static string get_ERR_QueryAnonymousTypeDisallowsTypeChar();
    internal static string get_ERR_QueryAnonymousTypeFieldNameInference();
    internal static string get_ERR_QueryDuplicateAnonTypeMemberName1();
    internal static string get_ERR_QueryInvalidControlVariableName1();
    internal static string get_ERR_QueryNameNotDeclared();
    internal static string get_ERR_QueryOperatorNotFound();
    internal static string get_ERR_QueryStrictDisallowImplicitObject();
    internal static string get_ERR_QuotedEmbeddedExpression();
    internal static string get_ERR_RaiseEventShapeMismatch1();
    internal static string get_ERR_ReadOnlyAssignment();
    internal static string get_ERR_ReadOnlyHasNoGet();
    internal static string get_ERR_ReadOnlyHasSet();
    internal static string get_ERR_ReadOnlyInClosure();
    internal static string get_ERR_ReadOnlyNoAccessorFlag();
    internal static string get_ERR_ReadOnlyProperty1();
    internal static string get_ERR_RecordCycle2();
    internal static string get_ERR_RecordEmbeds2();
    internal static string get_ERR_RedimNoSizes();
    internal static string get_ERR_RedimRankMismatch();
    internal static string get_ERR_RefAndClassTypeConstrCombined();
    internal static string get_ERR_RefAndValueConstraintsCombined();
    internal static string get_ERR_ReferenceComparison3();
    internal static string get_ERR_ReferenceDirectiveOnlyAllowedInScripts();
    internal static string get_ERR_ReImplementingWinRTInterface4();
    internal static string get_ERR_ReImplementingWinRTInterface5();
    internal static string get_ERR_RemoveParamWrongForWinRT();
    internal static string get_ERR_RequiredAttributeConstConversion2();
    internal static string get_ERR_RequiredConstConversion2();
    internal static string get_ERR_RequiredConstExpr();
    internal static string get_ERR_RequiredNewCall2();
    internal static string get_ERR_RequiredNewCallTooMany2();
    internal static string get_ERR_RequiredNonObsoleteNewCall3();
    internal static string get_ERR_RequiredNonObsoleteNewCall4();
    internal static string get_ERR_ReservedAssemblyName();
    internal static string get_ERR_ReservedXmlNamespace();
    internal static string get_ERR_ReservedXmlPrefix();
    internal static string get_ERR_ResourceInModule();
    internal static string get_ERR_RestrictedAccess();
    internal static string get_ERR_RestrictedConversion1();
    internal static string get_ERR_RestrictedResumableType1();
    internal static string get_ERR_RestrictedType1();
    internal static string get_ERR_ResumableLambdaInExpressionTree();
    internal static string get_ERR_ResumablesCannotContainOnError();
    internal static string get_ERR_ReturnFromNonFunction();
    internal static string get_ERR_ReturnFromNonGenericTaskAsync();
    internal static string get_ERR_ReturnWithoutValue();
    internal static string get_ERR_RuntimeMemberNotFound2();
    internal static string get_ERR_SecurityAttributeInvalidAction();
    internal static string get_ERR_SecurityAttributeInvalidActionAssembly();
    internal static string get_ERR_SecurityAttributeInvalidActionTypeOrMethod();
    internal static string get_ERR_SecurityAttributeInvalidTarget();
    internal static string get_ERR_SecurityAttributeMissingAction();
    internal static string get_ERR_SecurityCriticalAsync();
    internal static string get_ERR_SecurityCriticalAsyncInClassOrStruct();
    internal static string get_ERR_SetHasOnlyOneParam();
    internal static string get_ERR_SetHasToBeByVal1();
    internal static string get_ERR_SetValueNotPropertyType();
    internal static string get_ERR_ShadowingGenericParamWithMember1();
    internal static string get_ERR_ShadowingTypeOutsideClass1();
    internal static string get_ERR_SharedConstructorIllegalSpec1();
    internal static string get_ERR_SharedConstructorWithParams();
    internal static string get_ERR_SharedEventNeedsSharedHandler();
    internal static string get_ERR_SharedMemberAggrMemberInit1();
    internal static string get_ERR_SharedOnProcThatImpl();
    internal static string get_ERR_SharedStructMemberCannotSpecifyNew();
    internal static string get_ERR_SignButNoPrivateKey();
    internal static string get_ERR_SourceInterfaceMustBeInterface();
    internal static string get_ERR_SpecifiersInvalidOnInheritsImplOpt();
    internal static string get_ERR_SpecifiersInvOnEventMethod();
    internal static string get_ERR_StandaloneAttribute();
    internal static string get_ERR_StartAttributeValue();
    internal static string get_ERR_StartupCodeNotFound1();
    internal static string get_ERR_StatementLambdaInExpressionTree();
    internal static string get_ERR_STAThreadAndMTAThread0();
    internal static string get_ERR_StaticInLambda();
    internal static string get_ERR_StrictArgumentCopyBackNarrowing3();
    internal static string get_ERR_StrictDisallowImplicitObject();
    internal static string get_ERR_StrictDisallowImplicitObjectLambda();
    internal static string get_ERR_StrictDisallowsImplicitArgs();
    internal static string get_ERR_StrictDisallowsImplicitProc();
    internal static string get_ERR_StrictDisallowsLateBinding();
    internal static string get_ERR_StrictDisallowsObjectComparison1();
    internal static string get_ERR_StrictDisallowsObjectOperand1();
    internal static string get_ERR_StructCantInherit();
    internal static string get_ERR_StructCantUseDLLDeclareSpecifier1();
    internal static string get_ERR_StructCantUseVarSpecifier1();
    internal static string get_ERR_StructLayoutAttributeNotAllowed();
    internal static string get_ERR_StructsCannotHandleEvents();
    internal static string get_ERR_StructureCantUseProtected();
    internal static string get_ERR_StructureNoDefault1();
    internal static string get_ERR_StructureNotExpression1();
    internal static string get_ERR_SubDisallowsStatement();
    internal static string get_ERR_SubNewCycle1();
    internal static string get_ERR_SubNewCycle2();
    internal static string get_ERR_SubRequiresParenthesesBang();
    internal static string get_ERR_SubRequiresParenthesesDot();
    internal static string get_ERR_SubRequiresParenthesesLParen();
    internal static string get_ERR_SubRequiresSingleStatement();
    internal static string get_ERR_SwitchNeedsBool();
    internal static string get_ERR_SxSIndirectRefHigherThanDirectRef3();
    internal static string get_ERR_SynchronizedAsyncMethod();
    internal static string get_ERR_SyncLockRequiresReferenceType1();
    internal static string get_ERR_Syntax();
    internal static string get_ERR_SyntaxInCastOp();
    internal static string get_ERR_SynthMemberClashesWithMember5();
    internal static string get_ERR_SynthMemberClashesWithSynth7();
    internal static string get_ERR_SynthMemberShadowsMustOverride5();
    internal static string get_ERR_SyntMemberShadowsGenericParam3();
    internal static string get_ERR_TooFewGenericArguments1();
    internal static string get_ERR_TooFewGenericArguments2();
    internal static string get_ERR_TooFewIndices();
    internal static string get_ERR_TooLongMetadataName();
    internal static string get_ERR_TooLongOrComplexExpression();
    internal static string get_ERR_TooManyArgs();
    internal static string get_ERR_TooManyArgs1();
    internal static string get_ERR_TooManyArgs2();
    internal static string get_ERR_TooManyGenericArguments1();
    internal static string get_ERR_TooManyGenericArguments2();
    internal static string get_ERR_TooManyIndices();
    internal static string get_ERR_TooManyUserStrings();
    internal static string get_ERR_TryAndOnErrorDoNotMix();
    internal static string get_ERR_TryCastOfUnconstrainedTypeParam1();
    internal static string get_ERR_TryCastOfValueType1();
    internal static string get_ERR_TryWithoutCatchOrFinally();
    internal static string get_ERR_TwoParametersRequired1();
    internal static string get_ERR_TypeArgsUnexpected();
    internal static string get_ERR_TypecharNoMatch2();
    internal static string get_ERR_TypecharNotallowed();
    internal static string get_ERR_TypeCharOnAggregation();
    internal static string get_ERR_TypeCharOnGenericParam();
    internal static string get_ERR_TypeCharOnSub();
    internal static string get_ERR_TypeCharWithType1();
    internal static string get_ERR_TypeClashesWithVbCoreType4();
    internal static string get_ERR_TypeConflict6();
    internal static string get_ERR_TypeDisallowsAttributes();
    internal static string get_ERR_TypeDisallowsDescendants();
    internal static string get_ERR_TypeDisallowsElements();
    internal static string get_ERR_TypeFwdCycle2();
    internal static string get_ERR_TypeInferenceArrayRankMismatch1();
    internal static string get_ERR_TypeInferenceFailure1();
    internal static string get_ERR_TypeInferenceFailure2();
    internal static string get_ERR_TypeInferenceFailure3();
    internal static string get_ERR_TypeInferenceFailureAmbiguous1();
    internal static string get_ERR_TypeInferenceFailureAmbiguous2();
    internal static string get_ERR_TypeInferenceFailureAmbiguous3();
    internal static string get_ERR_TypeInferenceFailureNoBest1();
    internal static string get_ERR_TypeInferenceFailureNoBest2();
    internal static string get_ERR_TypeInferenceFailureNoBest3();
    internal static string get_ERR_TypeInferenceFailureNoExplicit1();
    internal static string get_ERR_TypeInferenceFailureNoExplicit2();
    internal static string get_ERR_TypeInferenceFailureNoExplicit3();
    internal static string get_ERR_TypeInferenceFailureNoExplicitAmbiguous1();
    internal static string get_ERR_TypeInferenceFailureNoExplicitAmbiguous2();
    internal static string get_ERR_TypeInferenceFailureNoExplicitAmbiguous3();
    internal static string get_ERR_TypeInferenceFailureNoExplicitNoBest1();
    internal static string get_ERR_TypeInferenceFailureNoExplicitNoBest2();
    internal static string get_ERR_TypeInferenceFailureNoExplicitNoBest3();
    internal static string get_ERR_TypeInItsInheritsClause1();
    internal static string get_ERR_TypeMismatch2();
    internal static string get_ERR_TypeMismatchForXml3();
    internal static string get_ERR_TypeNotExpression1();
    internal static string get_ERR_TypeOfExprAlwaysFalse2();
    internal static string get_ERR_TypeOfRequiresReferenceType1();
    internal static string get_ERR_TypeOrMemberNotGeneric1();
    internal static string get_ERR_TypeOrMemberNotGeneric2();
    internal static string get_ERR_TypeParamMissingAsCommaOrRParen();
    internal static string get_ERR_TypeParamMissingCommaOrRParen();
    internal static string get_ERR_TypeParamNameFunctionNameCollision();
    internal static string get_ERR_TypeParamQualifierDisallowed();
    internal static string get_ERR_TypeParamWithStructConstAsConst();
    internal static string get_ERR_TypeRefResolutionError3();
    internal static string get_ERR_UnableToCreateTempFile();
    internal static string get_ERR_UnableToOpenResourceFile1();
    internal static string get_ERR_UnableToReadUacManifest2();
    internal static string get_ERR_UnacceptableForLoopOperator2();
    internal static string get_ERR_UnacceptableForLoopRelOperator2();
    internal static string get_ERR_UnacceptableLogicalOperator3();
    internal static string get_ERR_UnaryOperand2();
    internal static string get_ERR_UnaryParamMustBeContainingType1();
    internal static string get_ERR_UnboundTypeParam1();
    internal static string get_ERR_UnboundTypeParam2();
    internal static string get_ERR_UnboundTypeParam3();
    internal static string get_ERR_UndefinedType1();
    internal static string get_ERR_UndefinedTypeOrNamespace1();
    internal static string get_ERR_UndefinedXmlPrefix();
    internal static string get_ERR_UnexpectedExpressionStatement();
    internal static string get_ERR_UnexpectedGroup();
    internal static string get_ERR_UnimplementedMember3();
    internal static string get_ERR_UnimplementedMustOverride();
    internal static string get_ERR_UnknownOperator();
    internal static string get_ERR_UnrecognizedEnd();
    internal static string get_ERR_UnrecognizedType();
    internal static string get_ERR_UnrecognizedTypeKeyword();
    internal static string get_ERR_UnrecognizedTypeOrWith();
    internal static string get_ERR_UnreferencedAssembly3();
    internal static string get_ERR_UnreferencedAssemblyBase3();
    internal static string get_ERR_UnreferencedAssemblyEvent3();
    internal static string get_ERR_UnreferencedAssemblyImplements3();
    internal static string get_ERR_UnreferencedModule3();
    internal static string get_ERR_UnreferencedModuleBase3();
    internal static string get_ERR_UnreferencedModuleEvent3();
    internal static string get_ERR_UnreferencedModuleImplements3();
    internal static string get_ERR_UnsupportedConstant2();
    internal static string get_ERR_UnsupportedEvent1();
    internal static string get_ERR_UnsupportedField1();
    internal static string get_ERR_UnsupportedMethod1();
    internal static string get_ERR_UnsupportedModule1();
    internal static string get_ERR_UnsupportedProperty1();
    internal static string get_ERR_UnsupportedType1();
    internal static string get_ERR_UnterminatedStringLiteral();
    internal static string get_ERR_UseOfKeywordFromModule1();
    internal static string get_ERR_UseOfKeywordFromStructure1();
    internal static string get_ERR_UseOfKeywordNotInInstanceMethod1();
    internal static string get_ERR_UseOfLocalBeforeDeclaration1();
    internal static string get_ERR_UseOfObsoletePropertyAccessor2();
    internal static string get_ERR_UseOfObsoletePropertyAccessor3();
    internal static string get_ERR_UseOfObsoleteSymbol2();
    internal static string get_ERR_UseOfObsoleteSymbolNoMessage1();
    internal static string get_ERR_UsingRequiresDisposePattern();
    internal static string get_ERR_UsingResourceVarCantBeArray();
    internal static string get_ERR_UsingResourceVarNeedsInitializer();
    internal static string get_ERR_ValueAndClassTypeConstrCombined();
    internal static string get_ERR_VarianceConversionFailedIn6();
    internal static string get_ERR_VarianceConversionFailedOut6();
    internal static string get_ERR_VarianceConversionFailedTryIn4();
    internal static string get_ERR_VarianceConversionFailedTryOut4();
    internal static string get_ERR_VarianceDisallowedHere();
    internal static string get_ERR_VarianceIEnumerableSuggestion3();
    internal static string get_ERR_VarianceInByRefDisallowed1();
    internal static string get_ERR_VarianceInNullableDisallowed2();
    internal static string get_ERR_VarianceInParamDisallowed1();
    internal static string get_ERR_VarianceInParamDisallowedForGeneric3();
    internal static string get_ERR_VarianceInParamDisallowedHere2();
    internal static string get_ERR_VarianceInParamDisallowedHereForGeneric4();
    internal static string get_ERR_VarianceInPropertyDisallowed1();
    internal static string get_ERR_VarianceInReadOnlyPropertyDisallowed1();
    internal static string get_ERR_VarianceInReturnDisallowed1();
    internal static string get_ERR_VarianceInterfaceNesting();
    internal static string get_ERR_VarianceOutByRefDisallowed1();
    internal static string get_ERR_VarianceOutByValDisallowed1();
    internal static string get_ERR_VarianceOutConstraintDisallowed1();
    internal static string get_ERR_VarianceOutNullableDisallowed2();
    internal static string get_ERR_VarianceOutParamDisallowed1();
    internal static string get_ERR_VarianceOutParamDisallowedForGeneric3();
    internal static string get_ERR_VarianceOutParamDisallowedHere2();
    internal static string get_ERR_VarianceOutParamDisallowedHereForGeneric4();
    internal static string get_ERR_VarianceOutPropertyDisallowed1();
    internal static string get_ERR_VarianceOutWriteOnlyPropertyDisallowed1();
    internal static string get_ERR_VariancePreventsSynthesizedEvents2();
    internal static string get_ERR_VarianceTypeDisallowed2();
    internal static string get_ERR_VarianceTypeDisallowedForGeneric4();
    internal static string get_ERR_VarianceTypeDisallowedHere3();
    internal static string get_ERR_VarianceTypeDisallowedHereForGeneric5();
    internal static string get_ERR_VBCoreNetModuleConflict();
    internal static string get_ERR_VersionMustBeFirstInXmlDecl();
    internal static string get_ERR_VoidArrayDisallowed();
    internal static string get_ERR_VoidValue();
    internal static string get_ERR_WinRTEventWithoutDelegate();
    internal static string get_ERR_WithEventsAsStruct();
    internal static string get_ERR_WithEventsRequiresClass();
    internal static string get_ERR_WriteOnlyHasGet();
    internal static string get_ERR_WriteOnlyHasNoWrite();
    internal static string get_ERR_WriteOnlyNoAccessorFlag();
    internal static string get_ERR_XmlEndCDataNotAllowedInContent();
    internal static string get_ERR_XmlEndElementNoMatchingStart();
    internal static string get_ERR_XmlEntityReference();
    internal static string get_ERR_XmlFeaturesNotAvailable();
    internal static string get_ERR_XmlPrefixNotExpression();
    internal static string get_ERR_ZeroDivide();
    internal static string get_FEATURE_ArrayLiterals();
    internal static string get_FEATURE_AsyncExpressions();
    internal static string get_FEATURE_AutoProperties();
    internal static string get_FEATURE_CObjInAttributeArguments();
    internal static string get_FEATURE_CoContraVariance();
    internal static string get_FEATURE_CollectionInitializers();
    internal static string get_FEATURE_GlobalNamespace();
    internal static string get_FEATURE_ImplementingReadonlyOrWriteonlyPropertyWithReadwrite();
    internal static string get_FEATURE_Iterators();
    internal static string get_FEATURE_LineContinuation();
    internal static string get_FEATURE_LineContinuationComments();
    internal static string get_FEATURE_MultilineStringLiterals();
    internal static string get_FEATURE_NameOfExpressions();
    internal static string get_FEATURE_NullPropagatingOperator();
    internal static string get_FEATURE_PartialInterfaces();
    internal static string get_FEATURE_PartialModules();
    internal static string get_FEATURE_ReadonlyAutoProperties();
    internal static string get_FEATURE_RegionsEverywhere();
    internal static string get_FEATURE_StatementLambdas();
    internal static string get_FEATURE_SubLambdas();
    internal static string get_FEATURE_TypeOfIsNot();
    internal static string get_FEATURE_WarningDirectives();
    internal static string get_FEATURE_YearFirstDateLiterals();
    internal static string get_FieldInitializerSyntaxNotWithinSyntaxTree();
    internal static string get_FTL_InputFileNameTooLong();
    internal static string get_FunctionSyntaxNotWithinSyntaxTree();
    internal static string get_HDN_UnusedImportClause();
    internal static string get_HDN_UnusedImportClause_Title();
    internal static string get_HDN_UnusedImportStatement();
    internal static string get_HDN_UnusedImportStatement_Title();
    internal static string get_IdentifierSyntaxNotWithinSyntaxTree();
    internal static string get_IDS_FunctionReturnType();
    internal static string get_IDS_InvalidPreprocessorConstantType();
    internal static string get_IDS_LogoLine1();
    internal static string get_IDS_LogoLine2();
    internal static string get_IDS_MSG_ADDLINKREFERENCE();
    internal static string get_IDS_MSG_ADDMODULE();
    internal static string get_IDS_MSG_ADDREFERENCE();
    internal static string get_IDS_ProjectSettingsLocationName();
    internal static string get_IDS_TheSystemCannotFindThePathSpecified();
    internal static string get_IDS_ToolName();
    internal static string get_IDS_UnrecognizedFileFormat();
    internal static string get_IDS_VBCHelp();
    internal static string get_INF_UnableToLoadSomeTypesInAnalyzer();
    internal static string get_INF_UnableToLoadSomeTypesInAnalyzer_Title();
    internal static string get_LocationMustBeProvided();
    internal static string get_NodeIsNotWithinSyntaxTree();
    internal static string get_NoNoneSearchCriteria();
    internal static string get_NotAVbSymbol();
    internal static string get_NotWithinTree();
    internal static string get_NumberOfTypeParametersAndArgumentsMustMatch();
    internal static string get_PositionIsNotWithinSyntax();
    internal static string get_PositionNotWithinTree();
    internal static string get_PositionOfTypeParameterTooLarge();
    internal static string get_PropertiesCanNotHaveTypeArguments();
    internal static string get_RangeVariableSyntaxNotWithinSyntaxTree();
    internal static string get_SemanticModelMustBeProvided();
    internal static string get_SpeculatedSyntaxNodeCannotBelongToCurrentCompilation();
    internal static string get_StatementOrExpressionIsNotAValidType();
    internal static string get_SubmissionCanHaveAtMostOneSyntaxTree();
    internal static string get_SyntaxTreeAlreadyPresent();
    internal static string get_SyntaxTreeIsNotASubmission();
    internal static string get_SyntaxTreeNotFoundToRemove();
    internal static string get_ThereAreNoPointerTypesInVB();
    internal static string get_ThereIsNoDynamicTypeInVB();
    internal static string get_TreeMustHaveARootNodeWithCompilationUnit();
    internal static string get_Trees0();
    internal static string get_TreesMustHaveRootNode();
    internal static string get_TypeArgumentCannotBeNothing();
    internal static string get_TypeParameterNotWithinTree();
    internal static string get_VariableSyntaxNotWithinSyntaxTree();
    internal static string get_WRN_AmbiguousCastConversion2();
    internal static string get_WRN_AmbiguousCastConversion2_Title();
    internal static string get_WRN_AnalyzerCannotBeCreated();
    internal static string get_WRN_AnalyzerCannotBeCreated_Title();
    internal static string get_WRN_ArrayInitNoTypeObjectAssumed();
    internal static string get_WRN_ArrayInitNoTypeObjectAssumed_Title();
    internal static string get_WRN_ArrayInitTooManyTypesObjectAssumed();
    internal static string get_WRN_ArrayInitTooManyTypesObjectAssumed_Title();
    internal static string get_WRN_ArrayOverloadsNonCLS2();
    internal static string get_WRN_ArrayOverloadsNonCLS2_Title();
    internal static string get_WRN_AssemblyAttributeFromModuleIsOverridden();
    internal static string get_WRN_AssemblyAttributeFromModuleIsOverridden_Title();
    internal static string get_WRN_AssemblyGeneration0();
    internal static string get_WRN_AssemblyGeneration0_Title();
    internal static string get_WRN_AssemblyGeneration1();
    internal static string get_WRN_AssemblyGeneration1_Title();
    internal static string get_WRN_AsyncLacksAwaits();
    internal static string get_WRN_AsyncLacksAwaits_Title();
    internal static string get_WRN_AsyncSubCouldBeFunction();
    internal static string get_WRN_AsyncSubCouldBeFunction_Title();
    internal static string get_WRN_BadChecksumValExtChecksum();
    internal static string get_WRN_BadChecksumValExtChecksum_Title();
    internal static string get_WRN_BadGUIDFormatExtChecksum();
    internal static string get_WRN_BadGUIDFormatExtChecksum_Title();
    internal static string get_WRN_BadSwitch();
    internal static string get_WRN_BadSwitch_Title();
    internal static string get_WRN_BadUILang();
    internal static string get_WRN_BadUILang_Title();
    internal static string get_WRN_BaseClassNotCLSCompliant2();
    internal static string get_WRN_BaseClassNotCLSCompliant2_Title();
    internal static string get_WRN_CannotFindStandardLibrary1();
    internal static string get_WRN_CannotFindStandardLibrary1_Title();
    internal static string get_WRN_CLSAttrInvalidOnGetSet();
    internal static string get_WRN_CLSAttrInvalidOnGetSet_Title();
    internal static string get_WRN_CLSEventMethodInNonCLSType3();
    internal static string get_WRN_CLSEventMethodInNonCLSType3_Title();
    internal static string get_WRN_CLSMemberInNonCLSType3();
    internal static string get_WRN_CLSMemberInNonCLSType3_Title();
    internal static string get_WRN_ComClassInterfaceShadows5();
    internal static string get_WRN_ComClassInterfaceShadows5_Title();
    internal static string get_WRN_ComClassNoMembers1();
    internal static string get_WRN_ComClassNoMembers1_Title();
    internal static string get_WRN_ComClassPropertySetObject1();
    internal static string get_WRN_ComClassPropertySetObject1_Title();
    internal static string get_WRN_ConditionalNotValidOnFunction();
    internal static string get_WRN_ConditionalNotValidOnFunction_Title();
    internal static string get_WRN_ConflictingMachineAssembly();
    internal static string get_WRN_ConflictingMachineAssembly_Title();
    internal static string get_WRN_ConstraintsFailedForInferredArgs2();
    internal static string get_WRN_ConstraintsFailedForInferredArgs2_Title();
    internal static string get_WRN_DebuggerHiddenIgnoredOnProperties();
    internal static string get_WRN_DebuggerHiddenIgnoredOnProperties_Title();
    internal static string get_WRN_DefAsgNoRetValFuncRef1();
    internal static string get_WRN_DefAsgNoRetValFuncRef1_Title();
    internal static string get_WRN_DefAsgNoRetValFuncVal1();
    internal static string get_WRN_DefAsgNoRetValFuncVal1_Title();
    internal static string get_WRN_DefAsgNoRetValOpRef1();
    internal static string get_WRN_DefAsgNoRetValOpRef1_Title();
    internal static string get_WRN_DefAsgNoRetValOpVal1();
    internal static string get_WRN_DefAsgNoRetValOpVal1_Title();
    internal static string get_WRN_DefAsgNoRetValPropRef1();
    internal static string get_WRN_DefAsgNoRetValPropRef1_Title();
    internal static string get_WRN_DefAsgNoRetValPropVal1();
    internal static string get_WRN_DefAsgNoRetValPropVal1_Title();
    internal static string get_WRN_DefAsgNoRetValWinRtEventVal1();
    internal static string get_WRN_DefAsgNoRetValWinRtEventVal1_Title();
    internal static string get_WRN_DefAsgUseNullRef();
    internal static string get_WRN_DefAsgUseNullRef_Title();
    internal static string get_WRN_DefAsgUseNullRefByRef();
    internal static string get_WRN_DefAsgUseNullRefByRef_Title();
    internal static string get_WRN_DefAsgUseNullRefByRefStr();
    internal static string get_WRN_DefAsgUseNullRefByRefStr_Title();
    internal static string get_WRN_DefAsgUseNullRefStr();
    internal static string get_WRN_DefAsgUseNullRefStr_Title();
    internal static string get_WRN_DefaultnessShadowed4();
    internal static string get_WRN_DefaultnessShadowed4_Title();
    internal static string get_WRN_DelaySignButNoKey();
    internal static string get_WRN_DelaySignButNoKey_Title();
    internal static string get_WRN_DuplicateCatch();
    internal static string get_WRN_DuplicateCatch_Title();
    internal static string get_WRN_EmptyPrefixAndXmlnsLocalName();
    internal static string get_WRN_EmptyPrefixAndXmlnsLocalName_Title();
    internal static string get_WRN_EnumUnderlyingTypeNotCLS1();
    internal static string get_WRN_EnumUnderlyingTypeNotCLS1_Title();
    internal static string get_WRN_EqualToLiteralNothing();
    internal static string get_WRN_EqualToLiteralNothing_Title();
    internal static string get_WRN_EventDelegateTypeNotCLSCompliant2();
    internal static string get_WRN_EventDelegateTypeNotCLSCompliant2_Title();
    internal static string get_WRN_ExpectedInitComponentCall2();
    internal static string get_WRN_ExpectedInitComponentCall2_Title();
    internal static string get_WRN_FieldNotCLSCompliant1();
    internal static string get_WRN_FieldNotCLSCompliant1_Title();
    internal static string get_WRN_FileAlreadyIncluded();
    internal static string get_WRN_FileAlreadyIncluded_Title();
    internal static string get_WRN_GenericConstraintNotCLSCompliant1();
    internal static string get_WRN_GenericConstraintNotCLSCompliant1_Title();
    internal static string get_WRN_IfNoTypeObjectAssumed();
    internal static string get_WRN_IfNoTypeObjectAssumed_Title();
    internal static string get_WRN_IfTooManyTypesObjectAssumed();
    internal static string get_WRN_IfTooManyTypesObjectAssumed_Title();
    internal static string get_WRN_IgnoreModuleManifest();
    internal static string get_WRN_IgnoreModuleManifest_Title();
    internal static string get_WRN_ImplicitConversion2();
    internal static string get_WRN_ImplicitConversion2_Title();
    internal static string get_WRN_ImplicitConversionCopyBack();
    internal static string get_WRN_ImplicitConversionCopyBack_Title();
    internal static string get_WRN_ImplicitConversionSubst1();
    internal static string get_WRN_ImplicitConversionSubst1_Title();
    internal static string get_WRN_IndirectRefToLinkedAssembly2();
    internal static string get_WRN_IndirectRefToLinkedAssembly2_Title();
    internal static string get_WRN_InheritedInterfaceNotCLSCompliant2();
    internal static string get_WRN_InheritedInterfaceNotCLSCompliant2_Title();
    internal static string get_WRN_InterfaceConversion2();
    internal static string get_WRN_InterfaceConversion2_Title();
    internal static string get_WRN_InvalidAssemblyName();
    internal static string get_WRN_InvalidAssemblyName_Title();
    internal static string get_WRN_InvalidVersionFormat();
    internal static string get_WRN_InvalidVersionFormat_Title();
    internal static string get_WRN_InvalidWarningId();
    internal static string get_WRN_InvalidWarningId_Title();
    internal static string get_WRN_LambdaNoTypeObjectAssumed();
    internal static string get_WRN_LambdaNoTypeObjectAssumed_Title();
    internal static string get_WRN_LambdaPassedToRemoveHandler();
    internal static string get_WRN_LambdaPassedToRemoveHandler_Title();
    internal static string get_WRN_LambdaTooManyTypesObjectAssumed();
    internal static string get_WRN_LambdaTooManyTypesObjectAssumed_Title();
    internal static string get_WRN_LateBindingResolution();
    internal static string get_WRN_LateBindingResolution_Title();
    internal static string get_WRN_LiftControlVariableLambda();
    internal static string get_WRN_LiftControlVariableLambda_Title();
    internal static string get_WRN_LiftControlVariableQuery();
    internal static string get_WRN_LiftControlVariableQuery_Title();
    internal static string get_WRN_MainIgnored();
    internal static string get_WRN_MainIgnored_Title();
    internal static string get_WRN_MemberShadowsSynthMember6();
    internal static string get_WRN_MemberShadowsSynthMember6_Title();
    internal static string get_WRN_MissingAsClauseinFunction();
    internal static string get_WRN_MissingAsClauseinFunction_Title();
    internal static string get_WRN_MissingAsClauseinOperator();
    internal static string get_WRN_MissingAsClauseinOperator_Title();
    internal static string get_WRN_MissingAsClauseinProperty();
    internal static string get_WRN_MissingAsClauseinProperty_Title();
    internal static string get_WRN_MissingAsClauseinVarDecl();
    internal static string get_WRN_MissingAsClauseinVarDecl_Title();
    internal static string get_WRN_MultipleDeclFileExtChecksum();
    internal static string get_WRN_MultipleDeclFileExtChecksum_Title();
    internal static string get_WRN_MustOverloadBase4();
    internal static string get_WRN_MustOverloadBase4_Title();
    internal static string get_WRN_MustOverride2();
    internal static string get_WRN_MustOverride2_Title();
    internal static string get_WRN_MustShadowOnMultipleInheritance2();
    internal static string get_WRN_MustShadowOnMultipleInheritance2_Title();
    internal static string get_WRN_MutableGenericStructureInUsing();
    internal static string get_WRN_MutableGenericStructureInUsing_Title();
    internal static string get_WRN_MutableStructureInUsing();
    internal static string get_WRN_MutableStructureInUsing_Title();
    internal static string get_WRN_NameNotCLSCompliant1();
    internal static string get_WRN_NameNotCLSCompliant1_Title();
    internal static string get_WRN_NamespaceCaseMismatch3();
    internal static string get_WRN_NamespaceCaseMismatch3_Title();
    internal static string get_WRN_NoAnalyzerInAssembly();
    internal static string get_WRN_NoAnalyzerInAssembly_Title();
    internal static string get_WRN_NoConfigInResponseFile();
    internal static string get_WRN_NoConfigInResponseFile_Title();
    internal static string get_WRN_NonCLSMemberInCLSInterface1();
    internal static string get_WRN_NonCLSMemberInCLSInterface1_Title();
    internal static string get_WRN_NonCLSMustOverrideInCLSType1();
    internal static string get_WRN_NonCLSMustOverrideInCLSType1_Title();
    internal static string get_WRN_NoNonObsoleteConstructorOnBase3();
    internal static string get_WRN_NoNonObsoleteConstructorOnBase3_Title();
    internal static string get_WRN_NoNonObsoleteConstructorOnBase4();
    internal static string get_WRN_NoNonObsoleteConstructorOnBase4_Title();
    internal static string get_WRN_NotEqualToLiteralNothing();
    internal static string get_WRN_NotEqualToLiteralNothing_Title();
    internal static string get_WRN_ObjectAssumed1();
    internal static string get_WRN_ObjectAssumed1_Title();
    internal static string get_WRN_ObjectAssumedProperty1();
    internal static string get_WRN_ObjectAssumedProperty1_Title();
    internal static string get_WRN_ObjectAssumedVar1();
    internal static string get_WRN_ObjectAssumedVar1_Title();
    internal static string get_WRN_ObjectMath1();
    internal static string get_WRN_ObjectMath1_Title();
    internal static string get_WRN_ObjectMath1Not();
    internal static string get_WRN_ObjectMath1Not_Title();
    internal static string get_WRN_ObjectMath2();
    internal static string get_WRN_ObjectMath2_Title();
    internal static string get_WRN_ObjectMathSelectCase();
    internal static string get_WRN_ObjectMathSelectCase_Title();
    internal static string get_WRN_ObsoleteIdentityDirectCastForValueType();
    internal static string get_WRN_ObsoleteIdentityDirectCastForValueType_Title();
    internal static string get_WRN_OptionalValueNotCLSCompliant1();
    internal static string get_WRN_OptionalValueNotCLSCompliant1_Title();
    internal static string get_WRN_OverlappingCatch();
    internal static string get_WRN_OverlappingCatch_Title();
    internal static string get_WRN_OverrideType5();
    internal static string get_WRN_OverrideType5_Title();
    internal static string get_WRN_ParamNotCLSCompliant1();
    internal static string get_WRN_ParamNotCLSCompliant1_Title();
    internal static string get_WRN_PdbLocalNameTooLong();
    internal static string get_WRN_PdbLocalNameTooLong_Title();
    internal static string get_WRN_PdbUsingNameTooLong();
    internal static string get_WRN_PdbUsingNameTooLong_Title();
    internal static string get_WRN_PrefixAndXmlnsLocalName();
    internal static string get_WRN_PrefixAndXmlnsLocalName_Title();
    internal static string get_WRN_ProcTypeNotCLSCompliant1();
    internal static string get_WRN_ProcTypeNotCLSCompliant1_Title();
    internal static string get_WRN_QueryMissingAsClauseinVarDecl();
    internal static string get_WRN_QueryMissingAsClauseinVarDecl_Title();
    internal static string get_WRN_RecursiveAddHandlerCall();
    internal static string get_WRN_RecursiveAddHandlerCall_Title();
    internal static string get_WRN_RecursiveOperatorCall();
    internal static string get_WRN_RecursiveOperatorCall_Title();
    internal static string get_WRN_RecursivePropertyCall();
    internal static string get_WRN_RecursivePropertyCall_Title();
    internal static string get_WRN_RefCultureMismatch();
    internal static string get_WRN_RefCultureMismatch_Title();
    internal static string get_WRN_ReferencedAssemblyDoesNotHaveStrongName();
    internal static string get_WRN_ReferencedAssemblyDoesNotHaveStrongName_Title();
    internal static string get_WRN_RelDelegatePassedToRemoveHandler();
    internal static string get_WRN_RelDelegatePassedToRemoveHandler_Title();
    internal static string get_WRN_RequiredNonObsoleteNewCall3();
    internal static string get_WRN_RequiredNonObsoleteNewCall3_Title();
    internal static string get_WRN_RequiredNonObsoleteNewCall4();
    internal static string get_WRN_RequiredNonObsoleteNewCall4_Title();
    internal static string get_WRN_ReturnTypeAttributeOnWriteOnlyProperty();
    internal static string get_WRN_ReturnTypeAttributeOnWriteOnlyProperty_Title();
    internal static string get_WRN_RootNamespaceNotCLSCompliant1();
    internal static string get_WRN_RootNamespaceNotCLSCompliant1_Title();
    internal static string get_WRN_RootNamespaceNotCLSCompliant2();
    internal static string get_WRN_RootNamespaceNotCLSCompliant2_Title();
    internal static string get_WRN_SelectCaseInvalidRange();
    internal static string get_WRN_SelectCaseInvalidRange_Title();
    internal static string get_WRN_ShadowingGenericParamWithParam1();
    internal static string get_WRN_ShadowingGenericParamWithParam1_Title();
    internal static string get_WRN_SharedMemberThroughInstance();
    internal static string get_WRN_SharedMemberThroughInstance_Title();
    internal static string get_WRN_StaticLocalNoInference();
    internal static string get_WRN_StaticLocalNoInference_Title();
    internal static string get_WRN_SynthMemberShadowsMember5();
    internal static string get_WRN_SynthMemberShadowsMember5_Title();
    internal static string get_WRN_SynthMemberShadowsSynthMember7();
    internal static string get_WRN_SynthMemberShadowsSynthMember7_Title();
    internal static string get_WRN_TypeConflictButMerged6();
    internal static string get_WRN_TypeConflictButMerged6_Title();
    internal static string get_WRN_TypeInferenceAssumed3();
    internal static string get_WRN_TypeInferenceAssumed3_Title();
    internal static string get_WRN_TypeNotCLSCompliant1();
    internal static string get_WRN_TypeNotCLSCompliant1_Title();
    internal static string get_WRN_UnableToLoadAnalyzer();
    internal static string get_WRN_UnableToLoadAnalyzer_Title();
    internal static string get_WRN_UndefinedOrEmptyNamespaceOrClass1();
    internal static string get_WRN_UndefinedOrEmptyNamespaceOrClass1_Title();
    internal static string get_WRN_UndefinedOrEmptyProjectNamespaceOrClass1();
    internal static string get_WRN_UndefinedOrEmptyProjectNamespaceOrClass1_Title();
    internal static string get_WRN_UnimplementedCommandLineSwitch();
    internal static string get_WRN_UnimplementedCommandLineSwitch_Title();
    internal static string get_WRN_UnobservedAwaitableDelegate();
    internal static string get_WRN_UnobservedAwaitableDelegate_Title();
    internal static string get_WRN_UnobservedAwaitableExpression();
    internal static string get_WRN_UnobservedAwaitableExpression_Title();
    internal static string get_WRN_UnreachableCode();
    internal static string get_WRN_UnreachableCode_Title();
    internal static string get_WRN_UnusedLocal();
    internal static string get_WRN_UnusedLocal_Title();
    internal static string get_WRN_UnusedLocalConst();
    internal static string get_WRN_UnusedLocalConst_Title();
    internal static string get_WRN_UseOfObsoletePropertyAccessor2();
    internal static string get_WRN_UseOfObsoletePropertyAccessor2_Title();
    internal static string get_WRN_UseOfObsoletePropertyAccessor3();
    internal static string get_WRN_UseOfObsoletePropertyAccessor3_Title();
    internal static string get_WRN_UseOfObsoleteSymbol2();
    internal static string get_WRN_UseOfObsoleteSymbol2_Title();
    internal static string get_WRN_UseOfObsoleteSymbolNoMessage1();
    internal static string get_WRN_UseOfObsoleteSymbolNoMessage1_Title();
    internal static string get_WRN_UseSwitchInsteadOfAttribute();
    internal static string get_WRN_UseSwitchInsteadOfAttribute_Title();
    internal static string get_WRN_UseValueForXmlExpression3();
    internal static string get_WRN_UseValueForXmlExpression3_Title();
    internal static string get_WRN_VarianceConversionFailedIn6();
    internal static string get_WRN_VarianceConversionFailedIn6_Title();
    internal static string get_WRN_VarianceConversionFailedOut6();
    internal static string get_WRN_VarianceConversionFailedOut6_Title();
    internal static string get_WRN_VarianceConversionFailedTryIn4();
    internal static string get_WRN_VarianceConversionFailedTryIn4_Title();
    internal static string get_WRN_VarianceConversionFailedTryOut4();
    internal static string get_WRN_VarianceConversionFailedTryOut4_Title();
    internal static string get_WRN_VarianceDeclarationAmbiguous3();
    internal static string get_WRN_VarianceDeclarationAmbiguous3_Title();
    internal static string get_WRN_VarianceIEnumerableSuggestion3();
    internal static string get_WRN_VarianceIEnumerableSuggestion3_Title();
    internal static string get_WRN_XMLCannotWriteToXMLDocFile2();
    internal static string get_WRN_XMLCannotWriteToXMLDocFile2_Title();
    internal static string get_WRN_XMLDocBadFormedXML();
    internal static string get_WRN_XMLDocBadFormedXML_Title();
    internal static string get_WRN_XMLDocBadGenericParamTag2();
    internal static string get_WRN_XMLDocBadGenericParamTag2_Title();
    internal static string get_WRN_XMLDocBadParamTag2();
    internal static string get_WRN_XMLDocBadParamTag2_Title();
    internal static string get_WRN_XMLDocBadXMLLine();
    internal static string get_WRN_XMLDocBadXMLLine_Title();
    internal static string get_WRN_XMLDocCrefAttributeNotFound1();
    internal static string get_WRN_XMLDocCrefAttributeNotFound1_Title();
    internal static string get_WRN_XMLDocCrefToTypeParameter();
    internal static string get_WRN_XMLDocCrefToTypeParameter_Title();
    internal static string get_WRN_XMLDocDuplicateXMLNode1();
    internal static string get_WRN_XMLDocDuplicateXMLNode1_Title();
    internal static string get_WRN_XMLDocExceptionTagWithoutCRef();
    internal static string get_WRN_XMLDocExceptionTagWithoutCRef_Title();
    internal static string get_WRN_XMLDocGenericParamTagWithoutName();
    internal static string get_WRN_XMLDocGenericParamTagWithoutName_Title();
    internal static string get_WRN_XMLDocIllegalTagOnElement2();
    internal static string get_WRN_XMLDocIllegalTagOnElement2_Title();
    internal static string get_WRN_XMLDocInsideMethod();
    internal static string get_WRN_XMLDocInsideMethod_Title();
    internal static string get_WRN_XMLDocInvalidXMLFragment();
    internal static string get_WRN_XMLDocInvalidXMLFragment_Title();
    internal static string get_WRN_XMLDocMoreThanOneCommentBlock();
    internal static string get_WRN_XMLDocMoreThanOneCommentBlock_Title();
    internal static string get_WRN_XMLDocNotFirstOnLine();
    internal static string get_WRN_XMLDocNotFirstOnLine_Title();
    internal static string get_WRN_XMLDocOnAPartialType();
    internal static string get_WRN_XMLDocOnAPartialType_Title();
    internal static string get_WRN_XMLDocParamTagWithoutName();
    internal static string get_WRN_XMLDocParamTagWithoutName_Title();
    internal static string get_WRN_XMLDocParseError1();
    internal static string get_WRN_XMLDocParseError1_Title();
    internal static string get_WRN_XMLDocReturnsOnADeclareSub();
    internal static string get_WRN_XMLDocReturnsOnADeclareSub_Title();
    internal static string get_WRN_XMLDocReturnsOnWriteOnlyProperty();
    internal static string get_WRN_XMLDocReturnsOnWriteOnlyProperty_Title();
    internal static string get_WRN_XMLDocStartTagWithNoEndTag();
    internal static string get_WRN_XMLDocStartTagWithNoEndTag_Title();
    internal static string get_WRN_XMLDocWithoutLanguageElement();
    internal static string get_WRN_XMLDocWithoutLanguageElement_Title();
    internal static string get_WRN_XMLMissingFileOrPathAttribute1();
    internal static string get_WRN_XMLMissingFileOrPathAttribute1_Title();
    internal static string get_WrongNumberOfTypeArguments();
    internal static string get_WrongSemanticModelType();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.VBSemanticModel : SemanticModel {
    public VisualBasicCompilation Compilation { get; }
    internal VisualBasicSyntaxNode Root { get; }
    public SemanticModel ParentModel { get; }
    public SyntaxTree SyntaxTree { get; }
    public OptionStrict OptionStrict { get; }
    public bool OptionInfer { get; }
    public bool OptionExplicit { get; }
    public bool OptionCompareText { get; }
    public string Language { get; }
    protected SemanticModel ParentModelCore { get; }
    protected SyntaxTree SyntaxTreeCore { get; }
    protected Compilation CompilationCore { get; }
    public CollectionRangeVariableSymbolInfo GetCollectionRangeVariableSymbolInfo(CollectionRangeVariableSyntax variableSyntax, CancellationToken cancellationToken);
    internal abstract virtual CollectionRangeVariableSymbolInfo GetCollectionRangeVariableSymbolInfoWorker(CollectionRangeVariableSyntax node, CancellationToken cancellationToken);
    public AggregateClauseSymbolInfo GetAggregateClauseSymbolInfo(AggregateClauseSyntax aggregateSyntax, CancellationToken cancellationToken);
    internal abstract virtual AggregateClauseSymbolInfo GetAggregateClauseSymbolInfoWorker(AggregateClauseSyntax node, CancellationToken cancellationToken);
    public SymbolInfo GetSymbolInfo(QueryClauseSyntax clauseSyntax, CancellationToken cancellationToken);
    internal abstract virtual SymbolInfo GetQueryClauseSymbolInfo(QueryClauseSyntax node, CancellationToken cancellationToken);
    public SymbolInfo GetSymbolInfo(ExpressionRangeVariableSyntax variableSyntax, CancellationToken cancellationToken);
    internal abstract virtual SymbolInfo GetLetClauseSymbolInfo(ExpressionRangeVariableSyntax node, CancellationToken cancellationToken);
    public SymbolInfo GetSymbolInfo(FunctionAggregationSyntax functionSyntax, CancellationToken cancellationToken);
    public SymbolInfo GetSymbolInfo(OrderingSyntax orderingSyntax, CancellationToken cancellationToken);
    internal abstract virtual SymbolInfo GetOrderingSymbolInfo(OrderingSyntax node, CancellationToken cancellationToken);
    public abstract virtual VisualBasicCompilation get_Compilation();
    internal abstract virtual VisualBasicSyntaxNode get_Root();
    internal abstract virtual SymbolInfo GetExpressionSymbolInfo(ExpressionSyntax node, SymbolInfoOptions options, CancellationToken cancellationToken);
    internal abstract virtual SymbolInfo GetCollectionInitializerAddSymbolInfo(ObjectCreationExpressionSyntax collectionInitializer, ExpressionSyntax node, CancellationToken cancellationToken);
    internal abstract virtual SymbolInfo GetAttributeSymbolInfo(AttributeSyntax attribute, CancellationToken cancellationToken);
    internal abstract virtual VisualBasicTypeInfo GetExpressionTypeInfo(ExpressionSyntax node, CancellationToken cancellationToken);
    internal abstract virtual VisualBasicTypeInfo GetAttributeTypeInfo(AttributeSyntax attribute, CancellationToken cancellationToken);
    internal abstract virtual ConstantValue GetExpressionConstantValue(ExpressionSyntax node, CancellationToken cancellationToken);
    internal abstract virtual ImmutableArray`1<Symbol> GetExpressionMemberGroup(ExpressionSyntax node, CancellationToken cancellationToken);
    internal abstract virtual ImmutableArray`1<Symbol> GetAttributeMemberGroup(AttributeSyntax attribute, CancellationToken cancellationToken);
    internal abstract virtual SymbolInfo GetCrefReferenceSymbolInfo(CrefReferenceSyntax crefReference, SymbolInfoOptions options, CancellationToken cancellationToken);
    internal bool CanGetSemanticInfo(VisualBasicSyntaxNode node, bool allowNamedArgumentName);
    protected virtual IOperation GetOperationCore(SyntaxNode node, CancellationToken cancellationToken);
    internal virtual IOperation GetOperationWorker(VisualBasicSyntaxNode node, GetOperationOptions options, CancellationToken cancellationToken);
    public SymbolInfo GetSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken);
    public SymbolInfo GetCollectionInitializerSymbolInfo(ExpressionSyntax expression, CancellationToken cancellationToken);
    public SymbolInfo GetSymbolInfo(CrefReferenceSyntax crefReference, CancellationToken cancellationToken);
    public SymbolInfo GetSpeculativeSymbolInfo(int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption);
    public SymbolInfo GetSpeculativeSymbolInfo(int position, AttributeSyntax attribute);
    public SymbolInfo GetSymbolInfo(AttributeSyntax attribute, CancellationToken cancellationToken);
    internal SymbolInfo GetSymbolInfoForNode(SymbolInfoOptions options, BoundNodeSummary boundNodes, Binder binderOpt);
    public TypeInfo GetTypeInfo(ExpressionSyntax expression, CancellationToken cancellationToken);
    internal VisualBasicTypeInfo GetTypeInfoWorker(ExpressionSyntax expression, CancellationToken cancellationToken);
    public TypeInfo GetSpeculativeTypeInfo(int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption);
    internal VisualBasicTypeInfo GetSpeculativeTypeInfoWorker(int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption);
    public TypeInfo GetTypeInfo(AttributeSyntax attribute, CancellationToken cancellationToken);
    private VisualBasicTypeInfo GetTypeInfoWorker(AttributeSyntax attribute, CancellationToken cancellationToken);
    internal VisualBasicTypeInfo GetTypeInfoForNode(BoundNodeSummary boundNodes);
    public Conversion GetConversion(SyntaxNode node, CancellationToken cancellationToken);
    public Conversion GetSpeculativeConversion(int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption);
    public Optional`1<object> GetConstantValue(ExpressionSyntax expression, CancellationToken cancellationToken);
    public Optional`1<object> GetSpeculativeConstantValue(int position, ExpressionSyntax expression);
    internal ConstantValue GetConstantValueForNode(BoundNodeSummary boundNodes);
    public ImmutableArray`1<ISymbol> GetMemberGroup(ExpressionSyntax expression, CancellationToken cancellationToken);
    public ImmutableArray`1<ISymbol> GetSpeculativeMemberGroup(int position, ExpressionSyntax expression);
    public ImmutableArray`1<ISymbol> GetMemberGroup(AttributeSyntax attribute, CancellationToken cancellationToken);
    internal ImmutableArray`1<Symbol> GetMemberGroupForNode(BoundNodeSummary boundNodes, Binder binderOpt);
    public IAliasSymbol GetAliasInfo(IdentifierNameSyntax nameSyntax, CancellationToken cancellationToken);
    public IAliasSymbol GetSpeculativeAliasInfo(int position, IdentifierNameSyntax nameSyntax, SpeculativeBindingOption bindingOption);
    internal abstract virtual Binder GetEnclosingBinder(int position);
    internal bool IsInTree(SyntaxNode node);
    private static bool IsUnderNode(SyntaxNode node, SyntaxNode root);
    protected void CheckPosition(int position);
    internal void CheckSyntaxNode(VisualBasicSyntaxNode node);
    private void CheckModelAndSyntaxNodeToSpeculate(VisualBasicSyntaxNode node);
    internal VisualBasicSyntaxNode FindInitialNodeFromPosition(int position);
    internal static bool IsInCrefOrNameAttributeInterior(VisualBasicSyntaxNode node);
    internal SpeculativeBinder GetSpeculativeBinderForExpression(int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption);
    private BoundNode GetSpeculativelyBoundNode(Binder binder, ExpressionSyntax expression, SpeculativeBindingOption bindingOption, DiagnosticBag diagnostics);
    internal BoundNode GetSpeculativelyBoundNode(int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption, Binder& binder);
    private BoundNodeSummary GetSpeculativelyBoundNodeSummary(int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption, Binder& binder);
    private BoundNode MakeValueIfPossible(Binder binder, BoundNode node);
    private AttributeBinder GetSpeculativeAttributeBinder(int position, AttributeSyntax attribute);
    internal BoundAttribute GetSpeculativelyBoundAttribute(int position, AttributeSyntax attribute, Binder& binder);
    private BoundNodeSummary GetSpeculativelyBoundAttributeSummary(int position, AttributeSyntax attribute, Binder& binder);
    private void AddSymbolsFromDiagnosticInfo(ArrayBuilder`1<Symbol> symbolsBuilder, DiagnosticInfo diagnosticInfo);
    internal ImmutableArray`1<Symbol> RemoveErrorTypesAndDuplicates(ArrayBuilder`1<Symbol> symbolsBuilder, SymbolInfoOptions options);
    private TypeSymbol GetSemanticType(BoundNodeSummary boundNodes, TypeSymbol& convertedType, Conversion& conversion);
    private ImmutableArray`1<Symbol> GetSemanticSymbols(BoundNodeSummary boundNodes, Binder binderOpt, SymbolInfoOptions options, LookupResultKind& resultKind, ImmutableArray`1& memberGroup);
    private static ParameterSymbol GetMeParameter(TypeSymbol referenceType, TypeSymbol containingType, Symbol containingMember, LookupResultKind& resultKind);
    private void GetSemanticSymbolsForLateBoundInvocation(BoundLateInvocation lateInvocation, ArrayBuilder`1<Symbol> symbolsBuilder, ArrayBuilder`1<Symbol> memberGroupBuilder, LookupResultKind& resultKind);
    private void GetSemanticSymbolsForLateBoundMemberAccess(BoundNodeSummary boundNodes, ArrayBuilder`1<Symbol> symbolsBuilder, ArrayBuilder`1<Symbol> memberGroupBuilder, LookupResultKind& resultKind);
    private void GetSemanticSymbolsForMethodGroup(BoundNodeSummary boundNodes, ArrayBuilder`1<Symbol> symbolsBuilder, ArrayBuilder`1<Symbol> memberGroupBuilder, LookupResultKind& resultKind);
    private void GetSemanticSymbolsForPropertyGroup(BoundNodeSummary boundNodes, ArrayBuilder`1<Symbol> symbolsBuilder, ArrayBuilder`1<Symbol> memberGroupBuilder, LookupResultKind& resultKind);
    private static ImmutableArray`1<Symbol> UnwrapAliases(ImmutableArray`1<Symbol> symbols);
    private void AdjustSymbolsForObjectCreation(BoundNodeSummary boundNodes, Binder binderOpt, ImmutableArray`1& bindingSymbols, ArrayBuilder`1<Symbol> memberGroupBuilder, LookupResultKind& resultKind);
    private void AdjustSymbolsForObjectCreation(BoundNode lowestBoundNode, NamedTypeSymbol namedTypeSymbol, MethodSymbol constructor, Binder binderOpt, ImmutableArray`1& bindingSymbols, ArrayBuilder`1<Symbol> memberGroupBuilder, LookupResultKind& resultKind);
    internal SymbolInfo GetSymbolInfoForSymbol(Symbol symbol, SymbolInfoOptions options);
    internal VisualBasicTypeInfo GetTypeInfoForSymbol(Symbol symbol);
    internal virtual BoundNode Bind(Binder binder, VisualBasicSyntaxNode node, DiagnosticBag diagnostics);
    public ImmutableArray`1<ISymbol> LookupSymbols(int position, INamespaceOrTypeSymbol container, string name, bool includeReducedExtensionMethods);
    public ImmutableArray`1<ISymbol> LookupBaseMembers(int position, string name);
    public ImmutableArray`1<ISymbol> LookupStaticMembers(int position, INamespaceOrTypeSymbol container, string name);
    public ImmutableArray`1<ISymbol> LookupNamespacesAndTypes(int position, INamespaceOrTypeSymbol container, string name);
    public ImmutableArray`1<ISymbol> LookupLabels(int position, string name);
    private ImmutableArray`1<Symbol> LookupSymbolsInternal(int position, NamespaceOrTypeSymbol container, string name, LookupOptions options, bool useBaseReferenceAccessibility);
    private void AppendSymbolsWithName(ArrayBuilder`1<Symbol> results, string name, Binder binder, NamespaceOrTypeSymbol container, LookupOptions options, LookupSymbolsInfo info);
    private void LookupSymbols(Binder binder, NamespaceOrTypeSymbol container, string name, IArityEnumerable<Symbol> arities, LookupOptions options, ArrayBuilder`1<Symbol> results);
    private void LookupSymbols(Binder binder, NamespaceOrTypeSymbol container, string name, int arity, LookupOptions options, ArrayBuilder`1<Symbol> results);
    private void LookupInstanceConstructors(Binder binder, NamespaceOrTypeSymbol container, LookupOptions options, ArrayBuilder`1<Symbol> results);
    private void AddLookupSymbolsInfo(int position, LookupSymbolsInfo info, NamespaceOrTypeSymbol container, LookupOptions options);
    public bool IsAccessible(int position, ISymbol symbol);
    public virtual ControlFlowAnalysis AnalyzeControlFlow(StatementSyntax firstStatement, StatementSyntax lastStatement);
    public virtual ControlFlowAnalysis AnalyzeControlFlow(StatementSyntax statement);
    public virtual DataFlowAnalysis AnalyzeDataFlow(ExpressionSyntax expression);
    public virtual DataFlowAnalysis AnalyzeDataFlow(StatementSyntax firstStatement, StatementSyntax lastStatement);
    public virtual DataFlowAnalysis AnalyzeDataFlow(StatementSyntax statement);
    public bool TryGetSpeculativeSemanticModelForMethodBody(int position, MethodBlockBaseSyntax method, SemanticModel& speculativeModel);
    internal abstract virtual bool TryGetSpeculativeSemanticModelForMethodBodyCore(SyntaxTreeSemanticModel parentModel, int position, MethodBlockBaseSyntax method, SemanticModel& speculativeModel);
    public bool TryGetSpeculativeSemanticModel(int position, RangeArgumentSyntax rangeArgument, SemanticModel& speculativeModel);
    internal abstract virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, RangeArgumentSyntax rangeArgument, SemanticModel& speculativeModel);
    public bool TryGetSpeculativeSemanticModel(int position, ExecutableStatementSyntax statement, SemanticModel& speculativeModel);
    internal abstract virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, ExecutableStatementSyntax statement, SemanticModel& speculativeModel);
    public bool TryGetSpeculativeSemanticModel(int position, EqualsValueSyntax initializer, SemanticModel& speculativeModel);
    internal abstract virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, EqualsValueSyntax initializer, SemanticModel& speculativeModel);
    public bool TryGetSpeculativeSemanticModel(int position, AttributeSyntax attribute, SemanticModel& speculativeModel);
    public bool TryGetSpeculativeSemanticModel(int position, TypeSyntax type, SemanticModel& speculativeModel, SpeculativeBindingOption bindingOption);
    internal abstract virtual bool TryGetSpeculativeSemanticModelCore(SyntaxTreeSemanticModel parentModel, int position, TypeSyntax type, SpeculativeBindingOption bindingOption, SemanticModel& speculativeModel);
    public abstract virtual SemanticModel get_ParentModel();
    public abstract virtual Conversion ClassifyConversion(ExpressionSyntax expression, ITypeSymbol destination);
    public Conversion ClassifyConversion(int position, ExpressionSyntax expression, ITypeSymbol destination);
    public virtual ISymbol GetDeclaredSymbol(ModifiedIdentifierSyntax identifierSyntax, CancellationToken cancellationToken);
    public virtual IPropertySymbol GetDeclaredSymbol(FieldInitializerSyntax fieldInitializerSyntax, CancellationToken cancellationToken);
    public virtual INamedTypeSymbol GetDeclaredSymbol(AnonymousObjectCreationExpressionSyntax anonymousObjectCreationExpressionSyntax, CancellationToken cancellationToken);
    public virtual IRangeVariableSymbol GetDeclaredSymbol(ExpressionRangeVariableSyntax rangeVariableSyntax, CancellationToken cancellationToken);
    public virtual IRangeVariableSymbol GetDeclaredSymbol(CollectionRangeVariableSyntax rangeVariableSyntax, CancellationToken cancellationToken);
    public virtual IRangeVariableSymbol GetDeclaredSymbol(AggregationRangeVariableSyntax rangeVariableSyntax, CancellationToken cancellationToken);
    public virtual ILabelSymbol GetDeclaredSymbol(LabelStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual IFieldSymbol GetDeclaredSymbol(EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual INamedTypeSymbol GetDeclaredSymbol(TypeStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public INamedTypeSymbol GetDeclaredSymbol(TypeBlockSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual INamedTypeSymbol GetDeclaredSymbol(EnumStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public INamedTypeSymbol GetDeclaredSymbol(EnumBlockSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual INamespaceSymbol GetDeclaredSymbol(NamespaceStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public INamespaceSymbol GetDeclaredSymbol(NamespaceBlockSyntax declarationSyntax, CancellationToken cancellationToken);
    internal abstract virtual ISymbol GetDeclaredSymbol(MethodBaseSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual IParameterSymbol GetDeclaredSymbol(ParameterSyntax parameter, CancellationToken cancellationToken);
    public abstract virtual ITypeParameterSymbol GetDeclaredSymbol(TypeParameterSyntax typeParameter, CancellationToken cancellationToken);
    public NamedTypeSymbol GetDeclaredSymbol(DelegateStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public IMethodSymbol GetDeclaredSymbol(SubNewStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public IMethodSymbol GetDeclaredSymbol(MethodStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public IMethodSymbol GetDeclaredSymbol(DeclareStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public IMethodSymbol GetDeclaredSymbol(OperatorStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public IMethodSymbol GetDeclaredSymbol(MethodBlockBaseSyntax declarationSyntax, CancellationToken cancellationToken);
    public IPropertySymbol GetDeclaredSymbol(PropertyStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public IEventSymbol GetDeclaredSymbol(EventStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public IPropertySymbol GetDeclaredSymbol(PropertyBlockSyntax declarationSyntax, CancellationToken cancellationToken);
    public IEventSymbol GetDeclaredSymbol(EventBlockSyntax declarationSyntax, CancellationToken cancellationToken);
    public ILocalSymbol GetDeclaredSymbol(CatchStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public IMethodSymbol GetDeclaredSymbol(AccessorStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    public abstract virtual IAliasSymbol GetDeclaredSymbol(SimpleImportsClauseSyntax declarationSyntax, CancellationToken cancellationToken);
    internal abstract virtual ImmutableArray`1<ISymbol> GetDeclaredSymbols(FieldDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    internal abstract virtual BoundNodeSummary GetInvokeSummaryForRaiseEvent(RaiseEventStatementSyntax node);
    private SymbolInfo GetNamedArgumentSymbolInfo(IdentifierNameSyntax identifierNameSyntax, CancellationToken cancellationToken);
    private SymbolInfo GetNamedArgumentSymbolInfoInRaiseEvent(string argumentName, RaiseEventStatementSyntax containingRaiseEvent);
    private SymbolInfo FindNameParameterInfo(ImmutableArray`1<Symbol> invocationInfosymbols, string arGumentName, CandidateReason reason);
    private ParameterSymbol FindNamedParameter(Symbol symbol, string argumentName);
    public abstract virtual SyntaxTree get_SyntaxTree();
    public ForEachStatementInfo GetForEachStatementInfo(ForEachStatementSyntax node);
    public ForEachStatementInfo GetForEachStatementInfo(ForEachBlockSyntax node);
    internal abstract virtual ForEachStatementInfo GetForEachStatementInfoWorker(ForEachBlockSyntax node);
    public AwaitExpressionInfo GetAwaitExpressionInfo(AwaitExpressionSyntax awaitExpression, CancellationToken cancellationToken);
    internal abstract virtual AwaitExpressionInfo GetAwaitExpressionInfoWorker(AwaitExpressionSyntax awaitExpression, CancellationToken cancellationToken);
    public VisualBasicPreprocessingSymbolInfo GetPreprocessingSymbolInfo(IdentifierNameSyntax node);
    internal void ValidateSymbolInfoOptions(SymbolInfoOptions options);
    public ISymbol GetEnclosingSymbol(int position, CancellationToken cancellationToken);
    public OptionStrict get_OptionStrict();
    public bool get_OptionInfer();
    public bool get_OptionExplicit();
    public bool get_OptionCompareText();
    internal static Binder StripSemanticModelBinder(Binder binder);
    public sealed virtual string get_Language();
    protected sealed virtual SemanticModel get_ParentModelCore();
    protected sealed virtual SyntaxTree get_SyntaxTreeCore();
    protected sealed virtual Compilation get_CompilationCore();
    private SymbolInfo GetSymbolInfoForNode(SyntaxNode node, CancellationToken cancellationToken);
    private VisualBasicTypeInfo GetTypeInfoForNode(SyntaxNode node, CancellationToken cancellationToken);
    private ImmutableArray`1<ISymbol> GetMemberGroupForNode(SyntaxNode node, CancellationToken cancellationToken);
    protected sealed virtual TypeInfo GetSpeculativeTypeInfoCore(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    protected sealed virtual SymbolInfo GetSpeculativeSymbolInfoCore(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    protected sealed virtual IAliasSymbol GetSpeculativeAliasInfoCore(int position, SyntaxNode nameSyntax, SpeculativeBindingOption bindingOption);
    protected sealed virtual SymbolInfo GetSymbolInfoCore(SyntaxNode node, CancellationToken cancellationToken);
    protected sealed virtual TypeInfo GetTypeInfoCore(SyntaxNode node, CancellationToken cancellationToken);
    protected sealed virtual IAliasSymbol GetAliasInfoCore(SyntaxNode node, CancellationToken cancellationToken);
    protected sealed virtual PreprocessingSymbolInfo GetPreprocessingSymbolInfoCore(SyntaxNode node);
    protected sealed virtual ImmutableArray`1<ISymbol> GetMemberGroupCore(SyntaxNode node, CancellationToken cancellationToken);
    protected sealed virtual ImmutableArray`1<ISymbol> LookupSymbolsCore(int position, INamespaceOrTypeSymbol container, string name, bool includeReducedExtensionMethods);
    protected sealed virtual ImmutableArray`1<ISymbol> LookupBaseMembersCore(int position, string name);
    protected sealed virtual ImmutableArray`1<ISymbol> LookupStaticMembersCore(int position, INamespaceOrTypeSymbol container, string name);
    protected sealed virtual ImmutableArray`1<ISymbol> LookupNamespacesAndTypesCore(int position, INamespaceOrTypeSymbol container, string name);
    protected sealed virtual ImmutableArray`1<ISymbol> LookupLabelsCore(int position, string name);
    private static NamespaceOrTypeSymbol ToLanguageSpecific(INamespaceOrTypeSymbol container);
    protected sealed virtual ISymbol GetDeclaredSymbolCore(SyntaxNode declaration, CancellationToken cancellationToken);
    protected sealed virtual ImmutableArray`1<ISymbol> GetDeclaredSymbolsCore(SyntaxNode declaration, CancellationToken cancellationToken);
    protected sealed virtual DataFlowAnalysis AnalyzeDataFlowCore(SyntaxNode firstStatement, SyntaxNode lastStatement);
    protected sealed virtual DataFlowAnalysis AnalyzeDataFlowCore(SyntaxNode statementOrExpression);
    protected sealed virtual ControlFlowAnalysis AnalyzeControlFlowCore(SyntaxNode firstStatement, SyntaxNode lastStatement);
    protected sealed virtual ControlFlowAnalysis AnalyzeControlFlowCore(SyntaxNode statement);
    private static T SafeCastArgument(SyntaxNode node, string argName);
    protected sealed virtual Optional`1<object> GetConstantValueCore(SyntaxNode node, CancellationToken cancellationToken);
    protected sealed virtual ISymbol GetEnclosingSymbolCore(int position, CancellationToken cancellationToken);
    protected sealed virtual bool IsAccessibleCore(int position, ISymbol symbol);
    protected sealed virtual bool IsEventUsableAsFieldCore(int position, IEventSymbol symbol);
    internal virtual void ComputeDeclarationsInSpan(TextSpan span, bool getSymbol, List`1<DeclarationInfo> builder, CancellationToken cancellationToken);
    internal virtual void ComputeDeclarationsInNode(SyntaxNode node, bool getSymbol, List`1<DeclarationInfo> builder, CancellationToken cancellationToken, Nullable`1<int> levelsToCompute);
    protected virtual SyntaxNode GetTopmostNodeForDiagnosticAnalysis(ISymbol symbol, SyntaxNode declaringSyntax);
    internal string GetMessage(int position);
    internal string GetMessage(VisualBasicSyntaxNode node);
    internal string GetMessage(VisualBasicSyntaxNode node, int position);
    internal string GetMessage(StatementSyntax firstStatement, StatementSyntax lastStatement);
    internal string GetMessage(ExpressionSyntax expression, TypeSymbol type);
    internal string GetMessage(ExpressionSyntax expression, TypeSymbol type, int position);
    internal string GetMessage(ExpressionSyntax expression, SpeculativeBindingOption option, int position);
    internal string GetMessage(string name, LookupOptions option, int position);
    internal string GetMessage(Symbol symbol, int position);
    internal string GetMessage(CompilationStage stage);
}
public class Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineArguments : CommandLineArguments {
    [CompilerGeneratedAttribute]
private VisualBasicCompilationOptions _CompilationOptions;
    [CompilerGeneratedAttribute]
private VisualBasicParseOptions _ParseOptions;
    internal OutputLevel OutputLevel;
    [CompilerGeneratedAttribute]
private Nullable`1<CommandLineReference> _DefaultCoreLibraryReference;
    public VisualBasicCompilationOptions CompilationOptions { get; public set; }
    public VisualBasicParseOptions ParseOptions { get; public set; }
    protected ParseOptions ParseOptionsCore { get; }
    protected CompilationOptions CompilationOptionsCore { get; }
    internal Nullable`1<CommandLineReference> DefaultCoreLibraryReference { get; internal set; }
    [CompilerGeneratedAttribute]
public VisualBasicCompilationOptions get_CompilationOptions();
    [CompilerGeneratedAttribute]
public void set_CompilationOptions(VisualBasicCompilationOptions AutoPropertyValue);
    [CompilerGeneratedAttribute]
public VisualBasicParseOptions get_ParseOptions();
    [CompilerGeneratedAttribute]
public void set_ParseOptions(VisualBasicParseOptions AutoPropertyValue);
    protected virtual ParseOptions get_ParseOptionsCore();
    protected virtual CompilationOptions get_CompilationOptionsCore();
    [CompilerGeneratedAttribute]
internal Nullable`1<CommandLineReference> get_DefaultCoreLibraryReference();
    [CompilerGeneratedAttribute]
internal void set_DefaultCoreLibraryReference(Nullable`1<CommandLineReference> AutoPropertyValue);
    internal virtual bool ResolveMetadataReferences(MetadataReferenceResolver metadataResolver, List`1<DiagnosticInfo> diagnostics, CommonMessageProvider messageProvider, List`1<MetadataReference> resolved);
}
public class Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParser : CommandLineParser {
    [CompilerGeneratedAttribute]
private static VisualBasicCommandLineParser _Default;
    [CompilerGeneratedAttribute]
private static VisualBasicCommandLineParser _ScriptRunner;
    private static string s_win32Manifest;
    private static string s_win32Icon;
    private static string s_win32Res;
    public static VisualBasicCommandLineParser Default { get; }
    internal static VisualBasicCommandLineParser ScriptRunner { get; }
    protected string RegularFileExtension { get; }
    protected string ScriptFileExtension { get; }
    private static VisualBasicCommandLineParser();
    internal VisualBasicCommandLineParser(bool isScriptRunner);
    [CompilerGeneratedAttribute]
public static VisualBasicCommandLineParser get_Default();
    [CompilerGeneratedAttribute]
internal static VisualBasicCommandLineParser get_ScriptRunner();
    protected virtual string get_RegularFileExtension();
    protected virtual string get_ScriptFileExtension();
    internal sealed virtual CommandLineArguments CommonParse(IEnumerable`1<string> args, string baseDirectory, string sdkDirectoryOpt, string additionalReferenceDirectories);
    public VisualBasicCommandLineArguments Parse(IEnumerable`1<string> args, string baseDirectory, string sdkDirectory, string additionalReferenceDirectories);
    private Nullable`1<CommandLineReference> LoadCoreLibraryReference(List`1<string> sdkPaths, string baseDirectory);
    private static string FindFileInSdkPath(List`1<string> sdkPaths, string fileName, string baseDirectory);
    private static string GetWin32Setting(string arg, string value, List`1<Diagnostic> diagnostics);
    private static ImmutableArray`1<string> BuildSearchPaths(string baseDirectory, List`1<string> sdkPaths, List`1<string> responsePaths, List`1<string> libPaths);
    private static void AddNormalizedPaths(ArrayBuilder`1<string> builder, List`1<string> paths, string baseDirectory);
    private static void ValidateWin32Settings(bool noWin32Manifest, string win32ResSetting, string win32IconSetting, string win32ManifestSetting, OutputKind outputKind, List`1<Diagnostic> diagnostics);
    private static OutputKind ParseTarget(string optionName, string value, IList`1<Diagnostic> diagnostics);
    internal static IEnumerable`1<CommandLineReference> ParseAssemblyReferences(string name, string value, IList`1<Diagnostic> diagnostics, bool embedInteropTypes);
    private IEnumerable`1<CommandLineAnalyzerReference> ParseAnalyzers(string name, string value, IList`1<Diagnostic> diagnostics);
    internal static ResourceDescription ParseResourceDescription(string name, string resourceDescriptor, string baseDirectory, IList`1<Diagnostic> diagnostics, bool embedded);
    private static void AddInvalidSwitchValueDiagnostic(IList`1<Diagnostic> diagnostics, string name, string nullStringText);
    private static void ParseGlobalImports(string value, List`1<GlobalImport> globalImports, List`1<Diagnostic> errors);
    private static ImmutableDictionary`2<string, CConst> PublicSymbolsToInternalDefines(IEnumerable`1<KeyValuePair`2<string, object>> symbols, string parameterName);
    private static IReadOnlyDictionary`2<string, object> InternalDefinesToPublicSymbols(ImmutableDictionary`2<string, CConst> defines);
    public static IReadOnlyDictionary`2<string, object> ParseConditionalCompilationSymbols(string symbolList, IEnumerable`1& diagnostics, IEnumerable`1<KeyValuePair`2<string, object>> symbols);
    private static ExpressionSyntax ParseConditionalCompilationExpression(string symbolList, int offset);
    private static bool IsSeparatorOrEndOfFile(SyntaxToken token);
    private static void GetErrorStringForRemainderOfConditionalCompilation(IEnumerator`1<SyntaxToken> tokens, StringBuilder remainderErrorLine, bool includeCurrentToken, SyntaxKind stopTokenKind);
    private static Platform ParsePlatform(string name, string value, List`1<Diagnostic> errors);
    private static int ParseFileAlignment(string name, string value, List`1<Diagnostic> errors);
    private static ulong ParseBaseAddress(string name, string value, List`1<Diagnostic> errors);
    private static IEnumerable`1<string> ParseWarnings(string value);
    private static void AddWarnings(IDictionary`2<string, ReportDiagnostic> d, ReportDiagnostic kind, IEnumerable`1<string> items);
    private static void UnimplementedSwitch(IList`1<Diagnostic> diagnostics, string switchName);
    internal virtual void GenerateErrorForNoFilesFoundInRecurse(string path, IList`1<Diagnostic> errors);
    private static void AddDiagnostic(IList`1<Diagnostic> diagnostics, ERRID errorCode, Object[] arguments);
    private void GetCompilationAndModuleNames(List`1<Diagnostic> diagnostics, OutputKind kind, List`1<CommandLineSourceFile> sourceFiles, string moduleAssemblyName, String& outputFileName, String& moduleName, String& compilationName);
}
public class Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation : Compilation {
    private static ConcurrentLruCache`2<VisualBasicParseOptions, SyntaxTree> s_myTemplateCache;
    private SourceAssemblySymbol _lazyAssemblySymbol;
    private ReferenceManager _referenceManager;
    private VisualBasicCompilationOptions _options;
    private NamespaceSymbol _lazyGlobalNamespace;
    private ImmutableArray`1<SyntaxTree> _syntaxTrees;
    private ImmutableDictionary`2<SyntaxTree, int> _syntaxTreeOrdinalMap;
    private ImmutableArray`1<SyntaxTree> _lazyAllSyntaxTrees;
    private ImmutableDictionary`2<SyntaxTree, DeclarationTableEntry> _rootNamespaces;
    private ConcurrentQueue`1<ImportInfo> _lazyImportInfos;
    private ImmutableArray`1<Diagnostic> _lazyClsComplianceDiagnostics;
    private ImmutableArray`1<EmbeddedTreeAndDeclaration> _embeddedTrees;
    private DeclarationTable _declarationTable;
    private AnonymousTypeManager _anonymousTypeManager;
    private EmbeddedSymbolManager _lazyEmbeddedSymbolManager;
    private SyntaxTree _lazyMyTemplate;
    private Lazy`1<ImplicitNamedTypeSymbol> _scriptClass;
    private EntryPoint _lazyEntryPoint;
    private HashSet`1<SyntaxTree> _lazyCompilationUnitCompletedTrees;
    private LanguageVersion _languageVersion;
    [CompilerGeneratedAttribute]
private VisualBasicScriptCompilationInfo _ScriptCompilationInfo;
    private WellKnownMembersSignatureComparer _wellKnownMemberSignatureComparer;
    private NamedTypeSymbol[] _lazyWellKnownTypes;
    private Symbol[] _lazyWellKnownTypeMembers;
    private Symbol _lazyExtensionAttributeConstructor;
    private object _lazyExtensionAttributeConstructorErrorInfo;
    public string Language { get; }
    public bool IsCaseSensitive { get; }
    internal DeclarationTable Declarations { get; }
    internal MergedNamespaceDeclaration MergedRootDeclaration { get; }
    public VisualBasicCompilationOptions Options { get; }
    public LanguageVersion LanguageVersion { get; }
    internal AnonymousTypeManager AnonymousTypeManager { get; }
    internal CommonAnonymousTypeManager CommonAnonymousTypeManager { get; }
    internal SyntaxTree MyTemplate { get; internal set; }
    internal EmbeddedSymbolManager EmbeddedSymbolManager { get; }
    internal VisualBasicScriptCompilationInfo ScriptCompilationInfo { get; }
    internal ScriptCompilationInfo CommonScriptCompilationInfo { get; }
    internal VisualBasicCompilation PreviousSubmission { get; }
    public ImmutableArray`1<SyntaxTree> SyntaxTrees { get; }
    internal ImmutableArray`1<SyntaxTree> AllSyntaxTrees { get; }
    public ImmutableArray`1<MetadataReference> DirectiveReferences { get; }
    internal IDictionary`2<ValueTuple`2<string, string>, MetadataReference> ReferenceDirectiveMap { get; }
    public IEnumerable`1<AssemblyIdentity> ReferencedAssemblyNames { get; }
    internal IEnumerable`1<ReferenceDirective> ReferenceDirectives { get; }
    internal bool EnableEnumArrayBlockInitialization { get; }
    internal SourceAssemblySymbol SourceAssembly { get; }
    internal AssemblySymbol Assembly { get; }
    internal ModuleSymbol SourceModule { get; }
    internal NamespaceSymbol GlobalNamespace { get; }
    internal NamespaceSymbol RootNamespace { get; }
    internal ImmutableArray`1<NamespaceOrTypeSymbol> MemberImports { get; }
    internal ImmutableArray`1<AliasSymbol> AliasImports { get; }
    internal bool DeclaresTheObjectClass { get; }
    internal NamedTypeSymbol ScriptClass { get; }
    internal ImplicitNamedTypeSymbol SourceScriptClass { get; }
    internal NamedTypeSymbol ObjectType { get; }
    internal bool FeatureStrictEnabled { get; }
    internal CommonMessageProvider MessageProvider { get; }
    internal byte LinkerMajorVersion { get; }
    internal bool IsDelaySigned { get; }
    internal StrongNameKeys StrongNameKeys { get; }
    protected IAssemblySymbol CommonAssembly { get; }
    protected INamespaceSymbol CommonGlobalNamespace { get; }
    protected CompilationOptions CommonOptions { get; }
    protected IEnumerable`1<SyntaxTree> CommonSyntaxTrees { get; }
    protected IModuleSymbol CommonSourceModule { get; }
    protected INamedTypeSymbol CommonScriptClass { get; }
    protected ITypeSymbol CommonDynamicType { get; }
    protected INamedTypeSymbol CommonObjectType { get; }
    private static VisualBasicCompilation();
    private VisualBasicCompilation(string assemblyName, VisualBasicCompilationOptions options, ImmutableArray`1<MetadataReference> references, ImmutableArray`1<SyntaxTree> syntaxTrees, ImmutableDictionary`2<SyntaxTree, int> syntaxTreeOrdinalMap, ImmutableDictionary`2<SyntaxTree, DeclarationTableEntry> rootNamespaces, ImmutableArray`1<EmbeddedTreeAndDeclaration> embeddedTrees, DeclarationTable declarationTable, VisualBasicCompilation previousSubmission, Type submissionReturnType, Type hostObjectType, bool isSubmission, ReferenceManager referenceManager, bool reuseReferenceManager, AsyncQueue`1<CompilationEvent> eventQueue);
    public virtual string get_Language();
    public virtual bool get_IsCaseSensitive();
    internal DeclarationTable get_Declarations();
    internal MergedNamespaceDeclaration get_MergedRootDeclaration();
    public VisualBasicCompilationOptions get_Options();
    public LanguageVersion get_LanguageVersion();
    internal AnonymousTypeManager get_AnonymousTypeManager();
    internal virtual CommonAnonymousTypeManager get_CommonAnonymousTypeManager();
    internal SyntaxTree get_MyTemplate();
    internal void set_MyTemplate(SyntaxTree value);
    internal EmbeddedSymbolManager get_EmbeddedSymbolManager();
    public static VisualBasicCompilation Create(string assemblyName, IEnumerable`1<SyntaxTree> syntaxTrees, IEnumerable`1<MetadataReference> references, VisualBasicCompilationOptions options);
    internal static VisualBasicCompilation CreateScriptCompilation(string assemblyName, SyntaxTree syntaxTree, IEnumerable`1<MetadataReference> references, VisualBasicCompilationOptions options, VisualBasicCompilation previousScriptCompilation, Type returnType, Type globalsType);
    private static VisualBasicCompilation Create(string assemblyName, VisualBasicCompilationOptions options, IEnumerable`1<SyntaxTree> syntaxTrees, IEnumerable`1<MetadataReference> references, VisualBasicCompilation previousSubmission, Type returnType, Type hostObjectType, bool isSubmission);
    internal virtual void ValidateDebugEntryPoint(IMethodSymbol debugEntryPoint, DiagnosticBag diagnostics);
    private LanguageVersion CommonLanguageVersion(ImmutableArray`1<SyntaxTree> syntaxTrees);
    public VisualBasicCompilation Clone();
    private VisualBasicCompilation UpdateSyntaxTrees(ImmutableArray`1<SyntaxTree> syntaxTrees, ImmutableDictionary`2<SyntaxTree, int> syntaxTreeOrdinalMap, ImmutableDictionary`2<SyntaxTree, DeclarationTableEntry> rootNamespaces, DeclarationTable declarationTable, bool referenceDirectivesChanged);
    public VisualBasicCompilation WithAssemblyName(string assemblyName);
    public VisualBasicCompilation WithReferences(MetadataReference[] newReferences);
    public VisualBasicCompilation WithReferences(IEnumerable`1<MetadataReference> newReferences);
    public VisualBasicCompilation WithOptions(VisualBasicCompilationOptions newOptions);
    internal VisualBasicCompilation WithScriptCompilationInfo(VisualBasicScriptCompilationInfo info);
    internal virtual Compilation WithEventQueue(AsyncQueue`1<CompilationEvent> eventQueue);
    [CompilerGeneratedAttribute]
internal VisualBasicScriptCompilationInfo get_ScriptCompilationInfo();
    internal virtual ScriptCompilationInfo get_CommonScriptCompilationInfo();
    internal VisualBasicCompilation get_PreviousSubmission();
    internal virtual bool HasSubmissionResult();
    internal SynthesizedInteractiveInitializerMethod GetSubmissionInitializer();
    public ImmutableArray`1<SyntaxTree> get_SyntaxTrees();
    internal ImmutableArray`1<SyntaxTree> get_AllSyntaxTrees();
    public bool ContainsSyntaxTree(SyntaxTree syntaxTree);
    public VisualBasicCompilation AddSyntaxTrees(SyntaxTree[] trees);
    public VisualBasicCompilation AddSyntaxTrees(IEnumerable`1<SyntaxTree> trees);
    private static void AddSyntaxTreeToDeclarationMapAndTable(SyntaxTree tree, VisualBasicCompilationOptions compilationOptions, bool isSubmission, ImmutableDictionary`2& declMap, DeclarationTable& declTable, Boolean& referenceDirectivesChanged);
    private static RootSingleNamespaceDeclaration ForTree(SyntaxTree tree, VisualBasicCompilationOptions options, bool isSubmission);
    public VisualBasicCompilation RemoveSyntaxTrees(SyntaxTree[] trees);
    public VisualBasicCompilation RemoveSyntaxTrees(IEnumerable`1<SyntaxTree> trees);
    private static void RemoveSyntaxTreeFromDeclarationMapAndTable(SyntaxTree tree, ImmutableDictionary`2& declMap, DeclarationTable& declTable, Boolean& referenceDirectivesChanged);
    public VisualBasicCompilation RemoveAllSyntaxTrees();
    public VisualBasicCompilation ReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree);
    private static ImmutableArray`1<EmbeddedTreeAndDeclaration> CreateEmbeddedTrees(Lazy`1<VisualBasicCompilation> compReference);
    private static DeclarationTable AddEmbeddedTrees(DeclarationTable declTable, ImmutableArray`1<EmbeddedTreeAndDeclaration> embeddedTrees);
    private static DeclarationTable RemoveEmbeddedTrees(DeclarationTable declTable, ImmutableArray`1<EmbeddedTreeAndDeclaration> embeddedTrees);
    private bool IncludeInternalXmlHelper();
    private bool InternalXmlHelperDependencyIsSatisfied(WellKnownType type);
    internal virtual int CompareSourceLocations(Location first, Location second);
    internal virtual int GetSyntaxTreeOrdinal(SyntaxTree tree);
    internal virtual CommonReferenceManager CommonGetBoundReferenceManager();
    internal ReferenceManager GetBoundReferenceManager();
    internal bool ReferenceManagerEquals(VisualBasicCompilation other);
    public virtual ImmutableArray`1<MetadataReference> get_DirectiveReferences();
    internal virtual IDictionary`2<ValueTuple`2<string, string>, MetadataReference> get_ReferenceDirectiveMap();
    internal Symbol GetAssemblyOrModuleSymbol(MetadataReference reference);
    internal MetadataReference GetMetadataReference(AssemblySymbol assemblySymbol);
    public virtual IEnumerable`1<AssemblyIdentity> get_ReferencedAssemblyNames();
    internal virtual IEnumerable`1<ReferenceDirective> get_ReferenceDirectives();
    public virtual CompilationReference ToMetadataReference(ImmutableArray`1<string> aliases, bool embedInteropTypes);
    public VisualBasicCompilation AddReferences(MetadataReference[] references);
    public VisualBasicCompilation AddReferences(IEnumerable`1<MetadataReference> references);
    public VisualBasicCompilation RemoveReferences(MetadataReference[] references);
    public VisualBasicCompilation RemoveReferences(IEnumerable`1<MetadataReference> references);
    public VisualBasicCompilation RemoveAllReferences();
    public VisualBasicCompilation ReplaceReference(MetadataReference oldReference, MetadataReference newReference);
    internal bool get_EnableEnumArrayBlockInitialization();
    internal SourceAssemblySymbol get_SourceAssembly();
    internal AssemblySymbol get_Assembly();
    internal ModuleSymbol get_SourceModule();
    internal NamespaceSymbol get_GlobalNamespace();
    internal NamespaceSymbol get_RootNamespace();
    internal NamespaceSymbol GetCompilationNamespace(INamespaceSymbol namespaceSymbol);
    internal MethodSymbol GetEntryPoint(CancellationToken cancellationToken);
    internal EntryPoint GetEntryPointAndDiagnostics(CancellationToken cancellationToken);
    private MethodSymbol FindEntryPoint(CancellationToken cancellationToken, ImmutableArray`1& sealedDiagnostics);
    internal ImmutableArray`1<NamespaceOrTypeSymbol> get_MemberImports();
    internal ImmutableArray`1<AliasSymbol> get_AliasImports();
    internal void ReportUnusedImports(SyntaxTree filterTree, DiagnosticBag diagnostics, CancellationToken cancellationToken);
    private void CompleteTree(SyntaxTree tree);
    internal bool ShouldAddEvent(Symbol symbol);
    internal void SymbolDeclaredEvent(Symbol symbol);
    internal void RecordImports(ImportsStatementSyntax syntax);
    internal bool get_DeclaresTheObjectClass();
    internal bool MightContainNoPiaLocalTypes();
    public Conversion ClassifyConversion(ITypeSymbol source, ITypeSymbol destination);
    internal NamedTypeSymbol get_ScriptClass();
    internal ImplicitNamedTypeSymbol get_SourceScriptClass();
    private ImplicitNamedTypeSymbol BindScriptClass();
    internal NamedTypeSymbol GetSpecialType(SpecialType typeId);
    internal Symbol GetSpecialTypeMember(SpecialMember memberId);
    internal TypeSymbol GetTypeByReflectionType(Type type, DiagnosticBag diagnostics);
    internal NamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName);
    internal NamedTypeSymbol get_ObjectType();
    internal ArrayTypeSymbol CreateArrayTypeSymbol(TypeSymbol elementType, int rank);
    public SemanticModel GetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility);
    internal bool get_FeatureStrictEnabled();
    internal virtual CommonMessageProvider get_MessageProvider();
    public virtual ImmutableArray`1<Diagnostic> GetDiagnostics(CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetParseDiagnostics(CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetDeclarationDiagnostics(CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Diagnostic> GetMethodBodyDiagnostics(CancellationToken cancellationToken);
    internal ImmutableArray`1<Diagnostic> GetDiagnostics(CompilationStage stage, bool includeEarlierStages, CancellationToken cancellationToken);
    private ImmutableArray`1<Diagnostic> GetClsComplianceDiagnostics(CancellationToken cancellationToken, SyntaxTree filterTree, Nullable`1<TextSpan> filterSpanWithinTree);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation/VB$StateMachine_163_FilterDiagnosticsByLocation")]
private static IEnumerable`1<Diagnostic> FilterDiagnosticsByLocation(IEnumerable`1<Diagnostic> diagnostics, SyntaxTree tree, Nullable`1<TextSpan> filterSpanWithinTree);
    internal ImmutableArray`1<Diagnostic> GetDiagnosticsForSyntaxTree(CompilationStage stage, SyntaxTree tree, Nullable`1<TextSpan> filterSpanWithinTree, bool includeEarlierStages, CancellationToken cancellationToken);
    private void GetDiagnosticsForAllMethodBodies(bool hasDeclarationErrors, DiagnosticBag diagnostics, CompilationStage stage, CancellationToken cancellationToken);
    private void GetDiagnosticsForMethodBodiesInTree(SyntaxTree tree, Nullable`1<TextSpan> filterSpanWithinTree, bool hasDeclarationErrors, DiagnosticBag diagnostics, CompilationStage stage, CancellationToken cancellationToken);
    internal virtual bool FilterAndAppendAndFreeDiagnostics(DiagnosticBag accumulator, DiagnosticBag& incoming);
    internal bool FilterAndAppendDiagnostics(DiagnosticBag accumulator, IEnumerable`1& incoming);
    internal virtual AnalyzerDriver AnalyzerForLanguage(ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerManager analyzerManager);
    protected virtual void AppendDefaultVersionResource(Stream resourceStream);
    internal virtual byte get_LinkerMajorVersion();
    internal virtual bool get_IsDelaySigned();
    internal virtual StrongNameKeys get_StrongNameKeys();
    internal virtual CommonPEModuleBuilder CreateModuleBuilder(EmitOptions emitOptions, IMethodSymbol debugEntryPoint, IEnumerable`1<ResourceDescription> manifestResources, CompilationTestData testData, DiagnosticBag diagnostics, CancellationToken cancellationToken);
    internal CommonPEModuleBuilder CreateModuleBuilder(EmitOptions emitOptions, IMethodSymbol debugEntryPoint, IEnumerable`1<ResourceDescription> manifestResources, CompilationTestData testData, DiagnosticBag diagnostics, ImmutableArray`1<NamedTypeSymbol> additionalTypes, CancellationToken cancellationToken);
    internal virtual bool CompileImpl(CommonPEModuleBuilder moduleBuilder, Stream win32Resources, Stream xmlDocStream, bool emittingPdb, DiagnosticBag diagnostics, Predicate`1<ISymbol> filterOpt, CancellationToken cancellationToken);
    private bool StartSourceChecksumCalculation(PEModuleBuilder moduleBeingBuilt, DiagnosticBag diagnostics);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation/VB$StateMachine_181_AddedModulesResourceNames")]
private IEnumerable`1<string> AddedModulesResourceNames(DiagnosticBag diagnostics);
    internal virtual EmitDifferenceResult EmitDifference(EmitBaseline baseline, IEnumerable`1<SemanticEdit> edits, Func`2<ISymbol, bool> isAddedSymbol, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection`1<MethodDefinitionHandle> updatedMethods, CompilationTestData testData, CancellationToken cancellationToken);
    internal string GetRuntimeMetadataVersion();
    private static void AddDebugSourceDocumentsForChecksumDirectives(PEModuleBuilder moduleBeingBuilt, SyntaxTree tree, DiagnosticBag diagnosticBag);
    private static bool CheckSumMatches(string bytesText, ImmutableArray`1<byte> bytes);
    private static ImmutableArray`1<byte> MakeCheckSumBytes(string bytesText);
    private static DebugSourceDocument MakeDebugSourceDocumentForTree(string normalizedPath, SyntaxTree tree);
    private void SetupWin32Resources(PEModuleBuilder moduleBeingBuilt, Stream win32Resources, DiagnosticBag diagnostics);
    internal virtual bool HasCodeToEmit();
    protected virtual Compilation CommonWithReferences(IEnumerable`1<MetadataReference> newReferences);
    protected virtual Compilation CommonWithAssemblyName(string assemblyName);
    protected virtual Compilation CommonWithScriptCompilationInfo(ScriptCompilationInfo info);
    protected virtual IAssemblySymbol get_CommonAssembly();
    protected virtual INamespaceSymbol get_CommonGlobalNamespace();
    protected virtual CompilationOptions get_CommonOptions();
    protected virtual SemanticModel CommonGetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility);
    protected virtual IEnumerable`1<SyntaxTree> get_CommonSyntaxTrees();
    protected virtual Compilation CommonAddSyntaxTrees(IEnumerable`1<SyntaxTree> trees);
    protected virtual Compilation CommonRemoveSyntaxTrees(IEnumerable`1<SyntaxTree> trees);
    protected virtual Compilation CommonRemoveAllSyntaxTrees();
    protected virtual Compilation CommonReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree);
    protected virtual Compilation CommonWithOptions(CompilationOptions options);
    protected virtual bool CommonContainsSyntaxTree(SyntaxTree syntaxTree);
    protected virtual ISymbol CommonGetAssemblyOrModuleSymbol(MetadataReference reference);
    protected virtual Compilation CommonClone();
    protected virtual IModuleSymbol get_CommonSourceModule();
    protected virtual INamedTypeSymbol CommonGetSpecialType(SpecialType specialType);
    protected virtual INamespaceSymbol CommonGetCompilationNamespace(INamespaceSymbol namespaceSymbol);
    protected virtual INamedTypeSymbol CommonGetTypeByMetadataName(string metadataName);
    protected virtual INamedTypeSymbol get_CommonScriptClass();
    public virtual INamedTypeSymbol CreateErrorTypeSymbol(INamespaceOrTypeSymbol container, string name, int arity);
    protected virtual IArrayTypeSymbol CommonCreateArrayTypeSymbol(ITypeSymbol elementType, int rank);
    protected virtual IPointerTypeSymbol CommonCreatePointerTypeSymbol(ITypeSymbol elementType);
    protected virtual ITypeSymbol get_CommonDynamicType();
    protected virtual INamedTypeSymbol get_CommonObjectType();
    protected virtual IMethodSymbol CommonGetEntryPoint(CancellationToken cancellationToken);
    public virtual bool ContainsSymbolsWithName(Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    public virtual IEnumerable`1<ISymbol> GetSymbolsWithName(Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    internal virtual bool IsIOperationFeatureEnabled();
    internal MethodSymbol GetExtensionAttributeConstructor(DiagnosticInfo& useSiteError);
    internal SynthesizedAttributeData TrySynthesizeAttribute(WellKnownMember constructor, ImmutableArray`1<TypedConstant> arguments, ImmutableArray`1<KeyValuePair`2<WellKnownMember, TypedConstant>> namedArguments);
    private SynthesizedAttributeData ReturnNothingOrThrowIfAttributeNonOptional(WellKnownMember constructor);
    internal SynthesizedAttributeData SynthesizeExtensionAttribute();
    internal SynthesizedAttributeData SynthesizeStateMachineAttribute(MethodSymbol method, ModuleCompilationState compilationState);
    internal SynthesizedAttributeData SynthesizeDecimalConstantAttribute(decimal value);
    internal SynthesizedAttributeData SynthesizeDebuggerBrowsableNeverAttribute();
    internal SynthesizedAttributeData SynthesizeDebuggerHiddenAttribute();
    internal SynthesizedAttributeData SynthesizeEditorBrowsableNeverAttribute();
    internal SynthesizedAttributeData SynthesizeDebuggerNonUserCodeAttribute();
    internal SynthesizedAttributeData SynthesizeOptionalDebuggerStepThroughAttribute();
    internal Symbol GetWellKnownTypeMember(WellKnownMember member);
    internal virtual bool IsSystemTypeReference(ITypeSymbol type);
    internal virtual ISymbol CommonGetWellKnownTypeMember(WellKnownMember member);
    internal virtual bool IsAttributeType(ITypeSymbol type);
    internal NamedTypeSymbol GetWellKnownType(WellKnownType type);
    internal static Symbol GetRuntimeMember(NamedTypeSymbol declaringType, MemberDescriptor& descriptor, SignatureComparer`5<MethodSymbol, FieldSymbol, PropertySymbol, TypeSymbol, ParameterSymbol> comparer, AssemblySymbol accessWithinOpt);
}
public class Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationOptions : CompilationOptions {
    private ImmutableArray`1<GlobalImport> _globalImports;
    private string _rootNamespace;
    private OptionStrict _optionStrict;
    private bool _optionInfer;
    private bool _optionExplicit;
    private bool _optionCompareText;
    private bool _embedVbCoreRuntime;
    private VisualBasicParseOptions _parseOptions;
    private bool _suppressEmbeddedDeclarations;
    public ImmutableArray`1<GlobalImport> GlobalImports { get; }
    public string RootNamespace { get; }
    public OptionStrict OptionStrict { get; }
    public bool OptionInfer { get; }
    public bool OptionExplicit { get; }
    public bool OptionCompareText { get; }
    public bool EmbedVbCoreRuntime { get; }
    internal bool SuppressEmbeddedDeclarations { get; }
    internal VisualBasicParseOptions ParseOptions { get; }
    public VisualBasicCompilationOptions(OutputKind outputKind, string moduleName, string mainTypeName, string scriptClassName, IEnumerable`1<GlobalImport> globalImports, string rootNamespace, OptionStrict optionStrict, bool optionInfer, bool optionExplicit, bool optionCompareText, VisualBasicParseOptions parseOptions, bool embedVbCoreRuntime, OptimizationLevel optimizationLevel, bool checkOverflow, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray`1<byte> cryptoPublicKey, Nullable`1<bool> delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, bool deterministic, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider, bool publicSign, bool reportSuppressedDiagnostics);
    internal VisualBasicCompilationOptions(OutputKind outputKind, bool reportSuppressedDiagnostics, string ModuleName, string mainTypeName, string scriptClassName, IEnumerable`1<GlobalImport> globalImports, string rootNamespace, OptionStrict optionStrict, bool optionInfer, bool optionExplicit, bool optionCompareText, VisualBasicParseOptions parseOptions, bool embedVbCoreRuntime, OptimizationLevel optimizationLevel, bool checkOverflow, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray`1<byte> cryptoPublicKey, Nullable`1<bool> delaySign, bool publicSign, Platform platform, ReportDiagnostic generalDiagnosticOption, IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, bool deterministic, DateTime currentLocalTime, bool suppressEmbeddedDeclarations, bool extendedCustomDebugInformation, bool debugPlusMode, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider, MetadataImportOptions metadataImportOptions, bool referencesSupersedeLowerVersions);
    private VisualBasicCompilationOptions(VisualBasicCompilationOptions other);
    public VisualBasicCompilationOptions(OutputKind outputKind, string moduleName, string mainTypeName, string scriptClassName, IEnumerable`1<GlobalImport> globalImports, string rootNamespace, OptionStrict optionStrict, bool optionInfer, bool optionExplicit, bool optionCompareText, VisualBasicParseOptions parseOptions, bool embedVbCoreRuntime, OptimizationLevel optimizationLevel, bool checkOverflow, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray`1<byte> cryptoPublicKey, Nullable`1<bool> delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, bool deterministic, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider);
    public VisualBasicCompilationOptions(OutputKind outputKind, string moduleName, string mainTypeName, string scriptClassName, IEnumerable`1<GlobalImport> globalImports, string rootNamespace, OptionStrict optionStrict, bool optionInfer, bool optionExplicit, bool optionCompareText, VisualBasicParseOptions parseOptions, bool embedVbCoreRuntime, OptimizationLevel optimizationLevel, bool checkOverflow, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray`1<byte> cryptoPublicKey, Nullable`1<bool> delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider);
    public VisualBasicCompilationOptions(OutputKind outputKind, bool reportSuppressedDiagnostics, string moduleName, string mainTypeName, string scriptClassName, IEnumerable`1<GlobalImport> globalImports, string rootNamespace, OptionStrict optionStrict, bool optionInfer, bool optionExplicit, bool optionCompareText, VisualBasicParseOptions parseOptions, bool embedVbCoreRuntime, OptimizationLevel optimizationLevel, bool checkOverflow, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray`1<byte> cryptoPublicKey, Nullable`1<bool> delaySign, Platform platform, ReportDiagnostic generalDiagnosticOption, IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> specificDiagnosticOptions, bool concurrentBuild, bool deterministic, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider);
    internal virtual ImmutableArray`1<string> GetImports();
    public ImmutableArray`1<GlobalImport> get_GlobalImports();
    public string get_RootNamespace();
    internal ImmutableArray`1<string> GetRootNamespaceParts();
    public OptionStrict get_OptionStrict();
    public bool get_OptionInfer();
    public bool get_OptionExplicit();
    public bool get_OptionCompareText();
    public bool get_EmbedVbCoreRuntime();
    internal bool get_SuppressEmbeddedDeclarations();
    internal VisualBasicParseOptions get_ParseOptions();
    public VisualBasicCompilationOptions WithOutputKind(OutputKind kind);
    public VisualBasicCompilationOptions WithModuleName(string moduleName);
    public VisualBasicCompilationOptions WithScriptClassName(string name);
    public VisualBasicCompilationOptions WithMainTypeName(string name);
    public VisualBasicCompilationOptions WithGlobalImports(ImmutableArray`1<GlobalImport> globalImports);
    public VisualBasicCompilationOptions WithGlobalImports(IEnumerable`1<GlobalImport> globalImports);
    public VisualBasicCompilationOptions WithGlobalImports(GlobalImport[] globalImports);
    public VisualBasicCompilationOptions WithRootNamespace(string rootNamespace);
    public VisualBasicCompilationOptions WithOptionStrict(OptionStrict value);
    public VisualBasicCompilationOptions WithOptionInfer(bool value);
    public VisualBasicCompilationOptions WithOptionExplicit(bool value);
    public VisualBasicCompilationOptions WithOptionCompareText(bool value);
    public VisualBasicCompilationOptions WithEmbedVbCoreRuntime(bool value);
    public VisualBasicCompilationOptions WithOverflowChecks(bool enabled);
    public VisualBasicCompilationOptions WithConcurrentBuild(bool concurrentBuild);
    public VisualBasicCompilationOptions WithDeterministic(bool deterministic);
    internal VisualBasicCompilationOptions WithCurrentLocalTime(DateTime value);
    internal VisualBasicCompilationOptions WithExtendedCustomDebugInformation(bool extendedCustomDebugInformation);
    internal VisualBasicCompilationOptions WithDebugPlusMode(bool debugPlusMode);
    internal VisualBasicCompilationOptions WithSuppressEmbeddedDeclarations(bool suppressEmbeddedDeclarations);
    public VisualBasicCompilationOptions WithCryptoKeyContainer(string name);
    public VisualBasicCompilationOptions WithCryptoKeyFile(string path);
    public VisualBasicCompilationOptions WithCryptoPublicKey(ImmutableArray`1<byte> value);
    public VisualBasicCompilationOptions WithDelaySign(Nullable`1<bool> value);
    public VisualBasicCompilationOptions WithPlatform(Platform value);
    public VisualBasicCompilationOptions WithPublicSign(bool value);
    protected virtual CompilationOptions CommonWithDeterministic(bool deterministic);
    protected virtual CompilationOptions CommonWithGeneralDiagnosticOption(ReportDiagnostic value);
    protected virtual CompilationOptions CommonWithSpecificDiagnosticOptions(ImmutableDictionary`2<string, ReportDiagnostic> specificDiagnosticOptions);
    protected virtual CompilationOptions CommonWithSpecificDiagnosticOptions(IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> specificDiagnosticOptions);
    protected virtual CompilationOptions CommonWithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics);
    [ObsoleteAttribute]
protected virtual CompilationOptions CommonWithFeatures(ImmutableArray`1<string> features);
    public VisualBasicCompilationOptions WithGeneralDiagnosticOption(ReportDiagnostic value);
    public VisualBasicCompilationOptions WithSpecificDiagnosticOptions(ImmutableDictionary`2<string, ReportDiagnostic> value);
    public VisualBasicCompilationOptions WithSpecificDiagnosticOptions(IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> value);
    public VisualBasicCompilationOptions WithReportSuppressedDiagnostics(bool value);
    public VisualBasicCompilationOptions WithOptimizationLevel(OptimizationLevel value);
    internal VisualBasicCompilationOptions WithMetadataImportOptions(MetadataImportOptions value);
    internal VisualBasicCompilationOptions WithReferencesSupersedeLowerVersions(bool value);
    public VisualBasicCompilationOptions WithParseOptions(VisualBasicParseOptions options);
    public VisualBasicCompilationOptions WithXmlReferenceResolver(XmlReferenceResolver resolver);
    public VisualBasicCompilationOptions WithSourceReferenceResolver(SourceReferenceResolver resolver);
    public VisualBasicCompilationOptions WithMetadataReferenceResolver(MetadataReferenceResolver resolver);
    public VisualBasicCompilationOptions WithAssemblyIdentityComparer(AssemblyIdentityComparer comparer);
    public VisualBasicCompilationOptions WithStrongNameProvider(StrongNameProvider provider);
    protected virtual CompilationOptions CommonWithOutputKind(OutputKind kind);
    protected virtual CompilationOptions CommonWithPlatform(Platform platform);
    protected virtual CompilationOptions CommonWithPublicSign(bool publicSign);
    protected virtual CompilationOptions CommonWithOptimizationLevel(OptimizationLevel value);
    protected virtual CompilationOptions CommonWithAssemblyIdentityComparer(AssemblyIdentityComparer comparer);
    protected virtual CompilationOptions CommonWithXmlReferenceResolver(XmlReferenceResolver resolver);
    protected virtual CompilationOptions CommonWithSourceReferenceResolver(SourceReferenceResolver resolver);
    protected virtual CompilationOptions CommonWithMetadataReferenceResolver(MetadataReferenceResolver resolver);
    protected virtual CompilationOptions CommonWithStrongNameProvider(StrongNameProvider provider);
    internal virtual void ValidateOptions(ArrayBuilder`1<Diagnostic> builder);
    public sealed virtual override bool Equals(VisualBasicCompilationOptions other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual Diagnostic FilterDiagnostic(Diagnostic diagnostic);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationReference : CompilationReference {
    private VisualBasicCompilation _compilation;
    public VisualBasicCompilation Compilation { get; }
    internal Compilation CompilationCore { get; }
    public VisualBasicCompilationReference(VisualBasicCompilation compilation, ImmutableArray`1<string> aliases, bool embedInteropTypes);
    private VisualBasicCompilationReference(VisualBasicCompilation compilation, MetadataReferenceProperties properties);
    public VisualBasicCompilation get_Compilation();
    internal virtual Compilation get_CompilationCore();
    internal virtual CompilationReference WithPropertiesImpl(MetadataReferenceProperties properties);
    private string GetDebuggerDisplay();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompiler : CommonCompiler {
    internal static string ResponseFileName;
    internal static string VbcCommandLinePrefix;
    private static string s_responseFileName;
    private string _responseFile;
    private CommandLineDiagnosticFormatter _diagnosticFormatter;
    private ImmutableArray`1<AdditionalTextFile> _additionalTextFiles;
    internal VisualBasicCommandLineArguments Arguments { get; }
    public DiagnosticFormatter DiagnosticFormatter { get; }
    protected VisualBasicCompiler(VisualBasicCommandLineParser parser, string responseFile, String[] args, string clientDirectory, string baseDirectory, string sdkDirectory, string additionalReferenceDirectories, IAnalyzerAssemblyLoader analyzerLoader);
    private ImmutableArray`1<AdditionalTextFile> GetAdditionalTextFiles();
    protected virtual ImmutableArray`1<AdditionalTextFile> ResolveAdditionalFilesFromArguments(List`1<DiagnosticInfo> diagnostics, CommonMessageProvider messageProvider, TouchedFileLogger touchedFilesLogger);
    internal VisualBasicCommandLineArguments get_Arguments();
    public virtual DiagnosticFormatter get_DiagnosticFormatter();
    private SyntaxTree ParseFile(TextWriter consoleOutput, VisualBasicParseOptions parseOptions, VisualBasicParseOptions scriptParseOptions, Boolean& hadErrors, CommandLineSourceFile file, ErrorLogger errorLogger);
    public virtual Compilation CreateCompilation(TextWriter consoleOutput, TouchedFileLogger touchedFilesLogger, ErrorLogger errorLogger);
    private void PrintReferences(List`1<MetadataReference> resolvedReferences, TextWriter consoleOutput);
    protected virtual void PrintError(DiagnosticInfo Diagnostic, TextWriter consoleOutput);
    internal virtual bool SuppressDefaultResponseFile(IEnumerable`1<string> args);
    public virtual void PrintLogo(TextWriter consoleOutput);
    internal virtual string GetToolName();
    public virtual void PrintHelp(TextWriter consoleOutput);
    protected virtual bool TryGetCompilerDiagnosticCode(string diagnosticId, UInt32& code);
    protected virtual ImmutableArray`1<DiagnosticAnalyzer> ResolveAnalyzersFromArguments(List`1<DiagnosticInfo> diagnostics, CommonMessageProvider messageProvider, TouchedFileLogger touchedFiles);
}
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicControlFlowAnalysis : ControlFlowAnalysis {
    private RegionAnalysisContext _context;
    private ImmutableArray`1<SyntaxNode> _entryPoints;
    private ImmutableArray`1<SyntaxNode> _exitPoints;
    private object _regionStartPointIsReachable;
    private object _regionEndPointIsReachable;
    private ImmutableArray`1<SyntaxNode> _returnStatements;
    private Nullable`1<bool> _succeeded;
    public ImmutableArray`1<SyntaxNode> EntryPoints { get; }
    public ImmutableArray`1<SyntaxNode> ExitPoints { get; }
    public bool EndPointIsReachable { get; }
    public bool StartPointIsReachable { get; }
    public ImmutableArray`1<SyntaxNode> ReturnStatements { get; }
    public bool Succeeded { get; }
    internal VisualBasicControlFlowAnalysis(RegionAnalysisContext _context);
    public virtual ImmutableArray`1<SyntaxNode> get_EntryPoints();
    public virtual ImmutableArray`1<SyntaxNode> get_ExitPoints();
    public sealed virtual bool get_EndPointIsReachable();
    public sealed virtual bool get_StartPointIsReachable();
    private void ComputeReachability();
    public virtual ImmutableArray`1<SyntaxNode> get_ReturnStatements();
    public sealed virtual bool get_Succeeded();
}
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicDataFlowAnalysis : DataFlowAnalysis {
    private RegionAnalysisContext _context;
    private ImmutableArray`1<ISymbol> _variablesDeclared;
    private HashSet`1<Symbol> _unassignedVariables;
    private ImmutableArray`1<ISymbol> _dataFlowsIn;
    private ImmutableArray`1<ISymbol> _dataFlowsOut;
    private ImmutableArray`1<ISymbol> _alwaysAssigned;
    private ImmutableArray`1<ISymbol> _readInside;
    private ImmutableArray`1<ISymbol> _writtenInside;
    private ImmutableArray`1<ISymbol> _readOutside;
    private ImmutableArray`1<ISymbol> _writtenOutside;
    private ImmutableArray`1<ISymbol> _captured;
    private Nullable`1<bool> _succeeded;
    private bool _invalidRegionDetected;
    public ImmutableArray`1<ISymbol> VariablesDeclared { get; }
    private HashSet`1<Symbol> UnassignedVariables { get; }
    public ImmutableArray`1<ISymbol> DataFlowsIn { get; }
    public ImmutableArray`1<ISymbol> DataFlowsOut { get; }
    public ImmutableArray`1<ISymbol> AlwaysAssigned { get; }
    public ImmutableArray`1<ISymbol> ReadInside { get; }
    public ImmutableArray`1<ISymbol> WrittenInside { get; }
    public ImmutableArray`1<ISymbol> ReadOutside { get; }
    public ImmutableArray`1<ISymbol> WrittenOutside { get; }
    public ImmutableArray`1<ISymbol> Captured { get; }
    internal bool InvalidRegionDetectedInternal { get; }
    public bool Succeeded { get; }
    public ImmutableArray`1<ISymbol> UnsafeAddressTaken { get; }
    internal VisualBasicDataFlowAnalysis(RegionAnalysisContext _context);
    public virtual ImmutableArray`1<ISymbol> get_VariablesDeclared();
    private HashSet`1<Symbol> get_UnassignedVariables();
    public virtual ImmutableArray`1<ISymbol> get_DataFlowsIn();
    public virtual ImmutableArray`1<ISymbol> get_DataFlowsOut();
    public virtual ImmutableArray`1<ISymbol> get_AlwaysAssigned();
    public virtual ImmutableArray`1<ISymbol> get_ReadInside();
    public virtual ImmutableArray`1<ISymbol> get_WrittenInside();
    public virtual ImmutableArray`1<ISymbol> get_ReadOutside();
    public virtual ImmutableArray`1<ISymbol> get_WrittenOutside();
    private void AnalyzeReadWrite();
    public virtual ImmutableArray`1<ISymbol> get_Captured();
    internal bool get_InvalidRegionDetectedInternal();
    public sealed virtual bool get_Succeeded();
    public virtual ImmutableArray`1<ISymbol> get_UnsafeAddressTaken();
    internal ImmutableArray`1<ISymbol> Sort(IEnumerable`1<Symbol> data);
}
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicDeclarationComputer : DeclarationComputer {
    public static void ComputeDeclarationsInSpan(SemanticModel model, TextSpan span, bool getSymbol, List`1<DeclarationInfo> builder, CancellationToken cancellationToken);
    public static void ComputeDeclarationsInNode(SemanticModel model, SyntaxNode node, bool getSymbol, List`1<DeclarationInfo> builder, CancellationToken cancellationToken, Nullable`1<int> levelsToCompute);
    private static bool InvalidLevel(Nullable`1<int> level);
    private static Nullable`1<int> DecrementLevel(Nullable`1<int> level);
    private static void ComputeDeclarationsCore(SemanticModel model, SyntaxNode node, Func`3<SyntaxNode, Nullable`1<int>, bool> shouldSkip, bool getSymbol, List`1<DeclarationInfo> builder, Nullable`1<int> levelsToCompute, CancellationToken cancellationToken);
    private static IEnumerable`1<SyntaxNode> GetParameterInitializers(ParameterListSyntax parameterList);
    private static IEnumerable`1<SyntaxNode> GetInitializerNodes(PropertyStatementSyntax propertyStatement);
    private static SyntaxNode GetInitializerNode(VariableDeclaratorSyntax variableDeclarator);
    private static SyntaxNode GetAsNewClauseIntializer(AsClauseSyntax asClause);
}
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicDiagnosticFilter : object {
    private static ERRID[] s_alinkWarnings;
    private static VisualBasicDiagnosticFilter();
    public static Diagnostic Filter(Diagnostic diagnostic, ReportDiagnostic generalDiagnosticOption, IDictionary`2<string, ReportDiagnostic> specificDiagnosticOptions);
    internal static ReportDiagnostic GetDiagnosticReport(DiagnosticSeverity severity, bool isEnabledByDefault, string id, Location location, string category, ReportDiagnostic generalDiagnosticOption, IDictionary`2<string, ReportDiagnostic> caseInsensitiveSpecificDiagnosticOptions, Boolean& hasDisableDirectiveSuppression);
}
public class Microsoft.CodeAnalysis.VisualBasic.VisualBasicDiagnosticFormatter : DiagnosticFormatter {
    [CompilerGeneratedAttribute]
private static VisualBasicDiagnosticFormatter _Instance;
    public static VisualBasicDiagnosticFormatter Instance { get; }
    private static VisualBasicDiagnosticFormatter();
    internal virtual string FormatSourceSpan(LinePositionSpan span, IFormatProvider formatter);
    [CompilerGeneratedAttribute]
public static VisualBasicDiagnosticFormatter get_Instance();
}
[ExtensionAttribute]
[StandardModuleAttribute]
public class Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions : object {
    internal static bool IsVisualBasicKind(int rawKind);
    [ExtensionAttribute]
public static SyntaxKind Kind(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static SyntaxKind Kind(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxKind Kind(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxKind Kind(SyntaxNodeOrToken nodeOrToken);
    [ExtensionAttribute]
internal static Location GetLocation(SyntaxReference syntaxReference);
    [ExtensionAttribute]
internal static bool IsMyTemplate(SyntaxTree syntaxTree);
    [ExtensionAttribute]
internal static bool HasReferenceDirectives(SyntaxTree syntaxTree);
    [ExtensionAttribute]
internal static bool IsAnyPreprocessorSymbolDefined(SyntaxTree syntaxTree, IEnumerable`1<string> conditionalSymbolNames, SyntaxNodeOrToken atNode);
    [ExtensionAttribute]
internal static VisualBasicSyntaxNode GetVisualBasicSyntax(SyntaxReference syntaxReference, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static VisualBasicSyntaxNode GetVisualBasicRoot(SyntaxTree syntaxTree, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static VisualBasicPreprocessingSymbolInfo GetPreprocessingSymbolInfo(SyntaxTree syntaxTree, IdentifierNameSyntax identifierNode);
    [ExtensionAttribute]
internal static SyntaxDiagnosticInfoList Errors(SyntaxTrivia trivia);
    [ExtensionAttribute]
internal static SyntaxDiagnosticInfoList Errors(SyntaxToken token);
    [ExtensionAttribute]
internal static ReadOnlyCollection`1<Diagnostic> GetSyntaxErrors(SyntaxToken token, SyntaxTree tree);
    [ExtensionAttribute]
internal static GreenNode AddError(GreenNode node, DiagnosticInfo diagnostic);
    [ExtensionAttribute]
public static bool IsBracketed(SyntaxToken token);
    [ExtensionAttribute]
public static TypeCharacter GetTypeCharacter(SyntaxToken token);
    [ExtensionAttribute]
public static Nullable`1<LiteralBase> GetBase(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsKeyword(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsReservedKeyword(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsContextualKeyword(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsPreprocessorKeyword(SyntaxToken token);
    [ExtensionAttribute]
public static string GetIdentifierText(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxTokenList Insert(SyntaxTokenList list, int index, SyntaxToken[] items);
    [ExtensionAttribute]
public static SyntaxTokenList Add(SyntaxTokenList list, SyntaxToken[] items);
    [ExtensionAttribute]
public static SyntaxToken ReplaceTrivia(SyntaxToken token, SyntaxTrivia oldTrivia, SyntaxTrivia newTrivia);
    [ExtensionAttribute]
public static SyntaxToken ReplaceTrivia(SyntaxToken token, IEnumerable`1<SyntaxTrivia> trivia, Func`3<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia);
    [ExtensionAttribute]
internal static SeparatedSyntaxList`1<TOther> AsSeparatedList(SyntaxNodeOrTokenList list);
    [ExtensionAttribute]
public static IList`1<DirectiveTriviaSyntax> GetDirectives(SyntaxNode node, Func`2<DirectiveTriviaSyntax, bool> filter);
    [ExtensionAttribute]
public static DirectiveTriviaSyntax GetFirstDirective(SyntaxNode node, Func`2<DirectiveTriviaSyntax, bool> predicate);
    [ExtensionAttribute]
public static DirectiveTriviaSyntax GetLastDirective(SyntaxNode node, Func`2<DirectiveTriviaSyntax, bool> predicate);
    [ExtensionAttribute]
public static CompilationUnitSyntax GetCompilationUnitRoot(SyntaxTree tree);
    [ExtensionAttribute]
internal static ReportDiagnostic GetWarningState(SyntaxTree tree, string id, int position);
    [ExtensionAttribute]
public static bool IsShared(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsOverrides(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsOverridable(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsNotOverridable(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsMustOverride(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsMe(IParameterSymbol parameterSymbol);
    [ExtensionAttribute]
public static bool IsOverloads(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsOverloads(IPropertySymbol propertySymbol);
    [ExtensionAttribute]
public static bool IsDefault(IPropertySymbol propertySymbol);
    [ExtensionAttribute]
public static ImmutableArray`1<HandledEvent> HandledEvents(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool IsFor(ILocalSymbol localSymbol);
    [ExtensionAttribute]
public static bool IsForEach(ILocalSymbol localSymbol);
    [ExtensionAttribute]
public static bool IsCatch(ILocalSymbol localSymbol);
    [ExtensionAttribute]
public static IFieldSymbol AssociatedField(IEventSymbol eventSymbol);
    [ExtensionAttribute]
public static bool HasAssociatedField(IEventSymbol eventSymbol);
    [ExtensionAttribute]
public static ImmutableArray`1<AttributeData> GetFieldAttributes(IEventSymbol eventSymbol);
    [ExtensionAttribute]
public static bool IsImplicitlyDeclared(IEventSymbol eventSymbol);
    [ExtensionAttribute]
public static ImmutableArray`1<INamedTypeSymbol> GetModuleMembers(INamespaceSymbol namespace);
    [ExtensionAttribute]
public static ImmutableArray`1<INamedTypeSymbol> GetModuleMembers(INamespaceSymbol namespace, string name);
    [ExtensionAttribute]
public static OptionStrict OptionStrict(SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool OptionInfer(SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool OptionExplicit(SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool OptionCompareText(SemanticModel semanticModel);
    [ExtensionAttribute]
public static INamespaceSymbol RootNamespace(Compilation compilation);
    [ExtensionAttribute]
public static ImmutableArray`1<IAliasSymbol> AliasImports(Compilation compilation);
    [ExtensionAttribute]
public static ImmutableArray`1<INamespaceOrTypeSymbol> MemberImports(Compilation compilation);
    [ExtensionAttribute]
public static Conversion ClassifyConversion(Compilation compilation, ITypeSymbol source, ITypeSymbol destination);
    [ExtensionAttribute]
public static INamedTypeSymbol GetSpecialType(Compilation compilation, SpecialType typeId);
    [ExtensionAttribute]
public static Conversion ClassifyConversion(SemanticModel semanticModel, ExpressionSyntax expression, ITypeSymbol destination);
    [ExtensionAttribute]
public static Conversion ClassifyConversion(SemanticModel semanticModel, int position, ExpressionSyntax expression, ITypeSymbol destination);
    [ExtensionAttribute]
public static ISymbol GetDeclaredSymbol(SemanticModel semanticModel, ModifiedIdentifierSyntax identifierSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IPropertySymbol GetDeclaredSymbol(SemanticModel semanticModel, FieldInitializerSyntax fieldInitializerSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol GetDeclaredSymbol(SemanticModel semanticModel, AnonymousObjectCreationExpressionSyntax anonymousObjectCreationExpressionSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IRangeVariableSymbol GetDeclaredSymbol(SemanticModel semanticModel, ExpressionRangeVariableSyntax rangeVariableSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IRangeVariableSymbol GetDeclaredSymbol(SemanticModel semanticModel, CollectionRangeVariableSyntax rangeVariableSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IRangeVariableSymbol GetDeclaredSymbol(SemanticModel semanticModel, AggregationRangeVariableSyntax rangeVariableSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ILabelSymbol GetDeclaredSymbol(SemanticModel semanticModel, LabelStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IFieldSymbol GetDeclaredSymbol(SemanticModel semanticModel, EnumMemberDeclarationSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol GetDeclaredSymbol(SemanticModel semanticModel, TypeStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol GetDeclaredSymbol(SemanticModel semanticModel, TypeBlockSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol GetDeclaredSymbol(SemanticModel semanticModel, EnumStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol GetDeclaredSymbol(SemanticModel semanticModel, EnumBlockSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamespaceSymbol GetDeclaredSymbol(SemanticModel semanticModel, NamespaceStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamespaceSymbol GetDeclaredSymbol(SemanticModel semanticModel, NamespaceBlockSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IParameterSymbol GetDeclaredSymbol(SemanticModel semanticModel, ParameterSyntax parameter, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeParameterSymbol GetDeclaredSymbol(SemanticModel semanticModel, TypeParameterSyntax typeParameter, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol GetDeclaredSymbol(SemanticModel semanticModel, DelegateStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMethodSymbol GetDeclaredSymbol(SemanticModel semanticModel, SubNewStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMethodSymbol GetDeclaredSymbol(SemanticModel semanticModel, MethodStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMethodSymbol GetDeclaredSymbol(SemanticModel semanticModel, DeclareStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMethodSymbol GetDeclaredSymbol(SemanticModel semanticModel, OperatorStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMethodSymbol GetDeclaredSymbol(SemanticModel semanticModel, MethodBlockBaseSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IPropertySymbol GetDeclaredSymbol(SemanticModel semanticModel, PropertyStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEventSymbol GetDeclaredSymbol(SemanticModel semanticModel, EventStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IPropertySymbol GetDeclaredSymbol(SemanticModel semanticModel, PropertyBlockSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEventSymbol GetDeclaredSymbol(SemanticModel semanticModel, EventBlockSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ILocalSymbol GetDeclaredSymbol(SemanticModel semanticModel, CatchStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMethodSymbol GetDeclaredSymbol(SemanticModel semanticModel, AccessorStatementSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IAliasSymbol GetDeclaredSymbol(SemanticModel semanticModel, SimpleImportsClauseSyntax declarationSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ForEachStatementInfo GetForEachStatementInfo(SemanticModel semanticModel, ForEachStatementSyntax node);
    [ExtensionAttribute]
public static ForEachStatementInfo GetForEachStatementInfo(SemanticModel semanticModel, ForEachBlockSyntax node);
    [ExtensionAttribute]
public static AwaitExpressionInfo GetAwaitExpressionInfo(SemanticModel semanticModel, AwaitExpressionSyntax awaitExpression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static PreprocessingSymbolInfo GetPreprocessingSymbolInfo(SemanticModel semanticModel, IdentifierNameSyntax node);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetCollectionInitializerSymbolInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, CrefReferenceSyntax crefReference, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSpeculativeSymbolInfo(SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption);
    [ExtensionAttribute]
public static SymbolInfo GetSpeculativeSymbolInfo(SemanticModel semanticModel, int position, AttributeSyntax attribute);
    [ExtensionAttribute]
public static Conversion GetConversion(SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Conversion GetSpeculativeConversion(SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption);
    [ExtensionAttribute]
public static TypeInfo GetTypeInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TypeInfo GetSpeculativeTypeInfo(SemanticModel semanticModel, int position, ExpressionSyntax expression, SpeculativeBindingOption bindingOption);
    [ExtensionAttribute]
public static TypeInfo GetTypeInfo(SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> GetMemberGroup(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> GetSpeculativeMemberGroup(SemanticModel semanticModel, int position, ExpressionSyntax expression);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> GetMemberGroup(SemanticModel semanticModel, AttributeSyntax attribute, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IAliasSymbol GetAliasInfo(SemanticModel semanticModel, IdentifierNameSyntax nameSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IAliasSymbol GetSpeculativeAliasInfo(SemanticModel semanticModel, int position, IdentifierNameSyntax nameSyntax, SpeculativeBindingOption bindingOption);
    [ExtensionAttribute]
public static CollectionRangeVariableSymbolInfo GetCollectionRangeVariableSymbolInfo(SemanticModel semanticModel, CollectionRangeVariableSyntax variableSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static AggregateClauseSymbolInfo GetAggregateClauseSymbolInfo(SemanticModel semanticModel, AggregateClauseSyntax aggregateSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, QueryClauseSyntax clauseSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, ExpressionRangeVariableSyntax variableSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, FunctionAggregationSyntax functionSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, OrderingSyntax orderingSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ControlFlowAnalysis AnalyzeControlFlow(SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement);
    [ExtensionAttribute]
public static ControlFlowAnalysis AnalyzeControlFlow(SemanticModel semanticModel, StatementSyntax statement);
    [ExtensionAttribute]
public static DataFlowAnalysis AnalyzeDataFlow(SemanticModel semanticModel, ExpressionSyntax expression);
    [ExtensionAttribute]
public static DataFlowAnalysis AnalyzeDataFlow(SemanticModel semanticModel, StatementSyntax firstStatement, StatementSyntax lastStatement);
    [ExtensionAttribute]
public static DataFlowAnalysis AnalyzeDataFlow(SemanticModel semanticModel, StatementSyntax statement);
    [ExtensionAttribute]
public static bool TryGetSpeculativeSemanticModelForMethodBody(SemanticModel semanticModel, int position, MethodBlockBaseSyntax method, SemanticModel& speculativeModel);
    [ExtensionAttribute]
public static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, RangeArgumentSyntax rangeArgument, SemanticModel& speculativeModel);
    [ExtensionAttribute]
public static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, ExecutableStatementSyntax statement, SemanticModel& speculativeModel);
    [ExtensionAttribute]
public static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, EqualsValueSyntax initializer, SemanticModel& speculativeModel);
    [ExtensionAttribute]
public static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, AttributeSyntax attribute, SemanticModel& speculativeModel);
    [ExtensionAttribute]
public static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, TypeSyntax type, SemanticModel& speculativeModel, SpeculativeBindingOption bindingOption);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicFileSystemExtensions : object {
    [ExtensionAttribute]
public static EmitResult Emit(VisualBasicCompilation compilation, string outputPath, string pdbPath, string xmlDocPath, string win32ResourcesPath, IEnumerable`1<ResourceDescription> manifestResources, CancellationToken cancellationToken);
}
public class Microsoft.CodeAnalysis.VisualBasic.VisualBasicParseOptions : ParseOptions {
    [CompilerGeneratedAttribute]
private static VisualBasicParseOptions _Default;
    private static ImmutableArray`1<KeyValuePair`2<string, object>> s_defaultPreprocessorSymbols;
    private ImmutableDictionary`2<string, string> _features;
    private ImmutableArray`1<KeyValuePair`2<string, object>> _preprocessorSymbols;
    private LanguageVersion _languageVersion;
    public static VisualBasicParseOptions Default { get; }
    private static ImmutableArray`1<KeyValuePair`2<string, object>> DefaultPreprocessorSymbols { get; }
    public LanguageVersion LanguageVersion { get; }
    public ImmutableArray`1<KeyValuePair`2<string, object>> PreprocessorSymbols { get; }
    public IEnumerable`1<string> PreprocessorSymbolNames { get; }
    public IReadOnlyDictionary`2<string, string> Features { get; }
    private static VisualBasicParseOptions();
    public VisualBasicParseOptions(LanguageVersion languageVersion, DocumentationMode documentationMode, SourceCodeKind kind, IEnumerable`1<KeyValuePair`2<string, object>> preprocessorSymbols);
    internal VisualBasicParseOptions(LanguageVersion languageVersion, DocumentationMode documentationMode, SourceCodeKind kind, IEnumerable`1<KeyValuePair`2<string, object>> preprocessorSymbols, ImmutableDictionary`2<string, string> features);
    private VisualBasicParseOptions(LanguageVersion languageVersion, DocumentationMode documentationMode, SourceCodeKind kind, ImmutableArray`1<KeyValuePair`2<string, object>> preprocessorSymbols, ImmutableDictionary`2<string, string> features);
    private VisualBasicParseOptions(VisualBasicParseOptions other);
    [CompilerGeneratedAttribute]
public static VisualBasicParseOptions get_Default();
    private static void ValidatePreprocessorSymbols(IEnumerable`1<KeyValuePair`2<string, object>> preprocessorSymbols, string parameterName);
    private static ImmutableArray`1<KeyValuePair`2<string, object>> get_DefaultPreprocessorSymbols();
    public LanguageVersion get_LanguageVersion();
    public ImmutableArray`1<KeyValuePair`2<string, object>> get_PreprocessorSymbols();
    public virtual IEnumerable`1<string> get_PreprocessorSymbolNames();
    public VisualBasicParseOptions WithLanguageVersion(LanguageVersion version);
    public VisualBasicParseOptions WithKind(SourceCodeKind kind);
    public VisualBasicParseOptions WithDocumentationMode(DocumentationMode documentationMode);
    public VisualBasicParseOptions WithPreprocessorSymbols(IEnumerable`1<KeyValuePair`2<string, object>> symbols);
    public VisualBasicParseOptions WithPreprocessorSymbols(KeyValuePair`2[] symbols);
    public VisualBasicParseOptions WithPreprocessorSymbols(ImmutableArray`1<KeyValuePair`2<string, object>> symbols);
    public virtual ParseOptions CommonWithKind(SourceCodeKind kind);
    protected virtual ParseOptions CommonWithDocumentationMode(DocumentationMode documentationMode);
    protected virtual ParseOptions CommonWithFeatures(IEnumerable`1<KeyValuePair`2<string, string>> features);
    public VisualBasicParseOptions WithFeatures(IEnumerable`1<KeyValuePair`2<string, string>> features);
    public virtual IReadOnlyDictionary`2<string, string> get_Features();
    public sealed virtual override bool Equals(VisualBasicParseOptions other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicPreprocessingSymbolInfo : ValueType {
    private PreprocessingSymbol _symbol;
    private object _constantValue;
    private bool _isDefined;
    internal static VisualBasicPreprocessingSymbolInfo None;
    public PreprocessingSymbol Symbol { get; }
    public bool IsDefined { get; }
    public object ConstantValue { get; }
    private static VisualBasicPreprocessingSymbolInfo();
    internal VisualBasicPreprocessingSymbolInfo(PreprocessingSymbol symbol, object constantValueOpt, bool isDefined);
    public PreprocessingSymbol get_Symbol();
    public bool get_IsDefined();
    public object get_ConstantValue();
    public static PreprocessingSymbolInfo op_Implicit(VisualBasicPreprocessingSymbolInfo info);
    public sealed virtual override bool Equals(VisualBasicPreprocessingSymbolInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicScriptCompilationInfo : ScriptCompilationInfo {
    [CompilerGeneratedAttribute]
private VisualBasicCompilation _PreviousScriptCompilation;
    public VisualBasicCompilation PreviousScriptCompilation { get; }
    internal Compilation CommonPreviousScriptCompilation { get; }
    internal VisualBasicScriptCompilationInfo(VisualBasicCompilation previousCompilationOpt, Type returnType, Type globalsType);
    [CompilerGeneratedAttribute]
public VisualBasicCompilation get_PreviousScriptCompilation();
    internal virtual Compilation get_CommonPreviousScriptCompilation();
    public VisualBasicScriptCompilationInfo WithPreviousScriptCompilation(VisualBasicCompilation compilation);
    internal virtual ScriptCompilationInfo CommonWithPreviousScriptCompilation(Compilation compilation);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.VisualBasicSymbolVisitor : object {
    public virtual void Visit(Symbol symbol);
    public virtual void DefaultVisit(Symbol symbol);
    public virtual void VisitAlias(AliasSymbol symbol);
    public virtual void VisitArrayType(ArrayTypeSymbol symbol);
    public virtual void VisitAssembly(AssemblySymbol symbol);
    public virtual void VisitEvent(EventSymbol symbol);
    public virtual void VisitField(FieldSymbol symbol);
    public virtual void VisitLabel(LabelSymbol symbol);
    public virtual void VisitLocal(LocalSymbol symbol);
    public virtual void VisitMethod(MethodSymbol symbol);
    public virtual void VisitModule(ModuleSymbol symbol);
    public virtual void VisitNamedType(NamedTypeSymbol symbol);
    public virtual void VisitNamespace(NamespaceSymbol symbol);
    public virtual void VisitParameter(ParameterSymbol symbol);
    public virtual void VisitProperty(PropertySymbol symbol);
    public virtual void VisitRangeVariable(RangeVariableSymbol symbol);
    public virtual void VisitTypeParameter(TypeParameterSymbol symbol);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.VisualBasicSymbolVisitor`1 : object {
    public virtual TResult Visit(Symbol symbol);
    public virtual TResult DefaultVisit(Symbol symbol);
    public virtual TResult VisitAlias(AliasSymbol symbol);
    public virtual TResult VisitArrayType(ArrayTypeSymbol symbol);
    public virtual TResult VisitAssembly(AssemblySymbol symbol);
    public virtual TResult VisitEvent(EventSymbol symbol);
    public virtual TResult VisitField(FieldSymbol symbol);
    public virtual TResult VisitLabel(LabelSymbol symbol);
    public virtual TResult VisitLocal(LocalSymbol symbol);
    public virtual TResult VisitMethod(MethodSymbol symbol);
    public virtual TResult VisitModule(ModuleSymbol symbol);
    public virtual TResult VisitNamedType(NamedTypeSymbol symbol);
    public virtual TResult VisitNamespace(NamespaceSymbol symbol);
    public virtual TResult VisitParameter(ParameterSymbol symbol);
    public virtual TResult VisitProperty(PropertySymbol symbol);
    public virtual TResult VisitRangeVariable(RangeVariableSymbol symbol);
    public virtual TResult VisitTypeParameter(TypeParameterSymbol symbol);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.VisualBasicSymbolVisitor`2 : object {
    public virtual TResult Visit(Symbol symbol, TArgument arg);
    public virtual TResult DefaultVisit(Symbol symbol, TArgument arg);
    public virtual TResult VisitAlias(AliasSymbol symbol, TArgument arg);
    public virtual TResult VisitAssembly(AssemblySymbol symbol, TArgument arg);
    public virtual TResult VisitModule(ModuleSymbol symbol, TArgument arg);
    public virtual TResult VisitNamespace(NamespaceSymbol symbol, TArgument arg);
    public virtual TResult VisitNamedType(NamedTypeSymbol symbol, TArgument arg);
    public virtual TResult VisitTypeParameter(TypeParameterSymbol symbol, TArgument arg);
    public virtual TResult VisitArrayType(ArrayTypeSymbol symbol, TArgument arg);
    public virtual TResult VisitErrorType(ErrorTypeSymbol symbol, TArgument arg);
    public virtual TResult VisitMethod(MethodSymbol symbol, TArgument arg);
    public virtual TResult VisitProperty(PropertySymbol symbol, TArgument arg);
    public virtual TResult VisitField(FieldSymbol symbol, TArgument arg);
    public virtual TResult VisitParameter(ParameterSymbol symbol, TArgument arg);
    public virtual TResult VisitLocal(LocalSymbol symbol, TArgument arg);
    public virtual TResult VisitRangeVariable(RangeVariableSymbol symbol, TArgument arg);
    public virtual TResult VisitLabel(LabelSymbol symbol, TArgument arg);
    public virtual TResult VisitEvent(EventSymbol symbol, TArgument arg);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxNode : SyntaxNode {
    private static RecordingObjectBinder s_binder;
    private static ObjectReaderData s_defaultObjectReaderData;
    private static ObjectWriterData s_defaultObjectWriterData;
    private static IEnumerable`1<object> s_serializationData;
    internal static ReadOnlyCollection`1<Diagnostic> EmptyErrorCollection;
    internal AbstractSyntaxNavigator Navigator { get; }
    internal VisualBasicSyntaxNode VbGreen { get; }
    internal SyntaxTree SyntaxTree { get; }
    protected string KindText { get; }
    public string Language { get; }
    internal VisualBasicSyntaxNode Parent { get; }
    public bool IsDirective { get; }
    public int SpanStart { get; }
    internal bool HasErrors { get; }
    protected SyntaxTree SyntaxTreeCore { get; }
    private static VisualBasicSyntaxNode();
    internal VisualBasicSyntaxNode(GreenNode green, SyntaxNode parent, int position);
    internal VisualBasicSyntaxNode(GreenNode green, int position, SyntaxTree syntaxTree);
    internal virtual AbstractSyntaxNavigator get_Navigator();
    internal VisualBasicSyntaxNode get_VbGreen();
    internal static T CloneNodeAsRoot(T node, SyntaxTree syntaxTree);
    internal SyntaxTree get_SyntaxTree();
    public abstract virtual TResult Accept(VisualBasicSyntaxVisitor`1<TResult> visitor);
    public abstract virtual void Accept(VisualBasicSyntaxVisitor visitor);
    public SyntaxKind Kind();
    protected virtual string get_KindText();
    public virtual string get_Language();
    internal VisualBasicSyntaxNode get_Parent();
    public sealed virtual string ToString();
    public sealed virtual string ToFullString();
    public virtual void WriteTo(TextWriter writer);
    public virtual void SerializeTo(Stream stream, CancellationToken cancellationToken);
    public static SyntaxNode DeserializeFrom(Stream stream, CancellationToken cancellationToken);
    private static ObjectReaderData GetDefaultObjectReaderData();
    private static ObjectWriterData GetDefaultObjectWriterData();
    private static IEnumerable`1<object> GetSerializationData();
    public bool get_IsDirective();
    public int get_SpanStart();
    public SyntaxTriviaList GetLeadingTrivia();
    public SyntaxTriviaList GetTrailingTrivia();
    internal bool get_HasErrors();
    internal ReadOnlyCollection`1<Diagnostic> GetSyntaxErrors(SyntaxTree tree);
    internal static ReadOnlyCollection`1<Diagnostic> DoGetSyntaxErrors(SyntaxTree tree, SyntaxNodeOrToken nodeOrToken);
    private static void PushNodesWithErrors(Stack`1<SyntaxNodeOrToken> stack, ChildSyntaxList nodes);
    private static void ProcessTrivia(SyntaxTree tree, List`1<Diagnostic> errorList, Stack`1<SyntaxNodeOrToken> stack, SyntaxTriviaList nodes);
    private static Diagnostic CreateSyntaxError(SyntaxTree tree, SyntaxNodeOrToken nodeOrToken, DiagnosticInfo errorInfo);
    private static Diagnostic CreateSyntaxError(SyntaxTree tree, SyntaxTrivia nodeOrToken, DiagnosticInfo errorInfo);
    internal bool IsEquivalentTo(VisualBasicSyntaxNode other);
    internal VisualBasicSyntaxNode AddError(DiagnosticInfo err);
    public SyntaxToken GetFirstToken(bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    public SyntaxToken GetLastToken(bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    public IList`1<DirectiveTriviaSyntax> GetDirectives(Func`2<DirectiveTriviaSyntax, bool> filter);
    public DirectiveTriviaSyntax GetFirstDirective(Func`2<DirectiveTriviaSyntax, bool> predicate);
    public DirectiveTriviaSyntax GetLastDirective(Func`2<DirectiveTriviaSyntax, bool> predicate);
    public virtual SyntaxNodeOrToken ChildThatContainsPosition(int position);
    protected sealed virtual bool EquivalentToCore(SyntaxNode other);
    protected virtual SyntaxTree get_SyntaxTreeCore();
    protected virtual SyntaxNode ReplaceCore(IEnumerable`1<TNode> nodes, Func`3<TNode, TNode, SyntaxNode> computeReplacementNode, IEnumerable`1<SyntaxToken> tokens, Func`3<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken, IEnumerable`1<SyntaxTrivia> trivia, Func`3<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia);
    protected virtual SyntaxNode RemoveNodesCore(IEnumerable`1<SyntaxNode> nodes, SyntaxRemoveOptions options);
    protected virtual SyntaxNode ReplaceNodeInListCore(SyntaxNode originalNode, IEnumerable`1<SyntaxNode> replacementNodes);
    protected virtual SyntaxNode InsertNodesInListCore(SyntaxNode nodeInList, IEnumerable`1<SyntaxNode> nodesToInsert, bool insertBefore);
    protected virtual SyntaxNode ReplaceTokenInListCore(SyntaxToken originalToken, IEnumerable`1<SyntaxToken> newTokens);
    protected virtual SyntaxNode InsertTokensInListCore(SyntaxToken originalToken, IEnumerable`1<SyntaxToken> newTokens, bool insertBefore);
    protected virtual SyntaxNode ReplaceTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable`1<SyntaxTrivia> newTrivia);
    protected virtual SyntaxNode InsertTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable`1<SyntaxTrivia> newTrivia, bool insertBefore);
    protected virtual SyntaxNode NormalizeWhitespaceCore(string indentation, string eol, bool elasticTrivia);
    public Location GetLocation();
    internal SyntaxReference GetReference();
    public IEnumerable`1<Diagnostic> GetDiagnostics();
    protected virtual bool IsEquivalentToCore(SyntaxNode node, bool topLevel);
    internal virtual SyntaxNode TryGetCorrespondingLambdaBody(SyntaxNode body);
    internal virtual SyntaxNode GetLambda();
    public SyntaxToken FindToken(int position, bool findInsideTrivia);
    public SyntaxTrivia FindTrivia(int textPosition, bool findInsideTrivia);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxRewriter : VisualBasicSyntaxVisitor`1<SyntaxNode> {
    private bool _visitIntoStructuredTrivia;
    private int _recursionDepth;
    public bool VisitIntoStructuredTrivia { get; }
    public VisualBasicSyntaxRewriter(bool visitIntoStructuredTrivia);
    public virtual bool get_VisitIntoStructuredTrivia();
    public virtual SyntaxNode Visit(SyntaxNode node);
    public virtual SyntaxToken VisitToken(SyntaxToken token);
    public virtual SyntaxTrivia VisitTrivia(SyntaxTrivia trivia);
    public virtual SyntaxList`1<TNode> VisitList(SyntaxList`1<TNode> list);
    public virtual TNode VisitListElement(TNode node);
    public virtual SyntaxTokenList VisitList(SyntaxTokenList list);
    public virtual SyntaxToken VisitListElement(SyntaxToken token);
    public virtual SeparatedSyntaxList`1<TNode> VisitList(SeparatedSyntaxList`1<TNode> list);
    public virtual SyntaxToken VisitListSeparator(SyntaxToken token);
    public virtual SyntaxTriviaList VisitList(SyntaxTriviaList list);
    public virtual SyntaxTrivia VisitListElement(SyntaxTrivia element);
    public virtual SyntaxNode VisitEmptyStatement(EmptyStatementSyntax node);
    public virtual SyntaxNode VisitEndBlockStatement(EndBlockStatementSyntax node);
    public virtual SyntaxNode VisitCompilationUnit(CompilationUnitSyntax node);
    public virtual SyntaxNode VisitOptionStatement(OptionStatementSyntax node);
    public virtual SyntaxNode VisitImportsStatement(ImportsStatementSyntax node);
    public virtual SyntaxNode VisitSimpleImportsClause(SimpleImportsClauseSyntax node);
    public virtual SyntaxNode VisitImportAliasClause(ImportAliasClauseSyntax node);
    public virtual SyntaxNode VisitXmlNamespaceImportsClause(XmlNamespaceImportsClauseSyntax node);
    public virtual SyntaxNode VisitNamespaceBlock(NamespaceBlockSyntax node);
    public virtual SyntaxNode VisitNamespaceStatement(NamespaceStatementSyntax node);
    public virtual SyntaxNode VisitModuleBlock(ModuleBlockSyntax node);
    public virtual SyntaxNode VisitStructureBlock(StructureBlockSyntax node);
    public virtual SyntaxNode VisitInterfaceBlock(InterfaceBlockSyntax node);
    public virtual SyntaxNode VisitClassBlock(ClassBlockSyntax node);
    public virtual SyntaxNode VisitEnumBlock(EnumBlockSyntax node);
    public virtual SyntaxNode VisitInheritsStatement(InheritsStatementSyntax node);
    public virtual SyntaxNode VisitImplementsStatement(ImplementsStatementSyntax node);
    public virtual SyntaxNode VisitModuleStatement(ModuleStatementSyntax node);
    public virtual SyntaxNode VisitStructureStatement(StructureStatementSyntax node);
    public virtual SyntaxNode VisitInterfaceStatement(InterfaceStatementSyntax node);
    public virtual SyntaxNode VisitClassStatement(ClassStatementSyntax node);
    public virtual SyntaxNode VisitEnumStatement(EnumStatementSyntax node);
    public virtual SyntaxNode VisitTypeParameterList(TypeParameterListSyntax node);
    public virtual SyntaxNode VisitTypeParameter(TypeParameterSyntax node);
    public virtual SyntaxNode VisitTypeParameterSingleConstraintClause(TypeParameterSingleConstraintClauseSyntax node);
    public virtual SyntaxNode VisitTypeParameterMultipleConstraintClause(TypeParameterMultipleConstraintClauseSyntax node);
    public virtual SyntaxNode VisitSpecialConstraint(SpecialConstraintSyntax node);
    public virtual SyntaxNode VisitTypeConstraint(TypeConstraintSyntax node);
    public virtual SyntaxNode VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node);
    public virtual SyntaxNode VisitMethodBlock(MethodBlockSyntax node);
    public virtual SyntaxNode VisitConstructorBlock(ConstructorBlockSyntax node);
    public virtual SyntaxNode VisitOperatorBlock(OperatorBlockSyntax node);
    public virtual SyntaxNode VisitAccessorBlock(AccessorBlockSyntax node);
    public virtual SyntaxNode VisitPropertyBlock(PropertyBlockSyntax node);
    public virtual SyntaxNode VisitEventBlock(EventBlockSyntax node);
    public virtual SyntaxNode VisitParameterList(ParameterListSyntax node);
    public virtual SyntaxNode VisitMethodStatement(MethodStatementSyntax node);
    public virtual SyntaxNode VisitSubNewStatement(SubNewStatementSyntax node);
    public virtual SyntaxNode VisitDeclareStatement(DeclareStatementSyntax node);
    public virtual SyntaxNode VisitDelegateStatement(DelegateStatementSyntax node);
    public virtual SyntaxNode VisitEventStatement(EventStatementSyntax node);
    public virtual SyntaxNode VisitOperatorStatement(OperatorStatementSyntax node);
    public virtual SyntaxNode VisitPropertyStatement(PropertyStatementSyntax node);
    public virtual SyntaxNode VisitAccessorStatement(AccessorStatementSyntax node);
    public virtual SyntaxNode VisitImplementsClause(ImplementsClauseSyntax node);
    public virtual SyntaxNode VisitHandlesClause(HandlesClauseSyntax node);
    public virtual SyntaxNode VisitKeywordEventContainer(KeywordEventContainerSyntax node);
    public virtual SyntaxNode VisitWithEventsEventContainer(WithEventsEventContainerSyntax node);
    public virtual SyntaxNode VisitWithEventsPropertyEventContainer(WithEventsPropertyEventContainerSyntax node);
    public virtual SyntaxNode VisitHandlesClauseItem(HandlesClauseItemSyntax node);
    public virtual SyntaxNode VisitIncompleteMember(IncompleteMemberSyntax node);
    public virtual SyntaxNode VisitFieldDeclaration(FieldDeclarationSyntax node);
    public virtual SyntaxNode VisitVariableDeclarator(VariableDeclaratorSyntax node);
    public virtual SyntaxNode VisitSimpleAsClause(SimpleAsClauseSyntax node);
    public virtual SyntaxNode VisitAsNewClause(AsNewClauseSyntax node);
    public virtual SyntaxNode VisitObjectMemberInitializer(ObjectMemberInitializerSyntax node);
    public virtual SyntaxNode VisitObjectCollectionInitializer(ObjectCollectionInitializerSyntax node);
    public virtual SyntaxNode VisitInferredFieldInitializer(InferredFieldInitializerSyntax node);
    public virtual SyntaxNode VisitNamedFieldInitializer(NamedFieldInitializerSyntax node);
    public virtual SyntaxNode VisitEqualsValue(EqualsValueSyntax node);
    public virtual SyntaxNode VisitParameter(ParameterSyntax node);
    public virtual SyntaxNode VisitModifiedIdentifier(ModifiedIdentifierSyntax node);
    public virtual SyntaxNode VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node);
    public virtual SyntaxNode VisitAttributeList(AttributeListSyntax node);
    public virtual SyntaxNode VisitAttribute(AttributeSyntax node);
    public virtual SyntaxNode VisitAttributeTarget(AttributeTargetSyntax node);
    public virtual SyntaxNode VisitAttributesStatement(AttributesStatementSyntax node);
    public virtual SyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node);
    public virtual SyntaxNode VisitPrintStatement(PrintStatementSyntax node);
    public virtual SyntaxNode VisitWhileBlock(WhileBlockSyntax node);
    public virtual SyntaxNode VisitUsingBlock(UsingBlockSyntax node);
    public virtual SyntaxNode VisitSyncLockBlock(SyncLockBlockSyntax node);
    public virtual SyntaxNode VisitWithBlock(WithBlockSyntax node);
    public virtual SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node);
    public virtual SyntaxNode VisitLabelStatement(LabelStatementSyntax node);
    public virtual SyntaxNode VisitGoToStatement(GoToStatementSyntax node);
    public virtual SyntaxNode VisitLabel(LabelSyntax node);
    public virtual SyntaxNode VisitStopOrEndStatement(StopOrEndStatementSyntax node);
    public virtual SyntaxNode VisitExitStatement(ExitStatementSyntax node);
    public virtual SyntaxNode VisitContinueStatement(ContinueStatementSyntax node);
    public virtual SyntaxNode VisitReturnStatement(ReturnStatementSyntax node);
    public virtual SyntaxNode VisitSingleLineIfStatement(SingleLineIfStatementSyntax node);
    public virtual SyntaxNode VisitSingleLineElseClause(SingleLineElseClauseSyntax node);
    public virtual SyntaxNode VisitMultiLineIfBlock(MultiLineIfBlockSyntax node);
    public virtual SyntaxNode VisitIfStatement(IfStatementSyntax node);
    public virtual SyntaxNode VisitElseIfBlock(ElseIfBlockSyntax node);
    public virtual SyntaxNode VisitElseIfStatement(ElseIfStatementSyntax node);
    public virtual SyntaxNode VisitElseBlock(ElseBlockSyntax node);
    public virtual SyntaxNode VisitElseStatement(ElseStatementSyntax node);
    public virtual SyntaxNode VisitTryBlock(TryBlockSyntax node);
    public virtual SyntaxNode VisitTryStatement(TryStatementSyntax node);
    public virtual SyntaxNode VisitCatchBlock(CatchBlockSyntax node);
    public virtual SyntaxNode VisitCatchStatement(CatchStatementSyntax node);
    public virtual SyntaxNode VisitCatchFilterClause(CatchFilterClauseSyntax node);
    public virtual SyntaxNode VisitFinallyBlock(FinallyBlockSyntax node);
    public virtual SyntaxNode VisitFinallyStatement(FinallyStatementSyntax node);
    public virtual SyntaxNode VisitErrorStatement(ErrorStatementSyntax node);
    public virtual SyntaxNode VisitOnErrorGoToStatement(OnErrorGoToStatementSyntax node);
    public virtual SyntaxNode VisitOnErrorResumeNextStatement(OnErrorResumeNextStatementSyntax node);
    public virtual SyntaxNode VisitResumeStatement(ResumeStatementSyntax node);
    public virtual SyntaxNode VisitSelectBlock(SelectBlockSyntax node);
    public virtual SyntaxNode VisitSelectStatement(SelectStatementSyntax node);
    public virtual SyntaxNode VisitCaseBlock(CaseBlockSyntax node);
    public virtual SyntaxNode VisitCaseStatement(CaseStatementSyntax node);
    public virtual SyntaxNode VisitElseCaseClause(ElseCaseClauseSyntax node);
    public virtual SyntaxNode VisitSimpleCaseClause(SimpleCaseClauseSyntax node);
    public virtual SyntaxNode VisitRangeCaseClause(RangeCaseClauseSyntax node);
    public virtual SyntaxNode VisitRelationalCaseClause(RelationalCaseClauseSyntax node);
    public virtual SyntaxNode VisitSyncLockStatement(SyncLockStatementSyntax node);
    public virtual SyntaxNode VisitDoLoopBlock(DoLoopBlockSyntax node);
    public virtual SyntaxNode VisitDoStatement(DoStatementSyntax node);
    public virtual SyntaxNode VisitLoopStatement(LoopStatementSyntax node);
    public virtual SyntaxNode VisitWhileOrUntilClause(WhileOrUntilClauseSyntax node);
    public virtual SyntaxNode VisitWhileStatement(WhileStatementSyntax node);
    public virtual SyntaxNode VisitForBlock(ForBlockSyntax node);
    public virtual SyntaxNode VisitForEachBlock(ForEachBlockSyntax node);
    public virtual SyntaxNode VisitForStatement(ForStatementSyntax node);
    public virtual SyntaxNode VisitForStepClause(ForStepClauseSyntax node);
    public virtual SyntaxNode VisitForEachStatement(ForEachStatementSyntax node);
    public virtual SyntaxNode VisitNextStatement(NextStatementSyntax node);
    public virtual SyntaxNode VisitUsingStatement(UsingStatementSyntax node);
    public virtual SyntaxNode VisitThrowStatement(ThrowStatementSyntax node);
    public virtual SyntaxNode VisitAssignmentStatement(AssignmentStatementSyntax node);
    public virtual SyntaxNode VisitMidExpression(MidExpressionSyntax node);
    public virtual SyntaxNode VisitCallStatement(CallStatementSyntax node);
    public virtual SyntaxNode VisitAddRemoveHandlerStatement(AddRemoveHandlerStatementSyntax node);
    public virtual SyntaxNode VisitRaiseEventStatement(RaiseEventStatementSyntax node);
    public virtual SyntaxNode VisitWithStatement(WithStatementSyntax node);
    public virtual SyntaxNode VisitReDimStatement(ReDimStatementSyntax node);
    public virtual SyntaxNode VisitRedimClause(RedimClauseSyntax node);
    public virtual SyntaxNode VisitEraseStatement(EraseStatementSyntax node);
    public virtual SyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node);
    public virtual SyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node);
    public virtual SyntaxNode VisitMeExpression(MeExpressionSyntax node);
    public virtual SyntaxNode VisitMyBaseExpression(MyBaseExpressionSyntax node);
    public virtual SyntaxNode VisitMyClassExpression(MyClassExpressionSyntax node);
    public virtual SyntaxNode VisitGetTypeExpression(GetTypeExpressionSyntax node);
    public virtual SyntaxNode VisitTypeOfExpression(TypeOfExpressionSyntax node);
    public virtual SyntaxNode VisitGetXmlNamespaceExpression(GetXmlNamespaceExpressionSyntax node);
    public virtual SyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node);
    public virtual SyntaxNode VisitXmlMemberAccessExpression(XmlMemberAccessExpressionSyntax node);
    public virtual SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node);
    public virtual SyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node);
    public virtual SyntaxNode VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node);
    public virtual SyntaxNode VisitArrayCreationExpression(ArrayCreationExpressionSyntax node);
    public virtual SyntaxNode VisitCollectionInitializer(CollectionInitializerSyntax node);
    public virtual SyntaxNode VisitCTypeExpression(CTypeExpressionSyntax node);
    public virtual SyntaxNode VisitDirectCastExpression(DirectCastExpressionSyntax node);
    public virtual SyntaxNode VisitTryCastExpression(TryCastExpressionSyntax node);
    public virtual SyntaxNode VisitPredefinedCastExpression(PredefinedCastExpressionSyntax node);
    public virtual SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node);
    public virtual SyntaxNode VisitUnaryExpression(UnaryExpressionSyntax node);
    public virtual SyntaxNode VisitBinaryConditionalExpression(BinaryConditionalExpressionSyntax node);
    public virtual SyntaxNode VisitTernaryConditionalExpression(TernaryConditionalExpressionSyntax node);
    public virtual SyntaxNode VisitSingleLineLambdaExpression(SingleLineLambdaExpressionSyntax node);
    public virtual SyntaxNode VisitMultiLineLambdaExpression(MultiLineLambdaExpressionSyntax node);
    public virtual SyntaxNode VisitLambdaHeader(LambdaHeaderSyntax node);
    public virtual SyntaxNode VisitArgumentList(ArgumentListSyntax node);
    public virtual SyntaxNode VisitOmittedArgument(OmittedArgumentSyntax node);
    public virtual SyntaxNode VisitSimpleArgument(SimpleArgumentSyntax node);
    public virtual SyntaxNode VisitNameColonEquals(NameColonEqualsSyntax node);
    public virtual SyntaxNode VisitRangeArgument(RangeArgumentSyntax node);
    public virtual SyntaxNode VisitQueryExpression(QueryExpressionSyntax node);
    public virtual SyntaxNode VisitCollectionRangeVariable(CollectionRangeVariableSyntax node);
    public virtual SyntaxNode VisitExpressionRangeVariable(ExpressionRangeVariableSyntax node);
    public virtual SyntaxNode VisitAggregationRangeVariable(AggregationRangeVariableSyntax node);
    public virtual SyntaxNode VisitVariableNameEquals(VariableNameEqualsSyntax node);
    public virtual SyntaxNode VisitFunctionAggregation(FunctionAggregationSyntax node);
    public virtual SyntaxNode VisitGroupAggregation(GroupAggregationSyntax node);
    public virtual SyntaxNode VisitFromClause(FromClauseSyntax node);
    public virtual SyntaxNode VisitLetClause(LetClauseSyntax node);
    public virtual SyntaxNode VisitAggregateClause(AggregateClauseSyntax node);
    public virtual SyntaxNode VisitDistinctClause(DistinctClauseSyntax node);
    public virtual SyntaxNode VisitWhereClause(WhereClauseSyntax node);
    public virtual SyntaxNode VisitPartitionWhileClause(PartitionWhileClauseSyntax node);
    public virtual SyntaxNode VisitPartitionClause(PartitionClauseSyntax node);
    public virtual SyntaxNode VisitGroupByClause(GroupByClauseSyntax node);
    public virtual SyntaxNode VisitJoinCondition(JoinConditionSyntax node);
    public virtual SyntaxNode VisitSimpleJoinClause(SimpleJoinClauseSyntax node);
    public virtual SyntaxNode VisitGroupJoinClause(GroupJoinClauseSyntax node);
    public virtual SyntaxNode VisitOrderByClause(OrderByClauseSyntax node);
    public virtual SyntaxNode VisitOrdering(OrderingSyntax node);
    public virtual SyntaxNode VisitSelectClause(SelectClauseSyntax node);
    public virtual SyntaxNode VisitXmlDocument(XmlDocumentSyntax node);
    public virtual SyntaxNode VisitXmlDeclaration(XmlDeclarationSyntax node);
    public virtual SyntaxNode VisitXmlDeclarationOption(XmlDeclarationOptionSyntax node);
    public virtual SyntaxNode VisitXmlElement(XmlElementSyntax node);
    public virtual SyntaxNode VisitXmlText(XmlTextSyntax node);
    public virtual SyntaxNode VisitXmlElementStartTag(XmlElementStartTagSyntax node);
    public virtual SyntaxNode VisitXmlElementEndTag(XmlElementEndTagSyntax node);
    public virtual SyntaxNode VisitXmlEmptyElement(XmlEmptyElementSyntax node);
    public virtual SyntaxNode VisitXmlAttribute(XmlAttributeSyntax node);
    public virtual SyntaxNode VisitXmlString(XmlStringSyntax node);
    public virtual SyntaxNode VisitXmlPrefixName(XmlPrefixNameSyntax node);
    public virtual SyntaxNode VisitXmlName(XmlNameSyntax node);
    public virtual SyntaxNode VisitXmlBracketedName(XmlBracketedNameSyntax node);
    public virtual SyntaxNode VisitXmlPrefix(XmlPrefixSyntax node);
    public virtual SyntaxNode VisitXmlComment(XmlCommentSyntax node);
    public virtual SyntaxNode VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node);
    public virtual SyntaxNode VisitXmlCDataSection(XmlCDataSectionSyntax node);
    public virtual SyntaxNode VisitXmlEmbeddedExpression(XmlEmbeddedExpressionSyntax node);
    public virtual SyntaxNode VisitArrayType(ArrayTypeSyntax node);
    public virtual SyntaxNode VisitNullableType(NullableTypeSyntax node);
    public virtual SyntaxNode VisitPredefinedType(PredefinedTypeSyntax node);
    public virtual SyntaxNode VisitIdentifierName(IdentifierNameSyntax node);
    public virtual SyntaxNode VisitGenericName(GenericNameSyntax node);
    public virtual SyntaxNode VisitQualifiedName(QualifiedNameSyntax node);
    public virtual SyntaxNode VisitGlobalName(GlobalNameSyntax node);
    public virtual SyntaxNode VisitTypeArgumentList(TypeArgumentListSyntax node);
    public virtual SyntaxNode VisitCrefReference(CrefReferenceSyntax node);
    public virtual SyntaxNode VisitCrefSignature(CrefSignatureSyntax node);
    public virtual SyntaxNode VisitCrefSignaturePart(CrefSignaturePartSyntax node);
    public virtual SyntaxNode VisitCrefOperatorReference(CrefOperatorReferenceSyntax node);
    public virtual SyntaxNode VisitQualifiedCrefOperatorReference(QualifiedCrefOperatorReferenceSyntax node);
    public virtual SyntaxNode VisitYieldStatement(YieldStatementSyntax node);
    public virtual SyntaxNode VisitAwaitExpression(AwaitExpressionSyntax node);
    public virtual SyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node);
    public virtual SyntaxNode VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node);
    public virtual SyntaxNode VisitXmlCrefAttribute(XmlCrefAttributeSyntax node);
    public virtual SyntaxNode VisitXmlNameAttribute(XmlNameAttributeSyntax node);
    public virtual SyntaxNode VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node);
    public virtual SyntaxNode VisitNameOfExpression(NameOfExpressionSyntax node);
    public virtual SyntaxNode VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node);
    public virtual SyntaxNode VisitInterpolatedStringText(InterpolatedStringTextSyntax node);
    public virtual SyntaxNode VisitInterpolation(InterpolationSyntax node);
    public virtual SyntaxNode VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node);
    public virtual SyntaxNode VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node);
    public virtual SyntaxNode VisitConstDirectiveTrivia(ConstDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitExternalSourceDirectiveTrivia(ExternalSourceDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitEndExternalSourceDirectiveTrivia(EndExternalSourceDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitExternalChecksumDirectiveTrivia(ExternalChecksumDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitEnableWarningDirectiveTrivia(EnableWarningDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitDisableWarningDirectiveTrivia(DisableWarningDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node);
    public virtual SyntaxNode VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree : SyntaxTree {
    private VisualBasicLineDirectiveMap _lineDirectiveMap;
    internal static VisualBasicSyntaxTree Dummy;
    internal static SyntaxReference DummyReference;
    private VisualBasicWarningStateMap _lazyWarningStateMap;
    private ConditionalSymbolsMap _lazySymbolsMap;
    public VisualBasicParseOptions Options { get; }
    internal bool IsMyTemplate { get; }
    internal bool HasReferenceDirectives { get; }
    protected ParseOptions OptionsCore { get; }
    private ConditionalSymbolsMap ConditionalSymbols { get; }
    private static VisualBasicSyntaxTree();
    public abstract virtual VisualBasicParseOptions get_Options();
    internal virtual bool get_IsMyTemplate();
    protected T CloneNodeAsRoot(T node);
    public abstract virtual VisualBasicSyntaxNode GetRoot(CancellationToken cancellationToken);
    public virtual Task`1<VisualBasicSyntaxNode> GetRootAsync(CancellationToken cancellationToken);
    public abstract virtual bool TryGetRoot(VisualBasicSyntaxNode& root);
    public CompilationUnitSyntax GetCompilationUnitRoot(CancellationToken cancellationToken);
    internal bool get_HasReferenceDirectives();
    public virtual SyntaxTree WithChangedText(SourceText newText);
    private SyntaxTree WithChanges(SourceText newText, TextChangeRange[] changes);
    public static SyntaxTree Create(VisualBasicSyntaxNode root, VisualBasicParseOptions options, string path, Encoding encoding);
    internal static SyntaxTree CreateWithoutClone(VisualBasicSyntaxNode root);
    public static SyntaxTree ParseText(string text, VisualBasicParseOptions options, string path, Encoding encoding, CancellationToken cancellationToken);
    internal static SyntaxTree ParseText(string text, bool isMyTemplate, VisualBasicParseOptions options, string path, Encoding encoding, CancellationToken cancellationToken);
    public static SyntaxTree ParseText(SourceText text, VisualBasicParseOptions options, string path, CancellationToken cancellationToken);
    internal static SyntaxTree ParseText(SourceText text, bool isMyTemplate, VisualBasicParseOptions options, string path, CancellationToken cancellationToken);
    public virtual IEnumerable`1<Diagnostic> GetDiagnostics(SyntaxNode node);
    public virtual IEnumerable`1<Diagnostic> GetDiagnostics(SyntaxToken token);
    public virtual IEnumerable`1<Diagnostic> GetDiagnostics(SyntaxTrivia trivia);
    public virtual IEnumerable`1<Diagnostic> GetDiagnostics(SyntaxNodeOrToken nodeOrToken);
    public virtual IEnumerable`1<Diagnostic> GetDiagnostics(CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree/VB$StateMachine_32_EnumerateDiagnostics")]
internal IEnumerable`1<Diagnostic> EnumerateDiagnostics(VisualBasicSyntaxNode node, int position, bool InDocumentationComment);
    internal IEnumerable`1<Diagnostic> GetDiagnostics(VisualBasicSyntaxNode node, int position, bool InDocumentationComment);
    private bool InDocumentationComment(SyntaxNode node);
    private bool InDocumentationComment(SyntaxNodeOrToken node);
    private bool InDocumentationComment(SyntaxToken token);
    private bool InDocumentationComment(SyntaxTrivia trivia);
    public virtual FileLinePositionSpan GetLineSpan(TextSpan span, CancellationToken cancellationToken);
    public virtual FileLinePositionSpan GetMappedLineSpan(TextSpan span, CancellationToken cancellationToken);
    public virtual LineVisibility GetLineVisibility(int position, CancellationToken cancellationToken);
    internal virtual FileLinePositionSpan GetMappedLineSpanAndVisibility(TextSpan span, Boolean& isHiddenPosition);
    public virtual bool HasHiddenRegions();
    internal ReportDiagnostic GetWarningState(string id, int position);
    private LinePosition GetLinePosition(int position);
    public virtual Location GetLocation(TextSpan span);
    public virtual bool IsEquivalentTo(SyntaxTree tree, bool topLevel);
    public virtual IList`1<TextSpan> GetChangedSpans(SyntaxTree oldTree);
    public virtual IList`1<TextChange> GetChanges(SyntaxTree oldTree);
    protected virtual SyntaxNode GetRootCore(CancellationToken CancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree/VB$StateMachine_51_GetRootAsyncCore")]
protected virtual Task`1<SyntaxNode> GetRootAsyncCore(CancellationToken cancellationToken);
    protected virtual bool TryGetRootCore(SyntaxNode& root);
    protected virtual ParseOptions get_OptionsCore();
    private ConditionalSymbolsMap get_ConditionalSymbols();
    internal bool IsAnyPreprocessorSymbolDefined(IEnumerable`1<string> conditionalSymbolNames, SyntaxNodeOrToken atNode);
    internal VisualBasicPreprocessingSymbolInfo GetPreprocessingSymbolInfo(IdentifierNameSyntax identifierNode);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor : object {
    public virtual void Visit(SyntaxNode node);
    public virtual void DefaultVisit(SyntaxNode node);
    public virtual void VisitEmptyStatement(EmptyStatementSyntax node);
    public virtual void VisitEndBlockStatement(EndBlockStatementSyntax node);
    public virtual void VisitCompilationUnit(CompilationUnitSyntax node);
    public virtual void VisitOptionStatement(OptionStatementSyntax node);
    public virtual void VisitImportsStatement(ImportsStatementSyntax node);
    public virtual void VisitSimpleImportsClause(SimpleImportsClauseSyntax node);
    public virtual void VisitImportAliasClause(ImportAliasClauseSyntax node);
    public virtual void VisitXmlNamespaceImportsClause(XmlNamespaceImportsClauseSyntax node);
    public virtual void VisitNamespaceBlock(NamespaceBlockSyntax node);
    public virtual void VisitNamespaceStatement(NamespaceStatementSyntax node);
    public virtual void VisitModuleBlock(ModuleBlockSyntax node);
    public virtual void VisitStructureBlock(StructureBlockSyntax node);
    public virtual void VisitInterfaceBlock(InterfaceBlockSyntax node);
    public virtual void VisitClassBlock(ClassBlockSyntax node);
    public virtual void VisitEnumBlock(EnumBlockSyntax node);
    public virtual void VisitInheritsStatement(InheritsStatementSyntax node);
    public virtual void VisitImplementsStatement(ImplementsStatementSyntax node);
    public virtual void VisitModuleStatement(ModuleStatementSyntax node);
    public virtual void VisitStructureStatement(StructureStatementSyntax node);
    public virtual void VisitInterfaceStatement(InterfaceStatementSyntax node);
    public virtual void VisitClassStatement(ClassStatementSyntax node);
    public virtual void VisitEnumStatement(EnumStatementSyntax node);
    public virtual void VisitTypeParameterList(TypeParameterListSyntax node);
    public virtual void VisitTypeParameter(TypeParameterSyntax node);
    public virtual void VisitTypeParameterSingleConstraintClause(TypeParameterSingleConstraintClauseSyntax node);
    public virtual void VisitTypeParameterMultipleConstraintClause(TypeParameterMultipleConstraintClauseSyntax node);
    public virtual void VisitSpecialConstraint(SpecialConstraintSyntax node);
    public virtual void VisitTypeConstraint(TypeConstraintSyntax node);
    public virtual void VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node);
    public virtual void VisitMethodBlock(MethodBlockSyntax node);
    public virtual void VisitConstructorBlock(ConstructorBlockSyntax node);
    public virtual void VisitOperatorBlock(OperatorBlockSyntax node);
    public virtual void VisitAccessorBlock(AccessorBlockSyntax node);
    public virtual void VisitPropertyBlock(PropertyBlockSyntax node);
    public virtual void VisitEventBlock(EventBlockSyntax node);
    public virtual void VisitParameterList(ParameterListSyntax node);
    public virtual void VisitMethodStatement(MethodStatementSyntax node);
    public virtual void VisitSubNewStatement(SubNewStatementSyntax node);
    public virtual void VisitDeclareStatement(DeclareStatementSyntax node);
    public virtual void VisitDelegateStatement(DelegateStatementSyntax node);
    public virtual void VisitEventStatement(EventStatementSyntax node);
    public virtual void VisitOperatorStatement(OperatorStatementSyntax node);
    public virtual void VisitPropertyStatement(PropertyStatementSyntax node);
    public virtual void VisitAccessorStatement(AccessorStatementSyntax node);
    public virtual void VisitImplementsClause(ImplementsClauseSyntax node);
    public virtual void VisitHandlesClause(HandlesClauseSyntax node);
    public virtual void VisitKeywordEventContainer(KeywordEventContainerSyntax node);
    public virtual void VisitWithEventsEventContainer(WithEventsEventContainerSyntax node);
    public virtual void VisitWithEventsPropertyEventContainer(WithEventsPropertyEventContainerSyntax node);
    public virtual void VisitHandlesClauseItem(HandlesClauseItemSyntax node);
    public virtual void VisitIncompleteMember(IncompleteMemberSyntax node);
    public virtual void VisitFieldDeclaration(FieldDeclarationSyntax node);
    public virtual void VisitVariableDeclarator(VariableDeclaratorSyntax node);
    public virtual void VisitSimpleAsClause(SimpleAsClauseSyntax node);
    public virtual void VisitAsNewClause(AsNewClauseSyntax node);
    public virtual void VisitObjectMemberInitializer(ObjectMemberInitializerSyntax node);
    public virtual void VisitObjectCollectionInitializer(ObjectCollectionInitializerSyntax node);
    public virtual void VisitInferredFieldInitializer(InferredFieldInitializerSyntax node);
    public virtual void VisitNamedFieldInitializer(NamedFieldInitializerSyntax node);
    public virtual void VisitEqualsValue(EqualsValueSyntax node);
    public virtual void VisitParameter(ParameterSyntax node);
    public virtual void VisitModifiedIdentifier(ModifiedIdentifierSyntax node);
    public virtual void VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node);
    public virtual void VisitAttributeList(AttributeListSyntax node);
    public virtual void VisitAttribute(AttributeSyntax node);
    public virtual void VisitAttributeTarget(AttributeTargetSyntax node);
    public virtual void VisitAttributesStatement(AttributesStatementSyntax node);
    public virtual void VisitExpressionStatement(ExpressionStatementSyntax node);
    public virtual void VisitPrintStatement(PrintStatementSyntax node);
    public virtual void VisitWhileBlock(WhileBlockSyntax node);
    public virtual void VisitUsingBlock(UsingBlockSyntax node);
    public virtual void VisitSyncLockBlock(SyncLockBlockSyntax node);
    public virtual void VisitWithBlock(WithBlockSyntax node);
    public virtual void VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node);
    public virtual void VisitLabelStatement(LabelStatementSyntax node);
    public virtual void VisitGoToStatement(GoToStatementSyntax node);
    public virtual void VisitLabel(LabelSyntax node);
    public virtual void VisitStopOrEndStatement(StopOrEndStatementSyntax node);
    public virtual void VisitExitStatement(ExitStatementSyntax node);
    public virtual void VisitContinueStatement(ContinueStatementSyntax node);
    public virtual void VisitReturnStatement(ReturnStatementSyntax node);
    public virtual void VisitSingleLineIfStatement(SingleLineIfStatementSyntax node);
    public virtual void VisitSingleLineElseClause(SingleLineElseClauseSyntax node);
    public virtual void VisitMultiLineIfBlock(MultiLineIfBlockSyntax node);
    public virtual void VisitIfStatement(IfStatementSyntax node);
    public virtual void VisitElseIfBlock(ElseIfBlockSyntax node);
    public virtual void VisitElseIfStatement(ElseIfStatementSyntax node);
    public virtual void VisitElseBlock(ElseBlockSyntax node);
    public virtual void VisitElseStatement(ElseStatementSyntax node);
    public virtual void VisitTryBlock(TryBlockSyntax node);
    public virtual void VisitTryStatement(TryStatementSyntax node);
    public virtual void VisitCatchBlock(CatchBlockSyntax node);
    public virtual void VisitCatchStatement(CatchStatementSyntax node);
    public virtual void VisitCatchFilterClause(CatchFilterClauseSyntax node);
    public virtual void VisitFinallyBlock(FinallyBlockSyntax node);
    public virtual void VisitFinallyStatement(FinallyStatementSyntax node);
    public virtual void VisitErrorStatement(ErrorStatementSyntax node);
    public virtual void VisitOnErrorGoToStatement(OnErrorGoToStatementSyntax node);
    public virtual void VisitOnErrorResumeNextStatement(OnErrorResumeNextStatementSyntax node);
    public virtual void VisitResumeStatement(ResumeStatementSyntax node);
    public virtual void VisitSelectBlock(SelectBlockSyntax node);
    public virtual void VisitSelectStatement(SelectStatementSyntax node);
    public virtual void VisitCaseBlock(CaseBlockSyntax node);
    public virtual void VisitCaseStatement(CaseStatementSyntax node);
    public virtual void VisitElseCaseClause(ElseCaseClauseSyntax node);
    public virtual void VisitSimpleCaseClause(SimpleCaseClauseSyntax node);
    public virtual void VisitRangeCaseClause(RangeCaseClauseSyntax node);
    public virtual void VisitRelationalCaseClause(RelationalCaseClauseSyntax node);
    public virtual void VisitSyncLockStatement(SyncLockStatementSyntax node);
    public virtual void VisitDoLoopBlock(DoLoopBlockSyntax node);
    public virtual void VisitDoStatement(DoStatementSyntax node);
    public virtual void VisitLoopStatement(LoopStatementSyntax node);
    public virtual void VisitWhileOrUntilClause(WhileOrUntilClauseSyntax node);
    public virtual void VisitWhileStatement(WhileStatementSyntax node);
    public virtual void VisitForBlock(ForBlockSyntax node);
    public virtual void VisitForEachBlock(ForEachBlockSyntax node);
    public virtual void VisitForStatement(ForStatementSyntax node);
    public virtual void VisitForStepClause(ForStepClauseSyntax node);
    public virtual void VisitForEachStatement(ForEachStatementSyntax node);
    public virtual void VisitNextStatement(NextStatementSyntax node);
    public virtual void VisitUsingStatement(UsingStatementSyntax node);
    public virtual void VisitThrowStatement(ThrowStatementSyntax node);
    public virtual void VisitAssignmentStatement(AssignmentStatementSyntax node);
    public virtual void VisitMidExpression(MidExpressionSyntax node);
    public virtual void VisitCallStatement(CallStatementSyntax node);
    public virtual void VisitAddRemoveHandlerStatement(AddRemoveHandlerStatementSyntax node);
    public virtual void VisitRaiseEventStatement(RaiseEventStatementSyntax node);
    public virtual void VisitWithStatement(WithStatementSyntax node);
    public virtual void VisitReDimStatement(ReDimStatementSyntax node);
    public virtual void VisitRedimClause(RedimClauseSyntax node);
    public virtual void VisitEraseStatement(EraseStatementSyntax node);
    public virtual void VisitLiteralExpression(LiteralExpressionSyntax node);
    public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node);
    public virtual void VisitMeExpression(MeExpressionSyntax node);
    public virtual void VisitMyBaseExpression(MyBaseExpressionSyntax node);
    public virtual void VisitMyClassExpression(MyClassExpressionSyntax node);
    public virtual void VisitGetTypeExpression(GetTypeExpressionSyntax node);
    public virtual void VisitTypeOfExpression(TypeOfExpressionSyntax node);
    public virtual void VisitGetXmlNamespaceExpression(GetXmlNamespaceExpressionSyntax node);
    public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node);
    public virtual void VisitXmlMemberAccessExpression(XmlMemberAccessExpressionSyntax node);
    public virtual void VisitInvocationExpression(InvocationExpressionSyntax node);
    public virtual void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node);
    public virtual void VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node);
    public virtual void VisitArrayCreationExpression(ArrayCreationExpressionSyntax node);
    public virtual void VisitCollectionInitializer(CollectionInitializerSyntax node);
    public virtual void VisitCTypeExpression(CTypeExpressionSyntax node);
    public virtual void VisitDirectCastExpression(DirectCastExpressionSyntax node);
    public virtual void VisitTryCastExpression(TryCastExpressionSyntax node);
    public virtual void VisitPredefinedCastExpression(PredefinedCastExpressionSyntax node);
    public virtual void VisitBinaryExpression(BinaryExpressionSyntax node);
    public virtual void VisitUnaryExpression(UnaryExpressionSyntax node);
    public virtual void VisitBinaryConditionalExpression(BinaryConditionalExpressionSyntax node);
    public virtual void VisitTernaryConditionalExpression(TernaryConditionalExpressionSyntax node);
    public virtual void VisitSingleLineLambdaExpression(SingleLineLambdaExpressionSyntax node);
    public virtual void VisitMultiLineLambdaExpression(MultiLineLambdaExpressionSyntax node);
    public virtual void VisitLambdaHeader(LambdaHeaderSyntax node);
    public virtual void VisitArgumentList(ArgumentListSyntax node);
    public virtual void VisitOmittedArgument(OmittedArgumentSyntax node);
    public virtual void VisitSimpleArgument(SimpleArgumentSyntax node);
    public virtual void VisitNameColonEquals(NameColonEqualsSyntax node);
    public virtual void VisitRangeArgument(RangeArgumentSyntax node);
    public virtual void VisitQueryExpression(QueryExpressionSyntax node);
    public virtual void VisitCollectionRangeVariable(CollectionRangeVariableSyntax node);
    public virtual void VisitExpressionRangeVariable(ExpressionRangeVariableSyntax node);
    public virtual void VisitAggregationRangeVariable(AggregationRangeVariableSyntax node);
    public virtual void VisitVariableNameEquals(VariableNameEqualsSyntax node);
    public virtual void VisitFunctionAggregation(FunctionAggregationSyntax node);
    public virtual void VisitGroupAggregation(GroupAggregationSyntax node);
    public virtual void VisitFromClause(FromClauseSyntax node);
    public virtual void VisitLetClause(LetClauseSyntax node);
    public virtual void VisitAggregateClause(AggregateClauseSyntax node);
    public virtual void VisitDistinctClause(DistinctClauseSyntax node);
    public virtual void VisitWhereClause(WhereClauseSyntax node);
    public virtual void VisitPartitionWhileClause(PartitionWhileClauseSyntax node);
    public virtual void VisitPartitionClause(PartitionClauseSyntax node);
    public virtual void VisitGroupByClause(GroupByClauseSyntax node);
    public virtual void VisitJoinCondition(JoinConditionSyntax node);
    public virtual void VisitSimpleJoinClause(SimpleJoinClauseSyntax node);
    public virtual void VisitGroupJoinClause(GroupJoinClauseSyntax node);
    public virtual void VisitOrderByClause(OrderByClauseSyntax node);
    public virtual void VisitOrdering(OrderingSyntax node);
    public virtual void VisitSelectClause(SelectClauseSyntax node);
    public virtual void VisitXmlDocument(XmlDocumentSyntax node);
    public virtual void VisitXmlDeclaration(XmlDeclarationSyntax node);
    public virtual void VisitXmlDeclarationOption(XmlDeclarationOptionSyntax node);
    public virtual void VisitXmlElement(XmlElementSyntax node);
    public virtual void VisitXmlText(XmlTextSyntax node);
    public virtual void VisitXmlElementStartTag(XmlElementStartTagSyntax node);
    public virtual void VisitXmlElementEndTag(XmlElementEndTagSyntax node);
    public virtual void VisitXmlEmptyElement(XmlEmptyElementSyntax node);
    public virtual void VisitXmlAttribute(XmlAttributeSyntax node);
    public virtual void VisitXmlString(XmlStringSyntax node);
    public virtual void VisitXmlPrefixName(XmlPrefixNameSyntax node);
    public virtual void VisitXmlName(XmlNameSyntax node);
    public virtual void VisitXmlBracketedName(XmlBracketedNameSyntax node);
    public virtual void VisitXmlPrefix(XmlPrefixSyntax node);
    public virtual void VisitXmlComment(XmlCommentSyntax node);
    public virtual void VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node);
    public virtual void VisitXmlCDataSection(XmlCDataSectionSyntax node);
    public virtual void VisitXmlEmbeddedExpression(XmlEmbeddedExpressionSyntax node);
    public virtual void VisitArrayType(ArrayTypeSyntax node);
    public virtual void VisitNullableType(NullableTypeSyntax node);
    public virtual void VisitPredefinedType(PredefinedTypeSyntax node);
    public virtual void VisitIdentifierName(IdentifierNameSyntax node);
    public virtual void VisitGenericName(GenericNameSyntax node);
    public virtual void VisitQualifiedName(QualifiedNameSyntax node);
    public virtual void VisitGlobalName(GlobalNameSyntax node);
    public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node);
    public virtual void VisitCrefReference(CrefReferenceSyntax node);
    public virtual void VisitCrefSignature(CrefSignatureSyntax node);
    public virtual void VisitCrefSignaturePart(CrefSignaturePartSyntax node);
    public virtual void VisitCrefOperatorReference(CrefOperatorReferenceSyntax node);
    public virtual void VisitQualifiedCrefOperatorReference(QualifiedCrefOperatorReferenceSyntax node);
    public virtual void VisitYieldStatement(YieldStatementSyntax node);
    public virtual void VisitAwaitExpression(AwaitExpressionSyntax node);
    public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node);
    public virtual void VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node);
    public virtual void VisitXmlCrefAttribute(XmlCrefAttributeSyntax node);
    public virtual void VisitXmlNameAttribute(XmlNameAttributeSyntax node);
    public virtual void VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node);
    public virtual void VisitNameOfExpression(NameOfExpressionSyntax node);
    public virtual void VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node);
    public virtual void VisitInterpolatedStringText(InterpolatedStringTextSyntax node);
    public virtual void VisitInterpolation(InterpolationSyntax node);
    public virtual void VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node);
    public virtual void VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node);
    public virtual void VisitConstDirectiveTrivia(ConstDirectiveTriviaSyntax node);
    public virtual void VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node);
    public virtual void VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node);
    public virtual void VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node);
    public virtual void VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node);
    public virtual void VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node);
    public virtual void VisitExternalSourceDirectiveTrivia(ExternalSourceDirectiveTriviaSyntax node);
    public virtual void VisitEndExternalSourceDirectiveTrivia(EndExternalSourceDirectiveTriviaSyntax node);
    public virtual void VisitExternalChecksumDirectiveTrivia(ExternalChecksumDirectiveTriviaSyntax node);
    public virtual void VisitEnableWarningDirectiveTrivia(EnableWarningDirectiveTriviaSyntax node);
    public virtual void VisitDisableWarningDirectiveTrivia(DisableWarningDirectiveTriviaSyntax node);
    public virtual void VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node);
    public virtual void VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxVisitor`1 : object {
    public virtual TResult Visit(SyntaxNode node);
    public virtual TResult DefaultVisit(SyntaxNode node);
    public virtual TResult VisitEmptyStatement(EmptyStatementSyntax node);
    public virtual TResult VisitEndBlockStatement(EndBlockStatementSyntax node);
    public virtual TResult VisitCompilationUnit(CompilationUnitSyntax node);
    public virtual TResult VisitOptionStatement(OptionStatementSyntax node);
    public virtual TResult VisitImportsStatement(ImportsStatementSyntax node);
    public virtual TResult VisitSimpleImportsClause(SimpleImportsClauseSyntax node);
    public virtual TResult VisitImportAliasClause(ImportAliasClauseSyntax node);
    public virtual TResult VisitXmlNamespaceImportsClause(XmlNamespaceImportsClauseSyntax node);
    public virtual TResult VisitNamespaceBlock(NamespaceBlockSyntax node);
    public virtual TResult VisitNamespaceStatement(NamespaceStatementSyntax node);
    public virtual TResult VisitModuleBlock(ModuleBlockSyntax node);
    public virtual TResult VisitStructureBlock(StructureBlockSyntax node);
    public virtual TResult VisitInterfaceBlock(InterfaceBlockSyntax node);
    public virtual TResult VisitClassBlock(ClassBlockSyntax node);
    public virtual TResult VisitEnumBlock(EnumBlockSyntax node);
    public virtual TResult VisitInheritsStatement(InheritsStatementSyntax node);
    public virtual TResult VisitImplementsStatement(ImplementsStatementSyntax node);
    public virtual TResult VisitModuleStatement(ModuleStatementSyntax node);
    public virtual TResult VisitStructureStatement(StructureStatementSyntax node);
    public virtual TResult VisitInterfaceStatement(InterfaceStatementSyntax node);
    public virtual TResult VisitClassStatement(ClassStatementSyntax node);
    public virtual TResult VisitEnumStatement(EnumStatementSyntax node);
    public virtual TResult VisitTypeParameterList(TypeParameterListSyntax node);
    public virtual TResult VisitTypeParameter(TypeParameterSyntax node);
    public virtual TResult VisitTypeParameterSingleConstraintClause(TypeParameterSingleConstraintClauseSyntax node);
    public virtual TResult VisitTypeParameterMultipleConstraintClause(TypeParameterMultipleConstraintClauseSyntax node);
    public virtual TResult VisitSpecialConstraint(SpecialConstraintSyntax node);
    public virtual TResult VisitTypeConstraint(TypeConstraintSyntax node);
    public virtual TResult VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node);
    public virtual TResult VisitMethodBlock(MethodBlockSyntax node);
    public virtual TResult VisitConstructorBlock(ConstructorBlockSyntax node);
    public virtual TResult VisitOperatorBlock(OperatorBlockSyntax node);
    public virtual TResult VisitAccessorBlock(AccessorBlockSyntax node);
    public virtual TResult VisitPropertyBlock(PropertyBlockSyntax node);
    public virtual TResult VisitEventBlock(EventBlockSyntax node);
    public virtual TResult VisitParameterList(ParameterListSyntax node);
    public virtual TResult VisitMethodStatement(MethodStatementSyntax node);
    public virtual TResult VisitSubNewStatement(SubNewStatementSyntax node);
    public virtual TResult VisitDeclareStatement(DeclareStatementSyntax node);
    public virtual TResult VisitDelegateStatement(DelegateStatementSyntax node);
    public virtual TResult VisitEventStatement(EventStatementSyntax node);
    public virtual TResult VisitOperatorStatement(OperatorStatementSyntax node);
    public virtual TResult VisitPropertyStatement(PropertyStatementSyntax node);
    public virtual TResult VisitAccessorStatement(AccessorStatementSyntax node);
    public virtual TResult VisitImplementsClause(ImplementsClauseSyntax node);
    public virtual TResult VisitHandlesClause(HandlesClauseSyntax node);
    public virtual TResult VisitKeywordEventContainer(KeywordEventContainerSyntax node);
    public virtual TResult VisitWithEventsEventContainer(WithEventsEventContainerSyntax node);
    public virtual TResult VisitWithEventsPropertyEventContainer(WithEventsPropertyEventContainerSyntax node);
    public virtual TResult VisitHandlesClauseItem(HandlesClauseItemSyntax node);
    public virtual TResult VisitIncompleteMember(IncompleteMemberSyntax node);
    public virtual TResult VisitFieldDeclaration(FieldDeclarationSyntax node);
    public virtual TResult VisitVariableDeclarator(VariableDeclaratorSyntax node);
    public virtual TResult VisitSimpleAsClause(SimpleAsClauseSyntax node);
    public virtual TResult VisitAsNewClause(AsNewClauseSyntax node);
    public virtual TResult VisitObjectMemberInitializer(ObjectMemberInitializerSyntax node);
    public virtual TResult VisitObjectCollectionInitializer(ObjectCollectionInitializerSyntax node);
    public virtual TResult VisitInferredFieldInitializer(InferredFieldInitializerSyntax node);
    public virtual TResult VisitNamedFieldInitializer(NamedFieldInitializerSyntax node);
    public virtual TResult VisitEqualsValue(EqualsValueSyntax node);
    public virtual TResult VisitParameter(ParameterSyntax node);
    public virtual TResult VisitModifiedIdentifier(ModifiedIdentifierSyntax node);
    public virtual TResult VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node);
    public virtual TResult VisitAttributeList(AttributeListSyntax node);
    public virtual TResult VisitAttribute(AttributeSyntax node);
    public virtual TResult VisitAttributeTarget(AttributeTargetSyntax node);
    public virtual TResult VisitAttributesStatement(AttributesStatementSyntax node);
    public virtual TResult VisitExpressionStatement(ExpressionStatementSyntax node);
    public virtual TResult VisitPrintStatement(PrintStatementSyntax node);
    public virtual TResult VisitWhileBlock(WhileBlockSyntax node);
    public virtual TResult VisitUsingBlock(UsingBlockSyntax node);
    public virtual TResult VisitSyncLockBlock(SyncLockBlockSyntax node);
    public virtual TResult VisitWithBlock(WithBlockSyntax node);
    public virtual TResult VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node);
    public virtual TResult VisitLabelStatement(LabelStatementSyntax node);
    public virtual TResult VisitGoToStatement(GoToStatementSyntax node);
    public virtual TResult VisitLabel(LabelSyntax node);
    public virtual TResult VisitStopOrEndStatement(StopOrEndStatementSyntax node);
    public virtual TResult VisitExitStatement(ExitStatementSyntax node);
    public virtual TResult VisitContinueStatement(ContinueStatementSyntax node);
    public virtual TResult VisitReturnStatement(ReturnStatementSyntax node);
    public virtual TResult VisitSingleLineIfStatement(SingleLineIfStatementSyntax node);
    public virtual TResult VisitSingleLineElseClause(SingleLineElseClauseSyntax node);
    public virtual TResult VisitMultiLineIfBlock(MultiLineIfBlockSyntax node);
    public virtual TResult VisitIfStatement(IfStatementSyntax node);
    public virtual TResult VisitElseIfBlock(ElseIfBlockSyntax node);
    public virtual TResult VisitElseIfStatement(ElseIfStatementSyntax node);
    public virtual TResult VisitElseBlock(ElseBlockSyntax node);
    public virtual TResult VisitElseStatement(ElseStatementSyntax node);
    public virtual TResult VisitTryBlock(TryBlockSyntax node);
    public virtual TResult VisitTryStatement(TryStatementSyntax node);
    public virtual TResult VisitCatchBlock(CatchBlockSyntax node);
    public virtual TResult VisitCatchStatement(CatchStatementSyntax node);
    public virtual TResult VisitCatchFilterClause(CatchFilterClauseSyntax node);
    public virtual TResult VisitFinallyBlock(FinallyBlockSyntax node);
    public virtual TResult VisitFinallyStatement(FinallyStatementSyntax node);
    public virtual TResult VisitErrorStatement(ErrorStatementSyntax node);
    public virtual TResult VisitOnErrorGoToStatement(OnErrorGoToStatementSyntax node);
    public virtual TResult VisitOnErrorResumeNextStatement(OnErrorResumeNextStatementSyntax node);
    public virtual TResult VisitResumeStatement(ResumeStatementSyntax node);
    public virtual TResult VisitSelectBlock(SelectBlockSyntax node);
    public virtual TResult VisitSelectStatement(SelectStatementSyntax node);
    public virtual TResult VisitCaseBlock(CaseBlockSyntax node);
    public virtual TResult VisitCaseStatement(CaseStatementSyntax node);
    public virtual TResult VisitElseCaseClause(ElseCaseClauseSyntax node);
    public virtual TResult VisitSimpleCaseClause(SimpleCaseClauseSyntax node);
    public virtual TResult VisitRangeCaseClause(RangeCaseClauseSyntax node);
    public virtual TResult VisitRelationalCaseClause(RelationalCaseClauseSyntax node);
    public virtual TResult VisitSyncLockStatement(SyncLockStatementSyntax node);
    public virtual TResult VisitDoLoopBlock(DoLoopBlockSyntax node);
    public virtual TResult VisitDoStatement(DoStatementSyntax node);
    public virtual TResult VisitLoopStatement(LoopStatementSyntax node);
    public virtual TResult VisitWhileOrUntilClause(WhileOrUntilClauseSyntax node);
    public virtual TResult VisitWhileStatement(WhileStatementSyntax node);
    public virtual TResult VisitForBlock(ForBlockSyntax node);
    public virtual TResult VisitForEachBlock(ForEachBlockSyntax node);
    public virtual TResult VisitForStatement(ForStatementSyntax node);
    public virtual TResult VisitForStepClause(ForStepClauseSyntax node);
    public virtual TResult VisitForEachStatement(ForEachStatementSyntax node);
    public virtual TResult VisitNextStatement(NextStatementSyntax node);
    public virtual TResult VisitUsingStatement(UsingStatementSyntax node);
    public virtual TResult VisitThrowStatement(ThrowStatementSyntax node);
    public virtual TResult VisitAssignmentStatement(AssignmentStatementSyntax node);
    public virtual TResult VisitMidExpression(MidExpressionSyntax node);
    public virtual TResult VisitCallStatement(CallStatementSyntax node);
    public virtual TResult VisitAddRemoveHandlerStatement(AddRemoveHandlerStatementSyntax node);
    public virtual TResult VisitRaiseEventStatement(RaiseEventStatementSyntax node);
    public virtual TResult VisitWithStatement(WithStatementSyntax node);
    public virtual TResult VisitReDimStatement(ReDimStatementSyntax node);
    public virtual TResult VisitRedimClause(RedimClauseSyntax node);
    public virtual TResult VisitEraseStatement(EraseStatementSyntax node);
    public virtual TResult VisitLiteralExpression(LiteralExpressionSyntax node);
    public virtual TResult VisitParenthesizedExpression(ParenthesizedExpressionSyntax node);
    public virtual TResult VisitMeExpression(MeExpressionSyntax node);
    public virtual TResult VisitMyBaseExpression(MyBaseExpressionSyntax node);
    public virtual TResult VisitMyClassExpression(MyClassExpressionSyntax node);
    public virtual TResult VisitGetTypeExpression(GetTypeExpressionSyntax node);
    public virtual TResult VisitTypeOfExpression(TypeOfExpressionSyntax node);
    public virtual TResult VisitGetXmlNamespaceExpression(GetXmlNamespaceExpressionSyntax node);
    public virtual TResult VisitMemberAccessExpression(MemberAccessExpressionSyntax node);
    public virtual TResult VisitXmlMemberAccessExpression(XmlMemberAccessExpressionSyntax node);
    public virtual TResult VisitInvocationExpression(InvocationExpressionSyntax node);
    public virtual TResult VisitObjectCreationExpression(ObjectCreationExpressionSyntax node);
    public virtual TResult VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node);
    public virtual TResult VisitArrayCreationExpression(ArrayCreationExpressionSyntax node);
    public virtual TResult VisitCollectionInitializer(CollectionInitializerSyntax node);
    public virtual TResult VisitCTypeExpression(CTypeExpressionSyntax node);
    public virtual TResult VisitDirectCastExpression(DirectCastExpressionSyntax node);
    public virtual TResult VisitTryCastExpression(TryCastExpressionSyntax node);
    public virtual TResult VisitPredefinedCastExpression(PredefinedCastExpressionSyntax node);
    public virtual TResult VisitBinaryExpression(BinaryExpressionSyntax node);
    public virtual TResult VisitUnaryExpression(UnaryExpressionSyntax node);
    public virtual TResult VisitBinaryConditionalExpression(BinaryConditionalExpressionSyntax node);
    public virtual TResult VisitTernaryConditionalExpression(TernaryConditionalExpressionSyntax node);
    public virtual TResult VisitSingleLineLambdaExpression(SingleLineLambdaExpressionSyntax node);
    public virtual TResult VisitMultiLineLambdaExpression(MultiLineLambdaExpressionSyntax node);
    public virtual TResult VisitLambdaHeader(LambdaHeaderSyntax node);
    public virtual TResult VisitArgumentList(ArgumentListSyntax node);
    public virtual TResult VisitOmittedArgument(OmittedArgumentSyntax node);
    public virtual TResult VisitSimpleArgument(SimpleArgumentSyntax node);
    public virtual TResult VisitNameColonEquals(NameColonEqualsSyntax node);
    public virtual TResult VisitRangeArgument(RangeArgumentSyntax node);
    public virtual TResult VisitQueryExpression(QueryExpressionSyntax node);
    public virtual TResult VisitCollectionRangeVariable(CollectionRangeVariableSyntax node);
    public virtual TResult VisitExpressionRangeVariable(ExpressionRangeVariableSyntax node);
    public virtual TResult VisitAggregationRangeVariable(AggregationRangeVariableSyntax node);
    public virtual TResult VisitVariableNameEquals(VariableNameEqualsSyntax node);
    public virtual TResult VisitFunctionAggregation(FunctionAggregationSyntax node);
    public virtual TResult VisitGroupAggregation(GroupAggregationSyntax node);
    public virtual TResult VisitFromClause(FromClauseSyntax node);
    public virtual TResult VisitLetClause(LetClauseSyntax node);
    public virtual TResult VisitAggregateClause(AggregateClauseSyntax node);
    public virtual TResult VisitDistinctClause(DistinctClauseSyntax node);
    public virtual TResult VisitWhereClause(WhereClauseSyntax node);
    public virtual TResult VisitPartitionWhileClause(PartitionWhileClauseSyntax node);
    public virtual TResult VisitPartitionClause(PartitionClauseSyntax node);
    public virtual TResult VisitGroupByClause(GroupByClauseSyntax node);
    public virtual TResult VisitJoinCondition(JoinConditionSyntax node);
    public virtual TResult VisitSimpleJoinClause(SimpleJoinClauseSyntax node);
    public virtual TResult VisitGroupJoinClause(GroupJoinClauseSyntax node);
    public virtual TResult VisitOrderByClause(OrderByClauseSyntax node);
    public virtual TResult VisitOrdering(OrderingSyntax node);
    public virtual TResult VisitSelectClause(SelectClauseSyntax node);
    public virtual TResult VisitXmlDocument(XmlDocumentSyntax node);
    public virtual TResult VisitXmlDeclaration(XmlDeclarationSyntax node);
    public virtual TResult VisitXmlDeclarationOption(XmlDeclarationOptionSyntax node);
    public virtual TResult VisitXmlElement(XmlElementSyntax node);
    public virtual TResult VisitXmlText(XmlTextSyntax node);
    public virtual TResult VisitXmlElementStartTag(XmlElementStartTagSyntax node);
    public virtual TResult VisitXmlElementEndTag(XmlElementEndTagSyntax node);
    public virtual TResult VisitXmlEmptyElement(XmlEmptyElementSyntax node);
    public virtual TResult VisitXmlAttribute(XmlAttributeSyntax node);
    public virtual TResult VisitXmlString(XmlStringSyntax node);
    public virtual TResult VisitXmlPrefixName(XmlPrefixNameSyntax node);
    public virtual TResult VisitXmlName(XmlNameSyntax node);
    public virtual TResult VisitXmlBracketedName(XmlBracketedNameSyntax node);
    public virtual TResult VisitXmlPrefix(XmlPrefixSyntax node);
    public virtual TResult VisitXmlComment(XmlCommentSyntax node);
    public virtual TResult VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node);
    public virtual TResult VisitXmlCDataSection(XmlCDataSectionSyntax node);
    public virtual TResult VisitXmlEmbeddedExpression(XmlEmbeddedExpressionSyntax node);
    public virtual TResult VisitArrayType(ArrayTypeSyntax node);
    public virtual TResult VisitNullableType(NullableTypeSyntax node);
    public virtual TResult VisitPredefinedType(PredefinedTypeSyntax node);
    public virtual TResult VisitIdentifierName(IdentifierNameSyntax node);
    public virtual TResult VisitGenericName(GenericNameSyntax node);
    public virtual TResult VisitQualifiedName(QualifiedNameSyntax node);
    public virtual TResult VisitGlobalName(GlobalNameSyntax node);
    public virtual TResult VisitTypeArgumentList(TypeArgumentListSyntax node);
    public virtual TResult VisitCrefReference(CrefReferenceSyntax node);
    public virtual TResult VisitCrefSignature(CrefSignatureSyntax node);
    public virtual TResult VisitCrefSignaturePart(CrefSignaturePartSyntax node);
    public virtual TResult VisitCrefOperatorReference(CrefOperatorReferenceSyntax node);
    public virtual TResult VisitQualifiedCrefOperatorReference(QualifiedCrefOperatorReferenceSyntax node);
    public virtual TResult VisitYieldStatement(YieldStatementSyntax node);
    public virtual TResult VisitAwaitExpression(AwaitExpressionSyntax node);
    public virtual TResult VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node);
    public virtual TResult VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node);
    public virtual TResult VisitXmlCrefAttribute(XmlCrefAttributeSyntax node);
    public virtual TResult VisitXmlNameAttribute(XmlNameAttributeSyntax node);
    public virtual TResult VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node);
    public virtual TResult VisitNameOfExpression(NameOfExpressionSyntax node);
    public virtual TResult VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node);
    public virtual TResult VisitInterpolatedStringText(InterpolatedStringTextSyntax node);
    public virtual TResult VisitInterpolation(InterpolationSyntax node);
    public virtual TResult VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node);
    public virtual TResult VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node);
    public virtual TResult VisitConstDirectiveTrivia(ConstDirectiveTriviaSyntax node);
    public virtual TResult VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node);
    public virtual TResult VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node);
    public virtual TResult VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node);
    public virtual TResult VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node);
    public virtual TResult VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node);
    public virtual TResult VisitExternalSourceDirectiveTrivia(ExternalSourceDirectiveTriviaSyntax node);
    public virtual TResult VisitEndExternalSourceDirectiveTrivia(EndExternalSourceDirectiveTriviaSyntax node);
    public virtual TResult VisitExternalChecksumDirectiveTrivia(ExternalChecksumDirectiveTriviaSyntax node);
    public virtual TResult VisitEnableWarningDirectiveTrivia(EnableWarningDirectiveTriviaSyntax node);
    public virtual TResult VisitDisableWarningDirectiveTrivia(DisableWarningDirectiveTriviaSyntax node);
    public virtual TResult VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node);
    public virtual TResult VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node);
}
public abstract class Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxWalker : VisualBasicSyntaxVisitor {
    [CompilerGeneratedAttribute]
private SyntaxWalkerDepth _Depth;
    private int _recursionDepth;
    protected SyntaxWalkerDepth Depth { get; }
    protected VisualBasicSyntaxWalker(SyntaxWalkerDepth depth);
    [CompilerGeneratedAttribute]
protected SyntaxWalkerDepth get_Depth();
    public virtual void Visit(SyntaxNode node);
    public virtual void DefaultVisit(SyntaxNode node);
    public virtual void VisitToken(SyntaxToken token);
    public virtual void VisitLeadingTrivia(SyntaxToken token);
    public virtual void VisitTrailingTrivia(SyntaxToken token);
    public virtual void VisitTrivia(SyntaxTrivia trivia);
}
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicTypeInfo : ValueType {
    private TypeSymbol _type;
    private TypeSymbol _convertedType;
    private Conversion _implicitConversion;
    internal static VisualBasicTypeInfo None;
    public TypeSymbol Type { get; }
    public TypeSymbol ConvertedType { get; }
    public Conversion ImplicitConversion { get; }
    private static VisualBasicTypeInfo();
    internal VisualBasicTypeInfo(TypeSymbol type, TypeSymbol convertedType, Conversion implicitConversion);
    public TypeSymbol get_Type();
    public TypeSymbol get_ConvertedType();
    public Conversion get_ImplicitConversion();
    public static TypeInfo op_Implicit(VisualBasicTypeInfo info);
    public sealed virtual override bool Equals(VisualBasicTypeInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static TypeSymbol GetPossibleGuessForErrorType(TypeSymbol type);
}
internal class Microsoft.CodeAnalysis.VisualBasic.WithBlockBinder : BlockBaseBinder {
    private WithBlockSyntax _withBlockSyntax;
    private WithBlockInfo _withBlockInfo;
    private ExpressionSyntax Expression { get; }
    internal WithBlockInfo Info { get; }
    internal bool ExpressionIsAccessedFromNestedLambda { get; }
    internal BoundValuePlaceholderBase ExpressionPlaceholder { get; }
    internal ImmutableArray`1<BoundExpression> DraftInitializers { get; }
    internal BoundExpression DraftPlaceholderSubstitute { get; }
    internal ImmutableArray`1<LocalSymbol> Locals { get; }
    public WithBlockBinder(Binder enclosing, WithBlockSyntax syntax);
    private ExpressionSyntax get_Expression();
    internal WithBlockInfo get_Info();
    internal bool get_ExpressionIsAccessedFromNestedLambda();
    internal BoundValuePlaceholderBase get_ExpressionPlaceholder();
    internal ImmutableArray`1<BoundExpression> get_DraftInitializers();
    internal BoundExpression get_DraftPlaceholderSubstitute();
    internal virtual BoundExpression GetWithStatementPlaceholderSubstitute(BoundValuePlaceholderBase placeholder);
    private void EnsureExpressionAndPlaceholder();
    protected virtual BoundStatement CreateBoundWithBlock(WithBlockSyntax node, Binder boundBlockBinder, DiagnosticBag diagnostics);
    [ConditionalAttribute("DEBUG")]
private void AssertExpressionIsNotFromStatementExpression(VisualBasicSyntaxNode node);
    private void PrepareBindingOfOmittedLeft(VisualBasicSyntaxNode node, DiagnosticBag diagnostics, Binder accessingBinder);
    protected internal virtual BoundExpression TryBindOmittedLeftForMemberAccess(MemberAccessExpressionSyntax node, DiagnosticBag diagnostics, Binder accessingBinder, Boolean& wholeMemberAccessExpressionBound);
    protected virtual BoundExpression TryBindOmittedLeftForDictionaryAccess(MemberAccessExpressionSyntax node, Binder accessingBinder, DiagnosticBag diagnostics);
    protected virtual BoundExpression TryBindOmittedLeftForConditionalAccess(ConditionalAccessExpressionSyntax node, Binder accessingBinder, DiagnosticBag diagnostics);
    protected internal virtual BoundExpression TryBindOmittedLeftForXmlMemberAccess(XmlMemberAccessExpressionSyntax node, DiagnosticBag diagnostics, Binder accessingBinder);
    internal virtual ImmutableArray`1<LocalSymbol> get_Locals();
}
internal class Microsoft.CodeAnalysis.VisualBasic.WithExpressionRewriter : object {
    private WithStatementSyntax _withSyntax;
    internal WithExpressionRewriter(WithStatementSyntax withSyntax);
    private BoundLocal CaptureInATemp(BoundExpression value, State state);
    private BoundExpression CaptureInAByRefTemp(BoundExpression value, State state);
    private BoundExpression CaptureArrayAccess(BoundArrayAccess value, State state);
    private BoundExpression CaptureRValue(BoundExpression value, State state);
    private BoundExpression CaptureFieldAccess(BoundFieldAccess value, State state);
    private BoundExpression CaptureReceiver(BoundExpression value, State state);
    private BoundExpression CaptureExpression(BoundExpression value, State state);
    public Result AnalyzeWithExpression(Symbol containingMember, BoundExpression value, bool doNotUseByRefLocal, Binder binder, bool preserveIdentityOfLValues);
    private BoundExpression CaptureWithExpression(BoundExpression value, State state);
}
internal class Microsoft.CodeAnalysis.VisualBasic.XmlElementBinder : Binder {
    private Dictionary`2<string, string> _namespaces;
    public XmlElementBinder(Binder containingBinder, Dictionary`2<string, string> namespaces);
    internal virtual bool LookupXmlNamespace(string prefix, bool ignoreXmlNodes, String& namespace, Boolean& fromImports);
    internal virtual void GetInScopeXmlNamespaces(ArrayBuilder`1<KeyValuePair`2<string, string>> builder);
}
internal class Microsoft.CodeAnalysis.VisualBasic.XmlEmbeddedExpressionBinder : Binder {
    public XmlEmbeddedExpressionBinder(Binder containingBinder);
    internal virtual bool LookupXmlNamespace(string prefix, bool ignoreXmlNodes, String& namespace, Boolean& fromImports);
    internal virtual void GetInScopeXmlNamespaces(ArrayBuilder`1<KeyValuePair`2<string, string>> builder);
}
internal class Microsoft.CodeAnalysis.VisualBasic.XmlNamespaceAndImportsClausePosition : ValueType {
    public string XmlNamespace;
    public int ImportsClausePosition;
    public XmlNamespaceAndImportsClausePosition(string xmlNamespace, int importsClausePosition);
}
internal class Microsoft.CodeAnalysis.VisualBasic.XmlNamespaceImportsBinder : Binder {
    private IReadOnlyDictionary`2<string, XmlNamespaceAndImportsClausePosition> _namespaces;
    internal bool HasImportedXmlNamespaces { get; }
    public XmlNamespaceImportsBinder(Binder containingBinder, IReadOnlyDictionary`2<string, XmlNamespaceAndImportsClausePosition> namespaces);
    internal virtual bool get_HasImportedXmlNamespaces();
    internal virtual bool LookupXmlNamespace(string prefix, bool ignoreXmlNodes, String& namespace, Boolean& fromImports);
}
internal class Microsoft.CodeAnalysis.VisualBasic.XmlRootElementBinder : Binder {
    public XmlRootElementBinder(Binder containingBinder);
    internal virtual void GetInScopeXmlNamespaces(ArrayBuilder`1<KeyValuePair`2<string, string>> builder);
}
[ExtensionAttribute]
[StandardModuleAttribute]
public class Microsoft.CodeAnalysis.VisualBasicExtensions : object {
    [ExtensionAttribute]
public static bool IsKind(SyntaxTrivia trivia, SyntaxKind kind);
    [ExtensionAttribute]
public static bool IsKind(SyntaxToken token, SyntaxKind kind);
    [ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind);
    [ExtensionAttribute]
public static bool IsKind(SyntaxNodeOrToken nodeOrToken, SyntaxKind kind);
    [ExtensionAttribute]
public static int IndexOf(SyntaxList`1<TNode> list, SyntaxKind kind);
    [ExtensionAttribute]
public static bool Any(SyntaxList`1<TNode> list, SyntaxKind kind);
    [ExtensionAttribute]
public static int IndexOf(SeparatedSyntaxList`1<TNode> list, SyntaxKind kind);
    [ExtensionAttribute]
public static bool Any(SeparatedSyntaxList`1<TNode> list, SyntaxKind kind);
    [ExtensionAttribute]
public static int IndexOf(SyntaxTriviaList list, SyntaxKind kind);
    [ExtensionAttribute]
public static bool Any(SyntaxTriviaList list, SyntaxKind kind);
    [ExtensionAttribute]
public static int IndexOf(SyntaxTokenList list, SyntaxKind kind);
    [ExtensionAttribute]
public static bool Any(SyntaxTokenList list, SyntaxKind kind);
    [ExtensionAttribute]
internal static SyntaxToken FirstOrDefault(SyntaxTokenList list, SyntaxKind kind);
    [ExtensionAttribute]
internal static SyntaxToken First(SyntaxTokenList list, SyntaxKind kind);
}
[Embedded]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[EditorBrowsableAttribute("1")]
internal class Microsoft.VisualBasic.CompilerServices.Conversions : object {
    private static object GetEnumValue(object Value);
    public static bool ToBoolean(string Value);
    public static bool ToBoolean(object Value);
    public static byte ToByte(string Value);
    public static byte ToByte(object Value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string Value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object Value);
    public static short ToShort(string Value);
    public static short ToShort(object Value);
    [CLSCompliantAttribute("False")]
public static ushort ToUShort(string Value);
    [CLSCompliantAttribute("False")]
public static ushort ToUShort(object Value);
    public static int ToInteger(string Value);
    public static int ToInteger(object Value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInteger(string Value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInteger(object Value);
    public static long ToLong(string Value);
    public static long ToLong(object Value);
    [CLSCompliantAttribute("False")]
public static ulong ToULong(string Value);
    [CLSCompliantAttribute("False")]
public static ulong ToULong(object Value);
    public static decimal ToDecimal(bool Value);
    public static decimal ToDecimal(string Value);
    public static decimal ToDecimal(object Value);
    private static decimal ParseDecimal(string Value, NumberFormatInfo NumberFormat);
    private static NumberFormatInfo GetNormalizedNumberFormat(NumberFormatInfo InNumberFormat);
    public static float ToSingle(string Value);
    public static float ToSingle(object Value);
    public static double ToDouble(string Value);
    public static double ToDouble(object Value);
    private static double ParseDouble(string Value);
    public static DateTime ToDate(string Value);
    public static DateTime ToDate(object Value);
    public static char ToChar(string Value);
    public static char ToChar(object Value);
    public static string ToString(int Value);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 Value);
    public static string ToString(long Value);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong Value);
    public static string ToString(float Value);
    public static string ToString(double Value);
    public static string ToString(DateTime Value);
    public static string ToString(decimal Value);
    public static string ToString(object Value);
    public static string ToString(bool Value);
    public static string ToString(byte Value);
    public static string ToString(char Value);
    internal static CultureInfo GetCultureInfo();
    internal static string ToHalfwidthNumbers(string s, CultureInfo culture);
    internal static bool IsHexOrOctValue(string Value, Int64& i64Value);
    internal static bool IsHexOrOctValue(string Value, UInt64& ui64Value);
    public static T ToGenericParameter(object Value);
}
[Embedded]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[EditorBrowsableAttribute("1")]
internal class Microsoft.VisualBasic.CompilerServices.EmbeddedOperators : object {
    public static int CompareString(string Left, string Right, bool TextCompare);
}
[Embedded]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[EditorBrowsableAttribute("1")]
internal class Microsoft.VisualBasic.CompilerServices.ProjectData : object {
    public static void SetProjectError(Exception ex);
    public static void ClearProjectError();
}
[Embedded]
[AttributeUsageAttribute("4")]
[EditorBrowsableAttribute("1")]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualBasic.CompilerServices.StandardModuleAttribute : Attribute {
}
[Embedded]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[EditorBrowsableAttribute("1")]
internal class Microsoft.VisualBasic.CompilerServices.Utils : object {
    public static Array CopyArray(Array arySrc, Array aryDest);
}
[Embedded]
[AttributeUsageAttribute("7")]
[EditorBrowsableAttribute("1")]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualBasic.Embedded : Attribute {
}
[Embedded]
[AttributeUsageAttribute("4")]
[EditorBrowsableAttribute("1")]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualBasic.HideModuleNameAttribute : Attribute {
}
[StandardModuleAttribute]
[Embedded]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[StandardModuleAttribute]
internal class Microsoft.VisualBasic.Strings : object {
    public static char ChrW(int CharCode);
    public static int AscW(string String);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("<generated method>")]
internal class VB$AnonymousDelegate_0`2 : MulticastDelegate {
    public VB$AnonymousDelegate_0`2(object TargetObject, IntPtr TargetMethod);
    public virtual IAsyncResult BeginInvoke(TArg0 precedingInitializersLength, AsyncCallback DelegateCallback, object DelegateAsyncState);
    public virtual TResult EndInvoke(IAsyncResult DelegateAsyncResult);
    public virtual TResult Invoke(TArg0 precedingInitializersLength);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("Value={Value}, Group={Group}")]
internal class VB$AnonymousType_0`2 : object {
    private T0 $Value;
    private T1 $Group;
    public T0 Value { get; }
    public T1 Group { get; }
    public VB$AnonymousType_0`2(T0 Value, T1 Group);
    public T0 get_Value();
    public T1 get_Group();
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual override bool Equals(VB$AnonymousType_0`2<T0, T1> val);
    public virtual bool Equals(object obj);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("kv={kv}, n={n}")]
internal class VB$AnonymousType_1`2 : object {
    private T0 $kv;
    private T1 $n;
    public T0 kv { get; }
    public T1 n { get; }
    public VB$AnonymousType_1`2(T0 kv, T1 n);
    public T0 get_kv();
    public T1 get_n();
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual override bool Equals(VB$AnonymousType_1`2<T0, T1> val);
    public virtual bool Equals(object obj);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("t={t}, diag={diag}")]
internal class VB$AnonymousType_2`2 : object {
    private T0 $t;
    private T1 $diag;
    public T0 t { get; }
    public T1 diag { get; }
    public VB$AnonymousType_2`2(T0 t, T1 diag);
    public T0 get_t();
    public T1 get_diag();
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual override bool Equals(VB$AnonymousType_2`2<T0, T1> val);
    public virtual bool Equals(object obj);
}
