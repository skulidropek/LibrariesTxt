internal abstract class Microsoft.CodeAnalysis.AbstractLinkedFileMergeConflictCommentAdditionService : object {
    internal abstract virtual string GetConflictCommentText(string header, string beforeString, string afterString);
    public sealed virtual IEnumerable`1<TextChange> CreateEdits(SourceText originalSourceText, IEnumerable`1<UnmergedDocumentChanges> unmergedChanges);
    private IEnumerable`1<IEnumerable`1<TextChange>> PartitionChangesForDocument(IEnumerable`1<TextChange> changes, SourceText originalSourceText);
    private List`1<TextChange> GetCommentChangesForDocument(IEnumerable`1<IEnumerable`1<TextChange>> partitionedChanges, string projectName, SourceText oldDocumentText);
    private string TrimBlankLines(SourceText text);
}
public class Microsoft.CodeAnalysis.AdhocWorkspace : Workspace {
    public bool CanOpenDocuments { get; }
    public AdhocWorkspace(HostServices host, string workspaceKind);
    public virtual bool CanApplyChange(ApplyChangesKind feature);
    public virtual bool get_CanOpenDocuments();
    public void ClearSolution();
    public Solution AddSolution(SolutionInfo solutionInfo);
    public Project AddProject(string name, string language);
    public Project AddProject(ProjectInfo projectInfo);
    public void AddProjects(IEnumerable`1<ProjectInfo> projectInfos);
    public Document AddDocument(ProjectId projectId, string name, SourceText text);
    public Document AddDocument(DocumentInfo documentInfo);
    public virtual void OpenDocument(DocumentId documentId, bool activate);
    public virtual void CloseDocument(DocumentId documentId);
    public virtual void OpenAdditionalDocument(DocumentId documentId, bool activate);
    public virtual void CloseAdditionalDocument(DocumentId documentId);
}
public enum Microsoft.CodeAnalysis.ApplyChangesKind : Enum {
    public int value__;
    public static ApplyChangesKind AddProject;
    public static ApplyChangesKind RemoveProject;
    public static ApplyChangesKind AddProjectReference;
    public static ApplyChangesKind RemoveProjectReference;
    public static ApplyChangesKind AddMetadataReference;
    public static ApplyChangesKind RemoveMetadataReference;
    public static ApplyChangesKind AddDocument;
    public static ApplyChangesKind RemoveDocument;
    public static ApplyChangesKind ChangeDocument;
    public static ApplyChangesKind AddAnalyzerReference;
    public static ApplyChangesKind RemoveAnalyzerReference;
    public static ApplyChangesKind AddAdditionalDocument;
    public static ApplyChangesKind RemoveAdditionalDocument;
    public static ApplyChangesKind ChangeAdditionalDocument;
    public static ApplyChangesKind ChangeCompilationOptions;
    public static ApplyChangesKind ChangeParseOptions;
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count,nq}")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.ArrayBuilder`1/DebuggerProxy")]
internal class Microsoft.CodeAnalysis.ArrayBuilder`1 : object {
    private Builder<T> _builder;
    private ObjectPool`1<ArrayBuilder`1<T>> _pool;
    private static ObjectPool`1<ArrayBuilder`1<T>> s_poolInstance;
    public int Count { get; }
    public T Item { get; public set; }
    public ArrayBuilder`1(int size);
    private ArrayBuilder`1(ObjectPool`1<ArrayBuilder`1<T>> pool);
    private static ArrayBuilder`1();
    public ImmutableArray`1<T> ToImmutable();
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public void set_Item(int index, T value);
    public void Add(T item);
    public void Insert(int index, T item);
    public void EnsureCapacity(int capacity);
    public void Clear();
    public bool Contains(T item);
    public int IndexOf(T item);
    public void RemoveAt(int index);
    public void RemoveLast();
    public void ReverseContents();
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(int startIndex, IComparer`1<T> comparer);
    public T[] ToArray();
    public void CopyTo(T[] array, int start);
    public T Last();
    public T First();
    public bool Any();
    public ImmutableArray`1<T> ToImmutableOrNull();
    public ImmutableArray`1<U> ToDowncastedImmutable();
    public ImmutableArray`1<T> ToImmutableAndFree();
    public T[] ToArrayAndFree();
    public void Free();
    public static ArrayBuilder`1<T> GetInstance();
    public static ArrayBuilder`1<T> GetInstance(int capacity);
    public static ArrayBuilder`1<T> GetInstance(int capacity, T fillWithValue);
    public static ObjectPool`1<ArrayBuilder`1<T>> CreatePool();
    public static ObjectPool`1<ArrayBuilder`1<T>> CreatePool(int size);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal Dictionary`2<K, ImmutableArray`1<T>> ToDictionary(Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
    public void AddRange(ArrayBuilder`1<T> items);
    public void AddRange(ArrayBuilder`1<U> items);
    public void AddRange(ImmutableArray`1<T> items);
    public void AddRange(ImmutableArray`1<T> items, int length);
    public void AddRange(IEnumerable`1<T> items);
    public void AddRange(T[] items);
    public void AddRange(T[] items, int length);
    public void Clip(int limit);
    public void ZeroInit(int count);
    public void AddMany(T item, int count);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ArrayBuilderExtensions : object {
    [ExtensionAttribute]
public static bool Any(ArrayBuilder`1<T> builder, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool All(ArrayBuilder`1<T> builder, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ArrayBuilder`1<TItem> items, Func`2<TItem, TResult> map);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ArrayBuilder`1<TItem> items, Func`3<TItem, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static void AddOptional(ArrayBuilder`1<T> builder, T item);
    [ExtensionAttribute]
public static void Push(ArrayBuilder`1<T> builder, T e);
    [ExtensionAttribute]
public static T Pop(ArrayBuilder`1<T> builder);
    [ExtensionAttribute]
public static T Peek(ArrayBuilder`1<T> builder);
}
internal class Microsoft.CodeAnalysis.AssemblyReferenceResolver : MetadataReferenceResolver {
    internal MetadataFileReferenceResolver PathResolver;
    internal MetadataFileReferenceProvider Provider;
    public AssemblyReferenceResolver(MetadataFileReferenceResolver pathResolver, MetadataFileReferenceProvider provider);
    public virtual ImmutableArray`1<PortableExecutableReference> ResolveReference(string reference, string baseFilePath, MetadataReferenceProperties properties);
    public virtual bool Equals(object other);
    public bool Equals(AssemblyReferenceResolver other);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.BitVector : ValueType {
    private static UInt32[] s_emptyArray;
    private static BitVector s_nullValue;
    private static BitVector s_emptyValue;
    private static int Log2BitsPerWord;
    internal static int BitsPerWord;
    private static UInt32 ZeroWord;
    private UInt32 _bits0;
    private UInt32[] _bits;
    private int _capacity;
    public int Capacity { get; }
    public bool IsNull { get; }
    public static BitVector Null { get; }
    public static BitVector Empty { get; }
    public bool Item { get; public set; }
    private BitVector(UInt32 bits0, UInt32[] bits, int capacity);
    private static BitVector();
    public sealed virtual bool Equals(BitVector other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static int WordsForCapacity(int capacity);
    public int get_Capacity();
    [ConditionalAttribute("DEBUG_BITARRAY")]
private void Check();
    public void EnsureCapacity(int newCapacity);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.BitVector/<Words>d__18")]
internal IEnumerable`1<UInt32> Words();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.BitVector/<TrueBits>d__19")]
public IEnumerable`1<int> TrueBits();
    public static BitVector Create(int capacity);
    public static BitVector AllSet(int capacity);
    public BitVector Clone();
    public bool get_IsNull();
    public static BitVector get_Null();
    public static BitVector get_Empty();
    public bool IntersectWith(BitVector other);
    public void UnionWith(BitVector other);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    public void Clear();
}
internal static class Microsoft.CodeAnalysis.Boxes : object {
    public static object BoxedTrue;
    public static object BoxedFalse;
    public static object BoxedByteZero;
    public static object BoxedSByteZero;
    public static object BoxedInt16Zero;
    public static object BoxedUInt16Zero;
    public static object BoxedInt32Zero;
    public static object BoxedInt32One;
    public static object BoxedUInt32Zero;
    public static object BoxedInt64Zero;
    public static object BoxedUInt64Zero;
    public static object BoxedSingleZero;
    public static object BoxedDoubleZero;
    public static object BoxedDecimalZero;
    private static Object[] s_boxedAsciiChars;
    private static Boxes();
    public static object Box(bool b);
    public static object Box(byte b);
    public static object Box(sbyte sb);
    public static object Box(short s);
    public static object Box(ushort us);
    public static object Box(int i);
    public static object Box(UInt32 u);
    public static object Box(long l);
    public static object Box(ulong ul);
    public static object Box(float f);
    public static object Box(double d);
    public static object Box(char c);
    public static object Box(decimal d);
}
internal class Microsoft.CodeAnalysis.BranchId : object {
    private static int s_nextId;
    private int _id;
    private BranchId(int id);
    internal static BranchId GetNextId();
}
internal abstract class Microsoft.CodeAnalysis.CaseCorrection.AbstractCaseCorrectionService : object {
    protected abstract virtual void AddReplacements(SemanticModel semanticModel, SyntaxNode root, IEnumerable`1<TextSpan> spans, Workspace workspace, ConcurrentDictionary`2<SyntaxToken, SyntaxToken> replacements, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CaseCorrection.AbstractCaseCorrectionService/<CaseCorrectAsync>d__1")]
public sealed virtual Task`1<Document> CaseCorrectAsync(Document document, IEnumerable`1<TextSpan> spans, CancellationToken cancellationToken);
    public sealed virtual SyntaxNode CaseCorrect(SyntaxNode root, IEnumerable`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
    private SyntaxNode CaseCorrect(SemanticModel semanticModel, SyntaxNode root, IEnumerable`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector : object {
    public static SyntaxAnnotation Annotation;
    private static CaseCorrector();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector/<CaseCorrectAsync>d__1")]
public static Task`1<Document> CaseCorrectAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector/<CaseCorrectAsync>d__2")]
public static Task`1<Document> CaseCorrectAsync(Document document, SyntaxAnnotation annotation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector/<CaseCorrectAsync>d__3")]
public static Task`1<Document> CaseCorrectAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector/<CaseCorrectAsync>d__4")]
public static Task`1<Document> CaseCorrectAsync(Document document, IEnumerable`1<TextSpan> spans, CancellationToken cancellationToken);
    internal static SyntaxNode CaseCorrect(SyntaxNode root, IEnumerable`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CaseCorrection.ICaseCorrectionService {
    public abstract virtual Task`1<Document> CaseCorrectAsync(Document document, IEnumerable`1<TextSpan> spans, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CaseCorrect(SyntaxNode root, IEnumerable`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Classification.AbstractClassificationService : object {
    public abstract virtual void AddLexicalClassifications(SourceText text, TextSpan textSpan, List`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual void AddSyntacticClassifications(SyntaxTree syntaxTree, TextSpan textSpan, List`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<ISyntaxClassifier> GetDefaultSyntaxClassifiers();
    public abstract virtual ClassifiedSpan FixClassification(SourceText text, ClassifiedSpan classifiedSpan);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.AbstractClassificationService/<AddSemanticClassificationsAsync>d__5")]
public sealed virtual Task AddSemanticClassificationsAsync(Document document, TextSpan textSpan, Func`2<SyntaxNode, List`1<ISyntaxClassifier>> getNodeClassifiers, Func`2<SyntaxToken, List`1<ISyntaxClassifier>> getTokenClassifiers, List`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public sealed virtual void AddSemanticClassifications(SemanticModel semanticModel, TextSpan textSpan, Workspace workspace, Func`2<SyntaxNode, List`1<ISyntaxClassifier>> getNodeClassifiers, Func`2<SyntaxToken, List`1<ISyntaxClassifier>> getTokenClassifiers, List`1<ClassifiedSpan> result, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Classification.ClassificationExtensions : object {
    [ExtensionAttribute]
public static string GetClassification(ITypeSymbol type);
}
public static class Microsoft.CodeAnalysis.Classification.ClassificationTypeNames : object {
    public static string Comment;
    public static string ExcludedCode;
    public static string Identifier;
    public static string Keyword;
    public static string NumericLiteral;
    public static string Operator;
    public static string PreprocessorKeyword;
    public static string StringLiteral;
    public static string WhiteSpace;
    public static string Text;
    public static string PreprocessorText;
    public static string Punctuation;
    public static string VerbatimStringLiteral;
    public static string ClassName;
    public static string DelegateName;
    public static string EnumName;
    public static string InterfaceName;
    public static string ModuleName;
    public static string StructName;
    public static string TypeParameterName;
    public static string XmlDocCommentAttributeName;
    public static string XmlDocCommentAttributeQuotes;
    public static string XmlDocCommentAttributeValue;
    public static string XmlDocCommentCDataSection;
    public static string XmlDocCommentComment;
    public static string XmlDocCommentDelimiter;
    public static string XmlDocCommentEntityReference;
    public static string XmlDocCommentName;
    public static string XmlDocCommentProcessingInstruction;
    public static string XmlDocCommentText;
    public static string XmlLiteralAttributeName;
    public static string XmlLiteralAttributeQuotes;
    public static string XmlLiteralAttributeValue;
    public static string XmlLiteralCDataSection;
    public static string XmlLiteralComment;
    public static string XmlLiteralDelimiter;
    public static string XmlLiteralEmbeddedExpression;
    public static string XmlLiteralEntityReference;
    public static string XmlLiteralName;
    public static string XmlLiteralProcessingInstruction;
    public static string XmlLiteralText;
}
public class Microsoft.CodeAnalysis.Classification.ClassifiedSpan : ValueType {
    [CompilerGeneratedAttribute]
private string <ClassificationType>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    public string ClassificationType { get; }
    public TextSpan TextSpan { get; }
    public ClassifiedSpan(string classificationType, TextSpan textSpan);
    public ClassifiedSpan(TextSpan textSpan, string classificationType);
    [CompilerGeneratedAttribute]
public string get_ClassificationType();
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ClassifiedSpan other);
}
public static class Microsoft.CodeAnalysis.Classification.Classifier : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.Classifier/<GetClassifiedSpansAsync>d__0")]
public static Task`1<IEnumerable`1<ClassifiedSpan>> GetClassifiedSpansAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    public static IEnumerable`1<ClassifiedSpan> GetClassifiedSpans(SemanticModel semanticModel, TextSpan textSpan, Workspace workspace, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier {
    public IEnumerable`1<Type> SyntaxNodeTypes { get; }
    public IEnumerable`1<int> SyntaxTokenKinds { get; }
    public abstract virtual IEnumerable`1<Type> get_SyntaxNodeTypes();
    public abstract virtual IEnumerable`1<int> get_SyntaxTokenKinds();
    public abstract virtual IEnumerable`1<ClassifiedSpan> ClassifyNode(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<ClassifiedSpan> ClassifyToken(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Classification.IClassificationService {
    public abstract virtual IEnumerable`1<ISyntaxClassifier> GetDefaultSyntaxClassifiers();
    public abstract virtual void AddLexicalClassifications(SourceText text, TextSpan textSpan, List`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual void AddSyntacticClassifications(SyntaxTree syntaxTree, TextSpan textSpan, List`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual Task AddSemanticClassificationsAsync(Document document, TextSpan textSpan, Func`2<SyntaxNode, List`1<ISyntaxClassifier>> getNodeClassifiers, Func`2<SyntaxToken, List`1<ISyntaxClassifier>> getTokenClassifiers, List`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual void AddSemanticClassifications(SemanticModel semanticModel, TextSpan textSpan, Workspace workspace, Func`2<SyntaxNode, List`1<ISyntaxClassifier>> getNodeClassifiers, Func`2<SyntaxToken, List`1<ISyntaxClassifier>> getTokenClassifiers, List`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual ClassifiedSpan FixClassification(SourceText text, ClassifiedSpan classifiedSpan);
}
public class Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation : CodeActionOperation {
    private Solution _changedSolution;
    public Solution ChangedSolution { get; }
    public ApplyChangesOperation(Solution changedSolution);
    public Solution get_ChangedSolution();
    public virtual void Apply(Workspace workspace, CancellationToken cancellationToken);
}
public abstract class Microsoft.CodeAnalysis.CodeActions.CodeAction : object {
    public string Title { get; }
    public string EquivalenceKey { get; }
    public abstract virtual string get_Title();
    public virtual string get_EquivalenceKey();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<GetOperationsAsync>d__4")]
public Task`1<ImmutableArray`1<CodeActionOperation>> GetOperationsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<GetOperationsCoreAsync>d__5")]
internal virtual Task`1<ImmutableArray`1<CodeActionOperation>> GetOperationsCoreAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<GetPreviewOperationsAsync>d__6")]
public Task`1<ImmutableArray`1<CodeActionOperation>> GetPreviewOperationsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<ComputeOperationsAsync>d__7")]
protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<ComputePreviewOperationsAsync>d__8")]
protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputePreviewOperationsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<GetChangedSolutionAsync>d__9")]
protected virtual Task`1<Solution> GetChangedSolutionAsync(CancellationToken cancellationToken);
    protected virtual Task`1<Document> GetChangedDocumentAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<GetChangedSolutionInternalAsync>d__11")]
internal Task`1<Solution> GetChangedSolutionInternalAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<GetChangedDocumentInternalAsync>d__12")]
internal Task`1<Document> GetChangedDocumentInternalAsync(CancellationToken cancellation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<PostProcessAsync>d__13")]
protected Task`1<ImmutableArray`1<CodeActionOperation>> PostProcessAsync(IEnumerable`1<CodeActionOperation> operations, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<PostProcessChangesAsync>d__14")]
protected Task`1<Solution> PostProcessChangesAsync(Solution changedSolution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<PostProcessChangesAsync>d__15")]
protected virtual Task`1<Document> PostProcessChangesAsync(Document document, CancellationToken cancellationToken);
    public static CodeAction Create(string title, Func`2<CancellationToken, Task`1<Document>> createChangedDocument, string equivalenceKey);
    public static CodeAction Create(string title, Func`2<CancellationToken, Task`1<Solution>> createChangedSolution, string equivalenceKey);
}
public abstract class Microsoft.CodeAnalysis.CodeActions.CodeActionOperation : object {
    public string Title { get; }
    public virtual string get_Title();
    public virtual void Apply(Workspace workspace, CancellationToken cancellationToken);
}
public abstract class Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions : CodeAction {
    public abstract virtual object GetOptions(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions/<GetOperationsAsync>d__1")]
public Task`1<IEnumerable`1<CodeActionOperation>> GetOperationsAsync(object options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions/<GetOperationsCoreAsync>d__2")]
internal virtual Task`1<ImmutableArray`1<CodeActionOperation>> GetOperationsCoreAsync(CancellationToken cancellationToken);
    protected abstract virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(object options, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(CancellationToken cancellationToken);
}
public static class Microsoft.CodeAnalysis.CodeActions.ConflictAnnotation : object {
    public static string Kind;
    public static SyntaxAnnotation Create(string description);
    public static string GetDescription(SyntaxAnnotation annotation);
}
public class Microsoft.CodeAnalysis.CodeActions.OpenDocumentOperation : CodeActionOperation {
    private DocumentId _documentId;
    private bool _activate;
    public DocumentId DocumentId { get; }
    public OpenDocumentOperation(DocumentId documentId, bool activateIfAlreadyOpen);
    public DocumentId get_DocumentId();
    public virtual void Apply(Workspace workspace, CancellationToken cancellationToken);
}
public abstract class Microsoft.CodeAnalysis.CodeActions.PreviewOperation : CodeActionOperation {
    public abstract virtual Task`1<object> GetPreviewAsync(CancellationToken cancellationToken);
}
public static class Microsoft.CodeAnalysis.CodeActions.RenameAnnotation : object {
    public static string Kind;
    public static SyntaxAnnotation Create();
}
public static class Microsoft.CodeAnalysis.CodeActions.WarningAnnotation : object {
    public static string Kind;
    public static SyntaxAnnotation Create(string description);
    public static string GetDescription(SyntaxAnnotation annotation);
}
internal abstract class Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService : object {
    public abstract virtual IEnumerable`1<ICodeCleanupProvider> GetDefaultProviders();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService/<CleanupAsync>d__1")]
public sealed virtual Task`1<Document> CleanupAsync(Document document, IEnumerable`1<TextSpan> spans, IEnumerable`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    public sealed virtual SyntaxNode Cleanup(SyntaxNode root, IEnumerable`1<TextSpan> spans, Workspace workspace, IEnumerable`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService/<GetTextSpansFromAnnotation>d__3")]
private IEnumerable`1<TextSpan> GetTextSpansFromAnnotation(SyntaxNode node, List`1<ValueTuple`2<SyntaxAnnotation, SyntaxAnnotation>> annotations, CancellationToken cancellationToken);
    private bool TryGetTextSpanFromAnnotation(SpanMarker previousTokenMarker, SpanMarker nextTokenMarker, SyntaxNode node, IEnumerable`1<SyntaxToken> previousTokens, IEnumerable`1<SyntaxToken> nextTokens, TextSpan& span);
    private int GetPreviousTokenStartPosition(SpanMarkerType spanMarkerType, SyntaxToken previousToken);
    private int GetNextTokenEndPosition(SpanMarkerType spanMarkerType, SyntaxToken nextToken);
    private ValueTuple`2<SyntaxNode, List`1<ValueTuple`2<SyntaxAnnotation, SyntaxAnnotation>>> AnnotateNodeForTextSpans(ISyntaxFactsService syntaxFactsService, SyntaxNode root, IEnumerable`1<TextSpan> spans, CancellationToken cancellationToken);
    private IEnumerable`1<TextSpan> GetNonOverlappingSpans(ISyntaxFactsService syntaxFactsService, SyntaxNode root, IEnumerable`1<TextSpan> spans, CancellationToken cancellationToken);
    private static void GetTokensAroundSpan(SyntaxNode root, TextSpan span, SyntaxToken& previousToken, SyntaxToken& startToken, SyntaxToken& endToken, SyntaxToken& nextToken);
    private TextSpan GetSpanAlignedToTokens(ISyntaxFactsService syntaxFactsService, SyntaxNode root, TextSpan span, SyntaxToken& startToken, SyntaxToken& endToken);
    private SyntaxToken FindTokenOnRightOfPosition(ISyntaxFactsService syntaxFactsService, SyntaxNode root, int position);
    private SyntaxToken FindTokenOnLeftOfPosition(ISyntaxFactsService syntaxFactsService, SyntaxNode root, int position);
    private bool CleanupWholeNode(List`1<ValueTuple`2<SyntaxAnnotation, SyntaxAnnotation>> annotations);
    private bool CleanupWholeNode(TextSpan nodeSpan, IEnumerable`1<TextSpan> spans);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService/<IterateAllCodeCleanupProvidersAsync>d__15")]
private Task`1<Document> IterateAllCodeCleanupProvidersAsync(Document originalDocument, Document annotatedDocument, Func`2<SyntaxNode, IEnumerable`1<TextSpan>> spanGetter, IEnumerable`1<ICodeCleanupProvider> codeCleaners, CancellationToken cancellationToken);
    private SyntaxNode IterateAllCodeCleanupProviders(SyntaxNode originalRoot, SyntaxNode annotatedRoot, Func`2<SyntaxNode, IEnumerable`1<TextSpan>> spanGetter, Workspace workspace, IEnumerable`1<ICodeCleanupProvider> codeCleaners, CancellationToken cancellationToken);
    private string GetCodeCleanerTypeName(ICodeCleanupProvider codeCleaner);
    private SyntaxNode InjectAnnotations(SyntaxNode node, Dictionary`2<SyntaxToken, List`1<SyntaxAnnotation>> map);
    private bool TryCreateTextSpan(int start, int end, TextSpan& span);
}
internal static class Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner : object {
    public static IEnumerable`1<ICodeCleanupProvider> GetDefaultProviders(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner/<CleanupAsync>d__1")]
public static Task`1<Document> CleanupAsync(Document document, IEnumerable`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner/<CleanupAsync>d__2")]
public static Task`1<Document> CleanupAsync(Document document, SyntaxAnnotation annotation, IEnumerable`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    public static Task`1<Document> CleanupAsync(Document document, TextSpan span, IEnumerable`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    public static Task`1<Document> CleanupAsync(Document document, IEnumerable`1<TextSpan> spans, IEnumerable`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    public static SyntaxNode Cleanup(SyntaxNode root, TextSpan span, Workspace workspace, IEnumerable`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    public static SyntaxNode Cleanup(SyntaxNode root, IEnumerable`1<TextSpan> spans, Workspace workspace, IEnumerable`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanerService {
    public abstract virtual IEnumerable`1<ICodeCleanupProvider> GetDefaultProviders();
    public abstract virtual Task`1<Document> CleanupAsync(Document document, IEnumerable`1<TextSpan> spans, IEnumerable`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode Cleanup(SyntaxNode root, IEnumerable`1<TextSpan> spans, Workspace workspace, IEnumerable`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.CodeCleanup.Providers.ExportCodeCleanupProvider : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Languages>k__BackingField;
    public string Name { get; }
    public IEnumerable`1<string> Languages { get; }
    public ExportCodeCleanupProvider(string name, String[] languages);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Languages();
}
internal class Microsoft.CodeAnalysis.CodeCleanup.Providers.FormatCodeCleanupProvider : object {
    public string Name { get; }
    public sealed virtual string get_Name();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.Providers.FormatCodeCleanupProvider/<CleanupAsync>d__2")]
public sealed virtual Task`1<Document> CleanupAsync(Document document, IEnumerable`1<TextSpan> spans, CancellationToken cancellationToken);
    public sealed virtual SyntaxNode Cleanup(SyntaxNode root, IEnumerable`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual Task`1<Document> CleanupAsync(Document document, IEnumerable`1<TextSpan> spans, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode Cleanup(SyntaxNode root, IEnumerable`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CodeCleanup.Providers.PredefinedCodeCleanupProviderNames : object {
    public static string Simplification;
    public static string CaseCorrection;
    public static string AddMissingTokens;
    public static string NormalizeModifiersOrOperators;
    public static string RemoveUnnecessaryLineContinuation;
    public static string Format;
    public static string FixIncorrectTokens;
    public static string ReduceTokens;
}
internal class Microsoft.CodeAnalysis.CodeCleanup.Providers.SimpleCodeCleanupProvider : object {
    private Func`4<Document, IEnumerable`1<TextSpan>, CancellationToken, Task`1<Document>> _documentDelegatee;
    private Func`5<SyntaxNode, IEnumerable`1<TextSpan>, Workspace, CancellationToken, SyntaxNode> _syntaxDelegatee;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public SimpleCodeCleanupProvider(string name, Func`4<Document, IEnumerable`1<TextSpan>, CancellationToken, Task`1<Document>> documentDelegatee, Func`5<SyntaxNode, IEnumerable`1<TextSpan>, Workspace, CancellationToken, SyntaxNode> syntaxDelegatee);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.Providers.SimpleCodeCleanupProvider/<CleanupAsync>d__6")]
public sealed virtual Task`1<Document> CleanupAsync(Document document, IEnumerable`1<TextSpan> spans, CancellationToken cancellationToken);
    public sealed virtual SyntaxNode Cleanup(SyntaxNode root, IEnumerable`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CodeCleanup.Providers.SimplificationCodeCleanupProvider : object {
    public string Name { get; }
    public sealed virtual string get_Name();
    public sealed virtual Task`1<Document> CleanupAsync(Document document, IEnumerable`1<TextSpan> spans, CancellationToken cancellationToken);
    public sealed virtual SyntaxNode Cleanup(SyntaxNode root, IEnumerable`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider : FixAllProvider {
    public static FixAllProvider Instance;
    private static BatchFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<GetFixAsync>d__2")]
public virtual Task`1<CodeAction> GetFixAsync(FixAllContext fixAllContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<GetFixAsync>d__3")]
public virtual Task`1<CodeAction> GetFixAsync(ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>> documentsAndDiagnosticsToFixMap, FixAllContext fixAllContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<AddDocumentFixesAsync>d__4")]
public virtual Task AddDocumentFixesAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, Action`1<CodeAction> addFix, FixAllContext fixAllContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<GetFixAsync>d__5")]
public virtual Task`1<CodeAction> GetFixAsync(ImmutableDictionary`2<Project, ImmutableArray`1<Diagnostic>> projectsAndDiagnosticsToFixMap, FixAllContext fixAllContext);
    public virtual Task AddProjectFixesAsync(Project project, IEnumerable`1<Diagnostic> diagnostics, Action`1<CodeAction> addFix, FixAllContext fixAllContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<TryGetMergedFixAsync>d__7")]
public virtual Task`1<CodeAction> TryGetMergedFixAsync(IEnumerable`1<CodeAction> batchOfFixes, FixAllContext fixAllContext);
    public virtual string GetFixAllTitle(FixAllContext fixAllContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<GetDocumentDiagnosticsToFixAsync>d__9")]
public virtual Task`1<ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>>> GetDocumentDiagnosticsToFixAsync(FixAllContext fixAllContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<GetDocumentDiagnosticsToFixAsync>d__10")]
private static Task`1<ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>>> GetDocumentDiagnosticsToFixAsync(ImmutableArray`1<Diagnostic> diagnostics, ImmutableArray`1<Project> projects, Func`2<Document, bool> isGeneratedCode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<GetTreeToDocumentMapAsync>d__11")]
private static Task`1<ImmutableDictionary`2<SyntaxTree, Document>> GetTreeToDocumentMapAsync(ImmutableArray`1<Project> projects, CancellationToken cancellationToken);
    private static Document GetReportedDocument(Diagnostic diagnostic, ImmutableDictionary`2<SyntaxTree, Document> treeToDocumentsMap);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<GetProjectDiagnosticsToFixAsync>d__13")]
public virtual Task`1<ImmutableDictionary`2<Project, ImmutableArray`1<Diagnostic>>> GetProjectDiagnosticsToFixAsync(FixAllContext fixAllContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<TryMergeFixesAsync>d__14")]
public virtual Task`1<Solution> TryMergeFixesAsync(Solution oldSolution, IEnumerable`1<CodeAction> codeActions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<TryAddDocumentMergeChangesAsync>d__15")]
private static Task`1<List`1<TextChange>> TryAddDocumentMergeChangesAsync(Document oldDocument, Document newDocument, List`1<TextChange> cumulativeChanges, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CodeFixes.BatchSimplificationFixAllProvider : BatchFixAllProvider {
    public static FixAllProvider Instance;
    protected bool NeedsParentFixup { get; }
    private static BatchSimplificationFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchSimplificationFixAllProvider/<AddDocumentFixesAsync>d__2")]
public virtual Task AddDocumentFixesAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, Action`1<CodeAction> addFix, FixAllContext fixAllContext);
    protected virtual SyntaxNode GetNodeToSimplify(SyntaxNode root, SemanticModel model, Diagnostic diagnostic, Workspace workspace, String& codeActionEquivalenceKey, CancellationToken cancellationToken);
    protected virtual Task`1<Document> AddSimplifyAnnotationsAsync(Document document, SyntaxNode nodeToSimplify, CancellationToken cancellationToken);
    protected virtual bool get_NeedsParentFixup();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchSimplificationFixAllProvider/<AddSimplifierAnnotationsAsync>d__7")]
private Task`1<Document> AddSimplifierAnnotationsAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, FixAllContext fixAllContext);
}
internal class Microsoft.CodeAnalysis.CodeFixes.CodeFix : object {
    internal CodeAction Action;
    internal ImmutableArray`1<Diagnostic> Diagnostics;
    internal Diagnostic PrimaryDiagnostic { get; }
    internal CodeFix(CodeAction action, Diagnostic diagnostic);
    internal CodeFix(CodeAction action, ImmutableArray`1<Diagnostic> diagnostics);
    internal Diagnostic get_PrimaryDiagnostic();
}
public class Microsoft.CodeAnalysis.CodeFixes.CodeFixContext : ValueType {
    private Document _document;
    private TextSpan _span;
    private ImmutableArray`1<Diagnostic> _diagnostics;
    private CancellationToken _cancellationToken;
    private Action`2<CodeAction, ImmutableArray`1<Diagnostic>> _registerCodeFix;
    public Document Document { get; }
    public TextSpan Span { get; }
    public ImmutableArray`1<Diagnostic> Diagnostics { get; }
    public CancellationToken CancellationToken { get; }
    public CodeFixContext(Document document, TextSpan span, ImmutableArray`1<Diagnostic> diagnostics, Action`2<CodeAction, ImmutableArray`1<Diagnostic>> registerCodeFix, CancellationToken cancellationToken);
    public CodeFixContext(Document document, Diagnostic diagnostic, Action`2<CodeAction, ImmutableArray`1<Diagnostic>> registerCodeFix, CancellationToken cancellationToken);
    internal CodeFixContext(Document document, TextSpan span, ImmutableArray`1<Diagnostic> diagnostics, Action`2<CodeAction, ImmutableArray`1<Diagnostic>> registerCodeFix, bool verifyArguments, CancellationToken cancellationToken);
    internal CodeFixContext(Document document, Diagnostic diagnostic, Action`2<CodeAction, ImmutableArray`1<Diagnostic>> registerCodeFix, bool verifyArguments, CancellationToken cancellationToken);
    public Document get_Document();
    public TextSpan get_Span();
    public ImmutableArray`1<Diagnostic> get_Diagnostics();
    public CancellationToken get_CancellationToken();
    public void RegisterCodeFix(CodeAction action, Diagnostic diagnostic);
    public void RegisterCodeFix(CodeAction action, IEnumerable`1<Diagnostic> diagnostics);
    public void RegisterCodeFix(CodeAction action, ImmutableArray`1<Diagnostic> diagnostics);
    private static void VerifyDiagnosticsArgument(ImmutableArray`1<Diagnostic> diagnostics, TextSpan span);
}
public abstract class Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider : object {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public abstract virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public abstract virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    public virtual FixAllProvider GetFixAllProvider();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Languages>k__BackingField;
    public string Name { get; public set; }
    public String[] Languages { get; }
    public ExportCodeFixProviderAttribute(string firstLanguage, String[] additionalLanguages);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public String[] get_Languages();
}
public class Microsoft.CodeAnalysis.CodeFixes.FixAllContext : object {
    private DiagnosticProvider _diagnosticProvider;
    [CompilerGeneratedAttribute]
private Project <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeFixProvider <CodeFixProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private FixAllScope <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<string> <DiagnosticIds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CodeActionEquivalenceKey>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public Solution Solution { get; }
    public Project Project { get; }
    public Document Document { get; }
    public CodeFixProvider CodeFixProvider { get; }
    public FixAllScope Scope { get; }
    public ImmutableHashSet`1<string> DiagnosticIds { get; }
    public string CodeActionEquivalenceKey { get; }
    public CancellationToken CancellationToken { get; }
    public FixAllContext(Document document, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable`1<string> diagnosticIds, DiagnosticProvider fixAllDiagnosticProvider, CancellationToken cancellationToken);
    public FixAllContext(Project project, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable`1<string> diagnosticIds, DiagnosticProvider fixAllDiagnosticProvider, CancellationToken cancellationToken);
    private FixAllContext(Document document, Project project, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable`1<string> diagnosticIds, DiagnosticProvider fixAllDiagnosticProvider, CancellationToken cancellationToken);
    public Solution get_Solution();
    [CompilerGeneratedAttribute]
public Project get_Project();
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public CodeFixProvider get_CodeFixProvider();
    [CompilerGeneratedAttribute]
public FixAllScope get_Scope();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<string> get_DiagnosticIds();
    [CompilerGeneratedAttribute]
public string get_CodeActionEquivalenceKey();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FixAllContext/<GetDocumentDiagnosticsAsync>d__28")]
public Task`1<ImmutableArray`1<Diagnostic>> GetDocumentDiagnosticsAsync(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FixAllContext/<GetFilteredDiagnosticsAsync>d__29")]
private static Task`1<ImmutableArray`1<Diagnostic>> GetFilteredDiagnosticsAsync(Task`1<IEnumerable`1<Diagnostic>> getDiagnosticsTask, ImmutableHashSet`1<string> diagnosticIds);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FixAllContext/<GetProjectDiagnosticsAsync>d__30")]
public Task`1<ImmutableArray`1<Diagnostic>> GetProjectDiagnosticsAsync(Project project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FixAllContext/<GetAllDiagnosticsAsync>d__31")]
public Task`1<ImmutableArray`1<Diagnostic>> GetAllDiagnosticsAsync(Project project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FixAllContext/<GetProjectDiagnosticsAsync>d__32")]
private Task`1<ImmutableArray`1<Diagnostic>> GetProjectDiagnosticsAsync(Project project, bool includeAllDocumentDiagnostics);
    public FixAllContext WithCancellationToken(CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CodeFixes.FixAllLogger : object {
    private static string s_codeFixProvider;
    private static string s_codeActionEquivalenceKey;
    private static string s_fixAllScope;
    private static string s_languageName;
    private static string s_documentCount;
    private static string s_result;
    private static string s_completed;
    private static string s_timedOut;
    private static string s_cancelled;
    private static string s_allChangesApplied;
    private static string s_subsetOfChangesApplied;
    private static string s_documentsWithDiagnosticsToFix;
    private static string s_projectsWithDiagnosticsToFix;
    private static string s_totalDiagnosticsToFix;
    private static string s_totalFixesToMerge;
    private static FixAllLogger();
    public static void LogContext(FixAllContext fixAllContext, bool isInternalCodeFixProvider);
    public static void LogComputationResult(bool completed, bool timedOut);
    public static void LogPreviewChangesResult(bool applied, bool allChangesApplied);
    public static void LogDiagnosticsStats(ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>> documentsAndDiagnosticsToFixMap);
    public static void LogDiagnosticsStats(ImmutableDictionary`2<Project, ImmutableArray`1<Diagnostic>> projectsAndDiagnosticsToFixMap);
    public static void LogFixesToMergeStats(ConcurrentBag`1<CodeAction> fixesToMerge);
}
public abstract class Microsoft.CodeAnalysis.CodeFixes.FixAllProvider : object {
    public virtual IEnumerable`1<FixAllScope> GetSupportedFixAllScopes();
    public virtual IEnumerable`1<string> GetSupportedFixAllDiagnosticIds(CodeFixProvider originalCodeFixProvider);
    public abstract virtual Task`1<CodeAction> GetFixAsync(FixAllContext fixAllContext);
}
public enum Microsoft.CodeAnalysis.CodeFixes.FixAllScope : Enum {
    public int value__;
    public static FixAllScope Document;
    public static FixAllScope Project;
    public static FixAllScope Solution;
    public static FixAllScope Custom;
}
public static class Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders : object {
    public static FixAllProvider BatchFixer { get; }
    internal static FixAllProvider BatchSimplificationFixer { get; }
    public static FixAllProvider get_BatchFixer();
    internal static FixAllProvider get_BatchSimplificationFixer();
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService : object {
    private ISymbolDeclarationService _symbolDeclarationService;
    protected AbstractCodeGenerationService(ISymbolDeclarationService symbolDeclarationService);
    public sealed virtual TDeclarationNode AddEvent(TDeclarationNode destination, IEventSymbol event, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddField(TDeclarationNode destination, IFieldSymbol field, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddMethod(TDeclarationNode destination, IMethodSymbol method, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddProperty(TDeclarationNode destination, IPropertySymbol property, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddNamedType(TDeclarationNode destination, INamedTypeSymbol namedType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddNamespace(TDeclarationNode destination, INamespaceSymbol namespace, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<ISymbol> members, CodeGenerationOptions options, CancellationToken cancellationToken);
    protected abstract virtual TDeclarationNode AddEvent(TDeclarationNode destination, IEventSymbol event, CodeGenerationOptions options, IList`1<bool> availableIndices);
    protected abstract virtual TDeclarationNode AddField(TDeclarationNode destination, IFieldSymbol field, CodeGenerationOptions options, IList`1<bool> availableIndices);
    protected abstract virtual TDeclarationNode AddMethod(TDeclarationNode destination, IMethodSymbol method, CodeGenerationOptions options, IList`1<bool> availableIndices);
    protected abstract virtual TDeclarationNode AddProperty(TDeclarationNode destination, IPropertySymbol property, CodeGenerationOptions options, IList`1<bool> availableIndices);
    protected abstract virtual TDeclarationNode AddNamedType(TDeclarationNode destination, INamedTypeSymbol namedType, CodeGenerationOptions options, IList`1<bool> availableIndices);
    protected abstract virtual TDeclarationNode AddNamespace(TDeclarationNode destination, INamespaceSymbol namespace, CodeGenerationOptions options, IList`1<bool> availableIndices);
    protected abstract virtual TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<SyntaxNode> members);
    public abstract virtual TDeclarationNode AddParameters(TDeclarationNode destinationMember, IEnumerable`1<IParameterSymbol> parameters, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddAttributes(TDeclarationNode destination, IEnumerable`1<AttributeData> attributes, Nullable`1<SyntaxToken> target, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, SyntaxNode attributeToRemove, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, AttributeData attributeToRemove, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddStatements(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode declaration, IEnumerable`1<SyntaxToken> newModifiers, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationAccessibility(TDeclarationNode declaration, Accessibility newAccesibility, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationType(TDeclarationNode declaration, ITypeSymbol newType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationMembers(TDeclarationNode declaration, IList`1<ISymbol> newMembers, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual CodeGenerationDestination GetDestination(SyntaxNode node);
    public abstract virtual SyntaxNode CreateEventDeclaration(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationOptions options);
    public abstract virtual SyntaxNode CreateFieldDeclaration(IFieldSymbol field, CodeGenerationDestination destination, CodeGenerationOptions options);
    public abstract virtual SyntaxNode CreateMethodDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CodeGenerationOptions options);
    public abstract virtual SyntaxNode CreatePropertyDeclaration(IPropertySymbol property, CodeGenerationDestination destination, CodeGenerationOptions options);
    public abstract virtual SyntaxNode CreateNamedTypeDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, CodeGenerationOptions options);
    public abstract virtual SyntaxNode CreateNamespaceDeclaration(INamespaceSymbol namespace, CodeGenerationDestination destination, CodeGenerationOptions options);
    protected abstract virtual AbstractImportsAdder CreateImportsAdder(Document document);
    protected static T Cast(object value);
    protected static void CheckDeclarationNode(SyntaxNode destination);
    protected static void CheckDeclarationNode(SyntaxNode destination);
    protected static void CheckDeclarationNode(SyntaxNode destination);
    protected static void CheckDeclarationNode(SyntaxNode destination);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService/<GetEditAsync>d__38")]
private Task`1<Document> GetEditAsync(Solution solution, INamespaceOrTypeSymbol destination, Func`4<SyntaxNode, CodeGenerationOptions, IList`1<bool>, SyntaxNode> declarationTransform, CodeGenerationOptions options, IEnumerable`1<ISymbol> members, CancellationToken cancellationToken);
    protected TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<ISymbol> members, IList`1<bool> availableIndices, CodeGenerationOptions options);
    protected static CodeGenerationOptions CreateOptionsForMultipleMembers(CodeGenerationOptions options);
    public sealed virtual Task`1<Document> AddEventAsync(Solution solution, INamedTypeSymbol destination, IEventSymbol event, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddFieldAsync(Solution solution, INamedTypeSymbol destination, IFieldSymbol field, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddPropertyAsync(Solution solution, INamedTypeSymbol destination, IPropertySymbol property, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddNamedTypeAsync(Solution solution, INamedTypeSymbol destination, INamedTypeSymbol namedType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddNamedTypeAsync(Solution solution, INamespaceSymbol destination, INamedTypeSymbol namedType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddNamespaceAsync(Solution solution, INamespaceSymbol destination, INamespaceSymbol namespace, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddMethodAsync(Solution solution, INamedTypeSymbol destination, IMethodSymbol method, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddMembersAsync(Solution solution, INamedTypeSymbol destination, IEnumerable`1<ISymbol> members, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddNamespaceOrTypeAsync(Solution solution, INamespaceSymbol destination, INamespaceOrTypeSymbol namespaceOrType, CodeGenerationOptions options, CancellationToken cancellationToken);
    protected static void CheckLocation(TDeclarationNode destinationMember, Location location);
    protected static void ComputePositionAndTriviaForRemoveAttributeList(SyntaxNode attributeList, Func`2<SyntaxTrivia, bool> isEndOfLineTrivia, Int32& positionOfRemovedNode, IEnumerable`1& triviaOfRemovedNode);
    protected static void ComputePositionAndTriviaForRemoveAttributeFromAttributeList(SyntaxNode attributeToRemove, Func`2<SyntaxToken, bool> isComma, Int32& positionOfRemovedNode, IEnumerable`1& triviaOfRemovedNode);
    protected static T AppendTriviaAtPosition(T node, int position, SyntaxTriviaList trivia);
    protected static IList`1<SyntaxToken> GetUpdatedDeclarationAccessibilityModifiers(IList`1<SyntaxToken> newModifierTokens, SyntaxTokenList modifiersList, Func`2<SyntaxToken, bool> isAccessibilityModifier);
    protected abstract virtual IList`1<bool> GetAvailableInsertionIndices(SyntaxNode destination, CancellationToken cancellationToken);
    private IList`1<bool> GetAvailableInsertionIndices(TDeclarationNode destination, CancellationToken cancellationToken);
    public sealed virtual bool CanAddTo(ISymbol destination, Solution solution, CancellationToken cancellationToken);
    protected static SyntaxToken GetEndToken(SyntaxNode node);
    protected static TextSpan GetSpan(SyntaxNode node);
    public sealed virtual bool CanAddTo(SyntaxNode destination, Solution solution, CancellationToken cancellationToken);
    private bool CanAddTo(SyntaxNode destination, Solution solution, CancellationToken cancellationToken, IList`1& availableIndices);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService/<FindMostRelevantDeclarationAsync>d__62")]
private Task`1<Tuple`2<SyntaxNode, IList`1<bool>>> FindMostRelevantDeclarationAsync(Solution solution, INamespaceOrTypeSymbol namespaceOrType, CodeGenerationOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService/<SelectFirstOrDefaultAsync>d__63")]
private static Task`1<SyntaxNode> SelectFirstOrDefaultAsync(IEnumerable`1<SyntaxReference> references, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.AbstractFlagsEnumGenerator : object {
    protected abstract virtual SyntaxGenerator GetSyntaxGenerator();
    protected abstract virtual SyntaxNode CreateExplicitlyCastedLiteralValue(INamedTypeSymbol enumType, SpecialType underlyingSpecialType, object constantValue);
    protected abstract virtual bool IsValidName(INamedTypeSymbol enumType, string name);
    internal SyntaxNode CreateEnumConstantValue(INamedTypeSymbol enumType, object constantValue);
    private bool IsFlagsEnum(INamedTypeSymbol typeSymbol);
    private SyntaxNode CreateFlagsEnumConstantValue(INamedTypeSymbol enumType, object constantValue);
    private SyntaxNode CreateFlagsEnumConstantValue(INamedTypeSymbol enumType, object constantValue, List`1<ValueTuple`2<IFieldSymbol, ulong>> allFieldsAndValues, List`1<ValueTuple`2<IFieldSymbol, ulong>> usedFieldsAndValues);
    private SyntaxNode CreateMemberAccessExpression(IFieldSymbol field, INamedTypeSymbol enumType, SpecialType underlyingSpecialType);
    private IFieldSymbol GetZeroField(List`1<ValueTuple`2<IFieldSymbol, ulong>> allFieldsAndValues);
    private void GetSortedEnumFieldsAndValues(INamedTypeSymbol enumType, List`1<ValueTuple`2<IFieldSymbol, ulong>> allFieldsAndValues);
    private SyntaxNode CreateNonFlagsEnumConstantValue(INamedTypeSymbol enumType, object constantValue);
    private sealed virtual override int System.Collections.Generic.IComparer<Roslyn.Utilities.ValueTuple<Microsoft.CodeAnalysis.IFieldSymbol,System.UInt64>>.Compare(ValueTuple`2<IFieldSymbol, ulong> x, ValueTuple`2<IFieldSymbol, ulong> y);
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.AbstractImportsAdder : object {
    protected Document Document;
    protected AbstractImportsAdder(Document document);
    protected abstract virtual IList`1<INamespaceSymbol> GetExistingNamespaces(SemanticModel semanticModel, SyntaxNode namespaceScope, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode GetImportsContainer(SyntaxNode node);
    protected abstract virtual SyntaxNode GetInnermostNamespaceScope(SyntaxNodeOrToken node);
    public abstract virtual Task`1<Document> AddAsync(IEnumerable`1<ISymbol> members, bool placeSystemNamespaceFirst, CodeGenerationOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractImportsAdder/<GetAllReferencedDefinitionsAsync>d__6")]
protected Task`1<IDictionary`2<SyntaxNode, ISet`1<INamedTypeSymbol>>> GetAllReferencedDefinitionsAsync(Compilation compilation, IEnumerable`1<ISymbol> members, CancellationToken cancellationToken);
    private bool IsBuiltIn(INamedTypeSymbol type);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractImportsAdder/<DetermineNamespaceToImportAsync>d__8")]
protected Task`1<IDictionary`2<SyntaxNode, IList`1<INamespaceSymbol>>> DetermineNamespaceToImportAsync(IEnumerable`1<ISymbol> members, CodeGenerationOptions options, CancellationToken cancellationToken);
    private void AddMissingNamespaces(SemanticModel semanticModel, Dictionary`2<SyntaxNode, IList`1<INamespaceSymbol>> importsContainerToMissingImports, SyntaxNode namespaceScope, IEnumerable`1<INamespaceSymbol> referencedNamespaces, CancellationToken cancellationToken);
    protected virtual bool CouldCauseAmbiguity(ISet`1<INamespaceSymbol> currentImportedNamespaces, INamespaceSymbol namespaceToImport);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractImportsAdder/<GetContainingNamespacesAndThis>d__11")]
protected static IEnumerable`1<INamespaceSymbol> GetContainingNamespacesAndThis(INamespaceSymbol namespaceSymbol);
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationAbstractMethodSymbol : CodeGenerationSymbol {
    [CompilerGeneratedAttribute]
private IMethodSymbol <OriginalDefinition>k__BackingField;
    private ImmutableArray`1<AttributeData> _returnTypeAttributes;
    public IMethodSymbol OriginalDefinition { get; protected set; }
    public int Arity { get; }
    public bool ReturnsVoid { get; }
    public ITypeSymbol ReturnType { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public IMethodSymbol ConstructedFrom { get; }
    public IMethodSymbol OverriddenMethod { get; }
    public IMethodSymbol ReducedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> ExplicitInterfaceImplementations { get; }
    public IMethodSymbol PartialDefinitionPart { get; }
    public IMethodSymbol PartialImplementationPart { get; }
    public ITypeSymbol ReceiverType { get; }
    public MethodKind MethodKind { get; }
    public SymbolKind Kind { get; }
    public bool IsGenericMethod { get; }
    public bool IsExtensionMethod { get; }
    public bool IsAsync { get; }
    public bool IsVararg { get; }
    public bool IsCheckedBuiltin { get; }
    public bool HidesBaseMethodsByName { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public ISymbol AssociatedSymbol { get; }
    public INamedTypeSymbol AssociatedAnonymousDelegate { get; }
    protected CodeGenerationAbstractMethodSymbol(INamedTypeSymbol containingType, IList`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name, IList`1<AttributeData> returnTypeAttributes);
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_OriginalDefinition();
    [CompilerGeneratedAttribute]
protected void set_OriginalDefinition(IMethodSymbol value);
    public virtual ImmutableArray`1<AttributeData> GetReturnTypeAttributes();
    public abstract virtual int get_Arity();
    public abstract virtual bool get_ReturnsVoid();
    public abstract virtual ITypeSymbol get_ReturnType();
    public abstract virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public abstract virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    public abstract virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    public abstract virtual IMethodSymbol get_ConstructedFrom();
    public abstract virtual IMethodSymbol get_OverriddenMethod();
    public abstract virtual IMethodSymbol get_ReducedFrom();
    public abstract virtual ITypeSymbol GetTypeInferredDuringReduction(ITypeParameterSymbol reducedFromTypeParameter);
    public abstract virtual IMethodSymbol ReduceExtensionMethod(ITypeSymbol receiverType);
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_ExplicitInterfaceImplementations();
    public abstract virtual IMethodSymbol get_PartialDefinitionPart();
    public abstract virtual IMethodSymbol get_PartialImplementationPart();
    public virtual ITypeSymbol get_ReceiverType();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual MethodKind get_MethodKind();
    public virtual SymbolKind get_Kind();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsExtensionMethod();
    public virtual bool get_IsAsync();
    public virtual bool get_IsVararg();
    public sealed virtual bool get_IsCheckedBuiltin();
    public virtual bool get_HidesBaseMethodsByName();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual ISymbol get_AssociatedSymbol();
    public sealed virtual INamedTypeSymbol get_AssociatedAnonymousDelegate();
    public sealed virtual IMethodSymbol Construct(ITypeSymbol[] typeArguments);
    public sealed virtual DllImportData GetDllImportData();
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationAbstractNamedTypeSymbol : CodeGenerationTypeSymbol {
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <OriginalDefinition>k__BackingField;
    internal IList`1<CodeGenerationAbstractNamedTypeSymbol> TypeMembers;
    public INamedTypeSymbol OriginalDefinition { get; protected set; }
    public SymbolKind Kind { get; }
    public int Arity { get; }
    public bool IsGenericType { get; }
    public bool IsUnboundGenericType { get; }
    public bool IsScriptClass { get; }
    public bool IsImplicitClass { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public IMethodSymbol DelegateInvokeMethod { get; }
    public INamedTypeSymbol EnumUnderlyingType { get; }
    public INamedTypeSymbol ConstructedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> InstanceConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> StaticConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> Constructors { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public string MetadataName { get; }
    public ISymbol AssociatedSymbol { get; }
    public bool MightContainExtensionMethods { get; }
    protected CodeGenerationAbstractNamedTypeSymbol(INamedTypeSymbol containingType, IList`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name, SpecialType specialType, IList`1<CodeGenerationAbstractNamedTypeSymbol> typeMembers);
    [CompilerGeneratedAttribute]
public sealed virtual INamedTypeSymbol get_OriginalDefinition();
    [CompilerGeneratedAttribute]
protected void set_OriginalDefinition(INamedTypeSymbol value);
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public sealed virtual INamedTypeSymbol Construct(ITypeSymbol[] typeArguments);
    public abstract virtual int get_Arity();
    public abstract virtual bool get_IsGenericType();
    public abstract virtual bool get_IsUnboundGenericType();
    public abstract virtual bool get_IsScriptClass();
    public abstract virtual bool get_IsImplicitClass();
    public abstract virtual IEnumerable`1<string> get_MemberNames();
    public abstract virtual IMethodSymbol get_DelegateInvokeMethod();
    public abstract virtual INamedTypeSymbol get_EnumUnderlyingType();
    public abstract virtual INamedTypeSymbol get_ConstructedFrom();
    public abstract virtual INamedTypeSymbol ConstructUnboundGenericType();
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_InstanceConstructors();
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_StaticConstructors();
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_Constructors();
    public abstract virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public abstract virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    public virtual string get_MetadataName();
    public sealed virtual ISymbol get_AssociatedSymbol();
    public sealed virtual bool get_MightContainExtensionMethods();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationArrayTypeSymbol : CodeGenerationTypeSymbol {
    [CompilerGeneratedAttribute]
private ITypeSymbol <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Rank>k__BackingField;
    public ITypeSymbol ElementType { get; }
    public int Rank { get; }
    public TypeKind TypeKind { get; }
    public SymbolKind Kind { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public CodeGenerationArrayTypeSymbol(ITypeSymbol elementType, int rank);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_ElementType();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Rank();
    protected virtual CodeGenerationSymbol Clone();
    public virtual TypeKind get_TypeKind();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public sealed virtual bool Equals(IArrayTypeSymbol other);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationAttributeData : AttributeData {
    private INamedTypeSymbol _attributeClass;
    private ImmutableArray`1<TypedConstant> _constructorArguments;
    private ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> _namedArguments;
    protected INamedTypeSymbol CommonAttributeClass { get; }
    protected IMethodSymbol CommonAttributeConstructor { get; }
    protected ImmutableArray`1<TypedConstant> CommonConstructorArguments { get; }
    protected ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> CommonNamedArguments { get; }
    protected SyntaxReference CommonApplicationSyntaxReference { get; }
    public CodeGenerationAttributeData(INamedTypeSymbol attributeClass, ImmutableArray`1<TypedConstant> constructorArguments, ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArguments);
    protected virtual INamedTypeSymbol get_CommonAttributeClass();
    protected virtual IMethodSymbol get_CommonAttributeConstructor();
    protected virtual ImmutableArray`1<TypedConstant> get_CommonConstructorArguments();
    protected virtual ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> get_CommonNamedArguments();
    protected virtual SyntaxReference get_CommonApplicationSyntaxReference();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConstructedMethodSymbol : CodeGenerationAbstractMethodSymbol {
    private CodeGenerationAbstractMethodSymbol _constructedFrom;
    private ITypeSymbol[] _typeArguments;
    public int Arity { get; }
    public bool ReturnsVoid { get; }
    public ITypeSymbol ReturnType { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public IMethodSymbol ConstructedFrom { get; }
    public IMethodSymbol OverriddenMethod { get; }
    public IMethodSymbol ReducedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> ExplicitInterfaceImplementations { get; }
    public IMethodSymbol PartialDefinitionPart { get; }
    public IMethodSymbol PartialImplementationPart { get; }
    public CodeGenerationConstructedMethodSymbol(CodeGenerationAbstractMethodSymbol constructedFrom, ITypeSymbol[] typeArguments);
    public virtual int get_Arity();
    public virtual bool get_ReturnsVoid();
    public virtual ITypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    public virtual IMethodSymbol get_ConstructedFrom();
    public virtual IMethodSymbol get_OverriddenMethod();
    public virtual IMethodSymbol get_ReducedFrom();
    public virtual ITypeSymbol GetTypeInferredDuringReduction(ITypeParameterSymbol reducedFromTypeParameter);
    public virtual IMethodSymbol ReduceExtensionMethod(ITypeSymbol receiverType);
    public virtual ImmutableArray`1<IMethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual IMethodSymbol get_PartialDefinitionPart();
    public virtual IMethodSymbol get_PartialImplementationPart();
    protected virtual CodeGenerationSymbol Clone();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConstructedNamedTypeSymbol : CodeGenerationAbstractNamedTypeSymbol {
    private CodeGenerationAbstractNamedTypeSymbol _constructedFrom;
    private IList`1<ITypeSymbol> _typeArguments;
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public int Arity { get; }
    public bool IsGenericType { get; }
    public bool IsUnboundGenericType { get; }
    public bool IsScriptClass { get; }
    public bool IsImplicitClass { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public IMethodSymbol DelegateInvokeMethod { get; }
    public INamedTypeSymbol EnumUnderlyingType { get; }
    public INamedTypeSymbol ConstructedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> InstanceConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> StaticConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> Constructors { get; }
    public TypeKind TypeKind { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public CodeGenerationConstructedNamedTypeSymbol(CodeGenerationAbstractNamedTypeSymbol constructedFrom, IList`1<ITypeSymbol> typeArguments, IList`1<CodeGenerationAbstractNamedTypeSymbol> typeMembers);
    public virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public virtual int get_Arity();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsUnboundGenericType();
    public virtual bool get_IsScriptClass();
    public virtual bool get_IsImplicitClass();
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual IMethodSymbol get_DelegateInvokeMethod();
    public virtual INamedTypeSymbol get_EnumUnderlyingType();
    public virtual INamedTypeSymbol get_ConstructedFrom();
    public virtual INamedTypeSymbol ConstructUnboundGenericType();
    public virtual ImmutableArray`1<IMethodSymbol> get_InstanceConstructors();
    public virtual ImmutableArray`1<IMethodSymbol> get_StaticConstructors();
    public virtual ImmutableArray`1<IMethodSymbol> get_Constructors();
    public virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers();
    public virtual TypeKind get_TypeKind();
    protected virtual CodeGenerationSymbol Clone();
    public virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConstructorInfo : object {
    private static ConditionalWeakTable`2<IMethodSymbol, CodeGenerationConstructorInfo> s_constructorToInfoMap;
    private string _typeName;
    private IList`1<SyntaxNode> _baseConstructorArguments;
    private IList`1<SyntaxNode> _thisConstructorArguments;
    private IList`1<SyntaxNode> _statements;
    private CodeGenerationConstructorInfo(string typeName, IList`1<SyntaxNode> statements, IList`1<SyntaxNode> baseConstructorArguments, IList`1<SyntaxNode> thisConstructorArguments);
    private static CodeGenerationConstructorInfo();
    public static void Attach(IMethodSymbol constructor, string typeName, IList`1<SyntaxNode> statements, IList`1<SyntaxNode> baseConstructorArguments, IList`1<SyntaxNode> thisConstructorArguments);
    private static CodeGenerationConstructorInfo GetInfo(IMethodSymbol method);
    public static IList`1<SyntaxNode> GetThisConstructorArgumentsOpt(IMethodSymbol constructor);
    public static IList`1<SyntaxNode> GetBaseConstructorArgumentsOpt(IMethodSymbol constructor);
    public static IList`1<SyntaxNode> GetStatements(IMethodSymbol constructor);
    public static string GetTypeName(IMethodSymbol constructor);
    private static IList`1<SyntaxNode> GetThisConstructorArgumentsOpt(CodeGenerationConstructorInfo info);
    private static IList`1<SyntaxNode> GetBaseConstructorArgumentsOpt(CodeGenerationConstructorInfo info);
    private static IList`1<SyntaxNode> GetStatements(CodeGenerationConstructorInfo info);
    private static string GetTypeName(CodeGenerationConstructorInfo info, IMethodSymbol constructor);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConstructorSymbol : CodeGenerationMethodSymbol {
    public MethodKind MethodKind { get; }
    public CodeGenerationConstructorSymbol(INamedTypeSymbol containingType, IList`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, IList`1<IParameterSymbol> parameters);
    public virtual MethodKind get_MethodKind();
    protected virtual CodeGenerationSymbol Clone();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConversionSymbol : CodeGenerationMethodSymbol {
    public MethodKind MethodKind { get; }
    public CodeGenerationConversionSymbol(INamedTypeSymbol containingType, IList`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, ITypeSymbol toType, IParameterSymbol fromType, bool isImplicit, IList`1<AttributeData> toTypeAttributes);
    public virtual MethodKind get_MethodKind();
}
internal enum Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination : Enum {
    public int value__;
    public static CodeGenerationDestination Unspecified;
    public static CodeGenerationDestination CompilationUnit;
    public static CodeGenerationDestination Namespace;
    public static CodeGenerationDestination ClassType;
    public static CodeGenerationDestination EnumType;
    public static CodeGenerationDestination InterfaceType;
    public static CodeGenerationDestination ModuleType;
    public static CodeGenerationDestination StructType;
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestructorInfo : object {
    private static ConditionalWeakTable`2<IMethodSymbol, CodeGenerationDestructorInfo> s_destructorToInfoMap;
    private string _typeName;
    private IList`1<SyntaxNode> _statements;
    private CodeGenerationDestructorInfo(string typeName, IList`1<SyntaxNode> statements);
    private static CodeGenerationDestructorInfo();
    public static void Attach(IMethodSymbol destructor, string typeName, IList`1<SyntaxNode> statements);
    private static CodeGenerationDestructorInfo GetInfo(IMethodSymbol method);
    public static IList`1<SyntaxNode> GetStatements(IMethodSymbol destructor);
    public static string GetTypeName(IMethodSymbol destructor);
    private static IList`1<SyntaxNode> GetStatements(CodeGenerationDestructorInfo info);
    private static string GetTypeName(CodeGenerationDestructorInfo info, IMethodSymbol constructor);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestructorSymbol : CodeGenerationMethodSymbol {
    public MethodKind MethodKind { get; }
    public CodeGenerationDestructorSymbol(INamedTypeSymbol containingType, IList`1<AttributeData> attributes);
    public virtual MethodKind get_MethodKind();
    protected virtual CodeGenerationSymbol Clone();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationEventInfo : object {
    private static ConditionalWeakTable`2<IEventSymbol, CodeGenerationEventInfo> s_eventToInfoMap;
    private bool _isUnsafe;
    private CodeGenerationEventInfo(bool isUnsafe);
    private static CodeGenerationEventInfo();
    public static void Attach(IEventSymbol event, bool isUnsafe);
    private static CodeGenerationEventInfo GetInfo(IEventSymbol event);
    public static bool GetIsUnsafe(IEventSymbol event);
    private static bool GetIsUnsafe(CodeGenerationEventInfo info);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationEventSymbol : CodeGenerationSymbol {
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IEventSymbol> <ExplicitInterfaceImplementations>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <AddMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <RemoveMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <RaiseMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IParameterSymbol> <ParameterList>k__BackingField;
    public ITypeSymbol Type { get; }
    public bool IsWindowsRuntimeEvent { get; }
    public ImmutableArray`1<IEventSymbol> ExplicitInterfaceImplementations { get; }
    public IMethodSymbol AddMethod { get; }
    public IMethodSymbol RemoveMethod { get; }
    public IMethodSymbol RaiseMethod { get; }
    public IList`1<IParameterSymbol> ParameterList { get; }
    public SymbolKind Kind { get; }
    public IEventSymbol OriginalDefinition { get; }
    public IEventSymbol OverriddenEvent { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public CodeGenerationEventSymbol(INamedTypeSymbol containingType, IList`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, ITypeSymbol type, IEventSymbol explicitInterfaceSymbolOpt, string name, IMethodSymbol addMethod, IMethodSymbol removeMethod, IMethodSymbol raiseMethod, IList`1<IParameterSymbol> parameterList);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_Type();
    public sealed virtual bool get_IsWindowsRuntimeEvent();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IEventSymbol> get_ExplicitInterfaceImplementations();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_AddMethod();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_RemoveMethod();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_RaiseMethod();
    [CompilerGeneratedAttribute]
public IList`1<IParameterSymbol> get_ParameterList();
    protected virtual CodeGenerationSymbol Clone();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public sealed virtual IEventSymbol get_OriginalDefinition();
    public sealed virtual IEventSymbol get_OverriddenEvent();
    public ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationFieldInfo : object {
    private static ConditionalWeakTable`2<IFieldSymbol, CodeGenerationFieldInfo> s_fieldToInfoMap;
    private bool _isUnsafe;
    private bool _isWithEvents;
    private SyntaxNode _initializer;
    private CodeGenerationFieldInfo(bool isUnsafe, bool isWithEvents, SyntaxNode initializer);
    private static CodeGenerationFieldInfo();
    public static void Attach(IFieldSymbol field, bool isUnsafe, bool isWithEvents, SyntaxNode initializer);
    private static CodeGenerationFieldInfo GetInfo(IFieldSymbol field);
    private static bool GetIsUnsafe(CodeGenerationFieldInfo info);
    public static bool GetIsUnsafe(IFieldSymbol field);
    private static bool GetIsWithEvents(CodeGenerationFieldInfo info);
    public static bool GetIsWithEvents(IFieldSymbol field);
    private static SyntaxNode GetInitializer(CodeGenerationFieldInfo info);
    public static SyntaxNode GetInitializer(IFieldSymbol field);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationFieldSymbol : CodeGenerationSymbol {
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ConstantValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasConstantValue>k__BackingField;
    public ITypeSymbol Type { get; }
    public object ConstantValue { get; }
    public bool HasConstantValue { get; }
    public IFieldSymbol OriginalDefinition { get; }
    public SymbolKind Kind { get; }
    public bool IsConst { get; }
    public bool IsReadOnly { get; }
    public bool IsVolatile { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public ISymbol AssociatedSymbol { get; }
    public CodeGenerationFieldSymbol(INamedTypeSymbol containingType, IList`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, string name, bool hasConstantValue, object constantValue);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual object get_ConstantValue();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasConstantValue();
    protected virtual CodeGenerationSymbol Clone();
    public sealed virtual IFieldSymbol get_OriginalDefinition();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public sealed virtual bool get_IsConst();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public sealed virtual ISymbol get_AssociatedSymbol();
}
internal static class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationHelpers : object {
    public static SyntaxNode GenerateThrowStatement(SyntaxGenerator factory, SemanticDocument document, string exceptionMetadataName, CancellationToken cancellationToken);
    public static TSyntaxNode AddAnnotationsTo(ISymbol symbol, TSyntaxNode syntax);
    public static TSyntaxNode AddCleanupAnnotationsTo(TSyntaxNode node);
    public static void CheckNodeType(SyntaxNode node, string argumentName);
    public static void GetNameAndInnermostNamespace(INamespaceSymbol namespace, CodeGenerationOptions options, String& name, INamespaceSymbol& innermostNamespace);
    public static bool IsSpecialType(ITypeSymbol type, SpecialType specialType);
    public static int GetPreferredIndex(int index, IList`1<bool> availableIndices, bool forward);
    public static bool TryGetDocumentationComment(ISymbol symbol, string commentToken, String& comment, CancellationToken cancellationToken);
    public static bool TypesMatch(ITypeSymbol type, object value);
    public static IEnumerable`1<ISymbol> GetMembers(INamedTypeSymbol namedType);
    public static T GetReuseableSyntaxNodeForSymbol(ISymbol symbol, CodeGenerationOptions options);
    public static T GetReuseableSyntaxNodeForAttribute(AttributeData attribute, CodeGenerationOptions options);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationMethodInfo : object {
    private static ConditionalWeakTable`2<IMethodSymbol, CodeGenerationMethodInfo> s_methodToInfoMap;
    private bool _isNew;
    private bool _isUnsafe;
    private bool _isPartial;
    private bool _isAsync;
    private IList`1<SyntaxNode> _statements;
    private IList`1<SyntaxNode> _handlesExpressions;
    private CodeGenerationMethodInfo(bool isNew, bool isUnsafe, bool isPartial, bool isAsync, IList`1<SyntaxNode> statements, IList`1<SyntaxNode> handlesExpressions);
    private static CodeGenerationMethodInfo();
    public static void Attach(IMethodSymbol method, bool isNew, bool isUnsafe, bool isPartial, bool isAsync, IList`1<SyntaxNode> statements, IList`1<SyntaxNode> handlesExpressions);
    private static CodeGenerationMethodInfo GetInfo(IMethodSymbol method);
    public static IList`1<SyntaxNode> GetStatements(IMethodSymbol method);
    public static IList`1<SyntaxNode> GetHandlesExpressions(IMethodSymbol method);
    public static bool GetIsNew(IMethodSymbol method);
    public static bool GetIsUnsafe(IMethodSymbol method);
    public static bool GetIsPartial(IMethodSymbol method);
    public static bool GetIsAsync(IMethodSymbol method);
    private static IList`1<SyntaxNode> GetStatements(CodeGenerationMethodInfo info);
    private static IList`1<SyntaxNode> GetHandlesExpressions(CodeGenerationMethodInfo info);
    private static bool GetIsNew(CodeGenerationMethodInfo info);
    private static bool GetIsUnsafe(CodeGenerationMethodInfo info);
    private static bool GetIsPartial(CodeGenerationMethodInfo info);
    private static bool GetIsAsync(CodeGenerationMethodInfo info);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationMethodSymbol : CodeGenerationAbstractMethodSymbol {
    private ITypeSymbol _returnType;
    private ImmutableArray`1<ITypeParameterSymbol> _typeParameters;
    private ImmutableArray`1<IParameterSymbol> _parameters;
    private ImmutableArray`1<IMethodSymbol> _explicitInterfaceImplementations;
    private MethodKind _methodKind;
    public ITypeSymbol ReturnType { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public ImmutableArray`1<IMethodSymbol> ExplicitInterfaceImplementations { get; }
    public int Arity { get; }
    public bool ReturnsVoid { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public IMethodSymbol ConstructedFrom { get; }
    public IMethodSymbol OverriddenMethod { get; }
    public IMethodSymbol ReducedFrom { get; }
    public MethodKind MethodKind { get; }
    public IMethodSymbol PartialImplementationPart { get; }
    public IMethodSymbol PartialDefinitionPart { get; }
    public CodeGenerationMethodSymbol(INamedTypeSymbol containingType, IList`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, IMethodSymbol explicitInterfaceSymbolOpt, string name, IList`1<ITypeParameterSymbol> typeParameters, IList`1<IParameterSymbol> parameters, IList`1<AttributeData> returnTypeAttributes, MethodKind methodKind);
    public virtual ITypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    public virtual ImmutableArray`1<IMethodSymbol> get_ExplicitInterfaceImplementations();
    protected virtual CodeGenerationSymbol Clone();
    public virtual int get_Arity();
    public virtual bool get_ReturnsVoid();
    public virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public virtual IMethodSymbol get_ConstructedFrom();
    public virtual IMethodSymbol get_OverriddenMethod();
    public virtual IMethodSymbol get_ReducedFrom();
    public virtual MethodKind get_MethodKind();
    public virtual ITypeSymbol GetTypeInferredDuringReduction(ITypeParameterSymbol reducedFromTypeParameter);
    public virtual IMethodSymbol ReduceExtensionMethod(ITypeSymbol receiverType);
    public virtual IMethodSymbol get_PartialImplementationPart();
    public virtual IMethodSymbol get_PartialDefinitionPart();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationNamedTypeSymbol : CodeGenerationAbstractNamedTypeSymbol {
    private TypeKind _typeKind;
    private IList`1<ITypeParameterSymbol> _typeParameters;
    private INamedTypeSymbol _baseType;
    private IList`1<INamedTypeSymbol> _interfaces;
    private IList`1<ISymbol> _members;
    private INamedTypeSymbol _enumUnderlyingType;
    public TypeKind TypeKind { get; }
    public SymbolKind Kind { get; }
    public int Arity { get; }
    public bool IsGenericType { get; }
    public bool IsUnboundGenericType { get; }
    public bool IsScriptClass { get; }
    public bool IsImplicitClass { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public IMethodSymbol DelegateInvokeMethod { get; }
    public INamedTypeSymbol EnumUnderlyingType { get; }
    public INamedTypeSymbol ConstructedFrom { get; }
    public ImmutableArray`1<ISymbol> CandidateSymbols { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public INamedTypeSymbol BaseType { get; }
    public ImmutableArray`1<INamedTypeSymbol> Interfaces { get; }
    public ImmutableArray`1<IMethodSymbol> InstanceConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> StaticConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> Constructors { get; }
    public CodeGenerationNamedTypeSymbol(INamedTypeSymbol containingType, IList`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, TypeKind typeKind, string name, IList`1<ITypeParameterSymbol> typeParameters, INamedTypeSymbol baseType, IList`1<INamedTypeSymbol> interfaces, SpecialType specialType, IList`1<ISymbol> members, IList`1<CodeGenerationAbstractNamedTypeSymbol> typeMembers, INamedTypeSymbol enumUnderlyingType);
    protected virtual CodeGenerationSymbol Clone();
    public virtual TypeKind get_TypeKind();
    public virtual SymbolKind get_Kind();
    public virtual int get_Arity();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsUnboundGenericType();
    public virtual bool get_IsScriptClass();
    public virtual bool get_IsImplicitClass();
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual IMethodSymbol get_DelegateInvokeMethod();
    public virtual INamedTypeSymbol get_EnumUnderlyingType();
    public virtual INamedTypeSymbol get_ConstructedFrom();
    public virtual INamedTypeSymbol ConstructUnboundGenericType();
    public ImmutableArray`1<ISymbol> get_CandidateSymbols();
    public virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    public virtual INamedTypeSymbol get_BaseType();
    public virtual ImmutableArray`1<INamedTypeSymbol> get_Interfaces();
    public virtual ImmutableArray`1<ISymbol> GetMembers();
    public virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<IMethodSymbol> get_InstanceConstructors();
    public virtual ImmutableArray`1<IMethodSymbol> get_StaticConstructors();
    public virtual ImmutableArray`1<IMethodSymbol> get_Constructors();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationNamespaceInfo : object {
    private static ConditionalWeakTable`2<INamespaceSymbol, CodeGenerationNamespaceInfo> s_namespaceToInfoMap;
    private IList`1<ISymbol> _imports;
    private CodeGenerationNamespaceInfo(IList`1<ISymbol> imports);
    private static CodeGenerationNamespaceInfo();
    public static void Attach(INamespaceSymbol namespace, IList`1<ISymbol> imports);
    private static CodeGenerationNamespaceInfo GetInfo(INamespaceSymbol namespace);
    public static IList`1<ISymbol> GetImports(INamespaceSymbol namespace);
    private static IList`1<ISymbol> GetImports(CodeGenerationNamespaceInfo info);
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationNamespaceOrTypeSymbol : CodeGenerationSymbol {
    public bool IsNamespace { get; }
    public bool IsType { get; }
    protected CodeGenerationNamespaceOrTypeSymbol(INamedTypeSymbol containingType, IList`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name);
    public virtual ImmutableArray`1<ISymbol> GetMembers();
    public sealed virtual ImmutableArray`1<ISymbol> GetMembers(string name);
    public virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers();
    public sealed virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers(string name);
    public sealed virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers(string name, int arity);
    public abstract virtual bool get_IsNamespace();
    public abstract virtual bool get_IsType();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationNamespaceSymbol : CodeGenerationNamespaceOrTypeSymbol {
    private IList`1<INamespaceOrTypeSymbol> _members;
    public bool IsNamespace { get; }
    public bool IsType { get; }
    public SymbolKind Kind { get; }
    public bool IsGlobalNamespace { get; }
    public NamespaceKind NamespaceKind { get; }
    public Compilation ContainingCompilation { get; }
    public INamedTypeSymbol ImplicitType { get; }
    public ImmutableArray`1<INamespaceSymbol> ConstituentNamespaces { get; }
    public CodeGenerationNamespaceSymbol(string name, IList`1<INamespaceOrTypeSymbol> members);
    public virtual bool get_IsNamespace();
    public virtual bool get_IsType();
    protected virtual CodeGenerationSymbol Clone();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public sealed virtual IEnumerable`1<INamespaceOrTypeSymbol> GetMembers();
    private sealed virtual override IEnumerable`1<INamespaceOrTypeSymbol> Microsoft.CodeAnalysis.INamespaceSymbol.GetMembers(string name);
    public sealed virtual IEnumerable`1<INamespaceSymbol> GetNamespaceMembers();
    public sealed virtual bool get_IsGlobalNamespace();
    public sealed virtual NamespaceKind get_NamespaceKind();
    public sealed virtual Compilation get_ContainingCompilation();
    public INamedTypeSymbol get_ImplicitType();
    public sealed virtual ImmutableArray`1<INamespaceSymbol> get_ConstituentNamespaces();
}
internal enum Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOperatorKind : Enum {
    public int value__;
    public static CodeGenerationOperatorKind Addition;
    public static CodeGenerationOperatorKind BitwiseAnd;
    public static CodeGenerationOperatorKind BitwiseOr;
    public static CodeGenerationOperatorKind Concatenate;
    public static CodeGenerationOperatorKind Decrement;
    public static CodeGenerationOperatorKind Division;
    public static CodeGenerationOperatorKind Equality;
    public static CodeGenerationOperatorKind ExclusiveOr;
    public static CodeGenerationOperatorKind Exponent;
    public static CodeGenerationOperatorKind False;
    public static CodeGenerationOperatorKind GreaterThan;
    public static CodeGenerationOperatorKind GreaterThanOrEqual;
    public static CodeGenerationOperatorKind Increment;
    public static CodeGenerationOperatorKind Inequality;
    public static CodeGenerationOperatorKind IntegerDivision;
    public static CodeGenerationOperatorKind LeftShift;
    public static CodeGenerationOperatorKind LessThan;
    public static CodeGenerationOperatorKind LessThanOrEqual;
    public static CodeGenerationOperatorKind Like;
    public static CodeGenerationOperatorKind LogicalNot;
    public static CodeGenerationOperatorKind Modulus;
    public static CodeGenerationOperatorKind Multiplication;
    public static CodeGenerationOperatorKind OnesComplement;
    public static CodeGenerationOperatorKind RightShift;
    public static CodeGenerationOperatorKind Subtraction;
    public static CodeGenerationOperatorKind True;
    public static CodeGenerationOperatorKind UnaryPlus;
    public static CodeGenerationOperatorKind UnaryNegation;
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOperatorSymbol : CodeGenerationMethodSymbol {
    public MethodKind MethodKind { get; }
    public CodeGenerationOperatorSymbol(INamedTypeSymbol containingType, IList`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, CodeGenerationOperatorKind operatorKind, IList`1<IParameterSymbol> parameters, IList`1<AttributeData> returnTypeAttributes);
    public virtual MethodKind get_MethodKind();
    public static int GetParameterCount(CodeGenerationOperatorKind operatorKind);
    private static string GetMetadataName(CodeGenerationOperatorKind operatorKind);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions : object {
    public static CodeGenerationOptions Default;
    [CompilerGeneratedAttribute]
private Location <ContextLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <AfterThisLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <BeforeThisLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddImports>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PlaceSystemNamespaceFirst>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<INamespaceSymbol> <AdditionalImports>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MergeNestedNamespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MergeAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateDefaultAccessibility>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateMethodBodies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateDocumentationComments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoInsertionLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReuseSyntax>k__BackingField;
    public Location ContextLocation { get; }
    public Location AfterThisLocation { get; }
    public Location BeforeThisLocation { get; }
    public bool AddImports { get; }
    public bool PlaceSystemNamespaceFirst { get; }
    public IEnumerable`1<INamespaceSymbol> AdditionalImports { get; }
    public bool GenerateMembers { get; }
    public bool MergeNestedNamespaces { get; }
    public bool MergeAttributes { get; }
    public bool GenerateDefaultAccessibility { get; }
    public bool GenerateMethodBodies { get; }
    public bool GenerateDocumentationComments { get; }
    public bool AutoInsertionLocation { get; }
    public bool ReuseSyntax { get; }
    internal Location BestLocation { get; }
    public CodeGenerationOptions(Location contextLocation, Location afterThisLocation, Location beforeThisLocation, bool addImports, bool placeSystemNamespaceFirst, IEnumerable`1<INamespaceSymbol> additionalImports, bool generateMembers, bool mergeNestedNamespaces, bool mergeAttributes, bool generateDefaultAccessibility, bool generateMethodBodies, bool generateDocumentationComments, bool autoInsertionLocation, bool reuseSyntax);
    private static CodeGenerationOptions();
    [CompilerGeneratedAttribute]
public Location get_ContextLocation();
    [CompilerGeneratedAttribute]
public Location get_AfterThisLocation();
    [CompilerGeneratedAttribute]
public Location get_BeforeThisLocation();
    [CompilerGeneratedAttribute]
public bool get_AddImports();
    [CompilerGeneratedAttribute]
public bool get_PlaceSystemNamespaceFirst();
    [CompilerGeneratedAttribute]
public IEnumerable`1<INamespaceSymbol> get_AdditionalImports();
    [CompilerGeneratedAttribute]
public bool get_GenerateMembers();
    [CompilerGeneratedAttribute]
public bool get_MergeNestedNamespaces();
    [CompilerGeneratedAttribute]
public bool get_MergeAttributes();
    [CompilerGeneratedAttribute]
public bool get_GenerateDefaultAccessibility();
    [CompilerGeneratedAttribute]
public bool get_GenerateMethodBodies();
    [CompilerGeneratedAttribute]
public bool get_GenerateDocumentationComments();
    [CompilerGeneratedAttribute]
public bool get_AutoInsertionLocation();
    [CompilerGeneratedAttribute]
public bool get_ReuseSyntax();
    private void CheckLocation(Location location, string name);
    internal Location get_BestLocation();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationParameterSymbol : CodeGenerationSymbol {
    [CompilerGeneratedAttribute]
private RefKind <RefKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParams>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Ordinal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasExplicitDefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ExplicitDefaultValue>k__BackingField;
    public RefKind RefKind { get; }
    public bool IsParams { get; }
    public ITypeSymbol Type { get; }
    public bool IsOptional { get; }
    public int Ordinal { get; }
    public bool HasExplicitDefaultValue { get; }
    public object ExplicitDefaultValue { get; }
    public IParameterSymbol OriginalDefinition { get; }
    public SymbolKind Kind { get; }
    public bool IsThis { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public CodeGenerationParameterSymbol(INamedTypeSymbol containingType, IList`1<AttributeData> attributes, RefKind refKind, bool isParams, ITypeSymbol type, string name, bool isOptional, bool hasDefaultValue, object defaultValue);
    [CompilerGeneratedAttribute]
public sealed virtual RefKind get_RefKind();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsParams();
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsOptional();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Ordinal();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasExplicitDefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual object get_ExplicitDefaultValue();
    protected virtual CodeGenerationSymbol Clone();
    public sealed virtual IParameterSymbol get_OriginalDefinition();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public sealed virtual bool get_IsThis();
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationPointerTypeSymbol : CodeGenerationTypeSymbol {
    [CompilerGeneratedAttribute]
private ITypeSymbol <PointedAtType>k__BackingField;
    public ITypeSymbol PointedAtType { get; }
    public TypeKind TypeKind { get; }
    public SymbolKind Kind { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public CodeGenerationPointerTypeSymbol(ITypeSymbol pointedAtType);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_PointedAtType();
    protected virtual CodeGenerationSymbol Clone();
    public virtual TypeKind get_TypeKind();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationPropertyInfo : object {
    private static ConditionalWeakTable`2<IPropertySymbol, CodeGenerationPropertyInfo> s_propertyToInfoMap;
    private bool _isNew;
    private bool _isUnsafe;
    private SyntaxNode _initializer;
    private CodeGenerationPropertyInfo(bool isNew, bool isUnsafe, SyntaxNode initializer);
    private static CodeGenerationPropertyInfo();
    public static void Attach(IPropertySymbol property, bool isNew, bool isUnsafe, SyntaxNode initializer);
    private static CodeGenerationPropertyInfo GetInfo(IPropertySymbol property);
    public static SyntaxNode GetInitializer(CodeGenerationPropertyInfo info);
    public static SyntaxNode GetInitializer(IPropertySymbol property);
    public static bool GetIsNew(IPropertySymbol property);
    public static bool GetIsUnsafe(IPropertySymbol property);
    private static bool GetIsNew(CodeGenerationPropertyInfo info);
    private static bool GetIsUnsafe(CodeGenerationPropertyInfo info);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationPropertySymbol : CodeGenerationSymbol {
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIndexer>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IParameterSymbol> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IPropertySymbol> <ExplicitInterfaceImplementations>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <GetMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <SetMethod>k__BackingField;
    public ITypeSymbol Type { get; }
    public bool IsIndexer { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public ImmutableArray`1<IPropertySymbol> ExplicitInterfaceImplementations { get; }
    public IMethodSymbol GetMethod { get; }
    public IMethodSymbol SetMethod { get; }
    public SymbolKind Kind { get; }
    public bool IsReadOnly { get; }
    public bool IsWriteOnly { get; }
    public IPropertySymbol OriginalDefinition { get; }
    public IPropertySymbol OverriddenProperty { get; }
    public bool IsWithEvents { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public CodeGenerationPropertySymbol(INamedTypeSymbol containingType, IList`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, ITypeSymbol type, IPropertySymbol explicitInterfaceSymbolOpt, string name, bool isIndexer, IList`1<IParameterSymbol> parametersOpt, IMethodSymbol getMethod, IMethodSymbol setMethod);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsIndexer();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IPropertySymbol> get_ExplicitInterfaceImplementations();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_GetMethod();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_SetMethod();
    protected virtual CodeGenerationSymbol Clone();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsWriteOnly();
    public sealed virtual IPropertySymbol get_OriginalDefinition();
    public sealed virtual IPropertySymbol get_OverriddenProperty();
    public sealed virtual bool get_IsWithEvents();
    public sealed virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbol : object {
    protected static ConditionalWeakTable`2<CodeGenerationSymbol, SyntaxAnnotation[]> annotationsTable;
    private ImmutableArray`1<AttributeData> _attributes;
    [CompilerGeneratedAttribute]
private Accessibility <DeclaredAccessibility>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclarationModifiers <Modifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <ContainingType>k__BackingField;
    public Accessibility DeclaredAccessibility { get; }
    protected internal DeclarationModifiers Modifiers { get; }
    public string Name { get; }
    public INamedTypeSymbol ContainingType { get; protected set; }
    public SymbolKind Kind { get; }
    public string Language { get; }
    public ISymbol ContainingSymbol { get; }
    public IAssemblySymbol ContainingAssembly { get; }
    public IMethodSymbol ContainingMethod { get; }
    public IModuleSymbol ContainingModule { get; }
    public INamespaceSymbol ContainingNamespace { get; }
    public bool IsDefinition { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    public bool IsImplicitlyDeclared { get; }
    public bool CanBeReferencedByName { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxNode> DeclaringSyntaxNodes { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public ISymbol OriginalDefinition { get; }
    public string MetadataName { get; }
    public bool HasUnsupportedMetadata { get; }
    protected CodeGenerationSymbol(INamedTypeSymbol containingType, IList`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name);
    private static CodeGenerationSymbol();
    [CompilerGeneratedAttribute]
public sealed virtual Accessibility get_DeclaredAccessibility();
    [CompilerGeneratedAttribute]
protected internal DeclarationModifiers get_Modifiers();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual INamedTypeSymbol get_ContainingType();
    [CompilerGeneratedAttribute]
protected void set_ContainingType(INamedTypeSymbol value);
    protected abstract virtual CodeGenerationSymbol Clone();
    internal SyntaxAnnotation[] GetAnnotations();
    internal CodeGenerationSymbol WithAdditionalAnnotations(SyntaxAnnotation[] annotations);
    private CodeGenerationSymbol AddAnnotationsTo(CodeGenerationSymbol originalDefinition, CodeGenerationSymbol newDefinition, SyntaxAnnotation[] annotations);
    public abstract virtual SymbolKind get_Kind();
    public sealed virtual string get_Language();
    public sealed virtual ISymbol get_ContainingSymbol();
    public sealed virtual IAssemblySymbol get_ContainingAssembly();
    public IMethodSymbol get_ContainingMethod();
    public sealed virtual IModuleSymbol get_ContainingModule();
    public sealed virtual INamespaceSymbol get_ContainingNamespace();
    public sealed virtual bool get_IsDefinition();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsImplicitlyDeclared();
    public sealed virtual bool get_CanBeReferencedByName();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public ImmutableArray`1<SyntaxNode> get_DeclaringSyntaxNodes();
    public sealed virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public sealed virtual ImmutableArray`1<AttributeData> GetAttributes();
    public ImmutableArray`1<AttributeData> GetAttributes(INamedTypeSymbol attributeType);
    public ImmutableArray`1<AttributeData> GetAttributes(IMethodSymbol attributeConstructor);
    public sealed virtual ISymbol get_OriginalDefinition();
    public abstract virtual void Accept(SymbolVisitor visitor);
    public abstract virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public sealed virtual string GetDocumentationCommentId();
    public sealed virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    public sealed virtual string ToDisplayString(SymbolDisplayFormat format);
    public sealed virtual ImmutableArray`1<SymbolDisplayPart> ToDisplayParts(SymbolDisplayFormat format);
    public sealed virtual string ToMinimalDisplayString(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    public sealed virtual ImmutableArray`1<SymbolDisplayPart> ToMinimalDisplayParts(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    public SymbolKey GetSymbolId();
    public virtual string get_MetadataName();
    public sealed virtual bool get_HasUnsupportedMetadata();
    public sealed virtual bool Equals(ISymbol other);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory : object {
    [ExtensionAttribute]
public static bool IsCodeGenerationSymbol(ISymbol symbol);
    public static IEventSymbol CreateEventSymbol(IList`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, IEventSymbol explicitInterfaceSymbol, string name, IMethodSymbol addMethod, IMethodSymbol removeMethod, IMethodSymbol raiseMethod, IList`1<IParameterSymbol> parameterList);
    internal static IPropertySymbol CreatePropertySymbol(INamedTypeSymbol containingType, IList`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, IPropertySymbol explicitInterfaceSymbol, string name, IList`1<IParameterSymbol> parameters, IMethodSymbol getMethod, IMethodSymbol setMethod, bool isIndexer, SyntaxNode initializer);
    public static IPropertySymbol CreatePropertySymbol(IList`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, IPropertySymbol explicitInterfaceSymbol, string name, IList`1<IParameterSymbol> parameters, IMethodSymbol getMethod, IMethodSymbol setMethod, bool isIndexer);
    public static IFieldSymbol CreateFieldSymbol(IList`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, string name, bool hasConstantValue, object constantValue, SyntaxNode initializer);
    public static IMethodSymbol CreateConstructorSymbol(IList`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, string typeName, IList`1<IParameterSymbol> parameters, IList`1<SyntaxNode> statements, IList`1<SyntaxNode> baseConstructorArguments, IList`1<SyntaxNode> thisConstructorArguments);
    public static IMethodSymbol CreateDestructorSymbol(IList`1<AttributeData> attributes, string typeName, IList`1<SyntaxNode> statements);
    internal static IMethodSymbol CreateMethodSymbol(INamedTypeSymbol containingType, IList`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, IMethodSymbol explicitInterfaceSymbol, string name, IList`1<ITypeParameterSymbol> typeParameters, IList`1<IParameterSymbol> parameters, IList`1<SyntaxNode> statements, IList`1<SyntaxNode> handlesExpressions, IList`1<AttributeData> returnTypeAttributes, MethodKind methodKind);
    public static IMethodSymbol CreateMethodSymbol(IList`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, IMethodSymbol explicitInterfaceSymbol, string name, IList`1<ITypeParameterSymbol> typeParameters, IList`1<IParameterSymbol> parameters, IList`1<SyntaxNode> statements, IList`1<SyntaxNode> handlesExpressions, IList`1<AttributeData> returnTypeAttributes, MethodKind methodKind);
    public static IMethodSymbol CreateOperatorSymbol(IList`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, CodeGenerationOperatorKind operatorKind, IList`1<IParameterSymbol> parameters, IList`1<SyntaxNode> statements, IList`1<AttributeData> returnTypeAttributes);
    public static IMethodSymbol CreateConversionSymbol(IList`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol toType, IParameterSymbol fromType, bool isImplicit, IList`1<SyntaxNode> statements, IList`1<AttributeData> toTypeAttributes);
    public static IParameterSymbol CreateParameterSymbol(ITypeSymbol type, string name);
    public static IParameterSymbol CreateParameterSymbol(IList`1<AttributeData> attributes, RefKind refKind, bool isParams, ITypeSymbol type, string name, bool isOptional, bool hasDefaultValue, object defaultValue);
    public static ITypeParameterSymbol CreateTypeParameterSymbol(string name, int ordinal);
    public static ITypeParameterSymbol CreateTypeParameter(IList`1<AttributeData> attributes, VarianceKind varianceKind, string name, ImmutableArray`1<ITypeSymbol> constraintTypes, bool hasConstructorConstraint, bool hasReferenceConstraint, bool hasValueConstraint, int ordinal);
    public static IPointerTypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType);
    public static IArrayTypeSymbol CreateArrayTypeSymbol(ITypeSymbol elementType, int rank);
    internal static IMethodSymbol CreateAccessorSymbol(IMethodSymbol accessor, IList`1<AttributeData> attributes, Nullable`1<Accessibility> accessibility, IMethodSymbol explicitInterfaceSymbol, IList`1<SyntaxNode> statements);
    public static IMethodSymbol CreateAccessorSymbol(IList`1<AttributeData> attributes, Accessibility accessibility, IList`1<SyntaxNode> statements);
    public static AttributeData CreateAttributeData(INamedTypeSymbol attributeClass, ImmutableArray`1<TypedConstant> constructorArguments, ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArguments);
    public static INamedTypeSymbol CreateNamedTypeSymbol(IList`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, TypeKind typeKind, string name, IList`1<ITypeParameterSymbol> typeParameters, INamedTypeSymbol baseType, IList`1<INamedTypeSymbol> interfaces, SpecialType specialType, IList`1<ISymbol> members);
    public static INamedTypeSymbol CreateDelegateTypeSymbol(IList`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, string name, IList`1<ITypeParameterSymbol> typeParameters, IList`1<IParameterSymbol> parameters);
    public static INamespaceSymbol CreateNamespaceSymbol(string name, IList`1<ISymbol> imports, IList`1<INamespaceOrTypeSymbol> members);
    internal static IMethodSymbol CreateMethodSymbol(IMethodSymbol method, IList`1<AttributeData> attributes, Nullable`1<Accessibility> accessibility, Nullable`1<DeclarationModifiers> modifiers, IMethodSymbol explicitInterfaceSymbol, string name, IList`1<SyntaxNode> statements);
    internal static IPropertySymbol CreatePropertySymbol(IPropertySymbol property, IList`1<AttributeData> attributes, Nullable`1<Accessibility> accessibility, Nullable`1<DeclarationModifiers> modifiers, IPropertySymbol explicitInterfaceSymbol, string name, Nullable`1<bool> isIndexer, IMethodSymbol getMethod, IMethodSymbol setMethod);
    internal static IEventSymbol CreateEventSymbol(IEventSymbol event, IList`1<AttributeData> attributes, Nullable`1<Accessibility> accessibility, Nullable`1<DeclarationModifiers> modifiers, IEventSymbol explicitInterfaceSymbol, string name, IMethodSymbol addMethod, IMethodSymbol removeMethod);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationTypeParameterSymbol : CodeGenerationTypeSymbol {
    [CompilerGeneratedAttribute]
private VarianceKind <Variance>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ITypeSymbol> <ConstraintTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasConstructorConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasReferenceTypeConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValueTypeConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Ordinal>k__BackingField;
    public VarianceKind Variance { get; }
    public ImmutableArray`1<ITypeSymbol> ConstraintTypes { get; internal set; }
    public bool HasConstructorConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public int Ordinal { get; }
    public ITypeParameterSymbol OriginalDefinition { get; }
    public ITypeParameterSymbol ReducedFrom { get; }
    public SymbolKind Kind { get; }
    public TypeKind TypeKind { get; }
    public TypeParameterKind TypeParameterKind { get; }
    public IMethodSymbol DeclaringMethod { get; }
    public INamedTypeSymbol DeclaringType { get; }
    public CodeGenerationTypeParameterSymbol(INamedTypeSymbol containingType, IList`1<AttributeData> attributes, VarianceKind varianceKind, string name, ImmutableArray`1<ITypeSymbol> constraintTypes, bool hasConstructorConstraint, bool hasReferenceConstraint, bool hasValueConstraint, int ordinal);
    [CompilerGeneratedAttribute]
public sealed virtual VarianceKind get_Variance();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<ITypeSymbol> get_ConstraintTypes();
    [CompilerGeneratedAttribute]
internal void set_ConstraintTypes(ImmutableArray`1<ITypeSymbol> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasConstructorConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasReferenceTypeConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasValueTypeConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Ordinal();
    protected virtual CodeGenerationSymbol Clone();
    public sealed virtual ITypeParameterSymbol get_OriginalDefinition();
    public sealed virtual ITypeParameterSymbol get_ReducedFrom();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual TypeKind get_TypeKind();
    public sealed virtual TypeParameterKind get_TypeParameterKind();
    public sealed virtual IMethodSymbol get_DeclaringMethod();
    public sealed virtual INamedTypeSymbol get_DeclaringType();
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationTypeSymbol : CodeGenerationNamespaceOrTypeSymbol {
    [CompilerGeneratedAttribute]
private SpecialType <SpecialType>k__BackingField;
    public SpecialType SpecialType { get; protected set; }
    public TypeKind TypeKind { get; }
    public INamedTypeSymbol BaseType { get; }
    public ImmutableArray`1<INamedTypeSymbol> Interfaces { get; }
    public ImmutableArray`1<INamedTypeSymbol> AllInterfaces { get; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    public bool IsAnonymousType { get; }
    public ITypeSymbol OriginalDefinition { get; }
    public bool IsNamespace { get; }
    public bool IsType { get; }
    protected CodeGenerationTypeSymbol(INamedTypeSymbol containingType, IList`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name, SpecialType specialType);
    [CompilerGeneratedAttribute]
public sealed virtual SpecialType get_SpecialType();
    [CompilerGeneratedAttribute]
protected void set_SpecialType(SpecialType value);
    public abstract virtual TypeKind get_TypeKind();
    public virtual INamedTypeSymbol get_BaseType();
    public virtual ImmutableArray`1<INamedTypeSymbol> get_Interfaces();
    public sealed virtual ImmutableArray`1<INamedTypeSymbol> get_AllInterfaces();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsAnonymousType();
    public sealed virtual ITypeSymbol get_OriginalDefinition();
    public sealed virtual ISymbol FindImplementationForInterfaceMember(ISymbol interfaceMember);
    public virtual bool get_IsNamespace();
    public virtual bool get_IsType();
}
internal static class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator : object {
    private static ICodeGenerationService GetCodeGenerationService(Workspace workspace, string language);
    public static SyntaxNode CreateEventDeclaration(IEventSymbol event, Workspace workspace, CodeGenerationDestination destination, CodeGenerationOptions options);
    public static SyntaxNode CreateFieldDeclaration(IFieldSymbol field, Workspace workspace, CodeGenerationDestination destination, CodeGenerationOptions options);
    public static SyntaxNode CreateMethodDeclaration(IMethodSymbol method, Workspace workspace, CodeGenerationDestination destination, CodeGenerationOptions options);
    public static SyntaxNode CreatePropertyDeclaration(IPropertySymbol property, Workspace workspace, CodeGenerationDestination destination, CodeGenerationOptions options);
    public static SyntaxNode CreateNamedTypeDeclaration(INamedTypeSymbol namedType, Workspace workspace, CodeGenerationDestination destination, CodeGenerationOptions options);
    public static SyntaxNode CreateNamespaceDeclaration(INamespaceSymbol namespace, Workspace workspace, CodeGenerationDestination destination, CodeGenerationOptions options);
    public static TDeclarationNode AddEventDeclaration(TDeclarationNode destination, IEventSymbol event, Workspace workspace, CodeGenerationOptions options);
    public static TDeclarationNode AddFieldDeclaration(TDeclarationNode destination, IFieldSymbol field, Workspace workspace, CodeGenerationOptions options);
    public static TDeclarationNode AddMethodDeclaration(TDeclarationNode destination, IMethodSymbol method, Workspace workspace, CodeGenerationOptions options);
    public static TDeclarationNode AddPropertyDeclaration(TDeclarationNode destination, IPropertySymbol property, Workspace workspace, CodeGenerationOptions options);
    public static TDeclarationNode AddNamedTypeDeclaration(TDeclarationNode destination, INamedTypeSymbol namedType, Workspace workspace, CodeGenerationOptions options);
    public static TDeclarationNode AddMemberDeclarations(TDeclarationNode destination, IEnumerable`1<ISymbol> members, Workspace workspace, CodeGenerationOptions options);
    public static TDeclarationNode AddParameterDeclarations(TDeclarationNode destinationMember, IEnumerable`1<IParameterSymbol> parameters, Workspace workspace, CodeGenerationOptions options);
    public static TDeclarationNode AddAttributes(TDeclarationNode destination, Workspace workspace, IEnumerable`1<AttributeData> attributes, Nullable`1<SyntaxToken> target, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static TDeclarationNode RemoveAttribute(TDeclarationNode destination, Workspace workspace, AttributeData attributeToRemove, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static TDeclarationNode RemoveAttribute(TDeclarationNode destination, Workspace workspace, SyntaxNode attributeToRemove, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode destination, Workspace workspace, IEnumerable`1<SyntaxToken> newModifiers, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static TDeclarationNode UpdateDeclarationAccessibility(TDeclarationNode destination, Workspace workspace, Accessibility newAccesibility, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static TDeclarationNode UpdateDeclarationType(TDeclarationNode destination, Workspace workspace, ITypeSymbol newType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static TDeclarationNode UpdateDeclarationMembers(TDeclarationNode destination, Workspace workspace, IList`1<ISymbol> newMembers, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static TDeclarationNode AddStatements(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, Workspace workspace, CodeGenerationOptions options);
    public static Task`1<Document> AddEventDeclarationAsync(Solution solution, INamedTypeSymbol destination, IEventSymbol event, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static Task`1<Document> AddFieldDeclarationAsync(Solution solution, INamedTypeSymbol destination, IFieldSymbol field, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static Task`1<Document> AddMethodDeclarationAsync(Solution solution, INamedTypeSymbol destination, IMethodSymbol method, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static Task`1<Document> AddPropertyDeclarationAsync(Solution solution, INamedTypeSymbol destination, IPropertySymbol property, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static Task`1<Document> AddNamedTypeDeclarationAsync(Solution solution, INamedTypeSymbol destination, INamedTypeSymbol namedType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static Task`1<Document> AddNamedTypeDeclarationAsync(Solution solution, INamespaceSymbol destination, INamedTypeSymbol namedType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static Task`1<Document> AddNamespaceDeclarationAsync(Solution solution, INamespaceSymbol destination, INamespaceSymbol namespace, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static Task`1<Document> AddNamespaceOrTypeDeclarationAsync(Solution solution, INamespaceSymbol destination, INamespaceOrTypeSymbol namespaceOrType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static Task`1<Document> AddMemberDeclarationsAsync(Solution solution, INamedTypeSymbol destination, IEnumerable`1<ISymbol> members, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static bool CanAdd(Solution solution, ISymbol destination, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService {
    public abstract virtual SyntaxNode CreateEventDeclaration(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationOptions options);
    public abstract virtual SyntaxNode CreateFieldDeclaration(IFieldSymbol field, CodeGenerationDestination destination, CodeGenerationOptions options);
    public abstract virtual SyntaxNode CreateMethodDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CodeGenerationOptions options);
    public abstract virtual SyntaxNode CreatePropertyDeclaration(IPropertySymbol property, CodeGenerationDestination destination, CodeGenerationOptions options);
    public abstract virtual SyntaxNode CreateNamedTypeDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, CodeGenerationOptions options);
    public abstract virtual SyntaxNode CreateNamespaceDeclaration(INamespaceSymbol namespace, CodeGenerationDestination destination, CodeGenerationOptions options);
    public abstract virtual TDeclarationNode AddEvent(TDeclarationNode destination, IEventSymbol event, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddField(TDeclarationNode destination, IFieldSymbol field, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddMethod(TDeclarationNode destination, IMethodSymbol method, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddProperty(TDeclarationNode destination, IPropertySymbol property, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddNamedType(TDeclarationNode destination, INamedTypeSymbol namedType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddNamespace(TDeclarationNode destination, INamespaceSymbol namespace, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<ISymbol> members, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddParameters(TDeclarationNode destination, IEnumerable`1<IParameterSymbol> parameters, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddAttributes(TDeclarationNode destination, IEnumerable`1<AttributeData> attributes, Nullable`1<SyntaxToken> target, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, SyntaxNode attributeToRemove, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, AttributeData attributeToRemove, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode declaration, IEnumerable`1<SyntaxToken> newModifiers, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationAccessibility(TDeclarationNode declaration, Accessibility newAccesibility, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationType(TDeclarationNode declaration, ITypeSymbol newType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationMembers(TDeclarationNode declaration, IList`1<ISymbol> newMembers, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddStatements(TDeclarationNode destination, IEnumerable`1<SyntaxNode> statements, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddEventAsync(Solution solution, INamedTypeSymbol destination, IEventSymbol event, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddFieldAsync(Solution solution, INamedTypeSymbol destination, IFieldSymbol field, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddMethodAsync(Solution solution, INamedTypeSymbol destination, IMethodSymbol method, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddPropertyAsync(Solution solution, INamedTypeSymbol destination, IPropertySymbol property, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddNamedTypeAsync(Solution solution, INamedTypeSymbol destination, INamedTypeSymbol namedType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddNamedTypeAsync(Solution solution, INamespaceSymbol destination, INamedTypeSymbol namedType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddNamespaceAsync(Solution solution, INamespaceSymbol destination, INamespaceSymbol namespace, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddNamespaceOrTypeAsync(Solution solution, INamespaceSymbol destination, INamespaceOrTypeSymbol namespaceOrType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddMembersAsync(Solution solution, INamedTypeSymbol destination, IEnumerable`1<ISymbol> members, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual bool CanAddTo(ISymbol destination, Solution solution, CancellationToken cancellationToken);
    public abstract virtual bool CanAddTo(SyntaxNode destination, Solution solution, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeGeneration.INamedTypeSymbolExtensions : object {
    [ExtensionAttribute]
public static CodeGenerationAbstractNamedTypeSymbol ToCodeGenerationSymbol(INamedTypeSymbol namedType);
}
internal static class Microsoft.CodeAnalysis.CodeGeneration.LiteralSpecialValues : object {
    public static IEnumerable`1<KeyValuePair`2<byte, string>> ByteSpecialValues;
    public static IEnumerable`1<KeyValuePair`2<sbyte, string>> SByteSpecialValues;
    public static IEnumerable`1<KeyValuePair`2<short, string>> Int16SpecialValues;
    public static IEnumerable`1<KeyValuePair`2<ushort, string>> UInt16SpecialValues;
    public static IEnumerable`1<KeyValuePair`2<int, string>> Int32SpecialValues;
    public static IEnumerable`1<KeyValuePair`2<UInt32, string>> UInt32SpecialValues;
    public static IEnumerable`1<KeyValuePair`2<long, string>> Int64SpecialValues;
    public static IEnumerable`1<KeyValuePair`2<ulong, string>> UInt64SpecialValues;
    public static IEnumerable`1<KeyValuePair`2<float, string>> SingleSpecialValues;
    public static IEnumerable`1<KeyValuePair`2<double, string>> DoubleSpecialValues;
    public static IEnumerable`1<KeyValuePair`2<decimal, string>> DecimalSpecialValues;
    private static LiteralSpecialValues();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeGeneration.SyntaxAnnotationExtensions : object {
    [ExtensionAttribute]
public static TSymbol AddAnnotationToSymbol(SyntaxAnnotation annotation, TSymbol symbol);
    internal static SyntaxAnnotation[] CombineAnnotations(SyntaxAnnotation[] originalAnnotations, SyntaxAnnotation[] newAnnotations);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.TypeGenerator : object {
    public sealed virtual ITypeSymbol CreateArrayTypeSymbol(ITypeSymbol elementType, int rank);
    public sealed virtual ITypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType);
    public sealed virtual ITypeSymbol Construct(INamedTypeSymbol namedType, ITypeSymbol[] typeArguments);
}
public class Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext : ValueType {
    private Document _document;
    private TextSpan _span;
    private CancellationToken _cancellationToken;
    private Action`1<CodeAction> _registerRefactoring;
    public Document Document { get; }
    public TextSpan Span { get; }
    public CancellationToken CancellationToken { get; }
    public CodeRefactoringContext(Document document, TextSpan span, Action`1<CodeAction> registerRefactoring, CancellationToken cancellationToken);
    public Document get_Document();
    public TextSpan get_Span();
    public CancellationToken get_CancellationToken();
    public void RegisterRefactoring(CodeAction action);
}
public abstract class Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider : object {
    public abstract virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Languages>k__BackingField;
    public string Name { get; public set; }
    public String[] Languages { get; }
    public ExportCodeRefactoringProviderAttribute(string firstLanguage, String[] additionalLanguages);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public String[] get_Languages();
}
internal class Microsoft.CodeAnalysis.Collections.PooledDictionary`2 : Dictionary`2<K, V> {
    private ObjectPool`1<PooledDictionary`2<K, V>> _pool;
    private static ObjectPool`1<PooledDictionary`2<K, V>> s_poolInstance;
    private PooledDictionary`2(ObjectPool`1<PooledDictionary`2<K, V>> pool);
    private static PooledDictionary`2();
    public void Free();
    public static ObjectPool`1<PooledDictionary`2<K, V>> CreatePool();
    public static PooledDictionary`2<K, V> GetInstance();
}
internal class Microsoft.CodeAnalysis.Collections.PooledHashSet`1 : HashSet`1<T> {
    private ObjectPool`1<PooledHashSet`1<T>> _pool;
    private static ObjectPool`1<PooledHashSet`1<T>> s_poolInstance;
    private PooledHashSet`1(ObjectPool`1<PooledHashSet`1<T>> pool);
    private static PooledHashSet`1();
    public void Free();
    public static ObjectPool`1<PooledHashSet`1<T>> CreatePool();
    public static PooledHashSet`1<T> GetInstance();
}
internal class Microsoft.CodeAnalysis.Collections.PooledStringBuilder : object {
    public StringBuilder Builder;
    private ObjectPool`1<PooledStringBuilder> _pool;
    private static ObjectPool`1<PooledStringBuilder> s_poolInstance;
    public int Length { get; }
    private PooledStringBuilder(ObjectPool`1<PooledStringBuilder> pool);
    private static PooledStringBuilder();
    public int get_Length();
    public void Free();
    [ObsoleteAttribute("Consider calling ToStringAndFree instead.")]
public string ToString();
    public string ToStringAndFree();
    public string ToStringAndFree(int startIndex, int length);
    public static ObjectPool`1<PooledStringBuilder> CreatePool();
    public static PooledStringBuilder GetInstance();
    public static StringBuilder op_Implicit(PooledStringBuilder obj);
}
internal class Microsoft.CodeAnalysis.DefaultDocumentTextDifferencingService : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DefaultDocumentTextDifferencingService/<GetTextChangesAsync>d__0")]
public sealed virtual Task`1<IEnumerable`1<TextChange>> GetTextChangesAsync(Document oldDocument, Document newDocument, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.DeferredDocumentationProvider : DocumentationProvider {
    private Compilation _compilation;
    public DeferredDocumentationProvider(Compilation compilation);
    protected virtual string GetDocumentationForSymbol(string documentationMemberID, CultureInfo preferredCulture, CancellationToken cancellationToken);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.Diagnostics.AdditionalTextDocument : AdditionalText {
    private TextDocumentState _document;
    public string Path { get; }
    public AdditionalTextDocument(TextDocumentState document);
    public virtual string get_Path();
    public virtual SourceText GetText(CancellationToken cancellationToken);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.Differencing.Edit`1 : ValueType {
    private TreeComparer`1<TNode> _comparer;
    private EditKind _kind;
    private TNode _oldNode;
    private TNode _newNode;
    public EditKind Kind { get; }
    public TNode OldNode { get; }
    public TNode NewNode { get; }
    internal Edit`1(EditKind kind, TreeComparer`1<TNode> comparer, TNode oldNode, TNode newNode);
    public EditKind get_Kind();
    public TNode get_OldNode();
    public TNode get_NewNode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Edit`1<TNode> other);
    public virtual int GetHashCode();
    internal string GetDebuggerDisplay();
    private string DisplayPosition(TNode node);
}
public enum Microsoft.CodeAnalysis.Differencing.EditKind : Enum {
    public int value__;
    public static EditKind None;
    public static EditKind Update;
    public static EditKind Insert;
    public static EditKind Delete;
    public static EditKind Move;
    public static EditKind Reorder;
}
public class Microsoft.CodeAnalysis.Differencing.EditScript`1 : object {
    private Match`1<TNode> _match;
    private ImmutableArray`1<Edit`1<TNode>> _edits;
    public ImmutableArray`1<Edit`1<TNode>> Edits { get; }
    public Match`1<TNode> Match { get; }
    private TreeComparer`1<TNode> Comparer { get; }
    private TNode Root1 { get; }
    private TNode Root2 { get; }
    internal EditScript`1(Match`1<TNode> match);
    public ImmutableArray`1<Edit`1<TNode>> get_Edits();
    public Match`1<TNode> get_Match();
    private TreeComparer`1<TNode> get_Comparer();
    private TNode get_Root1();
    private TNode get_Root2();
    private void AddUpdatesInsertsMoves(List`1<Edit`1<TNode>> edits);
    private void ProcessNode(List`1<Edit`1<TNode>> edits, TNode x);
    private void AddDeletes(List`1<Edit`1<TNode>> edits);
    private void AlignChildren(List`1<Edit`1<TNode>> edits, TNode w, TNode x);
    private static bool ContainsPair(Dictionary`2<TNode, TNode> dict, TNode a, TNode b);
}
internal abstract class Microsoft.CodeAnalysis.Differencing.LongestCommonImmutableArraySubsequence`1 : LongestCommonSubsequence`1<ImmutableArray`1<TElement>> {
    protected abstract virtual bool Equals(TElement oldElement, TElement newElement);
    protected sealed virtual bool ItemsEqual(ImmutableArray`1<TElement> oldSequence, int oldIndex, ImmutableArray`1<TElement> newSequence, int newIndex);
    public IEnumerable`1<SequenceEdit> GetEdits(ImmutableArray`1<TElement> oldSequence, ImmutableArray`1<TElement> newSequence);
    public double ComputeDistance(ImmutableArray`1<TElement> oldSequence, ImmutableArray`1<TElement> newSequence);
}
internal abstract class Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1 : object {
    private static int DeleteCost;
    private static int InsertCost;
    private static int UpdateCost;
    protected abstract virtual bool ItemsEqual(TSequence oldSequence, int oldIndex, TSequence newSequence, int newIndex);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1/<GetMatchingPairs>d__4")]
protected IEnumerable`1<KeyValuePair`2<int, int>> GetMatchingPairs(TSequence oldSequence, int oldLength, TSequence newSequence, int newLength);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1/<GetEdits>d__5")]
protected IEnumerable`1<SequenceEdit> GetEdits(TSequence oldSequence, int oldLength, TSequence newSequence, int newLength);
    protected double ComputeDistance(TSequence oldSequence, int oldLength, TSequence newSequence, int newLength);
    private Int32[0...,0...] ComputeCostMatrix(TSequence oldSequence, int oldLength, TSequence newSequence, int newLength);
}
internal class Microsoft.CodeAnalysis.Differencing.LongestCommonSubstring : LongestCommonSubsequence`1<string> {
    private static LongestCommonSubstring s_instance;
    private static LongestCommonSubstring();
    protected virtual bool ItemsEqual(string oldSequence, int oldIndex, string newSequence, int newIndex);
    public static double ComputeDistance(string oldValue, string newValue);
    public static IEnumerable`1<SequenceEdit> GetEdits(string oldValue, string newValue);
}
public class Microsoft.CodeAnalysis.Differencing.Match`1 : object {
    private static double ExactMatchDistance;
    private static double EpsilonDistance;
    private static double MatchingDistance1;
    private static double MatchingDistance2;
    private static double MatchingDistance3;
    private static double MaxDistance;
    private TreeComparer`1<TNode> _comparer;
    private TNode _root1;
    private TNode _root2;
    private Dictionary`2<TNode, TNode> _oneToTwo;
    private Dictionary`2<TNode, TNode> _twoToOne;
    public TreeComparer`1<TNode> Comparer { get; }
    public TNode OldRoot { get; }
    public TNode NewRoot { get; }
    public IReadOnlyDictionary`2<TNode, TNode> Matches { get; }
    public IReadOnlyDictionary`2<TNode, TNode> ReverseMatches { get; }
    internal Match`1(TNode root1, TNode root2, TreeComparer`1<TNode> comparer, IEnumerable`1<KeyValuePair`2<TNode, TNode>> knownMatches);
    private static void CategorizeNodesByLabels(TreeComparer`1<TNode> comparer, TNode root, int labelCount, List`1[]& nodes, Int32& totalCount);
    private void ComputeMatch(List`1[] nodes1, List`1[] nodes2);
    private void ComputeMatchForLabel(int label, List`1<TNode> s1, List`1<TNode> s2);
    private void ComputeMatchForLabel(List`1<TNode> s1, List`1<TNode> s2, int tiedToAncestor, double maxAcceptableDistance);
    internal void Add(TNode node1, TNode node2);
    internal bool TryGetPartnerInTree1(TNode node2, TNode& partner1);
    internal bool HasPartnerInTree1(TNode node2);
    internal bool TryGetPartnerInTree2(TNode node1, TNode& partner2);
    internal bool HasPartnerInTree2(TNode node1);
    internal bool Contains(TNode node1, TNode node2);
    public TreeComparer`1<TNode> get_Comparer();
    public TNode get_OldRoot();
    public TNode get_NewRoot();
    public IReadOnlyDictionary`2<TNode, TNode> get_Matches();
    public IReadOnlyDictionary`2<TNode, TNode> get_ReverseMatches();
    public bool TryGetNewNode(TNode oldNode, TNode& newNode);
    public bool TryGetOldNode(TNode newNode, TNode& oldNode);
    public EditScript`1<TNode> GetTreeEdits();
    public IEnumerable`1<Edit`1<TNode>> GetSequenceEdits(IEnumerable`1<TNode> oldNodes, IEnumerable`1<TNode> newNodes);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.Differencing.SequenceEdit : ValueType {
    private int _oldIndex;
    private int _newIndex;
    public EditKind Kind { get; }
    public int OldIndex { get; }
    public int NewIndex { get; }
    internal SequenceEdit(int oldIndex, int newIndex);
    public EditKind get_Kind();
    public int get_OldIndex();
    public int get_NewIndex();
    public sealed virtual bool Equals(SequenceEdit other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal string GetDebuggerDisplay();
}
public abstract class Microsoft.CodeAnalysis.Differencing.TreeComparer`1 : object {
    protected internal int LabelCount { get; }
    public EditScript`1<TNode> ComputeEditScript(TNode oldRoot, TNode newRoot);
    public Match`1<TNode> ComputeMatch(TNode oldRoot, TNode newRoot, IEnumerable`1<KeyValuePair`2<TNode, TNode>> knownMatches);
    public abstract virtual double GetDistance(TNode oldNode, TNode newNode);
    public abstract virtual bool ValuesEqual(TNode oldNode, TNode newNode);
    protected internal abstract virtual int get_LabelCount();
    protected internal abstract virtual int GetLabel(TNode node);
    protected internal abstract virtual int TiedToAncestor(int label);
    protected internal abstract virtual IEnumerable`1<TNode> GetChildren(TNode node);
    protected internal abstract virtual IEnumerable`1<TNode> GetDescendants(TNode node);
    protected internal abstract virtual bool TryGetParent(TNode node, TNode& parent);
    internal TNode GetParent(TNode node);
    internal TNode GetAncestor(TNode node, int level);
    protected internal abstract virtual bool TreesEqual(TNode oldNode, TNode newNode);
    protected internal abstract virtual TextSpan GetSpan(TNode node);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.Document : TextDocument {
    private DocumentState _state;
    private WeakReference`1<SemanticModel> _model;
    private Task`1<SyntaxTree> _syntaxTreeResultTask;
    internal DocumentState State { get; }
    public SourceCodeKind SourceCodeKind { get; }
    public bool SupportsSyntaxTree { get; }
    public bool SupportsSemanticModel { get; }
    internal Document(Project project, DocumentState state);
    internal DocumentState get_State();
    internal virtual TextDocumentState GetDocumentState();
    public SourceCodeKind get_SourceCodeKind();
    public bool TryGetSyntaxTree(SyntaxTree& syntaxTree);
    public bool TryGetSyntaxVersion(VersionStamp& version);
    internal bool TryGetTopLevelChangeTextVersion(VersionStamp& version);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Document/<GetSyntaxVersionAsync>d__12")]
public Task`1<VersionStamp> GetSyntaxVersionAsync(CancellationToken cancellationToken);
    public bool get_SupportsSyntaxTree();
    public bool get_SupportsSemanticModel();
    public Task`1<SyntaxTree> GetSyntaxTreeAsync(CancellationToken cancellationToken);
    public bool TryGetSyntaxRoot(SyntaxNode& root);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Document/<GetSyntaxRootAsync>d__19")]
public Task`1<SyntaxNode> GetSyntaxRootAsync(CancellationToken cancellationToken);
    public bool TryGetSemanticModel(SemanticModel& semanticModel);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Document/<GetSemanticModelAsync>d__21")]
public Task`1<SemanticModel> GetSemanticModelAsync(CancellationToken cancellationToken);
    public Document WithSourceCodeKind(SourceCodeKind kind);
    public Document WithText(SourceText text);
    public Document WithSyntaxRoot(SyntaxNode root);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Document/<GetTextChangesAsync>d__25")]
public Task`1<IEnumerable`1<TextChange>> GetTextChangesAsync(Document oldDocument, CancellationToken cancellationToken);
    public ImmutableArray`1<DocumentId> GetLinkedDocumentIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Document/<WithFrozenPartialSemanticsAsync>d__27")]
internal Task`1<Document> WithFrozenPartialSemanticsAsync(CancellationToken cancellationToken);
    private string GetDebuggerDisplay();
}
public class Microsoft.CodeAnalysis.DocumentDiagnostic : WorkspaceDiagnostic {
    [CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    public DocumentId DocumentId { get; }
    public DocumentDiagnostic(WorkspaceDiagnosticKind kind, string message, DocumentId documentId);
    [CompilerGeneratedAttribute]
public DocumentId get_DocumentId();
}
public class Microsoft.CodeAnalysis.DocumentEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    public Document Document { get; }
    public DocumentEventArgs(Document document);
    [CompilerGeneratedAttribute]
public Document get_Document();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.DocumentId : object {
    [CompilerGeneratedAttribute]
private ProjectId <ProjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    private string _debugName;
    public ProjectId ProjectId { get; }
    public Guid Id { get; }
    internal string DebugName { get; }
    private DocumentId(ProjectId projectId, string debugName);
    internal DocumentId(ProjectId projectId, Guid guid, string debugName);
    [CompilerGeneratedAttribute]
public ProjectId get_ProjectId();
    [CompilerGeneratedAttribute]
public Guid get_Id();
    public static DocumentId CreateNewId(ProjectId projectId, string debugName);
    public static DocumentId CreateFromSerialized(ProjectId projectId, Guid id, string debugName);
    internal string GetDebuggerDisplay();
    internal string get_DebugName();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DocumentId other);
    public virtual int GetHashCode();
    public static bool op_Equality(DocumentId left, DocumentId right);
    public static bool op_Inequality(DocumentId left, DocumentId right);
}
public class Microsoft.CodeAnalysis.DocumentInfo : object {
    [CompilerGeneratedAttribute]
private DocumentId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Folders>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceCodeKind <SourceCodeKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private TextLoader <TextLoader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGenerated>k__BackingField;
    public DocumentId Id { get; }
    public string Name { get; }
    public IReadOnlyList`1<string> Folders { get; }
    public SourceCodeKind SourceCodeKind { get; }
    public string FilePath { get; }
    public TextLoader TextLoader { get; }
    public bool IsGenerated { get; }
    private DocumentInfo(DocumentId id, string name, IEnumerable`1<string> folders, SourceCodeKind sourceCodeKind, TextLoader loader, string filePath, bool isGenerated);
    [CompilerGeneratedAttribute]
public DocumentId get_Id();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Folders();
    [CompilerGeneratedAttribute]
public SourceCodeKind get_SourceCodeKind();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public TextLoader get_TextLoader();
    [CompilerGeneratedAttribute]
public bool get_IsGenerated();
    public static DocumentInfo Create(DocumentId id, string name, IEnumerable`1<string> folders, SourceCodeKind sourceCodeKind, TextLoader loader, string filePath, bool isGenerated);
    private DocumentInfo With(DocumentId id, string name, IEnumerable`1<string> folders, Optional`1<SourceCodeKind> sourceCodeKind, Optional`1<TextLoader> loader, Optional`1<string> filePath);
    public DocumentInfo WithId(DocumentId id);
    public DocumentInfo WithName(string name);
    public DocumentInfo WithFolders(IEnumerable`1<string> folders);
    public DocumentInfo WithSourceCodeKind(SourceCodeKind kind);
    public DocumentInfo WithTextLoader(TextLoader loader);
    public DocumentInfo WithFilePath(string filePath);
}
internal class Microsoft.CodeAnalysis.DocumentState : TextDocumentState {
    private static Func`3<string, PreservationMode, string> s_fullParseLog;
    private HostLanguageServices _languageServices;
    private ParseOptions _options;
    private ValueSource`1<TreeAndVersion> _treeSource;
    private static int MaxTextChangeRangeLength;
    private DocumentBranch _firstBranch;
    private static ReaderWriterLockSlim s_syntaxTreeToIdMapLock;
    private static ConditionalWeakTable`2<SyntaxTree, DocumentId> s_syntaxTreeToIdMap;
    public HostLanguageServices LanguageServices { get; }
    public ParseOptions ParseOptions { get; }
    public SourceCodeKind SourceCodeKind { get; }
    public bool IsGenerated { get; }
    private DocumentState(HostLanguageServices languageServices, SolutionServices solutionServices, DocumentInfo info, ParseOptions options, ValueSource`1<TextAndVersion> textSource, ValueSource`1<TreeAndVersion> treeSource);
    private static DocumentState();
    public static DocumentState Create(DocumentInfo info, ParseOptions options, HostLanguageServices language, SolutionServices services);
    private static string GetSyntaxTreeFilePath(DocumentInfo info);
    private static ValueSource`1<TreeAndVersion> CreateLazyFullyParsedTree(ValueSource`1<TextAndVersion> newTextSource, ProjectId cacheKey, string filePath, ParseOptions options, HostLanguageServices languageServices, SolutionServices solutionServices, PreservationMode mode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentState/<FullyParseTreeAsync>d__9")]
private static Task`1<TreeAndVersion> FullyParseTreeAsync(ValueSource`1<TextAndVersion> newTextSource, ProjectId cacheKey, string filePath, ParseOptions options, HostLanguageServices languageServices, SolutionServices solutionServices, PreservationMode mode, CancellationToken cancellationToken);
    private static ValueSource`1<TreeAndVersion> CreateLazyIncrementallyParsedTree(ValueSource`1<TreeAndVersion> oldTreeSource, ValueSource`1<TextAndVersion> newTextSource);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentState/<IncrementallyParseTreeAsync>d__11")]
private static Task`1<TreeAndVersion> IncrementallyParseTreeAsync(ValueSource`1<TreeAndVersion> oldTreeSource, ValueSource`1<TextAndVersion> newTextSource, CancellationToken cancellationToken);
    private static TreeAndVersion MakeNewTreeAndVersion(SyntaxTree oldTree, SourceText oldText, VersionStamp oldVersion, SyntaxTree newTree, SourceText newText, VersionStamp newVersion);
    private static bool TopLevelChanged(SyntaxTree oldTree, SourceText oldText, SyntaxTree newTree, SourceText newText);
    public DocumentState UpdateParseOptions(ParseOptions options);
    private DocumentState SetParseOptions(ParseOptions options);
    public DocumentState UpdateSourceCodeKind(SourceCodeKind kind);
    public DocumentState UpdateFolders(IList`1<string> folders);
    public DocumentState UpdateText(SourceText newText, PreservationMode mode);
    public DocumentState UpdateText(TextAndVersion newTextAndVersion, PreservationMode mode);
    public DocumentState UpdateText(TextLoader loader, PreservationMode mode);
    internal DocumentState UpdateTree(SyntaxNode newRoot, PreservationMode mode);
    private VersionStamp GetNewTreeVersionForUpdatedTree(SyntaxNode newRoot, VersionStamp newTextVersion, PreservationMode mode);
    private static Tuple`2<ValueSource`1<TextAndVersion>, TreeAndVersion> CreateRecoverableTextAndTree(SyntaxNode newRoot, VersionStamp textVersion, VersionStamp treeVersion, Encoding encoding, DocumentInfo info, ParseOptions options, ISyntaxTreeFactoryService factory, PreservationMode mode, SolutionServices solutionServices);
    private static SourceText BuildRecoverableTreeText(SyntaxTree tree, Encoding encoding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentState/<BuildRecoverableTreeTextAsync>d__28")]
private static Task`1<SourceText> BuildRecoverableTreeTextAsync(SyntaxTree tree, Encoding encoding, CancellationToken cancellationToken);
    private VersionStamp GetNewerVersion();
    public bool TryGetSyntaxTree(SyntaxTree& syntaxTree);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentState/<GetSyntaxTreeAsync>d__31")]
public Task`1<SyntaxTree> GetSyntaxTreeAsync(CancellationToken cancellationToken);
    public bool TryGetTopLevelChangeTextVersion(VersionStamp& version);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentState/<GetTopLevelChangeTextVersionAsync>d__33")]
public virtual Task`1<VersionStamp> GetTopLevelChangeTextVersionAsync(CancellationToken cancellationToken);
    private static void BindSyntaxTreeToId(SyntaxTree tree, DocumentId id);
    public static DocumentId GetDocumentIdForTree(SyntaxTree tree);
    public HostLanguageServices get_LanguageServices();
    public ParseOptions get_ParseOptions();
    public SourceCodeKind get_SourceCodeKind();
    public bool get_IsGenerated();
}
public enum Microsoft.CodeAnalysis.Editing.DeclarationKind : Enum {
    public int value__;
    public static DeclarationKind None;
    public static DeclarationKind CompilationUnit;
    public static DeclarationKind Class;
    public static DeclarationKind Struct;
    public static DeclarationKind Interface;
    public static DeclarationKind Enum;
    public static DeclarationKind Delegate;
    public static DeclarationKind Method;
    public static DeclarationKind Operator;
    public static DeclarationKind ConversionOperator;
    public static DeclarationKind Constructor;
    public static DeclarationKind Destructor;
    public static DeclarationKind Field;
    public static DeclarationKind Property;
    public static DeclarationKind Indexer;
    public static DeclarationKind EnumMember;
    public static DeclarationKind Event;
    public static DeclarationKind CustomEvent;
    public static DeclarationKind Namespace;
    public static DeclarationKind NamespaceImport;
    public static DeclarationKind Parameter;
    public static DeclarationKind Variable;
    public static DeclarationKind Attribute;
    public static DeclarationKind LambdaExpression;
    public static DeclarationKind GetAccessor;
    public static DeclarationKind SetAccessor;
    public static DeclarationKind AddAccessor;
    public static DeclarationKind RemoveAccessor;
    public static DeclarationKind RaiseAccessor;
}
public class Microsoft.CodeAnalysis.Editing.DeclarationModifiers : ValueType {
    private Modifiers _modifiers;
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsNew { get; }
    public bool IsUnsafe { get; }
    public bool IsReadOnly { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsSealed { get; }
    public bool IsConst { get; }
    public bool IsWithEvents { get; }
    public bool IsPartial { get; }
    public bool IsAsync { get; }
    public bool IsWriteOnly { get; }
    public static DeclarationModifiers None { get; }
    public static DeclarationModifiers Static { get; }
    public static DeclarationModifiers Abstract { get; }
    public static DeclarationModifiers New { get; }
    public static DeclarationModifiers Unsafe { get; }
    public static DeclarationModifiers ReadOnly { get; }
    public static DeclarationModifiers Virtual { get; }
    public static DeclarationModifiers Override { get; }
    public static DeclarationModifiers Sealed { get; }
    public static DeclarationModifiers Const { get; }
    public static DeclarationModifiers WithEvents { get; }
    public static DeclarationModifiers Partial { get; }
    public static DeclarationModifiers Async { get; }
    public static DeclarationModifiers WriteOnly { get; }
    private DeclarationModifiers(Modifiers modifiers);
    internal DeclarationModifiers(bool isStatic, bool isAbstract, bool isNew, bool isUnsafe, bool isReadOnly, bool isVirtual, bool isOverride, bool isSealed, bool isConst, bool isWithEvents, bool isPartial, bool isAsync, bool isWriteOnly);
    public static DeclarationModifiers From(ISymbol symbol);
    public bool get_IsStatic();
    public bool get_IsAbstract();
    public bool get_IsNew();
    public bool get_IsUnsafe();
    public bool get_IsReadOnly();
    public bool get_IsVirtual();
    public bool get_IsOverride();
    public bool get_IsSealed();
    public bool get_IsConst();
    public bool get_IsWithEvents();
    public bool get_IsPartial();
    public bool get_IsAsync();
    public bool get_IsWriteOnly();
    public DeclarationModifiers WithIsStatic(bool isStatic);
    public DeclarationModifiers WithIsAbstract(bool isAbstract);
    public DeclarationModifiers WithIsNew(bool isNew);
    public DeclarationModifiers WithIsUnsafe(bool isUnsafe);
    public DeclarationModifiers WithIsReadOnly(bool isReadOnly);
    public DeclarationModifiers WithIsVirtual(bool isVirtual);
    public DeclarationModifiers WithIsOverride(bool isOverride);
    public DeclarationModifiers WithIsSealed(bool isSealed);
    public DeclarationModifiers WithIsConst(bool isConst);
    public DeclarationModifiers WithWithEvents(bool withEvents);
    public DeclarationModifiers WithPartial(bool isPartial);
    public DeclarationModifiers WithAsync(bool isAsync);
    public DeclarationModifiers WithIsWriteOnly(bool isWriteOnly);
    private static Modifiers SetFlag(Modifiers existing, Modifiers modifier, bool isSet);
    public static DeclarationModifiers get_None();
    public static DeclarationModifiers get_Static();
    public static DeclarationModifiers get_Abstract();
    public static DeclarationModifiers get_New();
    public static DeclarationModifiers get_Unsafe();
    public static DeclarationModifiers get_ReadOnly();
    public static DeclarationModifiers get_Virtual();
    public static DeclarationModifiers get_Override();
    public static DeclarationModifiers get_Sealed();
    public static DeclarationModifiers get_Const();
    public static DeclarationModifiers get_WithEvents();
    public static DeclarationModifiers get_Partial();
    public static DeclarationModifiers get_Async();
    public static DeclarationModifiers get_WriteOnly();
    public static DeclarationModifiers op_BitwiseOr(DeclarationModifiers left, DeclarationModifiers right);
    public static DeclarationModifiers op_BitwiseAnd(DeclarationModifiers left, DeclarationModifiers right);
    public static DeclarationModifiers op_Addition(DeclarationModifiers left, DeclarationModifiers right);
    public static DeclarationModifiers op_Subtraction(DeclarationModifiers left, DeclarationModifiers right);
    public sealed virtual bool Equals(DeclarationModifiers modifiers);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DeclarationModifiers left, DeclarationModifiers right);
    public static bool op_Inequality(DeclarationModifiers left, DeclarationModifiers right);
    public virtual string ToString();
}
public class Microsoft.CodeAnalysis.Editing.DocumentEditor : SyntaxEditor {
    private Document _document;
    private SemanticModel _model;
    public Document OriginalDocument { get; }
    public SemanticModel SemanticModel { get; }
    private DocumentEditor(Document document, SemanticModel model, SyntaxNode root);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.DocumentEditor/<CreateAsync>d__3")]
public static Task`1<DocumentEditor> CreateAsync(Document document, CancellationToken cancellationToken);
    public Document get_OriginalDocument();
    public SemanticModel get_SemanticModel();
    public Document GetChangedDocument();
}
internal class Microsoft.CodeAnalysis.Editing.GenerationOptions : object {
    public static string FeatureName;
    public static PerLanguageOption`1<bool> PlaceSystemNamespaceFirst;
    private static GenerationOptions();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Editing.GenerationOptionsProvider : object {
    private static IEnumerable`1<IOption> _options;
    private static GenerationOptionsProvider();
    public sealed virtual IEnumerable`1<IOption> GetOptions();
}
public static class Microsoft.CodeAnalysis.Editing.ImportAdder : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.ImportAdder/<AddImportsAsync>d__0")]
public static Task`1<Document> AddImportsAsync(Document document, OptionSet options, CancellationToken cancellationToken);
    public static Task`1<Document> AddImportsAsync(Document document, TextSpan span, OptionSet options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.ImportAdder/<AddImportsAsync>d__2")]
public static Task`1<Document> AddImportsAsync(Document document, SyntaxAnnotation annotation, OptionSet options, CancellationToken cancellationToken);
    public static Task`1<Document> AddImportsAsync(Document document, IEnumerable`1<TextSpan> spans, OptionSet options, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Editing.ImportAdderService : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.ImportAdderService/<AddImportsAsync>d__0")]
public Task`1<Document> AddImportsAsync(Document document, IEnumerable`1<TextSpan> spans, OptionSet options, CancellationToken cancellationToken);
    private SyntaxNode AddNamespaceImports(Document document, SemanticModel model, OptionSet options, IEnumerable`1<INamespaceSymbol> namespaces);
    protected virtual void GetExistingImportedNamespaces(Document document, SemanticModel model, HashSet`1<INamespaceSymbol> namespaces);
    protected abstract virtual INamespaceSymbol GetImportedNamespaceSymbol(SyntaxNode import, SemanticModel model);
    protected abstract virtual INamespaceSymbol GetExplicitNamespaceSymbol(SyntaxNode node, SemanticModel model);
    protected abstract virtual SyntaxNode InsertNamespaceImport(SyntaxNode root, SyntaxGenerator gen, SyntaxNode import, OptionSet options);
}
public class Microsoft.CodeAnalysis.Editing.SolutionEditor : object {
    private Solution _solution;
    private Dictionary`2<DocumentId, DocumentEditor> _documentEditors;
    public Solution OriginalSolution { get; }
    public SolutionEditor(Solution solution);
    public Solution get_OriginalSolution();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SolutionEditor/<GetDocumentEditorAsync>d__5")]
public Task`1<DocumentEditor> GetDocumentEditorAsync(DocumentId id, CancellationToken cancellationToken);
    public Solution GetChangedSolution();
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind : Enum {
    public int value__;
    public static SpecialTypeConstraintKind None;
    public static SpecialTypeConstraintKind ReferenceType;
    public static SpecialTypeConstraintKind ValueType;
    public static SpecialTypeConstraintKind Constructor;
}
public class Microsoft.CodeAnalysis.Editing.SymbolEditor : object {
    private Solution _originalSolution;
    private Solution _currentSolution;
    private ImmutableDictionary`2<string, ImmutableArray`1<ProjectId>> _assemblyNameToProjectIdMap;
    public Solution OriginalSolution { get; }
    public Solution ChangedSolution { get; }
    private SymbolEditor(Solution solution);
    public static SymbolEditor Create(Solution solution);
    public static SymbolEditor Create(Document document);
    public Solution get_OriginalSolution();
    public Solution get_ChangedSolution();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<GetChangedDocuments>d__9")]
public IEnumerable`1<Document> GetChangedDocuments();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<GetCurrentSymbolAsync>d__10")]
public Task`1<ISymbol> GetCurrentSymbolAsync(ISymbol symbol, CancellationToken cancellationToken);
    private ImmutableArray`1<ProjectId> GetProjectsForAssembly(IAssemblySymbol assembly);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<GetSymbolAsync>d__13")]
private Task`1<ISymbol> GetSymbolAsync(Solution solution, ProjectId projectId, string symbolId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<GetCurrentDeclarationsAsync>d__14")]
public Task`1<IReadOnlyList`1<SyntaxNode>> GetCurrentDeclarationsAsync(ISymbol symbol, CancellationToken cancellationToken);
    private IEnumerable`1<SyntaxNode> GetDeclarations(ISymbol symbol);
    private bool TryGetBestDeclarationForSingleEdit(ISymbol symbol, SyntaxNode& declaration);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<EditOneDeclarationAsync>d__19")]
public Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, AsyncDeclarationEditAction editAction, CancellationToken cancellationToken);
    public Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, DeclarationEditAction editAction, CancellationToken cancellationToken);
    private void CheckSymbolArgument(ISymbol currentSymbol, ISymbol argSymbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<EditDeclarationAsync>d__22")]
private Task`1<ISymbol> EditDeclarationAsync(ISymbol currentSymbol, SyntaxNode declaration, AsyncDeclarationEditAction editAction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<EditOneDeclarationAsync>d__23")]
public Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, Location location, AsyncDeclarationEditAction editAction, CancellationToken cancellationToken);
    public Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, Location location, DeclarationEditAction editAction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<EditOneDeclarationAsync>d__25")]
private Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, DocumentId documentId, int position, AsyncDeclarationEditAction editAction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<EditOneDeclarationAsync>d__26")]
public Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, ISymbol member, AsyncDeclarationEditAction editAction, CancellationToken cancellationToken);
    public Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, ISymbol member, DeclarationEditAction editAction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<EditAllDeclarationsAsync>d__28")]
public Task`1<ISymbol> EditAllDeclarationsAsync(ISymbol symbol, AsyncDeclarationEditAction editAction, CancellationToken cancellationToken);
    public Task`1<ISymbol> EditAllDeclarationsAsync(ISymbol symbol, DeclarationEditAction editAction, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private SyntaxNode <GetDeclarations>b__15_1(SyntaxNode n);
    [CompilerGeneratedAttribute]
private DocumentId <EditAllDeclarationsAsync>b__28_0(SyntaxNode d);
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions/<GetBaseOrInterfaceDeclarationReferenceAsync>d__0")]
[ExtensionAttribute]
public static Task`1<SyntaxNode> GetBaseOrInterfaceDeclarationReferenceAsync(SymbolEditor editor, ISymbol symbol, ITypeSymbol baseOrInterfaceType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions/<SetBaseTypeAsync>d__1")]
[ExtensionAttribute]
public static Task`1<ISymbol> SetBaseTypeAsync(SymbolEditor editor, INamedTypeSymbol symbol, Func`2<SyntaxGenerator, SyntaxNode> getNewBaseType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ISymbol> SetBaseTypeAsync(SymbolEditor editor, INamedTypeSymbol symbol, ITypeSymbol newBaseType, CancellationToken cancellationToken);
}
public class Microsoft.CodeAnalysis.Editing.SyntaxEditor : object {
    private SyntaxGenerator _generator;
    private SyntaxNode _root;
    private List`1<Change> _changes;
    public SyntaxNode OriginalRoot { get; }
    public SyntaxGenerator Generator { get; }
    public SyntaxEditor(SyntaxNode root, Workspace workspace);
    public SyntaxNode get_OriginalRoot();
    public SyntaxGenerator get_Generator();
    public SyntaxNode GetChangedRoot();
    public void TrackNode(SyntaxNode node);
    public void RemoveNode(SyntaxNode node);
    public void ReplaceNode(SyntaxNode node, Func`3<SyntaxNode, SyntaxGenerator, SyntaxNode> computeReplacement);
    public void ReplaceNode(SyntaxNode node, SyntaxNode newNode);
    public void InsertBefore(SyntaxNode node, IEnumerable`1<SyntaxNode> newNodes);
    public void InsertBefore(SyntaxNode node, SyntaxNode newNode);
    public void InsertAfter(SyntaxNode node, IEnumerable`1<SyntaxNode> newNodes);
    public void InsertAfter(SyntaxNode node, SyntaxNode newNode);
    private void CheckNodeInTree(SyntaxNode node);
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions : object {
    [ExtensionAttribute]
public static void SetAccessibility(SyntaxEditor editor, SyntaxNode declaration, Accessibility accessibility);
    [ExtensionAttribute]
public static void SetModifiers(SyntaxEditor editor, SyntaxNode declaration, DeclarationModifiers modifiers);
    [ExtensionAttribute]
public static void SetName(SyntaxEditor editor, SyntaxNode declaration, string name);
    [ExtensionAttribute]
public static void SetType(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode type);
    [ExtensionAttribute]
public static void SetTypeParameters(SyntaxEditor editor, SyntaxNode declaration, IEnumerable`1<string> typeParameters);
    [ExtensionAttribute]
public static void SetTypeConstraint(SyntaxEditor editor, SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kind, IEnumerable`1<SyntaxNode> types);
    [ExtensionAttribute]
public static void SetExpression(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode expression);
    [ExtensionAttribute]
public static void SetStatements(SyntaxEditor editor, SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    [ExtensionAttribute]
public static void SetGetAccessorStatements(SyntaxEditor editor, SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    [ExtensionAttribute]
public static void SetSetAccessorStatements(SyntaxEditor editor, SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    [ExtensionAttribute]
public static void AddParameter(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode parameter);
    [ExtensionAttribute]
public static void AddAttribute(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode attribute);
    [ExtensionAttribute]
public static void AddReturnAttribute(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode attribute);
    [ExtensionAttribute]
public static void AddAttributeArgument(SyntaxEditor editor, SyntaxNode attributeDeclaration, SyntaxNode attributeArgument);
    [ExtensionAttribute]
public static void AddMember(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode member);
    [ExtensionAttribute]
public static void InsertMembers(SyntaxEditor editor, SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> members);
    [ExtensionAttribute]
public static void AddInterfaceType(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode interfaceType);
    [ExtensionAttribute]
public static void AddBaseType(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode baseType);
}
public abstract class Microsoft.CodeAnalysis.Editing.SyntaxGenerator : object {
    public static SyntaxRemoveOptions DefaultRemoveOptions;
    private static Char[] s_dotSeparator;
    private static SyntaxGenerator();
    public static SyntaxGenerator GetGenerator(Workspace workspace, string language);
    public static SyntaxGenerator GetGenerator(Document document);
    public SyntaxNode GetDeclaration(SyntaxNode node);
    public SyntaxNode GetDeclaration(SyntaxNode node, DeclarationKind kind);
    public abstract virtual SyntaxNode FieldDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, SyntaxNode initializer);
    public SyntaxNode FieldDeclaration(IFieldSymbol field);
    public SyntaxNode FieldDeclaration(IFieldSymbol field, SyntaxNode initializer);
    public abstract virtual SyntaxNode MethodDeclaration(string name, IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<string> typeParameters, SyntaxNode returnType, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode MethodDeclaration(IMethodSymbol method, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode ParameterDeclaration(string name, SyntaxNode type, SyntaxNode initializer, RefKind refKind);
    public SyntaxNode ParameterDeclaration(IParameterSymbol symbol, SyntaxNode initializer);
    public abstract virtual SyntaxNode PropertyDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> getAccessorStatements, IEnumerable`1<SyntaxNode> setAccessorStatements);
    public SyntaxNode PropertyDeclaration(IPropertySymbol property, IEnumerable`1<SyntaxNode> getAccessorStatements, IEnumerable`1<SyntaxNode> setAccessorStatements);
    public abstract virtual SyntaxNode IndexerDeclaration(IEnumerable`1<SyntaxNode> parameters, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> getAccessorStatements, IEnumerable`1<SyntaxNode> setAccessorStatements);
    public SyntaxNode IndexerDeclaration(IPropertySymbol indexer, IEnumerable`1<SyntaxNode> getAccessorStatements, IEnumerable`1<SyntaxNode> setAccessorStatements);
    public abstract virtual SyntaxNode EventDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers);
    public SyntaxNode EventDeclaration(IEventSymbol symbol);
    public abstract virtual SyntaxNode CustomEventDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<SyntaxNode> addAccessorStatements, IEnumerable`1<SyntaxNode> removeAccessorStatements);
    public SyntaxNode CustomEventDeclaration(IEventSymbol symbol, IEnumerable`1<SyntaxNode> addAccessorStatements, IEnumerable`1<SyntaxNode> removeAccessorStatements);
    public abstract virtual SyntaxNode ConstructorDeclaration(string containingTypeName, IEnumerable`1<SyntaxNode> parameters, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> baseConstructorArguments, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode ConstructorDeclaration(IMethodSymbol constructorMethod, IEnumerable`1<SyntaxNode> baseConstructorArguments, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode AsPublicInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType);
    public abstract virtual SyntaxNode AsPublicInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType, string interfaceMemberName);
    public SyntaxNode AsPrivateInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType);
    public abstract virtual SyntaxNode AsPrivateInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType, string interfaceMemberName);
    public abstract virtual SyntaxNode ClassDeclaration(string name, IEnumerable`1<string> typeParameters, Accessibility accessibility, DeclarationModifiers modifiers, SyntaxNode baseType, IEnumerable`1<SyntaxNode> interfaceTypes, IEnumerable`1<SyntaxNode> members);
    public abstract virtual SyntaxNode StructDeclaration(string name, IEnumerable`1<string> typeParameters, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> interfaceTypes, IEnumerable`1<SyntaxNode> members);
    public abstract virtual SyntaxNode InterfaceDeclaration(string name, IEnumerable`1<string> typeParameters, Accessibility accessibility, IEnumerable`1<SyntaxNode> interfaceTypes, IEnumerable`1<SyntaxNode> members);
    public abstract virtual SyntaxNode EnumDeclaration(string name, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> members);
    public abstract virtual SyntaxNode EnumMember(string name, SyntaxNode expression);
    public abstract virtual SyntaxNode DelegateDeclaration(string name, IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<string> typeParameters, SyntaxNode returnType, Accessibility accessibility, DeclarationModifiers modifiers);
    public SyntaxNode Declaration(ISymbol symbol);
    private static bool CanBeDeclared(ISymbol symbol);
    private SyntaxNode WithTypeParametersAndConstraints(SyntaxNode declaration, ImmutableArray`1<ITypeParameterSymbol> typeParameters);
    public abstract virtual SyntaxNode WithTypeParameters(SyntaxNode declaration, IEnumerable`1<string> typeParameters);
    public SyntaxNode WithTypeParameters(SyntaxNode declaration, String[] typeParameters);
    public abstract virtual SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kinds, IEnumerable`1<SyntaxNode> types);
    public SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kinds, SyntaxNode[] types);
    public SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, SyntaxNode[] types);
    public abstract virtual SyntaxNode NamespaceDeclaration(SyntaxNode name, IEnumerable`1<SyntaxNode> declarations);
    public SyntaxNode NamespaceDeclaration(SyntaxNode name, SyntaxNode[] declarations);
    public SyntaxNode NamespaceDeclaration(string name, IEnumerable`1<SyntaxNode> declarations);
    public SyntaxNode NamespaceDeclaration(string name, SyntaxNode[] declarations);
    public abstract virtual SyntaxNode CompilationUnit(IEnumerable`1<SyntaxNode> declarations);
    public SyntaxNode CompilationUnit(SyntaxNode[] declarations);
    public abstract virtual SyntaxNode NamespaceImportDeclaration(SyntaxNode name);
    public SyntaxNode NamespaceImportDeclaration(string name);
    public abstract virtual SyntaxNode Attribute(SyntaxNode name, IEnumerable`1<SyntaxNode> attributeArguments);
    public SyntaxNode Attribute(string name, IEnumerable`1<SyntaxNode> attributeArguments);
    public SyntaxNode Attribute(string name, SyntaxNode[] attributeArguments);
    public SyntaxNode Attribute(AttributeData attribute);
    private IEnumerable`1<SyntaxNode> GetSymbolAttributes(ISymbol symbol);
    public abstract virtual SyntaxNode AttributeArgument(string name, SyntaxNode expression);
    public SyntaxNode AttributeArgument(SyntaxNode expression);
    public SyntaxNode RemoveAllAttributes(SyntaxNode declaration);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetAttributes(SyntaxNode declaration);
    public abstract virtual SyntaxNode InsertAttributes(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributes);
    public SyntaxNode InsertAttributes(SyntaxNode declaration, int index, SyntaxNode[] attributes);
    public SyntaxNode AddAttributes(SyntaxNode declaration, IEnumerable`1<SyntaxNode> attributes);
    public SyntaxNode AddAttributes(SyntaxNode declaration, SyntaxNode[] attributes);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetReturnAttributes(SyntaxNode declaration);
    public abstract virtual SyntaxNode InsertReturnAttributes(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributes);
    public SyntaxNode InsertReturnAttributes(SyntaxNode declaration, int index, SyntaxNode[] attributes);
    public SyntaxNode AddReturnAttributes(SyntaxNode declaration, IEnumerable`1<SyntaxNode> attributes);
    public SyntaxNode AddReturnAttributes(SyntaxNode declaration, SyntaxNode[] attributes);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetAttributeArguments(SyntaxNode attributeDeclaration);
    public abstract virtual SyntaxNode InsertAttributeArguments(SyntaxNode attributeDeclaration, int index, IEnumerable`1<SyntaxNode> attributeArguments);
    public SyntaxNode AddAttributeArguments(SyntaxNode attributeDeclaration, IEnumerable`1<SyntaxNode> attributeArguments);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetNamespaceImports(SyntaxNode declaration);
    public abstract virtual SyntaxNode InsertNamespaceImports(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> imports);
    public SyntaxNode InsertNamespaceImports(SyntaxNode declaration, int index, SyntaxNode[] imports);
    public SyntaxNode AddNamespaceImports(SyntaxNode declaration, IEnumerable`1<SyntaxNode> imports);
    public SyntaxNode AddNamespaceImports(SyntaxNode declaration, SyntaxNode[] imports);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetMembers(SyntaxNode declaration);
    public abstract virtual SyntaxNode InsertMembers(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> members);
    public SyntaxNode InsertMembers(SyntaxNode declaration, int index, SyntaxNode[] members);
    public SyntaxNode AddMembers(SyntaxNode declaration, IEnumerable`1<SyntaxNode> members);
    public SyntaxNode AddMembers(SyntaxNode declaration, SyntaxNode[] members);
    public abstract virtual Accessibility GetAccessibility(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithAccessibility(SyntaxNode declaration, Accessibility accessibility);
    public abstract virtual DeclarationModifiers GetModifiers(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithModifiers(SyntaxNode declaration, DeclarationModifiers modifiers);
    public abstract virtual DeclarationKind GetDeclarationKind(SyntaxNode declaration);
    public abstract virtual string GetName(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithName(SyntaxNode declaration, string name);
    public abstract virtual SyntaxNode GetType(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithType(SyntaxNode declaration, SyntaxNode type);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetParameters(SyntaxNode declaration);
    public abstract virtual SyntaxNode InsertParameters(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> parameters);
    public SyntaxNode AddParameters(SyntaxNode declaration, IEnumerable`1<SyntaxNode> parameters);
    public abstract virtual SyntaxNode GetExpression(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithExpression(SyntaxNode declaration, SyntaxNode expression);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetStatements(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithStatements(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetAccessors(SyntaxNode declaration);
    public SyntaxNode GetAccessor(SyntaxNode declaration, DeclarationKind kind);
    public abstract virtual SyntaxNode InsertAccessors(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> accessors);
    public SyntaxNode AddAccessors(SyntaxNode declaration, IEnumerable`1<SyntaxNode> accessors);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetGetAccessorStatements(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithGetAccessorStatements(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetSetAccessorStatements(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithSetAccessorStatements(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetBaseAndInterfaceTypes(SyntaxNode declaration);
    public abstract virtual SyntaxNode AddBaseType(SyntaxNode declaration, SyntaxNode baseType);
    public abstract virtual SyntaxNode AddInterfaceType(SyntaxNode declaration, SyntaxNode interfaceType);
    public virtual SyntaxNode ReplaceNode(SyntaxNode root, SyntaxNode node, SyntaxNode newDeclaration);
    public virtual SyntaxNode InsertNodesBefore(SyntaxNode root, SyntaxNode node, IEnumerable`1<SyntaxNode> newDeclarations);
    public virtual SyntaxNode InsertNodesAfter(SyntaxNode root, SyntaxNode node, IEnumerable`1<SyntaxNode> newDeclarations);
    public virtual SyntaxNode RemoveNode(SyntaxNode root, SyntaxNode node);
    public SyntaxNode RemoveNodes(SyntaxNode root, IEnumerable`1<SyntaxNode> declarations);
    protected static SyntaxNode PreserveTrivia(TNode node, Func`2<TNode, SyntaxNode> nodeChanger);
    protected static SyntaxNode ReplaceWithTrivia(SyntaxNode root, SyntaxNode original, SyntaxNode replacement);
    protected static SyntaxNode ReplaceWithTrivia(SyntaxNode root, TNode original, Func`2<TNode, SyntaxNode> replacer);
    protected static SyntaxNode ReplaceWithTrivia(SyntaxNode root, SyntaxToken original, SyntaxToken replacement);
    public abstract virtual TNode ClearTrivia(TNode node);
    protected int IndexOf(IReadOnlyList`1<T> list, T element);
    protected static SyntaxNode ReplaceRange(SyntaxNode root, SyntaxNode node, IEnumerable`1<SyntaxNode> replacements);
    protected static SeparatedSyntaxList`1<TNode> RemoveRange(SeparatedSyntaxList`1<TNode> list, int offset, int count);
    protected static SyntaxList`1<TNode> RemoveRange(SyntaxList`1<TNode> list, int offset, int count);
    public abstract virtual SyntaxNode ExpressionStatement(SyntaxNode expression);
    public abstract virtual SyntaxNode ReturnStatement(SyntaxNode expression);
    public abstract virtual SyntaxNode ThrowStatement(SyntaxNode expression);
    public abstract virtual SyntaxNode LocalDeclarationStatement(SyntaxNode type, string identifier, SyntaxNode initializer, bool isConst);
    public SyntaxNode LocalDeclarationStatement(ITypeSymbol type, string name, SyntaxNode initializer, bool isConst);
    public SyntaxNode LocalDeclarationStatement(string name, SyntaxNode initializer);
    public abstract virtual SyntaxNode IfStatement(SyntaxNode condition, IEnumerable`1<SyntaxNode> trueStatements, IEnumerable`1<SyntaxNode> falseStatements);
    public SyntaxNode IfStatement(SyntaxNode condition, IEnumerable`1<SyntaxNode> trueStatements, SyntaxNode falseStatement);
    public abstract virtual SyntaxNode SwitchStatement(SyntaxNode expression, IEnumerable`1<SyntaxNode> sections);
    public SyntaxNode SwitchStatement(SyntaxNode expression, SyntaxNode[] sections);
    public abstract virtual SyntaxNode SwitchSection(IEnumerable`1<SyntaxNode> caseExpressions, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode SwitchSection(SyntaxNode caseExpression, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode DefaultSwitchSection(IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode ExitSwitchStatement();
    public abstract virtual SyntaxNode UsingStatement(SyntaxNode type, string name, SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode UsingStatement(string name, SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode UsingStatement(SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode TryCatchStatement(IEnumerable`1<SyntaxNode> tryStatements, IEnumerable`1<SyntaxNode> catchClauses, IEnumerable`1<SyntaxNode> finallyStatements);
    public SyntaxNode TryCatchStatement(IEnumerable`1<SyntaxNode> tryStatements, SyntaxNode[] catchClauses);
    public SyntaxNode TryFinallyStatement(IEnumerable`1<SyntaxNode> tryStatements, IEnumerable`1<SyntaxNode> finallyStatements);
    public abstract virtual SyntaxNode CatchClause(SyntaxNode type, string identifier, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode CatchClause(ITypeSymbol type, string identifier, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode WhileStatement(SyntaxNode condition, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode DefaultExpression(SyntaxNode type);
    public abstract virtual SyntaxNode DefaultExpression(ITypeSymbol type);
    public abstract virtual SyntaxNode ThisExpression();
    public abstract virtual SyntaxNode BaseExpression();
    public abstract virtual SyntaxNode LiteralExpression(object value);
    public abstract virtual SyntaxNode TypedConstantExpression(TypedConstant value);
    public SyntaxNode FalseLiteralExpression();
    public SyntaxNode TrueLiteralExpression();
    public SyntaxNode NullLiteralExpression();
    public abstract virtual SyntaxNode IdentifierName(string identifier);
    public abstract virtual SyntaxNode GenericName(string identifier, IEnumerable`1<SyntaxNode> typeArguments);
    public SyntaxNode GenericName(string identifier, IEnumerable`1<ITypeSymbol> typeArguments);
    public SyntaxNode GenericName(string identifier, SyntaxNode[] typeArguments);
    public SyntaxNode GenericName(string identifier, ITypeSymbol[] typeArguments);
    public abstract virtual SyntaxNode WithTypeArguments(SyntaxNode expression, IEnumerable`1<SyntaxNode> typeArguments);
    public SyntaxNode WithTypeArguments(SyntaxNode expression, SyntaxNode[] typeArguments);
    public abstract virtual SyntaxNode QualifiedName(SyntaxNode left, SyntaxNode right);
    public SyntaxNode DottedName(string dottedName);
    public abstract virtual SyntaxNode TypeExpression(ITypeSymbol typeSymbol);
    public abstract virtual SyntaxNode TypeExpression(SpecialType specialType);
    public abstract virtual SyntaxNode ArrayTypeExpression(SyntaxNode type);
    public abstract virtual SyntaxNode NullableTypeExpression(SyntaxNode type);
    public abstract virtual SyntaxNode AssignmentStatement(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode ValueEqualsExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode ReferenceEqualsExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode ValueNotEqualsExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode ReferenceNotEqualsExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode LessThanExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode LessThanOrEqualExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode GreaterThanExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode GreaterThanOrEqualExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode NegateExpression(SyntaxNode expression);
    public abstract virtual SyntaxNode AddExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode SubtractExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode MultiplyExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode DivideExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode ModuloExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode BitwiseAndExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode BitwiseOrExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode BitwiseNotExpression(SyntaxNode operand);
    public abstract virtual SyntaxNode LogicalAndExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode LogicalOrExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode LogicalNotExpression(SyntaxNode expression);
    public abstract virtual SyntaxNode ConditionalExpression(SyntaxNode condition, SyntaxNode whenTrue, SyntaxNode whenFalse);
    public abstract virtual SyntaxNode CoalesceExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode MemberAccessExpression(SyntaxNode expression, SyntaxNode memberName);
    public SyntaxNode MemberAccessExpression(SyntaxNode expression, string memberName);
    public abstract virtual SyntaxNode ObjectCreationExpression(SyntaxNode namedType, IEnumerable`1<SyntaxNode> arguments);
    public SyntaxNode ObjectCreationExpression(ITypeSymbol type, IEnumerable`1<SyntaxNode> arguments);
    public SyntaxNode ObjectCreationExpression(SyntaxNode type, SyntaxNode[] arguments);
    public SyntaxNode ObjectCreationExpression(ITypeSymbol type, SyntaxNode[] arguments);
    public abstract virtual SyntaxNode InvocationExpression(SyntaxNode expression, IEnumerable`1<SyntaxNode> arguments);
    public SyntaxNode InvocationExpression(SyntaxNode expression, SyntaxNode[] arguments);
    public abstract virtual SyntaxNode Argument(string name, RefKind refKind, SyntaxNode expression);
    public SyntaxNode Argument(RefKind refKind, SyntaxNode expression);
    public SyntaxNode Argument(SyntaxNode expression);
    public abstract virtual SyntaxNode ElementAccessExpression(SyntaxNode expression, IEnumerable`1<SyntaxNode> arguments);
    public SyntaxNode ElementAccessExpression(SyntaxNode expression, SyntaxNode[] arguments);
    public abstract virtual SyntaxNode TypeOfExpression(SyntaxNode type);
    public abstract virtual SyntaxNode IsTypeExpression(SyntaxNode expression, SyntaxNode type);
    public SyntaxNode IsTypeExpression(SyntaxNode expression, ITypeSymbol type);
    public abstract virtual SyntaxNode TryCastExpression(SyntaxNode expression, SyntaxNode type);
    public SyntaxNode TryCastExpression(SyntaxNode expression, ITypeSymbol type);
    public abstract virtual SyntaxNode CastExpression(SyntaxNode type, SyntaxNode expression);
    public SyntaxNode CastExpression(ITypeSymbol type, SyntaxNode expression);
    public abstract virtual SyntaxNode ConvertExpression(SyntaxNode type, SyntaxNode expression);
    public SyntaxNode ConvertExpression(ITypeSymbol type, SyntaxNode expression);
    public abstract virtual SyntaxNode ValueReturningLambdaExpression(IEnumerable`1<SyntaxNode> lambdaParameters, SyntaxNode expression);
    public abstract virtual SyntaxNode VoidReturningLambdaExpression(IEnumerable`1<SyntaxNode> lambdaParameters, SyntaxNode expression);
    public abstract virtual SyntaxNode ValueReturningLambdaExpression(IEnumerable`1<SyntaxNode> lambdaParameters, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode VoidReturningLambdaExpression(IEnumerable`1<SyntaxNode> lambdaParameters, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode ValueReturningLambdaExpression(string parameterName, SyntaxNode expression);
    public SyntaxNode VoidReturningLambdaExpression(string parameterName, SyntaxNode expression);
    public SyntaxNode ValueReturningLambdaExpression(string parameterName, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode VoidReturningLambdaExpression(string parameterName, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode ValueReturningLambdaExpression(SyntaxNode expression);
    public SyntaxNode VoidReturningLambdaExpression(SyntaxNode expression);
    public SyntaxNode ValueReturningLambdaExpression(IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode VoidReturningLambdaExpression(IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode LambdaParameter(string identifier, SyntaxNode type);
    public SyntaxNode LambdaParameter(string identifier, ITypeSymbol type);
    public abstract virtual SyntaxNode AwaitExpression(SyntaxNode expression);
    [CompilerGeneratedAttribute]
private SyntaxNode <MethodDeclaration>b__9_0(IParameterSymbol p);
    [CompilerGeneratedAttribute]
private SyntaxNode <IndexerDeclaration>b__15_0(IParameterSymbol p);
    [CompilerGeneratedAttribute]
private SyntaxNode <CustomEventDeclaration>b__19_1(IParameterSymbol p);
    [CompilerGeneratedAttribute]
private SyntaxNode <ConstructorDeclaration>b__21_0(IParameterSymbol p);
    [CompilerGeneratedAttribute]
private SyntaxNode <Declaration>b__32_0(INamedTypeSymbol i);
    [CompilerGeneratedAttribute]
private SyntaxNode <Declaration>b__32_1(ISymbol m);
    [CompilerGeneratedAttribute]
private SyntaxNode <Declaration>b__32_2(INamedTypeSymbol i);
    [CompilerGeneratedAttribute]
private SyntaxNode <Declaration>b__32_3(ISymbol m);
    [CompilerGeneratedAttribute]
private SyntaxNode <Declaration>b__32_4(INamedTypeSymbol i);
    [CompilerGeneratedAttribute]
private SyntaxNode <Declaration>b__32_5(ISymbol m);
    [CompilerGeneratedAttribute]
private SyntaxNode <Declaration>b__32_6(ISymbol m);
    [CompilerGeneratedAttribute]
private SyntaxNode <Declaration>b__32_7(IParameterSymbol p);
    [CompilerGeneratedAttribute]
private SyntaxNode <WithTypeParametersAndConstraints>b__34_1(ITypeSymbol t);
    [CompilerGeneratedAttribute]
private SyntaxNode <Attribute>b__51_0(TypedConstant a);
    [CompilerGeneratedAttribute]
private SyntaxNode <Attribute>b__51_1(KeyValuePair`2<string, TypedConstant> n);
    [CompilerGeneratedAttribute]
private SyntaxNode <GetSymbolAttributes>b__52_0(AttributeData a);
    [CompilerGeneratedAttribute]
private SyntaxNode <GenericName>b__154_0(ITypeSymbol ta);
}
internal interface Microsoft.CodeAnalysis.ErrorLogger.IErrorLoggerService {
    public abstract virtual void LogException(object source, Exception exception);
    public abstract virtual bool TryLogException(object source, Exception exception);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.ErrorLogger.IErrorLoggerService", "Default")]
[ExportAttribute("Microsoft.CodeAnalysis.ErrorLogger.IErrorLoggerService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ErrorLogger.WorkspaceErrorLogger : object {
    public sealed virtual void LogException(object source, Exception exception);
    public sealed virtual bool TryLogException(object source, Exception exception);
    private static string ToLogFormat(Exception exception);
}
internal static class Microsoft.CodeAnalysis.ErrorReporting.FatalError : object {
    private static Action`1<Exception> s_fatalHandler;
    private static Action`1<Exception> s_nonFatalHandler;
    private static Exception s_reportedException;
    private static string s_reportedExceptionMessage;
    public static Action`1<Exception> Handler { get; public set; }
    public static Action`1<Exception> NonFatalHandler { get; public set; }
    public static Action`1<Exception> get_Handler();
    public static void set_Handler(Action`1<Exception> value);
    public static Action`1<Exception> get_NonFatalHandler();
    public static void set_NonFatalHandler(Action`1<Exception> value);
    public static void OverwriteHandler(Action`1<Exception> value);
    [DebuggerHiddenAttribute]
public static bool ReportUnlessCanceled(Exception exception);
    [DebuggerHiddenAttribute]
public static bool ReportWithoutCrashUnlessCanceled(Exception exception);
    [DebuggerHiddenAttribute]
public static bool ReportUnlessNotImplemented(Exception exception);
    [DebuggerHiddenAttribute]
public static bool Report(Exception exception);
    [DebuggerHiddenAttribute]
public static bool ReportWithoutCrash(Exception exception);
    private static void Report(Exception exception, Action`1<Exception> handler);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.ExtensionOrderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <After>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Before>k__BackingField;
    public string After { get; public set; }
    public string Before { get; public set; }
    [CompilerGeneratedAttribute]
public string get_After();
    [CompilerGeneratedAttribute]
public void set_After(string value);
    [CompilerGeneratedAttribute]
public string get_Before();
    [CompilerGeneratedAttribute]
public void set_Before(string value);
}
internal abstract class Microsoft.CodeAnalysis.Extensions.AbstractExtensionManager : object {
    private ConcurrentSet`1<object> _disabledProviders;
    private ConcurrentSet`1<object> _ignoredProviders;
    protected void DisableProvider(object provider);
    protected void EnableProvider(object provider);
    protected void IgnoreProvider(object provider);
    public bool IsIgnored(object provider);
    public sealed virtual bool IsDisabled(object provider);
    public virtual bool CanHandleException(object provider, Exception exception);
    public virtual void HandleException(object provider, Exception exception);
}
internal interface Microsoft.CodeAnalysis.Extensions.IErrorReportingService {
    public abstract virtual void ShowErrorInfoForCodeFix(string codefixName, Action OnEnableClicked, Action OnEnableAndIgnoreClicked);
}
internal interface Microsoft.CodeAnalysis.Extensions.IExtensionManager {
    public abstract virtual bool IsDisabled(object provider);
    public abstract virtual bool CanHandleException(object provider, Exception exception);
    public abstract virtual void HandleException(object provider, Exception exception);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions : object {
    [ExtensionAttribute]
public static void PerformAction(IExtensionManager extensionManager, object extension, Action action);
    [ExtensionAttribute]
public static T PerformFunction(IExtensionManager extensionManager, object extension, Func`1<T> function, T defaultValue);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions/<PerformActionAsync>d__2")]
[ExtensionAttribute]
public static Task PerformActionAsync(IExtensionManager extensionManager, object extension, Func`1<Task> function);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions/<PerformFunctionAsync>d__3`1")]
[ExtensionAttribute]
public static Task`1<T> PerformFunctionAsync(IExtensionManager extensionManager, object extension, Func`1<Task`1<T>> function, T defaultValue);
    [ExtensionAttribute]
public static Func`2<SyntaxNode, List`1<TExtension>> CreateNodeExtensionGetter(IExtensionManager extensionManager, IEnumerable`1<TExtension> extensions, Func`2<TExtension, IEnumerable`1<Type>> nodeTypeGetter);
    [ExtensionAttribute]
public static Func`2<SyntaxToken, List`1<TExtension>> CreateTokenExtensionGetter(IExtensionManager extensionManager, IEnumerable`1<TExtension> extensions, Func`2<TExtension, IEnumerable`1<int>> tokenKindGetter);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Extensions.IExtensionManager", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Extensions.ServicesLayerExtensionManager : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal static class Microsoft.CodeAnalysis.FailFast : object {
    [DebuggerHiddenAttribute]
internal static void OnFatalException(Exception exception);
    [ConditionalAttribute("DEBUG")]
[DebuggerHiddenAttribute]
internal static void Assert(bool condition, string message);
}
internal abstract class Microsoft.CodeAnalysis.FindSymbols.AbstractPersistableState : object {
    public VersionStamp Version;
    protected AbstractPersistableState(VersionStamp version);
    protected void WriteVersion(ObjectWriter writer, string formatVersion);
    private static bool TryReadVersion(ObjectReader reader, string formatVersion, VersionStamp& version);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.AbstractPersistableState/<LoadAsync>d__4`1")]
protected static Task`1<T> LoadAsync(Document document, string persistenceName, string formatVersion, Func`3<ObjectReader, VersionStamp, T> readFrom, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.AbstractPersistableState/<SaveAsync>d__5`1")]
protected static Task`1<bool> SaveAsync(Document document, string persistenceName, string formatVersion, T data, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.AbstractPersistableState/<PrecalculatedAsync>d__6")]
protected static Task`1<bool> PrecalculatedAsync(Document document, string persistenceName, string formatVersion, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.FindSymbols.AbstractSyntaxTreeInfo : AbstractPersistableState {
    protected AbstractSyntaxTreeInfo(VersionStamp version);
    public abstract virtual void WriteTo(ObjectWriter writer);
    public abstract virtual Task`1<bool> SaveAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.AbstractSyntaxTreeInfo/<SaveAsync>d__3")]
protected Task`1<bool> SaveAsync(Document document, ConditionalWeakTable`2<BranchId, ConditionalWeakTable`2<DocumentId, AbstractSyntaxTreeInfo>> cache, string persistenceName, string serializationFormat, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.AbstractSyntaxTreeInfo/<LoadAsync>d__4")]
protected static Task`1<AbstractSyntaxTreeInfo> LoadAsync(Document document, Func`3<ObjectReader, VersionStamp, AbstractSyntaxTreeInfo> reader, ConditionalWeakTable`2<BranchId, ConditionalWeakTable`2<DocumentId, AbstractSyntaxTreeInfo>> cache, string persistenceName, string serializationFormat, CancellationToken cancellationToken);
    private static ConditionalWeakTable`2<DocumentId, AbstractSyntaxTreeInfo> GetInfoTable(BranchId branchId, Workspace workspace, ConditionalWeakTable`2<BranchId, ConditionalWeakTable`2<DocumentId, AbstractSyntaxTreeInfo>> cache);
    [CompilerGeneratedAttribute]
private AbstractSyntaxTreeInfo <SaveAsync>b__3_0(DocumentId _);
    [CompilerGeneratedAttribute]
private AbstractSyntaxTreeInfo <SaveAsync>b__3_1(DocumentId _);
}
internal class Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContainerDisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullyQualifiedContainerName>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclaredSymbolInfoKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <ParameterCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <TypeParameterCount>k__BackingField;
    public string Name { get; }
    public string ContainerDisplayName { get; }
    public string FullyQualifiedContainerName { get; }
    public DeclaredSymbolInfoKind Kind { get; }
    public TextSpan Span { get; }
    public ushort ParameterCount { get; }
    public ushort TypeParameterCount { get; }
    public DeclaredSymbolInfo(string name, string containerDisplayName, string fullyQualifiedContainerName, DeclaredSymbolInfoKind kind, TextSpan span, ushort parameterCount, ushort typeParameterCount);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_ContainerDisplayName();
    [CompilerGeneratedAttribute]
public string get_FullyQualifiedContainerName();
    [CompilerGeneratedAttribute]
public DeclaredSymbolInfoKind get_Kind();
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public ushort get_ParameterCount();
    [CompilerGeneratedAttribute]
public ushort get_TypeParameterCount();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfo/<GetSymbolAsync>d__22")]
public Task`1<ISymbol> GetSymbolAsync(Document document, CancellationToken cancellationToken);
    internal void WriteTo(ObjectWriter writer);
    internal static DeclaredSymbolInfo ReadFrom(ObjectReader reader);
}
internal enum Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfoKind : Enum {
    public byte value__;
    public static DeclaredSymbolInfoKind Class;
    public static DeclaredSymbolInfoKind Constant;
    public static DeclaredSymbolInfoKind Constructor;
    public static DeclaredSymbolInfoKind Delegate;
    public static DeclaredSymbolInfoKind Enum;
    public static DeclaredSymbolInfoKind EnumMember;
    public static DeclaredSymbolInfoKind Event;
    public static DeclaredSymbolInfoKind Field;
    public static DeclaredSymbolInfoKind Indexer;
    public static DeclaredSymbolInfoKind Interface;
    public static DeclaredSymbolInfoKind Method;
    public static DeclaredSymbolInfoKind Module;
    public static DeclaredSymbolInfoKind Property;
    public static DeclaredSymbolInfoKind Struct;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder : object {
    private static ConditionalWeakTable`2<Solution, ConcurrentDictionary`2<DefinitionProject, IEnumerable`1<DependentProject>>> s_dependentProjectsCache;
    private static CreateValueCallback<Solution, ConcurrentDictionary`2<DefinitionProject, IEnumerable`1<DependentProject>>> s_createDependentProjectsMapCallback;
    private static DependentProjectsFinder();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder/<GetDependentProjectsAsync>d__4")]
public static Task`1<IEnumerable`1<Project>> GetDependentProjectsAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    private static IEnumerable`1<Project> GetAllProjects(Solution solution);
    private static IEnumerable`1<Project> GetProjects(Solution solution, IEnumerable`1<ProjectId> projectIds);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder/<GetDependentProjectsWorkerAsync>d__7")]
[ExtensionAttribute]
private static Task`1<IEnumerable`1<Project>> GetDependentProjectsWorkerAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder/<GetDependentProjectsCoreAsync>d__8")]
private static Task`1<IEnumerable`1<DependentProject>> GetDependentProjectsCoreAsync(ISymbol symbol, Solution solution, Project sourceProject, SymbolVisibility visibility, CancellationToken cancellationToken);
    private static IEnumerable`1<Project> FilterDependentProjectsByVisibility(Solution solution, IEnumerable`1<DependentProject> dependentProjects, SymbolVisibility visibility);
    private static bool IsInternalsVisibleToAttribute(AttributeData attr);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder/<AddNonSubmissionDependentProjectsAsync>d__11")]
private static Task AddNonSubmissionDependentProjectsAsync(IAssemblySymbol sourceAssembly, Solution solution, Project sourceProject, HashSet`1<DependentProject> dependentProjects, CancellationToken cancellationToken);
    private static Lazy`1<HashSet`1<string>> CreateInternalsVisibleToMap(IAssemblySymbol assembly);
    private static bool HasReferenceTo(IAssemblySymbol containingAssembly, Project sourceProject, Project project, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder : object {
    private static ConditionalWeakTable`2<Compilation, List`1<INamedTypeSymbol>> s_compilationAllSourceAndAccessibleTypesTable;
    private static ConditionalWeakTable`2<Compilation, List`1<INamedTypeSymbol>> s_compilationSourceTypesTable;
    private static Func`3<INamedTypeSymbol, INamedTypeSymbol, bool> s_findDerivedClassesPredicate;
    private static ConditionalWeakTable`2<Compilation, ConcurrentDictionary`2<SymbolKey, List`1<SymbolKey>>> s_derivedClassesCache;
    private static Func`3<INamedTypeSymbol, INamedTypeSymbol, bool> s_findDerivedInterfacesPredicate;
    private static ConditionalWeakTable`2<Compilation, ConcurrentDictionary`2<SymbolKey, List`1<SymbolKey>>> s_derivedInterfacesCache;
    private static Func`3<INamedTypeSymbol, INamedTypeSymbol, bool> s_findImplementingInterfacesPredicate;
    private static ConditionalWeakTable`2<Compilation, ConcurrentDictionary`2<SymbolKey, List`1<SymbolKey>>> s_implementingInterfacesCache;
    private static IEqualityComparer`1<SymbolKey> s_symbolIdComparer;
    private static CreateValueCallback<Compilation, ConcurrentDictionary`2<SymbolKey, List`1<SymbolKey>>> s_createSymbolDictionary;
    private static DependentTypeFinder();
    public static Task`1<IEnumerable`1<INamedTypeSymbol>> FindDerivedClassesAsync(INamedTypeSymbol type, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<INamedTypeSymbol>> FindDerivedInterfacesAsync(INamedTypeSymbol type, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<INamedTypeSymbol>> FindImplementingTypesAsync(INamedTypeSymbol type, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<GetDependentTypesAsync>d__13")]
private static Task`1<IEnumerable`1<INamedTypeSymbol>> GetDependentTypesAsync(INamedTypeSymbol type, Solution solution, IImmutableSet`1<Project> projects, Func`3<INamedTypeSymbol, INamedTypeSymbol, bool> predicate, ConditionalWeakTable`2<Compilation, ConcurrentDictionary`2<SymbolKey, List`1<SymbolKey>>> cache, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<GetDependentTypesInProjectAsync>d__14")]
private static Task GetDependentTypesInProjectAsync(INamedTypeSymbol type, Project project, Solution solution, Func`3<INamedTypeSymbol, INamedTypeSymbol, bool> predicate, ConditionalWeakTable`2<Compilation, ConcurrentDictionary`2<SymbolKey, List`1<SymbolKey>>> cache, bool locationsInMetadata, ConcurrentSet`1<ISymbol> results, CancellationToken cancellationToken);
    private static List`1<INamedTypeSymbol> GetAllSourceAndAccessibleTypesInCompilation(Compilation compilation, CancellationToken cancellationToken);
    private static List`1<INamedTypeSymbol> GetAllSourceTypesInCompilation(Compilation compilation, CancellationToken cancellationToken);
    private static bool TryGetDependentTypes(ConditionalWeakTable`2<Compilation, ConcurrentDictionary`2<SymbolKey, List`1<SymbolKey>>> cache, Compilation compilation, SymbolKey typeId, List`1& dependentTypeIds);
    private static List`1<SymbolKey> GetOrAddDependentTypes(ConditionalWeakTable`2<Compilation, ConcurrentDictionary`2<SymbolKey, List`1<SymbolKey>>> cache, Compilation compilation, SymbolKey typeId, List`1<SymbolKey> dependentTypeIds);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FindSymbols.Extensions : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Extensions/<GetConstructorInitializerTokensAsync>d__0")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<SyntaxToken>> GetConstructorInitializerTokensAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Extensions/<GetIdentifierOrGlobalNamespaceTokensWithTextAsync>d__1")]
[ExtensionAttribute]
internal static Task`1<IEnumerable`1<SyntaxToken>> GetIdentifierOrGlobalNamespaceTokensWithTextAsync(Document document, string identifier, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool TextMatch(ISyntaxFactsService syntaxFacts, string text1, string text2);
}
internal abstract class Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractMemberScopedReferenceFinder`1 : AbstractReferenceFinder`1<TSymbol> {
    protected sealed virtual bool CanFind(TSymbol symbol);
    protected virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(TSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractMemberScopedReferenceFinder`1/<FindReferencesInDocumentAsync>d__2")]
protected virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(TSymbol symbol, Document document, CancellationToken cancellationToken);
    private static ISymbol GetContainer(ISymbol symbol);
    protected Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInTokensWithSymbolNameAsync(TSymbol symbol, Document document, IEnumerable`1<SyntaxToken> tokens, CancellationToken cancellationToken, Func`2<SyntaxToken, SyntaxNode> findParentNode);
    private Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInContainerAsync(TSymbol symbol, ISymbol container, Document document, CancellationToken cancellationToken, Func`2<SyntaxToken, SyntaxNode> findParentNode);
    protected abstract virtual Func`2<SyntaxToken, bool> GetTokensMatchFunction(ISyntaxFactsService syntaxFacts, string name);
}
internal abstract class Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1 : AbstractReferenceFinder`1<TSymbol> {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1/<DetermineCascadedSymbolsAsync>d__1")]
protected virtual Task`1<IEnumerable`1<ISymbol>> DetermineCascadedSymbolsAsync(TSymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder`1 : object {
    protected abstract virtual bool CanFind(TSymbol symbol);
    protected abstract virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(TSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected abstract virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(TSymbol symbol, Document document, CancellationToken cancellationToken);
    public sealed virtual Task`1<IEnumerable`1<Project>> DetermineProjectsToSearchAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    public sealed virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(ISymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    public sealed virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(ISymbol symbol, Document document, CancellationToken cancellationToken);
    public sealed virtual Task`1<IEnumerable`1<ISymbol>> DetermineCascadedSymbolsAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<Project>> DetermineProjectsToSearchAsync(TSymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<ISymbol>> DetermineCascadedSymbolsAsync(TSymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    protected static bool TryGetNameWithoutAttributeSuffix(string name, ISyntaxFactsService syntaxFacts, String& result);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder`1/<FindDocumentsAsync>d__10")]
protected Task`1<IEnumerable`1<Document>> FindDocumentsAsync(Project project, IImmutableSet`1<Document> scope, Func`3<Document, CancellationToken, Task`1<bool>> predicateAsync, CancellationToken cancellationToken);
    protected Task`1<IEnumerable`1<Document>> FindDocumentsAsync(Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken, String[] values);
    protected Task`1<IEnumerable`1<Document>> FindDocumentsAsync(Project project, IImmutableSet`1<Document> documents, PredefinedType predefinedType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder`1/<FindDocumentsAsync>d__13")]
protected Task`1<IEnumerable`1<Document>> FindDocumentsAsync(Project project, IImmutableSet`1<Document> documents, PredefinedOperator op, CancellationToken cancellationToken);
    protected static bool IdentifiersMatch(ISyntaxFactsService syntaxFacts, string name, SyntaxToken token);
    protected static Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentUsingSymbolNameAsync(TSymbol symbol, Document document, CancellationToken cancellationToken);
    protected static Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentUsingIdentifierAsync(ISymbol symbol, string identifier, Document document, CancellationToken cancellationToken, Func`2<SyntaxToken, SyntaxNode> findParentNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder`1/<FindReferencesInDocumentUsingIdentifierAsync>d__17")]
protected static Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentUsingIdentifierAsync(string identifier, Document document, Func`3<SyntaxToken, SemanticModel, ValueTuple`2<bool, CandidateReason>> symbolsMatch, CancellationToken cancellationToken);
    protected static Func`3<SyntaxToken, SemanticModel, ValueTuple`2<bool, CandidateReason>> GetStandardSymbolsMatchFunction(ISymbol symbol, Func`2<SyntaxToken, SyntaxNode> findParentNode, Solution solution, CancellationToken cancellationToken);
    protected static Func`3<SyntaxNode, SemanticModel, ValueTuple`2<bool, CandidateReason>> GetStandardSymbolsNodeMatchFunction(ISymbol searchSymbol, Solution solution, CancellationToken cancellationToken);
    private static bool OriginalSymbolsMatch(ISymbol searchSymbol, ISymbol symbolToMatch, Solution solution, Compilation& searchSymbolCompilation, Compilation symbolToMatchCompilation, CancellationToken cancellationToken);
    private static bool NamespaceSymbolsMatch(INamespaceSymbol namespace1, INamespaceSymbol namespace2, Solution solution, CancellationToken cancellationToken);
    private static bool OriginalSymbolsMatchCore(ISymbol searchSymbol, ISymbol symbolToMatch, Solution solution, Compilation& searchSymbolCompilation, Compilation symbolToMatchCompilation, CancellationToken cancellationToken);
    private static bool VerifyForwardedTypes(Dictionary`2<INamedTypeSymbol, INamedTypeSymbol> equivalentTypesWithDifferingAssemblies, ISymbol searchSymbol, ISymbol symbolToMatch, Solution solution, Compilation& searchSymbolCompilation, Compilation symbolToMatchCompilation, CancellationToken cancellationToken);
    private static int VerifyForwardedTypes(Dictionary`2<INamedTypeSymbol, INamedTypeSymbol> equivalentTypesWithDifferingAssemblies, Compilation compilation, HashSet`1<INamedTypeSymbol> verifiedKeys, bool isSearchSymbolCompilation);
    private static bool TryGetCompilation(ISymbol symbol, Solution solution, Compilation& definingCompilation, CancellationToken cancellationToken);
    protected Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInTokensAsync(TSymbol symbol, Document document, IEnumerable`1<SyntaxToken> tokens, Func`2<SyntaxToken, bool> tokensMatch, CancellationToken cancellationToken, Func`2<SyntaxToken, SyntaxNode> findParentNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder`1/<FindReferencesInTokensAsync>d__27")]
protected static Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInTokensAsync(Document document, IEnumerable`1<SyntaxToken> tokens, Func`2<SyntaxToken, bool> tokensMatch, Func`3<SyntaxToken, SemanticModel, ValueTuple`2<bool, CandidateReason>> symbolsMatch, CancellationToken cancellationToken);
    protected static Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(TSymbol symbol, Document document, Func`2<SyntaxToken, bool> tokensMatch, CancellationToken cancellationToken, Func`2<SyntaxToken, SyntaxNode> findParentNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder`1/<FindReferencesInDocumentAsync>d__29")]
protected static Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(TSymbol symbol, Document document, Func`2<SyntaxToken, bool> tokensMatch, Func`3<SyntaxToken, SemanticModel, ValueTuple`2<bool, CandidateReason>> symbolsMatch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder`1/<GetAliasSymbolAsync>d__30")]
private static Task`1<IAliasSymbol> GetAliasSymbolAsync(Document document, ReferenceLocation location, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder`1/<FindAliasReferencesAsync>d__31")]
protected static Task`1<IEnumerable`1<ReferenceLocation>> FindAliasReferencesAsync(IEnumerable`1<ReferenceLocation> nonAliasReferences, ISymbol symbol, Document document, CancellationToken cancellationToken, Func`2<SyntaxToken, SyntaxNode> findParentNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder`1/<FindAliasReferencesAsync>d__32")]
protected static Task`1<IEnumerable`1<ReferenceLocation>> FindAliasReferencesAsync(IEnumerable`1<ReferenceLocation> nonAliasReferences, ISymbol symbol, Document document, Func`3<SyntaxToken, SemanticModel, ValueTuple`2<bool, CandidateReason>> symbolsMatch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder`1/<GetAliasSymbolsAsync>d__33")]
private static Task`1<IEnumerable`1<IAliasSymbol>> GetAliasSymbolsAsync(Document document, IEnumerable`1<ReferenceLocation> nonAliasReferences, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder`1/<FindReferencesThroughAliasSymbolsAsync>d__34")]
private static Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesThroughAliasSymbolsAsync(ISymbol symbol, Document document, IEnumerable`1<IAliasSymbol> aliasSymbols, Func`2<SyntaxToken, SyntaxNode> findParentNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder`1/<FindReferencesThroughAliasSymbolsAsync>d__35")]
private static Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesThroughAliasSymbolsAsync(ISymbol symbol, Document document, IEnumerable`1<IAliasSymbol> aliasSymbols, Func`3<SyntaxToken, SemanticModel, ValueTuple`2<bool, CandidateReason>> symbolsMatch, CancellationToken cancellationToken);
    protected Task`1<IEnumerable`1<Document>> FindDocumentsWithForEachStatementsAsync(Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder`1/<FindReferencesInForEachStatementsAsync>d__37")]
protected Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInForEachStatementsAsync(ISymbol symbol, Document document, CancellationToken cancellationToken);
    private static bool Matches(ISymbol symbol1, ISymbol notNulloriginalUnreducedSymbol2);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorInitializerSymbolReferenceFinder : AbstractReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    protected virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorInitializerSymbolReferenceFinder/<FindReferencesInDocumentAsync>d__2")]
protected virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(IMethodSymbol methodSymbol, Document document, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorSymbolReferenceFinder : AbstractReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorSymbolReferenceFinder/<DetermineDocumentsToSearchAsync>d__1")]
protected virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    private static bool IsPotentialReference(PredefinedType predefinedType, ISyntaxFactsService syntaxFacts, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorSymbolReferenceFinder/<FindReferencesInDocumentAsync>d__3")]
protected virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(IMethodSymbol methodSymbol, Document document, CancellationToken cancellationToken);
    private static Func`2<SyntaxToken, SyntaxNode> GetFindParentNodeFunction(ISyntaxFactsService syntaxFacts);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorSymbolReferenceFinder/<FindReferencesInDocumentWorkerAsync>d__5")]
private Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentWorkerAsync(IMethodSymbol symbol, Document document, Func`2<SyntaxToken, SyntaxNode> findParentNode, CancellationToken cancellationToken);
    private Task`1<IEnumerable`1<ReferenceLocation>> FindOrdinaryReferencesAsync(IMethodSymbol symbol, Document document, Func`2<SyntaxToken, SyntaxNode> findParentNode, CancellationToken cancellationToken);
    private Task`1<IEnumerable`1<ReferenceLocation>> FindPredefinedTypeReferencesAsync(IMethodSymbol symbol, Document document, CancellationToken cancellationToken);
    private Task`1<IEnumerable`1<ReferenceLocation>> FindAttributeReferencesAsync(IMethodSymbol symbol, Document document, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.DestructorSymbolReferenceFinder : AbstractReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    protected virtual Task`1<IEnumerable`1<ISymbol>> DetermineCascadedSymbolsAsync(IMethodSymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(IMethodSymbol methodSymbol, Document document, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.EventSymbolReferenceFinder : AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1<IEventSymbol> {
    protected virtual bool CanFind(IEventSymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.EventSymbolReferenceFinder/<DetermineCascadedSymbolsAsync>d__1")]
protected virtual Task`1<IEnumerable`1<ISymbol>> DetermineCascadedSymbolsAsync(IEventSymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(IEventSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(IEventSymbol symbol, Document document, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private Task`1<IEnumerable`1<ISymbol>> <>n__0(IEventSymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.ExplicitInterfaceMethodReferenceFinder : AbstractReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    protected virtual Task`1<IEnumerable`1<ISymbol>> DetermineCascadedSymbolsAsync(IMethodSymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(IMethodSymbol symbol, Document document, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.FieldSymbolReferenceFinder : AbstractReferenceFinder`1<IFieldSymbol> {
    protected virtual bool CanFind(IFieldSymbol symbol);
    protected virtual Task`1<IEnumerable`1<ISymbol>> DetermineCascadedSymbolsAsync(IFieldSymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(IFieldSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(IFieldSymbol symbol, Document document, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.FindSymbols.Finders.IReferenceFinder {
    public abstract virtual Task`1<IEnumerable`1<Project>> DetermineProjectsToSearchAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(ISymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(ISymbol symbol, Document document, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<ISymbol>> DetermineCascadedSymbolsAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.LabelSymbolReferenceFinder : AbstractMemberScopedReferenceFinder`1<ILabelSymbol> {
    protected virtual Func`2<SyntaxToken, bool> GetTokensMatchFunction(ISyntaxFactsService syntaxFacts, string name);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.LinkedFileReferenceFinder : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.LinkedFileReferenceFinder/<DetermineCascadedSymbolsAsync>d__0")]
public sealed virtual Task`1<IEnumerable`1<ISymbol>> DetermineCascadedSymbolsAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    public sealed virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(ISymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    public sealed virtual Task`1<IEnumerable`1<Project>> DetermineProjectsToSearchAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    public sealed virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(ISymbol symbol, Document document, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.LocalSymbolReferenceFinder : AbstractMemberScopedReferenceFinder`1<ILocalSymbol> {
    protected virtual Func`2<SyntaxToken, bool> GetTokensMatchFunction(ISyntaxFactsService syntaxFacts, string name);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.MethodTypeParameterSymbolReferenceFinder : AbstractReferenceFinder`1<ITypeParameterSymbol> {
    protected virtual bool CanFind(ITypeParameterSymbol symbol);
    protected virtual Task`1<IEnumerable`1<ISymbol>> DetermineCascadedSymbolsAsync(ITypeParameterSymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(ITypeParameterSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    private static string GetMemberNameWithoutInterfaceName(string fullName);
    protected virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(ITypeParameterSymbol symbol, Document document, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.NamedTypeSymbolReferenceFinder : AbstractReferenceFinder`1<INamedTypeSymbol> {
    protected virtual bool CanFind(INamedTypeSymbol symbol);
    protected virtual Task`1<IEnumerable`1<ISymbol>> DetermineCascadedSymbolsAsync(INamedTypeSymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.NamedTypeSymbolReferenceFinder/<DetermineDocumentsToSearchAsync>d__2")]
protected virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(INamedTypeSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    private static bool IsPotentialReference(PredefinedType predefinedType, ISyntaxFactsService syntaxFacts, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.NamedTypeSymbolReferenceFinder/<FindReferencesInDocumentAsync>d__4")]
protected virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(INamedTypeSymbol namedType, Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.NamedTypeSymbolReferenceFinder/<FindNonAliasReferencesAsync>d__5")]
internal static Task`1<IEnumerable`1<ReferenceLocation>> FindNonAliasReferencesAsync(INamedTypeSymbol symbol, Document document, CancellationToken cancellationToken);
    private static Task`1<IEnumerable`1<ReferenceLocation>> FindOrdinaryReferencesAsync(INamedTypeSymbol namedType, Document document, CancellationToken cancellationToken);
    private static Task`1<IEnumerable`1<ReferenceLocation>> FindPredefinedTypeReferencesAsync(INamedTypeSymbol symbol, Document document, CancellationToken cancellationToken);
    private static Task`1<IEnumerable`1<ReferenceLocation>> FindAttributeReferencesAsync(INamedTypeSymbol namedType, Document document, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.NamespaceSymbolReferenceFinder : AbstractReferenceFinder`1<INamespaceSymbol> {
    private static SymbolDisplayFormat s_globalNamespaceFormat;
    private static NamespaceSymbolReferenceFinder();
    protected virtual bool CanFind(INamespaceSymbol symbol);
    protected virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(INamespaceSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    private static string GetNamespaceIdentifierName(INamespaceSymbol symbol, Project project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.NamespaceSymbolReferenceFinder/<FindReferencesInDocumentAsync>d__4")]
protected virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(INamespaceSymbol symbol, Document document, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.OperatorSymbolReferenceFinder : AbstractReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    protected virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(IMethodSymbol symbol, Document document, CancellationToken cancellationToken);
    private bool IsPotentialReference(ISyntaxFactsService syntaxFacts, PredefinedOperator op, SyntaxToken token);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.OrdinaryMethodReferenceFinder : AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.OrdinaryMethodReferenceFinder/<DetermineCascadedSymbolsAsync>d__1")]
protected virtual Task`1<IEnumerable`1<ISymbol>> DetermineCascadedSymbolsAsync(IMethodSymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    private IEnumerable`1<ISymbol> GetOtherPartsOfPartial(IMethodSymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.OrdinaryMethodReferenceFinder/<DetermineDocumentsToSearchAsync>d__3")]
protected virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol methodSymbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    private bool IsForEachMethod(IMethodSymbol methodSymbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.OrdinaryMethodReferenceFinder/<FindReferencesInDocumentAsync>d__5")]
protected virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(IMethodSymbol symbol, Document document, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private Task`1<IEnumerable`1<ISymbol>> <>n__0(IMethodSymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.ParameterSymbolReferenceFinder : AbstractReferenceFinder`1<IParameterSymbol> {
    protected virtual bool CanFind(IParameterSymbol symbol);
    protected virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(IParameterSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(IParameterSymbol symbol, Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ParameterSymbolReferenceFinder/<DetermineCascadedSymbolsAsync>d__3")]
protected virtual Task`1<IEnumerable`1<ISymbol>> DetermineCascadedSymbolsAsync(IParameterSymbol parameter, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ParameterSymbolReferenceFinder/<CascadeBetweenAnonymousFunctionParametersAsync>d__4")]
private Task`1<IEnumerable`1<IParameterSymbol>> CascadeBetweenAnonymousFunctionParametersAsync(Solution solution, IParameterSymbol parameter, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ParameterSymbolReferenceFinder/<CascadeBetweenAnonymousFunctionParameters>d__5")]
private IEnumerable`1<IParameterSymbol> CascadeBetweenAnonymousFunctionParameters(Document document, SemanticModel semanticModel, SyntaxNode container, IParameterSymbol parameter, ITypeSymbol convertedType1, CancellationToken cancellationToken);
    private bool ParameterNamesMatch(ISyntaxFactsService syntaxFacts, IMethodSymbol methodSymbol1, IMethodSymbol methodSymbol2);
    private SyntaxNode GetContainer(SemanticModel semanticModel, SyntaxNode parameterNode, ISyntaxFactsService syntaxFactsService);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ParameterSymbolReferenceFinder/<CascadeBetweenPropertyOrEventAndAccessorParameterAsync>d__8")]
private Task`1<IEnumerable`1<IParameterSymbol>> CascadeBetweenPropertyOrEventAndAccessorParameterAsync(Solution solution, IParameterSymbol parameter, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ParameterSymbolReferenceFinder/<CascadeBetweenPartialMethodParameters>d__9")]
private IEnumerable`1<IParameterSymbol> CascadeBetweenPartialMethodParameters(IParameterSymbol parameter);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.PropertyAccessorSymbolReferenceFinder : AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.PropertyAccessorSymbolReferenceFinder/<DetermineCascadedSymbolsAsync>d__1")]
protected virtual Task`1<IEnumerable`1<ISymbol>> DetermineCascadedSymbolsAsync(IMethodSymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(IMethodSymbol symbol, Document document, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private Task`1<IEnumerable`1<ISymbol>> <>n__0(IMethodSymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.PropertySymbolReferenceFinder : AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1<IPropertySymbol> {
    protected virtual bool CanFind(IPropertySymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.PropertySymbolReferenceFinder/<DetermineCascadedSymbolsAsync>d__1")]
protected virtual Task`1<IEnumerable`1<ISymbol>> DetermineCascadedSymbolsAsync(IPropertySymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.PropertySymbolReferenceFinder/<DetermineDocumentsToSearchAsync>d__2")]
protected virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(IPropertySymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    private static bool IsForEachProperty(IPropertySymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.PropertySymbolReferenceFinder/<FindReferencesInDocumentAsync>d__4")]
protected virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(IPropertySymbol symbol, Document document, CancellationToken cancellationToken);
    private Task`1<IEnumerable`1<Document>> FindDocumentWithElementAccessExpressionsAsync(Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    private Task`1<IEnumerable`1<Document>> FindDocumentWithIndexerMemberCrefAsync(Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.PropertySymbolReferenceFinder/<FindElementAccessReferencesAndIndexerMemberCrefReferencesAsync>d__7")]
private Task`1<IEnumerable`1<ReferenceLocation>> FindElementAccessReferencesAndIndexerMemberCrefReferencesAsync(IPropertySymbol symbol, Document document, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private Task`1<IEnumerable`1<ISymbol>> <>n__0(IPropertySymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.RangeVariableSymbolReferenceFinder : AbstractMemberScopedReferenceFinder`1<IRangeVariableSymbol> {
    protected virtual Func`2<SyntaxToken, bool> GetTokensMatchFunction(ISyntaxFactsService syntaxFacts, string name);
}
internal static class Microsoft.CodeAnalysis.FindSymbols.Finders.ReferenceFinders : object {
    public static IReferenceFinder Constructor;
    public static IReferenceFinder ConstructorInitializer;
    public static IReferenceFinder Destructor;
    public static IReferenceFinder ExplicitInterfaceMethod;
    public static IReferenceFinder Event;
    public static IReferenceFinder Field;
    public static IReferenceFinder Label;
    public static IReferenceFinder LinkedFiles;
    public static IReferenceFinder Local;
    public static IReferenceFinder MethodTypeParameter;
    public static IReferenceFinder NamedType;
    public static IReferenceFinder Namespace;
    public static IReferenceFinder Operator;
    public static IReferenceFinder OrdinaryMethod;
    public static IReferenceFinder Parameter;
    public static IReferenceFinder Property;
    public static IReferenceFinder PropertyAccessor;
    public static IReferenceFinder RangeVariable;
    public static IReferenceFinder TypeParameter;
    public static ImmutableArray`1<IReferenceFinder> DefaultReferenceFinders;
    internal static ImmutableArray`1<IReferenceFinder> DefaultRenameReferenceFinders;
    private static ReferenceFinders();
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.TypeParameterSymbolReferenceFinder : AbstractReferenceFinder`1<ITypeParameterSymbol> {
    protected virtual bool CanFind(ITypeParameterSymbol symbol);
    protected virtual Task`1<IEnumerable`1<Document>> DetermineDocumentsToSearchAsync(ITypeParameterSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<ReferenceLocation>> FindReferencesInDocumentAsync(ITypeParameterSymbol symbol, Document document, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.FindSymbols.FindReferenceCache : object {
    private static ReaderWriterLockSlim s_gate;
    private static Dictionary`2<SemanticModel, Entry> s_cache;
    private static Func`2<SemanticModel, Entry> s_entryCreator;
    private static FindReferenceCache();
    public static SymbolInfo GetSymbolInfo(SemanticModel model, SyntaxNode node, CancellationToken cancellationToken);
    public static IAliasSymbol GetAliasInfo(ISemanticFactsService semanticFacts, SemanticModel model, SyntaxToken token, CancellationToken cancellationToken);
    public static IEnumerable`1<SyntaxToken> GetIdentifierOrGlobalNamespaceTokensWithText(ISyntaxFactsService syntaxFacts, Document document, VersionStamp version, SemanticModel model, SyntaxNode root, SourceText sourceText, string text, CancellationToken cancellationToken);
    private static IList`1<SyntaxToken> GetIdentifierOrGlobalNamespaceTokensWithText(ISyntaxFactsService syntaxFacts, Document document, VersionStamp version, SyntaxNode root, SourceText sourceText, string text, CancellationToken cancellationToken);
    private static IList`1<SyntaxToken> GetTokensFromText(ISyntaxFactsService syntaxFacts, Document document, VersionStamp version, SyntaxNode root, SourceText content, string text, Func`2<SyntaxToken, bool> candidate, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferenceCache/<GetTokensFromText>d__7")]
private static IEnumerable`1<SyntaxToken> GetTokensFromText(SyntaxNode root, List`1<int> positions, string text, Func`2<SyntaxToken, bool> candidate, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferenceCache/<GetTokensFromText>d__8")]
private static IEnumerable`1<SyntaxToken> GetTokensFromText(ISyntaxFactsService syntaxFacts, SyntaxNode root, SourceText content, string text, Func`2<SyntaxToken, bool> candidate, CancellationToken cancellationToken);
    public static IEnumerable`1<SyntaxToken> GetConstructorInitializerTokens(ISyntaxFactsService syntaxFacts, SemanticModel model, SyntaxNode root, CancellationToken cancellationToken);
    private static List`1<SyntaxToken> GetConstructorInitializerTokens(ISyntaxFactsService syntaxFacts, SyntaxNode root, CancellationToken cancellationToken);
    private static ConcurrentDictionary`2<SyntaxNode, SymbolInfo> GetNodeCache(SemanticModel model);
    private static Entry GetCachedEntry(SemanticModel model);
    public static void Start(SemanticModel model);
    public static void Stop(SemanticModel model);
}
internal class Microsoft.CodeAnalysis.FindSymbols.FindReferencesProgress : object {
    public static IFindReferencesProgress Instance;
    private static FindReferencesProgress();
    public sealed virtual void ReportProgress(int current, int maximum);
    public sealed virtual void OnCompleted();
    public sealed virtual void OnStarted();
    public sealed virtual void OnDefinitionFound(ISymbol symbol);
    public sealed virtual void OnReferenceFound(ISymbol symbol, ReferenceLocation location);
    public sealed virtual void OnFindInDocumentStarted(Document document);
    public sealed virtual void OnFindInDocumentCompleted(Document document);
}
internal class Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine : object {
    private Solution _solution;
    private IImmutableSet`1<Document> _documents;
    private ImmutableArray`1<IReferenceFinder> _finders;
    private IFindReferencesProgress _progress;
    private CancellationToken _cancellationToken;
    private ProjectDependencyGraph _dependencyGraph;
    private ConcurrentDictionary`2<Document, ConcurrentSet`1<ReferenceLocation>> _documentToLocationMap;
    private static Func`2<Document, ConcurrentSet`1<ReferenceLocation>> s_createDocumentLocations;
    private ConcurrentDictionary`2<ISymbol, ConcurrentSet`1<ReferenceLocation>> _foundReferences;
    private static Func`2<ISymbol, ConcurrentSet`1<ReferenceLocation>> s_createSymbolLocations;
    private static Func`2<Project, Dictionary`2<Document, List`1<ValueTuple`2<ISymbol, IReferenceFinder>>>> s_documentMapGetter;
    private static Func`2<Document, List`1<ValueTuple`2<ISymbol, IReferenceFinder>>> s_queueGetter;
    private static Func`3<Document, ISymbol, string> s_logDocument;
    public FindReferencesSearchEngine(Solution solution, IImmutableSet`1<Document> documents, ImmutableArray`1<IReferenceFinder> finders, IFindReferencesProgress progress, CancellationToken cancellationToken);
    private static FindReferencesSearchEngine();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<FindReferencesAsync>d__11")]
public Task`1<IEnumerable`1<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<ProcessAsync>d__12")]
private Task ProcessAsync(ConcurrentDictionary`2<Document, ConcurrentQueue`1<ValueTuple`2<ISymbol, IReferenceFinder>>> documentMap);
    private static Dictionary`2<Project, Dictionary`2<Document, List`1<ValueTuple`2<ISymbol, IReferenceFinder>>>> CreateProjectMap(ConcurrentDictionary`2<Document, ConcurrentQueue`1<ValueTuple`2<ISymbol, IReferenceFinder>>> map);
    [ConditionalAttribute("DEBUG")]
private static void ValidateProjectMap(Dictionary`2<Project, Dictionary`2<Document, List`1<ValueTuple`2<ISymbol, IReferenceFinder>>>> projectMap);
    private void HandleLocation(ISymbol symbol, ReferenceLocation location);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<ProcessDocumentQueueAsync>d__19")]
private Task ProcessDocumentQueueAsync(Document document, List`1<ValueTuple`2<ISymbol, IReferenceFinder>> documentQueue, ProgressWrapper wrapper);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<ProcessDocumentAsync>d__21")]
private Task ProcessDocumentAsync(Document document, ISymbol symbol, IReferenceFinder finder, ProgressWrapper wrapper);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<CreateDocumentMapAsync>d__22")]
private Task`1<ConcurrentDictionary`2<Document, ConcurrentQueue`1<ValueTuple`2<ISymbol, IReferenceFinder>>>> CreateDocumentMapAsync(ConcurrentDictionary`2<Project, ConcurrentQueue`1<ValueTuple`2<ISymbol, IReferenceFinder>>> projectMap);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<CreateProjectMapAsync>d__23")]
private Task`1<ConcurrentDictionary`2<Project, ConcurrentQueue`1<ValueTuple`2<ISymbol, IReferenceFinder>>>> CreateProjectMapAsync(ConcurrentSet`1<ISymbol> symbols);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<DetermineAllSymbolsAsync>d__24")]
private Task`1<ConcurrentSet`1<ISymbol>> DetermineAllSymbolsAsync(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<DetermineAllSymbolsCoreAsync>d__25")]
private Task DetermineAllSymbolsCoreAsync(ISymbol symbol, ConcurrentSet`1<ISymbol> result);
    private ImmutableHashSet`1<Project> GetProjectScope();
    private static ISymbol MapToAppropriateSymbol(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<ProcessProjectsAsync>d__28")]
private Task ProcessProjectsAsync(IEnumerable`1<ProjectId> projectSet, Dictionary`2<Project, Dictionary`2<Document, List`1<ValueTuple`2<ISymbol, IReferenceFinder>>>> projectMap, ProgressWrapper wrapper);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<ProcessProjectAsync>d__29")]
private Task ProcessProjectAsync(ProjectId projectId, Dictionary`2<Project, Dictionary`2<Document, List`1<ValueTuple`2<ISymbol, IReferenceFinder>>>> projectMap, HashSet`1<ProjectId> visitedProjects, ProgressWrapper wrapper);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<ProcessProjectAsync>d__30")]
private Task ProcessProjectAsync(Project project, Dictionary`2<Project, Dictionary`2<Document, List`1<ValueTuple`2<ISymbol, IReferenceFinder>>>> projectMap, ProgressWrapper wrapper);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<ProcessProjectAsync>d__31")]
private Task ProcessProjectAsync(Project project, Dictionary`2<Document, List`1<ValueTuple`2<ISymbol, IReferenceFinder>>> map, ProgressWrapper wrapper);
}
public interface Microsoft.CodeAnalysis.FindSymbols.IFindReferencesProgress {
    public abstract virtual void OnStarted();
    public abstract virtual void OnCompleted();
    public abstract virtual void OnFindInDocumentStarted(Document document);
    public abstract virtual void OnFindInDocumentCompleted(Document document);
    public abstract virtual void OnDefinitionFound(ISymbol symbol);
    public abstract virtual void OnReferenceFound(ISymbol symbol, ReferenceLocation location);
    public abstract virtual void ReportProgress(int current, int maximum);
}
internal interface Microsoft.CodeAnalysis.FindSymbols.ISyntaxTreeInfoPersistentStorage {
    public abstract virtual VersionStamp GetIdentifierSetVersion(Document document);
    public abstract virtual bool ReadIdentifierPositions(Document document, VersionStamp version, string identifier, List`1<int> positions, CancellationToken cancellationToken);
    public abstract virtual bool WriteIdentifierLocations(Document document, VersionStamp version, SyntaxNode root, CancellationToken cancellationToken);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol : object {
    [CompilerGeneratedAttribute]
private ISymbol <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ReferenceLocation> <Locations>k__BackingField;
    public ISymbol Definition { get; }
    public IEnumerable`1<ReferenceLocation> Locations { get; }
    internal ReferencedSymbol(ISymbol definition, IEnumerable`1<ReferenceLocation> locations);
    [CompilerGeneratedAttribute]
public ISymbol get_Definition();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ReferenceLocation> get_Locations();
    internal string GetDebuggerDisplay();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation : ValueType {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private IAliasSymbol <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWrittenTo>k__BackingField;
    [CompilerGeneratedAttribute]
private CandidateReason <CandidateReason>k__BackingField;
    public Document Document { get; }
    public IAliasSymbol Alias { get; }
    public Location Location { get; }
    public bool IsImplicit { get; }
    internal bool IsWrittenTo { get; }
    public CandidateReason CandidateReason { get; }
    public bool IsCandidateLocation { get; }
    internal ReferenceLocation(Document document, IAliasSymbol alias, Location location, bool isImplicit, bool isWrittenTo, CandidateReason candidateReason);
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public IAliasSymbol get_Alias();
    [CompilerGeneratedAttribute]
public Location get_Location();
    [CompilerGeneratedAttribute]
public bool get_IsImplicit();
    [CompilerGeneratedAttribute]
internal bool get_IsWrittenTo();
    [CompilerGeneratedAttribute]
public CandidateReason get_CandidateReason();
    public bool get_IsCandidateLocation();
    public static bool op_Equality(ReferenceLocation left, ReferenceLocation right);
    public static bool op_Inequality(ReferenceLocation left, ReferenceLocation right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ReferenceLocation other);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(ReferenceLocation other);
    private string GetDebuggerDisplay();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FindSymbols.ReferenceLocationExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.ReferenceLocationExtensions/<FindReferencingSymbolsAsync>d__0")]
[ExtensionAttribute]
public static Task`1<Dictionary`2<ISymbol, List`1<Location>>> FindReferencingSymbolsAsync(IEnumerable`1<ReferenceLocation> referenceLocations, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.ReferenceLocationExtensions/<AddSymbolsAsync>d__1")]
private static Task AddSymbolsAsync(Document document, IEnumerable`1<ReferenceLocation> references, Dictionary`2<ISymbol, List`1<Location>> result, CancellationToken cancellationToken);
    private static ISymbol GetEnclosingMethodOrPropertyOrField(SemanticModel semanticModel, ReferenceLocation reference);
}
public class Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo : ValueType {
    [CompilerGeneratedAttribute]
private ISymbol <CallingSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Location> <Locations>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <CalledSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDirect>k__BackingField;
    public ISymbol CallingSymbol { get; }
    public IEnumerable`1<Location> Locations { get; }
    public ISymbol CalledSymbol { get; }
    public bool IsDirect { get; }
    internal SymbolCallerInfo(ISymbol callingSymbol, ISymbol calledSymbol, IEnumerable`1<Location> locations, bool isDirect);
    [CompilerGeneratedAttribute]
public ISymbol get_CallingSymbol();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Location> get_Locations();
    [CompilerGeneratedAttribute]
public ISymbol get_CalledSymbol();
    [CompilerGeneratedAttribute]
public bool get_IsDirect();
}
public static class Microsoft.CodeAnalysis.FindSymbols.SymbolFinder : object {
    public static ISymbol FindSymbolAtPosition(SemanticModel semanticModel, int position, Workspace workspace, CancellationToken cancellationToken);
    internal static ISymbol FindSymbolAtPosition(SemanticModel semanticModel, int position, Workspace workspace, bool bindLiteralsToUnderlyingType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSymbolAtPositionAsync>d__2")]
public static Task`1<ISymbol> FindSymbolAtPositionAsync(Document document, int position, CancellationToken cancellationToken);
    public static Task`1<ISymbol> FindSourceDefinitionAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDefinitionWorkerAsync>d__4")]
private static Task`1<ISymbol> FindSourceDefinitionWorkerAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    private static bool InSource(ISymbol symbol);
    public static IEnumerable`1<TSymbol> FindSimilarSymbols(TSymbol symbol, Compilation compilation, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindDeclarationsAsync(Project project, string name, bool ignoreCase, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindDeclarationsAsync(Project project, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindDeclarationsAsyncImpl>d__9")]
private static Task`1<IEnumerable`1<ISymbol>> FindDeclarationsAsyncImpl(Project project, string name, bool ignoreCase, SymbolFilter criteria, CancellationToken cancellationToken);
    private static string GetMetadataReferenceFilePath(MetadataReference metadataReference);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<TranslateNamespaces>d__11")]
private static IEnumerable`1<ISymbol> TranslateNamespaces(List`1<ISymbol> symbols, Compilation compilation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<AddDeclarationsAsync>d__12")]
private static Task AddDeclarationsAsync(Project project, string name, bool ignoreCase, SymbolFilter filter, List`1<ISymbol> list, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<AddDeclarationsAsync>d__13")]
private static Task AddDeclarationsAsync(Project project, Compilation startingCompilation, IAssemblySymbol startingAssembly, string name, bool ignoreCase, SymbolFilter filter, List`1<ISymbol> list, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<AddDeclarationsAsync>d__14")]
private static Task AddDeclarationsAsync(Solution solution, IAssemblySymbol assembly, string filePath, string name, bool ignoreCase, SymbolFilter filter, List`1<ISymbol> list, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Solution solution, string name, bool ignoreCase, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Solution solution, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsAsyncImpl>d__17")]
private static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsyncImpl(Solution solution, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Project project, string name, bool ignoreCase, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Project project, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsAsyncImpl>d__20")]
private static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsyncImpl(Project project, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Solution solution, Func`2<string, bool> predicate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsAsync>d__22")]
public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Solution solution, Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Project project, Func`2<string, bool> predicate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsAsync>d__24")]
public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Project project, Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FilterByCriteria>d__25")]
private static IEnumerable`1<ISymbol> FilterByCriteria(IEnumerable`1<ISymbol> symbols, SymbolFilter criteria);
    private static bool MeetCriteria(ISymbol symbol, SymbolFilter filter);
    private static bool IsNonTypeMember(ISymbol symbol);
    private static bool IsOn(SymbolFilter filter, SymbolFilter flag);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindOverridesAsync>d__29")]
public static Task`1<IEnumerable`1<ISymbol>> FindOverridesAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindImplementedInterfaceMembersAsync>d__30")]
public static Task`1<IEnumerable`1<ISymbol>> FindImplementedInterfaceMembersAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindImplementationsAsync>d__31")]
public static Task`1<IEnumerable`1<ISymbol>> FindImplementationsAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    private static bool IsAccessible(ISymbol s);
    public static Task`1<IEnumerable`1<SymbolCallerInfo>> FindCallersAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindCallersAsync>d__34")]
public static Task`1<IEnumerable`1<SymbolCallerInfo>> FindCallersAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    private static Task`1<IEnumerable`1<ReferencedSymbol>> FindCallReferencesAsync(Solution solution, ISymbol symbol, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindReferencesAsync>d__38")]
public static Task`1<IEnumerable`1<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol, Solution solution, IFindReferencesProgress progress, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    internal static Task`1<IEnumerable`1<ReferencedSymbol>> FindRenamableReferencesAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo : object {
    private VersionStamp _version;
    private IReadOnlyList`1<Node> _nodes;
    private static StringComparer s_nodeSortComparer;
    private static ConditionalWeakTable`2<IAssemblySymbol, SymbolTreeInfo> s_assemblyInfos;
    private static string PrefixMetadataSymbolTreeInfo;
    private static string SerializationFormat;
    public int Count { get; }
    private SymbolTreeInfo(VersionStamp version, IReadOnlyList`1<Node> orderedNodes);
    private static SymbolTreeInfo();
    public int get_Count();
    public bool HasSymbols(string name, bool ignoreCase);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<Find>d__7")]
public IEnumerable`1<ISymbol> Find(IAssemblySymbol assembly, string name, bool ignoreCase, CancellationToken cancellationToken);
    private static StringComparer GetComparer(bool ignoreCase);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<FindNodes>d__9")]
private IEnumerable`1<int> FindNodes(string name, StringComparer comparer);
    private int BinarySearch(string name);
    public bool HasSymbols(Func`2<string, bool> predicate, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<Search>d__12")]
public IEnumerable`1<ISymbol> Search(IAssemblySymbol assembly, Func`2<string, bool> predicate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<GetInfoForAssemblyAsync>d__14")]
public static Task`1<SymbolTreeInfo> GetInfoForAssemblyAsync(Solution solution, IAssemblySymbol assembly, string filePath, CancellationToken cancellationToken);
    internal static SymbolTreeInfo Create(VersionStamp version, IAssemblySymbol assembly, CancellationToken cancellationToken);
    private static Node[] SortNodes(List`1<Node> nodes);
    private static int CompareNodes(Node x, Node y, IReadOnlyList`1<Node> nodeList);
    private static void GenerateNodes(INamespaceSymbol globalNamespace, List`1<Node> list);
    private static void GenerateNodes(string name, int parentIndex, IEnumerable`1<INamespaceOrTypeSymbol> symbolsWithSameName, List`1<Node> list);
    private static IEnumerable`1<string> GetMemberNames(ISymbol symbol);
    private static IEnumerable`1<INamespaceOrTypeSymbol> GetMembers(ISymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<Bind>d__22")]
private IEnumerable`1<ISymbol> Bind(int index, INamespaceOrTypeSymbol rootContainer, CancellationToken cancellationToken);
    private void Bind(int index, INamespaceOrTypeSymbol rootContainer, List`1<ISymbol> results, CancellationToken cancellationToken);
    internal bool IsEquivalent(SymbolTreeInfo other);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<LoadOrCreateAsync>d__28")]
private static Task`1<SymbolTreeInfo> LoadOrCreateAsync(Solution solution, IAssemblySymbol assembly, string filePath, CancellationToken cancellationToken);
    public sealed virtual void WriteTo(ObjectWriter writer);
    internal static SymbolTreeInfo ReadFrom(ObjectReader reader);
}
internal class Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeContextInfo : AbstractPersistableState {
    private static string PersistenceName;
    private static string SerializationFormat;
    private static ConditionalWeakTable`2<BranchId, ConditionalWeakTable`2<DocumentId, SyntaxTreeContextInfo>> s_cache;
    private int _predefinedTypes;
    private int _predefinedOperators;
    private ContainingNodes _containingNodes;
    public bool ContainsForEachStatement { get; }
    public bool ContainsLockStatement { get; }
    public bool ContainsUsingStatement { get; }
    public bool ContainsQueryExpression { get; }
    public bool ContainsThisConstructorInitializer { get; }
    public bool ContainsBaseConstructorInitializer { get; }
    public bool ContainsElementAccessExpression { get; }
    public bool ContainsIndexerMemberCref { get; }
    internal SyntaxTreeContextInfo(VersionStamp version, int predefinedTypes, int predefinedOperators, bool containsForEachStatement, bool containsLockStatement, bool containsUsingStatement, bool containsQueryExpression, bool containsThisConstructorInitializer, bool containsBaseConstructorInitializer, bool containsElementAccessExpression, bool containsIndexerMemberCref);
    private SyntaxTreeContextInfo(VersionStamp version, int predefinedTypes, int predefinedOperators, ContainingNodes containingNodes);
    private static SyntaxTreeContextInfo();
    private static ContainingNodes ConvertToContainingNodeFlag(bool containsForEachStatement, bool containsLockStatement, bool containsUsingStatement, bool containsQueryExpression, bool containsThisConstructorInitializer, bool containsBaseConstructorInitializer, bool containsElementAccessExpression, bool containsIndexerMemberCref);
    public bool ContainsPredefinedType(PredefinedType type);
    public bool ContainsPredefinedOperator(PredefinedOperator op);
    public bool get_ContainsForEachStatement();
    public bool get_ContainsLockStatement();
    public bool get_ContainsUsingStatement();
    public bool get_ContainsQueryExpression();
    public bool get_ContainsThisConstructorInitializer();
    public bool get_ContainsBaseConstructorInitializer();
    public bool get_ContainsElementAccessExpression();
    public bool get_ContainsIndexerMemberCref();
    public sealed virtual void WriteTo(ObjectWriter writer);
    private static SyntaxTreeContextInfo ReadFrom(ObjectReader reader, VersionStamp version);
    public static Task`1<bool> PrecalculatedAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeContextInfo/<LoadAsync>d__30")]
public static Task`1<SyntaxTreeContextInfo> LoadAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeContextInfo/<SaveAsync>d__31")]
public Task`1<bool> SaveAsync(Document document, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private SyntaxTreeContextInfo <SaveAsync>b__31_1(DocumentId _);
    [CompilerGeneratedAttribute]
private SyntaxTreeContextInfo <SaveAsync>b__31_3(DocumentId _);
}
internal class Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeDeclarationInfo : AbstractSyntaxTreeInfo {
    private static string PersistenceName;
    private static string SerializationFormat;
    private static ConditionalWeakTable`2<BranchId, ConditionalWeakTable`2<DocumentId, AbstractSyntaxTreeInfo>> s_cache;
    [CompilerGeneratedAttribute]
private IEnumerable`1<DeclaredSymbolInfo> <DeclaredSymbolInfos>k__BackingField;
    public IEnumerable`1<DeclaredSymbolInfo> DeclaredSymbolInfos { get; }
    public SyntaxTreeDeclarationInfo(VersionStamp version, IEnumerable`1<DeclaredSymbolInfo> declaredSymbolInfos);
    private static SyntaxTreeDeclarationInfo();
    [CompilerGeneratedAttribute]
public IEnumerable`1<DeclaredSymbolInfo> get_DeclaredSymbolInfos();
    public virtual void WriteTo(ObjectWriter writer);
    public virtual Task`1<bool> SaveAsync(Document document, CancellationToken cancellationToken);
    public static Task`1<bool> PrecalculatedAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeDeclarationInfo/<LoadAsync>d__10")]
public static Task`1<SyntaxTreeDeclarationInfo> LoadAsync(Document document, CancellationToken cancellationToken);
    private static SyntaxTreeDeclarationInfo ReadFrom(ObjectReader reader, VersionStamp version);
}
internal class Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIdentifierInfo : AbstractSyntaxTreeInfo {
    private static string PersistenceName;
    private static string SerializationFormat;
    private static ConditionalWeakTable`2<BranchId, ConditionalWeakTable`2<DocumentId, AbstractSyntaxTreeInfo>> s_cache;
    private VersionStamp _version;
    private BloomFilter _identifierFilter;
    private BloomFilter _escapedIdentifierFilter;
    public SyntaxTreeIdentifierInfo(VersionStamp version, BloomFilter identifierFilter, BloomFilter escapedIdentifierFilter);
    private static SyntaxTreeIdentifierInfo();
    public bool ProbablyContainsIdentifier(string identifier);
    public bool ProbablyContainsEscapedIdentifier(string identifier);
    public virtual void WriteTo(ObjectWriter writer);
    public static Task`1<bool> PrecalculatedAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIdentifierInfo/<LoadAsync>d__11")]
public static Task`1<SyntaxTreeIdentifierInfo> LoadAsync(Document document, CancellationToken cancellationToken);
    public virtual Task`1<bool> SaveAsync(Document document, CancellationToken cancellationToken);
    private static SyntaxTreeIdentifierInfo ReadFrom(ObjectReader reader, VersionStamp version);
    public static bool TryGetIdentifierLocations(Document document, VersionStamp version, string identifier, List`1<int> positions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIdentifierInfo/<IdentifierSetPrecalculatedAsync>d__15")]
public static Task`1<bool> IdentifierSetPrecalculatedAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIdentifierInfo/<SaveIdentifierSetAsync>d__16")]
public static Task SaveIdentifierSetAsync(Document document, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeInfo : object {
    private static ConditionalWeakTable`2<Document, SyntaxTreeIdentifierInfo> s_identifierSnapshotCache;
    private static ConditionalWeakTable`2<Document, SyntaxTreeContextInfo> s_contextSnapshotCache;
    private static ConditionalWeakTable`2<Document, SyntaxTreeDeclarationInfo> s_declaredSymbolsSnapshotCache;
    private static double FalsePositiveProbability;
    private static SyntaxTreeInfo();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeInfo/<PrecalculateAsync>d__3")]
public static Task PrecalculateAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeInfo/<PrecalculateAdvancedInfoAsync>d__4")]
private static Task PrecalculateAdvancedInfoAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeInfo/<PrecalculateBasicInfoAsync>d__5")]
private static Task PrecalculateBasicInfoAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeInfo/<GetInfoAsync>d__6`1")]
private static Task`1<T> GetInfoAsync(Document document, ConditionalWeakTable`2<Document, T> cache, Func`3<Document, CancellationToken, Task`1<T>> generator, Func`2<ValueTuple`3<SyntaxTreeIdentifierInfo, SyntaxTreeContextInfo, SyntaxTreeDeclarationInfo>, T> selector, CancellationToken cancellationToken);
    public static Task`1<SyntaxTreeContextInfo> GetContextInfoAsync(Document document, CancellationToken cancellationToken);
    public static Task`1<SyntaxTreeIdentifierInfo> GetIdentifierInfoAsync(Document document, CancellationToken cancellationToken);
    public static Task`1<SyntaxTreeDeclarationInfo> GetDeclarationInfoAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeInfo/<CreateInfoAsync>d__11")]
private static Task`1<ValueTuple`3<SyntaxTreeIdentifierInfo, SyntaxTreeContextInfo, SyntaxTreeDeclarationInfo>> CreateInfoAsync(Document document, CancellationToken cancellationToken);
    private static void GetIdentifierSet(bool ignoreCase, HashSet`1& identifiers, HashSet`1& escapedIdentifiers);
    private static void Free(bool ignoreCase, HashSet`1<string> identifiers, HashSet`1<string> escapedIdentifiers);
}
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractAggregatedFormattingResult : object {
    protected SyntaxNode Node;
    private IList`1<AbstractFormattingResult> _formattingResults;
    private SimpleIntervalTree`1<TextSpan> _formattingSpans;
    private CancellableLazy`1<IList`1<TextChange>> _lazyTextChanges;
    private CancellableLazy`1<SyntaxNode> _lazyNode;
    public bool ContainsChanges { get; }
    public AbstractAggregatedFormattingResult(SyntaxNode node, IList`1<AbstractFormattingResult> formattingResults, SimpleIntervalTree`1<TextSpan> formattingSpans);
    protected abstract virtual SyntaxNode Rewriter(Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> changeMap, CancellationToken cancellationToken);
    protected SimpleIntervalTree`1<TextSpan> GetFormattingSpans();
    public bool get_ContainsChanges();
    public sealed virtual IList`1<TextChange> GetTextChanges(CancellationToken cancellationToken);
    public sealed virtual SyntaxNode GetFormattedRoot(CancellationToken cancellationToken);
    private IList`1<TextChange> CreateTextChanges(CancellationToken cancellationToken);
    private IList`1<TextChange> CreateTextChangesWorker(CancellationToken cancellationToken);
    private SyntaxNode CreateFormattedRoot(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <CreateTextChanges>b__12_0(TextChange s);
}
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractFormatEngine : object {
    private static int ConcurrentThreshold;
    private ChainedFormattingRules _formattingRules;
    private SyntaxNode _commonRoot;
    private SyntaxToken _token1;
    private SyntaxToken _token2;
    private string _language;
    protected TextSpan SpanToFormat;
    internal TaskExecutor TaskExecutor;
    internal OptionSet OptionSet;
    internal TreeData TreeData;
    public AbstractFormatEngine(TreeData treeData, OptionSet optionSet, IEnumerable`1<IFormattingRule> formattingRules, SyntaxToken token1, SyntaxToken token2, TaskExecutor executor);
    internal AbstractFormatEngine(TreeData treeData, OptionSet optionSet, ChainedFormattingRules formattingRules, SyntaxToken token1, SyntaxToken token2, TaskExecutor executor);
    protected abstract virtual AbstractTriviaDataFactory CreateTriviaFactory();
    protected abstract virtual AbstractFormattingResult CreateFormattingResult(TokenStream tokenStream);
    public AbstractFormattingResult Format(CancellationToken cancellationToken);
    protected virtual FormattingContext CreateFormattingContext(TokenStream tokenStream, CancellationToken cancellationToken);
    protected virtual NodeOperations CreateNodeOperationTasks(CancellationToken cancellationToken);
    private List`1<T> AddOperations(List`1<SyntaxNode> nodes, Action`2<List`1<T>, SyntaxNode> addOperations, CancellationToken cancellationToken);
    private Task`1<TokenPairWithOperations[]> CreateTokenOperationTask(TokenStream tokenStream, CancellationToken cancellationToken);
    private void ApplyTokenOperations(FormattingContext context, TokenStream tokenStream, Task anchorContextTask, NodeOperations nodeOperations, TokenPairWithOperations[] tokenOperations, CancellationToken cancellationToken);
    private void ApplyBeginningOfTreeTriviaOperation(FormattingContext context, TokenStream tokenStream, CancellationToken cancellationToken);
    private void ApplyEndOfTreeTriviaOperation(FormattingContext context, TokenStream tokenStream, CancellationToken cancellationToken);
    private void ApplyTriviaOperations(FormattingContext context, TokenStream tokenStream, CancellationToken cancellationToken);
    private TextSpan GetSpanToFormat();
    private void ApplySpecialOperations(FormattingContext context, TokenStream tokenStream, NodeOperations nodeOperationsCollector, OperationApplier applier, CancellationToken cancellationToken);
    private void ApplyAnchorOperations(FormattingContext context, TokenStream tokenStream, TokenPairWithOperations[] tokenOperations, OperationApplier applier, CancellationToken cancellationToken);
    private static bool AnchorOperationCandidate(TokenPairWithOperations pair);
    private SyntaxToken FindCorrectBaseTokenOfRelativeIndentBlockOperation(IndentBlockOperation operation, TokenStream tokenStream);
    private void ApplySpaceAndWrappingOperations(FormattingContext context, TokenStream tokenStream, TokenPairWithOperations[] tokenOperations, OperationApplier applier, CancellationToken cancellationToken);
    private static void ApplySpaceAndWrappingOperationsBody(FormattingContext context, TokenStream tokenStream, TokenPairWithOperations operation, OperationApplier applier, CancellationToken cancellationToken);
    private void BuildContext(FormattingContext context, TokenStream tokenStream, NodeOperations nodeOperations, CancellationToken cancellationToken);
    private string FormatSummary();
    [CompilerGeneratedAttribute]
private void <CreateNodeOperationTasks>b__16_2(List`1<IndentBlockOperation> l, SyntaxNode n);
    [CompilerGeneratedAttribute]
private void <CreateNodeOperationTasks>b__16_4(List`1<SuppressOperation> l, SyntaxNode n);
    [CompilerGeneratedAttribute]
private void <CreateNodeOperationTasks>b__16_6(List`1<AlignTokensOperation> l, SyntaxNode n);
    [CompilerGeneratedAttribute]
private void <CreateNodeOperationTasks>b__16_9(List`1<AnchorIndentationOperation> l, SyntaxNode n);
}
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractFormattingResult : object {
    protected TreeData TreeInfo;
    protected TokenStream TokenStream;
    protected TaskExecutor TaskExecutor;
    private CancellableLazy`1<IList`1<TextChange>> _lazyChanges;
    private CancellableLazy`1<SyntaxNode> _lazyNode;
    public TextSpan FormattedSpan;
    internal AbstractFormattingResult(TreeData treeInfo, TokenStream tokenStream, TextSpan formattedSpan, TaskExecutor taskExecutor);
    protected abstract virtual SyntaxNode Rewriter(Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> map, CancellationToken cancellationToken);
    public sealed virtual IList`1<TextChange> GetTextChanges(CancellationToken cancellationToken);
    public sealed virtual SyntaxNode GetFormattedRoot(CancellationToken cancellationToken);
    private IList`1<TextChange> CreateTextChanges(CancellationToken cancellationToken);
    private void AddTextChanges(List`1<TextChange> list, SyntaxToken token1, SyntaxToken token2, TriviaData data);
    private SyntaxNode CreateFormattedRoot(CancellationToken cancellationToken);
    internal IEnumerable`1<ValueTuple`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData>> GetChanges(CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractSyntaxFormattingService : object {
    private static Func`2<TextSpan, bool> s_notEmpty;
    private static Func`2<TextSpan, int> s_spanLength;
    private static AbstractSyntaxFormattingService();
    public abstract virtual IEnumerable`1<IFormattingRule> GetDefaultFormattingRules();
    protected abstract virtual IFormattingResult CreateAggregatedFormattingResult(SyntaxNode node, IList`1<AbstractFormattingResult> results, SimpleIntervalTree`1<TextSpan> formattingSpans);
    protected abstract virtual AbstractFormattingResult Format(SyntaxNode node, OptionSet options, IEnumerable`1<IFormattingRule> rules, SyntaxToken token1, SyntaxToken token2, CancellationToken cancellationToken);
    public sealed virtual IFormattingResult Format(SyntaxNode node, IEnumerable`1<TextSpan> spans, OptionSet options, IEnumerable`1<IFormattingRule> rules, CancellationToken cancellationToken);
    private IFormattingResult FormatMergedSpan(SyntaxNode node, OptionSet options, IEnumerable`1<IFormattingRule> rules, IList`1<TextSpan> spansToFormat, CancellationToken cancellationToken);
    private IFormattingResult FormatIndividually(SyntaxNode node, OptionSet options, IEnumerable`1<IFormattingRule> rules, IList`1<TextSpan> spansToFormat, CancellationToken cancellationToken);
    private bool AllowDisjointSpanMerging(IList`1<TextSpan> list, bool shouldUseFormattingSpanCollapse);
    private static void CheckArguments(SyntaxNode node, IEnumerable`1<TextSpan> spans, OptionSet options, IEnumerable`1<IFormattingRule> rules);
}
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractTriviaDataFactory : object {
    private static int SpaceCacheSize;
    private static int LineBreakCacheSize;
    private static int IndentationLevelCacheSize;
    protected TreeData TreeInfo;
    protected OptionSet OptionSet;
    private Whitespace[] _spaces;
    private Whitespace[0...,0...] _whitespaces;
    protected AbstractTriviaDataFactory(TreeData treeInfo, OptionSet optionSet);
    protected TriviaData GetSpaceTriviaData(int space, bool elastic);
    protected TriviaData GetWhitespaceTriviaData(int lineBreaks, int indentation, bool useTriviaAsItIs, bool elastic);
    private void EnsureWhitespaceTriviaInfo(int lineIndex, int indentationLevel);
    public abstract virtual TriviaData CreateLeadingTrivia(SyntaxToken token);
    public abstract virtual TriviaData CreateTrailingTrivia(SyntaxToken token);
    public abstract virtual TriviaData Create(SyntaxToken token1, SyntaxToken token2);
}
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter`1 : object {
    private static String[] s_spaceCache;
    protected FormattingContext Context;
    protected ChainedFormattingRules FormattingRules;
    protected string OriginalString;
    protected int LineBreaks;
    protected int Spaces;
    protected LineColumn InitialLineColumn;
    protected SyntaxToken Token1;
    protected SyntaxToken Token2;
    private string _language;
    private int _indentation;
    private bool _firstLineBlank;
    protected int StartPosition { get; }
    protected int EndPosition { get; }
    protected TreeData TreeInfo { get; }
    protected OptionSet OptionSet { get; }
    protected string Language { get; }
    protected TokenStream TokenStream { get; }
    private static AbstractTriviaFormatter`1();
    public AbstractTriviaFormatter`1(FormattingContext context, ChainedFormattingRules formattingRules, SyntaxToken token1, SyntaxToken token2, string originalString, int lineBreaks, int spaces);
    protected abstract virtual bool Succeeded();
    protected abstract virtual bool IsWhitespace(SyntaxTrivia trivia);
    protected abstract virtual bool IsEndOfLine(SyntaxTrivia trivia);
    protected bool IsNullOrWhitespace(string text);
    protected abstract virtual bool IsWhitespace(char ch);
    protected abstract virtual bool IsNewLine(char ch);
    protected abstract virtual TTrivia Convert(SyntaxTrivia trivia);
    protected abstract virtual SyntaxTrivia CreateWhitespace(string text);
    protected abstract virtual SyntaxTrivia CreateEndOfLine();
    protected abstract virtual LineColumnRule GetLineColumnRuleBetween(SyntaxTrivia trivia1, LineColumnDelta existingWhitespaceBetween, bool implicitLineBreak, SyntaxTrivia trivia2);
    protected abstract virtual LineColumnDelta Format(LineColumn lineColumn, SyntaxTrivia trivia, List`1<SyntaxTrivia> changes, CancellationToken cancellationToken);
    protected abstract virtual LineColumnDelta Format(LineColumn lineColumn, SyntaxTrivia trivia, List`1<TextChange> changes, CancellationToken cancellationToken);
    protected abstract virtual bool ContainsImplicitLineBreak(SyntaxTrivia trivia);
    protected int get_StartPosition();
    protected int get_EndPosition();
    protected TreeData get_TreeInfo();
    protected OptionSet get_OptionSet();
    protected string get_Language();
    protected TokenStream get_TokenStream();
    public List`1<TTrivia> FormatToSyntaxTrivia(CancellationToken cancellationToken);
    public List`1<TextChange> FormatToTextChanges(CancellationToken cancellationToken);
    private LineColumn FormatTrivia(Formatter`1<TTrivia, T> formatter, WhitespaceAppender`1<TTrivia, T> whitespaceAdder, List`1<T> changes, CancellationToken cancellationToken);
    private LineColumn FormatFirstTriviaAndWhitespaceAfter(LineColumn lineColumnBeforeTrivia1, SyntaxTrivia trivia1, LineColumnDelta existingWhitespaceBetween, SyntaxTrivia trivia2, Formatter`1<TTrivia, T> format, WhitespaceAppender`1<TTrivia, T> addWhitespaceTrivia, List`1<T> changes, bool implicitLineBreak, CancellationToken cancellationToken);
    private LineColumnRule GetOverallLineColumnRuleBetween(SyntaxTrivia trivia1, LineColumnDelta existingWhitespaceBetween, bool implicitLineBreak, SyntaxTrivia trivia2);
    private void GetTokensAtEdgeOfStructureTrivia(SyntaxTrivia trivia1, SyntaxTrivia trivia2, SyntaxToken& token1, SyntaxToken& token2);
    private bool ContainsOnlyWhitespace(int start, int end);
    private bool FirstLineBlank();
    private LineColumnDelta Apply(LineColumn lineColumnBeforeTrivia1, SyntaxTrivia trivia1, LineColumn lineColumnAfterTrivia1, LineColumnDelta existingWhitespaceBetween, SyntaxTrivia trivia2, LineColumnRule rule);
    private int GetRuleSpacesOrIndentation(LineColumn lineColumnBeforeTrivia1, SyntaxTrivia trivia1, LineColumn lineColumnAfterTrivia1, LineColumnDelta existingWhitespaceBetween, SyntaxTrivia trivia2, LineColumnRule rule);
    private int GetRuleLines(LineColumnRule rule, LineColumn lineColumnAfterTrivia1, LineColumnDelta existingWhitespaceBetween);
    private int GetIndentation();
    private int GetTrailingLinesAtEndOfTrivia1(LineColumn lineColumnAfterTrivia1);
    private void AddExtraLines(int linesBetweenTokens, List`1<SyntaxTrivia> changes);
    private int GetInsertionIndex(List`1<SyntaxTrivia> changes);
    private void AddExtraLines(int linesBetweenTokens, List`1<TextChange> changes);
    private bool TryGetMatchingChangeIndex(List`1<TextChange> changes, Int32& index);
    private TextSpan GetInsertionSpan(List`1<TextChange> changes);
    private void AddWhitespaceTrivia(LineColumn lineColumn, LineColumnDelta delta, List`1<SyntaxTrivia> changes);
    private void AddWhitespaceTrivia(LineColumn lineColumn, LineColumnDelta delta, TextSpan notUsed, List`1<SyntaxTrivia> changes);
    private string GetWhitespaceString(LineColumn lineColumn, LineColumnDelta delta);
    private TextChange GetWhitespaceTextChange(LineColumn lineColumn, LineColumnDelta delta, TextSpan span);
    private void AddWhitespaceTextChange(LineColumn lineColumn, LineColumnDelta delta, TextSpan span, List`1<TextChange> changes);
    private TextSpan GetTextSpan(SyntaxTrivia trivia1, SyntaxTrivia trivia2);
    private bool IsWhitespaceOrEndOfLine(SyntaxTrivia trivia);
    private LineColumnDelta GetLineColumnOfWhitespace(LineColumn lineColumn, SyntaxTrivia previousTrivia, SyntaxTrivia trivia1, LineColumnDelta whitespaceBetween, SyntaxTrivia trivia2);
    private LineColumn GetInitialLineColumn();
    protected LineColumn GetLineColumn(LineColumn lineColumn, SyntaxTrivia trivia);
    protected LineColumnDelta GetLineColumnDelta(LineColumn lineColumn, SyntaxTrivia trivia);
    protected LineColumnDelta GetLineColumnDelta(int initialColumn, string text);
    protected int GetExistingIndentation(SyntaxTrivia trivia);
    private static string GetSpaces(int space);
}
internal class Microsoft.CodeAnalysis.Formatting.ActionCache`1 : object {
    [CompilerGeneratedAttribute]
private Action`4<int, List`1<TArgument>, SyntaxNode, NextAction`1<TArgument>> <NextOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`4<int, List`1<TArgument>, SyntaxNode, IActionHolder`1<TArgument>> <Continuation>k__BackingField;
    public Action`4<int, List`1<TArgument>, SyntaxNode, NextAction`1<TArgument>> NextOperation { get; }
    public Action`4<int, List`1<TArgument>, SyntaxNode, IActionHolder`1<TArgument>> Continuation { get; }
    public ActionCache`1(Action`4<int, List`1<TArgument>, SyntaxNode, NextAction`1<TArgument>> nextOperation, Action`4<int, List`1<TArgument>, SyntaxNode, IActionHolder`1<TArgument>> continuation);
    [CompilerGeneratedAttribute]
public sealed virtual Action`4<int, List`1<TArgument>, SyntaxNode, NextAction`1<TArgument>> get_NextOperation();
    [CompilerGeneratedAttribute]
public sealed virtual Action`4<int, List`1<TArgument>, SyntaxNode, IActionHolder`1<TArgument>> get_Continuation();
}
internal class Microsoft.CodeAnalysis.Formatting.BottomUpBaseIndentationFinder : object {
    private TokenStream _tokenStream;
    private ChainedFormattingRules _formattingRules;
    private int _tabSize;
    private int _indentationSize;
    public BottomUpBaseIndentationFinder(ChainedFormattingRules formattingRules, int tabSize, int indentationSize, TokenStream tokenStream);
    public Nullable`1<int> FromIndentBlockOperations(SyntaxTree tree, SyntaxToken token, int position, CancellationToken cancellationToken);
    public Nullable`1<int> FromAlignTokensOperations(SyntaxTree tree, SyntaxToken token);
    public int GetIndentationOfCurrentPosition(SyntaxTree tree, SyntaxToken token, int position, CancellationToken cancellationToken);
    public int GetIndentationOfCurrentPosition(SyntaxTree tree, SyntaxToken token, int position, int extraSpaces, CancellationToken cancellationToken);
    public int GetIndentationOfCurrentPosition(SyntaxNode root, IndentBlockOperation startingOperation, Func`2<SyntaxToken, int> tokenColumnGetter, CancellationToken cancellationToken);
    private int GetIndentationOfCurrentPosition(SyntaxNode root, SyntaxToken token, List`1<IndentBlockOperation> list, int position, int extraSpaces, Func`2<SyntaxToken, int> tokenColumnGetter, CancellationToken cancellationToken);
    private ValueTuple`2<int, IndentBlockOperation> GetIndentationRuleOfCurrentPosition(SyntaxNode root, SyntaxToken token, List`1<IndentBlockOperation> list, int position);
    private List`1<IndentBlockOperation> GetParentIndentBlockOperations(SyntaxToken token);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.BottomUpBaseIndentationFinder/<GetParentNodes>d__13")]
private IEnumerable`1<SyntaxNode> GetParentNodes(SyntaxToken token);
    private SyntaxToken GetAlignmentBaseTokenFor(SyntaxToken token);
    private IndentBlockOperation GetIndentationDataFor(SyntaxNode root, SyntaxToken token, int position);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.BottomUpBaseIndentationFinder/<GetIndentBlockOperationsFromSmallestSpan>d__16")]
private static IEnumerable`1<IndentBlockOperation> GetIndentBlockOperationsFromSmallestSpan(SyntaxNode root, List`1<IndentBlockOperation> list, int position);
}
internal class Microsoft.CodeAnalysis.Formatting.ChainedFormattingRules : object {
    private List`1<IFormattingRule> _formattingRules;
    private OptionSet _optionSet;
    private ActionCache`1<SuppressOperation> _suppressWrappingFuncCache;
    private ActionCache`1<AnchorIndentationOperation> _anchorFuncCache;
    private ActionCache`1<IndentBlockOperation> _indentFuncCache;
    private ActionCache`1<AlignTokensOperation> _alignFuncCache;
    private OperationCache`1<AdjustNewLinesOperation> _newLinesFuncCache;
    private OperationCache`1<AdjustSpacesOperation> _spaceFuncCache;
    public ChainedFormattingRules(IEnumerable`1<IFormattingRule> formattingRules, OptionSet set);
    public void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode currentNode);
    public void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode currentNode);
    public void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode currentNode);
    public void AddAlignTokensOperations(List`1<AlignTokensOperation> list, SyntaxNode currentNode);
    public AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken previousToken, SyntaxToken currentToken);
    public AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken previousToken, SyntaxToken currentToken);
    private void AddContinuedOperations(int index, List`1<TArg1> arg1, SyntaxNode node, IActionHolder`1<TArg1> actionCache);
    private TResult GetContinuedOperations(int index, SyntaxToken token1, SyntaxToken token2, IOperationHolder`1<TResult> funcCache);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_0(int index, List`1<SuppressOperation> list, SyntaxNode node, NextAction`1<SuppressOperation> next);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_1(int index, List`1<AnchorIndentationOperation> list, SyntaxNode node, NextAction`1<AnchorIndentationOperation> next);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_2(int index, List`1<IndentBlockOperation> list, SyntaxNode node, NextAction`1<IndentBlockOperation> next);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_3(int index, List`1<AlignTokensOperation> list, SyntaxNode node, NextAction`1<AlignTokensOperation> next);
    [CompilerGeneratedAttribute]
private AdjustNewLinesOperation <.ctor>b__8_4(int index, SyntaxToken token1, SyntaxToken token2, NextOperation`1<AdjustNewLinesOperation> next);
    [CompilerGeneratedAttribute]
private AdjustSpacesOperation <.ctor>b__8_5(int index, SyntaxToken token1, SyntaxToken token2, NextOperation`1<AdjustSpacesOperation> next);
}
internal class Microsoft.CodeAnalysis.Formatting.ContextIntervalTree`1 : SimpleIntervalTree`1<T> {
    private Func`4<T, int, int, bool> _edgeExclusivePredicate;
    private Func`4<T, int, int, bool> _edgeInclusivePredicate;
    private Func`4<T, int, int, bool> _containPredicate;
    public ContextIntervalTree`1(IIntervalIntrospector`1<T> introspector);
    public void AddIntervalInPlace(T value);
    public T GetSmallestEdgeExclusivelyContainingInterval(int start, int length);
    public T GetSmallestEdgeInclusivelyContainingInterval(int start, int length);
    public T GetSmallestContainingInterval(int start, int length);
    private bool ContainsEdgeExclusive(T value, int start, int length);
    private bool ContainsEdgeInclusive(T value, int start, int length);
    private T GetSmallestContainingIntervalWorker(int start, int length, Func`4<T, int, int, bool> predicate);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__3_0(T value, int start, int end);
}
public static class Microsoft.CodeAnalysis.Formatting.Formatter : object {
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <Annotation>k__BackingField;
    public static SyntaxAnnotation Annotation { get; }
    private static Formatter();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_Annotation();
    internal static IEnumerable`1<IFormattingRule> GetDefaultFormattingRules(Document document);
    internal static IEnumerable`1<IFormattingRule> GetDefaultFormattingRules(Workspace workspace, string language);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.Formatter/<FormatAsync>d__5")]
public static Task`1<Document> FormatAsync(Document document, OptionSet options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.Formatter/<FormatAsync>d__6")]
public static Task`1<Document> FormatAsync(Document document, TextSpan span, OptionSet options, CancellationToken cancellationToken);
    public static Task`1<Document> FormatAsync(Document document, IEnumerable`1<TextSpan> spans, OptionSet options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.Formatter/<FormatAsync>d__8")]
internal static Task`1<Document> FormatAsync(Document document, IEnumerable`1<TextSpan> spans, OptionSet options, IEnumerable`1<IFormattingRule> rules, CancellationToken cancellationToken);
    public static Task`1<Document> FormatAsync(Document document, SyntaxAnnotation annotation, OptionSet options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.Formatter/<FormatAsync>d__10")]
internal static Task`1<Document> FormatAsync(Document document, SyntaxAnnotation annotation, OptionSet options, IEnumerable`1<IFormattingRule> rules, CancellationToken cancellationToken);
    public static SyntaxNode Format(SyntaxNode node, SyntaxAnnotation annotation, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    internal static SyntaxNode Format(SyntaxNode node, SyntaxAnnotation annotation, Workspace workspace, OptionSet options, IEnumerable`1<IFormattingRule> rules, CancellationToken cancellationToken);
    public static SyntaxNode Format(SyntaxNode node, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    public static SyntaxNode Format(SyntaxNode node, TextSpan span, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    public static SyntaxNode Format(SyntaxNode node, IEnumerable`1<TextSpan> spans, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    internal static SyntaxNode Format(SyntaxNode node, IEnumerable`1<TextSpan> spans, Workspace workspace, OptionSet options, IEnumerable`1<IFormattingRule> rules, CancellationToken cancellationToken);
    public static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    public static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, TextSpan span, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    public static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, IEnumerable`1<TextSpan> spans, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    internal static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, IEnumerable`1<TextSpan> spans, Workspace workspace, OptionSet options, IEnumerable`1<IFormattingRule> rules, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.Formatter/<GetAnnotatedSpans>d__21")]
private static IEnumerable`1<TextSpan> GetAnnotatedSpans(SyntaxNode node, SyntaxAnnotation annotation);
    private static TextSpan GetSpan(SyntaxToken firstToken, SyntaxToken lastToken);
    private static IEnumerable`1<TextSpan> GetElasticSpans(SyntaxNode root);
    private static TextSpan GetElasticSpan(SyntaxToken token);
    private static IEnumerable`1<TextSpan> AggregateSpans(IEnumerable`1<TextSpan> spans);
}
internal class Microsoft.CodeAnalysis.Formatting.FormattingContext : object {
    private AbstractFormatEngine _engine;
    private TokenStream _tokenStream;
    private ContextIntervalTree`1<RelativeIndentationData> _relativeIndentationTree;
    private ContextIntervalTree`1<IndentationData> _indentationTree;
    private ContextIntervalTree`1<SuppressWrappingData> _suppressWrappingTree;
    private ContextIntervalTree`1<SuppressSpacingData> _suppressSpacingTree;
    private ContextIntervalTree`1<AnchorData> _anchorTree;
    private Dictionary`2<SyntaxToken, AnchorData> _anchorBaseTokenMap;
    private HashSet`1<TextSpan> _indentationMap;
    private HashSet`1<TextSpan> _suppressWrappingMap;
    private HashSet`1<TextSpan> _suppressSpacingMap;
    private HashSet`1<TextSpan> _anchorMap;
    private List`1<IndentBlockOperation> _initialIndentBlockOperations;
    private string _language;
    public OptionSet OptionSet { get; }
    public TreeData TreeData { get; }
    public TokenStream TokenStream { get; }
    public FormattingContext(AbstractFormatEngine engine, TokenStream tokenStream, string language);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.FormattingContext.AnchorData>.GetStart(AnchorData value);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.FormattingContext.AnchorData>.GetLength(AnchorData value);
    public void Initialize(ChainedFormattingRules formattingRules, SyntaxToken startToken, SyntaxToken endToken, CancellationToken cancellationToken);
    public void AddIndentBlockOperations(List`1<IndentBlockOperation> operations, CancellationToken cancellationToken);
    public void AddIndentBlockOperation(IndentBlockOperation operation);
    public void AddInitialSuppressOperation(SuppressOperation operation);
    public void AddSuppressOperations(List`1<SuppressOperation> operations, CancellationToken cancellationToken);
    private void AddSuppressOperation(SuppressOperation operation, bool onSameLine);
    private void AddSpacingSuppressOperation(SuppressOperation operation, bool twoTokensOnSameLine);
    private void AddWrappingSuppressOperation(SuppressOperation operation, bool twoTokensOnSameLine);
    public void AddAnchorIndentationOperation(AnchorIndentationOperation operation);
    [ConditionalAttribute("DEBUG")]
private void DebugCheckEmpty(ContextIntervalTree`1<T> tree, TextSpan textSpan);
    public int GetBaseIndentation(SyntaxToken token);
    public int GetBaseIndentation(int position);
    public IEnumerable`1<IndentBlockOperation> GetAllRelativeIndentBlockOperations();
    public SyntaxToken GetEndTokenForRelativeIndentationSpan(SyntaxToken token, CancellationToken cancellationToken);
    private AnchorData GetAnchorData(SyntaxToken token);
    public int GetAnchorDeltaFromOriginalColumn(SyntaxToken token);
    public SyntaxToken GetAnchorToken(SyntaxToken token);
    public int GetDeltaFromPreviousChangesMap(SyntaxToken token, Dictionary`2<SyntaxToken, int> previousChangesMap);
    public SyntaxToken GetEndTokenForAnchorSpan(TokenData tokenData);
    private AnchorData FindAnchorSpanOnSameLineAfterToken(TokenData tokenData);
    public bool IsWrappingSuppressed(TextSpan textSpan);
    public bool IsSpacingSuppressed(TextSpan textSpan);
    public bool IsSpacingSuppressed(int pairIndex);
    public OptionSet get_OptionSet();
    public TreeData get_TreeData();
    public TokenStream get_TokenStream();
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.FormattingContext.IndentationData>.GetStart(IndentationData value);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.FormattingContext.IndentationData>.GetLength(IndentationData value);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.FormattingContext.RelativeIndentationData>.GetStart(RelativeIndentationData value);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.FormattingContext.RelativeIndentationData>.GetLength(RelativeIndentationData value);
    [CompilerGeneratedAttribute]
private int <Initialize>b__18_0(SyntaxToken t);
    [CompilerGeneratedAttribute]
private void <Initialize>b__18_1(SuppressOperation o);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Formatting.FormattingExtensions : object {
    private static Char[] s_trimChars;
    private static FormattingExtensions();
    [ExtensionAttribute]
public static SyntaxNode GetParentWithBiggerSpan(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<IFormattingRule> Concat(IFormattingRule rule, IEnumerable`1<IFormattingRule> rules);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> list, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static List`1<T> Combine(List`1<T> list1, List`1<T> list2);
    [ExtensionAttribute]
public static bool ContainsElasticTrivia(SuppressOperation operation, TokenStream tokenStream);
    [ExtensionAttribute]
public static bool HasAnyWhitespaceElasticTrivia(SyntaxTriviaList list);
    [ExtensionAttribute]
public static bool IsOn(IndentBlockOption option, IndentBlockOption flag);
    [ExtensionAttribute]
public static bool IsMaskOn(IndentBlockOption option, IndentBlockOption mask);
    [ExtensionAttribute]
public static bool IsOn(SuppressOption option, SuppressOption flag);
    [ExtensionAttribute]
public static bool IsMaskOn(SuppressOption option, SuppressOption mask);
    [ExtensionAttribute]
public static SuppressOption RemoveFlag(SuppressOption option, SuppressOption flag);
    [ExtensionAttribute]
public static string CreateIndentationString(int desiredIndentation, bool useTab, int tabSize);
    [ExtensionAttribute]
public static StringBuilder AppendIndentationString(StringBuilder sb, int desiredIndentation, bool useTab, int tabSize);
    [ExtensionAttribute]
public static void ProcessTextBetweenTokens(string text, TreeData treeInfo, SyntaxToken baseToken, int tabSize, Int32& lineBreaks, Int32& spaceOrIndentation);
    [ExtensionAttribute]
public static string AdjustIndentForXmlDocExteriorTrivia(string triviaText, bool forceIndentation, int indentation, int indentationDelta, bool useTab, int tabSize);
    [ExtensionAttribute]
public static string ReindentStartOfXmlDocumentationComment(string triviaText, bool forceIndentation, int indentation, int indentationDelta, bool useTab, int tabSize, string newLine);
    [ExtensionAttribute]
private static int GetNewIndentationForComments(string line, int nonWhitespaceCharIndex, bool forceIndentation, int indentation, int indentationDelta, int tabSize);
    [ExtensionAttribute]
public static int GetFirstNonWhitespaceIndexInString(string text);
    [ExtensionAttribute]
public static TextChange SimpleDiff(TextChange textChange, string text);
}
public static class Microsoft.CodeAnalysis.Formatting.FormattingOptions : object {
    internal static string TabFeatureName;
    internal static string InternalTabFeatureName;
    internal static string FormattingFeatureName;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <UseTabs>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<int> <TabSize>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<int> <IndentationSize>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<IndentStyle> <SmartIndent>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<string> <NewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <DebugMode>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <AllowDisjointSpanMerging>k__BackingField;
    public static PerLanguageOption`1<bool> UseTabs { get; }
    public static PerLanguageOption`1<int> TabSize { get; }
    public static PerLanguageOption`1<int> IndentationSize { get; }
    public static PerLanguageOption`1<IndentStyle> SmartIndent { get; }
    public static PerLanguageOption`1<string> NewLine { get; }
    internal static PerLanguageOption`1<bool> DebugMode { get; }
    internal static Option`1<bool> AllowDisjointSpanMerging { get; }
    private static FormattingOptions();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_UseTabs();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<int> get_TabSize();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<int> get_IndentationSize();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<IndentStyle> get_SmartIndent();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<string> get_NewLine();
    [CompilerGeneratedAttribute]
internal static PerLanguageOption`1<bool> get_DebugMode();
    [CompilerGeneratedAttribute]
internal static Option`1<bool> get_AllowDisjointSpanMerging();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Formatting.FormattingOptionsProvider : object {
    private IEnumerable`1<IOption> _options;
    public sealed virtual IEnumerable`1<IOption> GetOptions();
}
internal interface Microsoft.CodeAnalysis.Formatting.IFormattingResult {
    public abstract virtual IList`1<TextChange> GetTextChanges(CancellationToken cancellationToken);
    public abstract virtual SyntaxNode GetFormattedRoot(CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Formatting.ISyntaxFormattingService {
    public abstract virtual IEnumerable`1<IFormattingRule> GetDefaultFormattingRules();
    public abstract virtual IFormattingResult Format(SyntaxNode node, IEnumerable`1<TextSpan> spans, OptionSet options, IEnumerable`1<IFormattingRule> rules, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Formatting.LineColumn : ValueType {
    public static LineColumn Default;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WhitespaceOnly>k__BackingField;
    public int Line { get; private set; }
    public int Column { get; private set; }
    public bool WhitespaceOnly { get; private set; }
    public LineColumn(int line, int column, bool whitespaceOnly);
    private static LineColumn();
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
private void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
private void set_Column(int value);
    [CompilerGeneratedAttribute]
public bool get_WhitespaceOnly();
    [CompilerGeneratedAttribute]
private void set_WhitespaceOnly(bool value);
    public LineColumn With(LineColumnDelta delta);
}
internal class Microsoft.CodeAnalysis.Formatting.LineColumnDelta : ValueType {
    public static LineColumnDelta Default;
    [CompilerGeneratedAttribute]
private int <Lines>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Spaces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WhitespaceOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceUpdate>k__BackingField;
    public int Lines { get; private set; }
    public int Spaces { get; private set; }
    public bool WhitespaceOnly { get; private set; }
    public bool ForceUpdate { get; private set; }
    public LineColumnDelta(int lines, int spaces);
    public LineColumnDelta(int lines, int spaces, bool whitespaceOnly);
    public LineColumnDelta(int lines, int spaces, bool whitespaceOnly, bool forceUpdate);
    private static LineColumnDelta();
    [CompilerGeneratedAttribute]
public int get_Lines();
    [CompilerGeneratedAttribute]
private void set_Lines(int value);
    [CompilerGeneratedAttribute]
public int get_Spaces();
    [CompilerGeneratedAttribute]
private void set_Spaces(int value);
    [CompilerGeneratedAttribute]
public bool get_WhitespaceOnly();
    [CompilerGeneratedAttribute]
private void set_WhitespaceOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForceUpdate();
    [CompilerGeneratedAttribute]
private void set_ForceUpdate(bool value);
    internal LineColumnDelta With(LineColumnDelta delta);
}
internal class Microsoft.CodeAnalysis.Formatting.LineColumnRule : ValueType {
    [CompilerGeneratedAttribute]
private SpaceOperations <SpaceOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private LineOperations <LineOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private IndentationOperations <IndentationOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Lines>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Spaces>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Indentation>k__BackingField;
    public SpaceOperations SpaceOperation { get; private set; }
    public LineOperations LineOperation { get; private set; }
    public IndentationOperations IndentationOperation { get; private set; }
    public int Lines { get; private set; }
    public int Spaces { get; private set; }
    public int Indentation { get; private set; }
    public LineColumnRule With(Nullable`1<int> lines, Nullable`1<int> spaces, Nullable`1<int> indentation, Nullable`1<LineOperations> lineOperation, Nullable`1<SpaceOperations> spaceOperation, Nullable`1<IndentationOperations> indentationOperation);
    [CompilerGeneratedAttribute]
public SpaceOperations get_SpaceOperation();
    [CompilerGeneratedAttribute]
private void set_SpaceOperation(SpaceOperations value);
    [CompilerGeneratedAttribute]
public LineOperations get_LineOperation();
    [CompilerGeneratedAttribute]
private void set_LineOperation(LineOperations value);
    [CompilerGeneratedAttribute]
public IndentationOperations get_IndentationOperation();
    [CompilerGeneratedAttribute]
private void set_IndentationOperation(IndentationOperations value);
    [CompilerGeneratedAttribute]
public int get_Lines();
    [CompilerGeneratedAttribute]
private void set_Lines(int value);
    [CompilerGeneratedAttribute]
public int get_Spaces();
    [CompilerGeneratedAttribute]
private void set_Spaces(int value);
    [CompilerGeneratedAttribute]
public int get_Indentation();
    [CompilerGeneratedAttribute]
private void set_Indentation(int value);
    public static LineColumnRule Preserve();
    public static LineColumnRule PreserveWithGivenSpaces(int spaces);
    public static LineColumnRule PreserveLinesWithDefaultIndentation(int lines);
    public static LineColumnRule PreserveLinesWithGivenIndentation(int lines);
    public static LineColumnRule PreserveLinesWithAbsoluteIndentation(int lines, int indentation);
    public static LineColumnRule PreserveLinesWithFollowingPreceedingIndentation();
    public static LineColumnRule ForceSpaces(int spaces);
    public static LineColumnRule PreserveSpacesOrUseDefaultIndentation(int spaces);
    public static LineColumnRule ForceSpacesOrUseDefaultIndentation(int spaces);
    public static LineColumnRule ForceSpacesOrUseAbsoluteIndentation(int spacesOrIndentation);
}
internal static class Microsoft.CodeAnalysis.Formatting.ListPool`1 : object {
    public static List`1<T> Allocate();
    public static void Free(List`1<T> list);
    public static List`1<T> ReturnAndFree(List`1<T> list);
}
internal class Microsoft.CodeAnalysis.Formatting.NodeOperations : object {
    public static NodeOperations Empty;
    [CompilerGeneratedAttribute]
private Task`1<List`1<IndentBlockOperation>> <IndentBlockOperationTask>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<List`1<SuppressOperation>> <SuppressOperationTask>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<List`1<AlignTokensOperation>> <AlignmentOperationTask>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<List`1<AnchorIndentationOperation>> <AnchorIndentationOperationsTask>k__BackingField;
    public Task`1<List`1<IndentBlockOperation>> IndentBlockOperationTask { get; }
    public Task`1<List`1<SuppressOperation>> SuppressOperationTask { get; }
    public Task`1<List`1<AlignTokensOperation>> AlignmentOperationTask { get; }
    public Task`1<List`1<AnchorIndentationOperation>> AnchorIndentationOperationsTask { get; }
    public NodeOperations(Task`1<List`1<IndentBlockOperation>> indentBlockOperationTask, Task`1<List`1<SuppressOperation>> suppressOperationTask, Task`1<List`1<AnchorIndentationOperation>> anchorIndentationOperationsTask, Task`1<List`1<AlignTokensOperation>> alignmentOperationTask);
    private static NodeOperations();
    [CompilerGeneratedAttribute]
public Task`1<List`1<IndentBlockOperation>> get_IndentBlockOperationTask();
    [CompilerGeneratedAttribute]
public Task`1<List`1<SuppressOperation>> get_SuppressOperationTask();
    [CompilerGeneratedAttribute]
public Task`1<List`1<AlignTokensOperation>> get_AlignmentOperationTask();
    [CompilerGeneratedAttribute]
public Task`1<List`1<AnchorIndentationOperation>> get_AnchorIndentationOperationsTask();
}
internal class Microsoft.CodeAnalysis.Formatting.OperationCache`1 : object {
    [CompilerGeneratedAttribute]
private Func`5<int, SyntaxToken, SyntaxToken, NextOperation`1<TResult>, TResult> <NextOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`5<int, SyntaxToken, SyntaxToken, IOperationHolder`1<TResult>, TResult> <Continuation>k__BackingField;
    public Func`5<int, SyntaxToken, SyntaxToken, NextOperation`1<TResult>, TResult> NextOperation { get; }
    public Func`5<int, SyntaxToken, SyntaxToken, IOperationHolder`1<TResult>, TResult> Continuation { get; }
    public OperationCache`1(Func`5<int, SyntaxToken, SyntaxToken, NextOperation`1<TResult>, TResult> nextOperation, Func`5<int, SyntaxToken, SyntaxToken, IOperationHolder`1<TResult>, TResult> continuation);
    [CompilerGeneratedAttribute]
public sealed virtual Func`5<int, SyntaxToken, SyntaxToken, NextOperation`1<TResult>, TResult> get_NextOperation();
    [CompilerGeneratedAttribute]
public sealed virtual Func`5<int, SyntaxToken, SyntaxToken, IOperationHolder`1<TResult>, TResult> get_Continuation();
}
internal abstract class Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule : object {
    public virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<SuppressOperation> nextOperation);
    public virtual void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<AnchorIndentationOperation> nextOperation);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<IndentBlockOperation> nextOperation);
    public virtual void AddAlignTokensOperations(List`1<AlignTokensOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<AlignTokensOperation> nextOperation);
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet, NextOperation`1<AdjustNewLinesOperation> nextOperation);
    public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet, NextOperation`1<AdjustSpacesOperation> nextOperation);
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOperation : object {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private AdjustNewLinesOption <Option>k__BackingField;
    public int Line { get; }
    public AdjustNewLinesOption Option { get; }
    internal AdjustNewLinesOperation(int line, AdjustNewLinesOption option);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public AdjustNewLinesOption get_Option();
}
internal enum Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOption : Enum {
    public int value__;
    public static AdjustNewLinesOption PreserveLines;
    public static AdjustNewLinesOption ForceLines;
    public static AdjustNewLinesOption ForceLinesIfOnSingleLine;
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOperation : object {
    [CompilerGeneratedAttribute]
private int <Space>k__BackingField;
    [CompilerGeneratedAttribute]
private AdjustSpacesOption <Option>k__BackingField;
    public int Space { get; }
    public AdjustSpacesOption Option { get; }
    internal AdjustSpacesOperation(int space, AdjustSpacesOption option);
    [CompilerGeneratedAttribute]
public int get_Space();
    [CompilerGeneratedAttribute]
public AdjustSpacesOption get_Option();
}
internal enum Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption : Enum {
    public int value__;
    public static AdjustSpacesOption PreserveSpaces;
    public static AdjustSpacesOption DefaultSpacesIfOnSingleLine;
    public static AdjustSpacesOption ForceSpacesIfOnSingleLine;
    public static AdjustSpacesOption ForceSpaces;
    public static AdjustSpacesOption DynamicSpaceToIndentationIfOnSingleLine;
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation : object {
    [CompilerGeneratedAttribute]
private SyntaxToken <BaseToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SyntaxToken> <Tokens>k__BackingField;
    [CompilerGeneratedAttribute]
private AlignTokensOption <Option>k__BackingField;
    public SyntaxToken BaseToken { get; }
    public IEnumerable`1<SyntaxToken> Tokens { get; }
    public AlignTokensOption Option { get; }
    internal AlignTokensOperation(SyntaxToken baseToken, IEnumerable`1<SyntaxToken> tokens, AlignTokensOption option);
    [CompilerGeneratedAttribute]
public SyntaxToken get_BaseToken();
    [CompilerGeneratedAttribute]
public IEnumerable`1<SyntaxToken> get_Tokens();
    [CompilerGeneratedAttribute]
public AlignTokensOption get_Option();
}
internal enum Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOption : Enum {
    public int value__;
    public static AlignTokensOption AlignIndentationOfTokensToBaseToken;
    public static AlignTokensOption AlignIndentationOfTokensToFirstTokenOfBaseTokenLine;
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.AnchorIndentationOperation : object {
    [CompilerGeneratedAttribute]
private SyntaxToken <AnchorToken>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <StartToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <EndToken>k__BackingField;
    public SyntaxToken AnchorToken { get; }
    public TextSpan TextSpan { get; }
    public SyntaxToken StartToken { get; }
    public SyntaxToken EndToken { get; }
    internal AnchorIndentationOperation(SyntaxToken anchorToken, SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan);
    [CompilerGeneratedAttribute]
public SyntaxToken get_AnchorToken();
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public SyntaxToken get_StartToken();
    [CompilerGeneratedAttribute]
public SyntaxToken get_EndToken();
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.BaseIndentationFormattingRule : AbstractFormattingRule {
    private IFormattingRule _vbHelperFormattingRule;
    private int _baseIndentation;
    private SyntaxToken _token1;
    private SyntaxToken _token2;
    private SyntaxNode _commonNode;
    private TextSpan _span;
    public BaseIndentationFormattingRule(SyntaxNode root, TextSpan span, int baseIndentation, IFormattingRule vbHelperFormattingRule);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<IndentBlockOperation> nextOperation);
    private void AddNextIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<IndentBlockOperation> nextOperation);
    private void AdjustIndentBlockOperation(List`1<IndentBlockOperation> list);
    private bool Myself(IndentBlockOperation operation);
    private IndentBlockOperation CloneAndAdjustFormattingOperation(IndentBlockOperation operation);
    private TextSpan AdjustTextSpan(TextSpan textSpan);
    private void SetInnermostNodeForSpan(SyntaxNode root, TextSpan& span, SyntaxToken& token1, SyntaxToken& token2, SyntaxNode& commonNode);
    private static void GetTokens(SyntaxNode root, TextSpan span, SyntaxToken& token1, SyntaxToken& token2);
    private static TextSpan GetSpanFromTokens(TextSpan span, SyntaxToken token1, SyntaxToken token2);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Formatting.Rules.IHostDependentFormattingRuleFactoryService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Formatting.Rules.DefaultFormattingRuleFactoryServiceFactory : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.Formatting.Rules.ExportFormattingRule : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Name { get; }
    public string Language { get; }
    public ExportFormattingRule(string name, string language);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Language();
}
internal static class Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations : object {
    private static AdjustNewLinesOperation s_preserveZeroLine;
    private static AdjustNewLinesOperation s_preserveOneLine;
    private static AdjustNewLinesOperation s_forceOneLine;
    private static AdjustNewLinesOperation s_forceIfSameLine;
    private static AdjustSpacesOperation s_defaultOneSpaceIfOnSingleLine;
    private static AdjustSpacesOperation s_forceOneSpaceIfOnSingleLine;
    private static AdjustSpacesOperation s_forceZeroSpaceIfOnSingleLine;
    private static AdjustSpacesOperation s_forceZeroLineUsingSpaceForce;
    private static FormattingOperations();
    public static AnchorIndentationOperation CreateAnchorIndentationOperation(SyntaxToken startToken, SyntaxToken endToken);
    public static AnchorIndentationOperation CreateAnchorIndentationOperation(SyntaxToken anchorToken, SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan);
    public static SuppressOperation CreateSuppressOperation(SyntaxToken startToken, SyntaxToken endToken, SuppressOption option);
    private static SuppressOperation CreateSuppressOperation(SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, SuppressOption option);
    public static IndentBlockOperation CreateIndentBlockOperation(SyntaxToken startToken, SyntaxToken endToken, int indentationDelta, IndentBlockOption option);
    public static IndentBlockOperation CreateIndentBlockOperation(SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, int indentationDelta, IndentBlockOption option);
    public static IndentBlockOperation CreateRelativeIndentBlockOperation(SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, int indentationDelta, IndentBlockOption option);
    public static IndentBlockOperation CreateRelativeIndentBlockOperation(SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, int indentationDelta, IndentBlockOption option);
    public static AlignTokensOperation CreateAlignTokensOperation(SyntaxToken baseToken, IEnumerable`1<SyntaxToken> tokens, AlignTokensOption option);
    public static AdjustNewLinesOperation CreateAdjustNewLinesOperation(int line, AdjustNewLinesOption option);
    public static AdjustSpacesOperation CreateAdjustSpacesOperation(int space, AdjustSpacesOption option);
    internal static IEnumerable`1<SuppressOperation> GetSuppressOperations(IEnumerable`1<IFormattingRule> formattingRules, SyntaxNode node, OptionSet optionSet);
    internal static IEnumerable`1<AnchorIndentationOperation> GetAnchorIndentationOperations(IEnumerable`1<IFormattingRule> formattingRules, SyntaxNode node, OptionSet optionSet);
    internal static IEnumerable`1<IndentBlockOperation> GetIndentBlockOperations(IEnumerable`1<IFormattingRule> formattingRules, SyntaxNode node, OptionSet optionSet);
    internal static IEnumerable`1<AlignTokensOperation> GetAlignTokensOperations(IEnumerable`1<IFormattingRule> formattingRules, SyntaxNode node, OptionSet optionSet);
    internal static AdjustNewLinesOperation GetAdjustNewLinesOperation(IEnumerable`1<IFormattingRule> formattingRules, SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet);
    internal static AdjustSpacesOperation GetAdjustSpacesOperation(IEnumerable`1<IFormattingRule> formattingRules, SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet);
}
internal interface Microsoft.CodeAnalysis.Formatting.Rules.IActionHolder`1 {
    public Action`4<int, List`1<TArgument>, SyntaxNode, NextAction`1<TArgument>> NextOperation { get; }
    public Action`4<int, List`1<TArgument>, SyntaxNode, IActionHolder`1<TArgument>> Continuation { get; }
    public abstract virtual Action`4<int, List`1<TArgument>, SyntaxNode, NextAction`1<TArgument>> get_NextOperation();
    public abstract virtual Action`4<int, List`1<TArgument>, SyntaxNode, IActionHolder`1<TArgument>> get_Continuation();
}
internal interface Microsoft.CodeAnalysis.Formatting.Rules.IFormattingRule {
    public abstract virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<SuppressOperation> nextOperation);
    public abstract virtual void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<AnchorIndentationOperation> nextOperation);
    public abstract virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<IndentBlockOperation> nextOperation);
    public abstract virtual void AddAlignTokensOperations(List`1<AlignTokensOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<AlignTokensOperation> nextOperation);
    public abstract virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet, NextOperation`1<AdjustNewLinesOperation> nextOperation);
    public abstract virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet, NextOperation`1<AdjustSpacesOperation> nextOperation);
}
internal interface Microsoft.CodeAnalysis.Formatting.Rules.IHostDependentFormattingRuleFactoryService {
    public abstract virtual bool ShouldNotFormatOrCommitOnPaste(Document document);
    public abstract virtual bool ShouldUseBaseIndentation(Document document);
    public abstract virtual IFormattingRule CreateRule(Document document, int position);
    public abstract virtual IEnumerable`1<TextChange> FilterFormattedChanges(Document document, TextSpan span, IList`1<TextChange> changes);
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation : object {
    [CompilerGeneratedAttribute]
private SyntaxToken <BaseToken>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private IndentBlockOption <Option>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <StartToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <EndToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRelativeIndentation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndentationDeltaOrPosition>k__BackingField;
    public SyntaxToken BaseToken { get; }
    public TextSpan TextSpan { get; }
    public IndentBlockOption Option { get; }
    public SyntaxToken StartToken { get; }
    public SyntaxToken EndToken { get; }
    public bool IsRelativeIndentation { get; }
    public int IndentationDeltaOrPosition { get; }
    internal IndentBlockOperation(SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, int indentationDelta, IndentBlockOption option);
    internal IndentBlockOperation(SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, int indentationDelta, IndentBlockOption option);
    [CompilerGeneratedAttribute]
public SyntaxToken get_BaseToken();
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public IndentBlockOption get_Option();
    [CompilerGeneratedAttribute]
public SyntaxToken get_StartToken();
    [CompilerGeneratedAttribute]
public SyntaxToken get_EndToken();
    [CompilerGeneratedAttribute]
public bool get_IsRelativeIndentation();
    [CompilerGeneratedAttribute]
public int get_IndentationDeltaOrPosition();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption : Enum {
    public int value__;
    public static IndentBlockOption RelativeToFirstTokenOnBaseTokenLine;
    public static IndentBlockOption RelativePosition;
    public static IndentBlockOption AbsolutePosition;
    public static IndentBlockOption RelativePositionMask;
    public static IndentBlockOption PositionMask;
}
internal interface Microsoft.CodeAnalysis.Formatting.Rules.IOperationHolder`1 {
    public Func`5<int, SyntaxToken, SyntaxToken, NextOperation`1<TResult>, TResult> NextOperation { get; }
    public Func`5<int, SyntaxToken, SyntaxToken, IOperationHolder`1<TResult>, TResult> Continuation { get; }
    public abstract virtual Func`5<int, SyntaxToken, SyntaxToken, NextOperation`1<TResult>, TResult> get_NextOperation();
    public abstract virtual Func`5<int, SyntaxToken, SyntaxToken, IOperationHolder`1<TResult>, TResult> get_Continuation();
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.NextAction`1 : ValueType {
    private int _index;
    private SyntaxNode _node;
    private IActionHolder`1<TArgument> _actionCache;
    public NextAction`1(int index, SyntaxNode node, IActionHolder`1<TArgument> actionCache);
    public void Invoke(List`1<TArgument> arguments);
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.NextOperation`1 : ValueType {
    private int _index;
    private SyntaxToken _token1;
    private SyntaxToken _token2;
    private IOperationHolder`1<TResult> _operationCache;
    public NextOperation`1(int index, SyntaxToken token1, SyntaxToken token2, IOperationHolder`1<TResult> operationCache);
    public TResult Invoke();
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.NoOpFormattingRule : object {
    public sealed virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<SuppressOperation> nextOperation);
    public sealed virtual void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<AnchorIndentationOperation> nextOperation);
    public sealed virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<IndentBlockOperation> nextOperation);
    public sealed virtual void AddAlignTokensOperations(List`1<AlignTokensOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<AlignTokensOperation> nextOperation);
    public sealed virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet, NextOperation`1<AdjustNewLinesOperation> nextOperation);
    public sealed virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet, NextOperation`1<AdjustSpacesOperation> nextOperation);
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation : object {
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private SuppressOption <Option>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <StartToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <EndToken>k__BackingField;
    public TextSpan TextSpan { get; }
    public SuppressOption Option { get; }
    public SyntaxToken StartToken { get; }
    public SyntaxToken EndToken { get; }
    internal SuppressOperation(SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, SuppressOption option);
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public SuppressOption get_Option();
    [CompilerGeneratedAttribute]
public SyntaxToken get_StartToken();
    [CompilerGeneratedAttribute]
public SyntaxToken get_EndToken();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption : Enum {
    public int value__;
    public static SuppressOption None;
    public static SuppressOption NoWrappingIfOnSingleLine;
    public static SuppressOption NoWrappingIfOnMultipleLine;
    public static SuppressOption NoWrapping;
    public static SuppressOption NoSpacingIfOnSingleLine;
    public static SuppressOption NoSpacingIfOnMultipleLine;
    public static SuppressOption NoSpacing;
    public static SuppressOption IgnoreElastic;
}
internal static class Microsoft.CodeAnalysis.Formatting.StringBuilderPool : object {
    public static StringBuilder Allocate();
    public static void Free(StringBuilder builder);
    public static string ReturnAndFree(StringBuilder builder);
}
internal class Microsoft.CodeAnalysis.Formatting.SuppressIntervalIntrospector : object {
    public static SuppressIntervalIntrospector Instance;
    private static SuppressIntervalIntrospector();
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.SuppressSpacingData>.GetStart(SuppressSpacingData value);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.SuppressSpacingData>.GetLength(SuppressSpacingData value);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.SuppressWrappingData>.GetStart(SuppressWrappingData value);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.SuppressWrappingData>.GetLength(SuppressWrappingData value);
}
internal class Microsoft.CodeAnalysis.Formatting.SuppressSpacingData : object {
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoSpacing>k__BackingField;
    public TextSpan TextSpan { get; }
    public bool NoSpacing { get; }
    public SuppressSpacingData(TextSpan textSpan, bool noSpacing);
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public bool get_NoSpacing();
}
internal class Microsoft.CodeAnalysis.Formatting.SuppressWrappingData : object {
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoWrapping>k__BackingField;
    public TextSpan TextSpan { get; }
    public bool NoWrapping { get; }
    public SuppressWrappingData(TextSpan textSpan, bool noWrapping);
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public bool get_NoWrapping();
}
internal abstract class Microsoft.CodeAnalysis.Formatting.TaskExecutor : object {
    public static TaskExecutor Concurrent;
    public static TaskExecutor Synchronous;
    private static TaskExecutor();
    public abstract virtual Task`1<T2> ContinueWith(Task`1<T1> previousTask, Func`2<Task`1<T1>, T2> nextAction, CancellationToken cancellationToken);
    public abstract virtual Task ContinueWith(Task`1<T> previousTask, Action`1<Task`1<T>> nextAction, CancellationToken cancellationToken);
    public abstract virtual Task StartNew(Action action, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> StartNew(Func`1<T> action, CancellationToken cancellationToken);
    public abstract virtual void ForEach(IEnumerable`1<T> source, Action`1<T> action, CancellationToken cancellationToken);
    public abstract virtual void For(int fromInclusive, int toExclusive, Action`1<int> body, CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<TResult> Filter(IEnumerable`1<TSource> source, Func`2<TSource, bool> filter, Func`2<TSource, TResult> projection, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Formatting.TokenData : ValueType {
    [CompilerGeneratedAttribute]
private TokenStream <TokenStream>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexInStream>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <Token>k__BackingField;
    public TokenStream TokenStream { get; }
    public int IndexInStream { get; }
    public SyntaxToken Token { get; }
    public TokenData(TokenStream tokenStream, int indexInStream, SyntaxToken token);
    [CompilerGeneratedAttribute]
public TokenStream get_TokenStream();
    [CompilerGeneratedAttribute]
public int get_IndexInStream();
    [CompilerGeneratedAttribute]
public SyntaxToken get_Token();
    public TokenData GetPreviousTokenData();
    public TokenData GetNextTokenData();
    public sealed virtual bool Equals(TokenData x, TokenData y);
    public sealed virtual int GetHashCode(TokenData obj);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TokenData other);
    public sealed virtual int Compare(TokenData x, TokenData y);
    public sealed virtual int CompareTo(TokenData other);
    private int Index(IEnumerable`1<SyntaxToken> tokens, SyntaxToken token);
    public static bool op_LessThan(TokenData left, TokenData right);
    public static bool op_GreaterThan(TokenData left, TokenData right);
    public static bool op_Equality(TokenData left, TokenData right);
    public static bool op_Inequality(TokenData left, TokenData right);
}
internal class Microsoft.CodeAnalysis.Formatting.TokenPairWithOperations : ValueType {
    [CompilerGeneratedAttribute]
private TokenStream <TokenStream>k__BackingField;
    [CompilerGeneratedAttribute]
private AdjustSpacesOperation <SpaceOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private AdjustNewLinesOperation <LineOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PairIndex>k__BackingField;
    public TokenStream TokenStream { get; }
    public AdjustSpacesOperation SpaceOperation { get; }
    public AdjustNewLinesOperation LineOperation { get; }
    public int PairIndex { get; }
    public SyntaxToken Token1 { get; }
    public SyntaxToken Token2 { get; }
    public TokenPairWithOperations(TokenStream tokenStream, int tokenPairIndex, AdjustSpacesOperation spaceOperations, AdjustNewLinesOperation lineOperations);
    [CompilerGeneratedAttribute]
public TokenStream get_TokenStream();
    [CompilerGeneratedAttribute]
public AdjustSpacesOperation get_SpaceOperation();
    [CompilerGeneratedAttribute]
public AdjustNewLinesOperation get_LineOperation();
    [CompilerGeneratedAttribute]
public int get_PairIndex();
    public SyntaxToken get_Token1();
    public SyntaxToken get_Token2();
}
internal class Microsoft.CodeAnalysis.Formatting.TokenStream : object {
    private static int MagicTextLengthToTokensRatio;
    private List`1<SyntaxToken> _tokens;
    private Dictionary`2<SyntaxToken, int> _tokenToIndexMap;
    private TriviaData[] _cachedOriginalTriviaInfo;
    private TreeData _treeData;
    private OptionSet _optionSet;
    private Changes _changes;
    private AbstractTriviaDataFactory _factory;
    private Func`3<TokenData, TokenData, TriviaData> _getTriviaData;
    private Func`3<TokenData, TokenData, TriviaData> _getOriginalTriviaData;
    public bool FormatBeginningOfTree { get; }
    public bool FormatEndOfTree { get; }
    public bool IsFormattingWholeDocument { get; }
    public TokenData FirstTokenInStream { get; }
    public TokenData LastTokenInStream { get; }
    public int TokenCount { get; }
    public IEnumerable`1<ValueTuple`3<int, SyntaxToken, SyntaxToken>> TokenIterator { get; }
    public TokenStream(TreeData treeData, OptionSet optionSet, TextSpan spanToFormat, AbstractTriviaDataFactory factory);
    [ConditionalAttribute("DEBUG")]
private void DebugCheckTokenOrder();
    public bool get_FormatBeginningOfTree();
    public bool get_FormatEndOfTree();
    public bool get_IsFormattingWholeDocument();
    public TokenData get_FirstTokenInStream();
    public TokenData get_LastTokenInStream();
    public int get_TokenCount();
    public SyntaxToken GetToken(int index);
    public TokenData GetTokenData(SyntaxToken token);
    public TokenData GetPreviousTokenData(TokenData tokenData);
    public TokenData GetNextTokenData(TokenData tokenData);
    internal SyntaxToken FirstTokenOfBaseTokenLine(SyntaxToken token);
    public bool TwoTokensOriginallyOnSameLine(SyntaxToken token1, SyntaxToken token2);
    public bool TwoTokensOnSameLine(SyntaxToken token1, SyntaxToken token2);
    private bool TwoTokensOnSameLineWorker(SyntaxToken token1, SyntaxToken token2, Func`3<TokenData, TokenData, TriviaData> triviaDataGetter);
    public void ApplyBeginningOfTreeChange(TriviaData data);
    public void ApplyEndOfTreeChange(TriviaData data);
    public void ApplyChange(int pairIndex, TriviaData data);
    public int GetCurrentColumn(SyntaxToken token);
    public int GetCurrentColumn(TokenData tokenData);
    public int GetOriginalColumn(SyntaxToken token);
    private int GetColumn(TokenData tokenData, Func`3<TokenData, TokenData, TriviaData> triviaDataGetter);
    public void GetTokenLength(SyntaxToken token, Int32& length, Boolean& onMultipleLines);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.TokenStream/<GetTriviaDataWithTokenPair>d__41")]
public IEnumerable`1<ValueTuple`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData>> GetTriviaDataWithTokenPair(CancellationToken cancellationToken);
    public TriviaData GetTriviaData(TokenData token1, TokenData token2);
    private TriviaData GetOriginalTriviaData(TokenData token1, TokenData token2);
    public TriviaData GetTriviaDataAtBeginningOfTree();
    public TriviaData GetTriviaDataAtEndOfTree();
    public TriviaData GetTriviaData(int pairIndex);
    private TriviaData GetOriginalTriviaData(int pairIndex);
    public bool IsFirstTokenOnLine(SyntaxToken token);
    private bool IsFirstTokenOnLine(TokenData tokenData1, TokenData tokenData2);
    private int GetTokenIndexInStream(SyntaxToken token);
    public IEnumerable`1<ValueTuple`3<int, SyntaxToken, SyntaxToken>> get_TokenIterator();
}
internal abstract class Microsoft.CodeAnalysis.Formatting.TreeData : object {
    private SyntaxNode _root;
    private SyntaxToken _firstToken;
    private SyntaxToken _lastToken;
    public SyntaxNode Root { get; }
    public int StartPosition { get; }
    public int EndPosition { get; }
    public TreeData(SyntaxNode root);
    public static TreeData Create(SyntaxNode root);
    public static TreeData Create(SyntaxTrivia trivia, int initialColumn);
    public abstract virtual string GetTextBetween(SyntaxToken token1, SyntaxToken token2);
    public abstract virtual int GetOriginalColumn(int tabSize, SyntaxToken token);
    public SyntaxNode get_Root();
    public bool IsFirstToken(SyntaxToken token);
    public bool IsLastToken(SyntaxToken token);
    public int get_StartPosition();
    public int get_EndPosition();
    public IEnumerable`1<SyntaxToken> GetApplicableTokens(TextSpan textSpan);
}
internal abstract class Microsoft.CodeAnalysis.Formatting.TriviaData : object {
    protected static int TokenPairIndexNotNeeded;
    private OptionSet _optionSet;
    private string _language;
    [CompilerGeneratedAttribute]
private int <LineBreaks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Spaces>k__BackingField;
    protected OptionSet OptionSet { get; }
    protected string Language { get; }
    public int LineBreaks { get; protected set; }
    public int Spaces { get; protected set; }
    public bool SecondTokenIsFirstTokenOnLine { get; }
    public bool TreatAsElastic { get; }
    public bool IsWhitespaceOnlyTrivia { get; }
    public bool ContainsChanges { get; }
    protected TriviaData(OptionSet optionSet, string language);
    protected OptionSet get_OptionSet();
    protected string get_Language();
    [CompilerGeneratedAttribute]
public int get_LineBreaks();
    [CompilerGeneratedAttribute]
protected void set_LineBreaks(int value);
    [CompilerGeneratedAttribute]
public int get_Spaces();
    [CompilerGeneratedAttribute]
protected void set_Spaces(int value);
    public bool get_SecondTokenIsFirstTokenOnLine();
    public abstract virtual bool get_TreatAsElastic();
    public abstract virtual bool get_IsWhitespaceOnlyTrivia();
    public abstract virtual bool get_ContainsChanges();
    public abstract virtual IEnumerable`1<TextChange> GetTextChanges(TextSpan span);
    public abstract virtual TriviaData WithSpace(int space, FormattingContext context, ChainedFormattingRules formattingRules);
    public abstract virtual TriviaData WithLine(int line, int indentation, FormattingContext context, ChainedFormattingRules formattingRules, CancellationToken cancellationToken);
    public abstract virtual TriviaData WithIndentation(int indentation, FormattingContext context, ChainedFormattingRules formattingRules, CancellationToken cancellationToken);
    public abstract virtual void Format(FormattingContext context, ChainedFormattingRules formattingRules, Action`2<int, TriviaData> formattingResultApplier, CancellationToken cancellationToken, int tokenPairIndex);
}
internal abstract class Microsoft.CodeAnalysis.Formatting.TriviaDataWithList`1 : TriviaData {
    public TriviaDataWithList`1(OptionSet optionSet, string language);
    public abstract virtual List`1<T> GetTriviaList(CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Formatting.TriviaList : ValueType {
    private SyntaxTriviaList _list1;
    private SyntaxTriviaList _list2;
    public int Count { get; }
    public TriviaList(SyntaxTriviaList list1, SyntaxTriviaList list2);
    public int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<SyntaxTrivia> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.GeneratedCodeRecognition.IGeneratedCodeRecognitionService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.GeneratedCodeRecognition.GeneratedCodeRecognitionServiceFactory : object {
    private static IGeneratedCodeRecognitionService s_singleton;
    private static GeneratedCodeRecognitionServiceFactory();
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal interface Microsoft.CodeAnalysis.GeneratedCodeRecognition.IGeneratedCodeRecognitionService {
    public abstract virtual bool IsGeneratedCode(Document document);
}
internal abstract class Microsoft.CodeAnalysis.Host.AbstractPersistentStorage : object {
    private IOptionService _optionService;
    private Action`1<AbstractPersistentStorage> _disposer;
    private int _refCounter;
    [CompilerGeneratedAttribute]
private string <WorkingFolderPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SolutionFilePath>k__BackingField;
    public string WorkingFolderPath { get; }
    public string SolutionFilePath { get; }
    protected bool PersistenceEnabled { get; }
    protected AbstractPersistentStorage(IOptionService optionService, string workingFolderPath, string solutionFilePath, Action`1<AbstractPersistentStorage> disposer);
    [CompilerGeneratedAttribute]
public string get_WorkingFolderPath();
    [CompilerGeneratedAttribute]
public string get_SolutionFilePath();
    protected bool get_PersistenceEnabled();
    public sealed virtual void Dispose();
    public void AddRefUnsafe();
    public bool ReleaseRefUnsafe();
    public virtual void Close();
    public abstract virtual Task`1<Stream> ReadStreamAsync(string name, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(Project project, string name, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(Document document, string name, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(string name, Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(Project project, string name, Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(Document document, string name, Stream stream, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Host.AbstractSyntaxTreeFactoryService : object {
    internal int MinimumLengthForRecoverableTree;
    private bool hasCachingService;
    [CompilerGeneratedAttribute]
private HostLanguageServices <LanguageServices>k__BackingField;
    internal HostLanguageServices LanguageServices { get; private set; }
    public AbstractSyntaxTreeFactoryService(HostLanguageServices languageServices);
    [CompilerGeneratedAttribute]
internal HostLanguageServices get_LanguageServices();
    [CompilerGeneratedAttribute]
private void set_LanguageServices(HostLanguageServices value);
    public abstract virtual ParseOptions GetDefaultParseOptions();
    public abstract virtual SyntaxTree CreateSyntaxTree(string filePath, ParseOptions options, Encoding encoding, SyntaxNode root);
    public abstract virtual SyntaxTree ParseSyntaxTree(string filePath, ParseOptions options, SourceText text, CancellationToken cancellationToken);
    public abstract virtual SyntaxTree CreateRecoverableTree(ProjectId cacheKey, string filePath, ParseOptions options, ValueSource`1<TextAndVersion> text, Encoding encoding, SyntaxNode root);
    public abstract virtual SyntaxNode DeserializeNodeFrom(Stream stream, CancellationToken cancellationToken);
    public virtual bool CanCreateRecoverableTree(SyntaxNode root);
    protected static SyntaxNode RecoverNode(SyntaxTree tree, TextSpan textSpan, int kind);
}
internal class Microsoft.CodeAnalysis.Host.CachedWeakValueSource`1 : ValueSource`1<T> {
    private SemaphoreSlim _gateDoNotAccessDirectly;
    private ValueSource`1<T> _source;
    private WeakReference`1<T> _reference;
    private static WeakReference`1<T> s_noReference;
    private SemaphoreSlim Gate { get; }
    public CachedWeakValueSource`1(ValueSource`1<T> source);
    private static CachedWeakValueSource`1();
    private SemaphoreSlim get_Gate();
    public virtual bool TryGetValue(T& value);
    public virtual T GetValue(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Host.CachedWeakValueSource`1/<GetValueAsync>d__9")]
public virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Host.CacheOptions : object {
    internal static string FeatureName;
    internal static Option`1<int> RecoverableTreeLengthThreshold;
    private static CacheOptions();
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Host.IHostContextService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.HostContext.HostContextService : object {
    private static string CSharpProjectType;
    private static string VisualBasicProjectType;
    public sealed virtual string GetProjectType(Workspace workspace, ProjectId projectId);
}
public abstract class Microsoft.CodeAnalysis.Host.HostLanguageServices : object {
    public HostWorkspaceServices WorkspaceServices { get; }
    public string Language { get; }
    internal ICompilationFactoryService CompilationFactory { get; }
    internal ISyntaxTreeFactoryService SyntaxTreeFactory { get; }
    public abstract virtual HostWorkspaceServices get_WorkspaceServices();
    public abstract virtual string get_Language();
    public abstract virtual TLanguageService GetService();
    public TLanguageService GetRequiredService();
    internal virtual ICompilationFactoryService get_CompilationFactory();
    internal virtual ISyntaxTreeFactoryService get_SyntaxTreeFactory();
}
public abstract class Microsoft.CodeAnalysis.Host.HostServices : object {
    protected internal abstract virtual HostWorkspaceServices CreateWorkspaceServices(Workspace workspace);
}
public abstract class Microsoft.CodeAnalysis.Host.HostWorkspaceServices : object {
    public HostServices HostServices { get; }
    public Workspace Workspace { get; }
    public IPersistentStorageService PersistentStorage { get; }
    public ITemporaryStorageService TemporaryStorage { get; }
    internal ITextFactoryService TextFactory { get; }
    public IEnumerable`1<string> SupportedLanguages { get; }
    public abstract virtual HostServices get_HostServices();
    public abstract virtual Workspace get_Workspace();
    public abstract virtual TWorkspaceService GetService();
    public TWorkspaceService GetRequiredService();
    public virtual IPersistentStorageService get_PersistentStorage();
    public virtual ITemporaryStorageService get_TemporaryStorage();
    internal virtual ITextFactoryService get_TextFactory();
    public virtual IEnumerable`1<string> get_SupportedLanguages();
    public virtual bool IsSupported(string languageName);
    public virtual HostLanguageServices GetLanguageServices(string languageName);
    public abstract virtual IEnumerable`1<TLanguageService> FindLanguageServices(MetadataFilter filter);
}
public interface Microsoft.CodeAnalysis.Host.IAnalyzerService {
    public abstract virtual IAnalyzerAssemblyLoader GetLoader();
}
internal interface Microsoft.CodeAnalysis.Host.ICachedObjectOwner {
    public object CachedObject { get; public set; }
    public abstract virtual object get_CachedObject();
    public abstract virtual void set_CachedObject(object value);
}
internal interface Microsoft.CodeAnalysis.Host.ICommandLineArgumentsFactoryService {
    public abstract virtual CommandLineArguments CreateCommandLineArguments(IEnumerable`1<string> arguments, string baseDirectory, bool isInteractive, string sdkDirectory);
}
internal interface Microsoft.CodeAnalysis.Host.ICompilationFactoryService {
    public abstract virtual Compilation CreateCompilation(string assemblyName, CompilationOptions options);
    public abstract virtual Compilation CreateSubmissionCompilation(string assemblyName, CompilationOptions options, Type hostObjectType);
    public abstract virtual Compilation GetCompilationFromCompilationReference(MetadataReference reference);
    public abstract virtual bool IsCompilationReference(MetadataReference reference);
    public abstract virtual CompilationOptions GetDefaultCompilationOptions();
}
internal interface Microsoft.CodeAnalysis.Host.IDocumentationProviderService {
    public abstract virtual DocumentationProvider GetDocumentationProvider(string assemblyFullPath);
}
internal interface Microsoft.CodeAnalysis.Host.IHostContextService {
    public abstract virtual string GetProjectType(Workspace workspace, ProjectId projectId);
}
public interface Microsoft.CodeAnalysis.Host.ILanguageService {
}
internal interface Microsoft.CodeAnalysis.Host.IMetadataService {
    public abstract virtual PortableExecutableReference GetReference(string resolvedPath, MetadataReferenceProperties properties);
    public abstract virtual MetadataFileReferenceProvider GetProvider();
}
public interface Microsoft.CodeAnalysis.Host.IPersistentStorage {
    public abstract virtual Task`1<Stream> ReadStreamAsync(string name, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(Project project, string name, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(Document document, string name, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(string name, Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(Project project, string name, Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(Document document, string name, Stream stream, CancellationToken cancellationToken);
}
public interface Microsoft.CodeAnalysis.Host.IPersistentStorageService {
    public abstract virtual IPersistentStorage GetStorage(Solution solution);
}
internal interface Microsoft.CodeAnalysis.Host.IProjectCacheHostService {
    public abstract virtual T CacheObjectIfCachingEnabledForKey(ProjectId key, object owner, T instance);
    public abstract virtual T CacheObjectIfCachingEnabledForKey(ProjectId key, ICachedObjectOwner owner, T instance);
}
internal interface Microsoft.CodeAnalysis.Host.IProjectCacheService {
    public abstract virtual IDisposable EnableCaching(ProjectId key);
}
internal interface Microsoft.CodeAnalysis.Host.IRecoverableSyntaxTree`1 {
    public abstract virtual TRoot CloneNodeAsRoot(TRoot root);
}
internal interface Microsoft.CodeAnalysis.Host.ISupportDirectMemoryAccess {
    public abstract virtual IntPtr GetPointer();
}
internal interface Microsoft.CodeAnalysis.Host.ISyntaxTreeFactoryService {
    public abstract virtual ParseOptions GetDefaultParseOptions();
    public abstract virtual SyntaxTree CreateSyntaxTree(string filePath, ParseOptions options, Encoding encoding, SyntaxNode root);
    public abstract virtual SyntaxTree ParseSyntaxTree(string filePath, ParseOptions options, SourceText text, CancellationToken cancellationToken);
    public abstract virtual bool CanCreateRecoverableTree(SyntaxNode root);
    public abstract virtual SyntaxTree CreateRecoverableTree(ProjectId cacheKey, string filePath, ParseOptions options, ValueSource`1<TextAndVersion> text, Encoding encoding, SyntaxNode root);
    public abstract virtual SyntaxNode DeserializeNodeFrom(Stream stream, CancellationToken cancellationToken);
}
public interface Microsoft.CodeAnalysis.Host.ITemporaryStorageService {
    public abstract virtual ITemporaryStreamStorage CreateTemporaryStreamStorage(CancellationToken cancellationToken);
    public abstract virtual ITemporaryTextStorage CreateTemporaryTextStorage(CancellationToken cancellationToken);
}
public interface Microsoft.CodeAnalysis.Host.ITemporaryStreamStorage {
    public abstract virtual Stream ReadStream(CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(CancellationToken cancellationToken);
    public abstract virtual void WriteStream(Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task WriteStreamAsync(Stream stream, CancellationToken cancellationToken);
}
public interface Microsoft.CodeAnalysis.Host.ITemporaryTextStorage {
    public abstract virtual SourceText ReadText(CancellationToken cancellationToken);
    public abstract virtual Task`1<SourceText> ReadTextAsync(CancellationToken cancellationToken);
    public abstract virtual void WriteText(SourceText text, CancellationToken cancellationToken);
    public abstract virtual Task WriteTextAsync(SourceText text, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Host.ITextFactoryService {
    public abstract virtual SourceText CreateText(Stream stream, Encoding defaultEncoding, CancellationToken cancellationToken);
    public abstract virtual SourceText CreateText(TextReader reader, Encoding encoding, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Host.IWorkspaceCacheService {
    [CompilerGeneratedAttribute]
public abstract virtual void add_CacheFlushRequested(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CacheFlushRequested(EventHandler value);
}
public interface Microsoft.CodeAnalysis.Host.IWorkspaceService {
}
internal interface Microsoft.CodeAnalysis.Host.IWorkspaceTaskScheduler {
    public abstract virtual Task ScheduleTask(Action taskAction, string taskName, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> ScheduleTask(Func`1<T> taskFunc, string taskName, CancellationToken cancellationToken);
    public abstract virtual Task ScheduleTask(Func`1<Task> taskFunc, string taskName, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> ScheduleTask(Func`1<Task`1<T>> taskFunc, string taskName, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Host.IWorkspaceTaskSchedulerFactory {
    public abstract virtual IWorkspaceTaskScheduler CreateTaskScheduler(TaskScheduler taskScheduler);
    public abstract virtual IWorkspaceTaskScheduler CreateTaskQueue(TaskScheduler taskScheduler);
}
internal class Microsoft.CodeAnalysis.Host.Mef.CodeChangeProviderMetadata : OrderableMetadata {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Languages>k__BackingField;
    public IEnumerable`1<string> Languages { get; }
    public CodeChangeProviderMetadata(IDictionary`2<string, object> data);
    public CodeChangeProviderMetadata(string name, IEnumerable`1<string> after, IEnumerable`1<string> before, String[] languages);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_Languages();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    public string ServiceType { get; }
    public string Language { get; }
    public string Layer { get; }
    public ExportLanguageServiceAttribute(Type type, string language, string layer);
    [CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public string get_Layer();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    public string ServiceType { get; }
    public string Language { get; }
    public string Layer { get; }
    public ExportLanguageServiceFactoryAttribute(Type type, string language, string layer);
    [CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public string get_Layer();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    public string ServiceType { get; }
    public string Layer { get; }
    public ExportWorkspaceServiceAttribute(Type serviceType, string layer);
    [CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_Layer();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    public string ServiceType { get; }
    public string Layer { get; }
    public ExportWorkspaceServiceFactoryAttribute(Type serviceType, string layer);
    [CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_Layer();
}
internal interface Microsoft.CodeAnalysis.Host.Mef.ILanguageMetadata {
    public string Language { get; }
    public abstract virtual string get_Language();
}
public interface Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory {
    public abstract virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
internal interface Microsoft.CodeAnalysis.Host.Mef.ILanguagesMetadata {
    public IEnumerable`1<string> Languages { get; }
    public abstract virtual IEnumerable`1<string> get_Languages();
}
internal interface Microsoft.CodeAnalysis.Host.Mef.IMefHostExportProvider {
    public abstract virtual IEnumerable`1<Lazy`2<TExtension, TMetadata>> GetExports();
    public abstract virtual IEnumerable`1<Lazy`1<TExtension>> GetExports();
}
public interface Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory {
    public abstract virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal class Microsoft.CodeAnalysis.Host.Mef.LanguageMetadata : object {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Language { get; }
    public LanguageMetadata(IDictionary`2<string, object> data);
    public LanguageMetadata(string language);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
}
internal class Microsoft.CodeAnalysis.Host.Mef.LanguageServiceMetadata : LanguageMetadata {
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Data>k__BackingField;
    public string ServiceType { get; }
    public string Layer { get; }
    public IReadOnlyDictionary`2<string, object> Data { get; }
    public LanguageServiceMetadata(IDictionary`2<string, object> data);
    [CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_Layer();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Data();
}
public class Microsoft.CodeAnalysis.Host.Mef.MefHostServices : HostServices {
    private CompositionContext _compositionContext;
    private static MefHostServices s_defaultHost;
    private static ImmutableArray`1<Assembly> s_defaultAssemblies;
    public static MefHostServices DefaultHost { get; }
    public static ImmutableArray`1<Assembly> DefaultAssemblies { get; }
    public MefHostServices(CompositionContext compositionContext);
    public static MefHostServices Create(CompositionContext compositionContext);
    public static MefHostServices Create(IEnumerable`1<Assembly> assemblies);
    protected internal virtual HostWorkspaceServices CreateWorkspaceServices(Workspace workspace);
    private sealed virtual override IEnumerable`1<Lazy`1<TExtension>> Microsoft.CodeAnalysis.Host.Mef.IMefHostExportProvider.GetExports();
    private sealed virtual override IEnumerable`1<Lazy`2<TExtension, TMetadata>> Microsoft.CodeAnalysis.Host.Mef.IMefHostExportProvider.GetExports();
    public static MefHostServices get_DefaultHost();
    public static ImmutableArray`1<Assembly> get_DefaultAssemblies();
    private static ImmutableArray`1<Assembly> LoadDefaultAssemblies();
    internal static ImmutableArray`1<Assembly> LoadNearbyAssemblies(String[] assemblyNames);
    private static Assembly TryLoadNearbyAssembly(string assemblySimpleName);
}
internal class Microsoft.CodeAnalysis.Host.Mef.MefLanguageServices : HostLanguageServices {
    private MefWorkspaceServices _workspaceServices;
    private string _language;
    private ImmutableArray`1<Lazy`2<ILanguageService, LanguageServiceMetadata>> _services;
    private ImmutableDictionary`2<Type, Lazy`2<ILanguageService, LanguageServiceMetadata>> _serviceMap;
    public HostWorkspaceServices WorkspaceServices { get; }
    public string Language { get; }
    public bool HasServices { get; }
    public MefLanguageServices(MefWorkspaceServices workspaceServices, string language);
    public virtual HostWorkspaceServices get_WorkspaceServices();
    public virtual string get_Language();
    public bool get_HasServices();
    public virtual TLanguageService GetService();
    internal bool TryGetService(Type serviceType, Lazy`2& service);
    private Lazy`2<ILanguageService, LanguageServiceMetadata> PickLanguageService(IEnumerable`1<Lazy`2<ILanguageService, LanguageServiceMetadata>> services);
    private static bool TryGetServiceByLayer(string layer, IEnumerable`1<Lazy`2<ILanguageService, LanguageServiceMetadata>> services, Lazy`2& service);
    [CompilerGeneratedAttribute]
private Lazy`2<ILanguageService, LanguageServiceMetadata> <.ctor>b__4_0(Lazy`2<ILanguageServiceFactory, LanguageServiceMetadata> lz);
    [CompilerGeneratedAttribute]
private Lazy`2<ILanguageService, LanguageServiceMetadata> <TryGetService>b__12_0(Type svctype);
}
internal class Microsoft.CodeAnalysis.Host.Mef.MefWorkspaceServices : HostWorkspaceServices {
    private IMefHostExportProvider _exportProvider;
    private Workspace _workspace;
    private ImmutableArray`1<Lazy`2<IWorkspaceService, WorkspaceServiceMetadata>> _services;
    private ImmutableDictionary`2<Type, Lazy`2<IWorkspaceService, WorkspaceServiceMetadata>> _serviceMap;
    private ImmutableDictionary`2<string, MefLanguageServices> _languageServicesMap;
    private IEnumerable`1<string> _languages;
    public HostServices HostServices { get; }
    internal IMefHostExportProvider HostExportProvider { get; }
    public Workspace Workspace { get; }
    public IEnumerable`1<string> SupportedLanguages { get; }
    public MefWorkspaceServices(IMefHostExportProvider host, Workspace workspace);
    public virtual HostServices get_HostServices();
    internal IMefHostExportProvider get_HostExportProvider();
    public virtual Workspace get_Workspace();
    public virtual TWorkspaceService GetService();
    private bool TryGetService(Type serviceType, Lazy`2& service);
    private Lazy`2<IWorkspaceService, WorkspaceServiceMetadata> PickWorkspaceService(IEnumerable`1<Lazy`2<IWorkspaceService, WorkspaceServiceMetadata>> services);
    private bool TryGetServiceByLayer(string layer, IEnumerable`1<Lazy`2<IWorkspaceService, WorkspaceServiceMetadata>> services, Lazy`2& service);
    private IEnumerable`1<string> GetSupportedLanguages();
    public virtual IEnumerable`1<string> get_SupportedLanguages();
    public virtual bool IsSupported(string languageName);
    public virtual HostLanguageServices GetLanguageServices(string languageName);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Host.Mef.MefWorkspaceServices/<FindLanguageServices>d__22`1")]
public virtual IEnumerable`1<TLanguageService> FindLanguageServices(MetadataFilter filter);
    [CompilerGeneratedAttribute]
private Lazy`2<IWorkspaceService, WorkspaceServiceMetadata> <.ctor>b__5_0(Lazy`2<IWorkspaceServiceFactory, WorkspaceServiceMetadata> lz);
    [CompilerGeneratedAttribute]
private Lazy`2<IWorkspaceService, WorkspaceServiceMetadata> <TryGetService>b__13_0(Type svctype);
}
internal class Microsoft.CodeAnalysis.Host.Mef.OrderableLanguageMetadata : OrderableMetadata {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Language { get; }
    public OrderableLanguageMetadata(IDictionary`2<string, object> data);
    public OrderableLanguageMetadata(string name, string language, IEnumerable`1<string> after, IEnumerable`1<string> before);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
}
public static class Microsoft.CodeAnalysis.Host.Mef.ServiceLayer : object {
    public static string Host;
    public static string Editor;
    public static string Desktop;
    public static string Default;
}
internal class Microsoft.CodeAnalysis.Host.Mef.WorkspaceServiceMetadata : object {
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    public string ServiceType { get; }
    public string Layer { get; }
    public WorkspaceServiceMetadata(Type serviceType, string layer);
    public WorkspaceServiceMetadata(IDictionary`2<string, object> data);
    public WorkspaceServiceMetadata(string serviceType, string layer);
    [CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_Layer();
}
internal class Microsoft.CodeAnalysis.Host.MetadataReferenceCache : object {
    private ImmutableDictionary`2<string, ReferenceSet> _referenceSets;
    private Func`3<string, MetadataReferenceProperties, MetadataReference> _createReference;
    public MetadataReferenceCache(Func`3<string, MetadataReferenceProperties, MetadataReference> createReference);
    public MetadataReference GetReference(string path, MetadataReferenceProperties properties);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Host.IMetadataService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.MetadataServiceFactory : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal class Microsoft.CodeAnalysis.Host.NoOpPersistentStorage : object {
    public sealed virtual void Dispose();
    public sealed virtual Task`1<Stream> ReadStreamAsync(Document document, string name, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> ReadStreamAsync(Project project, string name, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> ReadStreamAsync(string name, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(Document document, string name, Stream stream, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(Project project, string name, Stream stream, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(string name, Stream stream, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Host.PersistentStorageOptions : object {
    public static string OptionName;
    public static Option`1<bool> Enabled;
    private static PersistentStorageOptions();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.PersistentStorageOptionsProvider : object {
    public sealed virtual IEnumerable`1<IOption> GetOptions();
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Host.IPersistentStorageService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.PersistentStorageServiceFactory : object {
    private IPersistentStorageService _singleton;
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Host.IProjectCacheService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.ProjectCacheServiceFactory : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal abstract class Microsoft.CodeAnalysis.Host.RecoverableWeakValueSource`1 : ValueSource`1<T> {
    private SemaphoreSlim _gateDoNotAccessDirectly;
    private bool _saved;
    private WeakReference`1<T> _weakInstance;
    private ValueSource`1<T> _recoverySource;
    private static WeakReference`1<T> s_noReference;
    private static Task s_latestTask;
    private static NonReentrantLock s_taskGuard;
    private SemaphoreSlim Gate { get; }
    public RecoverableWeakValueSource`1(ValueSource`1<T> initialValue);
    public RecoverableWeakValueSource`1(RecoverableWeakValueSource`1<T> savedSource);
    private static RecoverableWeakValueSource`1();
    protected abstract virtual Task SaveAsync(T instance, CancellationToken cancellationToken);
    protected abstract virtual Task`1<T> RecoverAsync(CancellationToken cancellationToken);
    protected abstract virtual T Recover(CancellationToken cancellationToken);
    private SemaphoreSlim get_Gate();
    public virtual bool TryGetValue(T& value);
    public virtual T GetValue(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Host.RecoverableWeakValueSource`1/<GetValueAsync>d__16")]
public virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
    private void ResetRecoverySource(Task saveTask, T instance);
    private Task EnsureInstanceIsSaved(T instance);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Host.ITextFactoryService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.TextFactoryService : object {
    public sealed virtual SourceText CreateText(Stream stream, Encoding defaultEncoding, CancellationToken cancellationToken);
    public sealed virtual SourceText CreateText(TextReader reader, Encoding encoding, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Host.WorkspaceTaskSchedulerFactory : object {
    public virtual IWorkspaceTaskScheduler CreateTaskScheduler(TaskScheduler taskScheduler);
    public virtual IWorkspaceTaskScheduler CreateTaskQueue(TaskScheduler taskScheduler);
    protected virtual object BeginAsyncOperation(string taskName);
    protected virtual void CompleteAsyncOperation(object asyncToken, Task task);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Host.IWorkspaceTaskSchedulerFactory", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.WorkspaceTaskSchedulerFactoryFactory : object {
    private WorkspaceTaskSchedulerFactory _singleton;
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal class Microsoft.CodeAnalysis.HostBuildData : object {
    internal ParseOptions ParseOptions;
    internal CompilationOptions CompilationOptions;
    internal HostBuildData(ParseOptions parseOptions, CompilationOptions compilationOptions);
}
internal class Microsoft.CodeAnalysis.HostBuildOptions : object {
    [CompilerGeneratedAttribute]
private string <ProjectDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefineConstants>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentationFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LanguageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PlatformWith32BitPreference>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MainEntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleAssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuleSetFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OptionCompare>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OptionStrict>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VBRuntime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowUnsafeBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <CheckForOverflowUnderflow>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Optimize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <WarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <NoWarnings>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <OptionExplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <OptionInfer>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <WarningLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<OutputKind> <OutputKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Tuple`2<bool, bool> <DelaySign>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <GlobalImports>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ReportDiagnostic> <Warnings>k__BackingField;
    public string ProjectDirectory { get; public set; }
    public string OutputDirectory { get; public set; }
    public string DefineConstants { get; public set; }
    public string DocumentationFile { get; public set; }
    public string LanguageVersion { get; public set; }
    public string PlatformWith32BitPreference { get; public set; }
    public string ApplicationConfiguration { get; public set; }
    public string KeyContainer { get; public set; }
    public string KeyFile { get; public set; }
    public string MainEntryPoint { get; public set; }
    public string ModuleAssemblyName { get; public set; }
    public string Platform { get; public set; }
    public string RuleSetFile { get; public set; }
    public string OptionCompare { get; public set; }
    public string OptionStrict { get; public set; }
    public string RootNamespace { get; public set; }
    public string VBRuntime { get; public set; }
    public Nullable`1<bool> AllowUnsafeBlocks { get; public set; }
    public Nullable`1<bool> CheckForOverflowUnderflow { get; public set; }
    public Nullable`1<bool> Optimize { get; public set; }
    public Nullable`1<bool> WarningsAsErrors { get; public set; }
    public Nullable`1<bool> NoWarnings { get; public set; }
    public Nullable`1<bool> OptionExplicit { get; public set; }
    public Nullable`1<bool> OptionInfer { get; public set; }
    public Nullable`1<int> WarningLevel { get; public set; }
    public Nullable`1<OutputKind> OutputKind { get; public set; }
    public Tuple`2<bool, bool> DelaySign { get; public set; }
    public List`1<string> GlobalImports { get; public set; }
    public Dictionary`2<string, ReportDiagnostic> Warnings { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ProjectDirectory();
    [CompilerGeneratedAttribute]
public void set_ProjectDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_OutputDirectory();
    [CompilerGeneratedAttribute]
public void set_OutputDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_DefineConstants();
    [CompilerGeneratedAttribute]
public void set_DefineConstants(string value);
    [CompilerGeneratedAttribute]
public string get_DocumentationFile();
    [CompilerGeneratedAttribute]
public void set_DocumentationFile(string value);
    [CompilerGeneratedAttribute]
public string get_LanguageVersion();
    [CompilerGeneratedAttribute]
public void set_LanguageVersion(string value);
    [CompilerGeneratedAttribute]
public string get_PlatformWith32BitPreference();
    [CompilerGeneratedAttribute]
public void set_PlatformWith32BitPreference(string value);
    [CompilerGeneratedAttribute]
public string get_ApplicationConfiguration();
    [CompilerGeneratedAttribute]
public void set_ApplicationConfiguration(string value);
    [CompilerGeneratedAttribute]
public string get_KeyContainer();
    [CompilerGeneratedAttribute]
public void set_KeyContainer(string value);
    [CompilerGeneratedAttribute]
public string get_KeyFile();
    [CompilerGeneratedAttribute]
public void set_KeyFile(string value);
    [CompilerGeneratedAttribute]
public string get_MainEntryPoint();
    [CompilerGeneratedAttribute]
public void set_MainEntryPoint(string value);
    [CompilerGeneratedAttribute]
public string get_ModuleAssemblyName();
    [CompilerGeneratedAttribute]
public void set_ModuleAssemblyName(string value);
    [CompilerGeneratedAttribute]
public string get_Platform();
    [CompilerGeneratedAttribute]
public void set_Platform(string value);
    [CompilerGeneratedAttribute]
public string get_RuleSetFile();
    [CompilerGeneratedAttribute]
public void set_RuleSetFile(string value);
    [CompilerGeneratedAttribute]
public string get_OptionCompare();
    [CompilerGeneratedAttribute]
public void set_OptionCompare(string value);
    [CompilerGeneratedAttribute]
public string get_OptionStrict();
    [CompilerGeneratedAttribute]
public void set_OptionStrict(string value);
    [CompilerGeneratedAttribute]
public string get_RootNamespace();
    [CompilerGeneratedAttribute]
public void set_RootNamespace(string value);
    [CompilerGeneratedAttribute]
public string get_VBRuntime();
    [CompilerGeneratedAttribute]
public void set_VBRuntime(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AllowUnsafeBlocks();
    [CompilerGeneratedAttribute]
public void set_AllowUnsafeBlocks(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_CheckForOverflowUnderflow();
    [CompilerGeneratedAttribute]
public void set_CheckForOverflowUnderflow(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Optimize();
    [CompilerGeneratedAttribute]
public void set_Optimize(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_WarningsAsErrors();
    [CompilerGeneratedAttribute]
public void set_WarningsAsErrors(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_NoWarnings();
    [CompilerGeneratedAttribute]
public void set_NoWarnings(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_OptionExplicit();
    [CompilerGeneratedAttribute]
public void set_OptionExplicit(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_OptionInfer();
    [CompilerGeneratedAttribute]
public void set_OptionInfer(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_WarningLevel();
    [CompilerGeneratedAttribute]
public void set_WarningLevel(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<OutputKind> get_OutputKind();
    [CompilerGeneratedAttribute]
public void set_OutputKind(Nullable`1<OutputKind> value);
    [CompilerGeneratedAttribute]
public Tuple`2<bool, bool> get_DelaySign();
    [CompilerGeneratedAttribute]
public void set_DelaySign(Tuple`2<bool, bool> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_GlobalImports();
    [CompilerGeneratedAttribute]
public void set_GlobalImports(List`1<string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ReportDiagnostic> get_Warnings();
    [CompilerGeneratedAttribute]
public void set_Warnings(Dictionary`2<string, ReportDiagnostic> value);
}
internal interface Microsoft.CodeAnalysis.IDocumentTextDifferencingService {
    public abstract virtual Task`1<IEnumerable`1<TextChange>> GetTextChangesAsync(Document oldDocument, Document newDocument, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.IHostBuildDataFactory {
    public abstract virtual HostBuildData Create(HostBuildOptions options);
}
internal interface Microsoft.CodeAnalysis.ILinkedFileMergeConflictCommentAdditionService {
}
internal interface Microsoft.CodeAnalysis.IMergeConflictHandler {
    public abstract virtual IEnumerable`1<TextChange> CreateEdits(SourceText originalSourceText, IEnumerable`1<UnmergedDocumentChanges> unmergedChanges);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ImmutableArrayExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutable(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrEmpty(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrNull(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutable(T[] items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrNull(T[] items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrEmpty(T[] items);
    [ExtensionAttribute]
public static ImmutableArray`1<byte> ToImmutable(MemoryStream stream);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`2<TItem, TResult> map);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`3<TItem, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`4<TItem, int, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static ImmutableArray`1<T> WhereAsArray(ImmutableArray`1<T> array, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static ImmutableArray`1<TBase> Cast(ImmutableArray`1<TDerived> items);
    [ExtensionAttribute]
public static bool SetEquals(ImmutableArray`1<T> array1, ImmutableArray`1<T> array2, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static ImmutableArray`1<T> NullToEmpty(ImmutableArray`1<T> array);
    [ExtensionAttribute]
public static ImmutableArray`1<T> Distinct(ImmutableArray`1<T> array, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool HasAnyErrors(ImmutableArray`1<T> diagnostics);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> DeOrder(ImmutableArray`1<T> array);
    [ExtensionAttribute]
internal static ImmutableArray`1<TValue> Flatten(Dictionary`2<TKey, ImmutableArray`1<TValue>> dictionary, IComparer`1<TValue> comparer);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, ImmutableArray`1<T> second);
    [ExtensionAttribute]
internal static bool HasDuplicates(ImmutableArray`1<T> array, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int Count(ImmutableArray`1<T> items, Func`2<T, bool> predicate);
}
internal class Microsoft.CodeAnalysis.Internal.Log.AggregateLogger : object {
    private ImmutableArray`1<ILogger> _loggers;
    private AggregateLogger(ImmutableArray`1<ILogger> loggers);
    public static AggregateLogger Create(ILogger[] loggers);
    public static ILogger AddOrReplace(ILogger newLogger, ILogger oldLogger, Func`2<ILogger, bool> predicate);
    public sealed virtual bool IsEnabled(FunctionId functionId);
    public sealed virtual void Log(FunctionId functionId, LogMessage logMessage);
    public sealed virtual void LogBlockStart(FunctionId functionId, LogMessage logMessage, int uniquePairId, CancellationToken cancellationToken);
    public sealed virtual void LogBlockEnd(FunctionId functionId, LogMessage logMessage, int uniquePairId, int delta, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Internal.Log.EmptyLogBlock : object {
    public static EmptyLogBlock Instance;
    private static EmptyLogBlock();
    public sealed virtual void Dispose();
}
internal class Microsoft.CodeAnalysis.Internal.Log.EmptyLogger : object {
    public static EmptyLogger Instance;
    private static EmptyLogger();
    public sealed virtual bool IsEnabled(FunctionId functionId);
    public sealed virtual void Log(FunctionId functionId, LogMessage logMessage);
    public sealed virtual void LogBlockStart(FunctionId functionId, LogMessage logMessage, int uniquePairId, CancellationToken cancellationToken);
    public sealed virtual void LogBlockEnd(FunctionId functionId, LogMessage logMessage, int uniquePairId, int delta, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.Internal.Log.FunctionId : Enum {
    public int value__;
    public static FunctionId TestEvent_NotUsed;
    public static FunctionId WorkCoordinator_DocumentWorker_Enqueue;
    public static FunctionId WorkCoordinator_ProcessProjectAsync;
    public static FunctionId WorkCoordinator_ProcessDocumentAsync;
    public static FunctionId WorkCoordinator_SemanticChange_Enqueue;
    public static FunctionId WorkCoordinator_SemanticChange_EnqueueFromMember;
    public static FunctionId WorkCoordinator_SemanticChange_EnqueueFromType;
    public static FunctionId WorkCoordinator_SemanticChange_FullProjects;
    public static FunctionId WorkCoordinator_Project_Enqueue;
    public static FunctionId WorkCoordinator_AsyncWorkItemQueue_LastItem;
    public static FunctionId WorkCoordinator_AsyncWorkItemQueue_FirstItem;
    public static FunctionId Diagnostics_SyntaxDiagnostic;
    public static FunctionId Diagnostics_SemanticDiagnostic;
    public static FunctionId Diagnostics_ProjectDiagnostic;
    public static FunctionId Diagnostics_DocumentReset;
    public static FunctionId Diagnostics_DocumentOpen;
    public static FunctionId Diagnostics_RemoveDocument;
    public static FunctionId Diagnostics_RemoveProject;
    public static FunctionId Diagnostics_DocumentClose;
    public static FunctionId Run_Environment;
    public static FunctionId Run_Environment_Options;
    public static FunctionId Tagger_AdornmentManager_OnLayoutChanged;
    public static FunctionId Tagger_AdornmentManager_UpdateInvalidSpans;
    public static FunctionId Tagger_BatchChangeNotifier_NotifyEditorNow;
    public static FunctionId Tagger_BatchChangeNotifier_NotifyEditor;
    public static FunctionId Tagger_TagSource_RecomputeTags;
    public static FunctionId Tagger_TagSource_ProcessNewTags;
    public static FunctionId Tagger_SyntacticClassification_TagComputer_GetTags;
    public static FunctionId Tagger_SemanticClassification_TagProducer_ProduceTags;
    public static FunctionId Tagger_BraceHighlighting_TagProducer_ProduceTags;
    public static FunctionId Tagger_LineSeparator_TagProducer_ProduceTags;
    public static FunctionId Tagger_Outlining_TagProducer_ProduceTags;
    public static FunctionId Tagger_Highlighter_TagProducer_ProduceTags;
    public static FunctionId Tagger_ReferenceHighlighting_TagProducer_ProduceTags;
    public static FunctionId CaseCorrection_CaseCorrect;
    public static FunctionId CaseCorrection_ReplaceTokens;
    public static FunctionId CaseCorrection_AddReplacements;
    public static FunctionId CodeCleanup_CleanupAsync;
    public static FunctionId CodeCleanup_Cleanup;
    public static FunctionId CodeCleanup_IterateAllCodeCleanupProviders;
    public static FunctionId CodeCleanup_IterateOneCodeCleanup;
    public static FunctionId CommandHandler_GetCommandState;
    public static FunctionId CommandHandler_ExecuteHandlers;
    public static FunctionId Workspace_SourceText_GetChangeRanges;
    public static FunctionId Workspace_Recoverable_RecoverRootAsync;
    public static FunctionId Workspace_Recoverable_RecoverRoot;
    public static FunctionId Workspace_Recoverable_RecoverTextAsync;
    public static FunctionId Workspace_Recoverable_RecoverText;
    public static FunctionId Workspace_SkeletonAssembly_GetMetadataOnlyImage;
    public static FunctionId Workspace_SkeletonAssembly_EmitMetadataOnlyImage;
    public static FunctionId Workspace_Document_State_FullyParseSyntaxTree;
    public static FunctionId Workspace_Document_State_IncrementallyParseSyntaxTree;
    public static FunctionId Workspace_Document_GetSemanticModel;
    public static FunctionId Workspace_Document_GetSyntaxTree;
    public static FunctionId Workspace_Document_GetTextChanges;
    public static FunctionId Workspace_Project_GetCompilation;
    public static FunctionId Workspace_Project_CompilationTracker_BuildCompilationAsync;
    public static FunctionId Workspace_ApplyChanges;
    public static FunctionId Workspace_TryGetDocument;
    public static FunctionId Workspace_TryGetDocumentFromInProgressSolution;
    public static FunctionId Workspace_Solution_LinkedFileDiffMergingSession;
    public static FunctionId Workspace_Solution_LinkedFileDiffMergingSession_LinkedFileGroup;
    public static FunctionId EndConstruct_DoStatement;
    public static FunctionId EndConstruct_XmlCData;
    public static FunctionId EndConstruct_XmlComment;
    public static FunctionId EndConstruct_XmlElement;
    public static FunctionId EndConstruct_XmlEmbeddedExpression;
    public static FunctionId EndConstruct_XmlProcessingInstruction;
    public static FunctionId FindReference_Rename;
    public static FunctionId FindReference_ChangeSignature;
    public static FunctionId FindReference;
    public static FunctionId FindReference_DetermineAllSymbolsAsync;
    public static FunctionId FindReference_CreateProjectMapAsync;
    public static FunctionId FindReference_CreateDocumentMapAsync;
    public static FunctionId FindReference_ProcessAsync;
    public static FunctionId FindReference_ProcessProjectAsync;
    public static FunctionId FindReference_ProcessDocumentAsync;
    public static FunctionId LineCommit_CommitRegion;
    public static FunctionId Formatting_TokenStreamConstruction;
    public static FunctionId Formatting_ContextInitialization;
    public static FunctionId Formatting_Format;
    public static FunctionId Formatting_ApplyResultToBuffer;
    public static FunctionId Formatting_IterateNodes;
    public static FunctionId Formatting_CollectIndentBlock;
    public static FunctionId Formatting_CollectSuppressOperation;
    public static FunctionId Formatting_CollectAlignOperation;
    public static FunctionId Formatting_CollectAnchorOperation;
    public static FunctionId Formatting_CollectTokenOperation;
    public static FunctionId Formatting_BuildContext;
    public static FunctionId Formatting_ApplySpaceAndLine;
    public static FunctionId Formatting_ApplyAnchorOperation;
    public static FunctionId Formatting_ApplyAlignOperation;
    public static FunctionId Formatting_AggregateCreateTextChanges;
    public static FunctionId Formatting_AggregateCreateFormattedRoot;
    public static FunctionId Formatting_CreateTextChanges;
    public static FunctionId Formatting_CreateFormattedRoot;
    public static FunctionId SmartIndentation_Start;
    public static FunctionId SmartIndentation_OpenCurly;
    public static FunctionId SmartIndentation_CloseCurly;
    public static FunctionId Rename_InlineSession;
    public static FunctionId Rename_InlineSession_Session;
    public static FunctionId Rename_FindLinkedSpans;
    public static FunctionId Rename_GetSymbolRenameInfo;
    public static FunctionId Rename_OnTextBufferChanged;
    public static FunctionId Rename_ApplyReplacementText;
    public static FunctionId Rename_CommitCore;
    public static FunctionId Rename_CommitCoreWithPreview;
    public static FunctionId Rename_GetAsynchronousLocationsSource;
    public static FunctionId Rename_AllRenameLocations;
    public static FunctionId Rename_StartSearchingForSpansInAllOpenDocuments;
    public static FunctionId Rename_StartSearchingForSpansInOpenDocument;
    public static FunctionId Rename_CreateOpenTextBufferManagerForAllOpenDocs;
    public static FunctionId Rename_CreateOpenTextBufferManagerForAllOpenDocument;
    public static FunctionId Rename_ReportSpan;
    public static FunctionId Rename_GetNoChangeConflictResolution;
    public static FunctionId Rename_Tracking_BufferChanged;
    public static FunctionId TPLTask_TaskScheduled;
    public static FunctionId TPLTask_TaskStarted;
    public static FunctionId TPLTask_TaskCompleted;
    public static FunctionId QuickInfo_ModelComputation_ComputeModelInBackground;
    public static FunctionId Completion_ModelComputer_DoInBackground;
    public static FunctionId Completion_ModelComputation_FilterModelInBackground;
    public static FunctionId Completion_ModelComputation_WaitForModel;
    public static FunctionId Completion_SymbolCompletionProvider_GetItemsWorker;
    public static FunctionId Completion_KeywordCompletionProvider_GetItemsWorker;
    public static FunctionId Completion_SnippetCompletionProvider_GetItemsWorker_CSharp;
    public static FunctionId SignatureHelp_ModelComputation_ComputeModelInBackground;
    public static FunctionId SignatureHelp_ModelComputation_UpdateModelInBackground;
    public static FunctionId Refactoring_CodeRefactoringService_GetRefactoringsAsync;
    public static FunctionId Refactoring_AddImport;
    public static FunctionId Refactoring_FullyQualify;
    public static FunctionId Refactoring_GenerateFromMembers_AddConstructorParameters;
    public static FunctionId Refactoring_GenerateFromMembers_GenerateConstructor;
    public static FunctionId Refactoring_GenerateFromMembers_GenerateEqualsAndGetHashCode;
    public static FunctionId Refactoring_GenerateMember_GenerateConstructor;
    public static FunctionId Refactoring_GenerateMember_GenerateDefaultConstructors;
    public static FunctionId Refactoring_GenerateMember_GenerateEnumMember;
    public static FunctionId Refactoring_GenerateMember_GenerateMethod;
    public static FunctionId Refactoring_GenerateMember_GenerateVariable;
    public static FunctionId Refactoring_ImplementAbstractClass;
    public static FunctionId Refactoring_ImplementInterface;
    public static FunctionId Refactoring_IntroduceVariable;
    public static FunctionId Refactoring_GenerateType;
    public static FunctionId Refactoring_RemoveUnnecessaryImports_CSharp;
    public static FunctionId Refactoring_RemoveUnnecessaryImports_VisualBasic;
    public static FunctionId Snippet_OnBeforeInsertion;
    public static FunctionId Snippet_OnAfterInsertion;
    public static FunctionId Misc_NonReentrantLock_BlockingWait;
    public static FunctionId Misc_VisualStudioWaitIndicator_Wait;
    public static FunctionId Misc_SaveEventsSink_OnBeforeSave;
    public static FunctionId TaskList_Refresh;
    public static FunctionId TaskList_NavigateTo;
    public static FunctionId WinformDesigner_GenerateXML;
    public static FunctionId NavigateTo_Search;
    public static FunctionId NavigationService_VSDocumentNavigationService_NavigateTo;
    public static FunctionId NavigationBar_ComputeModelAsync;
    public static FunctionId NavigationBar_ItemService_GetMembersInTypes_CSharp;
    public static FunctionId NavigationBar_ItemService_GetTypesInFile_CSharp;
    public static FunctionId NavigationBar_UpdateDropDownsSynchronously_WaitForModel;
    public static FunctionId NavigationBar_UpdateDropDownsSynchronously_WaitForSelectedItemInfo;
    public static FunctionId EventHookup_Determine_If_Event_Hookup;
    public static FunctionId EventHookup_Generate_Handler;
    public static FunctionId EventHookup_Type_Char;
    public static FunctionId Cache_Created;
    public static FunctionId Cache_AddOrAccess;
    public static FunctionId Cache_Remove;
    public static FunctionId Cache_Evict;
    public static FunctionId Cache_EvictAll;
    public static FunctionId Cache_ItemRank;
    public static FunctionId TextStructureNavigator_GetExtentOfWord;
    public static FunctionId TextStructureNavigator_GetSpanOfEnclosing;
    public static FunctionId TextStructureNavigator_GetSpanOfFirstChild;
    public static FunctionId TextStructureNavigator_GetSpanOfNextSibling;
    public static FunctionId TextStructureNavigator_GetSpanOfPreviousSibling;
    public static FunctionId Debugging_LanguageDebugInfoService_GetDataTipSpanAndText;
    public static FunctionId Debugging_VsLanguageDebugInfo_ValidateBreakpointLocation;
    public static FunctionId Debugging_VsLanguageDebugInfo_GetProximityExpressions;
    public static FunctionId Debugging_VsLanguageDebugInfo_ResolveName;
    public static FunctionId Debugging_VsLanguageDebugInfo_GetNameOfLocation;
    public static FunctionId Debugging_VsLanguageDebugInfo_GetDataTipText;
    public static FunctionId Debugging_EncSession;
    public static FunctionId Debugging_EncSession_EditSession;
    public static FunctionId Debugging_EncSession_EditSession_EmitDeltaErrorId;
    public static FunctionId Debugging_EncSession_EditSession_RudeEdit;
    public static FunctionId Simplifier_ReduceAsync;
    public static FunctionId Simplifier_ExpandNode;
    public static FunctionId Simplifier_ExpandToken;
    public static FunctionId ForegroundNotificationService_Processed;
    public static FunctionId ForegroundNotificationService_NotifyOnForeground;
    public static FunctionId BackgroundCompiler_BuildCompilationsAsync;
    public static FunctionId PersistenceService_ReadAsync;
    public static FunctionId PersistenceService_WriteAsync;
    public static FunctionId PersistenceService_ReadAsyncFailed;
    public static FunctionId PersistenceService_WriteAsyncFailed;
    public static FunctionId PersistenceService_Initialization;
    public static FunctionId TemporaryStorageServiceFactory_ReadText;
    public static FunctionId TemporaryStorageServiceFactory_WriteText;
    public static FunctionId TemporaryStorageServiceFactory_ReadStream;
    public static FunctionId TemporaryStorageServiceFactory_WriteStream;
    public static FunctionId SmartTags_RefreshSession;
    public static FunctionId SmartTags_SmartTagInitializeFixes;
    public static FunctionId SmartTags_ApplyQuickFix;
    public static FunctionId EditorTestApp_RefreshTask;
    public static FunctionId EditorTestApp_UpdateDiagnostics;
    public static FunctionId IncrementalAnalyzerProcessor_Analyzers;
    public static FunctionId IncrementalAnalyzerProcessor_Analyzer;
    public static FunctionId IncrementalAnalyzerProcessor_ActiveFileAnalyzers;
    public static FunctionId IncrementalAnalyzerProcessor_ActiveFileAnalyzer;
    public static FunctionId IncrementalAnalyzerProcessor_Shutdown;
    public static FunctionId WorkCoordinatorRegistrationService_Register;
    public static FunctionId WorkCoordinatorRegistrationService_Unregister;
    public static FunctionId WorkCoordinatorRegistrationService_Reanalyze;
    public static FunctionId WorkCoordinator_SolutionCrawlerOption;
    public static FunctionId WorkCoordinator_PersistentStorageAdded;
    public static FunctionId WorkCoordinator_PersistentStorageRemoved;
    public static FunctionId WorkCoordinator_Shutdown;
    public static FunctionId DiagnosticAnalyzerService_Analyzers;
    public static FunctionId DiagnosticAnalyzerDriver_AnalyzerCrash;
    public static FunctionId DiagnosticAnalyzerDriver_AnalyzerTypeCount;
    public static FunctionId PersistedSemanticVersion_Info;
    public static FunctionId Esent_Exceptions;
    public static FunctionId WorkCoordinator_ShutdownTimeout;
    public static FunctionId Diagnostics_HyperLink;
    public static FunctionId CodeFixes_FixAllOccurrencesSession;
    public static FunctionId CodeFixes_FixAllOccurrencesContext;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Diagnostics;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Fixes;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Merge;
    public static FunctionId CodeFixes_FixAllOccurrencesPreviewChanges;
    public static FunctionId SolutionExplorer_AnalyzerItemSource_GetItems;
    public static FunctionId SolutionExplorer_DiagnosticItemSource_GetItems;
    public static FunctionId WorkCoordinator_ActivieFileEnqueue;
    public static FunctionId SymbolFinder_FindDeclarationsAsync;
    public static FunctionId SymbolFinder_Project_AddDeclarationsAsync;
    public static FunctionId SymbolFinder_Assembly_AddDeclarationsAsync;
    public static FunctionId SymbolFinder_Solution_Name_FindSourceDeclarationsAsync;
    public static FunctionId SymbolFinder_Project_Name_FindSourceDeclarationsAsync;
    public static FunctionId SymbolFinder_Solution_Predicate_FindSourceDeclarationsAsync;
    public static FunctionId SymbolFinder_Project_Predicate_FindSourceDeclarationsAsync;
    public static FunctionId Tagger_Diagnostics_RecomputeTags;
    public static FunctionId Tagger_Diagnostics_Updated;
    public static FunctionId SuggestedActions_HasSuggestedActionsAsync;
    public static FunctionId SuggestedActions_GetSuggestedActions;
    public static FunctionId AnalyzerDependencyCheckingService_LogConflict;
    public static FunctionId AnalyzerDependencyCheckingService_LogMissingDependency;
    public static FunctionId VirtualMemory_MemoryLow;
    public static FunctionId Extension_Exception;
    public static FunctionId WorkCoordinator_WaitForHigherPriorityOperationsAsync;
}
internal static class Microsoft.CodeAnalysis.Internal.Log.FunctionIdOptions : object {
    private static string FeatureName;
    private static ConcurrentDictionary`2<FunctionId, Option`1<bool>> s_options;
    private static Func`2<FunctionId, Option`1<bool>> s_optionGetter;
    private static FunctionIdOptions();
    public static Option`1<bool> GetOption(FunctionId id);
    private static bool GetDefaultValue(FunctionId id);
}
internal interface Microsoft.CodeAnalysis.Internal.Log.ILogger {
    public abstract virtual bool IsEnabled(FunctionId functionId);
    public abstract virtual void Log(FunctionId functionId, LogMessage logMessage);
    public abstract virtual void LogBlockStart(FunctionId functionId, LogMessage logMessage, int uniquePairId, CancellationToken cancellationToken);
    public abstract virtual void LogBlockEnd(FunctionId functionId, LogMessage logMessage, int uniquePairId, int delta, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.Internal.Log.InteractionClass : Enum {
    public int value__;
    public static InteractionClass Undefined;
    public static InteractionClass Instant;
    public static InteractionClass Fast;
    public static InteractionClass Typical;
    public static InteractionClass Responsive;
    public static InteractionClass Captive;
    public static InteractionClass Extended;
}
internal class Microsoft.CodeAnalysis.Internal.Log.KeyValueLogMessage : LogMessage {
    private static ObjectPool`1<KeyValueLogMessage> s_pool;
    private Dictionary`2<string, object> _map;
    private Action`1<Dictionary`2<string, object>> _propertySetter;
    public bool ContainsProperty { get; }
    public IEnumerable`1<KeyValuePair`2<string, object>> Properties { get; }
    private static KeyValueLogMessage();
    public static KeyValueLogMessage Create(Action`1<Dictionary`2<string, object>> propertySetter);
    private void Constrcut(Action`1<Dictionary`2<string, object>> propertySetter);
    public bool get_ContainsProperty();
    public IEnumerable`1<KeyValuePair`2<string, object>> get_Properties();
    protected virtual string CreateMessage();
    protected virtual void FreeCore();
    private void EnsureMap();
}
internal class Microsoft.CodeAnalysis.Internal.Log.LogAggregator : object {
    private static int s_globalId;
    private ConcurrentDictionary`2<object, Counter> _map;
    public static int GetNextId();
    public static StatisticResult GetStatistics(List`1<int> values);
    public void SetCount(object key, int count);
    public void IncreaseCount(object key);
    public int GetCount(object key);
    public int GetAverage(string key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<object, Counter>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private Counter GetCounter(object key);
}
internal static class Microsoft.CodeAnalysis.Internal.Log.Logger : object {
    private static ObjectPool`1<RoslynLogBlock> s_pool;
    private static ILogger s_currentLogger;
    private static int s_lastUniqueBlockId;
    private static Logger();
    private static IDisposable CreateLogBlock(FunctionId functionId, LogMessage message, int blockId, CancellationToken cancellationToken);
    public static ILogger SetLogger(ILogger logger);
    public static ILogger GetLogger();
    public static void Log(FunctionId functionId, string message);
    public static void Log(FunctionId functionId, Func`1<string> messageGetter);
    public static void Log(FunctionId functionId, Func`2<TArg, string> messageGetter, TArg arg);
    public static void Log(FunctionId functionId, Func`3<TArg0, TArg1, string> messageGetter, TArg0 arg0, TArg1 arg1);
    public static void Log(FunctionId functionId, Func`4<TArg0, TArg1, TArg2, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2);
    public static void Log(FunctionId functionId, Func`5<TArg0, TArg1, TArg2, TArg3, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3);
    public static void Log(FunctionId functionId, LogMessage logMessage);
    private static int GetNextUniqueBlockId();
    public static IDisposable LogBlock(FunctionId functionId, CancellationToken token);
    public static IDisposable LogBlock(FunctionId functionId, string message, CancellationToken token);
    public static IDisposable LogBlock(FunctionId functionId, Func`1<string> messageGetter, CancellationToken token);
    public static IDisposable LogBlock(FunctionId functionId, Func`2<TArg, string> messageGetter, TArg arg, CancellationToken token);
    public static IDisposable LogBlock(FunctionId functionId, Func`3<TArg0, TArg1, string> messageGetter, TArg0 arg0, TArg1 arg1, CancellationToken token);
    public static IDisposable LogBlock(FunctionId functionId, Func`4<TArg0, TArg1, TArg2, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, CancellationToken token);
    public static IDisposable LogBlock(FunctionId functionId, Func`5<TArg0, TArg1, TArg2, TArg3, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3, CancellationToken token);
    public static IDisposable LogBlock(FunctionId functionId, LogMessage logMessage, CancellationToken token);
    public static Func`2<FunctionId, bool> GetLoggingChecker(IOptionService optionService);
}
internal abstract class Microsoft.CodeAnalysis.Internal.Log.LogMessage : object {
    private string _message;
    public static LogMessage Create(string message);
    public static LogMessage Create(Func`1<string> messageGetter);
    public static LogMessage Create(Func`2<TArg, string> messageGetter, TArg arg);
    public static LogMessage Create(Func`3<TArg0, TArg1, string> messageGetter, TArg0 arg0, TArg1 arg1);
    public static LogMessage Create(Func`4<TArg0, TArg1, TArg2, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2);
    public static LogMessage Create(Func`5<TArg0, TArg1, TArg2, TArg3, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3);
    protected abstract virtual string CreateMessage();
    protected abstract virtual void FreeCore();
    public string GetMessage();
    public void Free();
}
[AttributeUsageAttribute("256")]
internal class Microsoft.CodeAnalysis.Internal.Log.PerfGoalAttribute : Attribute {
    private InteractionClass _interactionClass;
    public InteractionClass InteractionClass { get; }
    public PerfGoalAttribute(InteractionClass interactionClass);
    public InteractionClass get_InteractionClass();
}
internal interface Microsoft.CodeAnalysis.IOrderableMetadata {
    public IEnumerable`1<string> After { get; }
    public IEnumerable`1<string> Before { get; }
    public string Name { get; }
    public abstract virtual IEnumerable`1<string> get_After();
    public abstract virtual IEnumerable`1<string> get_Before();
    public abstract virtual string get_Name();
}
internal interface Microsoft.CodeAnalysis.ITextVersionable {
    public abstract virtual bool TryGetTextVersion(VersionStamp& version);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.LanguageServices.DisplayNameOptions : Enum {
    public int value__;
    public static DisplayNameOptions None;
    public static DisplayNameOptions IncludeMemberKeyword;
    public static DisplayNameOptions IncludeNamespaces;
    public static DisplayNameOptions IncludeParameters;
    public static DisplayNameOptions IncludeType;
    public static DisplayNameOptions IncludeTypeParameters;
}
internal class Microsoft.CodeAnalysis.LanguageServices.ExternalSourceInfo : ValueType {
    public Nullable`1<int> StartLine;
    public bool Ends;
    public ExternalSourceInfo(Nullable`1<int> startLine, bool ends);
}
internal class Microsoft.CodeAnalysis.LanguageServices.ForEachSymbols : ValueType {
    public IMethodSymbol GetEnumeratorMethod;
    public IMethodSymbol MoveNextMethod;
    public IPropertySymbol CurrentProperty;
    public IMethodSymbol DisposeMethod;
    public ITypeSymbol ElementType;
    internal ForEachSymbols(IMethodSymbol getEnumeratorMethod, IMethodSymbol moveNextMethod, IPropertySymbol currentProperty, IMethodSymbol disposeMethod, ITypeSymbol elementType);
}
internal interface Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService {
    public bool SupportsImplicitInterfaceImplementation { get; }
    public bool SupportsParameterizedProperties { get; }
    public bool ExposesAnonymousFunctionParameterNames { get; }
    public bool SupportsParameterizedEvents { get; }
    public abstract virtual bool get_SupportsImplicitInterfaceImplementation();
    public abstract virtual bool get_SupportsParameterizedProperties();
    public abstract virtual bool get_ExposesAnonymousFunctionParameterNames();
    public abstract virtual bool IsExpressionContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsStatementContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsTypeContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsNamespaceContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsTypeDeclarationContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsMemberDeclarationContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsPreProcessorDirectiveContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsGlobalStatementContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsLabelContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsAttributeNameContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsNameOfContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool IsOnlyWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool IsInOutContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool IsInRefContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool CanReplaceWithRValue(SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    public abstract virtual string GenerateNameForExpression(SemanticModel semanticModel, SyntaxNode expression, bool capitalize);
    public abstract virtual ISymbol GetDeclaredSymbol(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    public abstract virtual bool LastEnumValueHasInitializer(INamedTypeSymbol namedTypeSymbol);
    public abstract virtual bool get_SupportsParameterizedEvents();
    public abstract virtual bool TryGetSpeculativeSemanticModel(SemanticModel oldSemanticModel, SyntaxNode oldNode, SyntaxNode newNode, SemanticModel& speculativeModel);
    public abstract virtual ImmutableHashSet`1<string> GetAliasNameSet(SemanticModel model, CancellationToken cancellationToken);
    public abstract virtual ForEachSymbols GetForEachSymbols(SemanticModel semanticModel, SyntaxNode forEachStatement);
    public abstract virtual bool IsAssignableTo(ITypeSymbol fromSymbol, ITypeSymbol toSymbol, Compilation compilation);
}
internal interface Microsoft.CodeAnalysis.LanguageServices.ISymbolDeclarationService {
    public abstract virtual IEnumerable`1<SyntaxReference> GetDeclarations(ISymbol symbol);
}
internal interface Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService {
    public bool IsCaseSensitive { get; }
    public abstract virtual bool get_IsCaseSensitive();
    public abstract virtual bool IsAwaitKeyword(SyntaxToken token);
    public abstract virtual bool IsIdentifier(SyntaxToken token);
    public abstract virtual bool IsGlobalNamespaceKeyword(SyntaxToken token);
    public abstract virtual bool IsVerbatimIdentifier(SyntaxToken token);
    public abstract virtual bool IsOperator(SyntaxToken token);
    public abstract virtual bool IsPredefinedType(SyntaxToken token);
    public abstract virtual bool IsPredefinedType(SyntaxToken token, PredefinedType type);
    public abstract virtual bool IsPredefinedOperator(SyntaxToken token);
    public abstract virtual bool IsPredefinedOperator(SyntaxToken token, PredefinedOperator op);
    public abstract virtual bool IsKeyword(SyntaxToken token);
    public abstract virtual bool IsContextualKeyword(SyntaxToken token);
    public abstract virtual bool IsPreprocessorKeyword(SyntaxToken token);
    public abstract virtual bool IsHashToken(SyntaxToken token);
    public abstract virtual bool IsLiteral(SyntaxToken token);
    public abstract virtual bool IsStringLiteral(SyntaxToken token);
    public abstract virtual bool IsTypeNamedVarInVariableOrFieldDeclaration(SyntaxToken token, SyntaxNode parent);
    public abstract virtual bool IsTypeNamedDynamic(SyntaxToken token, SyntaxNode parent);
    public abstract virtual string GetText(int kind);
    public abstract virtual bool IsInInactiveRegion(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsInNonUserCode(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsEntirelyWithinStringOrCharOrNumericLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public abstract virtual bool TryGetPredefinedType(SyntaxToken token, PredefinedType& type);
    public abstract virtual bool TryGetPredefinedOperator(SyntaxToken token, PredefinedOperator& op);
    public abstract virtual bool TryGetExternalSourceInfo(SyntaxNode directive, ExternalSourceInfo& info);
    public abstract virtual bool IsObjectCreationExpressionType(SyntaxNode node);
    public abstract virtual bool IsObjectCreationExpression(SyntaxNode node);
    public abstract virtual bool IsInvocationExpression(SyntaxNode node);
    public abstract virtual bool IsRightSideOfQualifiedName(SyntaxNode node);
    public abstract virtual bool IsMemberAccessExpressionName(SyntaxNode node);
    public abstract virtual bool IsMemberAccessExpression(SyntaxNode node);
    public abstract virtual bool IsPointerMemberAccessExpression(SyntaxNode node);
    public abstract virtual bool IsNamedParameter(SyntaxNode node);
    public abstract virtual bool IsSkippedTokensTrivia(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfMemberAccessExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfConditionalMemberAccessExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfArgument(SyntaxNode node);
    public abstract virtual bool IsConditionalMemberAccessExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetNameOfAttribute(SyntaxNode node);
    public abstract virtual SyntaxToken GetIdentifierOfGenericName(SyntaxNode node);
    public abstract virtual RefKind GetRefKindOfArgument(SyntaxNode node);
    public abstract virtual void GetNameAndArityOfSimpleName(SyntaxNode node, String& name, Int32& arity);
    public abstract virtual bool IsUsingDirectiveName(SyntaxNode node);
    public abstract virtual bool IsGenericName(SyntaxNode node);
    public abstract virtual bool IsAttribute(SyntaxNode node);
    public abstract virtual bool IsAttributeName(SyntaxNode node);
    public abstract virtual bool IsAttributeNamedArgumentIdentifier(SyntaxNode node);
    public abstract virtual bool IsObjectInitializerNamedAssignmentIdentifier(SyntaxNode node);
    public abstract virtual bool IsDirective(SyntaxNode node);
    public abstract virtual bool IsForEachStatement(SyntaxNode node);
    public abstract virtual bool IsLockStatement(SyntaxNode node);
    public abstract virtual bool IsUsingStatement(SyntaxNode node);
    public abstract virtual bool IsThisConstructorInitializer(SyntaxToken token);
    public abstract virtual bool IsBaseConstructorInitializer(SyntaxToken token);
    public abstract virtual bool IsQueryExpression(SyntaxNode node);
    public abstract virtual bool IsElementAccessExpression(SyntaxNode node);
    public abstract virtual bool IsIndexerMemberCRef(SyntaxNode node);
    public abstract virtual bool IsIdentifierStartCharacter(char c);
    public abstract virtual bool IsIdentifierPartCharacter(char c);
    public abstract virtual bool IsIdentifierEscapeCharacter(char c);
    public abstract virtual bool IsStartOfUnicodeEscapeSequence(char c);
    public abstract virtual bool IsValidIdentifier(string identifier);
    public abstract virtual bool IsVerbatimIdentifier(string identifier);
    public abstract virtual bool IsTypeCharacter(char c);
    public abstract virtual bool IsBindableToken(SyntaxToken token);
    public abstract virtual bool IsInStaticContext(SyntaxNode node);
    public abstract virtual bool IsUnsafeContext(SyntaxNode node);
    public abstract virtual bool IsInNamespaceOrTypeContext(SyntaxNode node);
    public abstract virtual bool IsAnonymousFunction(SyntaxNode n);
    public abstract virtual bool IsInConstantContext(SyntaxNode node);
    public abstract virtual bool IsInConstructor(SyntaxNode node);
    public abstract virtual bool IsMethodLevelMember(SyntaxNode node);
    public abstract virtual bool IsTopLevelNodeWithMembers(SyntaxNode node);
    public abstract virtual bool HasIncompleteParentMember(SyntaxNode node);
    public abstract virtual bool TryGetDeclaredSymbolInfo(SyntaxNode node, DeclaredSymbolInfo& declaredSymbolInfo);
    public abstract virtual string GetDisplayName(SyntaxNode node, DisplayNameOptions options, string rootNamespace);
    public abstract virtual SyntaxNode GetContainingTypeDeclaration(SyntaxNode root, int position);
    public abstract virtual SyntaxNode GetContainingMemberDeclaration(SyntaxNode root, int position, bool useFullSpan);
    public abstract virtual SyntaxNode GetContainingVariableDeclaratorOfFieldDeclaration(SyntaxNode node);
    public abstract virtual SyntaxToken FindTokenOnLeftOfPosition(SyntaxNode node, int position, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    public abstract virtual SyntaxToken FindTokenOnRightOfPosition(SyntaxNode node, int position, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    public abstract virtual SyntaxNode Parenthesize(SyntaxNode expression, bool includeElasticTrivia);
    public abstract virtual SyntaxNode ConvertToSingleLine(SyntaxNode node);
    public abstract virtual SyntaxToken ToIdentifierToken(string name);
    public abstract virtual List`1<SyntaxNode> GetMethodLevelMembers(SyntaxNode root);
    public abstract virtual bool ContainsInMemberBody(SyntaxNode node, TextSpan span);
    public abstract virtual int GetMethodLevelMemberId(SyntaxNode root, SyntaxNode node);
    public abstract virtual SyntaxNode GetMethodLevelMember(SyntaxNode root, int memberId);
    public abstract virtual TextSpan GetMemberBodySpanForSpeculativeBinding(SyntaxNode node);
    public abstract virtual SyntaxNode GetBindableParent(SyntaxToken token);
    public abstract virtual IEnumerable`1<SyntaxNode> GetConstructors(SyntaxNode root, CancellationToken cancellationToken);
    public abstract virtual bool TryGetCorrespondingOpenBrace(SyntaxToken token, SyntaxToken& openBrace);
}
internal interface Microsoft.CodeAnalysis.LanguageServices.ITypeInferenceService {
    public abstract virtual IEnumerable`1<ITypeSymbol> InferTypes(SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<ITypeSymbol> InferTypes(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.LanguageServices.PredefinedOperator : Enum {
    public int value__;
    public static PredefinedOperator None;
    public static PredefinedOperator Addition;
    public static PredefinedOperator BitwiseAnd;
    public static PredefinedOperator BitwiseOr;
    public static PredefinedOperator Complement;
    public static PredefinedOperator Concatenate;
    public static PredefinedOperator Decrement;
    public static PredefinedOperator Division;
    public static PredefinedOperator Equality;
    public static PredefinedOperator ExclusiveOr;
    public static PredefinedOperator Exponent;
    public static PredefinedOperator GreaterThan;
    public static PredefinedOperator GreaterThanOrEqual;
    public static PredefinedOperator Increment;
    public static PredefinedOperator Inequality;
    public static PredefinedOperator IntegerDivision;
    public static PredefinedOperator LeftShift;
    public static PredefinedOperator LessThan;
    public static PredefinedOperator LessThanOrEqual;
    public static PredefinedOperator Like;
    public static PredefinedOperator Modulus;
    public static PredefinedOperator Multiplication;
    public static PredefinedOperator RightShift;
    public static PredefinedOperator Subtraction;
}
internal enum Microsoft.CodeAnalysis.LanguageServices.PredefinedType : Enum {
    public int value__;
    public static PredefinedType None;
    public static PredefinedType Boolean;
    public static PredefinedType Byte;
    public static PredefinedType Char;
    public static PredefinedType DateTime;
    public static PredefinedType Decimal;
    public static PredefinedType Double;
    public static PredefinedType Int16;
    public static PredefinedType Int32;
    public static PredefinedType Int64;
    public static PredefinedType Object;
    public static PredefinedType SByte;
    public static PredefinedType Single;
    public static PredefinedType String;
    public static PredefinedType UInt16;
    public static PredefinedType UInt32;
    public static PredefinedType UInt64;
    public static PredefinedType Void;
}
internal class Microsoft.CodeAnalysis.LinkedFileDiffMergingSession : object {
    private bool _logSessionInfo;
    private Solution _oldSolution;
    private Solution _newSolution;
    private SolutionChanges _solutionChanges;
    public LinkedFileDiffMergingSession(Solution oldSolution, Solution newSolution, SolutionChanges solutionChanges, bool logSessionInfo);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.LinkedFileDiffMergingSession/<MergeDiffsAsync>d__5")]
internal Task`1<LinkedFileMergeSessionResult> MergeDiffsAsync(IMergeConflictHandler mergeConflictHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.LinkedFileDiffMergingSession/<MergeLinkedDocumentGroupAsync>d__6")]
private Task`1<LinkedFileMergeResult> MergeLinkedDocumentGroupAsync(IEnumerable`1<DocumentId> allLinkedDocuments, IEnumerable`1<DocumentId> linkedDocumentGroup, LinkedFileDiffMergingSessionInfo sessionInfo, IMergeConflictHandler mergeConflictHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.LinkedFileDiffMergingSession/<AddDocumentMergeChangesAsync>d__7")]
private static Task`1<IEnumerable`1<TextChange>> AddDocumentMergeChangesAsync(Document oldDocument, Document newDocument, List`1<TextChange> cumulativeChanges, List`1<UnmergedDocumentChanges> unmergedChanges, LinkedFileGroupSessionInfo groupSessionInfo, IDocumentTextDifferencingService textDiffService, CancellationToken cancellationToken);
    private IEnumerable`1<TextChange> MergeChangesWithMergeFailComments(IEnumerable`1<TextChange> mergedChanges, IEnumerable`1<TextChange> commentChanges, IList`1<TextSpan> mergeConflictResolutionSpans, LinkedFileGroupSessionInfo groupSessionInfo);
    private IEnumerable`1<TextChange> NormalizeChanges(IEnumerable`1<TextChange> changes);
    private void LogLinkedFileDiffMergingSessionInfo(LinkedFileDiffMergingSessionInfo sessionInfo);
    [CompilerGeneratedAttribute]
private string <MergeDiffsAsync>b__5_1(DocumentId d);
}
internal class Microsoft.CodeAnalysis.LinkedFileMergeResult : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<DocumentId> <DocumentIds>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceText <MergedSourceText>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TextSpan> <MergeConflictResolutionSpans>k__BackingField;
    public IEnumerable`1<DocumentId> DocumentIds { get; internal set; }
    public SourceText MergedSourceText { get; internal set; }
    public IEnumerable`1<TextSpan> MergeConflictResolutionSpans { get; }
    public bool HasMergeConflicts { get; }
    public LinkedFileMergeResult(IEnumerable`1<DocumentId> documentIds, SourceText mergedSourceText, IEnumerable`1<TextSpan> mergeConflictResolutionSpans);
    [CompilerGeneratedAttribute]
public IEnumerable`1<DocumentId> get_DocumentIds();
    [CompilerGeneratedAttribute]
internal void set_DocumentIds(IEnumerable`1<DocumentId> value);
    [CompilerGeneratedAttribute]
public SourceText get_MergedSourceText();
    [CompilerGeneratedAttribute]
internal void set_MergedSourceText(SourceText value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<TextSpan> get_MergeConflictResolutionSpans();
    public bool get_HasMergeConflicts();
}
internal class Microsoft.CodeAnalysis.LinkedFileMergeSessionResult : object {
    [CompilerGeneratedAttribute]
private Solution <MergedSolution>k__BackingField;
    private Dictionary`2<DocumentId, IEnumerable`1<TextSpan>> _mergeConflictCommentSpans;
    public Solution MergedSolution { get; }
    public Dictionary`2<DocumentId, IEnumerable`1<TextSpan>> MergeConflictCommentSpans { get; }
    public LinkedFileMergeSessionResult(Solution mergedSolution, IEnumerable`1<LinkedFileMergeResult> fileMergeResults);
    [CompilerGeneratedAttribute]
public Solution get_MergedSolution();
    public Dictionary`2<DocumentId, IEnumerable`1<TextSpan>> get_MergeConflictCommentSpans();
}
internal class Microsoft.CodeAnalysis.MetadataFileReferenceProvider : object {
    public static MetadataFileReferenceProvider Default;
    private static MetadataFileReferenceProvider();
    public virtual PortableExecutableReference GetReference(string path, MetadataReferenceProperties properties);
}
internal class Microsoft.CodeAnalysis.MetadataFileReferenceResolver : object {
    public static MetadataFileReferenceResolver Default;
    private ImmutableArray`1<string> _searchPaths;
    private string _baseDirectory;
    public ImmutableArray`1<string> SearchPaths { get; }
    public string BaseDirectory { get; }
    public MetadataFileReferenceResolver(ImmutableArray`1<string> searchPaths, string baseDirectory);
    public MetadataFileReferenceResolver(IEnumerable`1<string> searchPaths, string baseDirectory);
    private static MetadataFileReferenceResolver();
    internal static void ValidateSearchPaths(ImmutableArray`1<string> paths, string argName);
    public ImmutableArray`1<string> get_SearchPaths();
    public string get_BaseDirectory();
    public virtual string ResolveReference(string reference, string baseFilePath);
    internal string ResolveReferenceChecked(string reference, string baseFilePath);
    protected virtual bool FileExists(string fullPath);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.MetadataOnlyImage : object {
    public static MetadataOnlyImage Empty;
    private static EmitOptions s_emitOptions;
    private ITemporaryStreamStorage _storage;
    private string _assemblyName;
    private static ConditionalWeakTable`2<MetadataReference, Stream> s_lifetime;
    public bool IsEmpty { get; }
    private MetadataOnlyImage(ITemporaryStreamStorage storage, string assemblyName);
    private static MetadataOnlyImage();
    public bool get_IsEmpty();
    public static MetadataOnlyImage Create(ITemporaryStorageService service, Compilation compilation, CancellationToken cancellationToken);
    public MetadataReference CreateReference(ImmutableArray`1<string> aliases, bool embedInteropTypes, DocumentationProvider documentationProvider);
    public void Cleanup();
}
internal class Microsoft.CodeAnalysis.MetadataOnlyReference : object {
    private static ConditionalWeakTable`2<BranchId, ConditionalWeakTable`2<ProjectId, MetadataOnlyReferenceSet>> s_cache;
    private static ConditionalWeakTable`2<Compilation, MetadataOnlyReferenceSet> s_snapshotCache;
    private static CreateValueCallback<BranchId, ConditionalWeakTable`2<ProjectId, MetadataOnlyReferenceSet>> s_createReferenceSetMap;
    private static MetadataOnlyReference();
    internal static MetadataReference GetOrBuildReference(Solution solution, ProjectReference projectReference, Compilation finalCompilation, VersionStamp version, CancellationToken cancellationToken);
    internal static bool TryGetReference(Solution solution, ProjectReference projectReference, Compilation finalOrDeclarationCompilation, VersionStamp version, MetadataReference& reference);
    private static bool TryGetReferenceFromBranch(BranchId branchId, ProjectReference projectReference, Compilation finalOrDeclarationCompilation, VersionStamp version, MetadataReference& reference);
}
internal class Microsoft.CodeAnalysis.MetadataReferenceManager : object {
    private static ConditionalWeakTable`2<ProjectState, WeakReference`1<Compilation>> s_compilationReferenceMap;
    private static CreateValueCallback<ProjectState, WeakReference`1<Compilation>> s_createValue;
    private static object s_guard;
    private static MetadataReferenceManager();
    internal static Compilation GetCompilationForMetadataReference(ProjectState projectState, Compilation compilation);
    internal static bool TryGetCompilationForMetadataReference(ProjectState projectState, Compilation& referenceCompilation);
}
internal abstract class Microsoft.CodeAnalysis.Notification.AbstractGlobalOperationNotificationService : object {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Started(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Started(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Stopped(EventHandler`1<GlobalOperationEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Stopped(EventHandler`1<GlobalOperationEventArgs> value);
    public abstract virtual GlobalOperationRegistration Start(string reason);
    public abstract virtual void Cancel(GlobalOperationRegistration registration);
    public abstract virtual void Done(GlobalOperationRegistration registration);
}
internal class Microsoft.CodeAnalysis.Notification.GlobalOperationEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Operations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Cancelled>k__BackingField;
    public IReadOnlyList`1<string> Operations { get; }
    public bool Cancelled { get; }
    public GlobalOperationEventArgs(IReadOnlyList`1<string> operations, bool cancelled);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Operations();
    [CompilerGeneratedAttribute]
public bool get_Cancelled();
}
internal class Microsoft.CodeAnalysis.Notification.GlobalOperationNotificationService : AbstractGlobalOperationNotificationService {
    private static string GlobalOperationStartedEventName;
    private static string GlobalOperationStoppedEventName;
    private object _gate;
    private HashSet`1<GlobalOperationRegistration> _registrations;
    private HashSet`1<string> _operations;
    private SimpleTaskQueue _eventQueue;
    private EventMap _eventMap;
    public virtual GlobalOperationRegistration Start(string operation);
    protected virtual Task RaiseGlobalOperationStarted();
    protected virtual Task RaiseGlobalOperationStopped(IReadOnlyList`1<string> operations, bool cancelled);
    public virtual void add_Started(EventHandler value);
    public virtual void remove_Started(EventHandler value);
    public virtual void add_Stopped(EventHandler`1<GlobalOperationEventArgs> value);
    public virtual void remove_Stopped(EventHandler`1<GlobalOperationEventArgs> value);
    public virtual void Cancel(GlobalOperationRegistration registration);
    public virtual void Done(GlobalOperationRegistration registration);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
private void <RaiseGlobalOperationStarted>b__9_1(EventHandler handler);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Notification.IGlobalOperationNotificationService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Notification.GlobalOperationNotificationServiceFactory : object {
    private static NoOpService s_singleton;
    private static GlobalOperationNotificationServiceFactory();
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal class Microsoft.CodeAnalysis.Notification.GlobalOperationRegistration : object {
    private AbstractGlobalOperationNotificationService _service;
    private bool _done;
    [CompilerGeneratedAttribute]
private string <Operation>k__BackingField;
    public string Operation { get; }
    public GlobalOperationRegistration(AbstractGlobalOperationNotificationService service, string operation);
    [CompilerGeneratedAttribute]
public string get_Operation();
    public void Done();
    public sealed virtual void Dispose();
}
internal interface Microsoft.CodeAnalysis.Notification.IGlobalOperationNotificationService {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Started(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Started(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Stopped(EventHandler`1<GlobalOperationEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Stopped(EventHandler`1<GlobalOperationEventArgs> value);
    public abstract virtual GlobalOperationRegistration Start(string operation);
}
public interface Microsoft.CodeAnalysis.Options.IOption {
    public string Feature { get; }
    public string Name { get; }
    public Type Type { get; }
    public object DefaultValue { get; }
    public bool IsPerLanguage { get; }
    public abstract virtual string get_Feature();
    public abstract virtual string get_Name();
    public abstract virtual Type get_Type();
    public abstract virtual object get_DefaultValue();
    public abstract virtual bool get_IsPerLanguage();
}
internal interface Microsoft.CodeAnalysis.Options.IOptionService {
    public abstract virtual T GetOption(Option`1<T> option);
    public abstract virtual T GetOption(PerLanguageOption`1<T> option, string languageName);
    public abstract virtual object GetOption(OptionKey optionKey);
    public abstract virtual OptionSet GetOptions();
    public abstract virtual void SetOptions(OptionSet optionSet);
    public abstract virtual IEnumerable`1<IOption> GetRegisteredOptions();
    [CompilerGeneratedAttribute]
public abstract virtual void add_OptionChanged(EventHandler`1<OptionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OptionChanged(EventHandler`1<OptionChangedEventArgs> value);
}
public class Microsoft.CodeAnalysis.Options.Option`1 : object {
    [CompilerGeneratedAttribute]
private string <Feature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private T <DefaultValue>k__BackingField;
    public string Feature { get; }
    public string Name { get; }
    public Type Type { get; }
    public T DefaultValue { get; }
    private Type Microsoft.CodeAnalysis.Options.IOption.Type { get; }
    private object Microsoft.CodeAnalysis.Options.IOption.DefaultValue { get; }
    private bool Microsoft.CodeAnalysis.Options.IOption.IsPerLanguage { get; }
    public Option`1(string feature, string name, T defaultValue);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Feature();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public Type get_Type();
    [CompilerGeneratedAttribute]
public T get_DefaultValue();
    private sealed virtual override Type Microsoft.CodeAnalysis.Options.IOption.get_Type();
    private sealed virtual override object Microsoft.CodeAnalysis.Options.IOption.get_DefaultValue();
    private sealed virtual override bool Microsoft.CodeAnalysis.Options.IOption.get_IsPerLanguage();
    public virtual string ToString();
    public static OptionKey op_Implicit(Option`1<T> option);
}
internal class Microsoft.CodeAnalysis.Options.OptionChangedEventArgs : EventArgs {
    private OptionKey _optionKey;
    private object _value;
    public IOption Option { get; }
    public string Language { get; }
    public object Value { get; }
    internal OptionChangedEventArgs(OptionKey optionKey, object value);
    public IOption get_Option();
    public string get_Language();
    public object get_Value();
}
public class Microsoft.CodeAnalysis.Options.OptionKey : ValueType {
    [CompilerGeneratedAttribute]
private IOption <Option>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public IOption Option { get; }
    public string Language { get; }
    public OptionKey(IOption option, string language);
    [CompilerGeneratedAttribute]
public IOption get_Option();
    [CompilerGeneratedAttribute]
public string get_Language();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OptionKey other);
    public virtual int GetHashCode();
    public static bool op_Equality(OptionKey left, OptionKey right);
    public static bool op_Inequality(OptionKey left, OptionKey right);
}
[ExportAttribute("Microsoft.CodeAnalysis.Options.IOptionService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Options.OptionService : object {
    private Lazy`1<HashSet`1<IOption>> _options;
    private ImmutableDictionary`2<string, ImmutableArray`1<Lazy`2<IOptionSerializer, OptionSerializerMetadata>>> _featureNameToOptionSerializers;
    private object _gate;
    private ImmutableDictionary`2<OptionKey, object> _currentValues;
    [CompilerGeneratedAttribute]
private EventHandler`1<OptionChangedEventArgs> OptionChanged;
    [ImportingConstructorAttribute]
public OptionService(IEnumerable`1<Lazy`1<IOptionProvider>> optionProviders, IEnumerable`1<Lazy`2<IOptionSerializer, OptionSerializerMetadata>> optionSerializers);
    private object LoadOptionFromSerializerOrGetDefault(OptionKey optionKey);
    public sealed virtual IEnumerable`1<IOption> GetRegisteredOptions();
    public sealed virtual OptionSet GetOptions();
    public sealed virtual T GetOption(Option`1<T> option);
    public sealed virtual T GetOption(PerLanguageOption`1<T> option, string language);
    public sealed virtual object GetOption(OptionKey optionKey);
    public sealed virtual void SetOptions(OptionSet optionSet);
    private static bool SupportedSerializer(OptionKey optionKey, OptionSerializerMetadata metadata);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OptionChanged(EventHandler`1<OptionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OptionChanged(EventHandler`1<OptionChangedEventArgs> value);
}
public class Microsoft.CodeAnalysis.Options.OptionSet : object {
    private IOptionService _service;
    private object _gate;
    private ImmutableDictionary`2<OptionKey, object> _values;
    internal OptionSet(IOptionService service);
    private OptionSet(IOptionService service, ImmutableDictionary`2<OptionKey, object> values);
    public T GetOption(Option`1<T> option);
    public T GetOption(PerLanguageOption`1<T> option, string language);
    public object GetOption(OptionKey optionKey);
    public OptionSet WithChangedOption(Option`1<T> option, T value);
    public OptionSet WithChangedOption(PerLanguageOption`1<T> option, string language, T value);
    public OptionSet WithChangedOption(OptionKey optionAndLanguage, object value);
    internal IEnumerable`1<OptionKey> GetAccessedOptions();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Options.OptionSet/<GetChangedOptions>d__12")]
internal IEnumerable`1<OptionKey> GetChangedOptions(OptionSet optionSet);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Options.IOptionService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Options.OptionsServiceFactory : object {
    private IOptionService _optionService;
    [ImportingConstructorAttribute]
public OptionsServiceFactory(IOptionService optionService);
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
public class Microsoft.CodeAnalysis.Options.PerLanguageOption`1 : object {
    [CompilerGeneratedAttribute]
private string <Feature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private T <DefaultValue>k__BackingField;
    public string Feature { get; }
    public string Name { get; }
    public Type Type { get; }
    public T DefaultValue { get; }
    private Type Microsoft.CodeAnalysis.Options.IOption.Type { get; }
    private object Microsoft.CodeAnalysis.Options.IOption.DefaultValue { get; }
    private bool Microsoft.CodeAnalysis.Options.IOption.IsPerLanguage { get; }
    public PerLanguageOption`1(string feature, string name, T defaultValue);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Feature();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public Type get_Type();
    [CompilerGeneratedAttribute]
public T get_DefaultValue();
    private sealed virtual override Type Microsoft.CodeAnalysis.Options.IOption.get_Type();
    private sealed virtual override object Microsoft.CodeAnalysis.Options.IOption.get_DefaultValue();
    private sealed virtual override bool Microsoft.CodeAnalysis.Options.IOption.get_IsPerLanguage();
    public virtual string ToString();
}
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.Options.Providers.ExportOptionProviderAttribute : ExportAttribute {
}
internal interface Microsoft.CodeAnalysis.Options.Providers.IOptionProvider {
    public abstract virtual IEnumerable`1<IOption> GetOptions();
}
internal interface Microsoft.CodeAnalysis.Options.Providers.IOptionSerializer {
    public abstract virtual bool TryFetch(OptionKey optionKey, Object& value);
    public abstract virtual bool TryPersist(OptionKey optionKey, object value);
}
internal class Microsoft.CodeAnalysis.Options.Providers.OptionSerializerMetadata : LanguageMetadata {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Features>k__BackingField;
    public IEnumerable`1<string> Features { get; }
    public OptionSerializerMetadata(IDictionary`2<string, object> data);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Features();
}
internal class Microsoft.CodeAnalysis.OrderableMetadata : object {
    [CompilerGeneratedAttribute]
private object <After>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Before>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <AfterTyped>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <BeforeTyped>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public object After { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public object Before { get; }
    internal IEnumerable`1<string> AfterTyped { get; internal set; }
    internal IEnumerable`1<string> BeforeTyped { get; internal set; }
    public string Name { get; }
    private IEnumerable`1<string> Microsoft.CodeAnalysis.IOrderableMetadata.After { get; }
    private IEnumerable`1<string> Microsoft.CodeAnalysis.IOrderableMetadata.Before { get; }
    public OrderableMetadata(IDictionary`2<string, object> data);
    public OrderableMetadata(string name, IEnumerable`1<string> after, IEnumerable`1<string> before);
    [CompilerGeneratedAttribute]
public object get_After();
    [CompilerGeneratedAttribute]
public object get_Before();
    [CompilerGeneratedAttribute]
internal IEnumerable`1<string> get_AfterTyped();
    [CompilerGeneratedAttribute]
internal void set_AfterTyped(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
internal IEnumerable`1<string> get_BeforeTyped();
    [CompilerGeneratedAttribute]
internal void set_BeforeTyped(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    private sealed virtual override IEnumerable`1<string> Microsoft.CodeAnalysis.IOrderableMetadata.get_After();
    private sealed virtual override IEnumerable`1<string> Microsoft.CodeAnalysis.IOrderableMetadata.get_Before();
}
public enum Microsoft.CodeAnalysis.PreservationMode : Enum {
    public int value__;
    public static PreservationMode PreserveValue;
    public static PreservationMode PreserveIdentity;
}
internal static class Microsoft.CodeAnalysis.PrimaryWorkspace : object {
    private static ReaderWriterLockSlim s_registryGate;
    private static Workspace s_primaryWorkspace;
    private static List`1<TaskCompletionSource`1<Workspace>> s_primaryWorkspaceTaskSourceList;
    public static Workspace Workspace { get; }
    private static PrimaryWorkspace();
    public static Workspace get_Workspace();
    public static void Register(Workspace workspace);
    public static Task`1<Workspace> GetWorkspaceAsync(CancellationToken cancellationToken);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.Project : object {
    private Solution _solution;
    private ProjectState _projectState;
    private ImmutableHashMap`2<DocumentId, Document> _idToDocumentMap;
    private ImmutableHashMap`2<DocumentId, TextDocument> _idToAdditionalDocumentMap;
    private static Func`3<DocumentId, Project, Document> s_createDocumentFunction;
    private static Func`3<DocumentId, Project, TextDocument> s_createAdditionalDocumentFunction;
    internal ProjectState State { get; }
    public Solution Solution { get; }
    public ProjectId Id { get; }
    public string FilePath { get; }
    public string OutputFilePath { get; }
    public bool SupportsCompilation { get; }
    public HostLanguageServices LanguageServices { get; }
    public string Language { get; }
    public string AssemblyName { get; }
    public string Name { get; }
    public IReadOnlyList`1<MetadataReference> MetadataReferences { get; }
    public IEnumerable`1<ProjectReference> ProjectReferences { get; }
    public IReadOnlyList`1<ProjectReference> AllProjectReferences { get; }
    public IReadOnlyList`1<AnalyzerReference> AnalyzerReferences { get; }
    public AnalyzerOptions AnalyzerOptions { get; }
    public CompilationOptions CompilationOptions { get; }
    public ParseOptions ParseOptions { get; }
    internal bool IsSubmission { get; }
    public bool HasDocuments { get; }
    public IReadOnlyList`1<DocumentId> DocumentIds { get; }
    public IReadOnlyList`1<DocumentId> AdditionalDocumentIds { get; }
    public IEnumerable`1<Document> Documents { get; }
    public IEnumerable`1<TextDocument> AdditionalDocuments { get; }
    public VersionStamp Version { get; }
    internal Project(Solution solution, ProjectState projectState);
    private static Project();
    internal ProjectState get_State();
    public Solution get_Solution();
    public ProjectId get_Id();
    public string get_FilePath();
    public string get_OutputFilePath();
    public bool get_SupportsCompilation();
    public HostLanguageServices get_LanguageServices();
    public string get_Language();
    public string get_AssemblyName();
    public string get_Name();
    public IReadOnlyList`1<MetadataReference> get_MetadataReferences();
    public IEnumerable`1<ProjectReference> get_ProjectReferences();
    public IReadOnlyList`1<ProjectReference> get_AllProjectReferences();
    public IReadOnlyList`1<AnalyzerReference> get_AnalyzerReferences();
    public AnalyzerOptions get_AnalyzerOptions();
    public CompilationOptions get_CompilationOptions();
    public ParseOptions get_ParseOptions();
    internal bool get_IsSubmission();
    public bool get_HasDocuments();
    public IReadOnlyList`1<DocumentId> get_DocumentIds();
    public IReadOnlyList`1<DocumentId> get_AdditionalDocumentIds();
    public IEnumerable`1<Document> get_Documents();
    public IEnumerable`1<TextDocument> get_AdditionalDocuments();
    public bool ContainsDocument(DocumentId documentId);
    public bool ContainsAdditionalDocument(DocumentId documentId);
    public DocumentId GetDocumentId(SyntaxTree syntaxTree);
    public Document GetDocument(SyntaxTree syntaxTree);
    public Document GetDocument(DocumentId documentId);
    public TextDocument GetAdditionalDocument(DocumentId documentId);
    internal DocumentState GetDocumentState(DocumentId documentId);
    internal TextDocumentState GetAdditionalDocumentState(DocumentId documentId);
    internal Task`1<bool> ContainsSymbolsWithNameAsync(Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    internal Task`1<IEnumerable`1<Document>> GetDocumentsWithName(Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    private static Document CreateDocument(DocumentId documentId, Project project);
    private static TextDocument CreateAdditionalDocument(DocumentId documentId, Project project);
    public bool TryGetCompilation(Compilation& compilation);
    public Task`1<Compilation> GetCompilationAsync(CancellationToken cancellationToken);
    public ProjectChanges GetChanges(Project oldProject);
    private void CheckContainsDocument(DocumentId documentId);
    public VersionStamp get_Version();
    public Task`1<VersionStamp> GetLatestDocumentVersionAsync(CancellationToken cancellationToken);
    public Task`1<VersionStamp> GetDependentVersionAsync(CancellationToken cancellationToken);
    public Task`1<VersionStamp> GetDependentSemanticVersionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Project/<GetSemanticVersionAsync>d__74")]
public Task`1<VersionStamp> GetSemanticVersionAsync(CancellationToken cancellationToken);
    public Project WithAssemblyName(string assemblyName);
    public Project WithCompilationOptions(CompilationOptions options);
    public Project WithParseOptions(ParseOptions options);
    public Project AddProjectReference(ProjectReference projectReference);
    public Project AddProjectReferences(IEnumerable`1<ProjectReference> projectReferences);
    public Project RemoveProjectReference(ProjectReference projectReference);
    public Project WithProjectReferences(IEnumerable`1<ProjectReference> projectReferences);
    public Project AddMetadataReference(MetadataReference metadataReference);
    public Project AddMetadataReferences(IEnumerable`1<MetadataReference> metadataReferences);
    public Project RemoveMetadataReference(MetadataReference metadataReference);
    public Project WithMetadataReferences(IEnumerable`1<MetadataReference> metadataReferences);
    public Project AddAnalyzerReference(AnalyzerReference analyzerReference);
    public Project AddAnalyzerReferences(IEnumerable`1<AnalyzerReference> analyzerReferences);
    public Project RemoveAnalyzerReference(AnalyzerReference analyzerReference);
    public Project WithAnalyzerReferences(IEnumerable`1<AnalyzerReference> analyzerReferencs);
    public Document AddDocument(string name, SyntaxNode syntaxRoot, IEnumerable`1<string> folders, string filePath);
    public Document AddDocument(string name, SourceText text, IEnumerable`1<string> folders, string filePath);
    public Document AddDocument(string name, string text, IEnumerable`1<string> folders, string filePath);
    public TextDocument AddAdditionalDocument(string name, SourceText text, IEnumerable`1<string> folders, string filePath);
    public TextDocument AddAdditionalDocument(string name, string text, IEnumerable`1<string> folders, string filePath);
    public Project RemoveDocument(DocumentId documentId);
    public Project RemoveAdditionalDocument(DocumentId documentId);
    private string GetDebuggerDisplay();
    [CompilerGeneratedAttribute]
private bool <get_ProjectReferences>b__28_0(ProjectReference pr);
}
public class Microsoft.CodeAnalysis.ProjectChanges : ValueType {
    private Project _newProject;
    private Project _oldProject;
    public ProjectId ProjectId { get; }
    public Project OldProject { get; }
    public Project NewProject { get; }
    internal ProjectChanges(Project newProject, Project oldProject);
    public ProjectId get_ProjectId();
    public Project get_OldProject();
    public Project get_NewProject();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetAddedProjectReferences>d__9")]
public IEnumerable`1<ProjectReference> GetAddedProjectReferences();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetRemovedProjectReferences>d__10")]
public IEnumerable`1<ProjectReference> GetRemovedProjectReferences();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetAddedMetadataReferences>d__11")]
public IEnumerable`1<MetadataReference> GetAddedMetadataReferences();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetRemovedMetadataReferences>d__12")]
public IEnumerable`1<MetadataReference> GetRemovedMetadataReferences();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetAddedAnalyzerReferences>d__13")]
public IEnumerable`1<AnalyzerReference> GetAddedAnalyzerReferences();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetRemovedAnalyzerReferences>d__14")]
public IEnumerable`1<AnalyzerReference> GetRemovedAnalyzerReferences();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetAddedDocuments>d__15")]
public IEnumerable`1<DocumentId> GetAddedDocuments();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetAddedAdditionalDocuments>d__16")]
public IEnumerable`1<DocumentId> GetAddedAdditionalDocuments();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetChangedDocuments>d__17")]
public IEnumerable`1<DocumentId> GetChangedDocuments();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetChangedAdditionalDocuments>d__18")]
public IEnumerable`1<DocumentId> GetChangedAdditionalDocuments();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetRemovedDocuments>d__19")]
public IEnumerable`1<DocumentId> GetRemovedDocuments();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetRemovedAdditionalDocuments>d__20")]
public IEnumerable`1<DocumentId> GetRemovedAdditionalDocuments();
}
public class Microsoft.CodeAnalysis.ProjectDependencyGraph : object {
    private ImmutableArray`1<ProjectId> _projectIds;
    private ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> _referencesMap;
    private NonReentrantLock _dataLock;
    private ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> _lazyReverseReferencesMap;
    private ImmutableArray`1<ProjectId> _lazyTopologicallySortedProjects;
    private ImmutableArray`1<IEnumerable`1<ProjectId>> _lazyDependencySets;
    private ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> _transitiveReferencesMap;
    private ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> _reverseTransitiveReferencesMap;
    internal static ProjectDependencyGraph Empty;
    internal ProjectDependencyGraph(ImmutableArray`1<ProjectId> projectIds, ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> referencesMap);
    private static ProjectDependencyGraph();
    public IImmutableSet`1<ProjectId> GetProjectsThatThisProjectDirectlyDependsOn(ProjectId projectId);
    public IImmutableSet`1<ProjectId> GetProjectsThatDirectlyDependOnThisProject(ProjectId projectId);
    private ImmutableHashSet`1<ProjectId> GetProjectsThatDirectlyDependOnThisProject_NoLock(ProjectId projectId);
    private ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> ComputeReverseReferencesMap();
    public IImmutableSet`1<ProjectId> GetProjectsThatThisProjectTransitivelyDependsOn(ProjectId projectId);
    private ImmutableHashSet`1<ProjectId> GetProjectsThatThisProjectTransitivelyDependsOn_NoLock(ProjectId projectId);
    private void ComputeTransitiveReferences(ProjectId project, HashSet`1<ProjectId> result);
    public IEnumerable`1<ProjectId> GetProjectsThatTransitivelyDependOnThisProject(ProjectId projectId);
    private ImmutableHashSet`1<ProjectId> GetProjectsThatTransitivelyDependOnThisProject_NoLock(ProjectId projectId);
    private void ComputeReverseTransitiveReferences(ProjectId project, HashSet`1<ProjectId> results);
    public IEnumerable`1<ProjectId> GetTopologicallySortedProjects(CancellationToken cancellationToken);
    private IEnumerable`1<ProjectId> GetTopologicallySortedProjects_NoLock(CancellationToken cancellationToken);
    private void TopologicalSort(IEnumerable`1<ProjectId> projectIds, HashSet`1<ProjectId> seenProjects, List`1<ProjectId> resultList, CancellationToken cancellationToken);
    public IEnumerable`1<IEnumerable`1<ProjectId>> GetDependencySets(CancellationToken cancellationToken);
    private IEnumerable`1<IEnumerable`1<ProjectId>> GetDependencySets_NoLock(CancellationToken cancellationToken);
    private void ComputeDependencySets(HashSet`1<ProjectId> seenProjects, List`1<IEnumerable`1<ProjectId>> results, CancellationToken cancellationToken);
    private void ComputedDependencySet(ProjectId project, HashSet`1<ProjectId> result);
}
public class Microsoft.CodeAnalysis.ProjectDiagnostic : WorkspaceDiagnostic {
    [CompilerGeneratedAttribute]
private ProjectId <ProjectId>k__BackingField;
    public ProjectId ProjectId { get; }
    public ProjectDiagnostic(WorkspaceDiagnosticKind kind, string message, ProjectId projectId);
    [CompilerGeneratedAttribute]
public ProjectId get_ProjectId();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.ProjectId : object {
    private string _debugName;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    public Guid Id { get; }
    internal string DebugName { get; }
    private ProjectId(string debugName);
    internal ProjectId(Guid guid, string debugName);
    [CompilerGeneratedAttribute]
public Guid get_Id();
    public static ProjectId CreateNewId(string debugName);
    public static ProjectId CreateFromSerialized(Guid id, string debugName);
    private string GetDebuggerDisplay();
    internal string get_DebugName();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProjectId other);
    public static bool op_Equality(ProjectId left, ProjectId right);
    public static bool op_Inequality(ProjectId left, ProjectId right);
    public virtual int GetHashCode();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.ProjectInfo : object {
    [CompilerGeneratedAttribute]
private ProjectId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionStamp <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private CompilationOptions <CompilationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ParseOptions <ParseOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<DocumentInfo> <Documents>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ProjectReference> <ProjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<MetadataReference> <MetadataReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<AnalyzerReference> <AnalyzerReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<DocumentInfo> <AdditionalDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSubmission>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <HostObjectType>k__BackingField;
    public ProjectId Id { get; }
    public VersionStamp Version { get; }
    public string Name { get; }
    public string AssemblyName { get; }
    public string Language { get; }
    public string FilePath { get; }
    public string OutputFilePath { get; }
    public CompilationOptions CompilationOptions { get; }
    public ParseOptions ParseOptions { get; }
    public IReadOnlyList`1<DocumentInfo> Documents { get; }
    public IReadOnlyList`1<ProjectReference> ProjectReferences { get; }
    public IReadOnlyList`1<MetadataReference> MetadataReferences { get; }
    public IReadOnlyList`1<AnalyzerReference> AnalyzerReferences { get; }
    public IReadOnlyList`1<DocumentInfo> AdditionalDocuments { get; }
    public bool IsSubmission { get; }
    public Type HostObjectType { get; }
    private ProjectInfo(ProjectId id, VersionStamp version, string name, string assemblyName, string language, string filePath, string outputFilePath, CompilationOptions compilationOptions, ParseOptions parseOptions, IEnumerable`1<DocumentInfo> documents, IEnumerable`1<ProjectReference> projectReferences, IEnumerable`1<MetadataReference> metadataReferences, IEnumerable`1<AnalyzerReference> analyzerReferences, IEnumerable`1<DocumentInfo> additionalDocuments, bool isSubmission, Type hostObjectType);
    [CompilerGeneratedAttribute]
public ProjectId get_Id();
    [CompilerGeneratedAttribute]
public VersionStamp get_Version();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public string get_OutputFilePath();
    [CompilerGeneratedAttribute]
public CompilationOptions get_CompilationOptions();
    [CompilerGeneratedAttribute]
public ParseOptions get_ParseOptions();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<DocumentInfo> get_Documents();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ProjectReference> get_ProjectReferences();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<MetadataReference> get_MetadataReferences();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<AnalyzerReference> get_AnalyzerReferences();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<DocumentInfo> get_AdditionalDocuments();
    [CompilerGeneratedAttribute]
public bool get_IsSubmission();
    [CompilerGeneratedAttribute]
public Type get_HostObjectType();
    public static ProjectInfo Create(ProjectId id, VersionStamp version, string name, string assemblyName, string language, string filePath, string outputFilePath, CompilationOptions compilationOptions, ParseOptions parseOptions, IEnumerable`1<DocumentInfo> documents, IEnumerable`1<ProjectReference> projectReferences, IEnumerable`1<MetadataReference> metadataReferences, IEnumerable`1<AnalyzerReference> analyzerReferences, IEnumerable`1<DocumentInfo> additionalDocuments, bool isSubmission, Type hostObjectType);
    private ProjectInfo With(ProjectId id, Nullable`1<VersionStamp> version, string name, string assemblyName, string language, Optional`1<string> filePath, Optional`1<string> outputPath, CompilationOptions compilationOptions, ParseOptions parseOptions, IEnumerable`1<DocumentInfo> documents, IEnumerable`1<ProjectReference> projectReferences, IEnumerable`1<MetadataReference> metadataReferences, IEnumerable`1<AnalyzerReference> analyzerReferences, IEnumerable`1<DocumentInfo> additionalDocuments, Optional`1<bool> isSubmission, Optional`1<Type> hostObjectType);
    public ProjectInfo WithDocuments(IEnumerable`1<DocumentInfo> documents);
    public ProjectInfo WithAdditionalDocuments(IEnumerable`1<DocumentInfo> additionalDocuments);
    public ProjectInfo WithVersion(VersionStamp version);
    public ProjectInfo WithName(string name);
    public ProjectInfo WithFilePath(string filePath);
    public ProjectInfo WithAssemblyName(string assemblyName);
    public ProjectInfo WithOutputFilePath(string outputFilePath);
    public ProjectInfo WithCompilationOptions(CompilationOptions compilationOptions);
    public ProjectInfo WithParseOptions(ParseOptions parseOptions);
    public ProjectInfo WithProjectReferences(IEnumerable`1<ProjectReference> projectReferences);
    public ProjectInfo WithMetadataReferences(IEnumerable`1<MetadataReference> metadataReferences);
    public ProjectInfo WithAnalyzerReferences(IEnumerable`1<AnalyzerReference> analyzerReferences);
    internal string GetDebuggerDisplay();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.ProjectReference : object {
    private ProjectId _projectId;
    private ImmutableArray`1<string> _aliases;
    private bool _embedInteropTypes;
    public ProjectId ProjectId { get; }
    public ImmutableArray`1<string> Aliases { get; }
    public bool EmbedInteropTypes { get; }
    public ProjectReference(ProjectId projectId, ImmutableArray`1<string> aliases, bool embedInteropTypes);
    public ProjectId get_ProjectId();
    public ImmutableArray`1<string> get_Aliases();
    public bool get_EmbedInteropTypes();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProjectReference reference);
    public static bool op_Equality(ProjectReference left, ProjectReference right);
    public static bool op_Inequality(ProjectReference left, ProjectReference right);
    public virtual int GetHashCode();
    private string GetDebuggerDisplay();
}
internal class Microsoft.CodeAnalysis.ProjectState : object {
    private ProjectInfo _projectInfo;
    private HostLanguageServices _languageServices;
    private SolutionServices _solutionServices;
    private ImmutableDictionary`2<DocumentId, DocumentState> _documentStates;
    private ImmutableDictionary`2<DocumentId, TextDocumentState> _additionalDocumentStates;
    private IReadOnlyList`1<DocumentId> _documentIds;
    private IReadOnlyList`1<DocumentId> _additionalDocumentIds;
    private AsyncLazy`1<VersionStamp> _lazyLatestDocumentVersion;
    private AsyncLazy`1<VersionStamp> _lazyLatestDocumentTopLevelChangeVersion;
    private AnalyzerOptions _analyzerOptions;
    public ProjectId Id { get; }
    public string FilePath { get; }
    public string OutputFilePath { get; }
    public HostLanguageServices LanguageServices { get; }
    public string Name { get; }
    public bool IsSubmission { get; }
    public Type HostObjectType { get; }
    [DebuggerBrowsableAttribute("2")]
public VersionStamp Version { get; }
    public AnalyzerOptions AnalyzerOptions { get; }
    [DebuggerBrowsableAttribute("2")]
public ProjectInfo ProjectInfo { get; }
    [DebuggerBrowsableAttribute("2")]
public string AssemblyName { get; }
    [DebuggerBrowsableAttribute("2")]
public CompilationOptions CompilationOptions { get; }
    [DebuggerBrowsableAttribute("2")]
public ParseOptions ParseOptions { get; }
    [DebuggerBrowsableAttribute("2")]
public IReadOnlyList`1<MetadataReference> MetadataReferences { get; }
    [DebuggerBrowsableAttribute("2")]
public IReadOnlyList`1<AnalyzerReference> AnalyzerReferences { get; }
    [DebuggerBrowsableAttribute("2")]
public IReadOnlyList`1<ProjectReference> ProjectReferences { get; }
    [DebuggerBrowsableAttribute("2")]
public bool HasDocuments { get; }
    [DebuggerBrowsableAttribute("2")]
public IEnumerable`1<DocumentState> OrderedDocumentStates { get; }
    [DebuggerBrowsableAttribute("2")]
public IReadOnlyList`1<DocumentId> DocumentIds { get; }
    [DebuggerBrowsableAttribute("2")]
public IReadOnlyList`1<DocumentId> AdditionalDocumentIds { get; }
    [DebuggerBrowsableAttribute("2")]
private ImmutableDictionary`2<DocumentId, DocumentState> DocumentStates { get; }
    [DebuggerBrowsableAttribute("2")]
private ImmutableDictionary`2<DocumentId, TextDocumentState> AdditionalDocumentStates { get; }
    private ProjectState(ProjectInfo projectInfo, HostLanguageServices languageServices, SolutionServices solutionServices, IEnumerable`1<DocumentId> documentIds, IEnumerable`1<DocumentId> additionalDocumentIds, ImmutableDictionary`2<DocumentId, DocumentState> documentStates, ImmutableDictionary`2<DocumentId, TextDocumentState> additionalDocumentStates, AsyncLazy`1<VersionStamp> lazyLatestDocumentVersion, AsyncLazy`1<VersionStamp> lazyLatestDocumentTopLevelChangeVersion);
    internal ProjectState(ProjectInfo projectInfo, HostLanguageServices languageServices, SolutionServices solutionServices);
    private ProjectInfo FixProjectInfo(ProjectInfo projectInfo);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ProjectState/<ComputeLatestDocumentVersionAsync>d__13")]
private static Task`1<VersionStamp> ComputeLatestDocumentVersionAsync(ImmutableDictionary`2<DocumentId, DocumentState> documentStates, ImmutableDictionary`2<DocumentId, TextDocumentState> additionalDocumentStates, CancellationToken cancellationToken);
    private AsyncLazy`1<VersionStamp> CreateLazyLatestDocumentTopLevelChangeVersion(TextDocumentState newDocument, ImmutableDictionary`2<DocumentId, DocumentState> newDocumentStates, ImmutableDictionary`2<DocumentId, TextDocumentState> newAdditionalDocumentStates);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ProjectState/<ComputeTopLevelChangeTextVersionAsync>d__15")]
private static Task`1<VersionStamp> ComputeTopLevelChangeTextVersionAsync(VersionStamp oldVersion, TextDocumentState newDocument, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ProjectState/<ComputeLatestDocumentTopLevelChangeVersionAsync>d__16")]
private static Task`1<VersionStamp> ComputeLatestDocumentTopLevelChangeVersionAsync(ImmutableDictionary`2<DocumentId, DocumentState> documentStates, ImmutableDictionary`2<DocumentId, TextDocumentState> additionalDocumentStates, CancellationToken cancellationToken);
    private static DocumentState CreateDocument(ProjectInfo projectInfo, DocumentInfo documentInfo, HostLanguageServices languageServices, SolutionServices solutionServices);
    public ProjectId get_Id();
    public string get_FilePath();
    public string get_OutputFilePath();
    public HostLanguageServices get_LanguageServices();
    public string get_Name();
    public bool get_IsSubmission();
    public Type get_HostObjectType();
    public VersionStamp get_Version();
    public AnalyzerOptions get_AnalyzerOptions();
    private static AnalyzerOptions CreateAnalyzerOptions(ImmutableDictionary`2<DocumentId, TextDocumentState> additionalDocStates);
    public Task`1<VersionStamp> GetLatestDocumentVersionAsync(CancellationToken cancellationToken);
    public Task`1<VersionStamp> GetLatestDocumentTopLevelChangeVersionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ProjectState/<GetSemanticVersionAsync>d__39")]
public Task`1<VersionStamp> GetSemanticVersionAsync(CancellationToken cancellationToken);
    public ProjectInfo get_ProjectInfo();
    public string get_AssemblyName();
    public CompilationOptions get_CompilationOptions();
    public ParseOptions get_ParseOptions();
    public IReadOnlyList`1<MetadataReference> get_MetadataReferences();
    public IReadOnlyList`1<AnalyzerReference> get_AnalyzerReferences();
    public IReadOnlyList`1<ProjectReference> get_ProjectReferences();
    public bool get_HasDocuments();
    public IEnumerable`1<DocumentState> get_OrderedDocumentStates();
    public IReadOnlyList`1<DocumentId> get_DocumentIds();
    public IReadOnlyList`1<DocumentId> get_AdditionalDocumentIds();
    private ImmutableDictionary`2<DocumentId, DocumentState> get_DocumentStates();
    private ImmutableDictionary`2<DocumentId, TextDocumentState> get_AdditionalDocumentStates();
    public bool ContainsDocument(DocumentId documentId);
    public bool ContainsAdditionalDocument(DocumentId documentId);
    public DocumentState GetDocumentState(DocumentId documentId);
    public TextDocumentState GetAdditionalDocumentState(DocumentId documentId);
    private ProjectState With(ProjectInfo projectInfo, ImmutableArray`1<DocumentId> documentIds, ImmutableArray`1<DocumentId> additionalDocumentIds, ImmutableDictionary`2<DocumentId, DocumentState> documentStates, ImmutableDictionary`2<DocumentId, TextDocumentState> additionalDocumentStates, AsyncLazy`1<VersionStamp> latestDocumentVersion, AsyncLazy`1<VersionStamp> latestDocumentTopLevelChangeVersion, Lazy`1<AnalyzerOptions> lazyAnalyzerOptions);
    public ProjectState UpdateName(string name);
    public ProjectState UpdateFilePath(string filePath);
    public ProjectState UpdateAssemblyName(string assemblyName);
    public ProjectState UpdateOutputPath(string outputFilePath);
    public ProjectState UpdateCompilationOptions(CompilationOptions options);
    public ProjectState UpdateParseOptions(ParseOptions options);
    public static bool IsSameLanguage(ProjectState project1, ProjectState project2);
    public ProjectState AddProjectReference(ProjectReference projectReference);
    public ProjectState RemoveProjectReference(ProjectReference projectReference);
    public ProjectState AddProjectReferences(IEnumerable`1<ProjectReference> projectReferences);
    public ProjectState WithProjectReferences(IEnumerable`1<ProjectReference> projectReferences);
    public ProjectState AddMetadataReference(MetadataReference toMetadata);
    public ProjectState RemoveMetadataReference(MetadataReference toMetadata);
    public ProjectState AddMetadataReferences(IEnumerable`1<MetadataReference> metadataReferences);
    public ProjectState WithMetadataReferences(IEnumerable`1<MetadataReference> metadataReferences);
    public ProjectState AddAnalyzerReference(AnalyzerReference analyzerReference);
    public ProjectState RemoveAnalyzerReference(AnalyzerReference analyzerReference);
    public ProjectState AddAnalyzerReferences(IEnumerable`1<AnalyzerReference> analyzerReferences);
    public ProjectState WithAnalyzerReferences(IEnumerable`1<AnalyzerReference> analyzerReferences);
    public ProjectState AddDocument(DocumentState document);
    public ProjectState AddAdditionalDocument(TextDocumentState document);
    public ProjectState RemoveDocument(DocumentId documentId);
    public ProjectState RemoveAdditionalDocument(DocumentId documentId);
    public ProjectState RemoveAllDocuments();
    public ProjectState UpdateDocument(DocumentState newDocument, bool textChanged, bool recalculateDependentVersions);
    public ProjectState UpdateAdditionalDocument(TextDocumentState newDocument, bool textChanged, bool recalculateDependentVersions);
    private void GetLatestDependentVersions(ImmutableDictionary`2<DocumentId, DocumentState> newDocumentStates, ImmutableDictionary`2<DocumentId, TextDocumentState> newAdditionalDocumentStates, TextDocumentState oldDocument, TextDocumentState newDocument, bool recalculateDependentVersions, bool textChanged, AsyncLazy`1& dependentDocumentVersion, AsyncLazy`1& dependentSemanticVersion);
}
internal abstract class Microsoft.CodeAnalysis.Recommendations.AbstractRecommendationService : object {
    protected abstract virtual Tuple`2<IEnumerable`1<ISymbol>, AbstractSyntaxContext> GetRecommendedSymbolsAtPositionWorker(Workspace workspace, SemanticModel semanticModel, int position, OptionSet options, CancellationToken cancellationToken);
    public sealed virtual IEnumerable`1<ISymbol> GetRecommendedSymbolsAtPosition(Workspace workspace, SemanticModel semanticModel, int position, OptionSet options, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Recommendations.IRecommendationService {
    public abstract virtual IEnumerable`1<ISymbol> GetRecommendedSymbolsAtPosition(Workspace workspace, SemanticModel semanticModel, int position, OptionSet options, CancellationToken cancellationToken);
}
public static class Microsoft.CodeAnalysis.Recommendations.RecommendationOptions : object {
    internal static string RecommendationsFeatureName;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <HideAdvancedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <FilterOutOfScopeLocals>k__BackingField;
    public static PerLanguageOption`1<bool> HideAdvancedMembers { get; }
    public static PerLanguageOption`1<bool> FilterOutOfScopeLocals { get; }
    private static RecommendationOptions();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_HideAdvancedMembers();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_FilterOutOfScopeLocals();
}
public static class Microsoft.CodeAnalysis.Recommendations.Recommender : object {
    public static IEnumerable`1<ISymbol> GetRecommendedSymbolsAtPosition(SemanticModel semanticModel, int position, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.RecoverableTextAndVersion : ValueSource`1<TextAndVersion> {
    private ITemporaryStorageService _storageService;
    private SemaphoreSlim _gateDoNotAccessDirectly;
    private ValueSource`1<TextAndVersion> _initialSource;
    private RecoverableText _text;
    private VersionStamp _version;
    private string _filePath;
    private SemaphoreSlim Gate { get; }
    public RecoverableTextAndVersion(ValueSource`1<TextAndVersion> initialTextAndVersion, ITemporaryStorageService storageService);
    private SemaphoreSlim get_Gate();
    public virtual bool TryGetValue(TextAndVersion& value);
    public sealed virtual bool TryGetTextVersion(VersionStamp& version);
    public virtual TextAndVersion GetValue(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RecoverableTextAndVersion/<GetValueAsync>d__12")]
public virtual Task`1<TextAndVersion> GetValueAsync(CancellationToken cancellationToken);
    private TextAndVersion InitRecoverable(TextAndVersion textAndVersion);
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictingIdentifierTracker : object {
    private Dictionary`2<string, List`1<SyntaxToken>> _currentIdentifiersInScope;
    private HashSet`1<SyntaxToken> _conflictingTokensToReport;
    private SyntaxToken _tokenBeingRenamed;
    public IEnumerable`1<SyntaxToken> ConflictingTokens { get; }
    public ConflictingIdentifierTracker(SyntaxToken tokenBeingRenamed, IEqualityComparer`1<string> identifierComparer);
    public IEnumerable`1<SyntaxToken> get_ConflictingTokens();
    public void AddIdentifier(SyntaxToken token);
    public void AddIdentifiers(IEnumerable`1<SyntaxToken> tokens);
    public void RemoveIdentifier(SyntaxToken token);
    public void RemoveIdentifiers(IEnumerable`1<SyntaxToken> tokens);
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution : object {
    private RenamedSpansTracker _renamedSpansTracker;
    private List`1<RelatedLocation> _relatedLocations;
    private Solution _oldSolution;
    private Solution _newSolution;
    private Solution _intermediateSolutionContainingOnlyModifiedDocuments;
    private ILookup`2<DocumentId, RelatedLocation> _relatedLocationsByDocumentId;
    [CompilerGeneratedAttribute]
private bool <ReplacementTextValid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplacementText>k__BackingField;
    public IList`1<RelatedLocation> RelatedLocations { get; }
    public RenamedSpansTracker RenamedSpansTracker { get; }
    public IEnumerable`1<DocumentId> DocumentIds { get; }
    public Solution NewSolution { get; }
    public Solution OldSolution { get; }
    public bool ReplacementTextValid { get; }
    public string ReplacementText { get; }
    public ConflictResolution(Solution oldSolution, RenamedSpansTracker renamedSpansTracker, string replacementText, bool replacementTextValid);
    internal void ClearDocuments(IEnumerable`1<DocumentId> conflictLocationDocumentIds);
    internal void UpdateCurrentSolution(Solution solution);
    internal void RemoveAllRenameAnnotations(IEnumerable`1<DocumentId> documentWithRenameAnnotations, AnnotationTable`1<RenameAnnotation> annotationSet, CancellationToken cancellationToken);
    public IList`1<RelatedLocation> get_RelatedLocations();
    public RenamedSpansTracker get_RenamedSpansTracker();
    public int GetAdjustedTokenStartingPosition(int startingPosition, DocumentId documentId);
    public TextSpan GetResolutionTextSpan(TextSpan originalSpan, DocumentId documentId);
    public IEnumerable`1<DocumentId> get_DocumentIds();
    public IEnumerable`1<RelatedLocation> GetRelatedLocationsForDocument(DocumentId documentId);
    internal void AddRelatedLocation(RelatedLocation location);
    internal void AddOrReplaceRelatedLocation(RelatedLocation location);
    public Solution get_NewSolution();
    public Solution get_OldSolution();
    [CompilerGeneratedAttribute]
public bool get_ReplacementTextValid();
    [CompilerGeneratedAttribute]
public string get_ReplacementText();
}
internal static class Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver : object {
    private static SymbolDisplayFormat s_metadataSymbolDisplayFormat;
    private static string s_metadataNameSeparators;
    private static ConflictResolver();
    public static Task`1<ConflictResolution> ResolveConflictsAsync(RenameLocationSet renameLocationSet, string originalText, string replacementText, OptionSet optionSet, CancellationToken cancellationToken);
    private static IEnumerable`1<ISymbol> SymbolsForEnclosingInvocationExpressionWorker(SyntaxNode invocationExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static SyntaxNode GetExpansionTargetForLocationPerLanguage(SyntaxToken tokenOrNode, Document document);
    private static bool LocalVariableConflictPerLanguage(SyntaxToken tokenOrNode, Document document, IEnumerable`1<ISymbol> newReferencedSymbols);
    private static bool IsIdentifierValid_Worker(Solution solution, string replacementText, IEnumerable`1<ProjectId> projectIds, CancellationToken cancellationToken);
    private static bool IsRenameValid(ConflictResolution conflictResolution, ISymbol renamedSymbol);
    private static void AddImplicitConflicts(ISymbol renamedSymbol, ISymbol originalSymbol, IEnumerable`1<ReferenceLocation> implicitReferenceLocations, SemanticModel semanticModel, Location originalDeclarationLocation, int newDeclarationLocationStartingPosition, ConflictResolution conflictResolution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver/<AddDeclarationConflictsAsync>d__9")]
internal static Task AddDeclarationConflictsAsync(ISymbol renamedSymbol, ISymbol renameSymbol, IEnumerable`1<ISymbol> referencedSymbols, ConflictResolution conflictResolution, IDictionary`2<Location, Location> reverseMappedLocations, CancellationToken cancellationToken);
    internal static void AddConflictingParametersOfProperties(IEnumerable`1<ISymbol> properties, string newPropertyName, List`1<Location> conflicts);
    private static void AddConflictingSymbolLocations(IEnumerable`1<ISymbol> conflictingSymbols, ConflictResolution conflictResolution, IDictionary`2<Location, Location> reverseMappedLocations);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver/<CreateDeclarationLocationAnnotationsAsync>d__12")]
public static Task`1<RenameDeclarationLocationReference[]> CreateDeclarationLocationAnnotationsAsync(Solution solution, IEnumerable`1<ISymbol> symbols, CancellationToken cancellationToken);
    private static string GetString(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver/<GetSymbolLocationAsync>d__14")]
private static Task`1<Location> GetSymbolLocationAsync(Solution solution, ISymbol symbol, CancellationToken cancellationToken);
    private static bool HeuristicMetadataNameEquivalenceCheck(string oldMetadataName, string newMetadataName, string originalText, string replacementText);
    private static bool IsSubStringEqual(string str1, string str2, int index);
    private static bool IsWholeIdentifier(string metadataName, string searchText, int index);
    private static bool IsIdentifierSeparator(char element);
}
internal static class Microsoft.CodeAnalysis.Rename.ConflictEngine.DeclarationConflictHelpers : object {
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.DeclarationConflictHelpers/<GetMembersWithConflictingSignatures>d__0")]
public static IEnumerable`1<Location> GetMembersWithConflictingSignatures(IMethodSymbol renamedMethod, bool trimOptionalParameters);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.DeclarationConflictHelpers/<GetAllSignatures>d__2")]
private static IEnumerable`1<List`1<ITypeSymbol>> GetAllSignatures(IMethodSymbol method, bool trimOptionalParameters);
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocation : object {
    [CompilerGeneratedAttribute]
private TextSpan <ConflictCheckSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private RelatedLocationType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <ComplexifiedTargetSpan>k__BackingField;
    public TextSpan ConflictCheckSpan { get; }
    public RelatedLocationType Type { get; public set; }
    public bool IsReference { get; }
    public DocumentId DocumentId { get; }
    public TextSpan ComplexifiedTargetSpan { get; }
    public RelatedLocation(TextSpan location, DocumentId documentId, RelatedLocationType type, bool isReference, TextSpan complexifiedTargetSpan);
    [CompilerGeneratedAttribute]
public TextSpan get_ConflictCheckSpan();
    [CompilerGeneratedAttribute]
public RelatedLocationType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(RelatedLocationType value);
    [CompilerGeneratedAttribute]
public bool get_IsReference();
    [CompilerGeneratedAttribute]
public DocumentId get_DocumentId();
    [CompilerGeneratedAttribute]
public TextSpan get_ComplexifiedTargetSpan();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocationType : Enum {
    public int value__;
    public static RelatedLocationType NoConflict;
    public static RelatedLocationType ResolvedReferenceConflict;
    public static RelatedLocationType ResolvedNonReferenceConflict;
    public static RelatedLocationType PossibilyResolvableConflict;
    public static RelatedLocationType UnresolvableConflict;
    public static RelatedLocationType UnresolvedConflict;
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation : RenameAnnotation {
    public TextSpan OriginalSpan;
    public bool IsRenameLocation;
    public bool IsOriginalTextLocation;
    public string Prefix;
    public string Suffix;
    public RenameDeclarationLocationReference[] RenameDeclarationLocationReferences;
    public bool IsNamespaceDeclarationReference;
    public bool IsMemberGroupReference;
    public bool IsInvocationExpression;
    public RenameActionAnnotation(TextSpan originalSpan, bool isRenameLocation, string prefix, string suffix, bool isOriginalTextLocation, RenameDeclarationLocationReference[] renameDeclarationLocations, bool isNamespaceDeclarationReference, bool isInvocationExpression, bool isMemberGroupReference);
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameAnnotation : object {
    public static string Kind;
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference : object {
    public DocumentId DocumentId;
    public TextSpan TextSpan;
    public string Name;
    public int SymbolLocationsCount;
    public bool IsOverriddenFromMetadata;
    public bool IsSourceLocation { get; }
    public RenameDeclarationLocationReference(DocumentId documentId, TextSpan textSpan, bool overriddenFromMetadata, int declaringSyntaxReferencesCount);
    public RenameDeclarationLocationReference(string name, int declaringSyntaxReferencesCount);
    public bool get_IsSourceLocation();
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenamedSpansTracker : object {
    private Dictionary`2<DocumentId, List`1<ValueTuple`2<TextSpan, TextSpan>>> _documentToModifiedSpansMap;
    private Dictionary`2<DocumentId, List`1<ComplexifiedSpan>> _documentToComplexifiedSpansMap;
    public IEnumerable`1<DocumentId> DocumentIds { get; }
    internal bool IsDocumentChanged(DocumentId documentId);
    internal void AddModifiedSpan(DocumentId documentId, TextSpan oldSpan, TextSpan newSpan);
    internal void AddComplexifiedSpan(DocumentId documentId, TextSpan oldSpan, TextSpan newSpan, List`1<ValueTuple`2<TextSpan, TextSpan>> modifiedSubSpans);
    internal TextSpan GetAdjustedComplexifiedSpan(TextSpan originalComplexifiedSpan, DocumentId documentId);
    internal int GetAdjustedPosition(int startingPosition, DocumentId documentId);
    internal TextSpan GetResolutionTextSpan(TextSpan originalSpan, DocumentId documentId);
    internal void ClearDocuments(IEnumerable`1<DocumentId> conflictLocationDocumentIds);
    internal bool ContainsResolvedNonReferenceLocation(DocumentId documentId, TextSpan originalLocation);
    public IEnumerable`1<DocumentId> get_DocumentIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.RenamedSpansTracker/<SimplifyAsync>d__14")]
internal Task`1<Solution> SimplifyAsync(Solution solution, IEnumerable`1<DocumentId> documentIds, bool replacementTextValid, AnnotationTable`1<RenameAnnotation> renameAnnotations, CancellationToken cancellationToken);
    internal Dictionary`2<TextSpan, TextSpan> GetModifiedSpanMap(DocumentId documentId);
    internal IEnumerable`1<ValueTuple`2<TextSpan, TextSpan>> GetComplexifiedSpans(DocumentId documentId);
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameInvalidIdentifierAnnotation : RenameAnnotation {
    public static RenameInvalidIdentifierAnnotation Instance;
    private static RenameInvalidIdentifierAnnotation();
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameNodeSimplificationAnnotation : RenameAnnotation {
    [CompilerGeneratedAttribute]
private TextSpan <OriginalTextSpan>k__BackingField;
    public TextSpan OriginalTextSpan { get; public set; }
    [CompilerGeneratedAttribute]
public TextSpan get_OriginalTextSpan();
    [CompilerGeneratedAttribute]
public void set_OriginalTextSpan(TextSpan value);
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameTokenSimplificationAnnotation : RenameAnnotation {
    [CompilerGeneratedAttribute]
private TextSpan <OriginalTextSpan>k__BackingField;
    public TextSpan OriginalTextSpan { get; public set; }
    [CompilerGeneratedAttribute]
public TextSpan get_OriginalTextSpan();
    [CompilerGeneratedAttribute]
public void set_OriginalTextSpan(TextSpan value);
}
internal interface Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService {
    public abstract virtual SyntaxNode AnnotateAndRename(RenameRewriterParameters parameters);
    public abstract virtual void TryAddPossibleNameConflicts(ISymbol symbol, string newName, ICollection`1<string> possibleNameConflicts);
    public abstract virtual Task`1<IEnumerable`1<Location>> ComputeDeclarationConflictsAsync(string replacementText, ISymbol renamedSymbol, ISymbol renameSymbol, IEnumerable`1<ISymbol> referencedSymbols, Solution baseSolution, Solution newSolution, IDictionary`2<Location, Location> reverseMappedLocations, CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<Location> ComputeImplicitReferenceConflicts(ISymbol renameSymbol, ISymbol renamedSymbol, IEnumerable`1<ReferenceLocation> implicitReferenceLocations, CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<Location> ComputePossibleImplicitUsageConflicts(ISymbol renamedSymbol, SemanticModel semanticModel, Location originalDeclarationLocation, int newDeclarationLocationStartingPosition, CancellationToken cancellationToken);
    public abstract virtual bool LocalVariableConflict(SyntaxToken token, IEnumerable`1<ISymbol> newReferencedSymbols);
    public abstract virtual bool IsIdentifierValid(string replacementText, ISyntaxFactsService syntaxFactsService);
    public abstract virtual SyntaxNode GetExpansionTargetForLocation(SyntaxToken token);
}
public enum Microsoft.CodeAnalysis.Rename.RenameEntityKind : Enum {
    public int value__;
    public static RenameEntityKind BaseSymbol;
    public static RenameEntityKind OverloadedSymbols;
}
internal class Microsoft.CodeAnalysis.Rename.RenameLocation : ValueType {
    public Location Location;
    public DocumentId DocumentId;
    public bool IsCandidateLocation;
    public bool IsRenamableAliasUsage;
    public bool IsRenamableAccessor;
    public TextSpan ContainingLocationForStringOrComment;
    [CompilerGeneratedAttribute]
private bool <IsMethodGroupReference>k__BackingField;
    public bool IsRenameInStringOrComment { get; }
    public bool IsMethodGroupReference { get; private set; }
    public RenameLocation(Location location, DocumentId documentId, bool isCandidateLocation, bool isMethodGroupReference, bool isRenamableAliasUsage, bool isRenamableAccessor, TextSpan containingLocationForStringOrComment);
    public RenameLocation(ReferenceLocation referenceLocation, DocumentId documentId);
    public bool get_IsRenameInStringOrComment();
    [CompilerGeneratedAttribute]
public bool get_IsMethodGroupReference();
    [CompilerGeneratedAttribute]
private void set_IsMethodGroupReference(bool value);
    public sealed virtual bool Equals(RenameLocation other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.Rename.RenameLocationSet : object {
    private ISymbol _symbol;
    private Solution _solution;
    private SearchResult _mergedResult;
    private OptionSet _optionSet;
    private SearchResult _originalSymbolResult;
    private List`1<SearchResult> _overloadsResult;
    private IEnumerable`1<RenameLocation> _stringsResult;
    private IEnumerable`1<RenameLocation> _commentsResult;
    public ISet`1<RenameLocation> Locations { get; }
    public ISymbol Symbol { get; }
    public Solution Solution { get; }
    public IEnumerable`1<ISymbol> ReferencedSymbols { get; }
    public IEnumerable`1<ReferenceLocation> ImplicitLocations { get; }
    public RenameLocationSet(ISet`1<RenameLocation> locations, ISymbol symbol, Solution solution, IEnumerable`1<ISymbol> referencedSymbols, IEnumerable`1<ReferenceLocation> implicitLocations);
    private RenameLocationSet(ISymbol symbol, Solution solution, OptionSet optionSet, SearchResult originalSymbolResult, List`1<SearchResult> overloadsResult, IEnumerable`1<RenameLocation> stringsResult, IEnumerable`1<RenameLocation> commentsResult);
    public ISet`1<RenameLocation> get_Locations();
    public ISymbol get_Symbol();
    public Solution get_Solution();
    public IEnumerable`1<ISymbol> get_ReferencedSymbols();
    public IEnumerable`1<ReferenceLocation> get_ImplicitLocations();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.RenameLocationSet/<FindAsync>d__22")]
public static Task`1<RenameLocationSet> FindAsync(ISymbol symbol, Solution solution, OptionSet optionSet, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.RenameLocationSet/<FindWithUpdatedOptionsAsync>d__23")]
public Task`1<RenameLocationSet> FindWithUpdatedOptionsAsync(OptionSet optionSet, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.RenameLocationSet/<GetOverloadsAsync>d__24")]
private static Task`1<List`1<SearchResult>> GetOverloadsAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Rename.RenameLocationSet/<GetOverloadedSymbols>d__25")]
internal static IEnumerable`1<ISymbol> GetOverloadedSymbols(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.RenameLocationSet/<AddLocationsReferenceSymbolsAsync>d__26")]
private static Task`1<SearchResult> AddLocationsReferenceSymbolsAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
}
public static class Microsoft.CodeAnalysis.Rename.RenameOptions : object {
    internal static string RenameFeatureName;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <RenameOverloads>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <RenameInStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <RenameInComments>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <PreviewChanges>k__BackingField;
    public static Option`1<bool> RenameOverloads { get; }
    public static Option`1<bool> RenameInStrings { get; }
    public static Option`1<bool> RenameInComments { get; }
    public static Option`1<bool> PreviewChanges { get; }
    private static RenameOptions();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_RenameOverloads();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_RenameInStrings();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_RenameInComments();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_PreviewChanges();
}
public static class Microsoft.CodeAnalysis.Rename.Renamer : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.Renamer/<RenameSymbolAsync>d__0")]
public static Task`1<Solution> RenameSymbolAsync(Solution solution, ISymbol symbol, string newName, OptionSet optionSet, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Rename.RenameRewriterParameters : object {
    internal CancellationToken CancellationToken;
    internal ISet`1<TextSpan> ConflictLocationSpans;
    internal OptionSet OptionSet;
    internal Solution OriginalSolution;
    internal SyntaxTree OriginalSyntaxTree;
    internal string OriginalText;
    internal ICollection`1<string> PossibleNameConflicts;
    internal RenameAnnotation RenamedSymbolDeclarationAnnotation;
    internal Dictionary`2<TextSpan, RenameLocation> RenameLocations;
    internal RenamedSpansTracker RenameSpansTracker;
    internal ISymbol RenameSymbol;
    internal string ReplacementText;
    internal bool ReplacementTextValid;
    internal ISet`1<TextSpan> StringAndCommentTextSpans;
    internal SyntaxNode SyntaxRoot;
    internal Document Document;
    internal SemanticModel SemanticModel;
    internal AnnotationTable`1<RenameAnnotation> RenameAnnotations;
    public RenameRewriterParameters(RenameAnnotation renamedSymbolDeclarationAnnotation, Document document, SemanticModel semanticModel, SyntaxNode syntaxRoot, string replacementText, string originalText, ICollection`1<string> possibleNameConflicts, Dictionary`2<TextSpan, RenameLocation> renameLocations, ISet`1<TextSpan> stringAndCommentTextSpans, ISet`1<TextSpan> conflictLocationSpans, Solution originalSolution, ISymbol renameSymbol, bool replacementTextValid, RenamedSpansTracker renameSpansTracker, OptionSet optionSet, AnnotationTable`1<RenameAnnotation> renameAnnotations, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Rename.RenameUtilities : object {
    internal static SyntaxToken UpdateAliasAnnotation(SyntaxToken token, ISymbol aliasSymbol, string replacementText);
    internal static IEnumerable`1<ISymbol> GetSymbolsTouchingPosition(int position, SemanticModel semanticModel, Workspace workspace, CancellationToken cancellationToken);
    private static bool IsSymbolDefinedInsideMethod(ISymbol symbol);
    internal static IEnumerable`1<Document> GetDocumentsAffectedByRename(ISymbol symbol, Solution solution, IEnumerable`1<RenameLocation> renameLocations);
    internal static TokenRenameInfo GetTokenRenameInfo(ISemanticFactsService semanticFacts, SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Rename.TokenRenameInfo : object {
    [CompilerGeneratedAttribute]
private bool <HasSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ISymbol> <Symbols>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMemberGroup>k__BackingField;
    public static TokenRenameInfo NoSymbolsTokenInfo;
    public bool HasSymbols { get; private set; }
    public IEnumerable`1<ISymbol> Symbols { get; private set; }
    public bool IsMemberGroup { get; private set; }
    private static TokenRenameInfo();
    [CompilerGeneratedAttribute]
public bool get_HasSymbols();
    [CompilerGeneratedAttribute]
private void set_HasSymbols(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ISymbol> get_Symbols();
    [CompilerGeneratedAttribute]
private void set_Symbols(IEnumerable`1<ISymbol> value);
    [CompilerGeneratedAttribute]
public bool get_IsMemberGroup();
    [CompilerGeneratedAttribute]
private void set_IsMemberGroup(bool value);
    public static TokenRenameInfo CreateMemberGroupTokenInfo(IEnumerable`1<ISymbol> symbols);
    public static TokenRenameInfo CreateSingleSymbolTokenInfo(ISymbol symbol);
}
internal class Microsoft.CodeAnalysis.SemanticDocument : SyntacticDocument {
    public SemanticModel SemanticModel;
    private SemanticDocument(Document document, SourceText text, SyntaxTree tree, SyntaxNode root, SemanticModel semanticModel);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SemanticDocument/<CreateAsync>d__2")]
public static Task`1<SemanticDocument> CreateAsync(Document document, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.SemanticModelWorkspaceService.ISemanticModelService {
    public abstract virtual Task`1<SemanticModel> GetSemanticModelForNodeAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.SemanticModelWorkspaceService.ISemanticModelService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SemanticModelWorkspaceService.SemanticModelWorkspaceServiceFactory : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Serialization.IAssemblySerializationInfoService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Serialization.AssemblySerializationInfoService : object {
    public sealed virtual bool Serializable(Solution solution, string assemblyFilePath);
    public sealed virtual bool TryGetSerializationPrefixAndVersion(Solution solution, string assemblyFilePath, String& prefix, VersionStamp& version);
}
internal interface Microsoft.CodeAnalysis.Serialization.IAssemblySerializationInfoService {
    public abstract virtual bool Serializable(Solution solution, string assemblyFilePath);
    public abstract virtual bool TryGetSerializationPrefixAndVersion(Solution solution, string assemblyFilePath, String& prefix, VersionStamp& version);
}
internal interface Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector`1 {
    public abstract virtual int GetStart(T value);
    public abstract virtual int GetLength(T value);
}
internal static class Microsoft.CodeAnalysis.Shared.Collections.IntervalTree : object {
    public static IntervalTree`1<T> Create(IIntervalIntrospector`1<T> introspector, T[] values);
    public static IntervalTree`1<T> Create(IIntervalIntrospector`1<T> introspector, IEnumerable`1<T> values);
}
internal class Microsoft.CodeAnalysis.Shared.Collections.IntervalTree`1 : object {
    public static IntervalTree`1<T> Empty;
    protected Node<T> root;
    private static TestInterval<T> s_intersectsWithTest;
    private static TestInterval<T> s_containsTest;
    private static TestInterval<T> s_overlapsWithTest;
    protected IntervalTree`1(Node<T> root);
    public IntervalTree`1(IIntervalIntrospector`1<T> introspector, IEnumerable`1<T> values);
    private static IntervalTree`1();
    protected static bool Contains(T value, int start, int length, IIntervalIntrospector`1<T> introspector);
    private static bool IntersectsWith(T value, int start, int length, IIntervalIntrospector`1<T> introspector);
    private static bool OverlapsWith(T value, int start, int length, IIntervalIntrospector`1<T> introspector);
    public IEnumerable`1<T> GetOverlappingIntervals(int start, int length, IIntervalIntrospector`1<T> introspector);
    public IEnumerable`1<T> GetIntersectingIntervals(int start, int length, IIntervalIntrospector`1<T> introspector);
    public IList`1<T> GetIntersectingInOrderIntervals(int start, int length, IIntervalIntrospector`1<T> introspector);
    public IEnumerable`1<T> GetContainingIntervals(int start, int length, IIntervalIntrospector`1<T> introspector);
    public bool IntersectsWith(int position, IIntervalIntrospector`1<T> introspector);
    private IList`1<T> GetInOrderIntervals(int start, int length, TestInterval<T> testInterval, IIntervalIntrospector`1<T> introspector);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Collections.IntervalTree`1/<GetPreOrderIntervals>d__18")]
private IEnumerable`1<T> GetPreOrderIntervals(int start, int length, TestInterval<T> testInterval, IIntervalIntrospector`1<T> introspector);
    public IntervalTree`1<T> AddInterval(T value, IIntervalIntrospector`1<T> introspector);
    public bool IsEmpty();
    protected static Node<T> Insert(Node<T> root, Node<T> newNode, IIntervalIntrospector`1<T> introspector, bool inPlace);
    private static Node<T> Insert(Node<T> root, Node<T> newNode, int newNodeStart, IIntervalIntrospector`1<T> introspector, bool inPlace);
    private static Node<T> Balance(Node<T> node, bool inPlace, IIntervalIntrospector`1<T> introspector);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Collections.IntervalTree`1/<GetEnumerator>d__24")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected static int GetEnd(T value, IIntervalIntrospector`1<T> introspector);
    protected static int MaxEndValue(Node<T> node, IIntervalIntrospector`1<T> arg);
    private static int Height(Node<T> node);
    private static int BalanceFactor(Node<T> node);
}
internal class Microsoft.CodeAnalysis.Shared.Collections.SimpleIntervalTree : object {
    public static SimpleIntervalTree`1<T> Create(IIntervalIntrospector`1<T> introspector, T[] values);
    public static SimpleIntervalTree`1<T> Create(IIntervalIntrospector`1<T> introspector, IEnumerable`1<T> values);
}
internal class Microsoft.CodeAnalysis.Shared.Collections.SimpleIntervalTree`1 : IntervalTree`1<T> {
    private IIntervalIntrospector`1<T> _introspector;
    protected IIntervalIntrospector`1<T> Introspector { get; }
    public SimpleIntervalTree`1(IIntervalIntrospector`1<T> introspector);
    protected SimpleIntervalTree`1(IIntervalIntrospector`1<T> introspector, Node<T> root);
    public SimpleIntervalTree`1(IIntervalIntrospector`1<T> introspector, IEnumerable`1<T> values);
    protected IIntervalIntrospector`1<T> get_Introspector();
    public IEnumerable`1<T> GetOverlappingIntervals(int start, int length);
    public IEnumerable`1<T> GetIntersectingIntervals(int start, int length);
    public IEnumerable`1<T> GetContainingIntervals(int start, int length);
    public bool IntersectsWith(int position);
    public SimpleIntervalTree`1<T> AddInterval(T value);
    protected int MaxEndValue(Node<T> node);
}
internal class Microsoft.CodeAnalysis.Shared.Collections.TextSpanIntervalIntrospector : object {
    public static IIntervalIntrospector`1<TextSpan> Instance;
    private static TextSpanIntervalIntrospector();
    public sealed virtual int GetStart(TextSpan value);
    public sealed virtual int GetLength(TextSpan value);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ArrayExtensions : object {
    [ExtensionAttribute]
public static bool IsNullOrEmpty(T[] array);
    [ExtensionAttribute]
public static bool Contains(T[] array, T item);
}
internal static class Microsoft.CodeAnalysis.Shared.Extensions.CommonAccessibilityUtilities : object {
    public static Accessibility Minimum(Accessibility accessibility1, Accessibility accessibility2);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.CommonLocationExtensions : object {
    [ExtensionAttribute]
public static SyntaxToken FindToken(Location location, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsVisibleSourceLocation(Location loc);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.CommonMethodKindExtensions : object {
    [ExtensionAttribute]
public static bool IsPropertyAccessor(MethodKind kind);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.CommonSymbolInfoExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<ISymbol> GetAllSymbols(SymbolInfo info);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.CommonSymbolInfoExtensions/<GetAllSymbolsWorker>d__1")]
[ExtensionAttribute]
private static IEnumerable`1<ISymbol> GetAllSymbolsWorker(SymbolInfo info);
    [ExtensionAttribute]
public static ISymbol GetAnySymbol(SymbolInfo info);
    [ExtensionAttribute]
public static IEnumerable`1<ISymbol> GetBestOrAllSymbols(SymbolInfo info);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxNodeExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxNodeOrToken> DepthFirstTraversal(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxNodeExtensions/<GetAncestors>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> GetAncestors(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxNodeExtensions/<GetAncestors>d__2`1")]
[ExtensionAttribute]
public static IEnumerable`1<TNode> GetAncestors(SyntaxNode node);
    [ExtensionAttribute]
public static TNode GetAncestor(SyntaxNode node);
    [ExtensionAttribute]
public static TNode GetAncestorOrThis(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxNodeExtensions/<GetAncestorsOrThis>d__5`1")]
[ExtensionAttribute]
public static IEnumerable`1<TNode> GetAncestorsOrThis(SyntaxNode node);
    [ExtensionAttribute]
public static bool HasAncestor(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxNodeExtensions/<Traverse>d__7`1")]
[ExtensionAttribute]
public static IEnumerable`1<TSyntaxNode> Traverse(SyntaxNode node, TextSpan searchSpan, Func`2<SyntaxNode, bool> predicate);
    [ExtensionAttribute]
public static bool CheckParent(SyntaxNode node, Func`2<T, bool> valueChecker);
    [ExtensionAttribute]
public static bool IsChildNode(SyntaxNode node, Func`2<TParent, SyntaxNode> childGetter);
    [ExtensionAttribute]
public static bool IsFoundUnder(SyntaxNode node, Func`2<TParent, SyntaxNode> childGetter);
    [ExtensionAttribute]
public static SyntaxNode GetCommonRoot(SyntaxNode node1, SyntaxNode node2);
    [ExtensionAttribute]
public static int Width(SyntaxNode node);
    [ExtensionAttribute]
public static int FullWidth(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode FindInnermostCommonNode(IEnumerable`1<SyntaxNode> nodes, Func`2<SyntaxNode, bool> predicate);
    [ExtensionAttribute]
public static TSyntaxNode FindInnermostCommonNode(IEnumerable`1<SyntaxNode> nodes);
    [ExtensionAttribute]
public static SyntaxNode AddAnnotations(SyntaxNode root, IEnumerable`1<Tuple`2<SyntaxToken, SyntaxAnnotation>> pairs);
    [ExtensionAttribute]
public static SyntaxNode AddAnnotations(SyntaxNode root, IEnumerable`1<Tuple`2<SyntaxNode, SyntaxAnnotation>> pairs);
    [ExtensionAttribute]
public static TextSpan GetContainedSpan(IEnumerable`1<SyntaxNode> nodes);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxNodeExtensions/<GetContiguousSpans>d__19")]
[ExtensionAttribute]
public static IEnumerable`1<TextSpan> GetContiguousSpans(IEnumerable`1<SyntaxNode> nodes, Func`2<SyntaxNode, SyntaxToken> getLastToken);
    [ExtensionAttribute]
public static bool OverlapsHiddenPosition(SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool OverlapsHiddenPosition(SyntaxNode node, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool OverlapsHiddenPosition(SyntaxNode declaration, SyntaxNode startNode, SyntaxNode endNode, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAnnotatedNodes(SyntaxNode node, SyntaxAnnotation syntaxAnnotation);
    [ExtensionAttribute]
public static Task`1<TRootNode> ReplaceNodesAsync(TRootNode root, IEnumerable`1<SyntaxNode> nodes, Func`4<SyntaxNode, SyntaxNode, CancellationToken, Task`1<SyntaxNode>> computeReplacementAsync, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TRootNode> ReplaceTokensAsync(TRootNode root, IEnumerable`1<SyntaxToken> tokens, Func`4<SyntaxToken, SyntaxToken, CancellationToken, Task`1<SyntaxToken>> computeReplacementAsync, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TRoot> ReplaceTriviaAsync(TRoot root, IEnumerable`1<SyntaxTrivia> trivia, Func`4<SyntaxTrivia, SyntaxTrivia, CancellationToken, Task`1<SyntaxTrivia>> computeReplacementAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxNodeExtensions/<ReplaceSyntaxAsync>d__27`1")]
[ExtensionAttribute]
public static Task`1<TRoot> ReplaceSyntaxAsync(TRoot root, IEnumerable`1<SyntaxNode> nodes, Func`4<SyntaxNode, SyntaxNode, CancellationToken, Task`1<SyntaxNode>> computeReplacementNodeAsync, IEnumerable`1<SyntaxToken> tokens, Func`4<SyntaxToken, SyntaxToken, CancellationToken, Task`1<SyntaxToken>> computeReplacementTokenAsync, IEnumerable`1<SyntaxTrivia> trivia, Func`4<SyntaxTrivia, SyntaxTrivia, CancellationToken, Task`1<SyntaxTrivia>> computeReplacementTriviaAsync, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxNodeOrTokenExtensions : object {
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxNodeOrTokenExtensions/<DepthFirstTraversal>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxNodeOrToken> DepthFirstTraversal(SyntaxNodeOrToken node);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxTokenExtensions : object {
    [ExtensionAttribute]
public static SyntaxNode GetAncestor(SyntaxToken token, Func`2<SyntaxNode, bool> predicate);
    [ExtensionAttribute]
public static T GetAncestor(SyntaxToken token, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAncestors(SyntaxToken token);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> GetAncestors(SyntaxToken token, Func`2<SyntaxNode, bool> predicate);
    [ExtensionAttribute]
public static SyntaxNode GetCommonRoot(SyntaxToken token1, SyntaxToken token2);
    [ExtensionAttribute]
public static bool CheckParent(SyntaxToken token, Func`2<T, bool> valueChecker);
    [ExtensionAttribute]
public static int Width(SyntaxToken token);
    [ExtensionAttribute]
public static int FullWidth(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken FindTokenFromEnd(SyntaxNode root, int position, bool includeZeroWidth, bool findInsideTrivia);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxTreeExtensions : object {
    [ExtensionAttribute]
public static SyntaxToken GetTouchingWord(SyntaxTree syntaxTree, int position, ISyntaxFactsService syntaxFacts, CancellationToken cancellationToken, bool findInsideTrivia);
    [ExtensionAttribute]
public static SyntaxToken GetTouchingToken(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, bool findInsideTrivia);
    [ExtensionAttribute]
public static SyntaxToken GetTouchingToken(SyntaxTree syntaxTree, int position, Predicate`1<SyntaxToken> predicate, CancellationToken cancellationToken, bool findInsideTrivia);
    [ExtensionAttribute]
public static bool OverlapsHiddenPosition(SyntaxTree tree, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyHidden(SyntaxTree tree, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsHiddenPosition(SyntaxTree tree, int position, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.CommonSyntaxTriviaExtensions : object {
    [ExtensionAttribute]
public static int Width(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static int FullWidth(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsElastic(SyntaxTrivia trivia);
}
internal abstract class Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.AbstractSyntaxContext : object {
    private ISet`1<INamedTypeSymbol> _outerTypes;
    [CompilerGeneratedAttribute]
private Workspace <Workspace>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxTree <SyntaxTree>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <LeftToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <TargetToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTypeContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNamespaceContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPreProcessorDirectiveContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRightOfNameSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatementContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAnyExpressionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAttributeNameContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnumTypeMemberAccessContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNameOfContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInImportsDirective>k__BackingField;
    public Workspace Workspace { get; }
    public SemanticModel SemanticModel { get; }
    public SyntaxTree SyntaxTree { get; }
    public int Position { get; }
    public SyntaxToken LeftToken { get; }
    public SyntaxToken TargetToken { get; }
    public bool IsTypeContext { get; }
    public bool IsNamespaceContext { get; }
    public bool IsPreProcessorDirectiveContext { get; }
    public bool IsRightOfNameSeparator { get; }
    public bool IsStatementContext { get; }
    public bool IsAnyExpressionContext { get; }
    public bool IsAttributeNameContext { get; }
    public bool IsEnumTypeMemberAccessContext { get; }
    public bool IsNameOfContext { get; }
    public bool IsInQuery { get; }
    public bool IsInImportsDirective { get; }
    protected AbstractSyntaxContext(Workspace workspace, SemanticModel semanticModel, int position, SyntaxToken leftToken, SyntaxToken targetToken, bool isTypeContext, bool isNamespaceContext, bool isPreProcessorDirectiveContext, bool isRightOfNameSeparator, bool isStatementContext, bool isAnyExpressionContext, bool isAttributeNameContext, bool isEnumTypeMemberAccessContext, bool isNameOfContext, bool isInQuery, bool isInImportsDirective);
    [CompilerGeneratedAttribute]
public Workspace get_Workspace();
    [CompilerGeneratedAttribute]
public SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
public SyntaxTree get_SyntaxTree();
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public SyntaxToken get_LeftToken();
    [CompilerGeneratedAttribute]
public SyntaxToken get_TargetToken();
    [CompilerGeneratedAttribute]
public bool get_IsTypeContext();
    [CompilerGeneratedAttribute]
public bool get_IsNamespaceContext();
    [CompilerGeneratedAttribute]
public bool get_IsPreProcessorDirectiveContext();
    [CompilerGeneratedAttribute]
public bool get_IsRightOfNameSeparator();
    [CompilerGeneratedAttribute]
public bool get_IsStatementContext();
    [CompilerGeneratedAttribute]
public bool get_IsAnyExpressionContext();
    [CompilerGeneratedAttribute]
public bool get_IsAttributeNameContext();
    [CompilerGeneratedAttribute]
public bool get_IsEnumTypeMemberAccessContext();
    [CompilerGeneratedAttribute]
public bool get_IsNameOfContext();
    [CompilerGeneratedAttribute]
public bool get_IsInQuery();
    [CompilerGeneratedAttribute]
public bool get_IsInImportsDirective();
    private ISet`1<INamedTypeSymbol> ComputeOuterTypes(CancellationToken cancellationToken);
    public ISet`1<INamedTypeSymbol> GetOuterTypes(CancellationToken cancellationToken);
    public TService GetLanguageService();
    public TService GetWorkspaceService();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions : object {
    [ExtensionAttribute]
public static TLanguageService GetLanguageService(Document document);
    [ExtensionAttribute]
public static bool IsOpen(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetSemanticModelForSpanAsync>d__2")]
[ExtensionAttribute]
public static Task`1<SemanticModel> GetSemanticModelForSpanAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<SemanticModel> GetSemanticModelForNodeAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    private static Task`1<SemanticModel> GetSemanticModelForNodeAsync(ISemanticModelService semanticModelService, ISyntaxFactsService syntaxFactService, Document document, SyntaxNode node, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsFromPrimaryBranch(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<IsForkedDocumentWithSyntaxChangesAsync>d__6")]
[ExtensionAttribute]
public static Task`1<bool> IsForkedDocumentWithSyntaxChangesAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetDeclaredSymbolInfosAsync>d__7")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<DeclaredSymbolInfo>> GetDeclaredSymbolInfosAsync(Document document, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.FileLinePositionSpanExtensions : object {
    [ExtensionAttribute]
public static string GetMappedFilePathIfExist(FileLinePositionSpan fileLinePositionSpan);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IAssemblySymbolExtensions : object {
    private static string AttributeSuffix;
    [ExtensionAttribute]
public static bool ContainsNamespaceName(List`1<IAssemblySymbol> assemblies, string namespaceName);
    [ExtensionAttribute]
public static bool ContainsTypeName(List`1<IAssemblySymbol> assemblies, string typeName, bool tryWithAttributeSuffix);
    [ExtensionAttribute]
public static bool IsSameAssemblyOrHasFriendAccessTo(IAssemblySymbol assembly, IAssemblySymbol toAssembly);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ICodeDefinitionFactoryExtensions : object {
    private static string EqualsName;
    private static string DefaultName;
    private static string ObjName;
    private static string GetHashCodeName;
    [ExtensionAttribute]
public static SyntaxNode CreateThrowNotImplementStatement(SyntaxGenerator codeDefinitionFactory, Compilation compilation);
    [ExtensionAttribute]
public static IList`1<SyntaxNode> CreateThrowNotImplementedStatementBlock(SyntaxGenerator codeDefinitionFactory, Compilation compilation);
    [ExtensionAttribute]
public static IList`1<SyntaxNode> CreateArguments(SyntaxGenerator factory, ImmutableArray`1<IParameterSymbol> parameters);
    [ExtensionAttribute]
private static SyntaxNode CreateArgument(SyntaxGenerator factory, IParameterSymbol parameter);
    [ExtensionAttribute]
public static IMethodSymbol CreateBaseDelegatingConstructor(SyntaxGenerator factory, IMethodSymbol constructor, string typeName);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ICodeDefinitionFactoryExtensions/<CreateFieldDelegatingConstructor>d__5")]
[ExtensionAttribute]
public static IEnumerable`1<ISymbol> CreateFieldDelegatingConstructor(SyntaxGenerator factory, string typeName, INamedTypeSymbol containingTypeOpt, IList`1<IParameterSymbol> parameters, IDictionary`2<string, ISymbol> parameterToExistingFieldMap, IDictionary`2<string, string> parameterToNewFieldMap, CancellationToken cancellationToken);
    private static IList`1<SyntaxNode> GetThisConstructorArguments(INamedTypeSymbol containingTypeOpt, IDictionary`2<string, ISymbol> parameterToExistingFieldMap);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ICodeDefinitionFactoryExtensions/<CreateFieldsForParameters>d__7")]
[ExtensionAttribute]
public static IEnumerable`1<IFieldSymbol> CreateFieldsForParameters(SyntaxGenerator factory, IList`1<IParameterSymbol> parameters, IDictionary`2<string, string> parameterToNewFieldMap);
    private static bool TryGetValue(IDictionary`2<string, string> dictionary, string key, String& value);
    private static bool TryGetValue(IDictionary`2<string, ISymbol> dictionary, string key, String& value);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ICodeDefinitionFactoryExtensions/<CreateAssignmentStatements>d__10")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> CreateAssignmentStatements(SyntaxGenerator factory, IList`1<IParameterSymbol> parameters, IDictionary`2<string, ISymbol> parameterToExistingFieldMap, IDictionary`2<string, string> parameterToNewFieldMap);
    [ExtensionAttribute]
public static IPropertySymbol OverrideProperty(SyntaxGenerator codeFactory, IPropertySymbol overriddenProperty, DeclarationModifiers modifiers, INamedTypeSymbol containingType, Document document, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEventSymbol OverrideEvent(SyntaxGenerator codeFactory, IEventSymbol overriddenEvent, DeclarationModifiers modifiers, INamedTypeSymbol newContainingType);
    [ExtensionAttribute]
public static IMethodSymbol OverrideMethod(SyntaxGenerator codeFactory, IMethodSymbol overriddenMethod, DeclarationModifiers modifiers, INamedTypeSymbol newContainingType, Document newDocument, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMethodSymbol CreateEqualsMethod(SyntaxGenerator factory, Compilation compilation, INamedTypeSymbol containingType, IList`1<ISymbol> symbols, CancellationToken cancellationToken);
    private static IList`1<SyntaxNode> CreateEqualsMethodStatements(SyntaxGenerator factory, Compilation compilation, INamedTypeSymbol containingType, IEnumerable`1<ISymbol> members, CancellationToken cancellationToken);
    private static SyntaxNode GetDefaultEqualityComparer(SyntaxGenerator factory, Compilation compilation, ISymbol member);
    private static ITypeSymbol GetType(Compilation compilation, ISymbol symbol);
    private static bool HasExistingBaseEqualsMethod(INamedTypeSymbol containingType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMethodSymbol CreateGetHashCodeMethod(SyntaxGenerator factory, Compilation compilation, INamedTypeSymbol containingType, IList`1<ISymbol> symbols, CancellationToken cancellationToken);
    private static IList`1<SyntaxNode> CreateGetHashCodeMethodStatements(SyntaxGenerator factory, Compilation compilation, INamedTypeSymbol containingType, IList`1<ISymbol> members, CancellationToken cancellationToken);
    private static SyntaxNode ComputeHashValue(SyntaxGenerator factory, Compilation compilation, ISymbol member);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ICollectionExtensions : object {
    [ExtensionAttribute]
public static void RemoveRange(ICollection`1<T> collection, IEnumerable`1<T> items);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IComparerExtensions : object {
    [ExtensionAttribute]
public static IComparer`1<T> Inverse(IComparer`1<T> comparer);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ICompilationExtensions : object {
    [ExtensionAttribute]
public static INamedTypeSymbol AttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ExceptionType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol DesignerCategoryAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol DesignerGeneratedAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol HideModuleNameAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol EventArgsType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol NotImplementedExceptionType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol EqualityComparerOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ActionType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ExpressionOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol EditorBrowsableAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol EditorBrowsableStateType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol TaskType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol TaskOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol SerializableAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol CoClassType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ComAliasNameAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol SuppressMessageAttributeType(Compilation compilation);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IEnumerableExtensions : object {
    [ExtensionAttribute]
public static Task`1<IEnumerable`1<S>> SelectManyAsync(IEnumerable`1<T> sequence, Func`3<T, CancellationToken, Task`1<IEnumerable`1<S>>> selector, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IFindReferencesResultExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<ReferencedSymbol> FilterUnreferencedSyntheticDefinitions(IEnumerable`1<ReferencedSymbol> result);
    private static bool ShouldKeep(ReferencedSymbol r);
    [ExtensionAttribute]
public static IEnumerable`1<ReferencedSymbol> FilterToAliasMatches(IEnumerable`1<ReferencedSymbol> result, IAliasSymbol aliasSymbolOpt);
    [ExtensionAttribute]
public static IEnumerable`1<ReferencedSymbol> FilterNonMatchingMethodNames(IEnumerable`1<ReferencedSymbol> result, Solution solution, ISymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.IFindReferencesResultExtensions/<FilterNonMatchingMethodNamesWorker>d__4")]
private static IEnumerable`1<ReferencedSymbol> FilterNonMatchingMethodNamesWorker(IEnumerable`1<ReferencedSymbol> result, Solution solution, ISymbol symbol);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ILanguageMetadataExtensions : object {
    [ExtensionAttribute]
public static TInterface ToSpecificLanguage(IEnumerable`1<Lazy`2<TInterface, TMetadata>> services, string languageName);
    [ExtensionAttribute]
public static IEnumerable`1<TInterface> FilterToSpecificLanguage(IEnumerable`1<Lazy`2<TInterface, TMetadata>> services, string languageName);
    [ExtensionAttribute]
public static Dictionary`2<string, List`1<Lazy`2<TInterface, TMetadata>>> ToPerLanguageMap(IEnumerable`1<Lazy`2<TInterface, TMetadata>> services);
    [ExtensionAttribute]
public static Dictionary`2<string, List`1<Lazy`2<TInterface, TMetadata>>> ToPerLanguageMapWithMultipleLanguages(IEnumerable`1<Lazy`2<TInterface, TMetadata>> services);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ILanguageServiceProviderExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Lazy`2<T, TMetadata>> SelectMatchingExtensions(HostLanguageServices serviceProvider, IEnumerable`1<Lazy`2<T, TMetadata>> items);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IListExtensions : object {
    [ExtensionAttribute]
public static int IndexOf(IList`1<T> list, Func`2<T, bool> predicate);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IMethodSymbolExtensions : object {
    [ExtensionAttribute]
public static bool CompatibleSignatureToDelegate(IMethodSymbol method, INamedTypeSymbol delegateType);
    [ExtensionAttribute]
public static IMethodSymbol RenameTypeParameters(IMethodSymbol method, IList`1<string> newNames);
    [ExtensionAttribute]
public static IMethodSymbol RenameParameters(IMethodSymbol method, IList`1<string> parameterNames);
    private static IList`1<ITypeParameterSymbol> RenameTypeParameters(IList`1<ITypeParameterSymbol> typeParameters, IList`1<string> newNames, ITypeGenerator typeGenerator);
    [ExtensionAttribute]
public static IMethodSymbol EnsureNonConflictingNames(IMethodSymbol method, INamedTypeSymbol containingType, ISyntaxFactsService syntaxFacts, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMethodSymbol RemoveInaccessibleAttributesAndAttributesOfType(IMethodSymbol method, ISymbol accessibleWithin, INamedTypeSymbol removeAttributeType, IList`1<SyntaxNode> statements, IList`1<SyntaxNode> handlesExpressions);
    [ExtensionAttribute]
private static IMethodSymbol RemoveAttributesCore(IMethodSymbol method, Func`2<AttributeData, bool> shouldRemoveAttribute, IList`1<SyntaxNode> statements, IList`1<SyntaxNode> handlesExpressions);
    [ExtensionAttribute]
public static Nullable`1<bool> IsMoreSpecificThan(IMethodSymbol method1, IMethodSymbol method2);
    [ExtensionAttribute]
public static bool TryGetPredefinedComparisonOperator(IMethodSymbol symbol, PredefinedOperator& op);
    [ExtensionAttribute]
public static PredefinedOperator GetPredefinedOperator(IMethodSymbol symbol);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.INamedTypeSymbolExtensions : object {
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.INamedTypeSymbolExtensions/<GetBaseTypesAndThis>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetBaseTypesAndThis(INamedTypeSymbol namedType);
    [ExtensionAttribute]
public static Task`1<IEnumerable`1<INamedTypeSymbol>> FindDerivedClassesAsync(INamedTypeSymbol type, Solution solution, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IEnumerable`1<INamedTypeSymbol>> FindDerivedClassesAsync(INamedTypeSymbol type, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IEnumerable`1<INamedTypeSymbol>> FindDerivedInterfacesAsync(INamedTypeSymbol type, Solution solution, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IEnumerable`1<INamedTypeSymbol>> FindDerivedInterfacesAsync(INamedTypeSymbol type, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<IEnumerable`1<INamedTypeSymbol>> FindImplementingTypesAsync(INamedTypeSymbol type, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<ITypeParameterSymbol> GetAllTypeParameters(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetAllTypeArguments(INamedTypeSymbol symbol);
    private static Stack`1<INamedTypeSymbol> GetContainmentStack(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsContainedWithin(INamedTypeSymbol symbol, INamedTypeSymbol outer);
    [ExtensionAttribute]
public static ISymbol FindImplementationForAbstractMember(INamedTypeSymbol type, ISymbol symbol);
    private static ISymbol GetOverriddenMember(ISymbol symbol);
    private static bool ImplementationExists(INamedTypeSymbol classOrStructType, ISymbol member);
    [ExtensionAttribute]
private static bool IsImplemented(INamedTypeSymbol classOrStructType, ISymbol member, Func`3<INamedTypeSymbol, ISymbol, bool> isValidImplementation, CancellationToken cancellationToken);
    private static bool IsInterfacePropertyImplemented(INamedTypeSymbol classOrStructType, IPropertySymbol propertySymbol, CancellationToken cancellationToken);
    private static bool IsAbstractPropertyImplemented(INamedTypeSymbol classOrStructType, IPropertySymbol propertySymbol, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static bool IsExplicitlyImplemented(INamedTypeSymbol classOrStructType, ISymbol member, Func`3<INamedTypeSymbol, ISymbol, bool> isValid, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IList`1<Tuple`2<INamedTypeSymbol, IList`1<ISymbol>>> GetAllUnimplementedMembers(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfacesOrAbstractClasses, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IList`1<Tuple`2<INamedTypeSymbol, IList`1<ISymbol>>> GetAllUnimplementedMembersInThis(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfacesOrAbstractClasses, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IList`1<Tuple`2<INamedTypeSymbol, IList`1<ISymbol>>> GetAllUnimplementedMembersInThis(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfacesOrAbstractClasses, Func`3<INamedTypeSymbol, ISymbol, ImmutableArray`1<ISymbol>> interfaceMemberGetter, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IList`1<Tuple`2<INamedTypeSymbol, IList`1<ISymbol>>> GetAllUnimplementedMembers(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfacesOrAbstractClasses, Func`3<INamedTypeSymbol, ISymbol, ImmutableArray`1<ISymbol>> interfaceMemberGetter, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IList`1<Tuple`2<INamedTypeSymbol, IList`1<ISymbol>>> GetAllUnimplementedExplicitMembers(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfaces, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IList`1<Tuple`2<INamedTypeSymbol, IList`1<ISymbol>>> GetAllUnimplementedExplicitMembers(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfaces, Func`3<INamedTypeSymbol, ISymbol, ImmutableArray`1<ISymbol>> interfaceMemberGetter, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static IList`1<Tuple`2<INamedTypeSymbol, IList`1<ISymbol>>> GetAllUnimplementedMembers(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfacesOrAbstractClasses, Func`5<INamedTypeSymbol, ISymbol, Func`3<INamedTypeSymbol, ISymbol, bool>, CancellationToken, bool> isImplemented, Func`3<INamedTypeSymbol, ISymbol, bool> isValidImplementation, Func`3<INamedTypeSymbol, ISymbol, ImmutableArray`1<ISymbol>> interfaceMemberGetter, bool allowReimplementation, CancellationToken cancellationToken);
    private static IList`1<INamedTypeSymbol> GetTypesToImplement(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfacesOrAbstractClasses, bool allowReimplementation, CancellationToken cancellationToken);
    private static IList`1<INamedTypeSymbol> GetAbstractClassesToImplement(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> abstractClasses, CancellationToken cancellationToken);
    private static IList`1<INamedTypeSymbol> GetInterfacesToImplement(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfaces, bool allowReimplementation, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static IList`1<ISymbol> GetUnimplementedMembers(INamedTypeSymbol classOrStructType, INamedTypeSymbol interfaceType, Func`5<INamedTypeSymbol, ISymbol, Func`3<INamedTypeSymbol, ISymbol, bool>, CancellationToken, bool> isImplemented, Func`3<INamedTypeSymbol, ISymbol, bool> isValidImplementation, Func`3<INamedTypeSymbol, ISymbol, ImmutableArray`1<ISymbol>> interfaceMemberGetter, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.INamedTypeSymbolExtensions/<GetAttributeNamedParameters>d__28")]
[ExtensionAttribute]
public static IEnumerable`1<ISymbol> GetAttributeNamedParameters(INamedTypeSymbol attributeSymbol, Compilation compilation, ISymbol within);
    private static ISymbol IsAttributeNamedParameter(ISymbol symbol, ISymbol within);
    private static ImmutableArray`1<ISymbol> GetMembers(INamedTypeSymbol type, ISymbol within);
    [ExtensionAttribute]
public static INamespaceOrTypeSymbol GenerateRootNamespaceOrType(INamedTypeSymbol namedType, String[] containers);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.INamespaceOrTypeSymbolExtensions : object {
    private static ConditionalWeakTable`2<INamespaceOrTypeSymbol, List`1<string>> s_namespaceOrTypeToNameMap;
    private static SymbolDisplayFormat s_shortNameFormat;
    public static Comparison`1<INamespaceOrTypeSymbol> CompareNamespaceOrTypeSymbols;
    private static INamespaceOrTypeSymbolExtensions();
    [ExtensionAttribute]
public static string GetShortName(INamespaceOrTypeSymbol symbol);
    [ExtensionAttribute]
public static IEnumerable`1<IPropertySymbol> GetIndexers(INamespaceOrTypeSymbol symbol);
    [ExtensionAttribute]
public static int CompareTo(INamespaceOrTypeSymbol n1, INamespaceOrTypeSymbol n2);
    private static List`1<string> GetNameParts(INamespaceOrTypeSymbol namespaceSymbol);
    private static void GetNameParts(INamespaceOrTypeSymbol namespaceOrTypeSymbol, List`1<string> result);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.INamespaceSymbolExtensions : object {
    private static ConditionalWeakTable`2<INamespaceSymbol, List`1<string>> s_namespaceToNameMap;
    private static CreateValueCallback<INamespaceSymbol, List`1<string>> s_getNameParts;
    public static Comparison`1<INamespaceSymbol> CompareNamespaces;
    public static IEqualityComparer`1<INamespaceSymbol> EqualityComparer;
    private static INamespaceSymbolExtensions();
    private static List`1<string> GetNameParts(INamespaceSymbol namespaceSymbol);
    private static void GetNameParts(INamespaceSymbol namespaceSymbol, List`1<string> result);
    [ExtensionAttribute]
public static int CompareTo(INamespaceSymbol n1, INamespaceSymbol n2);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.INamespaceSymbolExtensions/<GetAllTypes>d__8")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetAllTypes(INamespaceSymbol namespaceSymbol, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.INamespaceSymbolExtensions/<GetAllNamespacesAndTypes>d__9")]
[ExtensionAttribute]
public static IEnumerable`1<INamespaceOrTypeSymbol> GetAllNamespacesAndTypes(INamespaceSymbol namespaceSymbol, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetAllTypes(IEnumerable`1<INamespaceSymbol> namespaceSymbols, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.INamespaceSymbolExtensions/<FindNamespaces>d__11")]
[ExtensionAttribute]
public static IEnumerable`1<INamespaceSymbol> FindNamespaces(INamespaceSymbol namespaceSymbol, string namespaceName, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ContainsAccessibleTypesOrNamespaces(INamespaceSymbol namespaceSymbol, IAssemblySymbol assembly);
    [ExtensionAttribute]
private static bool ContainsAccessibleTypesOrNamespacesWorker(INamespaceSymbol namespaceSymbol, IAssemblySymbol assembly, Queue`1<INamespaceOrTypeSymbol> namespaceQueue);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IParameterSymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsRefOrOut(IParameterSymbol symbol);
    [ExtensionAttribute]
public static IParameterSymbol RenameParameter(IParameterSymbol parameter, string parameterName);
    [ExtensionAttribute]
public static IList`1<IParameterSymbol> RenameParameters(IList`1<IParameterSymbol> parameters, IList`1<string> parameterNames);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IPropertySymbolExtensions : object {
    [ExtensionAttribute]
public static IPropertySymbol RenameParameters(IPropertySymbol property, IList`1<string> parameterNames);
    [ExtensionAttribute]
public static IPropertySymbol RemoveAttributeFromParameters(IPropertySymbol property, INamedTypeSymbol attributeType);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ISolutionExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ISolutionExtensions/<GetGlobalNamespacesAsync>d__0")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<INamespaceSymbol>> GetGlobalNamespacesAsync(Solution solution, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ISolutionExtensions/<GetChangedDocuments>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<DocumentId> GetChangedDocuments(Solution newSolution, Solution oldSolution);
    [ExtensionAttribute]
public static TextDocument GetTextDocument(Solution solution, DocumentId documentId);
    [ExtensionAttribute]
public static Solution WithTextDocumentText(Solution solution, DocumentId documentId, SourceText text, PreservationMode mode);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions : object {
    private static int TypeLibTypeFlagsFHidden;
    private static int TypeLibFuncFlagsFHidden;
    private static int TypeLibVarFlagsFHidden;
    [ExtensionAttribute]
public static string ToNameDisplayString(ISymbol symbol);
    [ExtensionAttribute]
public static string ToSignatureDisplayString(ISymbol symbol);
    [ExtensionAttribute]
public static SymbolVisibility GetResultantVisibility(ISymbol symbol);
    [ExtensionAttribute]
public static ISymbol OverriddenMember(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> ExplicitInterfaceImplementations(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsOverridable(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsImplementable(ISymbol symbol);
    [ExtensionAttribute]
public static INamedTypeSymbol GetContainingTypeOrThis(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsPointerType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsErrorType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsModuleType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsInterfaceType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsArrayType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAnonymousFunction(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsKind(ISymbol symbol, SymbolKind kind);
    [ExtensionAttribute]
public static bool MatchesKind(ISymbol symbol, SymbolKind kind);
    [ExtensionAttribute]
public static bool MatchesKind(ISymbol symbol, SymbolKind kind1, SymbolKind kind2);
    [ExtensionAttribute]
public static bool MatchesKind(ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3);
    [ExtensionAttribute]
public static bool MatchesKind(ISymbol symbol, SymbolKind[] kinds);
    [ExtensionAttribute]
public static bool IsReducedExtension(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsExtensionMethod(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsModuleMember(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsConstructor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsStaticConstructor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsDestructor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsUserDefinedOperator(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsConversion(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsOrdinaryMethod(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsDelegateType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAnonymousType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsNormalAnonymousType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAnonymousDelegateType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAnonymousTypeProperty(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsIndexer(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsWriteableFieldOrProperty(ISymbol symbol);
    [ExtensionAttribute]
public static ITypeSymbol GetMemberType(ISymbol symbol);
    [ExtensionAttribute]
public static int GetArity(ISymbol symbol);
    [ExtensionAttribute]
public static ISymbol GetOriginalUnreducedDefinition(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsFunctionValue(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsThisParameter(ISymbol symbol);
    [ExtensionAttribute]
public static ISymbol ConvertThisParameterToType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsParams(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<ITypeSymbol> GetTypeArguments(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<ITypeSymbol> GetAllTypeArguments(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAttribute(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsUnsafe(ISymbol member);
    [ExtensionAttribute]
public static ITypeSymbol ConvertToType(ISymbol symbol, Compilation compilation, bool extensionUsedAsInstance);
    [ExtensionAttribute]
public static bool IsDeprecated(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsStaticType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsNamespace(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsOrContainsAccessibleAttribute(ISymbol symbol, ISymbol withinType, IAssemblySymbol withinAssembly);
    [ExtensionAttribute]
public static IEnumerable`1<IPropertySymbol> GetValidAnonymousTypeProperties(ISymbol symbol);
    [ExtensionAttribute]
public static Accessibility ComputeResultantAccessibility(ISymbol symbol, ITypeSymbol finalDestination);
    [ExtensionAttribute]
public static bool IsInaccessibleLocal(ISymbol symbol, int position);
    [ExtensionAttribute]
public static bool IsEditorBrowsable(ISymbol symbol, bool hideAdvancedMembers, Compilation compilation, IMethodSymbol editorBrowsableAttributeConstructor, List`1<IMethodSymbol> typeLibTypeAttributeConstructors, List`1<IMethodSymbol> typeLibFuncAttributeConstructors, List`1<IMethodSymbol> typeLibVarAttributeConstructors, INamedTypeSymbol hideModuleNameAttribute);
    private static bool IsBrowsingProhibited(ISymbol symbol, bool hideAdvancedMembers, Compilation compilation, IMethodSymbol editorBrowsableAttributeConstructor, List`1<IMethodSymbol> typeLibTypeAttributeConstructors, List`1<IMethodSymbol> typeLibFuncAttributeConstructors, List`1<IMethodSymbol> typeLibVarAttributeConstructors, INamedTypeSymbol hideModuleNameAttribute);
    private static bool IsBrowsingProhibitedByHideModuleNameAttribute(ISymbol symbol, Compilation compilation, INamedTypeSymbol hideModuleNameAttribute, ImmutableArray`1<AttributeData> attributes);
    private static bool IsBrowsingProhibitedByEditorBrowsableAttribute(ISymbol symbol, ImmutableArray`1<AttributeData> attributes, bool hideAdvancedMembers, Compilation compilation, IMethodSymbol constructor);
    private static bool IsBrowsingProhibitedByTypeLibTypeAttribute(ISymbol symbol, ImmutableArray`1<AttributeData> attributes, Compilation compilation, List`1<IMethodSymbol> constructors);
    private static bool IsBrowsingProhibitedByTypeLibFuncAttribute(ISymbol symbol, ImmutableArray`1<AttributeData> attributes, Compilation compilation, List`1<IMethodSymbol> constructors);
    private static bool IsBrowsingProhibitedByTypeLibVarAttribute(ISymbol symbol, ImmutableArray`1<AttributeData> attributes, Compilation compilation, List`1<IMethodSymbol> constructors);
    private static bool IsBrowsingProhibitedByTypeLibAttributeWorker(ISymbol symbol, ImmutableArray`1<AttributeData> attributes, List`1<IMethodSymbol> attributeConstructors, int hiddenFlag);
    [ExtensionAttribute]
public static bool IsAccessor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsPropertyAccessor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsEventAccessor(ISymbol symbol);
    [ExtensionAttribute]
public static DeclarationModifiers GetSymbolModifiers(ISymbol symbol);
    [ExtensionAttribute]
public static ITypeSymbol GetSymbolType(ISymbol symbol);
    [ExtensionAttribute]
public static DocumentationComment GetDocumentationComment(ISymbol symbol, CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsAwaitable(ISymbol symbol, SemanticModel semanticModel, int position);
    private static bool VerifyGetAwaiter(IMethodSymbol getAwaiter);
    [ExtensionAttribute]
public static IList`1<SymbolDisplayPart> ToAwaitableParts(ISymbol symbol, string awaitKeyword, string initializedVariableName, SemanticModel semanticModel, int position);
    [ExtensionAttribute]
public static ITypeSymbol InferAwaitableReturnType(ISymbol symbol, SemanticModel semanticModel, int position);
    [ExtensionAttribute]
public static IEnumerable`1<T> FilterToVisibleAndBrowsableSymbols(IEnumerable`1<T> symbols, bool hideAdvancedMembers, Compilation compilation);
    [ExtensionAttribute]
private static IEnumerable`1<T> RemoveOverriddenSymbolsWithinSet(IEnumerable`1<T> symbols);
    [ExtensionAttribute]
public static IEnumerable`1<T> FilterToVisibleAndBrowsableSymbolsAndNotUnsafeSymbols(IEnumerable`1<T> symbols, bool hideAdvancedMembers, Compilation compilation);
    [ExtensionAttribute]
public static bool IsValueParameter(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAccessibleWithin(ISymbol symbol, ISymbol within, ITypeSymbol throughTypeOpt);
    [ExtensionAttribute]
public static bool IsAccessibleWithin(ISymbol symbol, IAssemblySymbol within, ITypeSymbol throughTypeOpt);
    [ExtensionAttribute]
public static bool IsAccessibleWithin(ISymbol symbol, INamedTypeSymbol within, ITypeSymbol throughTypeOpt);
    private static bool IsSymbolAccessible(ISymbol symbol, INamedTypeSymbol within, ITypeSymbol throughTypeOpt, Boolean& failedThroughTypeCheck);
    private static bool IsSymbolAccessibleCore(ISymbol symbol, ISymbol within, ITypeSymbol throughTypeOpt, Boolean& failedThroughTypeCheck);
    private static bool IsNamedTypeAccessible(INamedTypeSymbol type, ISymbol within);
    private static bool IsNonNestedTypeAccessible(IAssemblySymbol assembly, Accessibility declaredAccessibility, ISymbol within);
    private static bool IsMemberAccessible(INamedTypeSymbol containingType, Accessibility declaredAccessibility, ISymbol within, ITypeSymbol throughTypeOpt, Boolean& failedThroughTypeCheck);
    private static bool IsProtectedSymbolAccessible(INamedTypeSymbol withinType, IAssemblySymbol withinAssembly, ITypeSymbol throughTypeOpt, INamedTypeSymbol originalContainingType, Boolean& failedThroughTypeCheck);
    private static bool IsPrivateSymbolAccessible(ISymbol within, INamedTypeSymbol originalContainingType);
    private static bool IsNestedWithinOriginalContainingType(INamedTypeSymbol withinType, INamedTypeSymbol originalContainingType);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ISyntaxFactsServiceExtensions : object {
    [ExtensionAttribute]
public static bool IsWord(ISyntaxFactsService syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsAnyMemberAccessExpression(ISyntaxFactsService syntaxFacts, SyntaxNode node);
}
internal interface Microsoft.CodeAnalysis.Shared.Extensions.ITypeGenerator {
    public abstract virtual ITypeSymbol CreateArrayTypeSymbol(ITypeSymbol elementType, int rank);
    public abstract virtual ITypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType);
    public abstract virtual ITypeSymbol Construct(INamedTypeSymbol namedType, ITypeSymbol[] typeArguments);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ITypeInferenceServiceExtensions : object {
    [ExtensionAttribute]
public static INamedTypeSymbol InferDelegateType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol InferType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, SyntaxNode expression, bool objectAsDefault, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol InferType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, int position, bool objectAsDefault, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ITypeParameterSymbolExtensions : object {
    [ExtensionAttribute]
public static INamedTypeSymbol GetNamedTypeSymbolConstraint(ITypeParameterSymbol typeParameter);
    private static INamedTypeSymbol GetNamedTypeSymbol(ITypeSymbol type);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions : object {
    private static string DefaultParameterName;
    private static string DefaultBuiltInParameterName;
    [ExtensionAttribute]
public static IList`1<INamedTypeSymbol> GetAllInterfacesIncludingThis(ITypeSymbol type);
    [ExtensionAttribute]
public static bool IsAbstractClass(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsSystemVoid(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsNullable(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsErrorType(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsModuleType(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsInterfaceType(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsDelegateType(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsAnonymousType(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static ITypeSymbol RemoveNullableIfPresent(ITypeSymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions/<FindImplementationsForInterfaceMember>d__16")]
[ExtensionAttribute]
public static IEnumerable`1<ISymbol> FindImplementationsForInterfaceMember(ITypeSymbol typeSymbol, ISymbol interfaceMember, Workspace workspace, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static HashSet`1<INamedTypeSymbol> GetOriginalInterfacesAndTheirBaseInterfaces(ITypeSymbol type, HashSet`1<INamedTypeSymbol> symbols);
    private static ISymbol FindImplementations(ITypeSymbol typeSymbol, TSymbol interfaceSymbol, Workspace workspace, Func`2<TSymbol, ImmutableArray`1<TSymbol>> getExplicitInterfaceImplementations);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions/<GetBaseTypesAndThis>d__19")]
[ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetBaseTypesAndThis(ITypeSymbol type);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions/<GetBaseTypes>d__20")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetBaseTypes(ITypeSymbol type);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions/<GetContainingTypesAndThis>d__21")]
[ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetContainingTypesAndThis(ITypeSymbol type);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions/<GetContainingTypes>d__22")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetContainingTypes(ITypeSymbol type);
    [ExtensionAttribute]
public static bool InheritsFromOrEquals(ITypeSymbol type, ITypeSymbol baseType);
    [ExtensionAttribute]
public static bool InheritsFromOrEqualsIgnoringConstruction(ITypeSymbol type, ITypeSymbol baseType);
    [ExtensionAttribute]
public static bool InheritsFromIgnoringConstruction(ITypeSymbol type, ITypeSymbol baseType);
    [ExtensionAttribute]
public static bool ImplementsIgnoringConstruction(ITypeSymbol type, ITypeSymbol interfaceType);
    [ExtensionAttribute]
public static bool Implements(ITypeSymbol type, ITypeSymbol interfaceType);
    [ExtensionAttribute]
public static bool IsAttribute(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsFormattableString(ITypeSymbol symbol);
    [ExtensionAttribute]
public static ITypeSymbol RemoveUnavailableTypeParameters(ITypeSymbol type, Compilation compilation, IEnumerable`1<ITypeParameterSymbol> availableTypeParameters);
    [ExtensionAttribute]
private static ITypeSymbol RemoveUnavailableTypeParameters(ITypeSymbol type, Compilation compilation, ISet`1<string> availableTypeParameterNames);
    [ExtensionAttribute]
public static ITypeSymbol RemoveAnonymousTypes(ITypeSymbol type, Compilation compilation);
    [ExtensionAttribute]
public static ITypeSymbol ReplaceTypeParametersBasedOnTypeConstraints(ITypeSymbol type, Compilation compilation, IEnumerable`1<ITypeParameterSymbol> availableTypeParameters, Solution solution, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol RemoveUnnamedErrorTypes(ITypeSymbol type, Compilation compilation);
    [ExtensionAttribute]
public static IList`1<ITypeParameterSymbol> GetReferencedMethodTypeParameters(ITypeSymbol type, IList`1<ITypeParameterSymbol> result);
    [ExtensionAttribute]
public static IList`1<ITypeParameterSymbol> GetReferencedTypeParameters(ITypeSymbol type, IList`1<ITypeParameterSymbol> result);
    [ExtensionAttribute]
public static ITypeSymbol SubstituteTypes(ITypeSymbol type, IDictionary`2<TType1, TType2> mapping, Compilation compilation);
    [ExtensionAttribute]
public static ITypeSymbol SubstituteTypes(ITypeSymbol type, IDictionary`2<TType1, TType2> mapping, ITypeGenerator typeGenerator);
    [ExtensionAttribute]
public static bool IsUnexpressableTypeParameterConstraint(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsNumericType(ITypeSymbol type);
    [ExtensionAttribute]
public static Accessibility DetermineMinimalAccessibility(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool ContainsAnonymousType(ITypeSymbol symbol);
    private static bool ContainsAnonymousType(INamedTypeSymbol type);
    [ExtensionAttribute]
public static string CreateParameterName(ITypeSymbol type, bool capitalize);
    private static string GetParameterName(ITypeSymbol type);
    [ExtensionAttribute]
public static bool IsSpecialType(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool CanSupportCollectionInitializer(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static INamedTypeSymbol GetDelegateType(ITypeSymbol typeSymbol, Compilation compilation);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAccessibleMembersInBaseTypes(ITypeSymbol containingType, ISymbol within);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAccessibleMembersInThisAndBaseTypes(ITypeSymbol containingType, ISymbol within);
    [ExtensionAttribute]
public static Nullable`1<bool> AreMoreSpecificThan(IList`1<ITypeSymbol> t1, IList`1<ITypeSymbol> t2);
    [ExtensionAttribute]
private static Nullable`1<bool> IsMoreSpecificThan(ITypeSymbol t1, ITypeSymbol t2);
    [ExtensionAttribute]
public static bool IsOrDerivesFromExceptionType(ITypeSymbol type, Compilation compilation);
    [ExtensionAttribute]
public static bool IsEnumType(ITypeSymbol type);
}
internal class Microsoft.CodeAnalysis.Shared.Extensions.LineSpan : ValueType {
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <End>k__BackingField;
    public int Start { get; private set; }
    public int End { get; private set; }
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
private void set_Start(int value);
    [CompilerGeneratedAttribute]
public int get_End();
    [CompilerGeneratedAttribute]
private void set_End(int value);
    public static LineSpan FromBounds(int start, int end);
    public sealed virtual bool Equals(LineSpan other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.LinkedListExtensions : object {
    [ExtensionAttribute]
public static void AddRangeAtHead(LinkedList`1<T> list, IEnumerable`1<T> values);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ObjectExtensions : object {
    [ExtensionAttribute]
public static string GetTypeDisplayName(object obj);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TDerivedType15> matchAction15, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TDerivedType15> matchAction15, Action`1<TDerivedType16> matchAction16, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TDerivedType15> matchAction15, Action`1<TDerivedType16> matchAction16, Action`1<TDerivedType17> matchAction17, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TDerivedType15> matchAction15, Action`1<TDerivedType16> matchAction16, Action`1<TDerivedType17> matchAction17, Action`1<TDerivedType18> matchAction18, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TDerivedType15> matchAction15, Action`1<TDerivedType16> matchAction16, Action`1<TDerivedType17> matchAction17, Action`1<TDerivedType18> matchAction18, Action`1<TDerivedType19> matchAction19, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TDerivedType15> matchAction15, Action`1<TDerivedType16> matchAction16, Action`1<TDerivedType17> matchAction17, Action`1<TDerivedType18> matchAction18, Action`1<TDerivedType19> matchAction19, Action`1<TDerivedType20> matchAction20, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TDerivedType15> matchAction15, Action`1<TDerivedType16> matchAction16, Action`1<TDerivedType17> matchAction17, Action`1<TDerivedType18> matchAction18, Action`1<TDerivedType19> matchAction19, Action`1<TDerivedType20> matchAction20, Action`1<TDerivedType21> matchAction21, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TDerivedType15> matchAction15, Action`1<TDerivedType16> matchAction16, Action`1<TDerivedType17> matchAction17, Action`1<TDerivedType18> matchAction18, Action`1<TDerivedType19> matchAction19, Action`1<TDerivedType20> matchAction20, Action`1<TDerivedType21> matchAction21, Action`1<TDerivedType22> matchAction22, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TDerivedType15> matchAction15, Action`1<TDerivedType16> matchAction16, Action`1<TDerivedType17> matchAction17, Action`1<TDerivedType18> matchAction18, Action`1<TDerivedType19> matchAction19, Action`1<TDerivedType20> matchAction20, Action`1<TDerivedType21> matchAction21, Action`1<TDerivedType22> matchAction22, Action`1<TDerivedType23> matchAction23, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TDerivedType15> matchAction15, Action`1<TDerivedType16> matchAction16, Action`1<TDerivedType17> matchAction17, Action`1<TDerivedType18> matchAction18, Action`1<TDerivedType19> matchAction19, Action`1<TDerivedType20> matchAction20, Action`1<TDerivedType21> matchAction21, Action`1<TDerivedType22> matchAction22, Action`1<TDerivedType23> matchAction23, Action`1<TDerivedType24> matchAction24, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TDerivedType15> matchAction15, Action`1<TDerivedType16> matchAction16, Action`1<TDerivedType17> matchAction17, Action`1<TDerivedType18> matchAction18, Action`1<TDerivedType19> matchAction19, Action`1<TDerivedType20> matchAction20, Action`1<TDerivedType21> matchAction21, Action`1<TDerivedType22> matchAction22, Action`1<TDerivedType23> matchAction23, Action`1<TDerivedType24> matchAction24, Action`1<TDerivedType25> matchAction25, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TDerivedType15> matchAction15, Action`1<TDerivedType16> matchAction16, Action`1<TDerivedType17> matchAction17, Action`1<TDerivedType18> matchAction18, Action`1<TDerivedType19> matchAction19, Action`1<TDerivedType20> matchAction20, Action`1<TDerivedType21> matchAction21, Action`1<TDerivedType22> matchAction22, Action`1<TDerivedType23> matchAction23, Action`1<TDerivedType24> matchAction24, Action`1<TDerivedType25> matchAction25, Action`1<TDerivedType26> matchAction26, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TDerivedType15> matchAction15, Action`1<TDerivedType16> matchAction16, Action`1<TDerivedType17> matchAction17, Action`1<TDerivedType18> matchAction18, Action`1<TDerivedType19> matchAction19, Action`1<TDerivedType20> matchAction20, Action`1<TDerivedType21> matchAction21, Action`1<TDerivedType22> matchAction22, Action`1<TDerivedType23> matchAction23, Action`1<TDerivedType24> matchAction24, Action`1<TDerivedType25> matchAction25, Action`1<TDerivedType26> matchAction26, Action`1<TDerivedType27> matchAction27, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TDerivedType15> matchAction15, Action`1<TDerivedType16> matchAction16, Action`1<TDerivedType17> matchAction17, Action`1<TDerivedType18> matchAction18, Action`1<TDerivedType19> matchAction19, Action`1<TDerivedType20> matchAction20, Action`1<TDerivedType21> matchAction21, Action`1<TDerivedType22> matchAction22, Action`1<TDerivedType23> matchAction23, Action`1<TDerivedType24> matchAction24, Action`1<TDerivedType25> matchAction25, Action`1<TDerivedType26> matchAction26, Action`1<TDerivedType27> matchAction27, Action`1<TDerivedType28> matchAction28, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TDerivedType15> matchAction15, Action`1<TDerivedType16> matchAction16, Action`1<TDerivedType17> matchAction17, Action`1<TDerivedType18> matchAction18, Action`1<TDerivedType19> matchAction19, Action`1<TDerivedType20> matchAction20, Action`1<TDerivedType21> matchAction21, Action`1<TDerivedType22> matchAction22, Action`1<TDerivedType23> matchAction23, Action`1<TDerivedType24> matchAction24, Action`1<TDerivedType25> matchAction25, Action`1<TDerivedType26> matchAction26, Action`1<TDerivedType27> matchAction27, Action`1<TDerivedType28> matchAction28, Action`1<TDerivedType29> matchAction29, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TDerivedType15> matchAction15, Action`1<TDerivedType16> matchAction16, Action`1<TDerivedType17> matchAction17, Action`1<TDerivedType18> matchAction18, Action`1<TDerivedType19> matchAction19, Action`1<TDerivedType20> matchAction20, Action`1<TDerivedType21> matchAction21, Action`1<TDerivedType22> matchAction22, Action`1<TDerivedType23> matchAction23, Action`1<TDerivedType24> matchAction24, Action`1<TDerivedType25> matchAction25, Action`1<TDerivedType26> matchAction26, Action`1<TDerivedType27> matchAction27, Action`1<TDerivedType28> matchAction28, Action`1<TDerivedType29> matchAction29, Action`1<TDerivedType30> matchAction30, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TDerivedType15> matchAction15, Action`1<TDerivedType16> matchAction16, Action`1<TDerivedType17> matchAction17, Action`1<TDerivedType18> matchAction18, Action`1<TDerivedType19> matchAction19, Action`1<TDerivedType20> matchAction20, Action`1<TDerivedType21> matchAction21, Action`1<TDerivedType22> matchAction22, Action`1<TDerivedType23> matchAction23, Action`1<TDerivedType24> matchAction24, Action`1<TDerivedType25> matchAction25, Action`1<TDerivedType26> matchAction26, Action`1<TDerivedType27> matchAction27, Action`1<TDerivedType28> matchAction28, Action`1<TDerivedType29> matchAction29, Action`1<TDerivedType30> matchAction30, Action`1<TDerivedType31> matchAction31, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TDerivedType15> matchAction15, Action`1<TDerivedType16> matchAction16, Action`1<TDerivedType17> matchAction17, Action`1<TDerivedType18> matchAction18, Action`1<TDerivedType19> matchAction19, Action`1<TDerivedType20> matchAction20, Action`1<TDerivedType21> matchAction21, Action`1<TDerivedType22> matchAction22, Action`1<TDerivedType23> matchAction23, Action`1<TDerivedType24> matchAction24, Action`1<TDerivedType25> matchAction25, Action`1<TDerivedType26> matchAction26, Action`1<TDerivedType27> matchAction27, Action`1<TDerivedType28> matchAction28, Action`1<TDerivedType29> matchAction29, Action`1<TDerivedType30> matchAction30, Action`1<TDerivedType31> matchAction31, Action`1<TDerivedType32> matchAction32, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static void TypeSwitch(TBaseType obj, Action`1<TDerivedType1> matchAction1, Action`1<TDerivedType2> matchAction2, Action`1<TDerivedType3> matchAction3, Action`1<TDerivedType4> matchAction4, Action`1<TDerivedType5> matchAction5, Action`1<TDerivedType6> matchAction6, Action`1<TDerivedType7> matchAction7, Action`1<TDerivedType8> matchAction8, Action`1<TDerivedType9> matchAction9, Action`1<TDerivedType10> matchAction10, Action`1<TDerivedType11> matchAction11, Action`1<TDerivedType12> matchAction12, Action`1<TDerivedType13> matchAction13, Action`1<TDerivedType14> matchAction14, Action`1<TDerivedType15> matchAction15, Action`1<TDerivedType16> matchAction16, Action`1<TDerivedType17> matchAction17, Action`1<TDerivedType18> matchAction18, Action`1<TDerivedType19> matchAction19, Action`1<TDerivedType20> matchAction20, Action`1<TDerivedType21> matchAction21, Action`1<TDerivedType22> matchAction22, Action`1<TDerivedType23> matchAction23, Action`1<TDerivedType24> matchAction24, Action`1<TDerivedType25> matchAction25, Action`1<TDerivedType26> matchAction26, Action`1<TDerivedType27> matchAction27, Action`1<TDerivedType28> matchAction28, Action`1<TDerivedType29> matchAction29, Action`1<TDerivedType30> matchAction30, Action`1<TDerivedType31> matchAction31, Action`1<TDerivedType32> matchAction32, Action`1<TDerivedType33> matchAction33, Action`1<TBaseType> defaultAction);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TDerivedType28, TResult> matchFunc28, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TDerivedType28, TResult> matchFunc28, Func`2<TDerivedType29, TResult> matchFunc29, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TDerivedType28, TResult> matchFunc28, Func`2<TDerivedType29, TResult> matchFunc29, Func`2<TDerivedType30, TResult> matchFunc30, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TDerivedType28, TResult> matchFunc28, Func`2<TDerivedType29, TResult> matchFunc29, Func`2<TDerivedType30, TResult> matchFunc30, Func`2<TDerivedType31, TResult> matchFunc31, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TDerivedType28, TResult> matchFunc28, Func`2<TDerivedType29, TResult> matchFunc29, Func`2<TDerivedType30, TResult> matchFunc30, Func`2<TDerivedType31, TResult> matchFunc31, Func`2<TDerivedType32, TResult> matchFunc32, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TDerivedType28, TResult> matchFunc28, Func`2<TDerivedType29, TResult> matchFunc29, Func`2<TDerivedType30, TResult> matchFunc30, Func`2<TDerivedType31, TResult> matchFunc31, Func`2<TDerivedType32, TResult> matchFunc32, Func`2<TDerivedType33, TResult> matchFunc33, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TDerivedType28, TResult> matchFunc28, Func`2<TDerivedType29, TResult> matchFunc29, Func`2<TDerivedType30, TResult> matchFunc30, Func`2<TDerivedType31, TResult> matchFunc31, Func`2<TDerivedType32, TResult> matchFunc32, Func`2<TDerivedType33, TResult> matchFunc33, Func`2<TDerivedType34, TResult> matchFunc34, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TDerivedType28, TResult> matchFunc28, Func`2<TDerivedType29, TResult> matchFunc29, Func`2<TDerivedType30, TResult> matchFunc30, Func`2<TDerivedType31, TResult> matchFunc31, Func`2<TDerivedType32, TResult> matchFunc32, Func`2<TDerivedType33, TResult> matchFunc33, Func`2<TDerivedType34, TResult> matchFunc34, Func`2<TDerivedType35, TResult> matchFunc35, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TDerivedType28, TResult> matchFunc28, Func`2<TDerivedType29, TResult> matchFunc29, Func`2<TDerivedType30, TResult> matchFunc30, Func`2<TDerivedType31, TResult> matchFunc31, Func`2<TDerivedType32, TResult> matchFunc32, Func`2<TDerivedType33, TResult> matchFunc33, Func`2<TDerivedType34, TResult> matchFunc34, Func`2<TDerivedType35, TResult> matchFunc35, Func`2<TDerivedType36, TResult> matchFunc36, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TDerivedType28, TResult> matchFunc28, Func`2<TDerivedType29, TResult> matchFunc29, Func`2<TDerivedType30, TResult> matchFunc30, Func`2<TDerivedType31, TResult> matchFunc31, Func`2<TDerivedType32, TResult> matchFunc32, Func`2<TDerivedType33, TResult> matchFunc33, Func`2<TDerivedType34, TResult> matchFunc34, Func`2<TDerivedType35, TResult> matchFunc35, Func`2<TDerivedType36, TResult> matchFunc36, Func`2<TDerivedType37, TResult> matchFunc37, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TDerivedType28, TResult> matchFunc28, Func`2<TDerivedType29, TResult> matchFunc29, Func`2<TDerivedType30, TResult> matchFunc30, Func`2<TDerivedType31, TResult> matchFunc31, Func`2<TDerivedType32, TResult> matchFunc32, Func`2<TDerivedType33, TResult> matchFunc33, Func`2<TDerivedType34, TResult> matchFunc34, Func`2<TDerivedType35, TResult> matchFunc35, Func`2<TDerivedType36, TResult> matchFunc36, Func`2<TDerivedType37, TResult> matchFunc37, Func`2<TDerivedType38, TResult> matchFunc38, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TDerivedType28, TResult> matchFunc28, Func`2<TDerivedType29, TResult> matchFunc29, Func`2<TDerivedType30, TResult> matchFunc30, Func`2<TDerivedType31, TResult> matchFunc31, Func`2<TDerivedType32, TResult> matchFunc32, Func`2<TDerivedType33, TResult> matchFunc33, Func`2<TDerivedType34, TResult> matchFunc34, Func`2<TDerivedType35, TResult> matchFunc35, Func`2<TDerivedType36, TResult> matchFunc36, Func`2<TDerivedType37, TResult> matchFunc37, Func`2<TDerivedType38, TResult> matchFunc38, Func`2<TDerivedType39, TResult> matchFunc39, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TDerivedType28, TResult> matchFunc28, Func`2<TDerivedType29, TResult> matchFunc29, Func`2<TDerivedType30, TResult> matchFunc30, Func`2<TDerivedType31, TResult> matchFunc31, Func`2<TDerivedType32, TResult> matchFunc32, Func`2<TDerivedType33, TResult> matchFunc33, Func`2<TDerivedType34, TResult> matchFunc34, Func`2<TDerivedType35, TResult> matchFunc35, Func`2<TDerivedType36, TResult> matchFunc36, Func`2<TDerivedType37, TResult> matchFunc37, Func`2<TDerivedType38, TResult> matchFunc38, Func`2<TDerivedType39, TResult> matchFunc39, Func`2<TDerivedType40, TResult> matchFunc40, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TDerivedType28, TResult> matchFunc28, Func`2<TDerivedType29, TResult> matchFunc29, Func`2<TDerivedType30, TResult> matchFunc30, Func`2<TDerivedType31, TResult> matchFunc31, Func`2<TDerivedType32, TResult> matchFunc32, Func`2<TDerivedType33, TResult> matchFunc33, Func`2<TDerivedType34, TResult> matchFunc34, Func`2<TDerivedType35, TResult> matchFunc35, Func`2<TDerivedType36, TResult> matchFunc36, Func`2<TDerivedType37, TResult> matchFunc37, Func`2<TDerivedType38, TResult> matchFunc38, Func`2<TDerivedType39, TResult> matchFunc39, Func`2<TDerivedType40, TResult> matchFunc40, Func`2<TDerivedType41, TResult> matchFunc41, Func`2<TBaseType, TResult> defaultFunc);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.PredefinedTypeExtensions : object {
    [ExtensionAttribute]
public static SpecialType ToSpecialType(PredefinedType predefinedType);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ProjectExtensions : object {
    [ExtensionAttribute]
public static bool IsFromPrimaryBranch(Project project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ProjectExtensions/<IsForkedProjectWithSemanticChangesAsync>d__1")]
[ExtensionAttribute]
public static Task`1<bool> IsForkedProjectWithSemanticChangesAsync(Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ProjectExtensions/<GetVersionAsync>d__2")]
[ExtensionAttribute]
public static Task`1<VersionStamp> GetVersionAsync(Project project, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SemanticEquivalence : object {
    public static bool AreSemanticallyEquivalent(SemanticModel semanticModel1, SemanticModel semanticModel2, SyntaxNode node1, SyntaxNode node2, Func`2<SyntaxNode, bool> predicate);
    private static bool AreSemanticallyEquivalentWorker(SemanticModel semanticModel1, SemanticModel semanticModel2, SyntaxNode node1, SyntaxNode node2, Func`2<SyntaxNode, bool> predicate);
    private static bool AreEquals(SemanticModel semanticModel1, SemanticModel semanticModel2, SymbolInfo info1, SymbolInfo info2);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SemanticModelExtensions : object {
    [ExtensionAttribute]
public static SemanticMap GetSemanticMap(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TSymbol GetEnclosingSymbol(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISymbol GetEnclosingNamedTypeOrAssembly(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol GetEnclosingNamedType(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamespaceSymbol GetEnclosingNamespace(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol GetType(SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<ISymbol> GetSymbols(SemanticModel semanticModel, SyntaxToken token, Workspace workspace, bool bindLiteralsToUnderlyingType, CancellationToken cancellationToken);
    private static ISymbol MapSymbol(ISymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SemanticModelExtensions/<GetSymbolsEnumerable>d__9")]
private static IEnumerable`1<ISymbol> GetSymbolsEnumerable(SemanticModel semanticModel, ISemanticFactsService semanticFacts, ISyntaxFactsService syntaxFacts, SyntaxToken token, bool bindLiteralsToUnderlyingType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SemanticModel GetOriginalSemanticModel(SemanticModel semanticModel);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SimpleIntervalTreeExtensions : object {
    [ExtensionAttribute]
public static bool IntersectsWith(SimpleIntervalTree`1<TextSpan> tree, TextSpan span);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SourceTextExtensions : object {
    [ExtensionAttribute]
public static string GetLeadingWhitespaceOfLineAtPosition(SourceText text, int position);
    [ExtensionAttribute]
public static void GetLineAndOffset(SourceText text, int position, Int32& lineNumber, Int32& offset);
    [ExtensionAttribute]
public static void GetLinesAndOffsets(SourceText text, TextSpan textSpan, Int32& startLineNumber, Int32& startOffset, Int32& endLineNumber, Int32& endOffset);
    [ExtensionAttribute]
public static bool OverlapsHiddenPosition(SourceText text, TextSpan span, Func`3<int, CancellationToken, bool> isPositionHidden, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool TryOverlapsHiddenPosition(SourceText text, TextSpan span, Func`3<int, CancellationToken, bool> isPositionHidden, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TextChangeRange GetEncompassingTextChangeRange(SourceText newText, SourceText oldText);
    [ExtensionAttribute]
public static int IndexOf(SourceText text, string value, int startIndex, bool caseSensitive);
    [ExtensionAttribute]
public static int LastIndexOf(SourceText text, string value, int startIndex, bool caseSensitive);
    private static bool Match(char nomalizedLeft, char right, bool caseSensitive);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SpecialTypeExtensions : object {
    [ExtensionAttribute]
public static PredefinedType ToPredefinedType(SpecialType specialType);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.StackExtensions : object {
    [ExtensionAttribute]
public static void Push(Stack`1<T> stack, IEnumerable`1<T> values);
    [ExtensionAttribute]
internal static void PushReverse(Stack`1<T> stack, IList`1<U> range);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<int> GetFirstNonWhitespaceOffset(string line);
    [ExtensionAttribute]
public static string GetLeadingWhitespace(string lineText);
    [ExtensionAttribute]
public static int GetTextColumn(string text, int tabSize, int initialColumn);
    [ExtensionAttribute]
public static int ConvertTabToSpace(string textSnippet, int tabSize, int initialColumn, int endPosition);
    [ExtensionAttribute]
public static int IndexOf(string text, Func`2<char, bool> predicate);
    [ExtensionAttribute]
public static string GetFirstLineText(string text);
    [ExtensionAttribute]
public static string GetLastLineText(string text);
    [ExtensionAttribute]
public static bool ContainsLineBreak(string text);
    [ExtensionAttribute]
public static int GetNumberOfLineBreaks(string text);
    [ExtensionAttribute]
public static bool ContainsTab(string text);
    [ExtensionAttribute]
public static ImmutableArray`1<SymbolDisplayPart> ToSymbolDisplayParts(string text);
    [ExtensionAttribute]
public static int GetColumnOfFirstNonWhitespaceCharacterOrEndOfLine(string line, int tabSize);
    [ExtensionAttribute]
public static int GetColumnFromLineOffset(string line, int endPosition, int tabSize);
    [ExtensionAttribute]
public static int GetLineOffsetFromColumn(string line, int column, int tabSize);
    [ExtensionAttribute]
public static void AppendToAliasNameSet(string alias, Builder<string> builder);
}
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SymbolDisplayFormats : object {
    public static SymbolDisplayFormat NameFormat;
    public static SymbolDisplayFormat SignatureFormat;
    private static SymbolDisplayFormats();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SymbolDisplayPartExtensions : object {
    [ExtensionAttribute]
public static string GetFullText(ImmutableArray`1<SymbolDisplayPart> parts);
    [ExtensionAttribute]
public static string GetFullText(IEnumerable`1<SymbolDisplayPart> parts);
    [ExtensionAttribute]
public static void AddAliasName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddAssemblyName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddClassName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddDelegateName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddEnumName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddErrorTypeName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddEventName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddFieldName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddInterfaceName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddKeyword(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddLabelName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddLineBreak(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddNumericLiteral(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddStringLiteral(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddLocalName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddMethodName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddModuleName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddNamespaceName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddOperator(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddParameterName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddPropertyName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddPunctuation(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddRangeVariableName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddStructName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddSpace(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddText(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddTypeParameterName(IList`1<SymbolDisplayPart> parts, string text);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.TextDocumentExtensions : object {
    [ExtensionAttribute]
public static TextDocument WithText(TextDocument textDocument, SourceText text);
    [ExtensionAttribute]
public static TextDocument WithAdditionalDocumentText(TextDocument textDocument, SourceText text);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.TextLineExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<int> GetFirstNonWhitespacePosition(TextLine line);
    [ExtensionAttribute]
public static Nullable`1<int> GetFirstNonWhitespaceOffset(TextLine line);
    [ExtensionAttribute]
public static string GetLeadingWhitespace(TextLine line);
    [ExtensionAttribute]
public static bool IsEmptyOrWhitespace(TextLine line);
    [ExtensionAttribute]
public static int GetColumnOfFirstNonWhitespaceCharacterOrEndOfLine(TextLine line, int tabSize);
    [ExtensionAttribute]
public static int GetColumnFromLineOffset(TextLine line, int lineOffset, int tabSize);
    [ExtensionAttribute]
public static int GetLineOffsetFromColumn(TextLine line, int column, int tabSize);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.TextSpanExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<TextSpan> ToNormalizedSpans(IEnumerable`1<TextSpan> spans);
    [ExtensionAttribute]
public static TextSpan Collapse(IEnumerable`1<TextSpan> spans);
}
internal class Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection : ReadOnlyCollection`1<TextSpan> {
    public NormalizedTextSpanCollection(TextSpan span);
    public NormalizedTextSpanCollection(IEnumerable`1<TextSpan> spans);
    private NormalizedTextSpanCollection(OrderedSpanList normalizedSpans);
    public static NormalizedTextSpanCollection Union(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public static NormalizedTextSpanCollection Overlap(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public static NormalizedTextSpanCollection Intersection(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public static NormalizedTextSpanCollection Difference(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public static bool op_Equality(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public static bool op_Inequality(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public bool OverlapsWith(NormalizedTextSpanCollection set);
    public bool OverlapsWith(TextSpan span);
    public bool IntersectsWith(NormalizedTextSpanCollection set);
    public bool IntersectsWith(TextSpan span);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    private static IList`1<TextSpan> ListFromSpan(TextSpan span);
    private static void UpdateSpanUnion(TextSpan span, IList`1<TextSpan> spans, Int32& start, Int32& end);
    private static IList`1<TextSpan> NormalizeSpans(IEnumerable`1<TextSpan> spans);
}
internal abstract class Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8 : object {
    private TExpressionSyntax _expression;
    private TExpressionSyntax _newExpressionForReplace;
    private TSemanticModel _semanticModel;
    private CancellationToken _cancellationToken;
    private bool _skipVerificationForReplacedNode;
    private bool _failOnOverloadResolutionFailuresInOriginalCode;
    private bool _isNewSemanticModelSpeculativeModel;
    private TSyntaxNode _lazySemanticRootOfOriginalExpression;
    private TExpressionSyntax _lazyReplacedExpression;
    private TSyntaxNode _lazySemanticRootOfReplacedExpression;
    private TSemanticModel _lazySpeculativeSemanticModel;
    public TExpressionSyntax OriginalExpression { get; }
    public TSyntaxNode SemanticRootOfOriginalExpression { get; }
    public TSemanticModel OriginalSemanticModel { get; }
    public TExpressionSyntax ReplacedExpression { get; }
    public TSyntaxNode SemanticRootOfReplacedExpression { get; }
    public TSemanticModel SpeculativeSemanticModel { get; }
    public CancellationToken CancellationToken { get; }
    public AbstractSpeculationAnalyzer`8(TExpressionSyntax expression, TExpressionSyntax newExpression, TSemanticModel semanticModel, CancellationToken cancellationToken, bool skipVerificationForReplacedNode, bool failOnOverloadResolutionFailuresInOriginalCode);
    public TExpressionSyntax get_OriginalExpression();
    public TSyntaxNode get_SemanticRootOfOriginalExpression();
    public TSemanticModel get_OriginalSemanticModel();
    public TExpressionSyntax get_ReplacedExpression();
    public TSyntaxNode get_SemanticRootOfReplacedExpression();
    public TSemanticModel get_SpeculativeSemanticModel();
    public CancellationToken get_CancellationToken();
    protected abstract virtual TSyntaxNode GetSemanticRootForSpeculation(TExpressionSyntax expression);
    protected virtual TSyntaxNode GetSemanticRootOfReplacedExpression(TSyntaxNode semanticRootOfOriginalExpression, TExpressionSyntax annotatedReplacedExpression);
    private void EnsureReplacedExpressionAndSemanticRoot();
    [ConditionalAttribute("DEBUG")]
protected abstract virtual void ValidateSpeculativeSemanticModel(TSemanticModel speculativeSemanticModel, TSyntaxNode nodeToSpeculate);
    private void EnsureSpeculativeSemanticModel();
    protected abstract virtual TSemanticModel CreateSpeculativeSemanticModel(TSyntaxNode originalNode, TSyntaxNode nodeToSpeculate, TSemanticModel semanticModel);
    private bool ReplacementIntroducesErrorType(TExpressionSyntax originalExpression, TExpressionSyntax newExpression);
    protected bool TypesAreCompatible(TExpressionSyntax originalExpression, TExpressionSyntax newExpression);
    protected bool ConvertedTypesAreCompatible(TExpressionSyntax originalExpression, TExpressionSyntax newExpression);
    protected bool ImplicitConversionsAreCompatible(TExpressionSyntax originalExpression, TExpressionSyntax newExpression);
    private bool ImplicitConversionsAreCompatible(TExpressionSyntax originalExpression, ITypeSymbol originalTargetType, TExpressionSyntax newExpression, ITypeSymbol newTargetType);
    protected abstract virtual bool ConversionsAreCompatible(SemanticModel model1, TExpressionSyntax expression1, SemanticModel model2, TExpressionSyntax expression2);
    protected abstract virtual bool ConversionsAreCompatible(TExpressionSyntax originalExpression, ITypeSymbol originalTargetType, TExpressionSyntax newExpression, ITypeSymbol newTargetType);
    protected bool SymbolsAreCompatible(TSyntaxNode originalNode, TSyntaxNode newNode, bool requireNonNullSymbols);
    public static bool SymbolInfosAreCompatible(SymbolInfo originalSymbolInfo, SymbolInfo newSymbolInfo, bool performEquivalenceCheck, bool requireNonNullSymbols);
    protected bool SymbolInfosAreCompatible(SymbolInfo originalSymbolInfo, SymbolInfo newSymbolInfo, bool requireNonNullSymbols);
    protected bool SymbolsAreCompatible(ISymbol symbol, ISymbol newSymbol, bool requireNonNullSymbols);
    private static bool SymbolsAreCompatibleCore(ISymbol symbol, ISymbol newSymbol, bool performEquivalenceCheck, bool requireNonNullSymbols);
    public bool ReplacementChangesSemantics();
    protected abstract virtual bool IsParenthesizedExpression(TSyntaxNode node);
    protected bool ReplacementChangesSemantics(TSyntaxNode currentOriginalNode, TSyntaxNode currentReplacedNode, TSyntaxNode originalRoot, bool skipVerificationForCurrentNode);
    public bool SymbolsForOriginalAndReplacedNodesAreCompatible();
    protected abstract virtual bool ReplacementChangesSemanticsForNodeLanguageSpecific(TSyntaxNode currentOriginalNode, TSyntaxNode currentReplacedNode, TSyntaxNode previousOriginalNode, TSyntaxNode previousReplacedNode);
    private bool ReplacementChangesSemanticsForNode(TSyntaxNode currentOriginalNode, TSyntaxNode currentReplacedNode, TSyntaxNode previousOriginalNode, TSyntaxNode previousReplacedNode);
    private bool ReplacementBreaksAttribute(TAttributeSyntax attribute, TAttributeSyntax newAttribute);
    protected abstract virtual TExpressionSyntax GetForEachStatementExpression(TForEachStatementSyntax forEachStatement);
    protected abstract virtual bool IsForEachTypeInferred(TForEachStatementSyntax forEachStatement, TSemanticModel semanticModel);
    private bool ReplacementBreaksForEachStatement(TForEachStatementSyntax forEachStatement, TForEachStatementSyntax newForEachStatement);
    protected abstract virtual bool ForEachConversionsAreCompatible(SemanticModel originalModel, TForEachStatementSyntax originalForEach, SemanticModel newModel, TForEachStatementSyntax newForEach);
    protected abstract virtual void GetForEachSymbols(SemanticModel model, TForEachStatementSyntax forEach, IMethodSymbol& getEnumeratorMethod, ITypeSymbol& elementType);
    private bool ReplacementBreaksForEachGetEnumerator(IMethodSymbol getEnumerator, IMethodSymbol newGetEnumerator, TExpressionSyntax newForEachStatementExpression);
    protected abstract virtual TExpressionSyntax GetThrowStatementExpression(TThrowStatementSyntax throwStatement);
    private bool ReplacementBreaksThrowStatement(TThrowStatementSyntax originalThrowStatement, TThrowStatementSyntax newThrowStatement);
    protected abstract virtual bool IsInNamespaceOrTypeContext(TExpressionSyntax node);
    private bool ReplacementBreaksTypeResolution(TTypeSyntax type, TTypeSyntax newType, bool useSpeculativeModel);
    protected abstract virtual bool IsInvocableExpression(TSyntaxNode node);
    private static bool IsDelegateInvoke(ISymbol symbol);
    private static bool IsAnonymousDelegateInvoke(ISymbol symbol);
    private bool ReplacementBreaksInvocableExpression(TExpressionSyntax expression, TExpressionSyntax newExpression);
    protected bool ReplacementBreaksCompoundAssignExpression(TExpressionSyntax originalLeft, TExpressionSyntax originalRight, TExpressionSyntax newLeft, TExpressionSyntax newRight);
    protected abstract virtual bool IsReferenceConversion(Compilation model, ITypeSymbol sourceType, ITypeSymbol targetType);
    private bool IsCompatibleInterfaceMemberImplementation(ISymbol symbol, ISymbol newSymbol, TExpressionSyntax originalInvocationExpression, TExpressionSyntax newInvocationExpression, TSemanticModel speculativeSemanticModel);
    private static bool IsEffectivelySealedClass(ITypeSymbol type);
    private bool IsReceiverNonUniquePossibleValueTypeParam(TExpressionSyntax invocation, TSemanticModel semanticModel);
    private static bool IsReceiverUniqueInstance(TExpressionSyntax receiver, TSemanticModel semanticModel);
    protected abstract virtual ImmutableArray`1<TArgumentSyntax> GetArguments(TExpressionSyntax expression);
    protected abstract virtual TExpressionSyntax GetReceiver(TExpressionSyntax expression);
    private bool SymbolsHaveCompatibleParameterLists(ISymbol originalSymbol, ISymbol newSymbol, TExpressionSyntax originalInvocation);
    protected abstract virtual bool IsNamedArgument(TArgumentSyntax argument);
    protected abstract virtual string GetNamedArgumentIdentifierValueText(TArgumentSyntax argument);
    private bool AreCompatibleParameterLists(ImmutableArray`1<TArgumentSyntax> specifiedArguments, ImmutableArray`1<IParameterSymbol> signature1Parameters, ImmutableArray`1<IParameterSymbol> signature2Parameters);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.AliasSymbolCache : object {
    private static ConditionalWeakTable`2<Compilation, ConcurrentDictionary`2<ValueTuple`2<SyntaxTree, int>, ImmutableDictionary`2<INamespaceOrTypeSymbol, IAliasSymbol>>> s_treeAliasMap;
    private static CreateValueCallback<Compilation, ConcurrentDictionary`2<ValueTuple`2<SyntaxTree, int>, ImmutableDictionary`2<INamespaceOrTypeSymbol, IAliasSymbol>>> s_createTreeMap;
    private static Func`2<ISymbol, string> s_symbolToName;
    private static AliasSymbolCache();
    public static bool TryGetAliasSymbol(SemanticModel semanticModel, int namespaceId, INamespaceOrTypeSymbol targetSymbol, IAliasSymbol& aliasSymbol);
    public static void AddAliasSymbols(SemanticModel semanticModel, int namespaceId, IEnumerable`1<IAliasSymbol> aliasSymbols);
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.BloomFilter : object {
    private BitArray _bitArray;
    private int _hashFunctionCount;
    private bool _isCaseSensitive;
    private static string SerializationFormat;
    public BloomFilter(int expectedCount, double falsePositiveProbability, bool isCaseSensitive);
    public BloomFilter(double falsePositiveProbability, bool isCaseSensitive, ICollection`1<string> values);
    private BloomFilter(BitArray bitArray, int hashFunctionCount, bool isCaseSensitive);
    private static int ComputeM(int expectedCount, double falsePositiveProbability);
    private static int ComputeK(int expectedCount, double falsePositiveProbability);
    private int ComputeHash(string key, int seed);
    private UInt32 GetCharacter(string key, int index);
    public void AddRange(IEnumerable`1<string> values);
    public void Add(string value);
    public bool ProbablyContains(string value);
    public bool IsEquivalent(BloomFilter filter);
    private bool IsEquivalent(BitArray array1, BitArray array2);
    public sealed virtual void WriteTo(ObjectWriter writer);
    private static void WriteBitArray(ObjectWriter writer, BitArray bitArray);
    public static BloomFilter ReadFrom(ObjectReader reader);
    private static BitArray ReadBitArray(ObjectReader reader);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Utilities.CommonFormattingHelpers : object {
    public static Comparison`1<SuppressOperation> SuppressOperationComparer;
    public static Comparison`1<IndentBlockOperation> IndentBlockOperationComparer;
    private static CommonFormattingHelpers();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Utilities.CommonFormattingHelpers/<ConvertToTokenPairs>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> ConvertToTokenPairs(SyntaxNode root, IList`1<TextSpan> spans);
    [ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> ConvertToTokenPair(SyntaxNode root, TextSpan textSpan);
    [ExtensionAttribute]
public static bool IsInvalidTokenRange(SyntaxNode root, SyntaxToken startToken, SyntaxToken endToken);
    [ExtensionAttribute]
public static int GetTokenColumn(SyntaxTree tree, SyntaxToken token, int tabSize);
    [ExtensionAttribute]
public static string GetText(SourceText text, SyntaxToken token1, SyntaxToken token2);
    public static string GetTextBetween(SyntaxToken token1, SyntaxToken token2);
    public static void AppendTextBetween(SyntaxToken token1, SyntaxToken token2, StringBuilder builder);
    private static void AppendTextBetweenTwoAdjacentTokens(SyntaxToken token1, SyntaxToken token2, StringBuilder builder);
    private static void AppendLeadingTriviaText(SyntaxToken token, StringBuilder builder);
    private static void AppendPartialLeadingTriviaText(SyntaxToken token, StringBuilder builder, int token1FullSpanEnd);
    private static void AppendTrailingTriviaText(SyntaxToken token, StringBuilder builder);
    public static TextSpan GetSpanIncludingTrailingAndLeadingTriviaOfAdjacentTokens(SyntaxToken startToken, SyntaxToken endToken);
    private static int GetEndPositionOfSpan(SyntaxToken token);
    public static int GetStartPositionOfSpan(SyntaxToken token);
    private static SyntaxNode GetParentThatContainsGivenSpan(SyntaxNode node, int position, bool forward);
    public static bool HasAnyWhitespaceElasticTrivia(SyntaxToken previousToken, SyntaxToken currentToken);
    public static bool IsNull(T t);
    public static bool IsNotNull(T t);
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment : object {
    [CompilerGeneratedAttribute]
private bool <HadXmlParseError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullXmlFragment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExampleText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SummaryText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReturnsText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemarksText>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ParameterNames>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <TypeParameterNames>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ExceptionTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompletionListCref>k__BackingField;
    private static DocumentationComment modreq(System.Runtime.CompilerServices.IsVolatile) s_cacheLastXmlFragmentParse;
    private Dictionary`2<string, string> _parameterTexts;
    private Dictionary`2<string, string> _typeParameterTexts;
    private Dictionary`2<string, ImmutableArray`1<string>> _exceptionTexts;
    public static DocumentationComment Empty;
    public bool HadXmlParseError { get; private set; }
    public string FullXmlFragment { get; private set; }
    public string ExampleText { get; private set; }
    public string SummaryText { get; private set; }
    public string ReturnsText { get; private set; }
    public string RemarksText { get; private set; }
    public ImmutableArray`1<string> ParameterNames { get; private set; }
    public ImmutableArray`1<string> TypeParameterNames { get; private set; }
    public ImmutableArray`1<string> ExceptionTypes { get; private set; }
    public string CompletionListCref { get; private set; }
    private static DocumentationComment();
    [CompilerGeneratedAttribute]
public bool get_HadXmlParseError();
    [CompilerGeneratedAttribute]
private void set_HadXmlParseError(bool value);
    [CompilerGeneratedAttribute]
public string get_FullXmlFragment();
    [CompilerGeneratedAttribute]
private void set_FullXmlFragment(string value);
    [CompilerGeneratedAttribute]
public string get_ExampleText();
    [CompilerGeneratedAttribute]
private void set_ExampleText(string value);
    [CompilerGeneratedAttribute]
public string get_SummaryText();
    [CompilerGeneratedAttribute]
private void set_SummaryText(string value);
    [CompilerGeneratedAttribute]
public string get_ReturnsText();
    [CompilerGeneratedAttribute]
private void set_ReturnsText(string value);
    [CompilerGeneratedAttribute]
public string get_RemarksText();
    [CompilerGeneratedAttribute]
private void set_RemarksText(string value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ParameterNames();
    [CompilerGeneratedAttribute]
private void set_ParameterNames(ImmutableArray`1<string> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_TypeParameterNames();
    [CompilerGeneratedAttribute]
private void set_TypeParameterNames(ImmutableArray`1<string> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ExceptionTypes();
    [CompilerGeneratedAttribute]
private void set_ExceptionTypes(ImmutableArray`1<string> value);
    [CompilerGeneratedAttribute]
public string get_CompletionListCref();
    [CompilerGeneratedAttribute]
private void set_CompletionListCref(string value);
    public static DocumentationComment FromXmlFragment(string xml);
    public string GetParameterText(string parameterName);
    public string GetTypeParameterText(string typeParameterName);
    public ImmutableArray`1<string> GetExceptionTexts(string exceptionName);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.EditorBrowsableHelpers : object {
    public static IMethodSymbol GetSpecialEditorBrowsableAttributeConstructor(Compilation compilation);
    public static List`1<IMethodSymbol> GetSpecialTypeLibTypeAttributeConstructors(Compilation compilation);
    public static List`1<IMethodSymbol> GetSpecialTypeLibFuncAttributeConstructors(Compilation compilation);
    public static List`1<IMethodSymbol> GetSpecialTypeLibVarAttributeConstructors(Compilation compilation);
    private static List`1<IMethodSymbol> GetSpecialTypeLibAttributeConstructorsWorker(Compilation compilation, string attributeMetadataName, string flagsMetadataName);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.EnumValueUtilities : object {
    public static object GetNextEnumValue(INamedTypeSymbol enumType, CancellationToken cancellationToken);
    private static object CreateOne(SpecialType specialType);
    private static IComparable Multiply(IComparable value, UInt32 number);
    private static IComparable Add(IComparable value, UInt32 number);
    private static bool GreaterThanOrEqualsZero(IComparable value);
    private static bool LooksLikeFlagsEnum(INamedTypeSymbol enumType, List`1<IComparable> existingConstants);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.ExtensionOrderer : object {
    internal static IList`1<Lazy`2<TExtension, TMetadata>> Order(IEnumerable`1<Lazy`2<TExtension, TMetadata>> extensions);
    internal static void CheckForCycles(IEnumerable`1<Lazy`2<TExtension, TMetadata>> extensions);
    private static Graph`2<TExtension, TMetadata> GetGraph(IEnumerable`1<Lazy`2<TExtension, TMetadata>> extensions);
    private static IEnumerable`1<string> Before(Lazy`2<TExtension, TMetadata> extension);
    private static IEnumerable`1<string> After(Lazy`2<TExtension, TMetadata> extension);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.FindTokenHelper : object {
    public static SyntaxToken FindTokenOnRightOfPosition(SyntaxNode root, int position, Func`3<SyntaxTriviaList, int, SyntaxToken> skippedTokenFinder, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    public static SyntaxToken FindTokenOnLeftOfPosition(SyntaxNode root, int position, Func`3<SyntaxTriviaList, int, SyntaxToken> skippedTokenFinder, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    private static SyntaxToken GetInitialToken(SyntaxNode root, int position, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    public static SyntaxToken FindSkippedTokenBackward(IEnumerable`1<SyntaxToken> skippedTokenList, int position);
    public static SyntaxToken FindSkippedTokenForward(IEnumerable`1<SyntaxToken> skippedTokenList, int position);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.IntegerUtilities : object {
    public static int CountOfBitsSet(long v);
    public static bool HasOneBitSet(IComparable value);
    public static bool HasOneBitSet(long v);
    public static int LogBase2(long v);
    public static long Convert(long v, SpecialType type);
    public static ulong ToUnsigned(long v);
    public static ulong ToUInt64(object o);
    public static long ToInt64(object o);
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.Matcher : object {
    public static Matcher`1<T> Repeat(Matcher`1<T> matcher);
    public static Matcher`1<T> OneOrMore(Matcher`1<T> matcher);
    public static Matcher`1<T> Choice(Matcher`1<T> matcher1, Matcher`1<T> matcher2);
    public static Matcher`1<T> Sequence(Matcher`1[] matchers);
    public static Matcher`1<T> Single(Func`2<T, bool> predicate, string description);
}
internal abstract class Microsoft.CodeAnalysis.Shared.Utilities.Matcher`1 : object {
    public abstract virtual bool TryMatch(IList`1<T> sequence, Int32& index);
    internal static Matcher`1<T> Repeat(Matcher`1<T> matcher);
    internal static Matcher`1<T> OneOrMore(Matcher`1<T> matcher);
    internal static Matcher`1<T> Choice(Matcher`1<T> matcher1, Matcher`1<T> matcher2);
    internal static Matcher`1<T> Sequence(Matcher`1[] matchers);
    internal static Matcher`1<T> Single(Func`2<T, bool> predicate, string description);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.NameGenerator : object {
    public static IList`1<string> EnsureUniqueness(IList`1<string> names, Func`2<string, bool> canUse);
    public static IList`1<string> EnsureUniqueness(IList`1<string> names, IList`1<bool> isFixed, Func`2<string, bool> canUse, bool isCaseSensitive);
    internal static IList`1<string> EnsureUniqueness(IList`1<string> names, bool isCaseSensitive);
    public static string EnsureUniqueness(string baseName, IEnumerable`1<string> reservedNames, bool isCaseSensitive);
    private static void EnsureUniquenessInPlace(IList`1<string> names, IList`1<bool> isFixed, Func`2<string, bool> canUse, bool isCaseSensitive);
    private static void HandleCollisions(IList`1<bool> isFixed, IList`1<string> names, string name, List`1<int> collisionIndices, Func`2<string, bool> canUse, bool isCaseSensitive);
    private static List`1<int> GetCollisionIndices(IList`1<string> names, string name, bool isCaseSensitive);
    public static string GenerateUniqueName(string baseName, Func`2<string, bool> canUse);
    public static string GenerateUniqueName(string baseName, ISet`1<string> names, StringComparer comparer);
    public static string GenerateUniqueName(string baseName, string extension, Func`2<string, bool> canUse);
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.ProgressTracker : object {
    private int _completedItems;
    private int _totalItems;
    private Action`2<int, int> _updateActionOpt;
    public int CompletedItems { get; }
    public int TotalItems { get; }
    public ProgressTracker(Action`2<int, int> updateActionOpt);
    public int get_CompletedItems();
    public int get_TotalItems();
    public void AddItems(int count);
    public void ItemCompleted();
    private void Update();
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.SemanticMap : object {
    private Dictionary`2<SyntaxNode, SymbolInfo> _expressionToInfoMap;
    private Dictionary`2<SyntaxToken, SymbolInfo> _tokenToInfoMap;
    public IEnumerable`1<ISymbol> AllReferencedSymbols { get; }
    internal static SemanticMap From(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public IEnumerable`1<ISymbol> get_AllReferencedSymbols();
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.SignatureComparer : object {
    public static SignatureComparer Instance;
    public static SignatureComparer IgnoreAssembliesInstance;
    private SymbolEquivalenceComparer _symbolEquivalenceComparer;
    private IEqualityComparer`1<IParameterSymbol> ParameterEquivalenceComparer { get; }
    private IEqualityComparer`1<ITypeSymbol> SignatureTypeEquivalenceComparer { get; }
    private SignatureComparer(SymbolEquivalenceComparer symbolEquivalenceComparer);
    private static SignatureComparer();
    private IEqualityComparer`1<IParameterSymbol> get_ParameterEquivalenceComparer();
    private IEqualityComparer`1<ITypeSymbol> get_SignatureTypeEquivalenceComparer();
    public bool HaveSameSignature(ISymbol symbol1, ISymbol symbol2, bool caseSensitive);
    private bool HaveSameSignature(IEventSymbol event1, IEventSymbol event2, bool caseSensitive);
    public bool HaveSameSignature(IPropertySymbol property1, IPropertySymbol property2, bool caseSensitive);
    private bool BadPropertyAccessor(IMethodSymbol method1, IMethodSymbol method2);
    public bool HaveSameSignature(IMethodSymbol method1, IMethodSymbol method2, bool caseSensitive, bool compareParameterName, bool isParameterCaseSensitive);
    private bool IdentifiersMatch(string identifier1, string identifier2, bool caseSensitive);
    public bool HaveSameSignature(IList`1<IParameterSymbol> parameters1, IList`1<IParameterSymbol> parameters2);
    public bool HaveSameSignature(IList`1<IParameterSymbol> parameters1, IList`1<IParameterSymbol> parameters2, bool compareParameterName, bool isCaseSensitive);
    public bool HaveSameSignatureAndConstraintsAndReturnTypeAndAccessors(ISymbol symbol1, ISymbol symbol2, bool caseSensitive);
    private bool HaveSameAccessors(IPropertySymbol property1, IPropertySymbol property2);
    private bool HaveSameSignatureAndConstraintsAndReturnType(IMethodSymbol method1, IMethodSymbol method2);
    private bool HaveSameConstraints(ITypeParameterSymbol typeParameter1, ITypeParameterSymbol typeParameter2);
    private bool HaveSameReturnType(IPropertySymbol property1, IPropertySymbol property2);
    private bool HaveSameReturnType(IEventSymbol ev1, IEventSymbol ev2);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.StringBreaker : object {
    private static Func`3<string, int, TextSpan> s_characterPartsGenerator;
    private static Func`3<string, int, TextSpan> s_wordPartsGenerator;
    private static StringBreaker();
    public static StringBreaks BreakIntoCharacterParts(string identifier);
    public static StringBreaks BreakIntoWordParts(string identifier);
    public static TextSpan GenerateSpan(string identifier, int wordStart, bool word);
    private static bool IsAllPunctuation(string identifier, int start, int end);
    private static bool TransitionFromUpperToLower(string identifier, bool word, int index, int wordStart);
    private static bool TransitionFromLowerToUpper(string identifier, bool word, int index);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Shared.Utilities.StringBreaks : ValueType {
    private List`1<TextSpan> _spans;
    private EncodedSpans _encodedSpans;
    private static int BitsForGap;
    private static int BitsForLength;
    private static int BitsPerEncodedSpan;
    private static int MaxShortSpans;
    private static int MaxGap;
    private static int MaxLength;
    public int Count { get; }
    public TextSpan Item { get; }
    private StringBreaks(EncodedSpans encodedSpans);
    private StringBreaks(List`1<TextSpan> spans);
    public static StringBreaks Create(string text, Func`3<string, int, TextSpan> spanGenerator);
    private static bool TryEncodeSpans(string text, Func`3<string, int, TextSpan> spanGenerator, EncodedSpans& encodedSpans);
    private static List`1<TextSpan> CreateFallbackList(string text, Func`3<string, int, TextSpan> spanGenerator);
    public int get_Count();
    public TextSpan get_Item(int index);
    private static byte Encode(int gap, int length);
    private static int DecodeLength(byte b);
    private static int DecodeGap(byte b);
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer : object {
    private ImmutableArray`1<EquivalenceVisitor> _equivalenceVisitors;
    private ImmutableArray`1<GetHashCodeVisitor> _getHashCodeVisitors;
    public static SymbolEquivalenceComparer Instance;
    public static SymbolEquivalenceComparer IgnoreAssembliesInstance;
    private IEqualityComparer`1<IAssemblySymbol> _assemblyComparerOpt;
    [CompilerGeneratedAttribute]
private ParameterSymbolEqualityComparer <ParameterEquivalenceComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureTypeSymbolEquivalenceComparer <SignatureTypeEquivalenceComparer>k__BackingField;
    public ParameterSymbolEqualityComparer ParameterEquivalenceComparer { get; private set; }
    public SignatureTypeSymbolEquivalenceComparer SignatureTypeEquivalenceComparer { get; private set; }
    internal SymbolEquivalenceComparer(IEqualityComparer`1<IAssemblySymbol> assemblyComparerOpt, bool distinguishRefFromOut);
    private static SymbolEquivalenceComparer();
    [CompilerGeneratedAttribute]
public ParameterSymbolEqualityComparer get_ParameterEquivalenceComparer();
    [CompilerGeneratedAttribute]
private void set_ParameterEquivalenceComparer(ParameterSymbolEqualityComparer value);
    [CompilerGeneratedAttribute]
public SignatureTypeSymbolEquivalenceComparer get_SignatureTypeEquivalenceComparer();
    [CompilerGeneratedAttribute]
private void set_SignatureTypeEquivalenceComparer(SignatureTypeSymbolEquivalenceComparer value);
    private EquivalenceVisitor GetEquivalenceVisitor(bool compareMethodTypeParametersByIndex, bool objectAndDynamicCompareEqually);
    private GetHashCodeVisitor GetGetHashCodeVisitor(bool compareMethodTypeParametersByIndex, bool objectAndDynamicCompareEqually);
    private static int GetVisitorIndex(bool compareMethodTypeParametersByIndex, bool objectAndDynamicCompareEqually);
    public bool ReturnTypeEquals(IMethodSymbol x, IMethodSymbol y, Dictionary`2<INamedTypeSymbol, INamedTypeSymbol> equivalentTypesWithDifferingAssemblies);
    public sealed virtual bool Equals(ISymbol x, ISymbol y);
    public bool Equals(ISymbol x, ISymbol y, Dictionary`2<INamedTypeSymbol, INamedTypeSymbol> equivalentTypesWithDifferingAssemblies);
    private bool EqualsCore(ISymbol x, ISymbol y, Dictionary`2<INamedTypeSymbol, INamedTypeSymbol> equivalentTypesWithDifferingAssemblies);
    public sealed virtual int GetHashCode(ISymbol x);
    private static ISymbol UnwrapAlias(ISymbol symbol);
    private static SymbolKind GetKindAndUnwrapAlias(ISymbol& symbol);
    private static bool IsConstructedFromSelf(INamedTypeSymbol symbol);
    private static bool IsConstructedFromSelf(IMethodSymbol symbol);
    private static bool IsObjectType(ISymbol symbol);
    private static bool CheckContainingType(IMethodSymbol x);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer/<Unwrap>d__29")]
private static IEnumerable`1<INamedTypeSymbol> Unwrap(INamedTypeSymbol namedType);
    private static bool IsPartialMethodDefinitionPart(IMethodSymbol symbol);
    private static bool IsPartialMethodImplementationPart(IMethodSymbol symbol);
    private static TypeKind GetTypeKind(INamedTypeSymbol x);
    public static bool AreRefKindsEquivalent(RefKind rk1, RefKind rk2, bool distinguishRefFromOut);
}
internal enum Microsoft.CodeAnalysis.Shared.Utilities.SymbolVisibility : Enum {
    public int value__;
    public static SymbolVisibility Public;
    public static SymbolVisibility Internal;
    public static SymbolVisibility Private;
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.XmlFragmentParser : object {
    private XmlReader _xmlReader;
    private Reader _textReader;
    private static ObjectPool`1<XmlFragmentParser> s_pool;
    private static XmlReaderSettings s_xmlSettings;
    private bool BeforeStart { get; }
    private bool ReachedEnd { get; }
    private static XmlFragmentParser();
    public static void ParseFragment(string xmlFragment, Action`2<XmlReader, TArg> callback, TArg arg);
    private void ParseInternal(string text, Action`2<XmlReader, TArg> callback, TArg arg);
    private bool get_BeforeStart();
    private bool get_ReachedEnd();
}
internal abstract class Microsoft.CodeAnalysis.Simplification.AbstractReducer : object {
    public abstract virtual IExpressionRewriter CreateExpressionRewriter(OptionSet optionSet, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Simplification.AbstractSimplificationService`3 : object {
    protected abstract virtual IEnumerable`1<AbstractReducer> GetReducers();
    protected abstract virtual ImmutableArray`1<NodeOrTokenToReduce> GetNodesAndTokensToReduce(SyntaxNode root, Func`2<SyntaxNodeOrToken, bool> isNodeOrTokenOutsideSimplifySpans);
    protected abstract virtual SemanticModel GetSpeculativeSemanticModel(SyntaxNode& nodeToSpeculate, SemanticModel originalSemanticModel, SyntaxNode originalNode);
    protected abstract virtual bool CanNodeBeSimplifiedWithoutSpeculation(SyntaxNode node);
    protected virtual SyntaxNode TransformReducedNode(SyntaxNode reducedNode, SyntaxNode originalNode);
    public abstract virtual SyntaxNode Expand(SyntaxNode node, SemanticModel semanticModel, SyntaxAnnotation annotationForReplacedAliasIdentifier, Func`2<SyntaxNode, bool> expandInsideNode, bool expandParameter, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken Expand(SyntaxToken token, SemanticModel semanticModel, Func`2<SyntaxNode, bool> expandInsideNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.AbstractSimplificationService`3/<ReduceAsync>d__7")]
public sealed virtual Task`1<Document> ReduceAsync(Document document, IEnumerable`1<TextSpan> spans, OptionSet optionSet, IEnumerable`1<AbstractReducer> reducers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.AbstractSimplificationService`3/<ReduceAsyncInternal>d__8")]
private Task`1<Document> ReduceAsyncInternal(Document document, List`1<TextSpan> spans, OptionSet optionSet, IEnumerable`1<AbstractReducer> reducers, CancellationToken cancellationToken);
    private Task ReduceAsync(Document document, SyntaxNode root, ImmutableArray`1<NodeOrTokenToReduce> nodesAndTokensToReduce, IEnumerable`1<AbstractReducer> reducers, OptionSet optionSet, SemanticModel semanticModel, ConcurrentDictionary`2<SyntaxNode, SyntaxNode> reducedNodesMap, ConcurrentDictionary`2<SyntaxToken, SyntaxToken> reducedTokensMap, CancellationToken cancellationToken);
    private SyntaxNode PrepareNamespaceImportsForRemovalIfUnused(Document document, SyntaxNode root, SyntaxAnnotation removeIfUnusedAnnotation, Func`2<SyntaxNodeOrToken, bool> isNodeOrTokenOutsideSimplifySpan);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.AbstractSimplificationService`3/<RemoveUnusedNamespaceImportsAsync>d__11")]
private Task`1<Document> RemoveUnusedNamespaceImportsAsync(Document document, SyntaxAnnotation removeIfUnusedAnnotation, CancellationToken cancellationToken);
    protected abstract virtual void GetUnusedNamespaceImports(SemanticModel model, HashSet`1<SyntaxNode> namespaceImports, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Simplification.AliasAnnotation : object {
    public static string Kind;
    public static string GetAliasName(SyntaxAnnotation annotation);
    public static SyntaxAnnotation Create(string aliasName);
}
internal interface Microsoft.CodeAnalysis.Simplification.ISimplificationService {
    public abstract virtual SyntaxNode Expand(SyntaxNode node, SemanticModel semanticModel, SyntaxAnnotation annotationForReplacedAliasIdentifier, Func`2<SyntaxNode, bool> expandInsideNode, bool expandParameter, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken Expand(SyntaxToken token, SemanticModel semanticModel, Func`2<SyntaxNode, bool> expandInsideNode, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> ReduceAsync(Document document, IEnumerable`1<TextSpan> spans, OptionSet optionSet, IEnumerable`1<AbstractReducer> reducers, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Simplification.NodeOrTokenToReduce : ValueType {
    public SyntaxNodeOrToken NodeOrToken;
    public bool SimplifyAllDescendants;
    public SyntaxNodeOrToken OriginalNodeOrToken;
    public bool CanBeSpeculated;
    public NodeOrTokenToReduce(SyntaxNodeOrToken nodeOrToken, bool simplifyAllDescendants, SyntaxNodeOrToken originalNodeOrToken, bool canBeSpeculated);
}
internal static class Microsoft.CodeAnalysis.Simplification.SimplificationHelpers : object {
    public static SyntaxAnnotation DontSimplifyAnnotation;
    public static SyntaxAnnotation SimplifyModuleNameAnnotation;
    private static SimplificationHelpers();
    public static TNode CopyAnnotations(SyntaxNode from, TNode to);
    public static SyntaxToken CopyAnnotations(SyntaxToken from, SyntaxToken to);
    internal static ISymbol GetOriginalSymbolInfo(SemanticModel semanticModel, SyntaxNode expression);
    internal static bool IsValidSymbolInfo(ISymbol symbol);
}
public static class Microsoft.CodeAnalysis.Simplification.SimplificationOptions : object {
    internal static string NonPerLanguageFeatureName;
    internal static string PerLanguageFeatureName;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <PreferAliasToQualification>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <PreferOmittingModuleNamesInQualification>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <PreferImplicitTypeInference>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <PreferImplicitTypeInLocalDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <AllowSimplificationToGenericType>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <AllowSimplificationToBaseType>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <QualifyMemberAccessWithThisOrMe>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <PreferIntrinsicPredefinedTypeKeywordInDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <PreferIntrinsicPredefinedTypeKeywordInMemberAccess>k__BackingField;
    public static Option`1<bool> PreferAliasToQualification { get; }
    public static Option`1<bool> PreferOmittingModuleNamesInQualification { get; }
    public static Option`1<bool> PreferImplicitTypeInference { get; }
    public static Option`1<bool> PreferImplicitTypeInLocalDeclaration { get; }
    public static Option`1<bool> AllowSimplificationToGenericType { get; }
    public static Option`1<bool> AllowSimplificationToBaseType { get; }
    public static PerLanguageOption`1<bool> QualifyMemberAccessWithThisOrMe { get; }
    public static PerLanguageOption`1<bool> PreferIntrinsicPredefinedTypeKeywordInDeclaration { get; }
    public static PerLanguageOption`1<bool> PreferIntrinsicPredefinedTypeKeywordInMemberAccess { get; }
    private static SimplificationOptions();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_PreferAliasToQualification();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_PreferOmittingModuleNamesInQualification();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_PreferImplicitTypeInference();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_PreferImplicitTypeInLocalDeclaration();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_AllowSimplificationToGenericType();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_AllowSimplificationToBaseType();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_QualifyMemberAccessWithThisOrMe();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_PreferIntrinsicPredefinedTypeKeywordInDeclaration();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_PreferIntrinsicPredefinedTypeKeywordInMemberAccess();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Simplification.SimplificationOptionsProvider : object {
    private IEnumerable`1<IOption> _options;
    public sealed virtual IEnumerable`1<IOption> GetOptions();
}
public static class Microsoft.CodeAnalysis.Simplification.Simplifier : object {
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <Annotation>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <SpecialTypeAnnotation>k__BackingField;
    public static SyntaxAnnotation Annotation { get; }
    public static SyntaxAnnotation SpecialTypeAnnotation { get; }
    private static Simplifier();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_Annotation();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_SpecialTypeAnnotation();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.Simplifier/<ExpandAsync>d__6`1")]
public static Task`1<TNode> ExpandAsync(TNode node, Document document, Func`2<SyntaxNode, bool> expandInsideNode, bool expandParameter, CancellationToken cancellationToken);
    public static TNode Expand(TNode node, SemanticModel semanticModel, Workspace workspace, Func`2<SyntaxNode, bool> expandInsideNode, bool expandParameter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.Simplifier/<ExpandAsync>d__8")]
public static Task`1<SyntaxToken> ExpandAsync(SyntaxToken token, Document document, Func`2<SyntaxNode, bool> expandInsideNode, CancellationToken cancellationToken);
    public static SyntaxToken Expand(SyntaxToken token, SemanticModel semanticModel, Workspace workspace, Func`2<SyntaxNode, bool> expandInsideNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.Simplifier/<ReduceAsync>d__10")]
public static Task`1<Document> ReduceAsync(Document document, OptionSet optionSet, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.Simplifier/<ReduceAsync>d__11")]
public static Task`1<Document> ReduceAsync(Document document, SyntaxAnnotation annotation, OptionSet optionSet, CancellationToken cancellationToken);
    public static Task`1<Document> ReduceAsync(Document document, TextSpan span, OptionSet optionSet, CancellationToken cancellationToken);
    public static Task`1<Document> ReduceAsync(Document document, IEnumerable`1<TextSpan> spans, OptionSet optionSet, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.Simplifier/<ReduceAsync>d__14")]
internal static Task`1<Document> ReduceAsync(Document document, IEnumerable`1<AbstractReducer> reducers, OptionSet optionSet, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Simplification.SimplifyTypeNameCodeAction : DocumentChangeAction {
    public SimplifyTypeNameCodeAction(string title, Func`2<CancellationToken, Task`1<Document>> createChangedDocument, string id);
}
internal class Microsoft.CodeAnalysis.Simplification.SpecialTypeAnnotation : object {
    public static string Kind;
    private static ConcurrentDictionary`2<SpecialType, string> s_fromSpecialTypes;
    private static ConcurrentDictionary`2<string, SpecialType> s_toSpecialTypes;
    private static SpecialTypeAnnotation();
    public static SyntaxAnnotation Create(SpecialType specialType);
    public static SpecialType GetSpecialType(SyntaxAnnotation annotation);
    private static string CreateFromSpecialTypes(SpecialType arg);
    private static SpecialType CreateToSpecialTypes(string arg);
}
internal class Microsoft.CodeAnalysis.Simplification.SymbolAnnotation : object {
    public static string Kind;
    public static SyntaxAnnotation Create(ISymbol symbol);
    public static ISymbol GetSymbol(SyntaxAnnotation annotation, Compilation compilation);
    public static IEnumerable`1<ISymbol> GetSymbols(SyntaxAnnotation annotation, Compilation compilation);
}
public class Microsoft.CodeAnalysis.Solution : object {
    private BranchId _branchId;
    private int _workspaceVersion;
    private SolutionServices _solutionServices;
    private SolutionId _id;
    private string _filePath;
    private IReadOnlyList`1<ProjectId> _projectIds;
    private ImmutableDictionary`2<ProjectId, ProjectState> _projectIdToProjectStateMap;
    private ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> _linkedFilesMap;
    private VersionStamp _version;
    private Lazy`1<VersionStamp> _lazyLatestProjectVersion;
    private ProjectDependencyGraph _dependencyGraph;
    private ImmutableHashMap`2<ProjectId, Project> _projectIdToProjectMap;
    private ImmutableDictionary`2<ProjectId, CompilationTracker> _projectIdToTrackerMap;
    private static Func`3<ProjectId, Solution, Project> s_createProjectFunction;
    private static Func`3<ProjectId, Solution, CompilationTracker> s_createCompilationTrackerFunction;
    private SolutionBranch _firstBranch;
    private NonReentrantLock _stateLockBackingField;
    private WeakReference`1<Solution> _latestSolutionWithPartialCompilation;
    private DateTime _timeOfLatestSolutionWithPartialCompilation;
    private DocumentId _documentIdOfLatestSolutionWithPartialCompilation;
    private static ConditionalWeakTable`2<MetadataReference, ProjectId> s_metadataReferenceToProjectMap;
    internal int WorkspaceVersion { get; }
    internal SolutionServices Services { get; }
    internal BranchId BranchId { get; }
    public Workspace Workspace { get; }
    public SolutionId Id { get; }
    public string FilePath { get; }
    public VersionStamp Version { get; }
    public IReadOnlyList`1<ProjectId> ProjectIds { get; }
    public IEnumerable`1<Project> Projects { get; }
    private NonReentrantLock StateLock { get; }
    private Solution(BranchId branchId, int workspaceVersion, SolutionServices solutionServices, SolutionId id, string filePath, IEnumerable`1<ProjectId> projectIds, ImmutableDictionary`2<ProjectId, ProjectState> idToProjectStateMap, ImmutableDictionary`2<ProjectId, CompilationTracker> projectIdToTrackerMap, ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> linkedFilesMap, ProjectDependencyGraph dependencyGraph, VersionStamp version, Lazy`1<VersionStamp> lazyLatestProjectVersion);
    internal Solution(Workspace workspace, SolutionInfo info);
    private static Solution();
    internal Solution WithNewWorkspace(Workspace workspace, int workspaceVersion);
    private VersionStamp ComputeLatestProjectVersion();
    internal int get_WorkspaceVersion();
    internal SolutionServices get_Services();
    internal BranchId get_BranchId();
    public Workspace get_Workspace();
    public SolutionId get_Id();
    public string get_FilePath();
    public VersionStamp get_Version();
    public IReadOnlyList`1<ProjectId> get_ProjectIds();
    public IEnumerable`1<Project> get_Projects();
    private void CheckInvariants();
    private Solution Branch(IEnumerable`1<ProjectId> projectIds, ImmutableDictionary`2<ProjectId, ProjectState> idToProjectStateMap, ImmutableDictionary`2<ProjectId, CompilationTracker> projectIdToTrackerMap, ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> linkedFilesMap, ProjectDependencyGraph dependencyGraph, Nullable`1<VersionStamp> version, Lazy`1<VersionStamp> lazyLatestProjectVersion);
    private Solution CreatePrimarySolution(BranchId branchId, int workspaceVersion, SolutionServices services);
    private BranchId GetBranchId();
    public VersionStamp GetLatestProjectVersion();
    public bool ContainsProject(ProjectId projectId);
    public Project GetProject(ProjectId projectId);
    private static Project CreateProject(ProjectId projectId, Solution solution);
    public Project GetProject(IAssemblySymbol assemblySymbol, CancellationToken cancellationToken);
    public bool ContainsDocument(DocumentId documentId);
    public bool ContainsAdditionalDocument(DocumentId documentId);
    public DocumentId GetDocumentId(SyntaxTree syntaxTree);
    public DocumentId GetDocumentId(SyntaxTree syntaxTree, ProjectId projectId);
    public Document GetDocument(DocumentId documentId);
    public TextDocument GetAdditionalDocument(DocumentId documentId);
    private DocumentState GetDocumentState(DocumentId documentId);
    private TextDocumentState GetAdditionalDocumentState(DocumentId documentId);
    public Document GetDocument(SyntaxTree syntaxTree);
    internal Document GetDocument(SyntaxTree syntaxTree, ProjectId projectId);
    internal Task`1<VersionStamp> GetDependentVersionAsync(ProjectId projectId, CancellationToken cancellationToken);
    internal Task`1<VersionStamp> GetDependentSemanticVersionAsync(ProjectId projectId, CancellationToken cancellationToken);
    internal ProjectState GetProjectState(ProjectId projectId);
    private bool TryGetCompilationTracker(ProjectId projectId, CompilationTracker& tracker);
    private static CompilationTracker CreateCompilationTracker(ProjectId projectId, Solution solution);
    private CompilationTracker GetCompilationTracker(ProjectId projectId);
    private Solution AddProject(ProjectId projectId, ProjectState projectState);
    public Project AddProject(string name, string assemblyName, string language);
    public Solution AddProject(ProjectId projectId, string name, string assemblyName, string language);
    public Solution AddProject(ProjectInfo projectInfo);
    private ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> CreateLinkedFilesMapWithAddedProject(ProjectState projectState);
    private ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> CreateLinkedFilesMapWithAddedDocuments(ProjectState projectState, IEnumerable`1<DocumentId> documentIds);
    public Solution RemoveProject(ProjectId projectId);
    private ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> CreateLinkedFilesMapWithRemovedProject(ProjectState projectState);
    private ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> CreateLinkedFilesMapWithRemovedDocuments(ProjectState projectState, IEnumerable`1<DocumentId> documentIds);
    public Solution WithProjectAssemblyName(ProjectId projectId, string assemblyName);
    public Solution WithProjectOutputFilePath(ProjectId projectId, string outputFilePath);
    public Solution WithProjectName(ProjectId projectId, string name);
    public Solution WithProjectFilePath(ProjectId projectId, string filePath);
    public Solution WithProjectCompilationOptions(ProjectId projectId, CompilationOptions options);
    public Solution WithProjectParseOptions(ProjectId projectId, ParseOptions options);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Solution/<ReplaceSyntaxTreesWithTreesFromNewProjectStateAsync>d__79")]
private static Task`1<Compilation> ReplaceSyntaxTreesWithTreesFromNewProjectStateAsync(Compilation compilation, ProjectState projectState, CancellationToken cancellationToken);
    public Solution AddProjectReference(ProjectId projectId, ProjectReference projectReference);
    public Solution AddProjectReferences(ProjectId projectId, IEnumerable`1<ProjectReference> projectReferences);
    public Solution RemoveProjectReference(ProjectId projectId, ProjectReference projectReference);
    public Solution WithProjectReferences(ProjectId projectId, IEnumerable`1<ProjectReference> projectReferences);
    public Solution AddMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    public Solution AddMetadataReferences(ProjectId projectId, IEnumerable`1<MetadataReference> metadataReferences);
    public Solution RemoveMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    public Solution WithProjectMetadataReferences(ProjectId projectId, IEnumerable`1<MetadataReference> metadataReferences);
    public Solution AddAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    public Solution AddAnalyzerReferences(ProjectId projectId, IEnumerable`1<AnalyzerReference> analyzerReferences);
    public Solution RemoveAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    public Solution WithProjectAnalyzerReferences(ProjectId projectId, IEnumerable`1<AnalyzerReference> analyzerReferences);
    private Solution AddDocument(DocumentState state);
    public Solution AddDocument(DocumentId documentId, string name, string text, IEnumerable`1<string> folders, string filePath);
    public Solution AddDocument(DocumentId documentId, string name, SourceText text, IEnumerable`1<string> folders, string filePath, bool isGenerated);
    private static SourceCodeKind GetSourceCodeKind(ProjectState project);
    public Solution AddDocument(DocumentId documentId, string name, SyntaxNode syntaxRoot, IEnumerable`1<string> folders, string filePath, bool isGenerated, PreservationMode preservationMode);
    public Solution AddDocument(DocumentId documentId, string name, TextLoader loader, IEnumerable`1<string> folders);
    public Solution AddDocument(DocumentInfo documentInfo);
    private Solution AddDocument(Document document);
    public Solution AddAdditionalDocument(DocumentId documentId, string name, string text, IEnumerable`1<string> folders, string filePath);
    public Solution AddAdditionalDocument(DocumentId documentId, string name, SourceText text, IEnumerable`1<string> folders, string filePath);
    public Solution AddAdditionalDocument(DocumentInfo documentInfo);
    private Solution AddAdditionalDocument(TextDocumentState state);
    public Solution RemoveDocument(DocumentId documentId);
    public Solution RemoveAdditionalDocument(DocumentId documentId);
    public Solution WithDocumentFolders(DocumentId documentId, IEnumerable`1<string> folders);
    public Solution WithDocumentText(DocumentId documentId, SourceText text, PreservationMode mode);
    public Solution WithAdditionalDocumentText(DocumentId documentId, SourceText text, PreservationMode mode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Solution/<WithMergedLinkedFileChangesAsync>d__109")]
internal Task`1<Solution> WithMergedLinkedFileChangesAsync(Solution oldSolution, Nullable`1<SolutionChanges> solutionChanges, IMergeConflictHandler mergeConflictHandler, CancellationToken cancellationToken);
    public Solution WithDocumentText(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode);
    public Solution WithAdditionalDocumentText(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode);
    public Solution WithDocumentSyntaxRoot(DocumentId documentId, SyntaxNode root, PreservationMode mode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Solution/<UpdateDocumentInCompilationAsync>d__115")]
private static Task`1<Compilation> UpdateDocumentInCompilationAsync(Compilation compilation, DocumentState oldDocument, DocumentState newDocument, CancellationToken cancellationToken);
    public Solution WithDocumentSourceCodeKind(DocumentId documentId, SourceCodeKind sourceCodeKind);
    public Solution WithDocumentTextLoader(DocumentId documentId, TextLoader loader, PreservationMode mode);
    public Solution WithAdditionalDocumentTextLoader(DocumentId documentId, TextLoader loader, PreservationMode mode);
    private Solution WithDocumentState(DocumentState newDocument, bool textChanged, bool recalculateDependentVersions);
    private Solution TouchDocument(DocumentId documentId, Func`2<ProjectState, ProjectState> touchProject);
    private Solution WithTextDocumentState(TextDocumentState newDocument, bool textChanged, bool recalculateDependentVersions);
    private Solution ForkProject(ProjectState newProjectState, CompilationTranslationAction translate, bool withProjectReferenceChange, ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> newLinkedFilesMap, bool forkTracker);
    public ImmutableArray`1<DocumentId> GetDocumentIdsWithFilePath(string filePath);
    private static ProjectDependencyGraph CreateDependencyGraph(IReadOnlyList`1<ProjectId> projectIds, ImmutableDictionary`2<ProjectId, ProjectState> projectStates);
    private ImmutableDictionary`2<ProjectId, CompilationTracker> CreateCompilationTrackerMap(ProjectId projectId, ProjectDependencyGraph dependencyGraph);
    public Solution GetIsolatedSolution();
    private NonReentrantLock get_StateLock();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Solution/<WithFrozenPartialCompilationIncludingSpecificDocumentAsync>d__133")]
internal Task`1<Solution> WithFrozenPartialCompilationIncludingSpecificDocumentAsync(DocumentId documentId, CancellationToken cancellationToken);
    public Solution WithDocumentText(IEnumerable`1<DocumentId> documentIds, SourceText text, PreservationMode mode);
    internal bool TryGetCompilation(ProjectId projectId, Compilation& compilation);
    internal Task`1<Compilation> GetCompilationAsync(ProjectId projectId, CancellationToken cancellationToken);
    internal Task`1<Compilation> GetCompilationAsync(Project project, CancellationToken cancellationToken);
    private void RecordReferencedProject(MetadataReference reference, ProjectId projectId);
    internal ProjectId GetProjectId(MetadataReference reference);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Solution/<GetMetadataReferenceAsync>d__141")]
internal Task`1<MetadataReference> GetMetadataReferenceAsync(ProjectReference projectReference, ProjectState fromProject, CancellationToken cancellationToken);
    internal MetadataReference GetPartialMetadataReference(ProjectReference projectReference, ProjectState fromProject, CancellationToken cancellationToken);
    public SolutionChanges GetChanges(Solution oldSolution);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Solution/<ContainsSymbolsWithNameAsync>d__144")]
internal Task`1<bool> ContainsSymbolsWithNameAsync(ProjectId id, Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Solution/<GetDocumentsWithName>d__145")]
internal Task`1<IEnumerable`1<Document>> GetDocumentsWithName(ProjectId id, Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Solution/<ConvertTreesToDocuments>d__146")]
private IEnumerable`1<Document> ConvertTreesToDocuments(ProjectId id, IEnumerable`1<SyntaxTree> trees);
    public ProjectDependencyGraph GetProjectDependencyGraph();
    private void CheckNotContainsProject(ProjectId projectId);
    private void CheckContainsProject(ProjectId projectId);
    private void CheckNotContainsProjectReference(ProjectId projectId, ProjectReference referencedProject);
    private void CheckNotContainsTransitiveReference(ProjectId fromProjectId, ProjectId toProjectId);
    private void CheckNotSecondSubmissionReference(ProjectId projectId, ProjectId toProjectId);
    private void CheckNotContainsDocument(DocumentId documentId);
    private void CheckNotContainsAdditionalDocument(DocumentId documentId);
    private void CheckContainsDocument(DocumentId documentId);
    private void CheckContainsAdditionalDocument(DocumentId documentId);
    [CompilerGeneratedAttribute]
private VersionStamp <.ctor>b__16_0();
    [CompilerGeneratedAttribute]
private Project <get_Projects>b__36_0(ProjectId id);
    [CompilerGeneratedAttribute]
private bool <CheckNotSecondSubmissionReference>b__152_0(ProjectReference p);
}
public class Microsoft.CodeAnalysis.SolutionChanges : ValueType {
    private Solution _newSolution;
    private Solution _oldSolution;
    internal SolutionChanges(Solution newSolution, Solution oldSolution);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SolutionChanges/<GetAddedProjects>d__3")]
public IEnumerable`1<Project> GetAddedProjects();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SolutionChanges/<GetProjectChanges>d__4")]
public IEnumerable`1<ProjectChanges> GetProjectChanges();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SolutionChanges/<GetRemovedProjects>d__5")]
public IEnumerable`1<Project> GetRemovedProjects();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.SolutionId : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    private string _debugName;
    public Guid Id { get; }
    private SolutionId(string debugName);
    [CompilerGeneratedAttribute]
public Guid get_Id();
    public static SolutionId CreateNewId(string debugName);
    private string GetDebuggerDisplay();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SolutionId other);
    public static bool op_Equality(SolutionId left, SolutionId right);
    public static bool op_Inequality(SolutionId left, SolutionId right);
    public virtual int GetHashCode();
}
public class Microsoft.CodeAnalysis.SolutionInfo : object {
    [CompilerGeneratedAttribute]
private SolutionId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionStamp <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ProjectInfo> <Projects>k__BackingField;
    public SolutionId Id { get; }
    public VersionStamp Version { get; }
    public string FilePath { get; }
    public IReadOnlyList`1<ProjectInfo> Projects { get; }
    private SolutionInfo(SolutionId id, VersionStamp version, string filePath, IEnumerable`1<ProjectInfo> projects);
    [CompilerGeneratedAttribute]
public SolutionId get_Id();
    [CompilerGeneratedAttribute]
public VersionStamp get_Version();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ProjectInfo> get_Projects();
    public static SolutionInfo Create(SolutionId id, VersionStamp version, string filePath, IEnumerable`1<ProjectInfo> projects);
}
internal class Microsoft.CodeAnalysis.SolutionServices : object {
    internal Workspace Workspace;
    internal ITemporaryStorageService TemporaryStorage;
    internal IMetadataService MetadataService;
    internal IProjectCacheHostService CacheService;
    internal bool SupportsCachingRecoverableObjects { get; }
    public SolutionServices(Workspace workspace);
    internal bool get_SupportsCachingRecoverableObjects();
}
internal abstract class Microsoft.CodeAnalysis.SymbolKey : object {
    private static SymbolKey s_null;
    private static SymbolKey();
    public abstract virtual SymbolKeyResolution Resolve(Compilation compilation, bool ignoreAssemblyKey, CancellationToken cancellationToken);
    public static IEqualityComparer`1<SymbolKey> GetComparer(bool ignoreCase, bool ignoreAssemblyKeys);
    internal static SymbolKey Create(ISymbol symbol, Compilation compilation, CancellationToken cancellationToken);
    private static SymbolKey GetOrCreate(ISymbol symbol, Visitor visitor);
    internal abstract virtual bool Equals(SymbolKey other, ComparisonOptions options);
    internal abstract virtual int GetHashCode(ComparisonOptions options);
    private static bool Equals(Compilation compilation, string name1, string name2);
    private static bool Equals(bool isCaseSensitive, string name1, string name2);
    private static int GetHashCode(bool isCaseSensitive, string metadataName);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SymbolKey/<GetAllSymbols>d__15")]
private static IEnumerable`1<ISymbol> GetAllSymbols(SymbolKeyResolution info);
    private static IEnumerable`1<TType> GetAllSymbols(SymbolKeyResolution info);
    private static SymbolKeyResolution CreateSymbolInfo(IEnumerable`1<ISymbol> symbols);
    private static SymbolKeyResolution CreateSymbolInfo(ISymbol[] symbols);
    private static bool ParametersMatch(ComparisonOptions options, Compilation compilation, ImmutableArray`1<IParameterSymbol> parameters, RefKind[] refKinds, SymbolKey[] typeKeys, CancellationToken cancellationToken);
    private static bool SequenceEquals(T[] array1, T[] array2, IEqualityComparer`1<T> comparer);
    private static bool SequenceEquals(ImmutableArray`1<T> array1, ImmutableArray`1<T> array2, IEqualityComparer`1<T> comparer);
    private static string GetName(string metadataName);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SymbolKeyExtensions : object {
    [ExtensionAttribute]
public static SymbolKey GetSymbolKey(ISymbol symbol);
}
internal class Microsoft.CodeAnalysis.SymbolKeyResolution : ValueType {
    private ISymbol _symbol;
    private ImmutableArray`1<ISymbol> _candidateSymbols;
    private CandidateReason _candidateReason;
    public ISymbol Symbol { get; }
    public ImmutableArray`1<ISymbol> CandidateSymbols { get; }
    public CandidateReason CandidateReason { get; }
    internal SymbolKeyResolution(ISymbol symbol);
    internal SymbolKeyResolution(ImmutableArray`1<ISymbol> candidateSymbols, CandidateReason candidateReason);
    public ISymbol get_Symbol();
    public ImmutableArray`1<ISymbol> get_CandidateSymbols();
    public CandidateReason get_CandidateReason();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SymbolKeyResolutionExtensions : object {
    [ExtensionAttribute]
internal static ISymbol GetAnySymbol(SymbolKeyResolution resolution);
    [ExtensionAttribute]
internal static IEnumerable`1<ISymbol> GetAllSymbols(SymbolKeyResolution resolution);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SymbolKeyResolutionExtensions/<GetAllSymbolsWorker>d__2")]
private static IEnumerable`1<ISymbol> GetAllSymbolsWorker(SymbolKeyResolution resolution);
}
internal class Microsoft.CodeAnalysis.SyntacticDocument : object {
    public Document Document;
    public SourceText Text;
    public SyntaxTree SyntaxTree;
    public SyntaxNode Root;
    public Project Project { get; }
    protected SyntacticDocument(Document document, SourceText text, SyntaxTree tree, SyntaxNode root);
    public Project get_Project();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SyntacticDocument/<CreateAsync>d__7")]
public static Task`1<SyntacticDocument> CreateAsync(Document document, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Text.TextExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Document> GetRelatedDocumentsWithChanges(SourceText text);
    [ExtensionAttribute]
public static Document GetOpenDocumentInCurrentContextWithChanges(SourceText text);
    [ExtensionAttribute]
public static IEnumerable`1<Document> GetRelatedDocuments(SourceTextContainer container);
    [ExtensionAttribute]
public static Document GetOpenDocumentInCurrentContext(SourceTextContainer container);
}
public class Microsoft.CodeAnalysis.TextAndVersion : object {
    [CompilerGeneratedAttribute]
private SourceText <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionStamp <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    public SourceText Text { get; }
    public VersionStamp Version { get; }
    public string FilePath { get; }
    private TextAndVersion(SourceText text, VersionStamp version, string filePath);
    [CompilerGeneratedAttribute]
public SourceText get_Text();
    [CompilerGeneratedAttribute]
public VersionStamp get_Version();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    public static TextAndVersion Create(SourceText text, VersionStamp version, string filePath);
}
public class Microsoft.CodeAnalysis.TextDocument : object {
    private TextDocumentState _state;
    [CompilerGeneratedAttribute]
private Project <Project>k__BackingField;
    public Project Project { get; protected set; }
    public DocumentId Id { get; }
    public string FilePath { get; }
    public string Name { get; }
    public IReadOnlyList`1<string> Folders { get; }
    internal TextDocument(Project project, TextDocumentState state);
    internal virtual TextDocumentState GetDocumentState();
    [CompilerGeneratedAttribute]
public Project get_Project();
    [CompilerGeneratedAttribute]
protected void set_Project(Project value);
    public DocumentId get_Id();
    public string get_FilePath();
    public string get_Name();
    public IReadOnlyList`1<string> get_Folders();
    public bool TryGetText(SourceText& text);
    public bool TryGetTextVersion(VersionStamp& version);
    public Task`1<SourceText> GetTextAsync(CancellationToken cancellationToken);
    public Task`1<VersionStamp> GetTextVersionAsync(CancellationToken cancellationToken);
    internal Task`1<VersionStamp> GetTopLevelChangeTextVersionAsync(CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.TextDocumentState : object {
    protected SolutionServices solutionServices;
    protected DocumentInfo info;
    protected ValueSource`1<TextAndVersion> textSource;
    private static double MaxDelaySecs;
    private static int MaxRetries;
    internal static TimeSpan RetryDelay;
    public DocumentId Id { get; }
    public string FilePath { get; }
    public DocumentInfo Info { get; }
    public IReadOnlyList`1<string> Folders { get; }
    public string Name { get; }
    protected TextDocumentState(SolutionServices solutionServices, DocumentInfo info, ValueSource`1<TextAndVersion> textSource);
    private static TextDocumentState();
    public DocumentId get_Id();
    public string get_FilePath();
    public DocumentInfo get_Info();
    public IReadOnlyList`1<string> get_Folders();
    public string get_Name();
    public static TextDocumentState Create(DocumentInfo info, SolutionServices services);
    protected static ValueSource`1<TextAndVersion> CreateStrongText(TextAndVersion text);
    protected static ValueSource`1<TextAndVersion> CreateStrongText(TextLoader loader, DocumentId documentId, SolutionServices services, bool reportInvalidDataException);
    protected static ValueSource`1<TextAndVersion> CreateRecoverableText(TextAndVersion text, SolutionServices services);
    protected static ValueSource`1<TextAndVersion> CreateRecoverableText(TextLoader loader, DocumentId documentId, SolutionServices services, bool reportInvalidDataException);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TextDocumentState/<LoadTextAsync>d__22")]
protected static Task`1<TextAndVersion> LoadTextAsync(TextLoader loader, DocumentId documentId, SolutionServices services, bool reportInvalidDataException, CancellationToken cancellationToken);
    public bool TryGetText(SourceText& text);
    public bool TryGetTextVersion(VersionStamp& version);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TextDocumentState/<GetTextAsync>d__25")]
public Task`1<SourceText> GetTextAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TextDocumentState/<GetTextVersionAsync>d__26")]
public Task`1<VersionStamp> GetTextVersionAsync(CancellationToken cancellationToken);
    public TextDocumentState UpdateText(TextAndVersion newTextAndVersion, PreservationMode mode);
    public TextDocumentState UpdateText(SourceText newText, PreservationMode mode);
    public TextDocumentState UpdateText(TextLoader loader, PreservationMode mode);
    private VersionStamp GetNewerVersion();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TextDocumentState/<GetTopLevelChangeTextVersionAsync>d__31")]
public virtual Task`1<VersionStamp> GetTopLevelChangeTextVersionAsync(CancellationToken cancellationToken);
}
public abstract class Microsoft.CodeAnalysis.TextLoader : object {
    public abstract virtual Task`1<TextAndVersion> LoadTextAndVersionAsync(Workspace workspace, DocumentId documentId, CancellationToken cancellationToken);
    public static TextLoader From(TextAndVersion textAndVersion);
    public static TextLoader From(SourceTextContainer container, VersionStamp version, string filePath);
}
internal class Microsoft.CodeAnalysis.TreeAndVersion : object {
    [CompilerGeneratedAttribute]
private SyntaxTree <Tree>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionStamp <Version>k__BackingField;
    public SyntaxTree Tree { get; }
    public VersionStamp Version { get; }
    private TreeAndVersion(SyntaxTree tree, VersionStamp version);
    [CompilerGeneratedAttribute]
public SyntaxTree get_Tree();
    [CompilerGeneratedAttribute]
public VersionStamp get_Version();
    public static TreeAndVersion Create(SyntaxTree tree, VersionStamp version);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Host.ITemporaryStorageService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.TrivialTemporaryStorageService : object {
    public sealed virtual ITemporaryStreamStorage CreateTemporaryStreamStorage(CancellationToken cancellationToken);
    public sealed virtual ITemporaryTextStorage CreateTemporaryTextStorage(CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.UnmergedDocumentChanges : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<TextChange> <UnmergedChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    public IEnumerable`1<TextChange> UnmergedChanges { get; }
    public string ProjectName { get; }
    public DocumentId DocumentId { get; }
    public UnmergedDocumentChanges(IEnumerable`1<TextChange> unmergedChanges, string projectName, DocumentId documentId);
    [CompilerGeneratedAttribute]
public IEnumerable`1<TextChange> get_UnmergedChanges();
    [CompilerGeneratedAttribute]
public string get_ProjectName();
    [CompilerGeneratedAttribute]
public DocumentId get_DocumentId();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Versions.Extensions : object {
    [ExtensionAttribute]
public static bool CanReusePersistedTextVersion(Document document, VersionStamp textVersion, VersionStamp persistedVersion);
    [ExtensionAttribute]
public static bool CanReusePersistedSyntaxTreeVersion(Document document, VersionStamp syntaxVersion, VersionStamp persistedVersion);
    [ExtensionAttribute]
public static bool CanReusePersistedProjectVersion(Project project, VersionStamp projectVersion, VersionStamp persistedVersion);
    [ExtensionAttribute]
public static bool CanReusePersistedDependentProjectVersion(Project project, VersionStamp dependentProjectVersion, VersionStamp persistedVersion);
    [ExtensionAttribute]
public static bool CanReusePersistedSemanticVersion(Project project, VersionStamp projectVersion, VersionStamp semanticVersion, VersionStamp persistedVersion);
    [ExtensionAttribute]
public static bool CanReusePersistedDependentSemanticVersion(Project project, VersionStamp dependentProjectVersion, VersionStamp dependentSemanticVersion, VersionStamp persistedVersion);
    private static bool CanReusePersistedSemanticVersionInternal(Project project, VersionStamp projectVersion, VersionStamp semanticVersion, VersionStamp persistedVersion, Func`4<ISemanticVersionTrackingService, Project, VersionStamp, VersionStamp> versionGetter);
}
internal interface Microsoft.CodeAnalysis.Versions.ISemanticVersionTrackingService {
    public abstract virtual VersionStamp GetInitialProjectVersionFromSemanticVersion(Project project, VersionStamp semanticVersion);
    public abstract virtual VersionStamp GetInitialDependentProjectVersionFromDependentSemanticVersion(Project project, VersionStamp dependentSemanticVersion);
    public abstract virtual void LoadInitialSemanticVersions(Solution solution);
    public abstract virtual void LoadInitialSemanticVersions(Project project);
    public abstract virtual Task RecordSemanticVersionsAsync(Project project, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Versions.PersistedVersionStampLogger : object {
    private static string Text;
    private static string SyntaxTree;
    private static string Project;
    private static string DependentProject;
    private static string Semantic;
    private static string DependentSemantic;
    private static string ProjectCount;
    private static string InitialSemanticVersionCount;
    private static string InitialDependentSemanticVersionCount;
    private static LogAggregator s_logAggregator;
    private static PersistedVersionStampLogger();
    public static void LogPersistedTextVersionUsage(bool succeeded);
    public static void LogPersistedSyntaxTreeVersionUsage(bool succeeded);
    public static void LogPersistedProjectVersionUsage(bool succeeded);
    public static void LogPersistedDependentProjectVersionUsage(bool succeeded);
    public static void LogPersistedSemanticVersionUsage(bool succeeded);
    public static void LogPersistedDependentSemanticVersionUsage(bool succeeded);
    public static void LogProject();
    public static void LogInitialSemanticVersion();
    public static void LogInitialDependentSemanticVersion();
    public static void LogSummary();
}
public class Microsoft.CodeAnalysis.VersionStamp : ValueType {
    private static int GlobalVersionMarker;
    private static int InitialGlobalVersion;
    private static int s_globalVersion;
    private DateTime _utcLastModified;
    private int _localIncrement;
    private int _globalIncrement;
    public static VersionStamp Default { get; }
    private VersionStamp(DateTime utcLastModified);
    private VersionStamp(DateTime utcLastModified, int localIncrement);
    private VersionStamp(DateTime utcLastModified, int localIncrement, int globalIncrement);
    private static VersionStamp();
    public static VersionStamp get_Default();
    public static VersionStamp Create();
    public static VersionStamp Create(DateTime utcTimeLastModified);
    public VersionStamp GetNewerVersion(VersionStamp version);
    public VersionStamp GetNewerVersion();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(VersionStamp version);
    public static bool op_Equality(VersionStamp left, VersionStamp right);
    public static bool op_Inequality(VersionStamp left, VersionStamp right);
    internal static bool CanReusePersistedVersion(VersionStamp baseVersion, VersionStamp persistedVersion);
    private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    internal void WriteTo(ObjectWriter writer);
    internal static VersionStamp ReadFrom(ObjectReader reader);
    private static int GetGlobalVersion(VersionStamp version);
    private static int GetNextGlobalVersion();
    internal bool TestOnly_IsNewerThan(VersionStamp version);
}
public abstract class Microsoft.CodeAnalysis.Workspace : object {
    private string _workspaceKind;
    private HostWorkspaceServices _services;
    private BranchId _primaryBranchId;
    private NonReentrantLock _serializationLock;
    private NonReentrantLock _stateLock;
    private Solution _latestSolution;
    private IWorkspaceTaskScheduler _taskQueue;
    internal static bool TestHookStandaloneProjectsDoNotHoldReferences;
    [CompilerGeneratedAttribute]
private bool <TestHookPartialSolutionsDisabled>k__BackingField;
    private Dictionary`2<ProjectId, ISet`1<DocumentId>> _projectToOpenDocumentsMap;
    private Dictionary`2<SourceTextContainer, DocumentId> _bufferToDocumentInCurrentContextMap;
    private Dictionary`2<SourceTextContainer, ImmutableArray`1<DocumentId>> _bufferToDocumentIdMap;
    private Dictionary`2<DocumentId, TextTracker> _textTrackers;
    private EventMap _eventMap;
    private static string WorkspaceChangeEventName;
    private static string WorkspaceFailedEventName;
    private static string DocumentOpenedEventName;
    private static string DocumentClosedEventName;
    private static string DocumentActiveContextChangedName;
    private static ConditionalWeakTable`2<SourceTextContainer, WorkspaceRegistration> s_bufferToWorkspaceRegistrationMap;
    private static CreateValueCallback<SourceTextContainer, WorkspaceRegistration> s_createRegistration;
    internal bool TestHookPartialSolutionsDisabled { get; internal set; }
    public HostWorkspaceServices Services { get; }
    internal BranchId PrimaryBranchId { get; }
    protected internal bool PartialSemanticsEnabled { get; }
    public string Kind { get; }
    public Solution CurrentSolution { get; }
    public OptionSet Options { get; public set; }
    public bool CanOpenDocuments { get; }
    internal bool CanChangeActiveContextDocument { get; }
    protected Workspace(HostServices host, string workspaceKind);
    private static Workspace();
    [CompilerGeneratedAttribute]
internal bool get_TestHookPartialSolutionsDisabled();
    [CompilerGeneratedAttribute]
internal void set_TestHookPartialSolutionsDisabled(bool value);
    public HostWorkspaceServices get_Services();
    internal BranchId get_PrimaryBranchId();
    protected internal virtual bool get_PartialSemanticsEnabled();
    public string get_Kind();
    protected internal Solution CreateSolution(SolutionInfo solutionInfo);
    protected internal Solution CreateSolution(SolutionId id);
    public Solution get_CurrentSolution();
    protected Solution SetCurrentSolution(Solution solution);
    public OptionSet get_Options();
    public void set_Options(OptionSet value);
    protected internal Task ScheduleTask(Action action, string taskName);
    protected internal Task`1<T> ScheduleTask(Func`1<T> func, string taskName);
    protected virtual void OnDocumentTextChanged(Document document);
    protected virtual void OnDocumentClosing(DocumentId documentId);
    protected void ClearSolution();
    protected virtual void ClearSolutionData();
    protected virtual void ClearProjectData(ProjectId projectId);
    protected virtual void ClearDocumentData(DocumentId documentId);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool finalize);
    protected internal void OnSolutionAdded(SolutionInfo solutionInfo);
    protected internal void OnSolutionReloaded(SolutionInfo reloadedSolutionInfo);
    protected internal void OnSolutionRemoved();
    protected internal void OnProjectAdded(ProjectInfo projectInfo);
    private void OnProjectAdded(ProjectInfo projectInfo, bool silent);
    private void OnProjectAdded_NoLock(ProjectInfo projectInfo, bool silent);
    protected internal virtual void OnProjectReloaded(ProjectInfo reloadedProjectInfo);
    protected internal virtual void OnProjectRemoved(ProjectId projectId);
    protected virtual void CheckProjectCanBeRemoved(ProjectId projectId);
    protected internal void OnAssemblyNameChanged(ProjectId projectId, string assemblyName);
    protected internal void OnOutputFilePathChanged(ProjectId projectId, string outputFilePath);
    protected internal void OnProjectNameChanged(ProjectId projectId, string name, string filePath);
    protected internal void OnCompilationOptionsChanged(ProjectId projectId, CompilationOptions options);
    protected internal void OnParseOptionsChanged(ProjectId projectId, ParseOptions options);
    protected internal void OnProjectReferenceAdded(ProjectId projectId, ProjectReference projectReference);
    protected internal void OnProjectReferenceRemoved(ProjectId projectId, ProjectReference projectReference);
    protected internal void OnMetadataReferenceAdded(ProjectId projectId, MetadataReference metadataReference);
    protected internal void OnMetadataReferenceRemoved(ProjectId projectId, MetadataReference metadataReference);
    protected internal void OnAnalyzerReferenceAdded(ProjectId projectId, AnalyzerReference analyzerReference);
    protected internal void OnAnalyzerReferenceRemoved(ProjectId projectId, AnalyzerReference analyzerReference);
    protected internal void OnDocumentAdded(DocumentInfo documentInfo);
    protected internal void OnDocumentReloaded(DocumentInfo newDocumentInfo);
    protected internal void OnDocumentRemoved(DocumentId documentId);
    protected virtual void CheckDocumentCanBeRemoved(DocumentId documentId);
    protected internal void OnDocumentTextLoaderChanged(DocumentId documentId, TextLoader loader);
    protected internal void OnAdditionalDocumentTextLoaderChanged(DocumentId documentId, TextLoader loader);
    protected internal void OnDocumentTextChanged(DocumentId documentId, SourceText newText, PreservationMode mode);
    protected internal void OnAdditionalDocumentTextChanged(DocumentId documentId, SourceText newText, PreservationMode mode);
    protected internal void OnDocumentSourceCodeKindChanged(DocumentId documentId, SourceCodeKind sourceCodeKind);
    protected internal void OnAdditionalDocumentAdded(DocumentInfo documentInfo);
    protected internal void OnAdditionalDocumentRemoved(DocumentId documentId);
    public virtual bool CanApplyChange(ApplyChangesKind feature);
    public virtual bool TryApplyChanges(Solution newSolution);
    private void CheckAllowedSolutionChanges(SolutionChanges solutionChanges);
    private void CheckAllowedProjectChanges(ProjectChanges projectChanges);
    protected virtual void ApplyProjectChanges(ProjectChanges projectChanges);
    [ConditionalAttribute("DEBUG")]
private void CheckNoChanges(Solution oldSolution, Solution newSolution);
    private ProjectInfo CreateProjectInfo(Project project);
    private SourceText GetTextForced(TextDocument doc);
    private DocumentInfo CreateDocumentInfoWithText(TextDocument doc);
    private DocumentInfo CreateDocumentInfoWithoutText(TextDocument doc);
    protected virtual void ApplyProjectAdded(ProjectInfo project);
    protected virtual void ApplyProjectRemoved(ProjectId projectId);
    protected virtual void ApplyCompilationOptionsChanged(ProjectId projectId, CompilationOptions options);
    protected virtual void ApplyParseOptionsChanged(ProjectId projectId, ParseOptions options);
    protected virtual void ApplyProjectReferenceAdded(ProjectId projectId, ProjectReference projectReference);
    protected virtual void ApplyProjectReferenceRemoved(ProjectId projectId, ProjectReference projectReference);
    protected virtual void ApplyMetadataReferenceAdded(ProjectId projectId, MetadataReference metadataReference);
    protected virtual void ApplyMetadataReferenceRemoved(ProjectId projectId, MetadataReference metadataReference);
    protected virtual void ApplyAnalyzerReferenceAdded(ProjectId projectId, AnalyzerReference analyzerReference);
    protected virtual void ApplyAnalyzerReferenceRemoved(ProjectId projectId, AnalyzerReference analyzerReference);
    protected virtual void ApplyDocumentAdded(DocumentInfo info, SourceText text);
    protected virtual void ApplyDocumentRemoved(DocumentId documentId);
    protected virtual void ApplyDocumentTextChanged(DocumentId id, SourceText text);
    protected virtual void ApplyAdditionalDocumentAdded(DocumentInfo info, SourceText text);
    protected virtual void ApplyAdditionalDocumentRemoved(DocumentId documentId);
    protected virtual void ApplyAdditionalDocumentTextChanged(DocumentId id, SourceText text);
    protected void CheckSolutionIsEmpty();
    protected void CheckProjectIsInCurrentSolution(ProjectId projectId);
    protected void CheckProjectIsNotInCurrentSolution(ProjectId projectId);
    protected void CheckProjectHasProjectReference(ProjectId fromProjectId, ProjectReference projectReference);
    protected void CheckProjectDoesNotHaveProjectReference(ProjectId fromProjectId, ProjectReference projectReference);
    protected void CheckProjectDoesNotHaveTransitiveProjectReference(ProjectId fromProjectId, ProjectId toProjectId);
    private ISet`1<ProjectId> GetTransitiveProjectReferences(ProjectId project, ISet`1<ProjectId> projects);
    protected void CheckProjectHasMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    protected void CheckProjectDoesNotHaveMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    protected void CheckProjectHasAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    protected void CheckProjectDoesNotHaveAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    protected void CheckDocumentIsInCurrentSolution(DocumentId documentId);
    protected void CheckAdditionalDocumentIsInCurrentSolution(DocumentId documentId);
    protected void CheckDocumentIsNotInCurrentSolution(DocumentId documentId);
    protected void CheckAdditionalDocumentIsNotInCurrentSolution(DocumentId documentId);
    protected virtual string GetProjectName(ProjectId projectId);
    protected virtual string GetDocumentName(DocumentId documentId);
    protected virtual string GetAdditionalDocumentName(DocumentId documentId);
    public virtual bool get_CanOpenDocuments();
    internal virtual bool get_CanChangeActiveContextDocument();
    private static void RemoveIfEmpty(IDictionary`2<TKey, ISet`1<TValue>> dictionary, TKey key);
    private void ClearOpenDocuments();
    private void ClearOpenDocuments(ProjectId projectId);
    protected void ClearOpenDocument(DocumentId documentId, bool isSolutionClosing);
    private DocumentId ClearOpenDocument_NoLock(DocumentId documentId);
    public virtual void OpenDocument(DocumentId documentId, bool activate);
    public virtual void CloseDocument(DocumentId documentId);
    public virtual void OpenAdditionalDocument(DocumentId documentId, bool activate);
    public virtual void CloseAdditionalDocument(DocumentId documentId);
    protected void CheckCanOpenDocuments();
    protected void CheckProjectDoesNotContainOpenDocuments(ProjectId projectId);
    private bool ProjectHasOpenDocuments(ProjectId projectId);
    public virtual bool IsDocumentOpen(DocumentId documentId);
    public virtual IEnumerable`1<DocumentId> GetOpenDocumentIds(ProjectId projectId);
    public virtual IEnumerable`1<DocumentId> GetRelatedDocumentIds(SourceTextContainer container);
    private ImmutableArray`1<DocumentId> GetRelatedDocumentIds_NoLock(SourceTextContainer container);
    public virtual DocumentId GetDocumentIdInCurrentContext(SourceTextContainer container);
    internal virtual DocumentId GetDocumentIdInCurrentContext(DocumentId documentId);
    private DocumentId GetDocumentIdInCurrentContext_NoLock(SourceTextContainer container);
    internal virtual void SetDocumentContext(DocumentId documentId);
    protected void OnDocumentContextUpdated(DocumentId documentId);
    internal void OnDocumentContextUpdated(DocumentId documentId, SourceTextContainer container);
    protected void CheckDocumentIsClosed(DocumentId documentId);
    protected void CheckDocumentIsOpen(DocumentId documentId);
    private ISet`1<DocumentId> GetProjectOpenDocuments_NoLock(ProjectId project);
    protected internal void OnDocumentOpened(DocumentId documentId, SourceTextContainer textContainer, bool isCurrentContext);
    private void SignupForTextChanges(DocumentId documentId, SourceTextContainer textContainer, bool isCurrentContext, Action`4<Workspace, DocumentId, SourceText, PreservationMode> onChangedHandler);
    private void AddToOpenDocumentMap(DocumentId documentId);
    protected internal void OnAdditionalDocumentOpened(DocumentId documentId, SourceTextContainer textContainer, bool isCurrentContext);
    protected internal void OnDocumentClosed(DocumentId documentId, TextLoader reloader, bool updateActiveContext);
    private DocumentId ForgetAnyOpenDocumentInfo(DocumentId documentId);
    protected internal void OnAdditionalDocumentClosed(DocumentId documentId, TextLoader reloader);
    private void AddTextToDocumentIdMapping_NoLock(SourceTextContainer textContainer, DocumentId id, bool isCurrentContext);
    private DocumentId RemoveTextToDocumentIdMapping_NoLock(SourceTextContainer textContainer, DocumentId id);
    private SourceText GetOpenDocumentText(Solution solution, DocumentId documentId);
    protected virtual Solution AdjustReloadedSolution(Solution oldSolution, Solution reloadedSolution);
    protected virtual Project AdjustReloadedProject(Project oldProject, Project reloadedProject);
    public void add_WorkspaceChanged(EventHandler`1<WorkspaceChangeEventArgs> value);
    public void remove_WorkspaceChanged(EventHandler`1<WorkspaceChangeEventArgs> value);
    protected Task RaiseWorkspaceChangedEventAsync(WorkspaceChangeKind kind, Solution oldSolution, Solution newSolution, ProjectId projectId, DocumentId documentId);
    public void add_WorkspaceFailed(EventHandler`1<WorkspaceDiagnosticEventArgs> value);
    public void remove_WorkspaceFailed(EventHandler`1<WorkspaceDiagnosticEventArgs> value);
    protected internal virtual void OnWorkspaceFailed(WorkspaceDiagnostic diagnostic);
    public void add_DocumentOpened(EventHandler`1<DocumentEventArgs> value);
    public void remove_DocumentOpened(EventHandler`1<DocumentEventArgs> value);
    protected Task RaiseDocumentOpenedEventAsync(Document document);
    public void add_DocumentClosed(EventHandler`1<DocumentEventArgs> value);
    public void remove_DocumentClosed(EventHandler`1<DocumentEventArgs> value);
    protected Task RaiseDocumentClosedEventAsync(Document document);
    internal void add_DocumentActiveContextChanged(EventHandler`1<DocumentEventArgs> value);
    internal void remove_DocumentActiveContextChanged(EventHandler`1<DocumentEventArgs> value);
    protected Task RaiseDocumentActiveContextChangedEventAsync(Document document);
    public static bool TryGetWorkspace(SourceTextContainer textContainer, Workspace& workspace);
    protected void RegisterText(SourceTextContainer textContainer);
    protected void UnregisterText(SourceTextContainer textContainer);
    private static WorkspaceRegistration CreateRegistration(SourceTextContainer container);
    public static WorkspaceRegistration GetWorkspaceRegistration(SourceTextContainer textContainer);
    [CompilerGeneratedAttribute]
private void <OnSolutionAdded>b__39_0(ProjectInfo p);
    [CompilerGeneratedAttribute]
private void <OnSolutionReloaded>b__40_0(ProjectInfo pi);
    [CompilerGeneratedAttribute]
private DocumentInfo <CreateProjectInfo>b__76_0(Document d);
    [CompilerGeneratedAttribute]
private DocumentInfo <CreateProjectInfo>b__76_1(TextDocument d);
}
public class Microsoft.CodeAnalysis.WorkspaceChangeEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private WorkspaceChangeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private Solution <OldSolution>k__BackingField;
    [CompilerGeneratedAttribute]
private Solution <NewSolution>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectId <ProjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    public WorkspaceChangeKind Kind { get; }
    public Solution OldSolution { get; }
    public Solution NewSolution { get; }
    public ProjectId ProjectId { get; }
    public DocumentId DocumentId { get; }
    public WorkspaceChangeEventArgs(WorkspaceChangeKind kind, Solution oldSolution, Solution newSolution, ProjectId projectId, DocumentId documentId);
    [CompilerGeneratedAttribute]
public WorkspaceChangeKind get_Kind();
    [CompilerGeneratedAttribute]
public Solution get_OldSolution();
    [CompilerGeneratedAttribute]
public Solution get_NewSolution();
    [CompilerGeneratedAttribute]
public ProjectId get_ProjectId();
    [CompilerGeneratedAttribute]
public DocumentId get_DocumentId();
}
public enum Microsoft.CodeAnalysis.WorkspaceChangeKind : Enum {
    public int value__;
    public static WorkspaceChangeKind SolutionChanged;
    public static WorkspaceChangeKind SolutionAdded;
    public static WorkspaceChangeKind SolutionRemoved;
    public static WorkspaceChangeKind SolutionCleared;
    public static WorkspaceChangeKind SolutionReloaded;
    public static WorkspaceChangeKind ProjectAdded;
    public static WorkspaceChangeKind ProjectRemoved;
    public static WorkspaceChangeKind ProjectChanged;
    public static WorkspaceChangeKind ProjectReloaded;
    public static WorkspaceChangeKind DocumentAdded;
    public static WorkspaceChangeKind DocumentRemoved;
    public static WorkspaceChangeKind DocumentReloaded;
    public static WorkspaceChangeKind DocumentChanged;
    public static WorkspaceChangeKind AdditionalDocumentAdded;
    public static WorkspaceChangeKind AdditionalDocumentRemoved;
    public static WorkspaceChangeKind AdditionalDocumentReloaded;
    public static WorkspaceChangeKind AdditionalDocumentChanged;
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.WorkspaceDiagnostic : object {
    [CompilerGeneratedAttribute]
private WorkspaceDiagnosticKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public WorkspaceDiagnosticKind Kind { get; }
    public string Message { get; }
    public WorkspaceDiagnostic(WorkspaceDiagnosticKind kind, string message);
    [CompilerGeneratedAttribute]
public WorkspaceDiagnosticKind get_Kind();
    [CompilerGeneratedAttribute]
public string get_Message();
    public virtual string ToString();
    internal string GetDebuggerDisplay();
}
public class Microsoft.CodeAnalysis.WorkspaceDiagnosticEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private WorkspaceDiagnostic <Diagnostic>k__BackingField;
    public WorkspaceDiagnostic Diagnostic { get; }
    public WorkspaceDiagnosticEventArgs(WorkspaceDiagnostic diagnostic);
    [CompilerGeneratedAttribute]
public WorkspaceDiagnostic get_Diagnostic();
}
public enum Microsoft.CodeAnalysis.WorkspaceDiagnosticKind : Enum {
    public int value__;
    public static WorkspaceDiagnosticKind Failure;
    public static WorkspaceDiagnosticKind Warning;
}
public static class Microsoft.CodeAnalysis.WorkspaceKind : object {
    public static string Host;
    public static string Debugger;
    public static string Interactive;
    public static string MetadataAsSource;
    public static string MiscellaneousFiles;
    public static string Preview;
}
public class Microsoft.CodeAnalysis.WorkspaceRegistration : object {
    private Workspace _registeredWorkspace;
    [CompilerGeneratedAttribute]
private EventHandler WorkspaceChanged;
    public Workspace Workspace { get; }
    public Workspace get_Workspace();
    [CompilerGeneratedAttribute]
public void add_WorkspaceChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_WorkspaceChanged(EventHandler value);
    internal void SetWorkspaceAndRaiseEvents(Workspace workspace);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.CodeAnalysis.WorkspacesResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AbsolutePathExpected { get; }
    internal static string AddedHeader { get; }
    internal static string AddingAdditionalDocumentsNotSupported { get; }
    internal static string AddingAnalyzerReferencesNotSupported { get; }
    internal static string AddingDocumentsNotSupported { get; }
    internal static string AddingMetadataReferenceNotSupported { get; }
    internal static string AddingProjectReferencesNotSupported { get; }
    internal static string AddingProjectsNotSupported { get; }
    internal static string AfterHeader { get; }
    internal static string AnalyzerIsAlreadyPresent { get; }
    internal static string AnalyzerIsNotPresent { get; }
    internal static string ArraysWithMoreThanOneDimensionCannotBeSerialized { get; }
    internal static string BeforeHeader { get; }
    internal static string CannotCodeGenUnsupportedOperator { get; }
    internal static string CannotOpenProjectUnrecognizedFileExtension { get; }
    internal static string CannotOpenProjectUnsupportedLanguage { get; }
    internal static string CantResolveAnalyzerReference { get; }
    internal static string CantResolveMetadataReference { get; }
    internal static string CastIsRedundant { get; }
    internal static string CausesCircularProjectReference { get; }
    internal static string ChangingAdditionalDocumentsIsNotSupported { get; }
    internal static string ChangingCompilationOptionsNotSupported { get; }
    internal static string ChangingDocumentsNotSupported { get; }
    internal static string ChangingParseOptionsNotSupported { get; }
    internal static string ChangingProjectPropertiesNotSupported { get; }
    internal static string CouldNotFindLocationToGen { get; }
    internal static string CycleDetectedInExtensions { get; }
    internal static string DestinationLocationFromDifferentTree { get; }
    internal static string DiagnosticCannotBeNull { get; }
    internal static string DiagnosticMustHaveMatchingSpan { get; }
    internal static string DiagnosticsCannotBeEmpty { get; }
    internal static string DocumentAlreadyInSolution { get; }
    internal static string DocumentIsNotOpen { get; }
    internal static string DocumentIsOpen { get; }
    internal static string DocumentNotInProject { get; }
    internal static string DocumentNotInSolution { get; }
    internal static string DocumentVersionIsDifferent { get; }
    internal static string DuplicateKey { get; }
    internal static string DuplicateSourceFileInProject { get; }
    internal static string ErrorWhileReadingSpecifiedConfigFile { get; }
    internal static string FileWasExternallyModified { get; }
    internal static string FixAllOccurrencesOfDiagnostic { get; }
    internal static string FixAllOccurrencesOfDiagnosticInScope { get; }
    internal static string FixAllOccurrencesOfDiagnosticInSolution { get; }
    internal static string InvalidCodePage { get; }
    internal static string InvalidDestinationNode { get; }
    internal static string InvalidDestinationNode2 { get; }
    internal static string InvalidDestinationNode3 { get; }
    internal static string InvalidDocumentationCommentId { get; }
    internal static string InvalidLanguageNameOption { get; }
    internal static string InvalidLanguageNameOption2 { get; }
    internal static string InvalidLocationForCodeGen { get; }
    internal static string InvalidNonSourceLocationForCodeGen { get; }
    internal static string InvalidParameterCountForBinaryOperator { get; }
    internal static string InvalidParameterCountForUnaryOperator { get; }
    internal static string InvalidProjectBlockInSolutionFile { get; }
    internal static string InvalidProjectBlockInSolutionFile2 { get; }
    internal static string InvalidProjectBlockInSolutionFile3 { get; }
    internal static string InvalidProjectBlockInSolutionFile4 { get; }
    internal static string InvalidProjectFilePath { get; }
    internal static string InvalidSolutionFilePath { get; }
    internal static string InvalidSubmissionReference { get; }
    internal static string LabelForNodeIsInvalid { get; }
    internal static string LocationMustBeNullOrFromSource { get; }
    internal static string MatchingNodesMustHaveTheSameLabel { get; }
    internal static string MetadataIsAlreadyReferenced { get; }
    internal static string MetadataIsNotReferenced { get; }
    internal static string MissingEndOfFileInSolutionFile { get; }
    internal static string MissingHeaderInSolutionFile { get; }
    internal static string MissingLineInSolutionFile { get; }
    internal static string NameCanBeSimplified { get; }
    internal static string NoBinderException { get; }
    internal static string NodeIsOfTheWrongType { get; }
    internal static string NodeMustBeContainedInTheNewTree { get; }
    internal static string NodeMustBeContainedInTheOldTree { get; }
    internal static string NoReaderException { get; }
    internal static string NotWritableException { get; }
    internal static string OpenDocumentNotSupported { get; }
    internal static string PathMustBeAbsolute { get; }
    internal static string ProjectAlreadyInSolution { get; }
    internal static string ProjectAlreadyReferenced { get; }
    internal static string ProjectContainsOpenDocuments { get; }
    internal static string ProjectDirectlyReferencesTargetProject { get; }
    internal static string ProjectFileNotFound { get; }
    internal static string ProjectNotInSolution { get; }
    internal static string ProjectNotReferenced { get; }
    internal static string ProjectOrDocumentAlreadyInWorkspace { get; }
    internal static string ProjectOrDocumentNotInWorkspace { get; }
    internal static string ProjectTransitivelyReferencesTargetProject { get; }
    internal static string RemovedHeader { get; }
    internal static string RemovingAdditionalDocumentsIsNotSupported { get; }
    internal static string RemovingAnalyzerReferencesNotSupported { get; }
    internal static string RemovingDocumentsNotSupported { get; }
    internal static string RemovingMetadataReferencesNotSupported { get; }
    internal static string RemovingProjectReferencesNotSupported { get; }
    internal static string RemovingProjectsNotSupported { get; }
    internal static string RenameSymbolIsNotFromSource { get; }
    internal static string SolutionFileNotFound { get; }
    internal static string StringIsNullOrEmpty { get; }
    internal static string TemporaryStorageCannotBeWrittenMultipleTimes { get; }
    internal static string TheMemberIsNotDeclaredWithinTheDeclarationOfTheSymbol { get; }
    internal static string TheNodeIsNotPartOfTheTree { get; }
    internal static string ThePositionIsNotWithinTheSymbolsDeclaration { get; }
    internal static string TheSymbolCannotBeLocatedWithinTheCurrentSolution { get; }
    internal static string UnknownIdentifier { get; }
    internal static string UnmergedChangeFromProject { get; }
    internal static string UnrecognizedLanguageName { get; }
    internal static string UnsupportedLanguage { get; }
    internal static string Usage { get; }
    internal static string ValueTooLargeToBeRepresented { get; }
    internal static string WorkspaceIsNotEmpty { get; }
    internal static string WorkspaceServicesUnavailable { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AbsolutePathExpected();
    internal static string get_AddedHeader();
    internal static string get_AddingAdditionalDocumentsNotSupported();
    internal static string get_AddingAnalyzerReferencesNotSupported();
    internal static string get_AddingDocumentsNotSupported();
    internal static string get_AddingMetadataReferenceNotSupported();
    internal static string get_AddingProjectReferencesNotSupported();
    internal static string get_AddingProjectsNotSupported();
    internal static string get_AfterHeader();
    internal static string get_AnalyzerIsAlreadyPresent();
    internal static string get_AnalyzerIsNotPresent();
    internal static string get_ArraysWithMoreThanOneDimensionCannotBeSerialized();
    internal static string get_BeforeHeader();
    internal static string get_CannotCodeGenUnsupportedOperator();
    internal static string get_CannotOpenProjectUnrecognizedFileExtension();
    internal static string get_CannotOpenProjectUnsupportedLanguage();
    internal static string get_CantResolveAnalyzerReference();
    internal static string get_CantResolveMetadataReference();
    internal static string get_CastIsRedundant();
    internal static string get_CausesCircularProjectReference();
    internal static string get_ChangingAdditionalDocumentsIsNotSupported();
    internal static string get_ChangingCompilationOptionsNotSupported();
    internal static string get_ChangingDocumentsNotSupported();
    internal static string get_ChangingParseOptionsNotSupported();
    internal static string get_ChangingProjectPropertiesNotSupported();
    internal static string get_CouldNotFindLocationToGen();
    internal static string get_CycleDetectedInExtensions();
    internal static string get_DestinationLocationFromDifferentTree();
    internal static string get_DiagnosticCannotBeNull();
    internal static string get_DiagnosticMustHaveMatchingSpan();
    internal static string get_DiagnosticsCannotBeEmpty();
    internal static string get_DocumentAlreadyInSolution();
    internal static string get_DocumentIsNotOpen();
    internal static string get_DocumentIsOpen();
    internal static string get_DocumentNotInProject();
    internal static string get_DocumentNotInSolution();
    internal static string get_DocumentVersionIsDifferent();
    internal static string get_DuplicateKey();
    internal static string get_DuplicateSourceFileInProject();
    internal static string get_ErrorWhileReadingSpecifiedConfigFile();
    internal static string get_FileWasExternallyModified();
    internal static string get_FixAllOccurrencesOfDiagnostic();
    internal static string get_FixAllOccurrencesOfDiagnosticInScope();
    internal static string get_FixAllOccurrencesOfDiagnosticInSolution();
    internal static string get_InvalidCodePage();
    internal static string get_InvalidDestinationNode();
    internal static string get_InvalidDestinationNode2();
    internal static string get_InvalidDestinationNode3();
    internal static string get_InvalidDocumentationCommentId();
    internal static string get_InvalidLanguageNameOption();
    internal static string get_InvalidLanguageNameOption2();
    internal static string get_InvalidLocationForCodeGen();
    internal static string get_InvalidNonSourceLocationForCodeGen();
    internal static string get_InvalidParameterCountForBinaryOperator();
    internal static string get_InvalidParameterCountForUnaryOperator();
    internal static string get_InvalidProjectBlockInSolutionFile();
    internal static string get_InvalidProjectBlockInSolutionFile2();
    internal static string get_InvalidProjectBlockInSolutionFile3();
    internal static string get_InvalidProjectBlockInSolutionFile4();
    internal static string get_InvalidProjectFilePath();
    internal static string get_InvalidSolutionFilePath();
    internal static string get_InvalidSubmissionReference();
    internal static string get_LabelForNodeIsInvalid();
    internal static string get_LocationMustBeNullOrFromSource();
    internal static string get_MatchingNodesMustHaveTheSameLabel();
    internal static string get_MetadataIsAlreadyReferenced();
    internal static string get_MetadataIsNotReferenced();
    internal static string get_MissingEndOfFileInSolutionFile();
    internal static string get_MissingHeaderInSolutionFile();
    internal static string get_MissingLineInSolutionFile();
    internal static string get_NameCanBeSimplified();
    internal static string get_NoBinderException();
    internal static string get_NodeIsOfTheWrongType();
    internal static string get_NodeMustBeContainedInTheNewTree();
    internal static string get_NodeMustBeContainedInTheOldTree();
    internal static string get_NoReaderException();
    internal static string get_NotWritableException();
    internal static string get_OpenDocumentNotSupported();
    internal static string get_PathMustBeAbsolute();
    internal static string get_ProjectAlreadyInSolution();
    internal static string get_ProjectAlreadyReferenced();
    internal static string get_ProjectContainsOpenDocuments();
    internal static string get_ProjectDirectlyReferencesTargetProject();
    internal static string get_ProjectFileNotFound();
    internal static string get_ProjectNotInSolution();
    internal static string get_ProjectNotReferenced();
    internal static string get_ProjectOrDocumentAlreadyInWorkspace();
    internal static string get_ProjectOrDocumentNotInWorkspace();
    internal static string get_ProjectTransitivelyReferencesTargetProject();
    internal static string get_RemovedHeader();
    internal static string get_RemovingAdditionalDocumentsIsNotSupported();
    internal static string get_RemovingAnalyzerReferencesNotSupported();
    internal static string get_RemovingDocumentsNotSupported();
    internal static string get_RemovingMetadataReferencesNotSupported();
    internal static string get_RemovingProjectReferencesNotSupported();
    internal static string get_RemovingProjectsNotSupported();
    internal static string get_RenameSymbolIsNotFromSource();
    internal static string get_SolutionFileNotFound();
    internal static string get_StringIsNullOrEmpty();
    internal static string get_TemporaryStorageCannotBeWrittenMultipleTimes();
    internal static string get_TheMemberIsNotDeclaredWithinTheDeclarationOfTheSymbol();
    internal static string get_TheNodeIsNotPartOfTheTree();
    internal static string get_ThePositionIsNotWithinTheSymbolsDeclaration();
    internal static string get_TheSymbolCannotBeLocatedWithinTheCurrentSolution();
    internal static string get_UnknownIdentifier();
    internal static string get_UnmergedChangeFromProject();
    internal static string get_UnrecognizedLanguageName();
    internal static string get_UnsupportedLanguage();
    internal static string get_Usage();
    internal static string get_ValueTooLargeToBeRepresented();
    internal static string get_WorkspaceIsNotEmpty();
    internal static string get_WorkspaceServicesUnavailable();
}
internal abstract class Microsoft.CodeAnalysis.XmlDocumentationProvider : DocumentationProvider {
    private NonReentrantLock _gate;
    private Dictionary`2<string, string> _docComments;
    private static XmlReaderSettings s_xmlSettings;
    private static XmlDocumentationProvider();
    protected abstract virtual Stream GetSourceStream(CancellationToken cancellationToken);
    public static XmlDocumentationProvider Create(Byte[] xmlDocCommentBytes);
    private XDocument GetXDocument(CancellationToken cancellationToken);
    protected virtual string GetDocumentationForSymbol(string documentationMemberID, CultureInfo preferredCulture, CancellationToken cancellationToken);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("Roslyn.Collections.Immutable.ImmutableHashMap`2/DebuggerProxy")]
internal class Roslyn.Collections.Immutable.ImmutableHashMap`2 : object {
    private static ImmutableHashMap`2<TKey, TValue> s_emptySingleton;
    private Bucket<TKey, TValue> _root;
    private IEqualityComparer`1<TKey> _keyComparer;
    private IEqualityComparer`1<TValue> _valueComparer;
    public static ImmutableHashMap`2<TKey, TValue> Empty { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public TValue Item { get; }
    private ImmutableHashMap`2(Bucket<TKey, TValue> root, IEqualityComparer`1<TKey> comparer, IEqualityComparer`1<TValue> valueComparer);
    internal ImmutableHashMap`2(IEqualityComparer`1<TKey> comparer, IEqualityComparer`1<TValue> valueComparer);
    private static ImmutableHashMap`2();
    public static ImmutableHashMap`2<TKey, TValue> get_Empty();
    public ImmutableHashMap`2<TKey, TValue> Clear();
    public ImmutableHashMap`2<TKey, TValue> Add(TKey key, TValue value);
    public ImmutableHashMap`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    public ImmutableHashMap`2<TKey, TValue> SetItem(TKey key, TValue value);
    public ImmutableHashMap`2<TKey, TValue> SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public ImmutableHashMap`2<TKey, TValue> Remove(TKey key);
    public ImmutableHashMap`2<TKey, TValue> RemoveRange(IEnumerable`1<TKey> keys);
    public ImmutableHashMap`2<TKey, TValue> WithComparers(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public ImmutableHashMap`2<TKey, TValue> WithComparers(IEqualityComparer`1<TKey> keyComparer);
    public bool ContainsValue(TValue value);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    [IteratorStateMachineAttribute("Roslyn.Collections.Immutable.ImmutableHashMap`2/<get_Keys>d__23")]
public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual bool TryGetKey(TKey equalKey, TKey& actualKey);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    internal bool TryExchangeKey(TKey key, TKey& existingKey);
    private static bool TryCastToImmutableMap(IEnumerable`1<KeyValuePair`2<TKey, TValue>> sequence, ImmutableHashMap`2& other);
    private ImmutableHashMap`2<TKey, TValue> Wrap(Bucket<TKey, TValue> root);
    private ImmutableHashMap`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs, bool overwriteOnCollision, bool avoidToHashMap);
    [IteratorStateMachineAttribute("Roslyn.Collections.Immutable.ImmutableHashMap`2/<GetValueBuckets>d__39")]
private IEnumerable`1<ValueBucket<TKey, TValue>> GetValueBuckets();
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Clear();
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItem(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.RemoveRange(IEnumerable`1<TKey> keys);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Remove(TKey key);
}
internal class Roslyn.Utilities.AnnotationTable`1 : object {
    private int _globalId;
    private Dictionary`2<TAnnotation, SyntaxAnnotation> _realAnnotationMap;
    private Dictionary`2<string, TAnnotation> _annotationMap;
    private string _annotationKind;
    public AnnotationTable`1(string annotationKind);
    [IteratorStateMachineAttribute("Roslyn.Utilities.AnnotationTable`1/<GetOrCreateRealAnnotations>d__5")]
private IEnumerable`1<SyntaxAnnotation> GetOrCreateRealAnnotations(TAnnotation[] annotations);
    private SyntaxAnnotation GetOrCreateRealAnnotation(TAnnotation annotation);
    [IteratorStateMachineAttribute("Roslyn.Utilities.AnnotationTable`1/<GetRealAnnotations>d__7")]
private IEnumerable`1<SyntaxAnnotation> GetRealAnnotations(TAnnotation[] annotations);
    private SyntaxAnnotation GetRealAnnotation(TAnnotation annotation);
    public TSyntaxNode WithAdditionalAnnotations(TSyntaxNode node, TAnnotation[] annotations);
    public SyntaxToken WithAdditionalAnnotations(SyntaxToken token, TAnnotation[] annotations);
    public SyntaxTrivia WithAdditionalAnnotations(SyntaxTrivia trivia, TAnnotation[] annotations);
    public SyntaxNodeOrToken WithAdditionalAnnotations(SyntaxNodeOrToken nodeOrToken, TAnnotation[] annotations);
    public TSyntaxNode WithoutAnnotations(TSyntaxNode node, TAnnotation[] annotations);
    public SyntaxToken WithoutAnnotations(SyntaxToken token, TAnnotation[] annotations);
    public SyntaxTrivia WithoutAnnotations(SyntaxTrivia trivia, TAnnotation[] annotations);
    public SyntaxNodeOrToken WithoutAnnotations(SyntaxNodeOrToken nodeOrToken, TAnnotation[] annotations);
    [IteratorStateMachineAttribute("Roslyn.Utilities.AnnotationTable`1/<GetAnnotations>d__17")]
private IEnumerable`1<TAnnotation> GetAnnotations(IEnumerable`1<SyntaxAnnotation> realAnnotations);
    public IEnumerable`1<TAnnotation> GetAnnotations(SyntaxNode node);
    public IEnumerable`1<TAnnotation> GetAnnotations(SyntaxToken token);
    public IEnumerable`1<TAnnotation> GetAnnotations(SyntaxTrivia trivia);
    public IEnumerable`1<TAnnotation> GetAnnotations(SyntaxNodeOrToken nodeOrToken);
    public IEnumerable`1<TSpecificAnnotation> GetAnnotations(SyntaxNode node);
    public IEnumerable`1<TSpecificAnnotation> GetAnnotations(SyntaxToken token);
    public IEnumerable`1<TSpecificAnnotation> GetAnnotations(SyntaxTrivia trivia);
    public IEnumerable`1<TSpecificAnnotation> GetAnnotations(SyntaxNodeOrToken nodeOrToken);
    public bool HasAnnotations(SyntaxNode node);
    public bool HasAnnotations(SyntaxToken token);
    public bool HasAnnotations(SyntaxTrivia trivia);
    public bool HasAnnotations(SyntaxNodeOrToken nodeOrToken);
    public bool HasAnnotations(SyntaxNode node);
    public bool HasAnnotations(SyntaxToken token);
    public bool HasAnnotations(SyntaxTrivia trivia);
    public bool HasAnnotations(SyntaxNodeOrToken nodeOrToken);
    public bool HasAnnotation(SyntaxNode node, TAnnotation annotation);
    public bool HasAnnotation(SyntaxToken token, TAnnotation annotation);
    public bool HasAnnotation(SyntaxTrivia trivia, TAnnotation annotation);
    public bool HasAnnotation(SyntaxNodeOrToken nodeOrToken, TAnnotation annotation);
    public IEnumerable`1<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(SyntaxNode node);
    public IEnumerable`1<SyntaxNode> GetAnnotatedNodes(SyntaxNode node);
    public IEnumerable`1<SyntaxToken> GetAnnotatedTokens(SyntaxNode node);
    public IEnumerable`1<SyntaxTrivia> GetAnnotatedTrivia(SyntaxNode node);
    public IEnumerable`1<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(SyntaxNode node);
    public IEnumerable`1<SyntaxNode> GetAnnotatedNodes(SyntaxNode node);
    public IEnumerable`1<SyntaxToken> GetAnnotatedTokens(SyntaxNode node);
    public IEnumerable`1<SyntaxTrivia> GetAnnotatedTrivia(SyntaxNode node);
    [CompilerGeneratedAttribute]
private bool <GetAnnotatedNodesAndTokens>b__42_0(SyntaxNodeOrToken nt);
    [CompilerGeneratedAttribute]
private bool <GetAnnotatedNodes>b__43_0(SyntaxNodeOrToken nt);
    [CompilerGeneratedAttribute]
private bool <GetAnnotatedTokens>b__44_0(SyntaxNodeOrToken nt);
    [CompilerGeneratedAttribute]
private bool <GetAnnotatedTrivia>b__45_0(SyntaxTrivia tr);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ArrayExtensions : object {
    [ExtensionAttribute]
internal static T[] Copy(T[] array, int start, int length);
    [ExtensionAttribute]
internal static bool ValueEquals(UInt32[] array, UInt32[] other);
    [ExtensionAttribute]
internal static T[] InsertAt(T[] array, int position, T item);
    [ExtensionAttribute]
internal static T[] Append(T[] array, T item);
    [ExtensionAttribute]
internal static T[] InsertAt(T[] array, int position, T[] items);
    [ExtensionAttribute]
internal static T[] Append(T[] array, T[] items);
    [ExtensionAttribute]
internal static T[] RemoveAt(T[] array, int position);
    [ExtensionAttribute]
internal static T[] RemoveAt(T[] array, int position, int length);
    [ExtensionAttribute]
internal static T[] ReplaceAt(T[] array, int position, T item);
    [ExtensionAttribute]
internal static T[] ReplaceAt(T[] array, int position, int length, T[] items);
    [ExtensionAttribute]
internal static void ReverseContents(T[] array);
    [ExtensionAttribute]
internal static void ReverseContents(T[] array, int start, int count);
    [ExtensionAttribute]
internal static int BinarySearch(Int32[] array, int value);
    [ExtensionAttribute]
internal static int BinarySearchUpperBound(Int32[] array, int value);
}
internal class Roslyn.Utilities.AsyncLazy`1 : ValueSource`1<T> {
    private Func`2<CancellationToken, Task`1<T>> _asynchronousComputeFunction;
    private Func`2<CancellationToken, T> _synchronousComputeFunction;
    private bool _cacheResult;
    private Task`1<T> _cachedResult;
    private static NonReentrantLock s_gate;
    private HashSet`1<Request<T>> _requests;
    private CancellationTokenSource _asynchronousComputationCancellationSource;
    private bool _computationActive;
    public AsyncLazy`1(T value);
    public AsyncLazy`1(Func`2<CancellationToken, Task`1<T>> asynchronousComputeFunction, bool cacheResult);
    public AsyncLazy`1(Func`2<CancellationToken, Task`1<T>> asynchronousComputeFunction, Func`2<CancellationToken, T> synchronousComputeFunction, bool cacheResult);
    private static AsyncLazy`1();
    private WaitThatValidatesInvariants<T> TakeLock(CancellationToken cancellationToken);
    private void AssertInvariants_NoLock();
    public virtual bool TryGetValue(T& result);
    public virtual T GetValue(CancellationToken cancellationToken);
    private Request<T> CreateNewRequest_NoLock();
    public virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
    private AsynchronousComputationToStart<T> RegisterAsynchronousComputation_NoLock();
    private void StartAsynchronousComputation(AsynchronousComputationToStart<T> computationToStart, Request<T> requestToCompleteSynchronously, CancellationToken callerCancellationToken);
    private static bool CrashIfCanceledWithDifferentToken(OperationCanceledException exception, CancellationToken cancellationToken);
    private void CompleteWithTask(Task`1<T> task, CancellationToken cancellationToken);
    private Task`1<T> GetCachedValueAndCacheThisValueIfNoneCached_NoLock(Task`1<T> task);
    private void OnAsynchronousRequestCancelled(object state);
    [CompilerGeneratedAttribute]
private void <StartAsynchronousComputation>b__20_0(Task`1<T> t, object s);
}
internal class Roslyn.Utilities.BidirectionalMap`2 : object {
    public static IBidirectionalMap`2<TKey, TValue> Empty;
    private ImmutableDictionary`2<TKey, TValue> _forwardMap;
    private ImmutableDictionary`2<TValue, TKey> _backwardMap;
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public BidirectionalMap`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    private BidirectionalMap`2(ImmutableDictionary`2<TKey, TValue> forwardMap, ImmutableDictionary`2<TValue, TKey> backwardMap);
    private static BidirectionalMap`2();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual bool TryGetKey(TValue value, TKey& key);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool ContainsValue(TValue value);
    public sealed virtual IBidirectionalMap`2<TKey, TValue> RemoveKey(TKey key);
    public sealed virtual IBidirectionalMap`2<TKey, TValue> RemoveValue(TValue value);
    public sealed virtual IBidirectionalMap`2<TKey, TValue> Add(TKey key, TValue value);
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<TValue> get_Values();
    public sealed virtual bool get_IsEmpty();
    public int get_Count();
    public sealed virtual TValue GetValueOrDefault(TKey key);
    public sealed virtual TKey GetKeyOrDefault(TValue value);
}
internal static class Roslyn.Utilities.BitArithmeticUtilities : object {
    public static int CountBits(int v);
    public static int CountBits(UInt32 v);
    public static int CountBits(long v);
    public static int CountBits(ulong v);
    internal static UInt32 Align(UInt32 position, UInt32 alignment);
    internal static int Align(int position, int alignment);
}
internal static class Roslyn.Utilities.CancellableLazy : object {
    public static CancellableLazy`1<T> Create(T value);
    public static CancellableLazy`1<T> Create(Func`2<CancellationToken, T> valueFactory);
}
internal class Roslyn.Utilities.CancellableLazy`1 : object {
    private NonReentrantLock _gate;
    private Func`2<CancellationToken, T> _valueFactory;
    private T _value;
    public bool HasValue { get; }
    public CancellableLazy`1(Func`2<CancellationToken, T> valueFactory);
    public CancellableLazy`1(T value);
    public bool get_HasValue();
    public bool TryGetValue(T& value);
    public T GetValue(CancellationToken cancellationToken);
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Roslyn.Utilities.ConcurrentSet`1 : object {
    private static int DefaultConcurrencyLevel;
    private static int DefaultCapacity;
    private ConcurrentDictionary`2<T, byte> _dictionary;
    public int Count { get; }
    public bool IsEmpty { get; }
    public ConcurrentSet`1(IEqualityComparer`1<T> equalityComparer);
    public int get_Count();
    public bool get_IsEmpty();
    public bool Contains(T value);
    public bool Add(T value);
    public bool Remove(T value);
    public void Clear();
    public KeyEnumerator<T> GetEnumerator();
    [IteratorStateMachineAttribute("Roslyn.Utilities.ConcurrentSet`1/<GetEnumeratorImpl>d__15")]
private IEnumerator`1<T> GetEnumeratorImpl();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Roslyn.Utilities.ConsList`1 : object {
    public static ConsList`1<T> Empty;
    private T _head;
    private ConsList`1<T> _tail;
    [DebuggerBrowsableAttribute("0")]
public T Head { get; }
    [DebuggerBrowsableAttribute("0")]
public ConsList`1<T> Tail { get; }
    public ConsList`1(T head, ConsList`1<T> tail);
    private static ConsList`1();
    public T get_Head();
    public ConsList`1<T> get_Tail();
    public bool Any();
    public ConsList`1<T> Push(T value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public Enumerator<T> GetEnumerator();
    public virtual string ToString();
}
internal class Roslyn.Utilities.ConstantValueSource`1 : ValueSource`1<T> {
    private T _value;
    private Task`1<T> _task;
    public ConstantValueSource`1(T value);
    public virtual T GetValue(CancellationToken cancellationToken);
    public virtual bool TryGetValue(T& value);
    public virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
}
internal static class Roslyn.Utilities.Contract : object {
    [ConditionalAttribute("DEBUG")]
[DebuggerHiddenAttribute]
public static void Requires(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
[DebuggerHiddenAttribute]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void Assume(bool condition, string message);
    public static void ThrowIfNull(T value, string message);
    public static void ThrowIfFalse(bool condition, string message);
    public static void ThrowIfTrue(bool condition, string message);
    [DebuggerHiddenAttribute]
public static void Fail(string message);
    [DebuggerHiddenAttribute]
public static T FailWithReturn(string message);
    public static void InvalidEnumValue(T value);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.DecimalUtilities : object {
    [ExtensionAttribute]
public static int GetScale(decimal value);
    [ExtensionAttribute]
public static void GetBits(decimal value, Boolean& isNegative, Byte& scale, UInt32& low, UInt32& mid, UInt32& high);
}
internal static class Roslyn.Utilities.DocumentationCommentXmlNames : object {
    public static string CElementName;
    public static string CodeElementName;
    public static string CompletionListElementName;
    public static string ExampleElementName;
    public static string ExceptionElementName;
    public static string IncludeElementName;
    public static string ListElementName;
    public static string ParaElementName;
    public static string ParameterElementName;
    public static string ParameterReferenceElementName;
    public static string PermissionElementName;
    public static string RemarksElementName;
    public static string ReturnsElementName;
    public static string SeeElementName;
    public static string SeeAlsoElementName;
    public static string SummaryElementName;
    public static string TypeParameterElementName;
    public static string TypeParameterReferenceElementName;
    public static string ValueElementName;
    public static string CrefAttributeName;
    public static string NameAttributeName;
    public static string FileAttributeName;
    public static string PathAttributeName;
    public static string TypeAttributeName;
    public static bool ElementEquals(string name1, string name2, bool fromVb);
    public static bool AttributeEquals(string name1, string name2);
    public static bool Equals(object left, object right);
}
internal static class Roslyn.Utilities.EditDistance : object {
    public static int GetEditDistance(string oldString, string newString);
    public static int GetLongestCommonSubsequenceLength(string oldString, string newString);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.EnumerableExtensions : object {
    private static Func`2<object, bool> s_notNullTest;
    private static EnumerableExtensions();
    [ExtensionAttribute]
public static IEnumerable`1<T> Do(IEnumerable`1<T> source, Action`1<T> action);
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> ToReadOnlyCollection(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> source, T value);
    [IteratorStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<ConcatWorker>d__4`1")]
[ExtensionAttribute]
private static IEnumerable`1<T> ConcatWorker(IEnumerable`1<T> source, T value);
    [ExtensionAttribute]
public static bool SetEquals(IEnumerable`1<T> source1, IEnumerable`1<T> source2, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool SetEquals(IEnumerable`1<T> source1, IEnumerable`1<T> source2);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> source, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static Nullable`1<T> FirstOrNullable(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static Nullable`1<T> FirstOrNullable(IEnumerable`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static Nullable`1<T> LastOrNullable(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool IsSingle(IEnumerable`1<T> list);
    [ExtensionAttribute]
public static bool IsEmpty(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(IReadOnlyCollection`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(ICollection`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(string source);
    [ExtensionAttribute]
public static bool IsEmpty(T[] source);
    [ExtensionAttribute]
public static bool IsEmpty(List`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool All(IEnumerable`1<bool> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> Flatten(IEnumerable`1<IEnumerable`1<T>> sequence);
    [ExtensionAttribute]
public static IEnumerable`1<T> OrderBy(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> OrderBy(IEnumerable`1<T> source, Comparison`1<T> compare);
    [ExtensionAttribute]
public static IEnumerable`1<T> Order(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool IsSorted(IEnumerable`1<T> enumerable, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<T> first, IEnumerable`1<T> second, Func`3<T, T, bool> comparer);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<T> sequence, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<string> sequence, string s);
}
internal static class Roslyn.Utilities.EnumUtilities : object {
    internal static ulong ConvertEnumUnderlyingTypeToUInt64(object value, SpecialType specialType);
}
internal class Roslyn.Utilities.EventMap : object {
    private NonReentrantLock _guard;
    private Dictionary`2<string, object> _eventNameToRegistries;
    public void AddEventHandler(string eventName, TEventHandler eventHandler);
    public void RemoveEventHandler(string eventName, TEventHandler eventHandler);
    public EventHandlerSet`1<TEventHandler> GetEventHandlers(string eventName);
    private ImmutableArray`1<Registry`1<TEventHandler>> GetRegistries(string eventName);
    private ImmutableArray`1<Registry`1<TEventHandler>> GetRegistries_NoLock(string eventName);
    private void SetRegistries_NoLock(string eventName, ImmutableArray`1<Registry`1<TEventHandler>> registries);
}
internal static class Roslyn.Utilities.ExceptionHelpers : object {
    public static FailFastReset SuppressFailFast();
    public static bool IsFailFastSuppressed();
}
internal static class Roslyn.Utilities.ExceptionUtilities : object {
    internal static Exception Unreachable { get; }
    internal static Exception UnexpectedValue(object o);
    internal static Exception get_Unreachable();
}
internal static class Roslyn.Utilities.FileNameUtilities : object {
    private static string DirectorySeparatorStr;
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static char VolumeSeparatorChar;
    internal static bool IsFileName(string path);
    private static int IndexOfExtension(string path);
    internal static string GetExtension(string path);
    private static string RemoveExtension(string path);
    internal static string ChangeExtension(string path, string extension);
    internal static int IndexOfFileName(string path);
    internal static string GetFileName(string path);
}
internal static class Roslyn.Utilities.FileUtilities : object {
    private static Char[] s_invalidPathChars;
    private static FileUtilities();
    internal static string ResolveRelativePath(string path, string basePath, string baseDirectory, IEnumerable`1<string> searchPaths, Func`2<string, bool> fileExists);
    internal static string ResolveRelativePath(string path, string baseDirectory);
    internal static string ResolveRelativePath(string path, string basePath, string baseDirectory);
    private static string ResolveRelativePath(PathKind kind, string path, string basePath, string baseDirectory);
    private static string GetBaseDirectory(string basePath, string baseDirectory);
    internal static string NormalizeRelativePath(string path, string basePath, string baseDirectory);
    internal static string NormalizeAbsolutePath(string path);
    internal static string NormalizeDirectoryPath(string path);
    internal static string TryNormalizeAbsolutePath(string path);
    internal static Stream OpenRead(string fullPath);
    internal static Stream OpenAsyncRead(string fullPath);
    internal static Stream CreateFileStreamChecked(Func`2<string, Stream> factory, string path, string paramName);
    internal static DateTime GetFileTimeStamp(string fullPath);
    internal static Stream OpenFileStream(string path);
}
internal class Roslyn.Utilities.FixedObjectBinder : ObjectBinder {
    private ImmutableDictionary`2<TypeKey, Type> _typeMap;
    private ImmutableDictionary`2<Type, Func`2<ObjectReader, object>> _readerMap;
    public FixedObjectBinder(ImmutableDictionary`2<Type, Func`2<ObjectReader, object>> readerMap);
    public virtual Type GetType(string assemblyName, string typeName);
    public virtual Func`2<ObjectReader, object> GetReader(Type type);
}
internal static class Roslyn.Utilities.Hash : object {
    internal static int FnvOffsetBias;
    internal static int FnvPrime;
    internal static int Combine(int newKey, int currentKey);
    internal static int Combine(bool newKeyPart, int currentKey);
    internal static int Combine(T newKeyPart, int currentKey);
    internal static int CombineValues(IEnumerable`1<T> values, int maxItemsToHash);
    internal static int CombineValues(T[] values, int maxItemsToHash);
    internal static int CombineValues(ImmutableArray`1<T> values, int maxItemsToHash);
    internal static int CombineValues(IEnumerable`1<string> values, StringComparer stringComparer, int maxItemsToHash);
    internal static int GetFNVHashCode(Byte[] data);
    internal static int GetFNVHashCode(Byte* data, int length, Boolean& isAscii);
    internal static int GetFNVHashCode(ImmutableArray`1<byte> data);
    internal static int GetFNVHashCode(string text, int start, int length);
    internal static int GetFNVHashCode(string text, int start);
    internal static int GetFNVHashCode(string text);
    internal static int GetFNVHashCode(StringBuilder text);
    internal static int GetFNVHashCode(Char[] text, int start, int length);
    internal static int GetFNVHashCode(char ch);
    internal static int CombineFNVHash(int hashCode, string text);
    internal static int CombineFNVHash(int hashCode, char ch);
}
internal abstract class Roslyn.Utilities.HashAlgorithm : object {
    private static MethodInfo s_ComputeHash_bytes_Method;
    private static MethodInfo s_ComputeHash_bytesOffsetCount_Method;
    private static MethodInfo s_ComputeHash_stream_Method;
    private static MethodInfo s_TransformBlock_Method;
    private static MethodInfo s_TransformFinalBlock_Method;
    private static MethodInfo s_Hash_PropertyGetter;
    private IDisposable _hashInstance;
    private static string MscorlibAssembly;
    private static string HashingAssembly;
    private static string HashingAlgorithmsAssembly;
    public bool SupportsTransform { get; }
    public Byte[] Hash { get; }
    private static HashAlgorithm();
    protected HashAlgorithm(IDisposable hashInstance);
    protected static MethodInfo LoadAlgorithmCreate(string name);
    private static Type GetType(string typeName, String[] assemblyNames);
    public Byte[] ComputeHash(Byte[] bytes);
    public Byte[] ComputeHash(Byte[] bytes, int offset, int count);
    public Byte[] ComputeHash(Stream stream);
    public bool get_SupportsTransform();
    public void TransformBlock(Byte[] inputBuffer, int inputCount);
    public void TransformFinalBlock(Byte[] inputBuffer, int inputCount);
    public Byte[] get_Hash();
    public sealed virtual void Dispose();
}
internal interface Roslyn.Utilities.IBidirectionalMap`2 {
    public bool IsEmpty { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
    public abstract virtual bool TryGetKey(TValue value, TKey& key);
    public abstract virtual TValue GetValueOrDefault(TKey key);
    public abstract virtual TKey GetKeyOrDefault(TValue value);
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool ContainsValue(TValue value);
    public abstract virtual IBidirectionalMap`2<TKey, TValue> RemoveKey(TKey key);
    public abstract virtual IBidirectionalMap`2<TKey, TValue> RemoveValue(TValue value);
    public abstract virtual IBidirectionalMap`2<TKey, TValue> Add(TKey key, TValue value);
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TValue> get_Values();
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ICollectionExtensions : object {
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> values);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.IDictionaryExtensions : object {
    [ExtensionAttribute]
public static V GetOrAdd(IDictionary`2<K, V> dictionary, K key, Func`2<K, V> function);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static bool DictionaryEquals(IDictionary`2<K, V> left, IDictionary`2<K, V> right, IEqualityComparer`1<KeyValuePair`2<K, V>> comparer);
    [ExtensionAttribute]
public static void MultiAdd(IDictionary`2<TKey, TCollection> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void MultiRemove(IDictionary`2<TKey, TCollection> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void MultiAddRange(IDictionary`2<TKey, TCollection> dictionary, TKey key, IEnumerable`1<TValue> values);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableArrayExtensions : object {
    [ExtensionAttribute]
internal static ImmutableArray`1<T> ToImmutableArrayOrEmpty(T[] items);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> ToImmutableArrayOrEmpty(IEnumerable`1<T> items);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> ToImmutableArrayOrEmpty(ImmutableArray`1<T> items);
    [ExtensionAttribute]
internal static IReadOnlyList`1<T> ToImmutableReadOnlyListOrEmpty(IEnumerable`1<T> items);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableDictionaryExtensions : object {
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, ImmutableHashSet`1<V>> AddAll(ImmutableDictionary`2<K, ImmutableHashSet`1<V>> map, IEnumerable`1<K> keys, V value);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, ImmutableHashSet`1<V>> Add(ImmutableDictionary`2<K, ImmutableHashSet`1<V>> map, K key, V value);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, ImmutableHashSet`1<V>> RemoveAll(ImmutableDictionary`2<K, ImmutableHashSet`1<V>> map, IEnumerable`1<K> keys, V value);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, ImmutableHashSet`1<V>> Remove(ImmutableDictionary`2<K, ImmutableHashSet`1<V>> map, K key, V value);
}
internal static class Roslyn.Utilities.ImmutableHashMapExtensions : object {
    public static TValue GetOrAdd(ImmutableHashMap`2& location, TKey key, Func`3<TKey, TArg, TValue> valueFactory, TArg factoryArgument);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableListExtensions : object {
    [ExtensionAttribute]
internal static ImmutableList`1<T> ToImmutableListOrEmpty(T[] items);
    [ExtensionAttribute]
internal static ImmutableList`1<T> ToImmutableListOrEmpty(IEnumerable`1<T> items);
}
internal interface Roslyn.Utilities.IObjectReadable {
    public abstract virtual Func`2<ObjectReader, object> GetReader();
}
internal interface Roslyn.Utilities.IObjectWritable {
    public abstract virtual void WriteTo(ObjectWriter writer);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.IReadOnlyDictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetEnumerableMetadata(IReadOnlyDictionary`2<string, object> metadata, string name);
}
internal interface Roslyn.Utilities.IReadOnlySet`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool Contains(T item);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ISetExtensions : object {
    [ExtensionAttribute]
public static bool AddAll(ISet`1<T> set, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static bool RemoveAll(ISet`1<T> set, IEnumerable`1<T> values);
}
internal static class Roslyn.Utilities.KeyValuePair : object {
    public static KeyValuePair`2<K, V> Create(K key, V value);
}
internal static class Roslyn.Utilities.LazyInitialization : object {
    internal static T InterlockedStore(T& target, T value);
    public static T EnsureInitialized(T& target, Func`1<T> valueFactory);
    public static T EnsureInitialized(T& target, Func`2<U, T> valueFactory, U state);
}
internal class Roslyn.Utilities.LinkedHashQueue`1 : object {
    private LinkedList`1<T> _list;
    private Dictionary`2<T, LinkedListNode`1<T>> _map;
    private int _insertionIndex;
    public int Count { get; }
    public T First { get; }
    public LinkedHashQueue`1(IEqualityComparer`1<T> comparer);
    public int get_Count();
    public void Clear();
    public T get_First();
    public bool Enqueue(T value);
    public T Dequeue();
    public bool Contains(T value);
    public void Remove(T value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Roslyn.Utilities.MD5CryptoServiceProvider : HashAlgorithm {
    private static MethodInfo s_create;
    private static MD5CryptoServiceProvider();
}
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.MultiDictionary`2 : object {
    private Dictionary`2<K, ValueSet<K, V>> _dictionary;
    public int Count { get; }
    public IEnumerable`1<K> Keys { get; }
    public ValueSet<K, V> Item { get; }
    public MultiDictionary`2(IEqualityComparer`1<K> comparer);
    public MultiDictionary`2(int capacity, IEqualityComparer`1<K> comparer);
    public int get_Count();
    public IEnumerable`1<K> get_Keys();
    public ValueSet<K, V> get_Item(K k);
    public void Add(K k, V v);
    public IEnumerator`1<KeyValuePair`2<K, ValueSet<K, V>>> GetEnumerator();
    public bool ContainsKey(K k);
    internal void Clear();
}
internal class Roslyn.Utilities.NonReentrantLock : object {
    private object _syncLock;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _owningThreadId;
    public static Func`1<NonReentrantLock> Factory;
    private static Action`1<object> s_cancellationTokenCanceledEventHandler;
    private bool IsLocked { get; }
    private bool IsOwnedByMe { get; }
    public NonReentrantLock(bool useThisInstanceForSynchronization);
    private static NonReentrantLock();
    public void Wait(CancellationToken cancellationToken);
    public void Release();
    public bool LockHeldByMe();
    public void AssertHasLock();
    private bool get_IsLocked();
    private bool get_IsOwnedByMe();
    private void TakeOwnership();
    private void ReleaseOwnership();
    private static void CancellationTokenCanceledEventHandler(object obj);
    public SemaphoreDisposer DisposableWait(CancellationToken cancellationToken);
}
internal abstract class Roslyn.Utilities.ObjectBinder : object {
    public abstract virtual Type GetType(string assemblyName, string typeName);
    public abstract virtual Func`2<ObjectReader, object> GetReader(Type type);
}
internal class Roslyn.Utilities.ObjectPool`1 : object {
    private T _firstItem;
    private Element[] _items;
    private Factory<T> _factory;
    internal ObjectPool`1(Factory<T> factory);
    internal ObjectPool`1(Factory<T> factory, int size);
    private T CreateInstance();
    internal T Allocate();
    private T AllocateSlow();
    internal void Free(T obj);
    private void FreeSlow(T obj);
    [ConditionalAttribute("DEBUG")]
internal void ForgetTrackedObject(T old, T replacement);
    [ConditionalAttribute("DEBUG")]
private void Validate(object obj);
}
internal class Roslyn.Utilities.ObjectReader : ObjectReaderWriterBase {
    private BinaryReader _reader;
    private ObjectReaderData _dataMap;
    private ObjectBinder _binder;
    internal ObjectReader(Stream stream, ObjectReaderData defaultData, ObjectBinder binder);
    public sealed virtual void Dispose();
    public bool ReadBoolean();
    public byte ReadByte();
    public char ReadChar();
    public decimal ReadDecimal();
    public double ReadDouble();
    public float ReadSingle();
    public int ReadInt32();
    public long ReadInt64();
    public sbyte ReadSByte();
    public short ReadInt16();
    public UInt32 ReadUInt32();
    public ulong ReadUInt64();
    public ushort ReadUInt16();
    public DateTime ReadDateTime();
    public UInt32 ReadCompressedUInt();
    public object ReadValue();
    public string ReadString();
    private string ReadString(DataKind kind);
    private string ReadStringLiteral(DataKind kind);
    private Array ReadArray(DataKind kind);
    private Type ReadType();
    private Type ReadType(DataKind kind);
    private object ReadEnum();
    private object ReadObject(DataKind kind);
    private object ReadReadableObject();
    private object CreateInstance(Type type);
    private static Exception NoBinderException(string typeName);
    private static Exception NoReaderException(string typeName);
}
internal class Roslyn.Utilities.ObjectReaderData : object {
    internal static ObjectPool`1<List`1<object>> ListPool;
    private ObjectReaderData _baseData;
    private List`1<object> _values;
    private int _baseDataCount;
    internal ObjectReaderData(Object[] items);
    internal ObjectReaderData(IEnumerable`1<object> items);
    internal ObjectReaderData(ObjectReaderData baseData);
    private static ObjectReaderData();
    public sealed virtual void Dispose();
    public int GetNextId();
    public void AddValue(int id, object value);
    public object GetValue(int id);
}
internal class Roslyn.Utilities.ObjectReaderWriterBase : object {
    internal static byte ByteMarkerMask;
    internal static byte Byte1Marker;
    internal static byte Byte2Marker;
    internal static byte Byte4Marker;
    private static ObjectReaderWriterBase();
}
internal class Roslyn.Utilities.ObjectWriter : ObjectReaderWriterBase {
    private BinaryWriter _writer;
    private ObjectWriterData _dataMap;
    private RecordingObjectBinder _binder;
    private CancellationToken _cancellationToken;
    public ObjectBinder Binder { get; }
    internal ObjectWriter(Stream stream, ObjectWriterData defaultData, RecordingObjectBinder binder, CancellationToken cancellationToken);
    public ObjectBinder get_Binder();
    public sealed virtual void Dispose();
    public void WriteBoolean(bool value);
    public void WriteByte(byte value);
    public void WriteChar(char ch);
    public void WriteDecimal(decimal value);
    public void WriteDouble(double value);
    public void WriteSingle(float value);
    public void WriteInt32(int value);
    public void WriteInt64(long value);
    public void WriteSByte(sbyte value);
    public void WriteInt16(short value);
    public void WriteUInt32(UInt32 value);
    public void WriteUInt64(ulong value);
    public void WriteUInt16(ushort value);
    public void WriteDateTime(DateTime value);
    public void WriteCompressedUInt(UInt32 value);
    public void WriteString(string value);
    public void WriteValue(object value);
    private void WriteEnum(object value, Type enumType);
    private void WriteArray(Array instance);
    private void WriteType(Type type);
    private void WriteObject(object instance);
    private void WriteWritableObject(IObjectWritable instance);
    private static Exception NotWritableException(string typeName);
}
internal class Roslyn.Utilities.ObjectWriterData : object {
    internal static ObjectPool`1<Dictionary`2<object, int>> DictionaryPool;
    private ObjectWriterData _baseData;
    private Dictionary`2<object, int> _valueToIdMap;
    private int _nextId;
    internal ObjectWriterData(Object[] items);
    internal ObjectWriterData(IEnumerable`1<object> items);
    internal ObjectWriterData(ObjectWriterData baseData);
    private static ObjectWriterData();
    public sealed virtual void Dispose();
    public bool TryGetId(object value, Int32& id);
    private int GetNextId();
    public int Add(object value);
}
internal enum Roslyn.Utilities.PathKind : Enum {
    public int value__;
    public static PathKind Empty;
    public static PathKind Relative;
    public static PathKind RelativeToCurrentDirectory;
    public static PathKind RelativeToCurrentParent;
    public static PathKind RelativeToCurrentRoot;
    public static PathKind RelativeToDriveDirectory;
    public static PathKind Absolute;
}
internal static class Roslyn.Utilities.PathUtilities : object {
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static string DirectorySeparatorStr;
    internal static char VolumeSeparatorChar;
    private static bool IsUnixLikePlatform { get; }
    private static PathUtilities();
    private static bool get_IsUnixLikePlatform();
    internal static bool IsDirectorySeparator(char c);
    internal static string GetExtension(string path);
    internal static string ChangeExtension(string path, string extension);
    internal static string RemoveExtension(string path);
    internal static string GetFileName(string path);
    internal static string GetDirectoryName(string path);
    internal static PathKind GetPathKind(string path);
    internal static bool IsAbsolute(string path);
    private static bool IsDriveRootedAbsolutePath(string path);
    internal static string GetPathRoot(string path);
    private static int GetPathRootLength(string path);
    private static int GetUncPathRootLength(string path);
    private static int IndexOfDirectorySeparator(string path, int start);
    private static int IndexOfNonDirectorySeparator(string path, int start);
    internal static string CombineAbsoluteAndRelativePaths(string root, string relativePath);
    internal static string CombinePossiblyRelativeAndRelativePaths(string rootOpt, string relativePath);
    internal static string CombinePathsUnchecked(string root, string relativePath);
    internal static string RemoveTrailingDirectorySeparator(string path);
    internal static bool IsFilePath(string assemblyDisplayNameOrPath);
}
internal class Roslyn.Utilities.PooledObject`1 : ValueType {
    private Action`2<ObjectPool`1<T>, T> _releaser;
    private ObjectPool`1<T> _pool;
    private T _pooledObject;
    public T Object { get; }
    public PooledObject`1(ObjectPool`1<T> pool, Func`2<ObjectPool`1<T>, T> allocator, Action`2<ObjectPool`1<T>, T> releaser);
    public T get_Object();
    public sealed virtual void Dispose();
    public static PooledObject`1<StringBuilder> Create(ObjectPool`1<StringBuilder> pool);
    public static PooledObject`1<Stack`1<TItem>> Create(ObjectPool`1<Stack`1<TItem>> pool);
    public static PooledObject`1<Queue`1<TItem>> Create(ObjectPool`1<Queue`1<TItem>> pool);
    public static PooledObject`1<HashSet`1<TItem>> Create(ObjectPool`1<HashSet`1<TItem>> pool);
    public static PooledObject`1<Dictionary`2<TKey, TValue>> Create(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    public static PooledObject`1<List`1<TItem>> Create(ObjectPool`1<List`1<TItem>> pool);
    private static StringBuilder Allocator(ObjectPool`1<StringBuilder> pool);
    private static void Releaser(ObjectPool`1<StringBuilder> pool, StringBuilder sb);
    private static Stack`1<TItem> Allocator(ObjectPool`1<Stack`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<Stack`1<TItem>> pool, Stack`1<TItem> obj);
    private static Queue`1<TItem> Allocator(ObjectPool`1<Queue`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<Queue`1<TItem>> pool, Queue`1<TItem> obj);
    private static HashSet`1<TItem> Allocator(ObjectPool`1<HashSet`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<HashSet`1<TItem>> pool, HashSet`1<TItem> obj);
    private static Dictionary`2<TKey, TValue> Allocator(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    private static void Releaser(ObjectPool`1<Dictionary`2<TKey, TValue>> pool, Dictionary`2<TKey, TValue> obj);
    private static List`1<TItem> Allocator(ObjectPool`1<List`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<List`1<TItem>> pool, List`1<TItem> obj);
}
internal static class Roslyn.Utilities.PortableShim : object {
    internal static void Initialize();
    private static void Touch(Type type);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ReaderWriterLockSlimExtensions : object {
    [ExtensionAttribute]
internal static ReadLockExiter DisposableRead(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static WriteLockExiter DisposableWrite(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static void AssertCanRead(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static void AssertCanWrite(ReaderWriterLockSlim lock);
}
internal abstract class Roslyn.Utilities.RecordingObjectBinder : ObjectBinder {
    public abstract virtual void Record(Type type);
    public abstract virtual void Record(object instance);
}
internal class Roslyn.Utilities.ReferenceEqualityComparer : object {
    public static IEqualityComparer`1<object> Instance;
    private static ReferenceEqualityComparer();
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object a, object b);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Object>.GetHashCode(object a);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ReflectionUtil : object {
    public static Type GetTypeFromEither(string contractName, string desktopName);
    public static T FindItem(IEnumerable`1<T> collection, Type[] paramTypes);
    [ExtensionAttribute]
internal static MethodInfo GetDeclaredMethod(TypeInfo typeInfo, string name, Type[] paramTypes);
    [ExtensionAttribute]
internal static ConstructorInfo GetDeclaredConstructor(TypeInfo typeInfo, Type[] paramTypes);
    [ExtensionAttribute]
public static T CreateDelegate(MethodInfo methodInfo);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.SemaphoreSlimExtensions : object {
    [ExtensionAttribute]
public static SemaphoreDisposer DisposableWait(SemaphoreSlim semaphore, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslyn.Utilities.SemaphoreSlimExtensions/<DisposableWaitAsync>d__1")]
[ExtensionAttribute]
public static Task`1<SemaphoreDisposer> DisposableWaitAsync(SemaphoreSlim semaphore, CancellationToken cancellationToken);
}
internal static class Roslyn.Utilities.SemaphoreSlimFactory : object {
    public static Func`1<SemaphoreSlim> Instance;
    private static SemaphoreSlimFactory();
}
internal static class Roslyn.Utilities.SerializableBytes : object {
    private static int ChunkSize;
    internal static PooledStream CreateReadableStream(Byte[] bytes, CancellationToken cancellationToken);
    internal static PooledStream CreateReadableStream(Stream stream, CancellationToken cancellationToken);
    internal static PooledStream CreateReadableStream(Stream stream, long length, CancellationToken cancellationToken);
    internal static Task`1<PooledStream> CreateReadableStreamAsync(Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslyn.Utilities.SerializableBytes/<CreateReadableStreamAsync>d__5")]
internal static Task`1<PooledStream> CreateReadableStreamAsync(Stream stream, long length, CancellationToken cancellationToken);
    private static void BlowChunks(Byte[][] chunks);
    internal static PooledStream CreateWritableStream();
}
internal class Roslyn.Utilities.SHA1CryptoServiceProvider : HashAlgorithm {
    private static MethodInfo s_create;
    private static SHA1CryptoServiceProvider();
}
internal class Roslyn.Utilities.SHA256CryptoServiceProvider : HashAlgorithm {
    private static MethodInfo s_create;
    private static SHA256CryptoServiceProvider();
}
internal class Roslyn.Utilities.SHA384CryptoServiceProvider : HashAlgorithm {
    private static MethodInfo s_create;
    private static SHA384CryptoServiceProvider();
}
internal class Roslyn.Utilities.SHA512CryptoServiceProvider : HashAlgorithm {
    private static MethodInfo s_create;
    private static SHA512CryptoServiceProvider();
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.SharedPoolExtensions : object {
    private static int Threshold;
    [ExtensionAttribute]
public static PooledObject`1<StringBuilder> GetPooledObject(ObjectPool`1<StringBuilder> pool);
    [ExtensionAttribute]
public static PooledObject`1<Stack`1<TItem>> GetPooledObject(ObjectPool`1<Stack`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<Queue`1<TItem>> GetPooledObject(ObjectPool`1<Queue`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<HashSet`1<TItem>> GetPooledObject(ObjectPool`1<HashSet`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<Dictionary`2<TKey, TValue>> GetPooledObject(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    [ExtensionAttribute]
public static PooledObject`1<List`1<TItem>> GetPooledObject(ObjectPool`1<List`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<T> GetPooledObject(ObjectPool`1<T> pool);
    [ExtensionAttribute]
public static StringBuilder AllocateAndClear(ObjectPool`1<StringBuilder> pool);
    [ExtensionAttribute]
public static Stack`1<T> AllocateAndClear(ObjectPool`1<Stack`1<T>> pool);
    [ExtensionAttribute]
public static Queue`1<T> AllocateAndClear(ObjectPool`1<Queue`1<T>> pool);
    [ExtensionAttribute]
public static HashSet`1<T> AllocateAndClear(ObjectPool`1<HashSet`1<T>> pool);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> AllocateAndClear(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    [ExtensionAttribute]
public static List`1<T> AllocateAndClear(ObjectPool`1<List`1<T>> pool);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<StringBuilder> pool, StringBuilder sb);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<HashSet`1<T>> pool, HashSet`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Stack`1<T>> pool, Stack`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Queue`1<T>> pool, Queue`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Dictionary`2<TKey, TValue>> pool, Dictionary`2<TKey, TValue> map);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<List`1<T>> pool, List`1<T> list);
}
internal static class Roslyn.Utilities.SharedPools : object {
    public static ObjectPool`1<HashSet`1<string>> StringIgnoreCaseHashSet;
    public static ObjectPool`1<HashSet`1<string>> StringHashSet;
    public static ObjectPool`1<Byte[]> ByteArray;
    public static int ByteBufferSize;
    private static int ByteBufferCount;
    private static SharedPools();
    public static ObjectPool`1<T> BigDefault();
    public static ObjectPool`1<T> Default();
    public static ObjectPool`1<Dictionary`2<string, T>> StringIgnoreCaseDictionary();
}
internal class Roslyn.Utilities.SimpleRecordingObjectBinder : RecordingObjectBinder {
    private Dictionary`2<TypeKey, Type> _typeMap;
    private Dictionary`2<Type, Func`2<ObjectReader, object>> _readerMap;
    public virtual Type GetType(string assemblyName, string typeName);
    public virtual Func`2<ObjectReader, object> GetReader(Type type);
    private bool HasConstructor(Type type);
    public virtual void Record(Type type);
    public virtual void Record(object instance);
}
internal class Roslyn.Utilities.SimpleTaskQueue : object {
    private TaskScheduler _taskScheduler;
    private object _gate;
    private Task _latestTask;
    private int _taskCount;
    public Task LastScheduledTask { get; }
    public SimpleTaskQueue(TaskScheduler taskScheduler);
    private TTask ScheduleTaskWorker(Func`2<int, TTask> taskCreator, CancellationToken cancellationToken);
    public Task ScheduleTask(Action taskAction, CancellationToken cancellationToken);
    public Task`1<T> ScheduleTask(Func`1<T> taskFunc, CancellationToken cancellationToken);
    public Task ScheduleTask(Func`1<Task> taskFuncAsync, CancellationToken cancellationToken);
    public Task`1<T> ScheduleTask(Func`1<Task`1<T>> taskFuncAsync, CancellationToken cancellationToken);
    public Task get_LastScheduledTask();
}
internal static class Roslyn.Utilities.SpecializedCollections : object {
    public static Byte[] EmptyBytes;
    public static Object[] EmptyObjects;
    private static SpecializedCollections();
    public static T[] EmptyArray();
    public static IEnumerator`1<T> EmptyEnumerator();
    public static IEnumerable`1<T> EmptyEnumerable();
    public static ICollection`1<T> EmptyCollection();
    public static IList`1<T> EmptyList();
    public static IReadOnlyList`1<T> EmptyReadOnlyList();
    public static ISet`1<T> EmptySet();
    public static IDictionary`2<TKey, TValue> EmptyDictionary();
    public static IEnumerable`1<T> SingletonEnumerable(T value);
    public static ICollection`1<T> SingletonCollection(T value);
    public static IEnumerator`1<T> SingletonEnumerator(T value);
    public static IEnumerable`1<T> ReadOnlyEnumerable(IEnumerable`1<T> values);
    public static ICollection`1<T> ReadOnlyCollection(ICollection`1<T> collection);
    public static ISet`1<T> ReadOnlySet(ISet`1<T> set);
    public static ISet`1<T> ReadOnlySet(IEnumerable`1<T> values);
}
internal static class Roslyn.Utilities.SpecializedTasks : object {
    public static Task`1<bool> True;
    public static Task`1<bool> False;
    public static Task EmptyTask;
    private static SpecializedTasks();
    public static Task`1<T> Default();
    public static Task`1<ImmutableArray`1<T>> EmptyImmutableArray();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T> FromResult(T t);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.StringExtensions : object {
    private static ImmutableArray`1<string> s_lazyNumerals;
    private static Func`2<char, char> s_toLower;
    private static Func`2<char, char> s_toUpper;
    private static StringExtensions();
    internal static string GetNumeral(int number);
    [ExtensionAttribute]
public static string Join(IEnumerable`1<string> source, string separator);
    [ExtensionAttribute]
public static bool LooksLikeInterfaceName(string name);
    [ExtensionAttribute]
public static bool LooksLikeTypeParameterName(string name);
    [ExtensionAttribute]
public static string ToPascalCase(string shortName, bool trimLeadingTypePrefix);
    [ExtensionAttribute]
public static string ToCamelCase(string shortName, bool trimLeadingTypePrefix);
    [ExtensionAttribute]
private static string ConvertCase(string shortName, bool trimLeadingTypePrefix, Func`2<char, char> convert);
    [ExtensionAttribute]
internal static bool IsValidClrTypeName(string name);
    [ExtensionAttribute]
internal static bool IsValidClrNamespaceName(string name);
    [ExtensionAttribute]
internal static string GetWithSingleAttributeSuffix(string name, bool isCaseSensitive);
    [ExtensionAttribute]
internal static bool TryGetWithoutAttributeSuffix(string name, String& result);
    [ExtensionAttribute]
internal static string GetWithoutAttributeSuffix(string name, bool isCaseSensitive);
    [ExtensionAttribute]
internal static bool TryGetWithoutAttributeSuffix(string name, bool isCaseSensitive, String& result);
    [ExtensionAttribute]
internal static bool IsValidUnicodeString(string str);
    [ExtensionAttribute]
internal static string Unquote(string arg);
    [ExtensionAttribute]
internal static string Unquote(string arg, Boolean& quoted);
    [ExtensionAttribute]
internal static int IndexOfBalancedParenthesis(string str, int openingOffset, char closing);
    [ExtensionAttribute]
internal static char First(string arg);
    [ExtensionAttribute]
internal static char Last(string arg);
    [ExtensionAttribute]
internal static bool All(string arg, Predicate`1<char> predicate);
}
internal class Roslyn.Utilities.SyntaxPath : object {
    private List`1<PathSegment> _segments;
    private int _kind;
    private bool _trackKinds;
    public SyntaxPath(SyntaxNodeOrToken nodeOrToken, bool trackKinds);
    private void AddSegment(SyntaxNodeOrToken nodeOrToken);
    public bool TryResolve(SyntaxNode root, SyntaxNodeOrToken& nodeOrToken);
    private SyntaxNodeOrToken FindChild(SyntaxNodeOrToken current, PathSegment segment);
    public bool TryResolve(SyntaxTree syntaxTree, CancellationToken cancellationToken, TNode& node);
    public bool TryResolve(SyntaxNode root, TNode& node);
    public static bool op_Equality(SyntaxPath left, SyntaxPath right);
    public static bool op_Inequality(SyntaxPath left, SyntaxPath right);
    public virtual bool Equals(object obj);
    public bool Equals(SyntaxPath other);
    public virtual int GetHashCode();
    private int GetSegmentHashCode();
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.TaskExtensions : object {
    [ExtensionAttribute]
public static T WaitAndGetResult(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SafeContinueWith(Task task, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWith(Task`1<TInput> task, Func`2<Task`1<TInput>, TResult> continuationFunction, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWith(Task`1<TInput> task, Func`2<Task`1<TInput>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWith(Task`1<TInput> task, Action`1<Task`1<TInput>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWith(Task task, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWith(Task task, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWith(Task task, Action`1<Task> continuationAction, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWith(Task`1<TInput> task, Action`1<Task`1<TInput>> continuationFunction, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWith(Task`1<TInput> task, Func`2<Task`1<TInput>, TResult> continuationFunction, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWith(Task task, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> ContinueWithAfterDelay(Task`1<TInput> task, Func`2<Task`1<TInput>, TResult> continuationFunction, CancellationToken cancellationToken, int millisecondsDelay, TaskContinuationOptions taskContinuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TNResult> ContinueWithAfterDelay(Task task, Func`2<Task, TNResult> continuationFunction, CancellationToken cancellationToken, int millisecondsDelay, TaskContinuationOptions taskContinuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task ContinueWithAfterDelay(Task task, Action continuationAction, CancellationToken cancellationToken, int millisecondsDelay, TaskContinuationOptions taskContinuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWithFromAsync(Task`1<TInput> task, Func`2<Task`1<TInput>, Task`1<TResult>> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWithFromAsync(Task task, Func`2<Task, Task`1<TResult>> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWithFromAsync(Task task, Func`2<Task, Task> continuationFunction, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWithFromAsync(Task task, Func`2<Task, Task> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TNResult> ContinueWithAfterDelayFromAsync(Task task, Func`2<Task, Task`1<TNResult>> continuationFunction, CancellationToken cancellationToken, int millisecondsDelay, TaskContinuationOptions taskContinuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task ContinueWithAfterDelayFromAsync(Task task, Func`2<Task, Task> continuationFunction, CancellationToken cancellationToken, int millisecondsDelay, TaskContinuationOptions taskContinuationOptions, TaskScheduler scheduler);
    internal static void ReportFatalError(Task task, object continuationFunction);
    private static void ReportFatalErrorWorker(Task task, object continuationFunction);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.TaskFactoryExtensions : object {
    [ExtensionAttribute]
public static Task SafeStartNew(TaskFactory factory, Action action, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeStartNew(TaskFactory factory, Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeStartNew(TaskFactory factory, Func`1<TResult> func, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeStartNew(TaskFactory factory, Func`1<TResult> func, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeStartNewFromAsync(TaskFactory factory, Func`1<Task> actionAsync, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeStartNewFromAsync(TaskFactory factory, Func`1<Task> actionAsync, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeStartNewFromAsync(TaskFactory factory, Func`1<Task`1<TResult>> funcAsync, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeStartNewFromAsync(TaskFactory factory, Func`1<Task`1<TResult>> funcAsync, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.TextChangeRangeExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<TextChangeRange> Accumulate(Nullable`1<TextChangeRange> accumulatedTextChangeSoFar, IEnumerable`1<TextChangeRange> changesInNextVersion);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.TopologicalSorter : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> TopologicalSort(IEnumerable`1<T> items, Func`2<T, IEnumerable`1<T>> itemsBefore);
    [ExtensionAttribute]
public static IEnumerable`1<T> TopologicalSort(IEnumerable`1<T> items, Func`2<T, IEnumerable`1<T>> itemsBefore, Func`2<T, IEnumerable`1<T>> itemsAfter);
    private static void Visit(T item, Func`2<T, IEnumerable`1<T>> itemsBefore, List`1<T> result, HashSet`1<T> visited);
    private static Func`2<T, IEnumerable`1<T>> CreateCombinedItemsBefore(IEnumerable`1<T> items, Func`2<T, IEnumerable`1<T>> itemsBefore, Func`2<T, IEnumerable`1<T>> itemsAfter);
}
internal abstract class Roslyn.Utilities.ValueSource`1 : object {
    public static ConstantValueSource`1<T> Empty;
    public bool HasValue { get; }
    private static ValueSource`1();
    public abstract virtual bool TryGetValue(T& value);
    public abstract virtual T GetValue(CancellationToken cancellationToken);
    public abstract virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
    public bool get_HasValue();
}
internal static class Roslyn.Utilities.ValueTuple : object {
    public static ValueTuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static ValueTuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
}
internal class Roslyn.Utilities.ValueTuple`2 : ValueType {
    private static EqualityComparer`1<T1> s_comparer1;
    private static EqualityComparer`1<T2> s_comparer2;
    public T1 Item1;
    public T2 Item2;
    public ValueTuple`2(T1 item1, T2 item2);
    private static ValueTuple`2();
    public sealed virtual bool Equals(ValueTuple`2<T1, T2> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ValueTuple`2<T1, T2> left, ValueTuple`2<T1, T2> right);
    public static bool op_Inequality(ValueTuple`2<T1, T2> left, ValueTuple`2<T1, T2> right);
}
internal class Roslyn.Utilities.ValueTuple`3 : ValueType {
    private static EqualityComparer`1<T1> s_comparer1;
    private static EqualityComparer`1<T2> s_comparer2;
    private static EqualityComparer`1<T3> s_comparer3;
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public ValueTuple`3(T1 item1, T2 item2, T3 item3);
    private static ValueTuple`3();
    public sealed virtual bool Equals(ValueTuple`3<T1, T2, T3> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ValueTuple`3<T1, T2, T3> left, ValueTuple`3<T1, T2, T3> right);
    public static bool op_Inequality(ValueTuple`3<T1, T2, T3> left, ValueTuple`3<T1, T2, T3> right);
}
internal class Roslyn.Utilities.WeakConstantValueSource`1 : ValueSource`1<T> {
    private WeakReference`1<T> _weakValue;
    public WeakConstantValueSource`1(T value);
    public virtual T GetValue(CancellationToken cancellationToken);
    public virtual bool TryGetValue(T& value);
    public virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
}
internal static class Roslyn.Utilities.WeakEventHandler`1 : object {
    public static EventHandler`1<TArgs> Create(TTarget target, Action`3<TTarget, object, TArgs> invoker);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.WeakReferenceExtensions : object {
    [ExtensionAttribute]
public static T GetTarget(WeakReference`1<T> reference);
    [ExtensionAttribute]
public static bool IsNull(WeakReference`1<T> reference);
}
