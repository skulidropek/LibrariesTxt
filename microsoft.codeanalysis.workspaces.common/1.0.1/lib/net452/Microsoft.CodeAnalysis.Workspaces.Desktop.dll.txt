internal abstract class Microsoft.CodeAnalysis.AbstractAnalyzerAssemblyLoader : object {
    private Dictionary`2<string, Assembly> _pathsToAssemblies;
    private Dictionary`2<string, Assembly> _namesToAssemblies;
    private List`1<string> _dependencyPaths;
    private object _guard;
    private bool _hookedAssemblyResolve;
    protected abstract virtual Assembly LoadCore(string fullPath);
    public sealed virtual void AddDependencyLocation(string fullPath);
    public sealed virtual Assembly LoadFromPath(string fullPath);
    private Assembly LoadInternal(string fullPath);
    private Assembly CurrentDomain_AssemblyResolve(object sender, ResolveEventArgs args);
    private Assembly AssemblyResolveInternal(ResolveEventArgs args);
    private bool AssemblyAlreadyLoaded(string path);
    private bool FileMatchesAssemblyName(string path, string assemblySimpleName);
    private static AssemblyIdentity TryGetAssemblyIdentity(string filePath);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.AssemblyIdentityExtensions : object {
    [ExtensionAttribute]
public static AssemblyName ToAssemblyName(AssemblyIdentity identity);
}
public static class Microsoft.CodeAnalysis.CommandLineProject : object {
    private static Char[] s_folderSplitters;
    private static CommandLineProject();
    public static ProjectInfo CreateProjectInfo(string projectName, string language, IEnumerable`1<string> commandLineArgs, string projectDirectory, Workspace workspace);
    public static ProjectInfo CreateProjectInfo(string projectName, string language, string commandLine, string baseDirectory, Workspace workspace);
    private static IList`1<string> GetFolders(string path);
}
internal class Microsoft.CodeAnalysis.CSharp.CSharpProjectFileLoader : ProjectFileLoader {
    private HostWorkspaceServices _workspaceServices;
    public string Language { get; }
    public IHostBuildDataFactory MSBuildHost { get; }
    public ICommandLineArgumentsFactoryService CommandLineArgumentsFactoryService { get; }
    public CSharpProjectFileLoader(HostWorkspaceServices workspaceServices);
    public virtual string get_Language();
    public IHostBuildDataFactory get_MSBuildHost();
    public ICommandLineArgumentsFactoryService get_CommandLineArgumentsFactoryService();
    protected virtual ProjectFile CreateProjectFile(Project loadedProject);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.MSBuild.IProjectFileLoader", "C#", "Default")]
[SharedAttribute]
[ProjectFileExtensionAttribute("csproj")]
[ProjectTypeGuidAttribute("FAE04EC0-301F-11D3-BF4B-00C04F79EFBC")]
internal class Microsoft.CodeAnalysis.CSharp.CSharpProjectFileLoaderFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
internal class Microsoft.CodeAnalysis.FileBasedXmlDocumentationProvider : XmlDocumentationProvider {
    private string _filePath;
    public FileBasedXmlDocumentationProvider(string filePath);
    protected virtual Stream GetSourceStream(CancellationToken cancellationToken);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.CodeAnalysis.FileTextLoader : TextLoader {
    private string _path;
    private Encoding _defaultEncoding;
    public string Path { get; }
    public Encoding DefaultEncoding { get; }
    public FileTextLoader(string path, Encoding defaultEncoding);
    public string get_Path();
    public Encoding get_DefaultEncoding();
    protected virtual SourceText CreateText(Stream stream, Workspace workspace);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FileTextLoader/<LoadTextAndVersionAsync>d__8")]
public virtual Task`1<TextAndVersion> LoadTextAndVersionAsync(Workspace workspace, DocumentId documentId, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FusionAssemblyIdentity : object {
    private static object s_assemblyIdentityGate;
    private static int ERROR_INSUFFICIENT_BUFFER;
    private static int FUSION_E_INVALID_NAME;
    private static FusionAssemblyIdentity();
    private static int CreateAssemblyNameObject(IAssemblyName& ppEnum, string szAssemblyName, UInt32 dwFlags, IntPtr pvReserved);
    private static int RealCreateAssemblyNameObject(IAssemblyName& ppEnum, string szAssemblyName, UInt32 dwFlags, IntPtr pvReserved);
    internal static string GetDisplayName(IAssemblyName nameObject, ASM_DISPLAYF displayFlags);
    internal static Byte[] GetPropertyBytes(IAssemblyName nameObject, PropertyId propertyId);
    internal static string GetPropertyString(IAssemblyName nameObject, PropertyId propertyId);
    internal static bool IsKeyOrTokenEmpty(IAssemblyName nameObject, PropertyId propertyId);
    internal static Version GetVersion(IAssemblyName nameObject);
    internal static Version GetVersion(IAssemblyName name, AssemblyIdentityParts& parts);
    internal static Byte[] GetPublicKeyToken(IAssemblyName nameObject);
    internal static Byte[] GetPublicKey(IAssemblyName nameObject);
    internal static Nullable`1<UInt32> GetPropertyWord(IAssemblyName nameObject, PropertyId propertyId);
    internal static string GetName(IAssemblyName nameObject);
    internal static string GetCulture(IAssemblyName nameObject);
    internal static AssemblyContentType GetContentType(IAssemblyName nameObject);
    internal static CultureInfo GetCultureInfo(IAssemblyName nameObject);
    internal static ProcessorArchitecture GetProcessorArchitecture(IAssemblyName nameObject);
    internal static AssemblyNameFlags GetFlags(IAssemblyName nameObject);
    private static void SetProperty(IAssemblyName nameObject, PropertyId propertyId, string data);
    private static void SetProperty(IAssemblyName nameObject, PropertyId propertyId, Byte[] data);
    private static void SetProperty(IAssemblyName nameObject, PropertyId propertyId, ushort data);
    private static void SetProperty(IAssemblyName nameObject, PropertyId propertyId, UInt32 data);
    private static void SetPublicKeyToken(IAssemblyName nameObject, Byte[] value);
    internal static AssemblyName ToAssemblyName(IAssemblyName nameObject);
    internal static AssemblyIdentity ToAssemblyIdentity(IAssemblyName nameObject);
    internal static IAssemblyName ToAssemblyNameObject(AssemblyName name);
    internal static IAssemblyName ToAssemblyNameObject(string displayName);
    internal static IAssemblyName GetBestMatch(IEnumerable`1<IAssemblyName> candidates, string preferredCultureOpt);
}
internal static class Microsoft.CodeAnalysis.GlobalAssemblyCache : object {
    public static ImmutableArray`1<ProcessorArchitecture> CurrentArchitectures;
    private static int MAX_PATH;
    private static int ERROR_INSUFFICIENT_BUFFER;
    public static ImmutableArray`1<string> RootLocations;
    private static int S_OK;
    private static int S_FALSE;
    private static GlobalAssemblyCache();
    private static int CreateAssemblyEnum(IAssemblyEnum& ppEnum, IApplicationContext pAppCtx, IAssemblyName pName, ASM_CACHE dwFlags, IntPtr pvReserved);
    private static int GetCachePath(ASM_CACHE id, Byte* path, Int32& length);
    private static void CreateAssemblyCache(IAssemblyCache& ppAsmCache, UInt32 dwReserved);
    private static string GetLocation(ASM_CACHE gacId);
    public static IEnumerable`1<AssemblyIdentity> GetAssemblyIdentities(AssemblyName partialName, ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    public static IEnumerable`1<AssemblyIdentity> GetAssemblyIdentities(string partialName, ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    public static IEnumerable`1<string> GetAssemblySimpleNames(ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    private static IEnumerable`1<AssemblyIdentity> GetAssemblyIdentities(IAssemblyName partialName, ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.GlobalAssemblyCache/<GetAssemblyObjects>d__19")]
internal static IEnumerable`1<IAssemblyName> GetAssemblyObjects(IAssemblyName partialNameFilter, ImmutableArray`1<ProcessorArchitecture> architectureFilter);
    public static AssemblyIdentity ResolvePartialName(string displayName, ImmutableArray`1<ProcessorArchitecture> architectureFilter, CultureInfo preferredCulture);
    public static AssemblyIdentity ResolvePartialName(string displayName, String& location, ImmutableArray`1<ProcessorArchitecture> architectureFilter, CultureInfo preferredCulture);
    private static AssemblyIdentity ResolvePartialName(string displayName, ImmutableArray`1<ProcessorArchitecture> architectureFilter, CultureInfo preferredCulture, String& location, bool resolveLocation);
    internal static string GetAssemblyLocation(IAssemblyName nameObject);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Host.ITextFactoryService", "Desktop")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.DesktopTextFactoryService : object {
    public sealed virtual SourceText CreateText(Stream stream, Encoding defaultEncoding, CancellationToken cancellationToken);
    public sealed virtual SourceText CreateText(TextReader reader, Encoding encoding, CancellationToken cancellationToken);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Host.IDocumentationProviderService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.DocumentationProviderServiceFactory : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
public static class Microsoft.CodeAnalysis.Host.Mef.DesktopMefHostServices : object {
    private static MefHostServices s_defaultServices;
    private static ImmutableArray`1<Assembly> s_defaultAssemblies;
    public static MefHostServices DefaultServices { get; }
    private static ImmutableArray`1<Assembly> DefaultAssemblies { get; }
    public static MefHostServices get_DefaultServices();
    private static ImmutableArray`1<Assembly> get_DefaultAssemblies();
    private static ImmutableArray`1<Assembly> CreateDefaultAssemblies();
}
public class Microsoft.CodeAnalysis.Host.Mef.MefV1HostServices : HostServices {
    private ExportProvider _exportProvider;
    private ImmutableDictionary`2<ExportKey, IEnumerable> _exportsMap;
    private MefV1HostServices(ExportProvider exportProvider);
    public static MefV1HostServices Create(ExportProvider exportProvider);
    public static MefV1HostServices Create(IEnumerable`1<Assembly> assemblies);
    protected internal virtual HostWorkspaceServices CreateWorkspaceServices(Workspace workspace);
    public sealed virtual IEnumerable`1<Lazy`2<TExtension, TMetadata>> GetExports();
    public sealed virtual IEnumerable`1<Lazy`1<TExtension>> GetExports();
    [CompilerGeneratedAttribute]
private IEnumerable <GetExports>b__6_0(ExportKey _);
    [CompilerGeneratedAttribute]
private IEnumerable <GetExports>b__7_0(ExportKey _);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Host.IAnalyzerService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.SimpleAnalyzerAssemblyLoaderService : object {
    private SimpleAnalyzerAssemblyLoader _loader;
    public sealed virtual IAnalyzerAssemblyLoader GetLoader();
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Host.ITemporaryStorageService", "Host")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal class Microsoft.CodeAnalysis.Internal.Log.EtwLogger : object {
    private Func`2<FunctionId, bool> _loggingChecker;
    private RoslynEventSource _source;
    public EtwLogger(IOptionService optionService);
    public EtwLogger(Func`2<FunctionId, bool> loggingChecker);
    public sealed virtual bool IsEnabled(FunctionId functionId);
    public sealed virtual void Log(FunctionId functionId, LogMessage logMessage);
    public sealed virtual void LogBlockStart(FunctionId functionId, LogMessage logMessage, int uniquePairId, CancellationToken cancellationToken);
    public sealed virtual void LogBlockEnd(FunctionId functionId, LogMessage logMessage, int uniquePairId, int delta, CancellationToken cancellationToken);
    private bool IsVerbose();
    private string GetMessage(LogMessage logMessage);
}
[EventSourceAttribute]
internal class Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource : EventSource {
    public static RoslynEventSource Instance;
    private bool _initialized;
    private static RoslynEventSource();
    [EventAttribute("1")]
public void Log(string message, FunctionId functionId);
    [EventAttribute("2")]
public void BlockStart(string message, FunctionId functionId, int blockId);
    [EventAttribute("3")]
public void BlockStop(FunctionId functionId, int tick, int blockId);
    [EventAttribute("4")]
public void SendFunctionDefinitions(string definitions);
    [EventAttribute("5")]
public void BlockCanceled(FunctionId functionId, int tick, int blockId);
    [NonEventAttribute]
protected virtual void OnEventCommand(EventCommandEventArgs command);
    [NonEventAttribute]
private bool FunctionDefinitionRequested(EventCommandEventArgs command);
    [NonEventAttribute]
private void SendFunctionDefinitionsAsync();
    [NonEventAttribute]
private void SendFunctionDefinitions();
    [NonEventAttribute]
public static string GenerateFunctionDefinitions();
}
internal class Microsoft.CodeAnalysis.MSBuild.BuildTargets : object {
    private Project _project;
    private List`1<string> _buildTargets;
    private static Char[] s_targetsSplitChars;
    public String[] Targets { get; }
    public BuildTargets(Project project, String[] targets);
    private static BuildTargets();
    public String[] get_Targets();
    public void Remove(string target);
    public void RemoveAfter(string target, bool includeTargetInRemoval);
    private bool DependsOn(string target, string dependentTarget);
    private static IEnumerable`1<string> SplitTargets(string targets);
    private static IEnumerable`1<string> GetTargetDependents(Project project, string targetName);
    internal static IEnumerable`1<string> GetTopLevelTargets(Project project);
}
internal class Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo : object {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LogicalPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLinked>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGenerated>k__BackingField;
    public string FilePath { get; }
    public string LogicalPath { get; }
    public bool IsLinked { get; }
    public bool IsGenerated { get; }
    public DocumentFileInfo(string filePath, string logicalPath, bool isLinked, bool isGenerated);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public string get_LogicalPath();
    [CompilerGeneratedAttribute]
public bool get_IsLinked();
    [CompilerGeneratedAttribute]
public bool get_IsGenerated();
}
internal interface Microsoft.CodeAnalysis.MSBuild.IProjectFile {
    public string FilePath { get; }
    public abstract virtual string get_FilePath();
    public abstract virtual Task`1<ProjectFileInfo> GetProjectFileInfoAsync(CancellationToken cancellationToken);
    public abstract virtual SourceCodeKind GetSourceCodeKind(string documentFileName);
    public abstract virtual string GetDocumentExtension(SourceCodeKind kind);
    public abstract virtual string GetPropertyValue(string name);
    public abstract virtual void AddDocument(string filePath, string logicalPath);
    public abstract virtual void RemoveDocument(string filePath);
    public abstract virtual void AddMetadataReference(MetadataReference reference, AssemblyIdentity identity);
    public abstract virtual void RemoveMetadataReference(MetadataReference reference, AssemblyIdentity identity);
    public abstract virtual void AddProjectReference(string projectName, ProjectFileReference reference);
    public abstract virtual void RemoveProjectReference(string projectName, string projectFilePath);
    public abstract virtual void AddAnalyzerReference(AnalyzerReference reference);
    public abstract virtual void RemoveAnalyzerReference(AnalyzerReference reference);
    public abstract virtual void Save();
}
internal interface Microsoft.CodeAnalysis.MSBuild.IProjectFileLoader {
    public string Language { get; }
    public abstract virtual string get_Language();
    public abstract virtual Task`1<IProjectFile> LoadProjectFileAsync(string path, IDictionary`2<string, string> globalProperties, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.MSBuild.LineScanner : object {
    private string _line;
    private int _currentPosition;
    public LineScanner(string line);
    public string ReadUpToAndEat(string delimiter);
    public string ReadRest();
}
public class Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace : Workspace {
    private NonReentrantLock _serializationLock;
    private NonReentrantLock _dataGuard;
    private Dictionary`2<string, string> _extensionToLanguageMap;
    private Dictionary`2<string, ProjectId> _projectPathToProjectIdMap;
    private Dictionary`2<string, IProjectFileLoader> _projectPathToLoaderMap;
    private string _solutionFilePath;
    private ImmutableDictionary`2<string, string> _properties;
    [CompilerGeneratedAttribute]
private bool <LoadMetadataForReferencedProjects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipUnrecognizedProjects>k__BackingField;
    private static string SolutionDirProperty;
    private static Char[] s_directorySplitChars;
    private IProjectFile _applyChangesProjectFile;
    public ImmutableDictionary`2<string, string> Properties { get; }
    public bool LoadMetadataForReferencedProjects { get; public set; }
    public bool SkipUnrecognizedProjects { get; public set; }
    private MSBuildWorkspace(HostServices hostServices, ImmutableDictionary`2<string, string> properties);
    private static MSBuildWorkspace();
    public static MSBuildWorkspace Create();
    public static MSBuildWorkspace Create(IDictionary`2<string, string> properties);
    public static MSBuildWorkspace Create(IDictionary`2<string, string> properties, HostServices hostServices);
    public ImmutableDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public bool get_LoadMetadataForReferencedProjects();
    [CompilerGeneratedAttribute]
public void set_LoadMetadataForReferencedProjects(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipUnrecognizedProjects();
    [CompilerGeneratedAttribute]
public void set_SkipUnrecognizedProjects(bool value);
    public void AssociateFileExtensionWithLanguage(string projectFileExtension, string language);
    public void CloseSolution();
    protected virtual void ClearSolutionData();
    private void SetSolutionProperties(string solutionFilePath);
    private ProjectId GetProjectId(string fullProjectPath);
    private ProjectId GetOrCreateProjectId(string fullProjectPath);
    private bool TryGetLoaderFromProjectPath(string projectFilePath, ReportMode mode, IProjectFileLoader& loader);
    private bool TryGetAbsoluteProjectPath(string path, string baseDirectory, ReportMode mode, String& absolutePath);
    private string GetAbsoluteSolutionPath(string path, string baseDirectory);
    private void ReportFailure(ReportMode mode, string message, Func`2<string, Exception> createException);
    private string GetAbsolutePath(string path, string baseDirectoryPath);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace/<OpenSolutionAsync>d__34")]
public Task`1<Solution> OpenSolutionAsync(string solutionFilePath, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace/<OpenProjectAsync>d__35")]
public Task`1<Project> OpenProjectAsync(string projectFilePath, CancellationToken cancellationToken);
    private string TryGetAbsolutePath(string path, ReportMode mode);
    private void UpdateReferencesAfterAdd();
    private Solution UpdateReferencesAfterAdd(Solution solution);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace/<GetOrLoadProjectAsync>d__39")]
private Task`1<ProjectId> GetOrLoadProjectAsync(string projectFilePath, IProjectFileLoader loader, bool preferMetadata, Dictionary`2<ProjectId, ProjectInfo> loadedProjects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace/<LoadProjectAsync>d__40")]
private Task`1<ProjectId> LoadProjectAsync(string projectFilePath, IProjectFileLoader loader, bool preferMetadata, Dictionary`2<ProjectId, ProjectInfo> loadedProjects, CancellationToken cancellationToken);
    private static Encoding GetDefaultEncoding(int codePage);
    private static void GetDocumentNameAndFolders(string logicalPath, String& name, ImmutableArray`1& folders);
    private void CheckDocuments(IEnumerable`1<DocumentFileInfo> docs, string projectFilePath, ProjectId projectId);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace/<ResolveProjectReferencesAsync>d__46")]
private Task`1<ResolvedReferences> ResolveProjectReferencesAsync(ProjectId thisProjectId, string thisProjectPath, IReadOnlyList`1<ProjectFileReference> projectFileReferences, bool preferMetadata, Dictionary`2<ProjectId, ProjectInfo> loadedProjects, CancellationToken cancellationToken);
    private bool ProjectAlreadyReferencesProject(Dictionary`2<ProjectId, ProjectInfo> loadedProjects, ProjectId fromProject, ProjectId targetProject);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.MSBuildWorkspace/<GetProjectMetadata>d__48")]
private Task`1<MetadataReference> GetProjectMetadata(string projectFilePath, ImmutableArray`1<string> aliases, IDictionary`2<string, string> globalProperties, CancellationToken cancellationToken);
    public virtual bool CanApplyChange(ApplyChangesKind feature);
    private bool HasProjectFileChanges(ProjectChanges changes);
    public virtual bool TryApplyChanges(Solution newSolution);
    protected virtual void ApplyProjectChanges(ProjectChanges projectChanges);
    protected virtual void ApplyDocumentTextChanged(DocumentId documentId, SourceText text);
    private static Encoding DetermineEncoding(SourceText text, Document document);
    protected virtual void ApplyDocumentAdded(DocumentInfo info, SourceText text);
    private void SaveDocumentText(DocumentId id, string fullPath, SourceText newText, Encoding encoding);
    protected virtual void ApplyDocumentRemoved(DocumentId documentId);
    private void DeleteDocumentFile(DocumentId documentId, string fullPath);
    protected virtual void ApplyMetadataReferenceAdded(ProjectId projectId, MetadataReference metadataReference);
    protected virtual void ApplyMetadataReferenceRemoved(ProjectId projectId, MetadataReference metadataReference);
    private AssemblyIdentity GetAssemblyIdentity(ProjectId projectId, MetadataReference metadataReference);
    protected virtual void ApplyProjectReferenceAdded(ProjectId projectId, ProjectReference projectReference);
    protected virtual void ApplyProjectReferenceRemoved(ProjectId projectId, ProjectReference projectReference);
    protected virtual void ApplyAnalyzerReferenceAdded(ProjectId projectId, AnalyzerReference analyzerReference);
    protected virtual void ApplyAnalyzerReferenceRemoved(ProjectId projectId, AnalyzerReference analyzerReference);
}
internal class Microsoft.CodeAnalysis.MSBuild.ProjectBlock : object {
    private Guid _projectTypeGuid;
    private string _projectName;
    private string _projectPath;
    private Guid _projectGuid;
    private IEnumerable`1<SectionBlock> _projectSections;
    public Guid ProjectTypeGuid { get; }
    public string ProjectName { get; }
    public string ProjectPath { get; }
    public Guid ProjectGuid { get; }
    public IEnumerable`1<SectionBlock> ProjectSections { get; }
    public ProjectBlock(Guid projectTypeGuid, string projectName, string projectPath, Guid projectGuid, IEnumerable`1<SectionBlock> projectSections);
    public Guid get_ProjectTypeGuid();
    public string get_ProjectName();
    public string get_ProjectPath();
    public Guid get_ProjectGuid();
    public IEnumerable`1<SectionBlock> get_ProjectSections();
    internal string GetText();
    internal static ProjectBlock Parse(TextReader reader);
}
internal abstract class Microsoft.CodeAnalysis.MSBuild.ProjectFile : object {
    private ProjectFileLoader _loader;
    private Project _loadedProject;
    private static SemaphoreSlim s_buildManagerLock;
    private IDictionary`2<string, ProjectItem> _documents;
    public string FilePath { get; }
    public ProjectFile(ProjectFileLoader loader, Project loadedProject);
    private static ProjectFile();
    protected virtual override void Finalize();
    public virtual string get_FilePath();
    public sealed virtual string GetPropertyValue(string name);
    public abstract virtual SourceCodeKind GetSourceCodeKind(string documentFileName);
    public abstract virtual string GetDocumentExtension(SourceCodeKind kind);
    public abstract virtual Task`1<ProjectFileInfo> GetProjectFileInfoAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.ProjectFile/<BuildAsync>d__10")]
protected Task`1<ProjectInstance> BuildAsync(string taskName, ITaskHost taskHost, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.ProjectFile/<BuildAsync>d__12")]
private Task`1<BuildResult> BuildAsync(BuildParameters parameters, BuildRequestData requestData, CancellationToken cancellationToken);
    private static Task`1<BuildResult> BuildAsync(BuildManager buildManager, BuildParameters parameters, BuildRequestData requestData, CancellationToken cancellationToken);
    protected virtual string GetOutputDirectory();
    protected virtual string GetAssemblyName();
    protected bool IsProjectReferenceOutputAssembly(ITaskItem item);
    protected IEnumerable`1<ProjectFileReference> GetProjectReferences(ProjectInstance executedProject);
    protected virtual ProjectFileReference CreateProjectFileReference(ProjectItemInstance reference);
    protected virtual IEnumerable`1<ITaskItem> GetDocumentsFromModel(ProjectInstance executedProject);
    protected virtual IEnumerable`1<ITaskItem> GetMetadataReferencesFromModel(ProjectInstance executedProject);
    protected virtual IEnumerable`1<ITaskItem> GetAnalyzerReferencesFromModel(ProjectInstance executedProject);
    protected virtual IEnumerable`1<ITaskItem> GetAdditionalFilesFromModel(ProjectInstance executedProject);
    public ProjectProperty GetProperty(string name);
    protected IEnumerable`1<ITaskItem> GetTaskItems(ProjectInstance executedProject, string itemType);
    protected string GetItemString(ProjectInstance executedProject, string itemType);
    protected string ReadPropertyString(ProjectInstance executedProject, string propertyName);
    protected string ReadPropertyString(ProjectInstance executedProject, string executedPropertyName, string evaluatedPropertyName);
    protected bool ReadPropertyBool(ProjectInstance executedProject, string propertyName);
    protected bool ReadPropertyBool(ProjectInstance executedProject, string executedPropertyName, string evaluatedPropertyName);
    private static bool ConvertToBool(string value);
    protected int ReadPropertyInt(ProjectInstance executedProject, string propertyName);
    protected int ReadPropertyInt(ProjectInstance executedProject, string executedPropertyName, string evaluatedPropertyName);
    private static int ConvertToInt(string value);
    protected ulong ReadPropertyULong(ProjectInstance executedProject, string propertyName);
    protected ulong ReadPropertyULong(ProjectInstance executedProject, string executedPropertyName, string evaluatedPropertyName);
    private static ulong ConvertToULong(string value);
    protected Nullable`1<TEnum> ReadPropertyEnum(ProjectInstance executedProject, string propertyName);
    protected Nullable`1<TEnum> ReadPropertyEnum(ProjectInstance executedProject, string executedPropertyName, string evaluatedPropertyName);
    private static Nullable`1<TEnum> ConvertToEnum(string value);
    protected string GetAbsolutePath(string path);
    protected string GetDocumentFilePath(ITaskItem documentItem);
    protected static bool IsDocumentLinked(ITaskItem documentItem);
    protected bool IsDocumentGenerated(ITaskItem documentItem);
    protected static string GetDocumentLogicalPath(ITaskItem documentItem, string projectDirectory);
    protected string GetReferenceFilePath(ProjectItemInstance projectItem);
    public sealed virtual void AddDocument(string filePath, string logicalPath);
    public sealed virtual void RemoveDocument(string filePath);
    public sealed virtual void AddMetadataReference(MetadataReference reference, AssemblyIdentity identity);
    private bool IsInGAC(string filePath);
    public sealed virtual void RemoveMetadataReference(MetadataReference reference, AssemblyIdentity identity);
    private ProjectItem FindReferenceItem(AssemblyIdentity identity, string filePath);
    public sealed virtual void AddProjectReference(string projectName, ProjectFileReference reference);
    public sealed virtual void RemoveProjectReference(string projectName, string projectFilePath);
    private ProjectItem FindProjectReferenceItem(string projectName, string projectFilePath);
    public sealed virtual void AddAnalyzerReference(AnalyzerReference reference);
    public sealed virtual void RemoveAnalyzerReference(AnalyzerReference reference);
    public sealed virtual void Save();
    internal static bool TryGetOutputKind(string outputKind, OutputKind& kind);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.MSBuild.ProjectFileExtensionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ProjectFileExtension>k__BackingField;
    public string ProjectFileExtension { get; public set; }
    public ProjectFileExtensionAttribute(string extension);
    [CompilerGeneratedAttribute]
public string get_ProjectFileExtension();
    [CompilerGeneratedAttribute]
public void set_ProjectFileExtension(string value);
}
internal class Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo : object {
    [CompilerGeneratedAttribute]
private string <OutputFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private CompilationOptions <CompilationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ParseOptions <ParseOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CodePage>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<DocumentFileInfo> <Documents>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<DocumentFileInfo> <AdditionalDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ProjectFileReference> <ProjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<MetadataReference> <MetadataReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<AnalyzerReference> <AnalyzerReferences>k__BackingField;
    public string OutputFilePath { get; }
    public string AssemblyName { get; }
    public CompilationOptions CompilationOptions { get; }
    public ParseOptions ParseOptions { get; }
    public int CodePage { get; }
    public IReadOnlyList`1<DocumentFileInfo> Documents { get; }
    public IReadOnlyList`1<DocumentFileInfo> AdditionalDocuments { get; }
    public IReadOnlyList`1<ProjectFileReference> ProjectReferences { get; }
    public IReadOnlyList`1<MetadataReference> MetadataReferences { get; }
    public IReadOnlyList`1<AnalyzerReference> AnalyzerReferences { get; }
    public ProjectFileInfo(string outputPath, string assemblyName, CompilationOptions compilationOptions, ParseOptions parseOptions, int codePage, IEnumerable`1<DocumentFileInfo> documents, IEnumerable`1<DocumentFileInfo> additionalDocuments, IEnumerable`1<ProjectFileReference> projectReferences, IEnumerable`1<MetadataReference> metadataReferences, IEnumerable`1<AnalyzerReference> analyzerReferences);
    [CompilerGeneratedAttribute]
public string get_OutputFilePath();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public CompilationOptions get_CompilationOptions();
    [CompilerGeneratedAttribute]
public ParseOptions get_ParseOptions();
    [CompilerGeneratedAttribute]
public int get_CodePage();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<DocumentFileInfo> get_Documents();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<DocumentFileInfo> get_AdditionalDocuments();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ProjectFileReference> get_ProjectReferences();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<MetadataReference> get_MetadataReferences();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<AnalyzerReference> get_AnalyzerReferences();
}
internal abstract class Microsoft.CodeAnalysis.MSBuild.ProjectFileLoader : object {
    private static XmlReaderSettings s_xmlSettings;
    public string Language { get; }
    private static ProjectFileLoader();
    public abstract virtual string get_Language();
    protected abstract virtual ProjectFile CreateProjectFile(Project loadedProject);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.ProjectFileLoader/<LoadProjectFileAsync>d__3")]
public sealed virtual Task`1<IProjectFile> LoadProjectFileAsync(string path, IDictionary`2<string, string> globalProperties, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.ProjectFileLoader/<LoadProjectAsync>d__5")]
private static Task`1<Project> LoadProjectAsync(string path, IDictionary`2<string, string> globalProperties, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.ProjectFileLoader/<GetOutputFilePathAsync>d__6")]
public static Task`1<string> GetOutputFilePathAsync(string path, IDictionary`2<string, string> globalProperties, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.ProjectFileLoader/<ReadFileAsync>d__7")]
private static Task`1<MemoryStream> ReadFileAsync(string path, CancellationToken cancellationToken);
    public static IProjectFileLoader GetLoaderForProjectTypeGuid(Workspace workspace, Guid guid);
    public static IProjectFileLoader GetLoaderForProjectFileExtension(Workspace workspace, string extension);
}
internal class Microsoft.CodeAnalysis.MSBuild.ProjectFileReference : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Aliases>k__BackingField;
    public string Path { get; }
    public ImmutableArray`1<string> Aliases { get; }
    public ProjectFileReference(string path, ImmutableArray`1<string> aliases);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Aliases();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.MSBuild.ProjectTypeGuidAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ProjectTypeGuid>k__BackingField;
    public string ProjectTypeGuid { get; public set; }
    public ProjectTypeGuidAttribute(string guid);
    [CompilerGeneratedAttribute]
public string get_ProjectTypeGuid();
    [CompilerGeneratedAttribute]
public void set_ProjectTypeGuid(string value);
}
internal class Microsoft.CodeAnalysis.MSBuild.SectionBlock : object {
    private string _type;
    private string _parenthesizedName;
    private string _value;
    private IEnumerable`1<KeyValuePair`2<string, string>> _keyValuePairs;
    public string Type { get; }
    public string ParenthesizedName { get; }
    public string Value { get; }
    public IEnumerable`1<KeyValuePair`2<string, string>> KeyValuePairs { get; }
    public SectionBlock(string type, string parenthesizedName, string value, IEnumerable`1<KeyValuePair`2<string, string>> keyValuePairs);
    public string get_Type();
    public string get_ParenthesizedName();
    public string get_Value();
    public IEnumerable`1<KeyValuePair`2<string, string>> get_KeyValuePairs();
    internal string GetText(int indent);
    internal static SectionBlock Parse(TextReader reader);
}
internal class Microsoft.CodeAnalysis.MSBuild.SolutionFile : object {
    private IEnumerable`1<string> _headerLines;
    private string _visualStudioVersionLineOpt;
    private string _minimumVisualStudioVersionLineOpt;
    private IEnumerable`1<ProjectBlock> _projectBlocks;
    private IEnumerable`1<SectionBlock> _globalSectionBlocks;
    public IEnumerable`1<string> HeaderLines { get; }
    public string VisualStudioVersionLineOpt { get; }
    public string MinimumVisualStudioVersionLineOpt { get; }
    public IEnumerable`1<ProjectBlock> ProjectBlocks { get; }
    public IEnumerable`1<SectionBlock> GlobalSectionBlocks { get; }
    public SolutionFile(IEnumerable`1<string> headerLines, string visualStudioVersionLineOpt, string minimumVisualStudioVersionLineOpt, IEnumerable`1<ProjectBlock> projectBlocks, IEnumerable`1<SectionBlock> globalSectionBlocks);
    public IEnumerable`1<string> get_HeaderLines();
    public string get_VisualStudioVersionLineOpt();
    public string get_MinimumVisualStudioVersionLineOpt();
    public IEnumerable`1<ProjectBlock> get_ProjectBlocks();
    public IEnumerable`1<SectionBlock> get_GlobalSectionBlocks();
    public string GetText();
    public static SolutionFile Parse(TextReader reader);
    private static IEnumerable`1<SectionBlock> ParseGlobal(TextReader reader);
    private static string GetNextNonEmptyLine(TextReader reader);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("256")]
internal class Microsoft.CodeAnalysis.Options.ExportOptionAttribute : ExportAttribute {
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Options.Providers.ExportedOptionProvider : object {
    private IEnumerable`1<Lazy`1<IOption>> _options;
    [ImportingConstructorAttribute]
public ExportedOptionProvider(IEnumerable`1<Lazy`1<IOption>> options);
    public sealed virtual IEnumerable`1<IOption> GetOptions();
}
internal class Microsoft.CodeAnalysis.Scripting.GacFileResolver : MetadataFileReferenceResolver {
    private ImmutableArray`1<ProcessorArchitecture> _architectures;
    private CultureInfo _preferredCulture;
    internal static GacFileResolver Default;
    public ImmutableArray`1<ProcessorArchitecture> Architectures { get; }
    public CultureInfo PreferredCulture { get; }
    public GacFileResolver(IEnumerable`1<string> assemblySearchPaths, string baseDirectory, ImmutableArray`1<ProcessorArchitecture> architectures, CultureInfo preferredCulture);
    private static GacFileResolver();
    public ImmutableArray`1<ProcessorArchitecture> get_Architectures();
    public CultureInfo get_PreferredCulture();
    public virtual string ResolveReference(string reference, string baseFilePath);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.SimpleAnalyzerAssemblyLoader : AbstractAnalyzerAssemblyLoader {
    protected virtual Assembly LoadCore(string fullPath);
}
internal static class Microsoft.CodeAnalysis.Text.EncodedStringText : object {
    private static int LargeObjectHeapLimitInChars;
    private static Encoding s_fallbackEncoding;
    private static Encoding s_defaultEncoding;
    private static EncodedStringText();
    private static Encoding GetDefaultEncoding();
    internal static SourceText Create(Stream stream, Encoding defaultEncoding, SourceHashAlgorithm checksumAlgorithm);
    internal static SourceText Decode(Stream data, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected);
    private static Byte[] TryGetByteArrayFromStream(Stream data);
    private static bool TryGetByteArrayFromMemoryStream(MemoryStream data, Byte[]& buffer);
    private static bool TryGetByteArrayFromFileStream(Stream stream, Byte[]& buffer);
}
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicProjectFileLoader : ProjectFileLoader {
    private HostWorkspaceServices _workspaceServices;
    internal HostLanguageServices LanguageServices { get; }
    public string Language { get; }
    internal VisualBasicProjectFileLoader(HostWorkspaceServices workspaceServices);
    internal HostLanguageServices get_LanguageServices();
    public virtual string get_Language();
    protected virtual ProjectFile CreateProjectFile(Project loadedProject);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.MSBuild.IProjectFileLoader", "Visual Basic", "Default")]
[SharedAttribute]
[ProjectFileExtensionAttribute("vbproj")]
[ProjectTypeGuidAttribute("F184B08F-C81C-45F6-A57F-5ABD9991F28F")]
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicProjectFileLoaderFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.CodeAnalysis.WorkspaceDesktopResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string InvalidAssemblyName { get; }
    internal static string InvalidCharactersInAssemblyName { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_InvalidAssemblyName();
    internal static string get_InvalidCharactersInAssemblyName();
}
internal class Roslyn.Utilities.FileKey : ValueType {
    public string FullPath;
    public DateTime Timestamp;
    public FileKey(string fullPath, DateTime timestamp);
    public static FileKey Create(string fullPath);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public sealed virtual bool Equals(FileKey other);
}
internal static class Roslyn.Utilities.FilePathUtilities : object {
    private static Char[] s_pathChars;
    private static FilePathUtilities();
    public static bool IsNestedPath(string basePath, string fullPath);
    public static string GetNestedPath(string baseDirectory, string fullPath);
    public static string GetRelativePath(string baseDirectory, string fullPath);
    internal static void RequireAbsolutePath(string path, string argumentName);
    public static bool PathsEqual(string path1, string path2);
    public static bool TryCombine(string path1, string path2, String& result);
}
internal static class Roslyn.Utilities.ReferencePathUtilities : object {
    public static bool TryGetReferenceFilePath(string filePath, String& referenceFilePath);
    public static bool TryFindXmlDocumentationFile(string assemblyFilePath, String& xmlDocumentationFilePath);
    private static IEnumerable`1<string> GetFrameworkPaths();
    [IteratorStateMachineAttribute("Roslyn.Utilities.ReferencePathUtilities/<GetReferencePaths>d__3")]
public static IEnumerable`1<string> GetReferencePaths();
    public static bool PartOfFrameworkOrReferencePaths(string filePath);
}
